ar
X
iv
:1
70
6.
07
83
1v
1 
 [
cs
.D
C
] 
 2
3 
Ju
n 
20
17
Synchronization in Dynamic Networks
Bernadette Charron-Bost1 Shlomo Moran2
1 École polytechnique, 91128 Palaiseau, France
2 Department of Computer Science, Technion, Haifa, Israel 32000
June 27, 2017
Abstract
In this article, we study algorithms for dynamic networks with asynchronous start, i.e.,
each node may start running the algorithm in a different round. Inactive nodes transmit only
heartbeats, which contain no information but can be detected by active nodes. We make no
assumption on the way the nodes are awakened, except that for each node u there is a time su
in which it is awakened and starts to run the algorithm. The identities of the nodes are not
mutually known, and the network size is unknown as well.
We present synchronization algorithms, which guarantee that after a finite number of rounds,
all nodes hold the same round number, which is incremented by one each round thereafter. We
study the time complexity and message size required for synchronization, and specifically for
simultaneous synchronization, in which all nodes synchronize their round numbers at exactly
the same round.
We show that there is a strong relation between the complexity of simultaneous synchroniza-
tion and the connectivity of the dynamic graphs: With high connectivity which guarantees that
messages can be broadcasted in a constant number of rounds, simultaneous synchronization by
all nodes can be obtained by a deterministic algorithm within a constant number of rounds,
and with messages of constant size. With a weaker connectivity, which only guarantees that
the broadcast time is proportional to the network size, our algorithms still achieve simultaneous
synchronization, but within linear time and long messages.
We also discuss how information on the network size and randomization may improve syn-
chronization algorithms, and show related impossibility results.
1 Introduction
We study distributed algorithms for dynamic networks over an arbitrary finite set of nodes V
that operate in synchronized rounds, communicate by broadcast messages, and in which the inter-
node connectivity may change each round of communication. The node identities, and even the
cardinality of the set V , are not mutually known.
In previous works it was typically assumed that algorithms in such dynamic networks are started
simultaneously by all nodes, and consequently that all nodes share the true round number (which
is incremented by one each round). In this paper we relax this assumption, and consider a model
in which round numbers are unknown to the nodes, and further that each node may start running
the algorithm in a different round. This relaxation is natural in environments with no central
control which monitors the nodes activities. To make our results more general, we do not make any
1
assumption on the way a node may become active and start running the algorithm, except that
eventually all nodes are active.
In this model, we study the basic question of synchronizing the network, in the sense that we
wish to ensure that eventually all nodes share the same round number. More specifically, we will
focus on the following two levels of synchronization: (a) implementing local round counters that
are eventually all equal, and (b) synchronizing the nodes themselves – and not only their round
counters – i.e., detecting the synchronization of the local round counters simultaneously.
Simultaneous synchronization (b) can be useful in various situations such as real-time processing
(where processors have to carry out some external actions simultaneously), distributed initiation
(to force nodes to begin some computation in unison), or distributed termination (to guarantee
that nodes complete their computation at the same round). It actually coincides with the Firing
Squad problem [2, 6, 7]: a node fires when it detects synchronization of the round counters. In the
context of clock synchronization, our results imply conditions under which a simultaneous phase
synchronization can be achieved in dynamic networks, given that the local clocks of the nodes have
the same frequency (see eg [15]).
We investigate these two levels of synchronization in the context of dynamic networks: the
communication topology may continuously and unpredictably change from one round to the next. In
particular, we do not assume any stability of the links. We examine various connectivity properties
that hold, not necessary round by round, but globally over finite periods of consecutive rounds [9].
Our synchronisation algorithms demonstrate a strong relation between the possibility and cost
of synchronizing a network, and the time required to broadcast a message from each node in the
network: perhaps a bit surprisingly, when broadcasts from all nodes are possible within a constant
number of rounds, a simultaneous synchronization can be achieved by a simple algorithm within
a constant number of rounds, using messages of constant size. When broadcast time is linear in
the network size n, we still achieve simultaneous synchronization in time which is proportional to
broadcast time (i.e., linear time), but with messages of size Ω(n log(n)). When broadcast from each
node is possible but there is no bound on the number of required rounds, simultaneous synchro-
nization is not possible, but the simple synchronization of round counters is still achievable within
finite time.
We then study models in which some bound N on the network size is known. We present
there few impossibility results and algorithms, including a randomized algorithm that assumes an
oblivious adversary and performs simultaneous synchronization in linear time with high probability,
but with messages which are considerably shorter than the ones used by our deterministic algorithm
for the same task.
Related work. Synchronization problems in distributed systems have been extensively studied,
but most of works assumed a fixed topology [16] or a complete graph and at most f faulty nodes [11],
i.e., a fixed core of at least n− f nodes.
Our work is closely related to the article by Kuhn et al. [10] on distributed computation in
dynamic networks: some of our results are based on the generalization to asynchronous starts of
their approach for counting the size of the network. In turn, our algorithms provide solutions to
distributed computations with asynchronous starts. In [17] a different model of networks with
asynchronous start is studied, in which inactive nodes do not submit any signal, and hence, unlike
in our model, their existence cannot be detected by active node - a property which is essential for
our results.
2
2 The Model
We consider a networked system with a fixed set of n nodes. Nodes have unique identifiers and the
set of the n identifiers is denoted by V . The identities of the nodes are not mutually known, and
the network size is unknown as well.
Each node is initially passive: it is part of the network, but sends only heartbeats – that we
call null messages – and does not change its state. Upon the receipt of a special signal, it becomes
active, sets up its local variables (with its initial state), and starts executing its code.
Execution proceeds in synchronized rounds: in a round t (t = 1, 2 . . . ), each node, be it active
or passive, attempts to send messages to all nodes, receives messages from some nodes, and finally
goes to a new state and proceeds to round t+1. The round number t is used for a reference, but is
unknown to the nodes. Synchronized rounds are communication closed in the sense that no node
receives messages in round t that are sent in a round different from t.
Communications that occur at round t are modeled by a directed graph G(t) = (V,Et) that
may change from round to round in dynamic networks [3]. We assume a self-loop at each node in
all the graphs G(t) since any node can communicate with itself instantaneously.
In each execution, every node u is assumed to receive a unique start signal at the beginning
of some round su. Each execution of the entire system is thus determined by the list (su)u∈V of
rounds at which nodes become active, by the collection of initial states, and by the sequence of
directed graphs (G(t))t∈N, that we call a dynamic graph.
The way start signals are generated is left arbitrary: they could be sent by an external oracle
(environment), or they could be generated endogenously as in the case of diffusive computations
initiated by a subset of nodes. Similarly, the sequence of directed graphs can be decided ahead of
time or, endogenously as in influence systems [5].
2.1 Paths and broken paths in a round interval
We now fix some notation and introduce some terminology that will be used throughout this paper.
First, let us fix an execution of an algorithm with the list of rounds (su)u∈V at which nodes become
active and the dynamic communication graph (G(t))t∈N.
If xu is a local variable of node u, then xu(t) denotes the value of xu at the beginning of round t.
Thus xu(t) is undefined for t < su. We let G
∗(t) = (V,E∗t ) denote the directed graph of edges that
transmit non-null messages at round t: (u, v) ∈ E∗t if and only if it is an edge of G(t) and u is active
at round t. We denote the sets of u’s incoming neighbors (in-neighbors for short) in the directed
graphs G(t) and G∗(t) by Inu(t) and In
∗
u(t), respectively.
We recall that the product of two directed graphs G = (V,E) and H = (V,E′), denoted G ◦H,
is the directed graph with the set of nodes V and with an edge (u, v) if there exists w ∈ V such
that (u,w) ∈ E and (w, v) ∈ E′. For t′ > t > 1, we let G(t : t′) = G(t) ◦G(t+ 1) ◦ · · · ◦G(t′), and
by convention, G(t : t) = G(t). Similarly, G∗(t : t′) = G∗(t) ◦G∗(t+ 1) ◦ · · · ◦G∗(t′).
Let Inu(t : t
′) and In∗u(t : t
′) denote the sets of u’s in-neighbors in G(t : t′) and in G∗(t : t′),
respectively. A directed edge (v, u) of G(t : t′) corresponds to a non-empty set of dynamic paths of
the form P = (v0 = v, v1, . . . , vm = u), where m = t
′ − t+ 1 and (vk, vk+1) is an edge of G(t + k)
for each k = 0, . . . ,m− 1.
We will say that the dynamic path P is broken if one of the edges of P carries a null message,
i.e., t+ k > svk for some k ∈ {0, . . . ,m− 1}. For brevity, we will use the terminology of v∼u path
and v∼u broken path in the round interval [t, t′].
3
2.2 A hierarchy of synchronization problems
Let A be an algorithm with an integer variable ru for each node u, which are aimed at simulating
synchronous round counters.
Synchronization: The algorithm A achieves synchronization if in each execution of A with the
start signals (su)u∈V , from some round tsynch > maxu∈V (su) onward, the ru counters are
incremented by 1 in every round and are all equal, i.e., for every t > tsynch,
1. ru(t+ 1) = ru(t) + 1
2. ∀u, v ∈ V, ru(t) = rv(t).
In the following each node u is equipped with an additional boolean variable synchu initialized to
false at round su.
Synchronization detection: The algorithm A achieves synchronization detection if it achieves
synchronization, and in addition it guarantees that each node eventually detects that the
network is synchronized, i.e.,
3. ∀u ∈ V, synchu(t) = true⇒ t > tsynch
4. ∀u ∈ V, ∃tu ∈ N, ∀t > tu, synchu(t) = true.
Simultaneous synchronization detection: The algorithm A achieves simultaneous synchro-
nization detection if all nodes detect synchronization simultaneously, i.e.,
5. ∀u, v ∈ V, ∀t > max{su, sv}, synchu(t) = synchv(t).
Note that the latter condition of simultaneity actually corresponds to the classical Firing Squad
problem [6, 2, 7] (i.e., all nodes can fire when the synch variables are set to true).
2.3 Completeness and connectivity of dynamic graphs
In this paper we consider the following connectivity conditions in dynamic graphs.
Definition 1. Let T be a positive integer. We say that the dynamic graph (G(t))t>1 is T -complete
if for every t > 1, the graph G(t : t+ T − 1) is complete.
Informally, T -completeness of a dynamic graph means that a message initiated by any node u
in any round t can be broadcasted to all other nodes within T rounds.
We next define dynamic graphs which enable broadcasts in linear time. For that, we first
introduce the concept of in-connectivity for directed graphs.
Definition 2. Let G = (V,E) be a directed graph with at least two nodes and let c < |V | be a
positive integer. We say that G is c in-connected if for any non-null subset S, the following holds:
|Γin(S) \ S| > min(c, |S|)
where Γin(S) denotes the set of in-neighbors of S in G, and S = V \ S.
4
Note that G is |V |−1 in-connected iff it is complete and that it is 1 in-connected iff it is strongly
connected.
One can define in an analogue way the c out-connectivity of a directed graph. The following
shows that these definitions are equivalent.
Proposition 3. Let G be a directed graph. For each positive integer c it holds that G is c in-
connected iff it is c out-connected
Proof. We will prove that if G is c in-connected then it is also c out-connected. The proof of the
other direction is essentially identical.
Assume for contradiction that G is c in-connected but not c out-connected. Then there is a
proper subset S of V s.t. |Γout(S) \ S| = b < c, and |S| > b.
Let X = Γout(S) \ S, and let R = S \ X. Since |X| = b and |S| > b, R is not empty. By
definition of R, there is no edge from a node in S to a node in R, meaning that Γin(R) \ R ⊆ X.
Hence |Γin(R)\R| 6 b. Since R = X∪S contains b+ |S| > b nodes, this contradicts the assumption
that G is c in-connected.
Definition 4. Let c, T be two positive integers. We say that the dynamic graph (G(t))t>1 is (c, T )
in-connected if for every t > 0, the graph G(t : t+ T − 1) is c in-connected.
The (c, T ) in-connectivity implies that a message initiated by any node u in any round t can
be broadcasted to all other nodes within ⌈T
c
n⌉ rounds (for c = T = 1, this is implied by a basic
inequality on the length of message chains – e.g., Lemma 3.2 in [10] – and the generalization for
arbitrary c and T is straightforward).
Finally, we present our weakest connectivity assumption which can be seen as ∞-completeness:
a message initiated by a node u in round t can be broadcasted to all other nodes, but the time
required for this broadcasting is unbounded.
Definition 5. A dynamic graph is said to be eventually strongly connected if for every t > 1, there
exists t′ > t such that the graph G(t : t′) is strongly connected.
In the following we will present algorithms which achieve synchronization in the above models.
In the first two models, simultaneous synchronization detection is achieved within constant and
linear broadcast time, respectively, but with substantially different messages sizes. We will start
with the last, weakest model.
3 Synchronization with Unbounded Broadcast Time
In this section, we show how the nodes in any dynamic graph that is eventually strongly connected
(and hence guarantees broadcasting in finite but unbounded number of rounds) can eventually
synchronize despite asynchronous starts. The synchronization algorithm (Algorithm 1) is simple
and does not use identifiers: nodes may be assumed to be anonymous and to have computation
and storage capabilities that do not grow with the network size [8].
First let us introduce one notation for the pseudo-codes of all our algorithms: we use M∗u to
denote the multiset of non-null messages received by u in the current round. Thus M∗u at round t
is the multiset of messages sent to u by the nodes in In∗u(t). If non-null messages are vectors of
same size, then M∗u
(i) denotes the multiset of the i-th entries of the messages in M∗u .
5
Algorithm 1 Algorithm for synchronization
Initialization:
1: ru ∈ N, initially 0
In each round t do:
2: send 〈ru〉 to all processes and receive one message from each in-neighbor
3: if at least one received message is null then
4: ru ← 0
5: else
6: ru ← 1 + minr∈M∗
u
(r)
7: end if
Theorem 6. Algorithm 1 achieves synchronization in any dynamic graph that is eventually strongly
connected.
Proof. For any round t > smax = maxu∈V (su), we let
W (t) =
{
u ∈ V : ru(t) = min
v∈V
(
rv(t)
)}
.
Because of self-loops, we have W (t) ⊆ W (t + 1). Moreover, if W (t) has an outgoing edge in the
directed graph G(t), then W (t) 6= W (t + 1). Eventual connectivity of the dynamic graph ensures
that from some round onward, we have W (t) = V , which implies the theorem.
We now state two useful lemmas about the way the local round counters ru’s evolve in dynamic
graphs.
Lemma 7. Assume that t < t′ and su 6 t
′. Then ru(t
′) is defined and:
1. If there exists a broken path ending at u in the round interval [t, t′−1], then ru(t
′) 6 t′− t−1.
2. Otherwise, for every v ∈ Inu(t : t
′− 1) it holds that rv(t) is defined and ru(t
′) 6 rv(t)+ t
′− t.
Proof. 1. Let P = (vt = v, vt+1, . . . , vt′ = u) be the assumed broken path, and let (vi−1, vi), be
the last edge in P which carries a null message (t+ 1 6 i 6 t′). Then vi is active at roundi,
and by line 4 in Algorithm 1, rvi(i) = 0 . By easy induction, for k = i + 1, . . . , t
′, it holds
that rvk(k) 6 k − i 6 k − t− 1. Substituting k = t
′, we obtain that ru(t
′) 6 t′ − t− 1.
2. If there is no such broken path, then for each v∼u path P as above, no edge in P carries a
null message, i.e., node vk is active at round k for each k = t, . . . , t
′ − 1.
By line 6 in Algorithm 1 and a straightforward induction, for k = t+ 1, . . . , t′, it holds that
rvk(k) 6 rv(t) + k − t. Substituting k = t
′, we obtain that ru(t
′) 6 rv(t) + t
′ − t.
Lemma 8. For every node u and at every round t > smax = maxv∈V (sv), we have ru(t) > t−smax.
Moreover, if t > smax + 1 and Inu(smax : t − 1) contains a node v such that sv = smax, then
ru(t) = t− smax.
Proof. By the definition of smax, for each node u we have ru(smax) > 0, and an easy induction on
t > smax shows that ru(t) > t− smax.
If Inu(smax : t−1) contains a node v such that sv = smax, then there is a v∼u path in the round
interval [smax, t − 1]. Since all nodes are active on round smax onward, only non-null messages
are sent and all the v∼u paths in the round interval [smax, t − 1] are non broken. The opposite
inequality ru(t) 6 t− smax now follows from Lemma 7.1 and rv
(
smax
)
= 0.
6
4 Simultaneous Synchronization Detection with Constant Time
Broadcasting
We now show that the synchronization of the round counters can be detected in any T -complete
dynamic graph. Synchronization detection can be achieved simultaneously by all the nodes in O(T )
time using only O(log(T )) bits per message.
Algorithm 2 Simultaneous synchronization detection with T -completeness
Initialization:
1: ru ∈ N, initially 0
2: synchu ∈ {true, false}, initially false
In each round t do:
3: send 〈ru〉 to all processes and receive one message from each in-neighbor
4: if at least one received message is null then
5: ru ← 0
6: else
7: ru ← 1 + minr∈M∗
u
(r)
8: end if
9: if ru > T then
10: synchu ← true
11: end if
Theorem 9. Algorithm 2 achieves Simultaneous Synchronization in any execution on a T -complete
dynamic graph. Specifically, all nodes detect the synchronization of the ru counters exactly T rounds
after all nodes have become active.
Proof. First, observe that by the first claim in Lemma 8, the condition in line 9, namely ru > T ,
eventually holds at each node u. Moreover, ru may increase by at most 1 in every round, and thus
hence there exists at least one round at which ru is equal to T .
Let t0 be the first round at which some node u sets its variable ru to T . Then ru(t0 + 1) = T
and
∀v ∈ V, rv(t0 + 1) 6 T . (1)
Note also that t0 > ru(t0), and hence t0 − T + 1 > 1.
By T -completeness, Inu(t0−T+1 : t0) = V . Since ru(t0+1) = T , Lemma 7.1 implies that there is
no broken path ending at node u in the interval [t0−T+1, t0]. Hence, smax = maxv∈V (sv) 6 t0−T+1
and In∗u(t0 − T + 1 : t0) = Inu(t0 − T + 1 : t0) = V .
In particular, In∗u(t0 − T + 1 : t0) contains the latest woken-up nodes. Hence, by Lemma 8,
T = ru(t0 + 1) = t0 − smax + 1 and for every node v ∈ V , rv(t0 + 1) > ru(t0 + 1) = T . Since by
(1) above rv(t0 + 1) 6 T , we get that rv(t0 + 1) = T for all v ∈ V . By the definition of t0, we also
have that rv(t
′) < T for t′ 6 t0 and for all v ∈ V . Thus all nodes set their local counters to T at
round t0 for the first time.
Let the synchronization time be the number of rounds from the time the last node is waked up
till (simultaneous) synchronization is achieved. Then the synchronization time of any execution of
Algorithm 2 is in O(T ), and it uses messages of size O(log T ).
7
5 Simultaneous Synchronization Detection with Linear Time Broad-
casting
We now present Algorithm 3 for the simultaneous detection of the counters ru in dynamic graphs
that are not T -complete, but still enjoy good connectivity, namely (c, T ) in-connectivity, which as
mentioned earlier enables broadcasting in time which is linear in the number of nodes. As opposed
to the previous algorithm, Algorithm 3 requires unique node identifiers and long messages. Indeed,
each node u maintains a variable HOu that contains the identifiers of all the active nodes of which
u has heard of since it became active, and broadcasts HOu in each round.
Algorithm 3 Simultaneous synchronization detection with in-connectivity
Initialization:
1: ru ∈ N, initially 0
2: synchu ∈ {true, false}, initially false
3: HOu ⊆ V , initially {u}
In each round t do:
4: send 〈ru, HOu〉 to all processes and receive one message from each in-neighbor
5: if at least one received message is null then
6: ru ← 0
7: else
8: ru ← 1 + minr∈M∗
u
(1)(r)
9: end if
10: HOu ← ∪HO∈M∗
u
(2)HO
11: if |HOu| 6
⌈
c
T
(ru + 1)
⌉
− c then
12: synchu ← true
13: end if
The correctness proof of the algorithm relies on the following inequality, which can be seen as a
generalization of a basic inequality established for global round numbers t (e.g., Lemma 3.2 of [10])
to local round counters ru.
Lemma 10. In each execution of Algorithm 3 in a (c, T ) in-connected dynamic graph, for each
node u and each round t > su, it holds that
|HOu(t)| > min
(
(1− c) +
c
T
(ru(t) + 1) , n
)
. (2)
Proof. For t = su, we have ru(t) = 0 and the proof is immediate.
Suppose now that t > su + 1, and let q and r two nonnegative integers such that t = qT + r
with 1 6 r 6 T . By induction, we construct a sequence of q+1 sets of nodes S0, S1, . . . , as follows:
1. S0 = {u}.
2. Suppose that S0, . . . , Si are defined and i < q. We let Hi+1 = G
(
t − (i + 1)T : t − iT − 1
)
.
We distinguish three cases.
(a) Hi+1 contains no edge (w, v) such that w 6∈ Si and v ∈ Si. Then the construction stops.
(b) Hi+1 contains an edge (w, v) such that w 6∈ Si and v ∈ Si, and that corresponds to a
w∼v broken path in the round interval [t− (i+ 1)T, t− iT − 1]. Then the construction
stops.
8
(c) Otherwise, we let Si+1 = Inu(t− (i+ 1)T : t).
Let Sk denote the last set in the sequence.
A straightforward induction shows that for each node v ∈ Si there is a v∼u path in the round
interval [t− iT, t] which is not broken.
Using the (c, T ) connectivity of G, an easy induction shows that the cardinality of each set Si
is at least c i + 1, except for the case when the construction is terminated by (a) above, in which
case |Sk| may be smaller than ck + 1.
Similarly, by lines (3) and (10) of the algorithm and by the conditions (b) and (c) above, an easy
induction shows that HOu(t) contains every set Si for 0 6 i 6 k, and in particular Sk ⊆ HOu(t).
Hence if the construction is terminated by (b), then the cardinality of HOu(t) is at least ck + 1.
We now distinguish the following three cases:
Construction terminated by (a): By the (c, T ) in-connectivity of the dynamic graph, this im-
plies that Sk = V . It follows that HOu(t) = V and Lemma 10 trivially follows.
Construction terminated by (b): We first observe that the assumed w∼v broken path in the
round interval
[
t− (k+1)T, t−kT −1
]
can be extended to a w∼u broken path in the interval
[
t − (k + 1)T, t
]
. This implies by Lemma 7.1 that ru(t) 6 (k + 1)T − 1 or equivalently that
k > ru(t)+1
T
− 1. Thus we get
|HOu(t)| > ck + 1 > c
(
ru(t) + 1
T
− 1
)
+ 1 = (1− c) +
c
T
(ru(t) + 1) .
Construction terminated by k = q : Thus we get |HOu(t)| > cq + 1. As an immediate con-
sequence of Lemma 7.1 and 7.2, we have ru(t) 6 t − 1. With r 6 T , it follows that
ru(t) 6 T (q + 1)− 1, and
|HOu(t)| > (1− c) +
c
T
(ru(t) + 1)
which also gives Lemma 10 in this last case.
Theorem 11. In any (c, T ) in-connected dynamic graph, all nodes in Algorithm 3 achieve simul-
taneous synchronization detection. Synchronization is detected in less than
⌈
T
c
(n− 1)
⌉
+T rounds
after all nodes have become active.
Proof. First, observe that by the first claim in Lemma 8 and the fact that the cardinality of each
set HOu is at most n, the condition in line 11 eventually holds at each node u. Moreover, we easily
check that at each round t > su, it holds that
HOu(t+ 1) ⊆
⋃
s>su
In∗u(s : t) . (3)
Let t0 be the first round at which the condition in line 11 holds at some node, and let u denote
one node such that
|HOu(t0 + 1)| 6
⌈ c
T
(ru(t0 + 1) + 1)
⌉
− c . (4)
9
From Lemma 10, we deduce that HOu(t0 + 1) = V . In particular, HOu(t0 + 1) contains the latest
woken-up nodes. Let v denote one such node, ie sv = smax. By (3), there is a v∼u non broken
path in some round interval [s, t0] with s > su. It follows that s > sv. Thereby t0 > smax and
v ∈ In∗u(smax : t0). This implies, by Lemma 8, that
ru(t0 + 1) = rv(t0 + 1) = t0 + 1− smax = min
w∈V
rw(t0 + 1) .
Using Lemma 10=10 again we get that for all w ∈ V , Hw(t0 + 1) = V . Therefore the inequality
(4) holds for all nodes in round t0 + 1, and by the definition of t0 this is the first round in which
this inequality holds for all nodes.
Considering that c and T are constants, the synchronization time of Algorithm 3 is O(n), and
it uses messages of size O(n log n).
A close examination of the proof of Theorem 11, shows that each node actually computes the set
V , and so its cardinality. In other words, Algorithm 3 solves the problem of counting the network
size despite asynchronous starts in any (c, T ) in-connected dynamic graph, and in particular in any
continuously strongly connected dynamic graph.
This should be compared with the impossibility result established by Wattenhofer [17], which
shows that if inactive nodes do not transmit any signal, then counting is impossible with asyn-
chronous start. In other words, in the latter network model passive nodes are not considered as
part of the network: the set of nodes in the network is thus time-varying while we assume a fixed
set V of nodes.
6 Synchronization with Bounds on Network Size
In this section, we show that knowledge of bounds on the network size can sometimes improve our
synchronization algorithms.
6.1 Simultaneous Synchronization Detection with linear broadcast time and
short messages
We now show that knowledge on network size can be used for reducing the message size required
for linear-time simultaneous synchronization in (c, T ) in-connected dynamic networks. For the sake
of simplicity, we assume c = T = 1 , i.e., dynamic graphs are continuously strongly connected, but
all the results can be obviously extended to the general case of in-connectivity.
First, observe that any connected dynamic graph with n nodes is (n − 1)-complete. Thus
one immediate spinoff of Theorem 9 is the following corollary, which provides a solution to the
simultaneous synchronization detection problem in strongly connected dynamic graphs when an
upper bound N on the network size is known by all nodes.
Corollary 12. If nodes have an upper bound N of the network size, simultaneous synchronization
detection can be achieved in any continuously strongly connected dynamic graph in N rounds after
all nodes have become active using only O(log(N)) bits per message.
When N is significantly larger than the network size n, this solution to simultaneous synchro-
nization detection may use much more than n rounds. However, Lemma 10 enables us to extend the
10
randomized algorithm for approximate counting presented in [10, 14] to the case of asynchronous
starts, by substituting the local round counters for the round numbers. As we shall show below,
this yields a randomized algorithm which has only a loose bound N on the network size n, sends
short messages, and with high probability enables all nodes to achieve simultaneous synchronization
detection within O(n) rounds. For this algorithm, it is assumed that the dynamic graph, and the
wakeup times sv, are managed by an oblivious adversary, which has no access to the outcomes of
the coin tosses made by the algorithm.
The algorithm, denoted AN,η, depends on the two parameters N and η where N is an upper
bound on the network size and η is any real number in [ 0, 1/2 [. It works as follows: upon becoming
active, each node u generates ℓ independent random numbers Y
(1)
u , . . . , Y
(ℓ)
u , where the distribution
of each Y
(i)
u is exponential with rate 1. At each round, any active node u first broadcasts the
smallest value of the Y
(i)
v ’s it has heard of for each index i, and then computes from the minimum
values it received so far an estimation nu of the cardinality of the set of nodes it heard of. It detects
the synchronization of the round counters when its round counter ru is sufficiently larger than nu.
The analysis of the algorithm AN,η relies on the following lemma in [12] which is is an application
of the Cramér-Chernoff method (see for instance [1], sections 2.2 and 2.4).
Lemma 13. Let I be a finite set of ℓ-tuples of independent exponential variables all with rate 1:
I =
{(
Y
(1)
1 , . . . , Y
(ℓ)
1
)
, . . . ,
(
Y
(1)
|I| , . . . , Y
(ℓ)
|I|
)}
, and let W := ℓ∑ℓ
i=1 min16j6|I| Y
(i)
j
.
For any ε ∈ [0, 1/2], we have
Pr (|W − |I| | > 2 ε|I|/3) 6 2 exp
(
−ε2ℓ/27
)
. (5)
It follows that for a sufficiently large value of ℓ, the value of nu at the end of round t provides
with high probability a good approximation of the number of active nodes that u has heard of so
far. Then by Lemma 10, it follows that with high probability, if nu < (1− ε)ru then all nodes are
active and node u has heard of all. As for Algorithm 3, we may conclude that with high probability,
all the nodes detect synchronization at the same round t0 and make no false detection.
We fix the precision parameter of the randomized approximate counting algorithm in [10] to
ε = 1/3, and choose ℓ =
⌈
243.(ln 4N2 − ln η)
⌉
to guarantee a final probability of at least 1 − η
for successful executions (cf. below). Node u detects synchronization when nu < 2ru/3 (see
Algorithm 4).
One key point of the randomized approximate counting algorithm in [10] lies in the fact that
the algorithm still works when the random variables Y
(i)
u are initialized with rounded and range-
restricted approximations of the initial random numbers of the above scheme. More precisely, if we
round down each Y
(i)
u to the next smaller integer power of 13/12, then the probability that nv is a
good approximation of the number of nodes v have heard of (inequality (10) below) still holds. By
the definition of the exponential distribution, it is not hard to see that the random variables Y
(i)
u
are all within the range [η/(4ℓN), ln(4ℓN/η)] with high probability, namely
Pr
[
∀u ∈ V, ∀i, Y (i)u ∈ [η/(4ℓN), ln(4ℓN/η)]
]
> 1− η/2 , (6)
The two above transformations of rounding and range-restricting can then be combined and yield
a collection of random variables denoted Y
(i)
u . The correctness proof of the original algorithm
with the exponential random variables Y
(i)
u is still valid when substituting Y
(i)
u for Y
(i)
u except an
11
additional probability of at most η/2 of unsuccessful executions in which the range (6) is violated.
In addition, the number of distinct variables Y
(i)
u in that range is O(log(Nη
−1), hence each such
variable can be represented using O (log log(N/η)) bits.
The reader is referred to [14] for more details on the above scheme developed for the model in
which all nodes start at round 1 and hold the true round numbers. Below, we only present the
points in the correctness proof of AN,η that are specific to the round counters ru.
Algorithm 4 The randomized algorithm AN,η
Initialization:
1: ru ∈ N, initially 0
2: synchu ∈ {true, false}, initially false
3: Y u =
(
Y
(1)
u , . . . , Y
(ℓ)
u
)
∈ Rℓ, initially ℓ =
⌈
243.(ln 4N2 − ln η)
⌉
rounded and range-restricted approxi-
mations of independent random numbers with exponential distribution of rate 1.
4: nu ∈ N, initially 0
In each round t do:
5: send 〈ru, Y u〉 to all processes and receive one message from each in-neighbor
6: if at least one received message is null then
7: ru ← 0
8: else
9: ru ← 1 + minr∈M∗
u
(1)(r)
10: end if
11: for i = 1, . . . , ℓ do
12: Y
(i)
u ← minY (i)∈M∗
u
(i+1)
(
Y
(i)
)
13: end for
14: nu ← ℓ/
∑ℓ
i=1 Y
(i)
u
15: if nu < 2 ru/3 then
16: synchu ← true
17: end if
Theorem 14. In any execution of Algorithm AN,η on a dynamic graph that is continuously strongly
connected with at most N nodes, with probability at least 1− η all nodes detect the synchronization
of the ru counters simultaneously in less than 2n rounds after all nodes have become active. The
algorithm uses messages of size O (log(N/η). log log(N/η)).
Proof. We fix any real number η ∈] 0, 1/2 ]. For any node v and at each round t > sv, let νv(t)
denote the number of nodes that v has heard of at the end of round t.1
For a continuously strongly connected graph, Lemma 10 then reads:
|νv(t)| > min (rv(t+ 1) + 1, n) . (7)
Let t0 be the first round at which some round counter in the network is set to n (the true network
size). Using (7), we deduce that all nodes are active at round t0 and that every node has heard of
all at the end of round t0, i.e., t0 > smax and νv(t0) = n. Then the same argument as in the proof
of Theorem 11 shows that all nodes have synchronized at the end of round t0, namely
∀v ∈ V, ∀t > t0 + 1, rv(t) = t− smax . (8)
1Formally, v has heard of w at the end of round t if for some s 6 t, there is a path (w = vs, . . . , vt = v) where
(vi, vi+1) ∈ G(i) and both vi and vi+1 are active in round i, i = s, . . . , t− 1.
12
In particular, we have t0 = n− 1 + smax.
Since νv(t0) = n, every node v computes the same estimate ñ of n at the end of round t0 in its
variable nv and keeps this value for nv at all later rounds:
∀v ∈ V, ∀t > t0 + 1, νv(t) = ñ . (9)
It follows that if the condition at line 15 holds at some node in round t > t0, then it holds at all
nodes in every round t′ > t.
By Lemma 13, for every node v ∈ V and every round t, t0 > t > sv, we have
Pr
[
|nv(t+ 1)− νv(t) | > 2 νv(t)/9
]
6 2 exp (−ℓ/243) . (10)
Using (7) and the inequality rv(t0) 6 n− 1, we get that at each round t, tu > t > sv, the following
implication holds:
|nv(t+ 1)− νv(t) | 6 2 νv(t)/9 ⇒ nv(t+ 1) > 2 rv(t+ 1)/3 .
Now observe that each node v makes a true update to nv at line 14 of the algorithm at most
n − 1 times (when the set of nodes it heard of strictly increases). This implies, by the union
bound, that the probability that node v does not detect synchronization by round t0 is at least
1−2(n−1) exp (−ℓ/243). Using the union bound again and the upper bound N > n, we obtain that
the probability that no node detects synchronization by round t0 when using the random variables
Y
(i)
u in the algorithm is thus at least 1− 2N(N − 1) exp (−ℓ/243).
Let θ denote the first round at which a node detects synchronization, i.e., the condition at line 15
holds for the first time at round θ. The above argument shows that the probability that θ > t0 is
at least 1− 2N(N − 1) exp (−ℓ/243).
Inequality (10) at round t = t0 shows that with probability at least 1 − 2 exp (−ℓ/243), it holds
that
| ñ− n | 6 2n/9 (11)
which implies that ñ 6 11n/9. Moreover equations (8) and (9) for t = 2n+ smax > t0 + 1 write:
∀v ∈ V, rv(2n + smax) = 2n and νv(2n + smax) = ñ .
It follows that the condition at line 15 holds at round 2n + smax, or equivalently θ 6 2n + smax,
with probability at least 1− 2 exp (−ℓ/243).
In conclusion, with probability at least 1− 2N2 exp (−ℓ/243) > 1− η/2, it holds that
n+ smax 6 θ 6 2n+ smax .
As explained above, using the approximated variables Y
(i)
u instead of Y
(i)
u results in an additional
probability of at most η/2 of unsuccessful executions. This shows that with probability at least
1− η, all the nodes correctly and simultaneously detect synchronization of their round counters by
round 2n+ smax.
The terminating variant of AN,η in which nodes stop executing their code after they have
detected synchronization (line 16) thus achieves simultaneous synchronization detection with high
probability: running time is in O(n) and messages are of size O (log(N/η). log log(N/η)).
13
6.2 Synchronization detection with unbounded broadcast time
Theorem 6 demonstrates that nodes can eventually synchronize in any dynamic graph that is
eventually strongly connected. In this section we show that this synchronization can be detected
only if nodes know the exact network size n.
We first show that synchronization cannot be detected in such dynamic graphs even if it is given
that the network size is either n or n+1, for some fixed integer n which is known to the algorithm.
Theorem 15. Synchronization of the ru counters cannot be detected under the sole assumption of
eventual connectivity. This result holds even if it is given that the network size is either n or n+1,
for some (fixed) n.
Sketch of proof. For the sake of contradiction, suppose that there is an algorithm A which detects
synchronization in every execution on an eventually connected dynamic graph with n or n + 1
nodes.
Let V be a set of cardinality n + 1, let u be a node in V , and let W = V \ {u}. Then by our
assumption, A achieves synchronization detection in the execution E over the dynamic graph G in
which each G(t) is KW , the complete directed graph over W , and all nodes in W are active from
the first round. Hence, there is some t0 such that every node in W has detected synchronization
by round t0.
Now consider an execution E ′ over a dynamic graph H in which H(t) = KuW for 1 6 t 6 t0
where KuW denotes the directed graph over V with the same edges as KW , and H(t) = KV , the
complete directed graph over V , for t > t0. Assume further that in E
′, sv = 1 for each v ∈ W ,
and su = t0 + 1. Then since nodes in W cannot distinguish between E and E
′ during the first t0
rounds, they all incorrectly detect synchronization by round t0 in E
′, i.e., before u became active.
The proof is completed by noting that H is eventually strongly connected over V .
Interestingly, the latter impossibility result does not hold anymore when the exact size of the
network is known. Indeed, thanks to its knowledge of n, each node u can detect that all nodes are
active. By Lemma 8, its round counter ru is then minimal amongst all the local round counters,
in which case u is considered as ready to synchronize. Then u can determine when nodes in the
network are all ready, that is to say all round counters are minimal, and thus are equal.
For that, each node u maintains two sets of node identifiers, namely HOu which is the set of
active nodes u has heard of so far, and OKu which is the set of nodes that u knows to be ready to
synchronize. The corresponding pseudo-code is given in Algorithm 5.
We now show that synchronization cannot be detected simultaneously by all nodes of an eventu-
ally strongly connected network, demonstrating that with respect to synchronization, simultaneity
is harder than detection in this network model.
Theorem 16. Simultaneous synchronization detection is impossible in eventually strongly con-
nected dynamic graphs, even if all nodes know the size of the network.
Sketch of proof. By contradiction, suppose that there is an algorithm A that achieves simultaneous
synchronization detection in any eventually strongly connected dynamic graph.
Let S denote the star directed graph centered at u, and let ST be its transpose. Let I = (V,EI)
the directed graph with only a self-loop at each node, i.e., EI = {(v, v) : v ∈ V }.
We consider the execution of A with start signals all received in the first round, and the al-
ternating sequence of directed graphs G = S, ST, S, ST, . . . . The dynamic graph G is eventually
strongly connected, and thus all nodes detect synchronization at the same round tF .
14
Algorithm 5 Synchronization detection with eventual strong connectivity
Initialization:
1: ru ∈ N, initially 0
2: synchu ∈ {true, false}, initially false
3: HOu ⊆ V , initially {p}
4: OKu ⊆ V , initially ∅
In each round t do:
5: send 〈ru, HOu, OKu〉 to all nodes and receive one message from each in-neighbor
6: if at least one received message is null then
7: ru ← 0
8: else
9: ru ← 1 + minr∈M∗
u
(1)(r)
10: end if
11: HOu ← ∪HO∈M∗
u
(2)HO
12: OKu ← ∪OK∈M∗
u
(3)OK
13: if |HOu| = n then
14: OKu ← OKu ∪ {u}
15: end if
16: if |OKu| = n then
17: synchu ← true
18: end if
Now assume that G(tF ) = S
T (the case G(tF ) = S is similar). From the viewpoint of any
node v 6= u, G is indistinguishable up to round tF from the dynamic graph G
1 that is similar to
G except at round tF where G
1(tF ) = I. Hence all nodes other than u also detect synchronization
at roundtF with the dynamic graph G
1. The same holds for nodeu since the dynamic graph G1 is
eventually strongly connected.
By repeating this argument tF times, we show that all nodes detect synchronization at round tF
in the execution of A with start signals all received in the first round, and the dynamic graph
GtF = I, . . . , I, S, ST , S, ST , . . . .
From the viewpoint of any node v 6= u, the latter execution is indistinguishable up to round tF
from the execution with the same dynamic graph GtF and start signals all received in the first
round except the one received by u at some round su > tF . In this execution, synchronization is
detected earlier than u’s start, a contradiction.
7 Conclusion
In this paper, we defined a model of distributed algorithms in which nodes do not start the algorithm
simultaneously. We studied algorithms in this model which synchronize the round counters of the
nodes in a dynamic network, where the network topology may change each round, there is no
information on the network size, and node identities are not mutually known. As opposed to many
models of dynamic networks developed for counting or consensus, links are not supposed to be
bidirectional, and we assume no stability of the network in time.
We presented several algorithms whose messages size and time complexity highly depend on
the connectivity of the topology.
15
We also showed that with only eventual connectivity assumptions, synchronization detection is
impossible unless nodes know the exact size of the network.
Possible extensions of this work involve variations of the model of computation. For instance,
it is interesting to know in which other models of connectivity, synchronization can be detected.
It is also of interest to determine whether simultaneous synchronization detection is possible in
an anonymous dynamic network where nodes have limited storage capabilities and communicate
through finite bandwith channels as in [8]. Our adaptation of the randomized algorithm of [10]
provides an efficient Monte Carlo solution for this problem, in the case of continuously strongly
connected networks.
This raises another question concerning the role of leaders in a dynamic network: does the exis-
tence of a leader in an anonymous network may help for synchronization detection? Combined with
our strategy for synchronization detection, the Metropolis method (see [13]) yields a deterministic
algorithm that achieves simultaneous synchronization detection in O(n3) rounds and that works in
any anonymous dynamic network with a leader and a bidirectional connected topology. Unfortu-
nately this algorithm uses messages of infinite size (nodes send real numbers) and do not tolerate
rounding. The existence of a deterministic algorithm for synchronization detection in polynomial
time, with anonymous nodes and bounded bandwith capacity is still an open problem.
Also of interest are dynamic networks which enable the solution of the consensus problem with
asynchronous start. This problem could shed light on the relation between consensus algorithms
and kernel agreement algorithms of [4].
References
[1] Stéphane Boucheron, Gábor Lugosi, and Pascal Massart. Concentration inequalities. Oxford
University Press, Oxford, 2013. A nonasymptotic theory of independence.
[2] James E. Burns and Nancy Lynch. The byzantine firing squad problem. Advances in Computing
Research, 4:147–161, 1987.
[3] Arnaud Casteigts, Paola Flocchini, Walter Quattrociocchi, and Nicola Santoro. Time-varying
graphs and dynamic networks. In Hannes Frey, Xu Li, and Stefan Rührup, editors, ADHOC-
NOW, volume 6811 of Lecture Notes in Computer Science, pages 346–359. Springer, 2011.
[4] Bernadette Charron-Bost and André Schiper. The Heard-Of model: computing in distributed
systems with benign faults. Distributed Computing, 22(1):49–71, 2009.
[5] Bernard Chazelle. Natural algorithms and influence systems. Communications of the ACM,
55(12):101–110, 2012.
[6] Brian A. Coan, Danny Dolev, Cynthia Dwork, and Larry Stockmeyer. The distributed firing
squad problem. In ACM Symposium on Theory of Computing Conference, STOC’85, pages
335–345, 1985.
[7] Brian A. Coan and Cynthia Dwork. Simultaneity is harder than agreement. Information and
Computation, 91(2):205–231, 1991.
[8] Julien M. Hendrickx, Alex Olshevsky, and John N. Tsitsiklis. Distributed anonymous discrete
function computation. IEEE Transactions on Automatic Control, 56(10):2276–2289, 2011.
16
[9] David Kempe, Jon M. Kleinberg, and Amit Kumar. Connectivity and inference problems for
temporal networks. Journal of Computer and System Sciences, 64(4):820–842, 2002.
[10] Fabian Kuhn, Nancy Lynch, and Rotem Oshman. Distributed computation in dynamic
networks. In Proceedings of the Forty-second ACM Symposium on Theory of Computing,
STOC’10, pages 513–522, New York, NY, USA, 2010. ACM.
[11] Nancy A. Lynch. Distributed Algorithms. Morgan Kaufmann, San Francisco, CA, 1996.
[12] Damon Mosk-Aoyama and Devavrat Shah. Computing separable functions via gossip. In
Proceedings of the 25th ACM Symposium on Principles of Distributed Computing (PODC),
pages 113–122. ACM, 2006.
[13] Angelia Nedic, Alexander Olshevsky, Asuman E. Ozdaglar, and John N. Tsitsiklis. On dis-
tributed averaging algorithms and quantization effects. IEEE Transactions on Automatic
Control, 54(11):2506–2517, 2009.
[14] Rotem Oshman. Distributed Computation in Wireless and Dynamic Networks. PhD thesis,
Massachusetts Institute of Technology, 2012.
[15] O Simeone and U Spagnolini. Distributed time synchronization in wireless sensor networks
with coupled discrete-time oscillators. EURASIP Journal on Wireless Communications and
Networking, 2007(1):057054, 2007.
[16] Gerard Tel. Introduction to Distributed Algorithms. Cambridge University Press, 2000.
[17] Roger Wattenhofer. Principles of distributed computing. Unpublished, 2014.
17

