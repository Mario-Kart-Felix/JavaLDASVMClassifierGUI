Proposed NIST Standard for Role-Based
Access Control
DAVID F. FERRAIOLO
National Institute of Standards and Technology
RAVI SANDHU
SingleSign On. Net and George Mason University, sandhu@gmu.edu
or www.list.gmu.edu
SERBAN GAVRILA
VDG Incorporated
and
D. RICHARD KUHN and RAMASWAMY CHANDRAMOULI
National Institute of Standards and Technology
In this article we propose a standard for role-based access control (RBAC). Although RBAC models
have received broad support as a generalized approach to access control, and are well recognized for
their many advantages in performing large-scale authorization management, no single authorita-
tive definition of RBAC exists today. This lack of a widely accepted model results in uncertainty and
confusion about RBAC’s utility and meaning. The standard proposed here seeks to resolve this sit-
uation by unifying ideas from a base of frequently referenced RBAC models, commercial products,
and research prototypes. It is intended to serve as a foundation for product development, evalu-
ation, and procurement specification. Although RBAC continues to evolve as users, researchers,
and vendors gain experience with its application, we feel the features and components proposed
in this standard represent a fundamental and stable set of mechanisms that may be enhanced
by developers in further meeting the needs of their customers. As such, this document does not
attempt to standardize RBAC features beyond those that have achieved acceptance in the com-
mercial marketplace and research community, but instead focuses on defining a fundamental and
stable set of RBAC components. This standard is organized into the RBAC Reference Model and
the RBAC System and Administrative Functional Specification. The reference model defines the
scope of features that comprise the standard and provides a consistent vocabulary in support of the
specification. The RBAC System and Administrative Functional Specification defines functional
requirements for administrative operations and queries for the creation, maintenance, and review
of RBAC sets and relations, as well as for specifying system level functionality in support of session
attribute management and an access control decision process.
Categories and Subject Descriptors: C.2.0 [Computer Communication Networks]: General—
security and protection
General Terms: Security, Standardization
Author’s address: D. F. Ferraiolo, NIST, 100 Bureau Drive, Stop 8930, Gaithersburg, MD 20899-
8930; e-mail: david.ferraiolo@nist.gov.
Permission to make digital/hard copy of part or all of this work for personal or classroom use is
granted without fee provided that the copies are not made or distributed for profit or commercial
advantage, the copyright notice, the title of the publication, and its date appear, and notice is given
that copying is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers,
or to redistribute to lists, requires prior specific permission and/or a fee.
C© 2001 ACM 1094-9224/01/0800–0224 $5.00
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001, Pages 224–274.
Proposed NIST Standard: Role-Based Access Control • 225
Additional Key Words and Phrases: Role-based access control, security, access control, authoriza-
tion management, standards
1. INTRODUCTION
In recent years, vendors have begun implementing role-based access control
(RBAC) features in their database management, security management, and
network operating system products, without general agreement as to what con-
stitutes an appropriate set of RBAC features. Several RBAC models have been
proposed1 without any attempt at standardizing salient RBAC features. To
identify RBAC features that exhibit true enterprise value and are practical to
implement, the National Institute of Standards and Technology (NIST) has con-
ducted and sponsored market analysis [Ferraiolo et al. 1993; Smith et al. 1996],
developed prototype implementations [Ferraiolo et al. 1999], and sponsored ex-
ternal research [Feinstein 1996]. However NIST is not alone in recognizing the
potential benefits of RBAC technology. Significant research has been performed
at the university level in developing new RBAC models and applications, and
researchers, vendors, and users have gathered on an annual basis to present
papers and discuss issues related to RBAC in a formal workshop setting. As a
result of these efforts much has been learned about RBAC and its practical im-
plementation. Our overall understanding of RBAC has dramatically advanced,
and a nascent consensus has begun.
A first effort at defining a consensus standard for RBAC was proposed at the
2000 ACM Workshop on Role-Based Access Control [Sandhu et al. 2000]. Pub-
lished comments on this earlier document [Jaeger and Tidswell 2000] assisted
in developing the reference model and functional specification proposed in this
article. Panel session discussions at the 2000 ACM Workshop also contributed
toward evolving the initial model into the following proposals. This standard
represents a proposal and a public draft, and should not be considered a final
version.
1.1 Background
The concept of roles has been used in software applications for at least 25 years,
but it is only within the past decade that role-based access control has emerged
as a full-fledged model as mature as traditional mandatory access control (MAC)
and discretionary access control (DAC) concepts. The roots of RBAC include
the use of groups in UNIX and other operating systems, privilege groupings
in database management systems [Baldwin 1990; Thomsen 1991; Ting et al.
1992], and separation of duty concepts described in earlier papers [Clark and
Wilson 1987; Sandhu 1988; Brewer and Nash 1989]. The modern concept of
RBAC embodies all these notions in a single access control model in terms of
roles and role hierarchies, role activation, and constraints on user/role mem-
bership and role set activation [Ferraiolo and Kuhn 1992]. These constructs are
1Please see Ferraiolo and Kuhn [1992], Nyanchama and Osborn [1994], Ferraiolo et al. [1995],
Giuri and Iglio [1996], and Sandhu et al. [1996].
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
226 • D. F. Ferraiolo et al.
common to the early formal definitions of RBAC proposed by various authors
[Ferraiolo et al. 1995; Sandhu et al. 1996; Nyanchama and Osborn 1994]. A com-
prehensive framework for RBAC models was defined by Sandhu et al. [1996],
and expanded in subsequent publications [Sandhu 1998; Sandhu et al. 1999;
Ahn and Sandhu 2000].
RBAC models have matured to the point where they are now being prescribed
as a generalized approach to access control. For instance, recently RBAC was
found to be “the most attractive solution for providing security features in multi-
domain digital government infrastructure,” [Joshi et al. 2001b], and has shown
its relevance in meeting the complex needs of Web-based applications [Joshi
et al. 2001a]. RBAC models have been shown to be “policy-neutral” in the sense
that by using role hierarchies and constraints, a wide range of security policies
can be expressed [Osborn et al. 2000]. Security administration is also greatly
simplified by the use of roles to organize access privileges. For example, if a
user moves to a new function within the organization, the user can simply be
assigned to the new role and removed from the old one, whereas in the absence
of an RBAC model, the user’s old permissions would have to be individually
revoked, and new permissions would have to be granted. In addition, admin-
istration constraints may need to be enforced to prevent information misuse
and prevent fraudulent activities. A typical authorization constraint, broadly
relevant and well recognized, is separation of duties (SoD). Reducing the risk of
fraud by not allowing any individual to have sufficient authority within the sys-
tem to single-handedly perpetrate fraud is the intent of SoD. Such constraints
can be easily expressed using an RBAC model through SoD constraints on roles,
user-role assignments, and role-permission assignments. Furthermore, using
constraints on the activation of user assigned roles, users can sign on with the
least privilege set required for any access. In case of inadvertent errors, such
least privilege assignments can contain damage.
Although existing RBAC models and implementations are relatively simi-
lar on fundamental RBAC concepts, they differ in significant details. Points of
similarity and differences are not obvious, because many models use different
terminology to describe the same concepts. Because RBAC is a relatively new
technology and because products and models come from different commercial
and academic backgrounds, little consensus exists on what to call the differ-
ent parts. RBAC is also a rich and open-ended technology, which ranges from
very simple at one extreme to fairly complex and sophisticated at the other.
Treating RBAC as a single model is therefore unrealistic. A single model would
either include or exclude too much, and would only represent one point along a
spectrum of technologies and choices.
1.2 RBAC Standardization
To address these issues of scope and terminology, this proposed standard be-
gins with an RBAC Reference Model defining a collection of model components.
The RBAC reference model defines sets of basic RBAC elements (i.e., users,
roles, permissions, operations, and objects) and relations as types and func-
tions that are included in this standard. The RBAC reference model serves two
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 227
purposes. It rigorously defines the scope of RBAC features that are included in
the standard. This covers the core set of features to be encompassed in all RBAC
systems, aspects of role hierarchies, aspects of static constraint relations, and
aspects of dynamic constraint relations. In addition, the reference model pro-
vides a precise and consistent language, in terms of element sets and functions
for use in defining the functional specification.
Not all RBAC features are appropriate for all environments nor do vendors
necessarily implement all RBAC features. As such, this standard provides a
method of packaging features through the selection of functional components
and feature options within a component, beginning with a core set of RBAC
features that must be included in all packages. Other components that may be
selected in arriving at a relevant package of features pertain to role hierarchies,
static constraints (static separation of duty), and dynamic constraints (dynamic
separation of duty). In arriving at the scope of RBAC features, the authors of
this document applied two selection criteria: the features must be well under-
stood and well represented within the RBAC literature and established RBAC
models; and RBAC features should be known to be viable in that there exists
at least one example commercial or reference implementation for each feature.
The RBAC System and Administrative Functional Specification defines the
features required of an RBAC system. These features fall into three cate-
gories: administrative operations, administrative reviews, and system level
functionality. The administrative operations define requirements in terms of
an administrative interface and an associated set of semantics that provide
the capability to create, delete, and maintain RBAC elements and relations
(e.g., to create and delete user role assignments). The administrative review
features define requirements in terms of an administrative interface and an
associated set of semantics that provide the capability to perform query op-
erations on RBAC elements and relations, for example, return the set of
users assigned to a role or the set of roles that are either assigned to or in-
herited by a user (authorized roles). System level functionality defines fea-
tures for the creation of user sessions to include role activation/deactivation,
the enforcement of constraints on role activation, and for calculation of an
access decision.
Standardization over a stable set of RBAC features is expected to provide a
multitude of benefits. These benefits include a common set of benchmarks for
vendors, who are already developing RBAC mechanisms, to use in the charac-
terization of their products. A standard will give IT consumers, who are the
principal beneficiaries of RBAC technology, a basis for the creation of uni-
form acquisition specifications and a basis for making purchasing decisions.
In addition, an RBAC standard will provide researchers with a well-defined
foundation for devising new and innovative access control and authorization
management models and techniques. Although the RBAC functional specifica-
tion is not intended to promote interoperability in and of itself, the functional
administrative interfaces and RBAC functional system specification provided
in this standard can provide a basis for further standardization in the devel-
opment of architecture-specific APIs. Taking this next step in standardization
will lead to the development of new and innovative authorization management
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
228 • D. F. Ferraiolo et al.
tools by guaranteeing interoperability and portability over a broad spectrum of
products and administrative services.
The rest of this article is organized as follows. Section 2 gives an overview
and a rationale for the four RBAC components that are included in this stan-
dard. These components are later used as a basis for modeling RBAC features
and are used to provide a uniform and consistent set of functional definitions
that are applied in the specification and packaging of the RBAC functional
specification. Section 3, the RBAC reference model, provides a rigorous defi-
nition of these components as a collection of relations on sets of RBAC basic
elements. Section 4 provides an overview of the RBAC functional specification
in three areas: administrative operations, administrative review capabilities,
and RBAC system functions. A complete and detailed requirement specification
for each RBAC component is provided as an Appendix. Section 5 describes the
method of packaging RBAC functional components into an environment-specific
collection of RBAC administrative operations and queries and system functions.
2. COMPONENT OVERVIEW
This RBAC standard is organized into two main parts: the RBAC Reference
Model and the RBAC Functional Specification. The RBAC Reference Model
provides a rigorous definition of RBAC sets and relations. The reference model
has two primary objectives: to define a common vocabulary of terms for use
in consistently specifying requirements and to set the scope of the RBAC fea-
tures included in the standard. The RBAC Functional Specification defines re-
quirements over administrative operations for the creation and maintenance of
RBAC element sets and relations; administrative review functions for perform-
ing administrative queries; and system functions for creating and managing
RBAC attributes on user sessions and making access control decisions.
The RBAC model and functional specification are organized into four RBAC
components, as described in the following sections. A rationale for each of these
components is also provided. Readers relatively new to RBAC can skim this
section and revisit it after reading the descriptions of the four components of
the model in the following section.
2.1 Core RBAC
Core RBAC embodies the essential aspects of RBAC. The basic concept of RBAC
is that users are assigned to roles, permissions are assigned to roles, and users
acquire permissions by being members of roles. Core RBAC includes require-
ments that user-role and permission-role assignment can be many-to-many.
Thus the same user can be assigned to many roles and a single role can have
many users. Similarly, for permissions, a single permission can be assigned
to many roles and a single role can be assigned to many permissions. Core
RBAC includes requirements for user-role review whereby the roles assigned
to a specific user can be determined as well as users assigned to a specific role.
A similar requirement for permission-role review is imposed as an advanced
review function. Core RBAC also includes the concept of user sessions, which al-
lows selective activation and deactivation of roles. Finally, Core RBAC requires
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 229
that users be able to simultaneously exercise permissions of multiple roles. This
precludes products that restrict users to activation of one role at a time.
Rationale. Core RBAC captures the features of traditional group-based ac-
cess control as implemented in operating systems through the current gen-
eration. As such it is widely deployed and familiar technology. The features
required of Core RBAC are essential for any form of RBAC. The main issue in
defining Core RBAC is to determine which features to exclude. This proposed
standard has deliberately kept a very minimal set of features in Core RBAC.
In particular, these features accommodate traditional but robust group-based
access control. Not every group-based mechanism qualifies because of the re-
quirements given above. One of the features omitted as mandatory for Core
RBAC is permission-role review. Although highly desirable, we recognize that
many well-accepted RBAC systems do not provide this feature. The require-
ment that users can be assigned to and can simultaneously activate multiple
roles could arguably be considered too strong for a core model. This requirement
seems appropriate when we have a large number of diverse roles (say hundreds
or thousands). It may not be appropriate for situations with few roles (say tens).
For now we have chosen to define the core model as presented here. But we leave
open the possibility of defining a smaller core model as the standard progresses.
2.2 Hierarchical RBAC
Hierarchical RBAC adds requirements for supporting role hierarchies. A hier-
archy is mathematically a partial order defining a seniority relation between
roles, whereby senior roles acquire the permissions of their juniors, and junior
roles acquire the user membership of their seniors. This standard recognizes
two types of role hierarchies.
—General Hierarchical RBAC. In this case, there is support for an arbitrary
partial order to serve as the role hierarchy, to include the concept of multiple
inheritance of permissions and user membership among roles.
—Limited Hierarchical RBAC. Some systems may impose restrictions on the
role hierarchy. Most commonly, hierarchies are limited to simple structures
such as trees or inverted trees.
Rationale. Roles can have overlapping capabilities; that is, users belonging
to different roles may be assigned common permissions. Furthermore, within
many organizations there are a number of general permissions that are per-
formed by a large number of users. As such, it would prove inefficient and
administratively cumbersome to specify repeatedly their general permission-
role assignments. To improve efficiency and support organizational structure,
RBAC models as well as commercial implementations include the concept of
role hierarchies. Role hierarchies in the form of an arbitrary partial ordering
are arguably the single most desirable feature in addition to core RBAC. This
feature has often been mentioned in the literature [Ferraiolo et al. 1995; Sandhu
et al. 1996; Moffett 1998] and has precedence in existing RBAC implementa-
tions. Justification for requiring the transitive, reflexive, and antisymmetric
properties of a partial order has been extensively discussed in the literature
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
230 • D. F. Ferraiolo et al.
[Ferraiolo et al. 1995; Nyanchama and Osborn 1999; Sandhu et al. 1996]. There
is a strong consensus on this issue. Nevertheless there are a number of products
that support only restricted hierarchies, which provide substantially improved
capabilities beyond Core RBAC.
2.3 Static Separation of Duty Relations
Separation of duty relations are used to enforce conflict of interest policies.
Conflict of interest in a role-based system may arise as a result of a user gaining
authorization for permissions associated with conflicting roles. One means of
preventing this form of conflict of interest is though static separation of duty
(SSD), that is, to enforce constraints on the assignment of users to roles. An
example of such a static constraint is the requirement that two roles be mutually
exclusive; for example, if one role requests expenditures and another approves
them, the organization may prohibit the same user from being assigned to both
roles. The SSD policy can be centrally specified and then uniformly imposed on
specific roles. Because of the potential for inconsistencies with respect to static
separation of duty relations and inheritance relations of a role hierarchy, we
define SSD requirements both in the presence and absence of role hierarchies.
—Static Separation of Duty. SSD relations place constraints on the assign-
ments of users to roles. Membership in one role may prevent the user from
being a member of one or more other roles, depending on the SSD rules en-
forced.
—Static Separation of Duty in the Presence of a Hierarchy. This type of SSD
relation works in the same way as basic SSD except that both inherited
roles as well as directly assigned roles are considered when enforcing the
constraints.
With respect to the constraints placed on the user-role assignments for de-
fined sets of roles, we define SSD as a pair (role set, n) where no user is assigned
to n or more roles from the role set. As such, we recognize a variety of SSD poli-
cies. For example, a user may not be assignable to every role in a specified role
set, while a strong deployment of the same feature may restrict a user from
being assigned to any combination of two or more roles in the role set.
Rationale. From a policy perspective, SSD relations provide a powerful
means of enforcing conflict of interest and other separation rules over sets of
RBAC elements. Static constraints generally place restrictions on administra-
tive operations that have the potential to undermine higher-level organizational
Separation of Duty policies.
Static constraints can take on a wide variety of forms. A common example is
that of static separation of duty, which defines mutually disjoint user assign-
ments with respect to sets of roles [Kuhn 1997; Giuri and Iglio 1996]. However,
static constraints have been shown to be a powerful means of implementing
a number of other important separation of duty policies. For example, Gligor
et al. [1998], and Simon and Zurko [1997], [Ahn and Sandhu 1999, 2000; Jaeger
2000] have identified SSD relations to include constraints on users, operations,
and objects as well as combinations thereof. Some authors [Ahn and Sandhu
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 231
1999, 2000; Jaeger 2000] have studied other forms of constraints recently, but
so far consensus has not been developed. The static constraints defined in this
standard are limited to those relations that place restrictions on sets of roles
and in particular on their ability to form user-role assignment relations. Al-
though formal RBAC models and RBAC policy specifications have grown well
beyond these simple relations, we know of no commercial products that imple-
ment these advanced static separation of duty relations.
2.4 Dynamic Separation of Duty Relations
Dynamic separation of duty (DSD) relations, like SSD relations, limit the per-
missions that are available to a user. However DSD relations differ from SSD
relations by the context in which these limitations are imposed. DSD require-
ments limit the availability of the permissions by placing constraints on the
roles that can be activated within or across a user’s sessions.
Similar to SSD relations, DSD relations define constraints as a pair (role set,
n) where n is a natural number ≥2, with the property that no user session may
activate n or more roles from the role set.
Rationale. DSD properties provide extended support for the principle of
least privilege in that each user has different levels of permission at different
times, depending on the task being performed. This ensures that permissions
do not persist beyond the time that they are required for performance of duty.
This aspect of least privilege is often referred to as timely revocation of trust.
Dynamic revocation of permissions can be a complex issue without the facilities
of dynamic separation of duty, and as such it has been generally ignored in the
past for reasons of expediency.
SSD provides the capability to address potential conflict of interest issues at
the time a user is assigned to a role. DSD allows a user to be authorized for
roles that do not cause a conflict of interest when acted on independently, but
which produce policy concerns when activated simultaneously. Although this
separation of duty requirement could be achieved through the establishment
of a static separation of duty relationship, DSD relationships generally provide
the enterprise with greater efficiency and operational flexibility.
3. THE ROLE-BASED ACCESS CONTROL REFERENCE MODEL
The NIST RBAC model is defined in terms of four model components: Core
RBAC, Hierarchical RBAC, Static Separation of Duty Relations, and Dynamic
Separation of Duty Relations. Core RBAC defines a minimum collection of
RBAC elements, element sets, and relations in order to completely achieve
a role-based access control system. This includes user-role assignment and
permission-role assignment relations, considered fundamental in any RBAC
system. In addition, Core RBAC introduces the concept of role activation as
part of a user’s session within a computer system. Core RBAC is required in
any RBAC system, but the other components are independent of each other and
may be implemented separately.
The Hierarchical RBAC component adds relations for supporting role hi-
erarchies. A hierarchy is mathematically a partial order defining a seniority
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
232 • D. F. Ferraiolo et al.
Fig. 1. Core RBAC.
relation between roles, whereby senior roles acquire the permissions of their
juniors and junior roles acquire users of their seniors. In addition, Hierarchical
RBAC goes beyond simple user- and permission-role assignment by introduc-
ing the concept of a role’s set of authorized users and authorized permissions.
A third model component, Static Separation of Duty Relations, adds exclu-
sivity relations among roles with respect to user assignments. Because of the
potential for inconsistencies with respect to Static Separation of Duty Rela-
tions and inheritance relations of a role hierarchy, the SSD relations model
component defines relations in both the presence and absence of role hierar-
chies. The fourth model component, Dynamic Separation of Duty Relations,
defines exclusivity relations with respect to roles that are activated as part of a
user’s session.
Each model component is defined by the subcomponents:
—a set of basic element sets;
—a set of RBAC relations involving those element sets (containing subsets of
Cartesian products denoting valid assignments); and
—a set of mapping functions that yield instances of members from one element
set for a given instance from another element set.
It is important to note that the RBAC reference model defines a taxonomy of
RBAC features that can be composed into a number of feature packages. Rather
then attempting to define a complete set of RBAC features, this model focuses
on providing a standard set of terms for defining the most salient features as
represented in existing models and implemented in commercial products.
3.1 Core RBAC
Core RBAC model element sets and relations are defined in Figure 1. Core
RBAC includes sets of five basic data elements called users (USERS), roles
(ROLES), objects (OBS), operations (OPS), and permissions (PRMS). The RBAC
model as a whole is fundamentally defined in terms of individual users be-
ing assigned to roles and permissions being assigned to roles. As such, a role
is a means for naming many-to-many relationships among individual users
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 233
and permissions. In addition, the Core RBAC model includes a set of sessions
(SESSIONS) where each session is a mapping between a user and an activated
subset of roles that are assigned to the user.
A user is defined as a human being. Although the concept of a user can
be extended to include machines, networks, or intelligent autonomous agents,
for simplicity reasons we limit a user to a person in this article. A role is
a job function within the context of an organization with some associated
semantics regarding the authority and responsibility conferred on the user
assigned to the role. Permission is an approval to perform an operation on
one or more RBAC protected objects.2 An operation is an executable image
of a program, which upon invocation executes some function for the user.
The types of operations and objects that RBAC controls are dependent on
the type of system in which they will be implemented. For example, within
a file system, operations might include read, write, and execute; within a
database management system, operations might include insert, delete, append,
and update.
The purpose of any access control mechanism is to protect system resources.
However, in applying RBAC to a computer system, we speak of protected ob-
jects. Consistent with earlier models of access control an object is an entity
that contains or receives information. For a system that implements RBAC,
the objects can represent information containers (e.g., files or directories in an
operating system, and/or columns, rows, tables, and views within a database
management system) or objects can represent exhaustible system resources,
such as printers, disk space, and CPU cycles. The set of objects covered by
RBAC includes all of the objects listed in the permissions that are assigned
to roles.
Central to RBAC is the concept of role relations, around which a role is a
semantic construct for formulating policy. Figure 1 illustrates user assignment
(UA) and permission assignment (PA) relations. The arrows indicate a many-
to-many relationship (e.g., a user can be assigned to one or more roles, and a
role can be assigned to one or more users). This arrangement provides great
flexibility and granularity of assignment of permissions to roles and users to
roles. Without these conveniences there is an enhanced danger that a user may
be granted more access to resources than is needed because of limited control
over the type of access that can be associated with users and resources. Users
may need to list directories and modify existing files, for example, without cre-
ating new files, or they may need to append records to a file without modifying
existing records. Any increase in the flexibility of controlling access to resources
also strengthens the application of the principle of least privilege.
Each session is a mapping of one user to possibly many roles, that is, a user
establishes a session during which the user activates some subset of roles that
he or she is assigned. Each session is associated with a single user and each
user is associated with one or more sessions. The function session roles gives
2Negative permissions have been discussed in the literature, but are not included in this
model. The model leaves open the possibility of incorporating negative permissions in an RBAC
implementation.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
234 • D. F. Ferraiolo et al.
us the roles activated by the session and the function user sessions gives us
the set of sessions that are associated with a user. The permissions available
to the user are the permissions assigned to the roles that are activated across
all the user’s sessions.
We summarize the above in the following definition.
Definition 1. Core RBAC.
—USERS, ROLES, OPS, and OBS (users, roles, operations, and objects, re-
spectively).
—UA ⊆ USERS × ROLES, a many-to-many mapping user-to-role assignment
relation.
—assigned users: (r:ROLES) → 2USERS, the mapping of role r onto a set of
users. Formally: assigned users(r) = {u ∈ USERS | (u, r) ∈ UA}.
—PRMS = 2(OPS × OBS), the set of permissions.
—PA ⊆ PRMS × ROLES, a many-to-many mapping permission-to-role assign-
ment relation.
—assigned permissions(r: ROLES)→ 2PRMS, the mapping of role r onto a set of
permissions. Formally: assigned permissions(r)= {p ∈ PRMS | (p, r) ∈ PA}.
—Ob(p: PRMS) →{op ⊆ OPS}, the permission-to-operation mapping, which
gives the set of operations associated with permission p.
—Ob(p: PRMS)→{ob ⊆ OBS}, the permission-to-object mapping, which gives
the set of objects associated with permission p.
—SESSIONS, the set of sessions.
—user sessions (u: USERS)→ 2SESSIONS, the mapping of user u onto a set of
sessions.
—session roles (s: SESSIONS)→ 2ROLES, the mapping of session s onto a set
of roles. Formally: session roles (si) ⊆ {r ∈ ROLES | (session users (si), r)
∈ UA}.
—avail session perms(s:SESSIONS)→ 2PRMS, the permissions available to a
user in a session,
⋃
r∈ session roles(s)
assigned permissions(r).
We now define role hierarchies as inheritance relationships between roles.
3.2 Hierarchal RBAC
This model component introduces role hierarchies (RH) as indicated in Figure 2.
Role hierarchies are commonly included as a key aspect of RBAC models3
and are often included as part of RBAC product offerings [Chandramouli and
Sandhu 1998]. Hierarchies are a natural means of structuring roles to reflect
an organization’s lines of authority and responsibility (see Figure 3).
Role hierarchies define an inheritance relation among roles. Inheritance has
been described in terms of permissions [Nyanchama and Osborn 1999]; that
3Please see Ferraiolo et al. [1995], Sandhu et al. [1996], Nyanchama and Osborn [1999], and Moffett
[1998].
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 235
Fig. 2. Hierarchical RBAC.
is, r1 “inherits” role r2 if all privileges of r2 are also privileges of r1. Other
authors have proposed a stronger definition of inheritance [Nyanchama and
Osborn 1999] as well as alternate interpretations [Kuhn 1998; Sandhu 1998a].
We have adopted the most widely used definition.4
This standard recognizes both general and limited role hierarchies. General
role hierarchies provide support for an arbitrary partial order to serve as the
role hierarchy, to include the concept of multiple inheritances of permissions
and user membership among roles. Limited role hierarchies impose restrictions
resulting in a simpler tree structure (i.e., a role may have one or more immediate
ascendants, but is restricted to a single immediate descendant). Note that an
inverted tree is also possible. Examples of possible hierarchical role structures
are shown in Figure 3. Note that user membership is inherited top-down, and
role permissions are inherited bottom-up.
We first formally define general role hierarchies.
Definition 2a. General Role Hierarchies.
—RH ⊆ ROLES×ROLES is a partial order on ROLES called the inheri-
tance relation, written as , where r1  r2 only if all permissions of r2
are also permissions of r1, and all users of r1 are also users of r2. For-
mally: r1  r2 ⇒ authorized permissions(r2) ⊆ authorized permissions(r1)
∧ authorized users(r1) ⊆ authorized users(r2).
—authorized users(r: ROLES) → 2USERS, the mapping of role r onto a set of
users in the presence of a role hierarchy. Formally: authorized users(r)= {u ∈
USERS | r ′  r (u, r ′) ∈ UA}.
4For some distributed RBAC implementations, role permissions are not managed centrally, while
the role hierarchies are. For these systems, role hierarchies are managed in terms of user contain-
ment relations: role r1 “contains” role r2 if all users authorized for r1 are also authorized for r2.
Note, however, that user containment implies that a user of r1 has (at least) all the privileges of r2,
while the permission inheritance for r1 and r2 does not imply anything about user assignment.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
236 • D. F. Ferraiolo et al.
Fig. 3. Example role hierarchies: (a) tree; (b) inverted tree; (c) lattice.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 237
Fig. 4. Accounting roles.
—authorized permissions(r: ROLES) → 2PRMS, the mapping of role r onto
a set of permissions in the presence of a role hierarchy. Formally:
authorized permissions(r) = {p ∈ PRMS | r ′  r, (p, r ′) ∈ PA}.
General role hierarchies support the concept of multiple inheritance, which
provides the ability to inherit permission from two or more role sources and to
inherit user membership from two or more role sources. Multiple inheritances
provide important hierarchy properties. The first is the ability to compose a role
from multiple subordinate roles (with fewer permissions) in defining roles and
relations that are characteristic of the organization and business structures,
which these roles are intended to represent. Second, multiple inheritances pro-
vide uniform treatment of user/role assignment relations and role/role inher-
itance relations. Users can be included in the role hierarchy, using the same
relation  to denote the user assignment to roles, as well as permission inher-
itance from a role to its assigned users.
Roles in a limited role hierarchy are restricted to a single immediate descen-
dant. Although limited role hierarchies do not support multiple inheritances,
they nonetheless provide clear administrative advantages over Core RBAC.
We represent r1 as an immediate descendent of r2 by r1  r2, if r1 r2, but
no role in the role hierarchy lies between r1 and r2. That is, there exists no role
r3 in the role hierarchy such that r  r3  r2, where r1 6= r2 and r2 6= r3.
We now define limited role hierarchies as a restriction on the immediate
descendants of the general role hierarchy.5
Definition 2b. Limited Role Hierarchies.
—Definition 2a with the limitation:
∀ r, r1, r2 ∈ ROLES, r  r1 ∧ r  r2 ⇒ r1 = r2.
Figure 4 illustrates properties of a limited role hierarchy. In the role graph
of Figure 4, where the users are represented by double ellipses and the
5A similar notion of limited role hierarchies for inverted trees can also be defined.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
238 • D. F. Ferraiolo et al.
roles by single ellipses, John is assigned to CashierSpv, and is authorized for
CashierSpv, Cashier, and Accounting. Also, John’s permissions are the union
of the permission sets assigned to John, CashierSpv, Cashier, Accounting, and
the permissions directly assigned to John. Note that users are permitted to be
included in the graph as a result of multiple inheritances. Although the role
assignments of Fred, John, and Mark could be represented in a limited role
hierarchy, Frank’s role assignments could not. Because Core RBAC requires
user role assignment to be a many-to-many relation, in the general case users
would be precluded from being included as nodes in a limited role hierarchy.
3.3 Constrained RBAC
Constrained RBAC adds separation of duty relations to the RBAC model. Sep-
aration of duty relations are used to enforce conflict of interest policies that
organizations may employ to prevent users from exceeding a reasonable level
of authority for their positions.
As a security principle, SOD has long been recognized for its wide applica-
tion in business, industry, and government [Brewer and Nash 1989; Clark and
Wilson 1987]. Its purpose is to ensure that failures of omission or commission
within an organization can be caused only as a result of collusion among indi-
viduals. To minimize the likelihood of collusion, individuals of different skills or
divergent interests are assigned to separate tasks required in the performance
of a business function. The motivation is to ensure that fraud and major errors
cannot occur without deliberate collusion of multiple users. This RBAC stan-
dard allows for both static and dynamic separation of duty as defined within
the next two subsections.
3.3.1 Static Separation of Duty Relations. Conflict of interest in a role-
based system may arise as a result of a user gaining authorization for permis-
sions associated with conflicting roles. One means of preventing this form of
conflict of interest is through static separation of duty, that is, to enforce con-
straints on the assignment of users to roles. Static constraints can take on a
wide variety of forms. A common example is that of static separation of duty that
defines mutually disjoint user assignments with respect to sets of roles. Static
constraints have also been shown to be a powerful means of implementing a
number of other important separation of duty policies.6 For example, Gligor
et al. [1998] formally defined four other types of static separation of duty poli-
cies. Static constraints beyond separation of duties have been identified in Ahn
and Sandhu [2000]. Although formal RBAC models and policy specifications
have grown well beyond simple relations, we know of no commercial products
that implement these advanced static constraint relations.
The static constraints defined in this model are limited to those relations that
place restrictions on sets of roles and in particular on their ability to form UA
relations. This means that if a user is assigned to one role, the user is prohibited
from being a member of a second role. For example, a user who is assigned to the
6Please see Ferraiolo et al. [1995], Kuhn [1997], Simon and Zurko [1997], Gligor et al. [1998], and
Giuri and Iglio [1996].
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 239
Fig. 5. SSD within Hierarchical RBAC.
role Billing Clerk may not be assigned to the role Accounts Receivable Clerk.
That is, the roles Billing Clerk and Accounts Receivable Clerk are mutually
exclusive. An SSD policy can be centrally specified and then uniformly imposed
on specific roles. From a policy perspective, static constraint relations provides
a powerful means of enforcing conflict of interest and other separation rules
over sets of RBAC elements. Static constraints generally place restrictions on
administrative operations that have the potential to undermine higher-level
organizational separation of duty policies.
RBAC models have defined SSD relations with respect to constraints on
user-role assignments over pairs of roles (i.e., no user can be simultaneously
assigned to both roles in SSD). Although real-world examples of this SSD policy
exist, this definition is overly restrictive in two important aspects: the size of
the set of roles in the SSD and the combination of roles in the set for which user
assignment is restricted. In this model we define SSD with two arguments: a
role set that includes two or more roles, and cardinality greater than one indi-
cating a combination of roles that would constitute a violation of the SSD policy.
For example, an organization may require that no one user may be assigned to
three of the four roles that represent the purchasing function.
As illustrated in Figure 5, SSD relations may exist within Hierarchical
RBAC. When applying SSD relations in the presence of a role hierarchy, spe-
cial care must be applied to ensure that user inheritance does not undermine
SSD policies. As such, role hierarchies have been defined to include the inher-
itance of SSD constraints [Gavrila and Barkley 1998; Ferraiolo et al. 1999].
If, for example, the role Accounts Receivable Supervisor inherits Accounts Re-
ceivable Clerk, and Accounts Receivable Clerk has an SSD relationship with
Billing Clerk, then Accounts Receivable Supervisor also has an SSD relation-
ship with Billing Clerk. To address this potential inconsistency we define SSD
as a constraint on the authorized users of the roles that have an SSD relation.
The formal definition of static separation of duty is given below.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
240 • D. F. Ferraiolo et al.
Definition 3a. Static Separation of Duty.
—SSD⊆ (2ROLES×N ) is a collection of pairs (rs, n) in Static Separation of Duty,
where each rs is a role set, t a subset of roles in rs, and n is a natural number
≥2, with the property that no user is assigned to n or more roles from the
set rs in each (rs, n) ∈ SSD. Formally: ∀(rs, n) ∈ SSD, ∀t ⊆ rs : |t| ≥ n ⇒⋂
r∈t assigned users (r) = Ø.
Definition 3b. Static Separation of Duty in the Presence of a Hierarchy.
—In the presence of a role hierarchy static separation of duty is redefined based
on authorized users rather than assigned users as follows.
∀(rs, n) ∈ SSD, ∀t ⊆ rs: |t| ≥ n⇒
⋂
r∈t
authorized users (r) = Ø.
3.3.2 Dynamic Separation of Duty Relations. Static Separation of Duty
relations reduce the number of potential permissions that can be made available
to a user by placing constraints on the users that can be assigned to a set of
roles. Dynamic Separation of Duty relations, like SSD relations, are intended
to limit the permissions that are available to a user. However DSD relations
differ from SSD relations by the context in which these limitations are imposed.
SSD relations define and place constraints on a user’s total permission space.
This model component defines DSD properties that limit the availability of
the permissions over a user’s permission space by placing constraints on the
roles that can be activated within or across a user’s sessions. DSD properties
provide extended support for the principle of least privilege in that each user
has different levels of permission at different times, depending on the role being
performed. These properties ensure that permissions do not persist beyond
the time that they are required for performance of duty. This aspect of least
privilege is often referred to as timely revocation of trust. Dynamic revocation
of permissions can be a rather complex issue without the facilities of dynamic
separation of duty, and as such it has been generally ignored in the past for
reasons of expediency.
This model component provides the capability to enforce an organization-
specific policy of dynamic separation of duty. SSD relations provide the capabil-
ity to address potential conflict-of-interest issues at the time a user is assigned
to a role. DSD allows a user to be authorized for two or more roles that do not
create a conflict of interest when acted on independently, but produce policy con-
cerns when activated simultaneously. For example, a user may be authorized
for both the roles of Cashier and Cashier Supervisor, where the supervisor
is allowed to acknowledge corrections to a Cashier’s open cash drawer. If the
individual acting in the role Cashier attempted to switch to the role Cashier
Supervisor, DSD would require the user to drop the Cashier role, and thereby
force the closure of the cash drawer before assuming the role Cashier Super-
visor. As long as the same user is not allowed to assume both of these roles at
the same time, a conflict of interest situation will not arise. Although this effect
could be achieved through the establishment of a Static Separation of Duty
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 241
Fig. 6. Dynamic Separation of Duty relations.
relationship, DSD relationships generally provide the enterprise with greater
operational flexibility.
We define Dynamic Separation of Duty relations as a constraint on the roles
that are activated in a user’s session (see Figure 6).
The formal definition of Dynamic Separation of Duty is given below.
Definition 4. Dynamic Separation of Duty.
—DSD ⊆ (2ROLES× N) is collection of pairs (rs, n) in Dynamic Separation of
Duty, where each rs is a role set and n is a natural number ≥2, with the
property that no subject may activate n or more roles from the set rs in each
dsd ∈ DSD. Formally:
∀rs ∈ 2ROLES, n ∈ N, (rs, n) ∈ DSD⇒ n ≥ 2 ∧ |rs| ≥ n, and
∀s ∈ SESSIONS, ∀rs ∈ 2ROLES, ∀role subset ∈ 2ROLES, ∀n ∈ N, (rs, n) ∈ DSD,
role subset ⊆ rs, role subset ⊆ session roles(s)⇒ | role subset | < n.
4. FUNCTIONAL SPECIFICATION OVERVIEW
In this section, we provide an overview of the functionality involved in meeting
the requirements for each of the components defined in the previous section. In
Section 3, we defined RBAC as four model components in terms of an abstract
set of element sets, relations, and administrative queries. In this section, we
cast the abstract model concepts into functional requirements for administra-
tive operations, session management, and administrative review. The RBAC
functional specification outlines the semantics of the various functions that are
required for creation and maintenance of the RBAC Model components (ele-
ment sets and relations), as well as supporting system functions. These func-
tions can be composed and packaged into higher-level abstract operations in
implementations.
The three categories of functions in the RBAC functional specification and
their purpose are:
—Administrative Functions: creation and maintenance of element sets and
relations for building the various component RBAC models;
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
242 • D. F. Ferraiolo et al.
—Supporting System Functions: functions that are required by the RBAC im-
plementation to support the RBAC model constructs (e.g., RBAC session at-
tributes and access decision logic) during user interaction with an IT system;
and
—Review Functions: review the results of the actions created by administrative
functions.
A complete specification of these functions using the Z notation is given in
Appendix A. Each subsection in Section 4 provides an overview of the corre-
spondingly numbered subsection in Appendix A (e.g., Section 4.1.2 summarizes
A.1.2.) Function descriptions in Appendix A are intended to provide a level of
detail sufficient for evaluating RBAC implementations for conformance with
the RBAC Reference Model.
4.1 Functional Specification for Core RBAC
4.1.1 Administrative Functions. Creation and Maintenance of Element
Sets. The basic element sets in Core RBAC are USERS, ROLES, OPS, and
OBS. Of these element sets, OPS and OBS are considered predefined by the un-
derlying information system for which RBAC is deployed. For example, a bank-
ing system may have predefined transactions (OPS) for savings deposit and
others, and predefined data sets (OBS) such as savings files, address files, and
other necessary data. Administrators create and delete USERS and ROLES,
and establish relationships between roles and existing operations and objects.
Required administrative functions for USERS are AddUser and DeleteUser,
and for ROLES are AddRole and DeleteRole.
Creation and Maintenance of Relations. The main relations of Core RBAC
are (a) user-to-role assignment relation (UA) and (b) permission-to-role assign-
ment relation (PA). Functions to create and delete instances of UA relations
are AssignUser and DeassignUser. For PA the required functions are Grant-
Permission and RevokePermission.
4.1.2 Supporting System Functions. Supporting system functions are re-
quired for session management and in making access control decisions. An
active role is necessary for regulating access control for a user in a session. The
function that creates a session establishes a default set of active roles for the
user at the start of the session. The composition of this default set can then
be altered by the user during the session by adding or deleting roles. Func-
tions relating to the adding and dropping of active roles and other auxiliary
functions are:
—CreateSession: creates a User Session and provides the user with a default
set of active roles;
—AddActiveRole: adds a role as an active role for the current session;
—DropActiveRole: deletes a role from the active role set for the current session;
and
—CheckAccess: determines if the session subject has permission to perform the
requested operation on an object.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 243
4.1.3 Review Functions. When user-to-role assignment and permission-
to-role relation instances have been created, it should be possible to view the
contents of those relations from both the user and role perspectives. For exam-
ple, from the UA relation, the administrator should have the facility to view
all the users assigned to a given role as well to view all the roles assigned to a
given user. In addition, it should be possible to view the results of the supporting
system functions to determine some session attributes such as the active roles
in a given session or the total permission domain for a given session. Since not
all RBAC implementations provide facilities for viewing role, user, and session
permissions or active roles for a session, these functions have been designated
as optional/advance functions in our requirement specification. Mandatory (M)
and Optional (O) review functions are:
—AssignedUsers (M): returns the set of users assigned to a given role;
—AssignedRoles (M): returns the set of roles assigned to a given user;
—RolePermissions (O): returns the set of permissions granted to a given role;
—UserPermissions (O): returns the set of permissions a given user gets through
his or her assigned roles;
—SessionRoles(O): returns the set of active roles associated with a session;
—SessionPermissions (O): returns the set of permissions available in the ses-
sion (i.e., union of all permissions assigned to sesssion’s active roles);
—RoleOperationsOnObject (O): returns the set of operations a given role may
perform on a given object; and
—UserOperationsOnObject (O): returns the set of operations a given user may
perform on a given object (obtained either directly or through his or her
assigned roles).
4.2 Functional Specification for Hierarchical RBAC
4.2.1 Hierarchical Administrative Functions. The administrative func-
tions required for hierarchical RBAC include all the administrative functions
that were required for Core RBAC. However, the semantics for DeassignUser
must be redefined because the presence of role hierarchies gives rise to the
concept of authorized roles for a user. In other words, a user may inherit au-
thorization for a role even if he or she is not directly assigned to the role. The
hierarchy allows users to inherit permissions from roles that are junior to their
assigned roles. An important issue is whether a user can only be deassigned
from a role that was directly assigned to the user or can be deassigned from one
of the (indirectly) authorized roles. The appropriate course of action is left as
an implementation issue and is not prescribed in this specification.
The additional administrative functions required for the Hierarchical RBAC
model pertain to creation and maintenance of the partial order relation (RH)
among roles. The operations for a partial order involve either: (a) creating (or
deleting) an inheritance relationship between two existing roles in a role set or
(b) adding a newly created role at an appropriate position in the hierarchy by
making it the ascendant or descendant role of an another role in the existing
hierarchy. The name and purpose of these functions are summarized below:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
244 • D. F. Ferraiolo et al.
—AddInheritance: establish a new immediate inheritance relationship be-
tween two existing roles;
—DeleteInheritance: delete an existing immediate inheritance relationship be-
tween two roles;
—AddAscendant: create a new role and add it as an immediate ascendant of
an existing role; and
—AddDescendant: create a new role and add it as an immediate descendant of
an existing role.
The model provides for both general and limited hierarchies. A general hier-
archy allows multiple inheritance, while a limited hierarchy is essentially a
tree (or inverted tree) structure. For a limited hierarchy, the AddInheritance
function is constrained to a single ascendant (or descendant) role.
The outcome of the DeleteInheritance function may result in multiple sce-
narios. When DeleteInheritance is invoked with two given roles, say Role A
and Role B, the implementation system is required to do one of the following.
(1) The system may preserve the implicit inheritance relationships that roles
A and B have with other roles in the hierarchy. That is, if role A inherits other
roles, say C and D, through role B, role A will maintain permissions for C and D
after the relationship with role B is deleted. (2) Another option is to break those
relationships because an inheritance relationship no longer exists between Role
A and Role B.
4.2.2 Supporting System Functions. The Supporting System Functions for
Hierarchical RBAC are the same as for Core RBAC and provide the same func-
tionality. However because of the presence of a role hierarchy, the functions
CreateSession and AddActiveRole have to be redefined. In a role hierarchy, a
given role may inherit one or more of the other roles. When that given role is
activated by a user, the question of whether the inherited roles are automati-
cally activated or must be explicitly activated is left as an implementation issue
and no one course of action is prescribed as part of this specification. However,
when the latter scenario is implemented (i.e., explicit activation) the corre-
sponding supporting functionality shall be provided in the supporting system
functions. For example, in the case of the CreateSession function, the active
role set created as a result of the new session shall include not only roles di-
rectly assigned to a user but also some or all of the roles inherited by those
“directly assigned roles” (that were previously included in the default Active
Role Set) as well. Similarly, in the AddActiveRole function, a user can activate
a directly assigned role or one or more of the roles inherited by the “directly
assigned role.”
4.2.3 Review Functions. All the review functions specified for Core RBAC
remain valid for Hierarchical RBAC as well. In addition, the user membership
set for a given role includes not only users directly assigned to that given role
but also those users assigned to roles that inherit the given role. Analogously the
role membership set for a given user includes not only roles directly assigned
to the given user but also those roles inherited by the directly assigned roles. To
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 245
capture this expanded “User Memberships for Roles” and “Role Memberships
for a User” the following functions are defined.
—AuthorizedUsers: returns the set of users directly assigned to a given role
as well as those who were members of those “roles that inherited the given
role.”
—AuthorizedRoles: returns the set of roles directly assigned to a given user as
well as those “roles that were inherited by the directly assigned roles.”
Because of the presence of partial order among the roles, the permission set
for a given role includes not only the permissions directly assigned to a given
role but also permissions obtained from the roles that the given role inherited.
Consequently the permission set for a user who is assigned that given role
becomes expanded as well. These “Permissions Review” functions are listed
below. As already alluded to, since not all RBAC implementations provide this
facility, these are treated as advanced/optional functions:
—RolePermissions: returns the set of all permissions either directly granted to
or inherited by a given role;
—UserPermissions: returns the set of permissions of a given user through his
or her authorized roles (union of directly assigned roles and roles inherited
by those roles);
—RoleOperationsOnObject: returns the set of operations a given role may per-
form on a given object (obtained either directly or by inheritance); and
—UserOperationsOnObject: returns the set of operations a given user may
perform on a given object (obtained directly or through his or her assigned
roles or through roles inherited by those roles).
4.3 Functional Specification for SSD Relation
4.3.1 Administrative Functions. The administrative functions for an SSD
RBAC model without hierarchies shall include all the administrative functions
for Core RBAC. However since the SSD property relates to membership of users
in conflicting roles, the AssignUser function shall incorporate functionality to
verify and ensure that a given user assignment does not violate the constraints
associated with any instance of an SSD relation.
As already described under the SSD RBAC reference model, an SSD
relation consists of a triplet: (SSD Set Name, role set, SSD Card). The
SSD Set Name indicates the transaction or business process in which common
user membership must be restricted in order to enforce a conflict of interest pol-
icy. The role set is a set containing the constituent roles for the named SSD
relation (and referred to as the Named SSD role set). The SSD Card designates
the cardinality of the subset within the role set to which common user member-
ships must be restricted. Hence, administrative functions relating to creation
and maintenance of an SSD relation are operations that Create and Delete an
instance of an SSD relation, add and delete role members to the role-set pa-
rameter of the SSD relation, as well as to change/set the SSD Card parameter
for the SSD relation. These functions are summarized below:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
246 • D. F. Ferraiolo et al.
—CreateSSDSet: creates a named instance of an SSD relation;
—DeleteSSDSet: deletes an existing SSD relation;
—AddSSDRoleMember: adds a role to a named SSD role set;
—DeleteSSDRoleMember: deletes a role from a named SSD role set; and
—SetSSDCardinality: sets the cardinality of the subset of roles from the named
SSD role set for which common user membership restriction applies.
For the case of SSD RBAC models with role hierarchies (both General Role
Hierarchies and Limited Role Hierarchies), the above functions produce the
same end result with one exception: constraints governing the combination
of role hierarchies and SSD relations shall be enforced when these functions
are invoked. For example, roles within a hierarchical chain cannot be made
members of a role set in an SSD relation.
4.3.2 Supporting System Functions. The Supporting System Functions for
an SSD RBAC Model are the same as those for the Core RBAC Model.
4.3.3 Review Functions. All the review functions for the Core RBAC model
are needed for implementation of the SSD RBAC model. In addition, functions to
view the results of administrative functions listed in Section 4.3.1 shall also be
provided. These include: (a) a function to reveal the set of named SSD relations
created, (b) a function that returns the set of roles associated with a named SSD
role set, and (c) a function that gives the cardinality of the subset within the
named SSD role set for which common user membership restriction applies.
—SSDRoleSets: returns the set of named SSD relations created for the SSD
RBAC model;
—SSDRoleSetRoles: returns the set of roles associated with a named SSD role
set; and
—SSDRoleSetCardinality: returns the cardinality of the subset within the
named SSD role set for which common user membership restriction applies.
4.4 Functional Specification for DSD Relation
4.4.1 Administrative Functions. The semantics of creating an instance of
a DSD relation are identical to that of an SSD relation. While constraints as-
sociated with an SSD relation are enforced during user assignments (as well
as while creating role hierarchies), the constraints associated with DSD are
typically enforced only at the time of role activation within a user session. The
list of administrative functions that shall be provided for the DSD RBAC model
and their purpose are listed below:
—CreateDSDSet: creates a named instance of a DSD relation;
—DeleteDSDSet: deletes an existing DSD relation;
—AddDSDRoleMember: adds a role to a named DSD role set;
—DeleteDSDRoleMember: deletes a role from a named DSD role set; and
—SetDSDCardinality: sets the cardinality of the subset of roles from the named
DSD role set for which user activation restriction within the same session
applies.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 247
4.4.2 Supporting System Functions. Recall from Section 4.1.2 that the
Supporting System Functions for Core RBAC are: (a) CreateSession, (b) Ad-
dActiveRole, and (c) DeleteActiveRole. These system functions shall be avail-
able for a DSD RBAC model implementation without role hierarchies as well.
However, the additional functionality required of these functions in the DSD
RBAC model context is that they should enforce the DSD constraints. For ex-
ample, during the invocation of the CreateSession function, the default active
role set that is made available to the user should not violate any of the DSD
constraints. Similarly, the AddActiveRole function shall check and prevent the
addition of any active role to the session’s active role set that violates any of
the DSD constraints.
The semantics of the Supporting System Functions for a DSD RBAC model
with role hierarchies (both General Role Hierarchy and Limited Role Hierarchy)
are the same as those for corresponding functions for hierarchical RBAC in
Section 4.2.2:
—CreateSession: creates a user session and provides the user with a default
set of active roles;
—AddActiveRole: adds a role as an active role for the current session; and
—DropActiveRole: deletes a role from the active role set for the current session.
4.4.3 Review Functions. All the review functions for the Core RBAC model
are needed for implementation of the DSD RBAC model. In addition, functions
to view the results of administrative functions listed in Section 4.4.1 shall also
be provided. These include: (a) a function to reveal the set of named DSD re-
lations created, (b) a function that returns the set of roles associated with a
named DSD role set, and (c) a function that gives the cardinality of the subset
within the named DSD role set for which common user membership restriction
applies.
—DSDRoleSets: returns the set of named SSD relations created for the DSD
RBAC model;
—DSDRoleSetRoles: returns the set of roles associated with a named DSD role
set; and
—DSDRoleSetCardinality: returns the cardinality of the subset within the
named DSD role set for which user activation restriction within the same
session applies.
5. FUNCTIONAL SPECIFICATION PACKAGES
As discussed in Section 1, RBAC is a technology that provides a diverse set
of access control management features. In a categorization of these features,
Section 4 defined a family of four functional components to include Core RBAC,
Hierarchical RBAC, Static Separation of Duty Relations, and Dynamic Sepa-
ration of Duty Relations. Each functional component includes three sections:
administrative operations for the creation and maintenance of RBAC sets and
relations, administrative review functions, and system level functions for the
binding of roles to a user’s session and making access control decisions.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
248 • D. F. Ferraiolo et al.
Fig. 7. Methodology for creating functional packages.
In this section we describe a logical approach for defining packages of func-
tional components, where each package may pertain to a different threat envi-
ronment and/or market segment. The basic concept is that each component can
optionally be selected for inclusion into a package with one exception—Core
RBAC must be included as a part of all packages. In selecting components,
the reader is referred to Section 2 for a rationale of each component. Also, see
Figure 7 for an overview of the methodology for composing functional packages.
In defining functional packages Core RBAC is unique in that it is funda-
mental and must be included in all packages. As such any package must begin
with the selection of the Core RBAC. Core RBAC includes an advanced review
feature that may be optionally selected. For some environments the selection
of the single Core RBAC component may be sufficient.
Hierarchical RBAC includes two subcomponents: General Role Hierarchies
and Limited Role Hierarchies. If Hierarchical RBAC is selected to be included
in a package then a choice must be made as to which of these subcomponents
is to be included. Like Core RBAC, Hierarchical RBAC includes an advanced
review feature that may be optionally selected.
The Static Separation of Duty Relations component also includes two sub-
components: Static Separation of Duty Relations and Static Separation of Duty
Relations in the Presence of a Hierarchy. If this component is selected for in-
clusion in a package then a dependency relation must be recognized. That is, if
the package includes a Hierarchical RBAC component then Static Separation
of Duty Relations in the Presence of a Hierarchy must be included in the pack-
age; otherwise the Static Separation of Duty Relations subcomponent must be
selected.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 249
The final component is Dynamic Separation of Duty Relations. This com-
ponent does not include any options or dependency relations other than with
Core RBAC.
6. CONCLUSIONS
The driving motivation for RBAC is to simplify security policy administration
while facilitating the definition of flexible customized policies. Over the past
nine years significant advancements have been made in both the theoretical
modeling and practical implementation of RBAC features. Today RBAC is com-
ing to be expected among large organizations and the number of vendors that
offer RBAC features is growing rapidly. This development continues without
general agreement on RBAC features. This article is a first attempt to develop
an authoritative definition of well-accepted RBAC features for use in autho-
rization management systems. Although RBAC continues to be an evolving
technology, the RBAC features that were chosen to be included within this pro-
posed standard represent a stable and well-accepted set of features, and are
known to be included within a wide breadth of commercial products and refer-
ence implementations.
Standardization over a stable set of RBAC features is expected to provide a
multitude of benefits, including a common set of benchmarks for vendors, who
are already developing RBAC mechanisms, to use in their product specifica-
tions. It will give IT consumers, who are the principle beneficiaries of RBAC
technology, a basis for the creation of uniform acquisition specifications. In
addition, an RBAC standard will allow for the subsequent development of a
standard RBAC API that would in turn promote the development of innovative
authorization management tools by guaranteeing interoperability and porta-
bility.
Although RBAC is often considered a single access control and authorization
model, it is in fact composed of a number of models each fit for a specific secu-
rity management application. RBAC is also an open-ended technology, which
ranges from the very simple to fairly sophisticated, as defined in numerous
RBAC models and system specifications. Although these models and product
specifications seem to agree on a fundamental set of RBAC concepts, they differ
significantly in their terminology.
To address these issues, this proposed standard specifies a Reference Model,
defined as a collection of four model components. The model components are
intended to provide a standard vocabulary of relevant terms for defining a
broad range of RBAC features. This proposed standard also includes an RBAC
Functional Specification that casts the reference model into a congruent set
of functional components, where each component defines specific requirements
for administrative operations to create and maintain RBAC sets and relations,
review functions, and system features pertaining to the corresponding model
component.
RBAC functional model components can be combined into a variety of pack-
ages to arrive at a relevant collection of requirements for product develop-
ment, system evaluation, or system acquisition specification. To facilitate this
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
250 • D. F. Ferraiolo et al.
packaging of requirements a rationale for the selection of components has been
provided.
APPENDIX A: RBAC FUNCTIONAL SPECIFICATION
The RBAC Functional Specification specifies administrative operations for the
creation and maintenance of RBAC element sets and relations, administrative
review functions for performing administrative queries, and system functions
for creating and managing RBAC attributes on user sessions and making access
control decisions. Functions are defined with sufficient precision to meet the
needs of conformance testing and assurance, while providing developers with
design flexibility and the ability to incorporate additional features to meet the
needs of users.
The notation used in the formal specification of the RBAC requirements is
basically a subset of the Z notation. The only major change is the representation
of a schema:
Schema-Name (Declaration) C Predicate; . . . ; Predicate B.
Most abstract data types and functions used in the formal specification are
defined in Section 3, RBAC Reference Model. New abstract data types and
functions are introduced as needed. NAME is an abstract data type whose
elements represent identifiers of entities that may or may not be included in
the RBAC system (roles, users, sessions, etc.).
A.1 Requirements for Core RBAC
A.1.1 Administrative Commands for Core RBAC
AddUser: This command creates a new RBAC user. The command is valid
only if the new user is not already a member of the USERS data set. The USER
data set is updated. The new user does not own any session at the time of its
creation. The following schema formally describes the command AddUser.
AddUser(user : NAME) C
user 6∈ USERS
USERS′ = USERS ∪ {user}
user sessions′ = user sessions ∪ {user 7→ Ø}B
DeleteUser: This command deletes an existing user from the RBAC database.
The command is valid if and only if the user to be deleted is a member of
the USERS data set. The USERS and UA data sets and the assigned users
function are updated. It is an implementation decision how to proceed with
the sessions owned by the user to be deleted. The RBAC system could wait
for such a session to terminate normally, or it could force its termination. Our
presentation illustrates the case when those sessions are forcefully terminated.
The following schema formally describes the command DeleteUser.
DeleteUser(user: NAME)C
user ∈ USERS
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 251
[∀s ∈ SESSIONS • s ∈ user sessions(user)⇒ DeleteSession(s)]
UA′ = UA\{r: ROLES • user 7→ r}
assigned users′ = {r: ROLES • r 7→ (assigned users(r)\{user})}
USERS′ = USERS \{user}B
AddRole: This command creates a new role. The command is valid if and only
if the new role is not already a member of the ROLES data set. The ROLES data
set and the functions assigned users and assigned permissions are updated.
Initially, no user or permission is assigned to the new role. The following schema
formally describes the command AddRole.
AddRole(role : NAME) C
role 6∈ ROLES
ROLES′ = ROLES ∪ {role}
assigned users′ = assigned users ∪ {role 7→ Ø}
assigned permissions′ = assigned permissions ∪ {role 7→ Ø}B
DeleteRole: This command deletes an existing role from the RBAC database.
The command is valid if and only if the role to be deleted is a member of the
ROLES data set. It is an implementation decision how to proceed with the ses-
sions in which the role to be deleted is active. The RBAC system could wait
for such a session to terminate normally, it could force the termination of that
session, or it could delete the role from that session while allowing the ses-
sion to continue. Our presentation illustrates the case when those sessions are
forcefully terminated.
DeleteRole(role: NAME) C
role ∈ ROLES
[∀s ∈ SESSIONS • role ∈ session roles(s)⇒ DeleteSession(s)]
UA′ = UA\{u: USERS • u 7→ role}
assigned users′ = assigned users\{role 7→ asigned users (role)}
PA′ = PA\{op: OPS, obj: OBJS • (op, obj) 7→ role}
assigned permissions′ = assigned permissions \
{role 7→ assigned permissions(role)}
ROLES′ = ROLES\{role}B
AssignUser: This command assigns a user to a role. The command is valid if
and only if the user is a member of the USERS data set, the role is a member of
the ROLES data set, and the user is not already assigned to the role. The data
set UA and the function assigned users are updated to reflect the assignment.
The following schema formally describes the command.
AssignUser(user, role: NAME) C
user ∈ USERS; role ∈ ROLES; (user 7→ role) 6∈ UA
UA′ = UA ∪ {user 7→ role}
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
252 • D. F. Ferraiolo et al.
assigned users′ = assigned users \{role 7→ assigned users(role)} ∪
{role 7→ (assigned users (role) ∪ {user})}B
DeassignUser: This command deletes the assignment of the user user to the
role role. The command is valid if and only if the user is a member of the USERS
data set, the role is a member of the ROLES data set, and the user is assigned
to the role. It is an implementation decision how to proceed with the sessions
in which the session user is user and one of his or her active roles is role. The
RBAC system could wait for such a session to terminate normally, could force its
termination, or could inactivate the role. Our presentation illustrates the case
when those sessions are forcefully terminated. The following schema formally
describes the command DeassignUser.
DeassignUser(user, role: NAME) C
user ∈ USERS; role ∈ ROLES; (user 7→ role) ∈ UA
[∀s: SESSIONS • s ∈ user sessions(user) ∧ role ∈ session roles(s)⇒
DeleteSession(s)]
UA′ = UA\{user 7→ role}
assigned users′ = assigned users \{role 7→ assigned users(role)} ∪
{role 7→ (asigned users (role)\{user})}B
GrantPermission: This command grants a role the permission to perform an
operation on an object to a role. The command may be implemented as granting
permissions to a group corresponding to that role, that is, setting the access
control list of the object involved. The command is valid if and only if the pair
(operation, object) represents a permission, and the role is a member of the
ROLES data set. The following schema formally defines the command.
GrantPermission(object, operation, role: NAME) C
(operation, object) ∈ PERMS; role ∈ ROLES
PA′ = PA ∪ {(operation, object) 7→ role}
assigned permissions′ = assigned permissions\
{role 7→ assigned permissions(roles)} ∪
{role 7→ (assigned permissions (role) ∪ {(operation, object)})} B
RevokePermission: This command revokes the permission to perform an op-
eration on an object from the set of permissions assigned to a role. The command
may be implemented as revoking permissions from a group corresponding to
that role, that is, setting the access control list of the object involved. The com-
mand is valid if and only if the pair (operation, object) represents a permission,
the role is a member of the ROLES data set, and the permission is assigned to
that role. The following schema formally describes the command.
RevokePermission(operation, object, role: NAME) C
(operation, object) ∈ PERMS; role ∈ ROLES;
((operation, object) 7→ role) ∈ PA
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 253
PA′ = PA\{(operation, object) 7→ role}
assigned permissions′ = assigned permissions\
{role 7→ assigned permissions(role)} ∪
{role 7→ (assigned permissions(role)\{(operation, object)})}B
A.1.2 System Functions for Core RBAC
CreateSession(user, session): This function creates a new session with a given
user as owner and an active role set. The function is valid if and only if:
—the user is a member of the USERS data set, and
—the active role set is a subset of the roles assigned to that user. In an RBAC
implementation, the session’s active roles might actually be the groups that
represent those roles.
The following schema formally describes the function. The session parameter,
which represents the session identifier, is actually generated by the underlying
system.
CreateSession(user: NAME; ars:2NAMES; session: NAME )C
user ∈ USERS; ars ⊆ {r: ROLES | (user 7→ r) ∈ UA}; session 6∈ SESSIONS
SESSIONS′ = SESSIONS ∪ {session}
user sessions′ = user sessions \{user 7→ user sessions(user)} ∪
{user 7→ (user sessions(user) ∪ {session})}
session roles′ = session roles ∪ {session 7→ ars}B
DeleteSession(user, session): This function deletes a given session with a
given owner user. The function is valid if and only if the session identifier is a
member of the SESSIONS data set, the user is a member of the USERS data
set, and the session is owned by the given user. The following schema formally
describes the function.
DeleteSession(user, session: NAME) C
user ∈ USERS; session ∈ SESSIONS; sessions ∈ user sessions(user)
user sessions′ = user sessions\{user 7→ user sessions(user)} ∪
{user 7→ (user sessions(user)\{session})}
session roles′ = session roles\{session 7→ session roles(session)}
SESSIONS′ = SESSIONS\{session} B
AddActiveRole: This function adds a role as an active role of a session whose
owner is a given user. The function is valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the session identifier is a member of the SESSIONS data set,
—the role is assigned to the user, and
—the session is owned by that user.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
254 • D. F. Ferraiolo et al.
In an implementation, the new active role might be a group that corresponds
to that role. The following schema formally describes the function.
AddActiveRole(user, session, role: NAME) C
user ∈ USERS; session ∈ SESSIONS; role ∈ ROLES;
session ∈ user sessions(user)
(user 7→ role) ∈ UA; role 6∈ session roles(session)
session roles′ = session roles\{session 7→ session roles(session)} ∪
{session 7→ (session roles(session) ∪ {role})} B
DropActiveRole: This function deletes a role from the active role set of a
session owned by a given user. The function is valid if and only if the user is
a member of the USERS data set, the session identifier is a member of the
SESSIONS data set, the session is owned by the user, and the role is an active
role of that session. The following schema formally describes this function.
DropActiveRole(user, session, role: NAME) C
user ∈ USERS; role ∈ ROLES; session ∈ SESSIONS
session ∈ user sessions(user); role ∈ session roles(session)
session roles′ = session roles\{session 7→ session roles(session)} ∪
{session 7→ (session roles(session)\{role}) B
CheckAccess: This function returns a Boolean value meaning the subject of
a given session is or is not allowed to perform a given operation on a given
object. The function is valid if and only if the session identifier is a member
of the SESSIONS data set, the object is a member of the OBJS data set, and
the operation is a member of the OPS data set. The session’s subject has the
permission to perform the operation on that object if and only if that permis-
sion is assigned to (at least) one of the session’s active roles. An implementation
might use the groups that correspond to the subject’s active roles and their per-
missions as registered in the object’s access control list. The following schema
formally describes the function.
CheckAccess(session, operation, object: NAME; out result: BOOLEAN) C
session ∈ SESSIONS; operation ∈ OPS; object ∈ OBJS
result = (∃r:ROLES • r ∈ session roles(session) ∧
((operation, object) 7→ r) ∈ PA) B
A.1.3 Review Functions for Core RBAC
AssignedUsers: This function returns the set of users assigned to a given
role. The function is valid if and only if the role is a member of the ROLES data
set. The following schema formally describes the function.
AssignedUsers(role: NAME; out result:2USERS) C
role ∈ ROLES
result = {u: USERS | (u 7→ role) ∈ UA} B
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 255
AssignedRoles: This function returns the set of roles assigned to a given user.
The function is valid if and only if the user is a member of the USERS data set.
The following schema formally describes the function.
AssignedRoles(user: NAME; result:2ROLES) C
user ∈ USERS
result = {r: ROLES | (user 7→ r) ∈ UA} B
A.1.4 Advanced Review Functions for Core RBAC
RolePermissions: This function returns the set of permissions (op, obj) gran-
ted to a given role. The function is valid if and only if the role is a member of
the ROLES data set. The following schema formally describes the function.
RolePermissions(role: NAME; result:2PERMS) C
role ∈ ROLES
result = {op: OPS; obj: OBJS | ((op, obj) 7→ role) ∈ PA} B
UserPermissions: This function returns the permissions a given user gets
through his or her assigned roles. The function is valid if and only if the user
is a member of the USERS data set. The following schema formally describes
this function.
UserPermissions(user: NAME; result:2PERMS) C
user ∈ USERS
result = {r: ROLES; op: OPS; obj: OBJS | (user 7→ r) ∈ UA ∧
((op; obj) 7→ r) ∈ PA • (op, obj)} B
SessionRoles: This function returns the active roles associated with a ses-
sion. The function is valid if and only if the session identifier is a mem-
ber of the SESSIONS data set. The following schema formally describes
this function.
SessionRoles(session: NAME; out result:2ROLES) C
session ∈ SESSIONS
result = session roles(session) B
SessionPermissions: This function returns the permissions of the session
session, that is, the permissions assigned to its active roles. The function is
valid if and only if the session identifier is a member of the SESSIONS data
set. The following schema formally describes this function.
SessionPermissions(session: NAME; out result:2PERMS) C
session ∈ SESSIONS
result = {r: ROLES; op ∈ OPS; obj ∈ OBJS | r ∈ session roles(session) ∧
((op, obj) 7→ r) ∈ PA • (op, obj)} B
RoleOperationsOnObject: This function returns the set of operations a given
role is permitted to perform on a given object. The function is valid only if the
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
256 • D. F. Ferraiolo et al.
role is a member of the ROLES data set, and the object is a member of the
OBJS data set. The following schema formally describes the function.
RoleOperationsOnObject(role: NAME; obj: NAME; result:2OPS) C
role ∈ ROLES
obj ∈ OBJS
result = {op: OPS | ((op, obj) 7→ role ∈ PA} B
UserOperationsOnObject: This function returns the set of operations a given
user is permitted to perform on a given object, obtained either directly or
through his or her assigned roles. The function is valid if and only if the user is
a member of the USERS data set and the object is a member of the OBJS data
set. The following schema formally describes this function.
UserOperationsOnObject(user: NAME; obj: NAME; result:2OPS) C
user ∈ USERS
obj ∈ OBJS
result = {r: ROLES; op: OPS | (user 7→ r)
∈ UA∧ ((op, obj) 7→ r) ∈ PA • op} B
A.2 Requirements for Hierarchical RBAC
A.2a General Role Hierarchies
A.2a.1 Administrative Commands for General Role Hierarchies
All functions of Section A.1.1 remain valid. In addition, this section defines the
following new specific functions.
AddInheritance: This command establishes a new immediate inheritance re-
lationship r asc  r desc between existing roles r asc, r desc. The command
is valid if and only if r asc and r desc are members of the ROLES data set,
r asc is not an immediate ascendant of r desc, and r desc does not properly
inherit r asc (in order to avoid cycle creation). The following schema uses the
notations
≥ == 
 == 
to formally describe the command
AddInheritance(r asc, r desc: NAME) C
r asc ∈ ROLES; r desc ∈ ROLES;¬(r asc r desc);¬(r desc ≥ r asc)
≥′ = ≥ ∪{r, q: ROLES | r ≥ r asc ∧ r desc ≥ q • r 7→ q} B
DeleteInheritance: This command deletes an existing immediate inheritance
relationship r asc  r desc. The command is valid if and only if the roles
r asc and r desc are members of the ROLES data set, and r asc is an im-
mediate ascendant of r desc. The new inheritance relation is computed as the
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 257
reflexive-transitive closure of the immediate inheritance relation resulting af-
ter deleting the relationship r asc  r desc. In this definition, implied rela-
tionships are preserved after deletion. The following schema formally describes
this command.
DeleteInheritance(r asc, r desc: NAME) C
r asc ∈ ROLES; r desc ∈ ROLES; r asc >> r desc
≥′= (\{r asc 7→ r desc})∗ B
AddAscendant: This command creates a new role r asc, and inserts it in
the role hierarchy as an immediate ascendant of the existing role r desc. The
command is valid if and only if r asc is not a member of the ROLES data
set, and r desc is a member of the ROLES data set. Note that the validity
conditions are verified in the schemas AddRole and AddInheritance, referred
to by AddAscendant.
AddAscendant(r asc, r desc: NAME) C
AddRole(r asc)
AddInheritance(r asc, r desc) B
AddDescendant: This command creates a new role r desc, and inserts it
in the role hierarchy as an immediate descendant of the existing role r asc.
The command is valid if and only if r desc is not a member of the ROLES
data set, and r asc is a member of the ROLES data set. Note that the validity
conditions are verified in the schemas AddRole and AddInheritance, referred
to by AddDescendant.
AddDescendant(r asc, r desc: NAME) C
AddRole(r desc)
AddInheritance(r asc, r desc) B
A.2a.2 System Functions for General Role Hierarchies
This section redefines the functions CreateSession and AddActiveRole of
Section A.1.2. The other functions of Section A.1.2 remain valid.
CreateSession(user, session): This function creates a new session with a given
user as owner and a given set of active roles. The function is valid if and
only if:
—the user is a member of the USERS data set, and
—the active role set is a subset of the roles authorized for that user. Note that if
a role is active for a session, its descendants or ascendants are not necessarily
active for that session. In an RBAC implementation, the session’s active roles
might actually be the groups that represent those roles.
The following schema formally describes the function. The parameter session,
which identifies the session, is actually generated by the underlying system.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
258 • D. F. Ferraiolo et al.
CreateSession(user: NAME; ars:2NAME; session: NAME) C
user ∈ USERS; ars ⊆ {r, q: ROLES | (user 7→ q) ∈ UA ∧
q ≥ r • r}; session 6∈ SESSIONS
SESSIONS′ = SESSIONS ∪ {session}
user sessions′ = user sessions\{user 7→ user sessions(user)} ∪
{user 7→ (user sessions(user) ∪ {sessions})}
session roles′ = session roles ∪ {session 7→ ars} B
AddActiveRole: This function adds a role as an active role of a session whose
owner is a given user. The function is valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the session identifier is a member of the SESSIONS data set,
—the user is authorized for that role, and
—the session is owned by that user.
The following schema formally describes the function.
AddActiveRole(user, session, role: NAME) C
user ∈ USERS; session ∈ SESSIONS; role
∈ ROLES; session ∈ user sessions(user)
user ∈ authorized users(role); role 6∈ session roles(session)
session roles′ = session roles\{session 7→ session roles(sessions)} ∪
{session 7→ (session roles(session) ∪ {role})} B
A.2a.3 Review Functions for General Role Hierarchies
All functions of Section A.1.3 remain valid. In addition, this section defines the
following review functions.
AuthorizedUsers: This function returns the set of users authorized for a given
role, that is, the users that are assigned to a role that inherits the given role.
The function is valid if and only if the given role is a member of the ROLES
data set. The following schema formally describes the function.
AuthorizedUsers(role: NAME; out result:2USERS) C
role ∈ ROLES
result = authorized users(role) B
AuthorizedRoles: This function returns the set of roles authorized for a given
user. The function is valid if and only if the user is a member of the USERS
data set. The following schema formally describes the function.
AuthorizedRoles(user: NAME; result:2ROLES) C
user ∈ USERS
result = {r, q: ROLES | (user 7→ q) ∈ UA ∧ q ≥ r} B
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 259
A.2a.4 Advanced Review Functions for General Role Hierarchies
This section redefines the functions RolePermissions and UserPermissions of
Section A.1.4. All other functions of Section A.1.4 remain valid.
RolePermissions: This function returns the set of all permissions (op, obj),
granted to or inherited by a given role. The function is valid if and only if
the role is a member of the ROLES data set. The following schema formally
describes the function.
RolePermission(role: NAME; result:2PERMS) C
role ∈ ROLES
result = {q: ROLES; op: OPS; obj: OBJS | (role ≥ q) ∧
((op, obj) 7→ role) ∈ PA • (op, obj)} B
UserPermissions: This function returns the set of permissions a given user
gets through his or her authorized roles. The function is valid if and only if
the user is a member of the USERS data set. The following schema formally
describes this function.
UserPermissions(user: NAME; result:2PERMS) C
user ∈ USERS
result = {r, q: ROLES; op: OPS; obj: OBJS | (user 7→ q) ∈ UA ∧ (q ≥ r) ∧
((op, obj) 7→ r) ∈ PA • (op, obj)})} B
RoleOperationsOnObject: This function returns the set of operations a given
role is permitted to perform on a given object. The set contains all operations
granted directly to that role or inherited by that role from other roles. The func-
tion is valid only if the role is a member of the ROLES data set, and the object
is a member of the OBJS data set. The following schema formally describes the
function.
RoleOperationsOnObject(role: NAME; obj: NAME; result:2OPS) C
role ∈ ROLES
obj ∈ OBJS
result = {q: ROLES; op: OPS | (role ≥ q) ∧ ((op, obj) 7→ role) ∈ PA • op} B
UserOperationsOnObject: This function returns the set of operations a given
user is permitted to perform on a given object. The set consists of all the op-
erations obtained by the user either directly or through his or her authorized
roles. The function is valid if and only if the user is a member of the USERS
data set and the object is a member of the OBJS data set. The following schema
formally describes this function.
UserOperationsOnObject(user: NAME; obj: NAME; result:2OPS) C
user ∈ USERS
obj ∈ OBJS
result = {r, q: ROLES; op: OPS | (user 7→ q) ∈ UA ∧ (q ≥ r) ∧
((op, obj) 7→ r) ∈ PA • op} B
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
260 • D. F. Ferraiolo et al.
A.2b Limited Role Hierarchies
A.2b.1 Administrative Commands for Limited Role Hierarchies
This section redefines the function AddInheritance of Section A.2a.1. All other
functions of Section A.2a.1 remain valid.
AddInheritance: This command establishes a new immediate inheritance re-
lationship r asc  r desc between existing roles r asc, r desc. The command
is valid if and only if r asc and r desc are members of the ROLES data set,
r asc has no descendants, and r desc does not properly inherit r asc (in order
to avoid cycle creation). The following schema uses the notations
≥ == 
 == 
to formally describe the command
AddInheritance(r asc, r desc: NAME) C
r asc ∈ ROLES; r desc ∈ ROLES; ∀r ∈ ROLES • ¬(r asc >> r);
¬(r desc ≥ r asc)
≥′ = ≥ ∪{r, q: ROLES | r ≥ r asc ∧ r desc ≥ q • r 7→ q} B
A.2b.2 System Functions for Limited Role Hierarchies
All functions of Section A.2a.2 remain valid.
A.2b.3 Review Functions for Limited Role Hierarchies
All functions of Section A.2a.3 remain valid.
A.2b.4 Advanced Review Functions for Limited Role Hierarchies
All functions of Section A.2a.4 remain valid.
A.3 Requirements for Static Separation of Duty Relations
The static separation of duty property, as defined in the model, uses a collection
SSD of pairs of a role set and an associated cardinality. We define the new
data type SSD, which in an implementation could be the set of names used to
identify the pairs in the collection.
The functions ssd set and, respectively, ssd card are used to obtain the role
set and the associated cardinality from each SSD pair:
ssd set: SSD→ 2ROLES
ssd card: SSD→ N
∀ssd ∈ SSD • ssd card(ssd) ≥ 2 ∧ ssd card(ssd) ≤ |ssd set(ssd)|
A.3a SSD Relations
A.3a.1 Administrative Commands for SSD Relations
This section redefines the function AssignUser of Section A.1.1 and defines a
set of new specific functions. The other functions of Section A.1.1 remain valid.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 261
AssignUser: The AssignUser command replaces the command with the same
name of Core RBAC. This command assigns a user to a role. The command is
valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the user is not already assigned to the role, and
—the SSD constraints are satisfied after assignment.
The data set UA and the function assigned users are updated to reflect the
assignment. The following schema formally describes the command.
AssignUser(user, role: NAME) C
user ∈ USERS; role ∈ ROLES; (user 7→ role) 6∈ UA
∀ssd ∈ SSD •
⋂
r∈subset
(assigned users(r) ∪ us) = Ø
subset⊆ssd set(ssd )
|subset|=ssd card(ssd )
us=if r=role then {user} else Ø
UA′ = UA ∪ {user 7→ role}
assigned users′ = assigned users\{role 7→ assigned users(role)} ∪
{role 7→ (assigned users(role) ∪ {user})} B
CreateSsdSet: This command creates a named SSD set of roles and sets the
cardinality n of its subsets that cannot have common users. The command is
valid if and only if:
—the name of the SSD set is not already in use,
—all the roles in the SSD set are members of the ROLES data set,
—n is a natural number greater than or equal to 2 and less than or equal to the
cardinality of the SSD role set, and
—the SSD constraint for the new role set is satisfied.
The following schema formally describes this command:
CreateSsdSet(set name: NAME; role set:2NAMES; n:N) C
set name 6∈ SSD; (n ≥ 2) ∧ (n ≤ |role set| ); role set ⊆ ROLES⋂
assigned users(r) = Ø
r∈subset
subset⊆role set
|subset|=ii
SSD′ = SSD ∪ {set name}
ssd set′ = ssd set ∪ {set name 7→ role set}
ssd card′ = ssd card ∪ {set name 7→ n} B
AddSsdRoleMember: This command adds a role to a named SSD set of roles.
The cardinality associated with the role set remains unchanged. The command
is valid if and only if:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
262 • D. F. Ferraiolo et al.
—the SSD role set exists,
—the role to be added is a member of the ROLES data set but not of a member
of the SSD role set, and
—the SSD constraint is satisfied after the addition of the role to the SSD
role set.
The following schema formally describes the command.
AddSsdRoleMember(set name: NAME; role: NAME) C
set name ∈ SSD; role ∈ ROLE; role 6∈ ssd set(set name)⋂
assigned users(r) = Ø
r∈subset
subset⊆sss set(set name)∪{role}
|subset|=n
ssd set′ = ssd set\{set name 7→ ssd set(set name)} ∪
{set name 7→ (ssd set(set name) ∪ {role})} B
DeleteSsdRoleMember: This command removes a role from a named SSD set
of roles. The cardinality associated with the role set remains unchanged. The
command is valid if and only if:
—the SSD role set exists,
—the role to be removed is a member of the SSD role set, and
—the cardinality associated with the SSD role set is less than the number of
elements of the SSD role set.
Note that the SSD constraint should be satisfied after the removal of the role
from the SSD role set. The following schema formally describes the command.
DeleteSsdRoleMember(set name: NAME; role: NAME) C
set name ∈ SSD; role ∈ ssd set(set name);
ssd card (set name) < |ssd set(set name)|
ssd set′ = ssd set\{set name 7→ ssd set(set name)} ∪
{set name 7→ (ssd set(set name)\{role})} B
DeleteSsdSet: This command deletes an SSD role set completely. The com-
mand is valid if and only if the SSD role set exists. The following schema for-
mally describes the command.
DeleteSsdSet(set name: NAME) C
set name ∈ SSD; ssd card′ = ssd card\{set name 7→ ssd card(set name)}
ssd set′ = ssd set\{set name 7→ ssd set(set name)}
SSD′ = SSD\{set name} B
SetSsdSetCardinality: This command sets the cardinality associated with a
given SSD role set. The command is valid if and only if:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 263
—the SSD role set exists,
—the new cardinality is a natural number greater than or equal to 2 and less
than or equal to the number of elements of the SSD role set, and
—the SSD constraint is satisfied after setting the new cardinality.
The following schema formally describes the command.
SetSsdSetCardinality(set name: NAME; n:N) C
set name ∈ SSD; (n ≥ 2) ∧ (n ≤ |ssd set(set name)|)⋂
assigned users(r) = Ø
r∈subset
subset⊆ssd set(set name)
|subset|=n
ssd card′ = ssd card\{set name 7→ ssd card(set name)} ∪ {set name 7→ n} B
A.3a.2 System Functions for SSD
All functions in Section A.1.2 remain valid.
A.3a.3 Review Functions for SSD
All functions in Section A.1.3 remain valid. In addition, this section defines the
following functions.
SsdRoleSets: This function returns the list of all SSD role sets. The following
schema formally describes the function.
SsdRoleSets(out result:2NAME) C result=SSD B
SsdRoleSetRoles: This function returns the set of roles of a SSD role set. The
function is valid if and only if the role set exists. The following schema formally
describes the function.
SsdRoleSetRoles(set name: NAME; out result:2ROLES) C
set name ∈ SSD
result = ssd set(set name) B
SsdRoleSetCardinality: This function returns the cardinality associated with
a SSD role set. The function is valid if and only if the role set exists. The
following schema formally describes the function.
SsdRoleSetCardinality(set name: NAME; out result: N) C
set name ∈ SSD
result = ssd card(set name) B
A.3a.4 Advanced Review Functions for SSD
All functions in Section A.1.4 remain valid.
A.3b SSD Relations with General Role Hierarchies
A.3b.1 Administrative Commands for SSD with General Role Hierarchies
This section redefines the functions AssignUser and AddInheritance of Section
A.2a.1, and the functions CreateSsdSet, AddSsdRoleMember, and SetSsdSet
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
264 • D. F. Ferraiolo et al.
Cardinality of Section A.3a.1. The other functions of Sections A.2a.1 and A.3a.1
remain valid.
AssignUser: The command AssignUser replaces the command with the same
name from Core RBAC with Static Separation of Duties. This command assigns
a user to a role. The command is valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the user is not already assigned to the role, and
—the SSD constraints are satisfied after assignment.
The data set UA and the function assigned users are updated to reflect the
assignment. The following schema formally describes the command.
AssignUser(user, role: NAME) C
user ∈ USERS; role ∈ ROLES; (user 7→ role) 6∈ UA
∀ssd ∈ SSD •
⋂
r∈subset
(authorized users(r) ∪ au) = Ø
subset⊆ssd set(ssd )
|subset|=ssd card(ssd)
au=if r=role then (user) else Ø
UA′ = UA ∪ {user 7→ role}
assigned users′ = assigned users\{role 7→ assigned users(role)} ∪
{role 7→ (assigned users(role) ∪ {user})} B
AddInheritance: This command establishes a new immediate inheritance re-
lationship r asc  r desc between existing roles r asc, r desc. The command
is valid if and only if:
—r asc and r desc are members of the ROLES data set,
—r asc is not an immediate ascendant of r desc,
—r desc does not properly inherit r asc, and
—the SSD constraints are satisfied after establishing the new inheritance.
The following schema uses the notations
≥ == 
 == 
to formally describes the command
AddInheritance(r asc, r desc: NAME) C
r asc ∈ ROLES; r desc ∈ ROLES;¬(r asc r desc);¬(r desc ≥ r asc)
∀ssd ∈ SSD •
⋂
r∈subset
(authorized users(r) ∪ au) = Ø
subset⊆ssd set(ssd )
|subset|=ssd card(ssd)
au=if r=r desc then authorized user(r asc) else Ø
≥′ = ≥ ∪{r, q: ROLES | r ≥ r asc ∧ r desc ≥ q • r 7→ q} B
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 265
CreateSsdSet: This command creates a named SSD set of roles and sets the
associated cardinality n of its subsets that cannot have common users. The
command is valid if and only if:
—the name of the SSD set is not already in use,
—all the roles in the SSD set are members of the ROLES data set,
—n is a natural number greater than or equal to 2 and less than or equal to the
cardinality of the SSD role set, and
—the SSD constraint for the new role set is satisfied.
The following schema formally describes this command.
CreateSsdSet(set name: NAME; role set: 2NAMES; n: N) C
set name 6∈ SSD; (n ≥ 2) ∧ (n ≤ |role set|); role set ⊆ ROLES⋂
authorized users(r) = Ø
r∈subset
subset⊆role set
|subset|=n
SSD′ = SSD ∪ {set name}
ssd set′ = ssd set ∪ {set name 7→ role set}
ssd card′ = ssd card ∪ {set name 7→ n} B
AddSsdRoleMember: This command adds a role to a named SSD set of roles.
The cardinality associated with the role set remains unchanged. The command
is valid if and only if:
—the SSD role set exists,
—the role to be added is a member of the ROLES data set but not of a member
of the SSD role set, and
—the SSD constraint is satisfied after the addition of the role to the SSD role
set.
The following schema formally describes the command.
AddSsdRoleMember(set name: NAME; role: NAME) C
set name ∈ SSD; role ∈ ROLES; role 6∈ ssd set(set name)⋂
authorized users(r) = Ø
r∈subset
subset⊆ssd set(set name)∪{role}
|subset|=n
ssd set′ = ssd set\{set name 7→ ssd set(set name)} ∪
{set name 7→ (ssd set(set name) ∪ {role})} B
SetSsdSetCardinality: This command sets the cardinality associated with a
given SSD role set. The command is valid if and only if:
—the SSD role set exists,
—the new cardinality is a natural number greater than or equal to 2 and less
than or equal to the number of elements of the SSD role set, and
—the SSD constraint is satisfied after setting the new cardinality.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
266 • D. F. Ferraiolo et al.
The following schema formally describes the command.
SetSsdSetCardinality(set name: NAME; n: N) C
set name ∈ SSD; (n ≥ 2) ∧ (n ≤ |ssd set(set name)|)⋂
authorized users(r) = Ø
r∈subset
subset⊆ssd set(set name)
|subset|=n
ssd card′ = ssd card\{set name 7→ ssd card(set name)} ∪ {set name 7→n} B
A.3b.2 System Functions for SSD with General Role Hierarchies
All functions of Section A.2a.2 remain valid.
A.3b.3 Review Functions for SSD with General Role Hierarchies
All functions of Sections A.2a.3 and A.3a.3 remain valid.
A.3b.4 Advanced Review Functions for SSD with General Role Hierarchies
All functions of Section A.2a.4 remain valid.
A.3c SSD Relations with Limited Role Hierarchies
A.3c.1 Administrative Commands for SSD with Limited Role Hierarchies
This section redefines the function AddInheritance of Section A.3b.1. All other
functions of Section A.3b.1 remain valid.
AddInheritance: This command establishes a new immediate inheritance re-
lationship r asc  r desc between existing roles r asc, r desc. The command
is valid if and only if r asc and r desc are members of the ROLES data set,
r asc has no descendants, and r desc does not properly inherit r asc (in order
to avoid cycle creation). The following schema uses the notations
≥ == 
 == 
to formally describe the command
AddInheritance(r asc, r desc: NAME) C
r asc ∈ ROLES; r desc ∈ ROLES; ∀r ∈ ROLES •
¬(r asc r);¬(r desc ≥ r asc)
∀ssd ∈ SSD •
⋂
r∈subset
(authorized users(r) ∪ au) = Ø
subset⊆ssd set(ssd )
|subset|=ssd card(ssd)
au=if r=r desc then authorized users(r asc) else Ø
≥′ = ≥ ∪{r, q: ROLES|r ≥ r asc ∧ r desc ≥ q • r 7→ q} B
A.3c.2 System Functions for SSD with Limited Role Hierarchies
All functions of Section A.2a.2 remain valid.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 267
A.3c.3 Review Functions for SSD with Limited Role Hierarchies
All functions of Sections A.2a.3 and A.3a.3 remain valid.
A.3c.4 Advanced Review Functions for SSD with Limited Role Hierarchies
All functions of Sections A.2a.4 remain valid.
A.4 Requirements for Dynamic Separation of Duties (DSD) Relations
The Dynamic Separation of Duty property, as defined in the model, uses a
collection DSD of pairs of a role set and an associated cardinality. We define
the new data type DSD, which in an implementation could be the set of names
used to identify the pairs in the collection.
The functions dsd set and, respectively, dsd card are used to obtain the role
set and the associated cardinality from each DSD pair:
dsd set: DSD→ 2ROLES
dsd card: DSD→ N
∀dsd ∈ SSD • dsd card(dsd) ≥ 2 ∧ dsd card(dsd) ≤ |dsd set(dsd)|
4.4a DSD Relations
A.4a.1 Administrative Commands for DSD Relations
All functions of Section A.1.1 remain valid. In addition, this section defines the
following functions.
CreateDsdSet: This command creates a named DSD set of roles and sets an
associated cardinality n. The DSD constraint stipulates that the DSD role set
cannot contain n or more roles simultaneously active in the same session. The
command is valid if and only if:
—the name of the DSD set is not already in use,
—all the roles in the DSD set are members of the ROLES data set,
—n is a natural number greater than or equal to 2 and less than or equal to
the cardinality of the DSD role set, and
—the DSD constraint for the new role set is satisfied.
The following schema formally describes this command.
CreateDsdSet(set name: NAME; role set:2NAMES; n:N) C
set name 6∈ DSD; (n ≥ 2) ∧ (n ≤ |role set|); role set ⊆ ROLES
∀s: SESSIONS; role subet:2role set • role subset ⊆
session roles(s)⇒ |role subset| ≤ n
DSD′ = DSD ∪ {set name}
dsd set′ = dsd set ∪ {set name 7→ role set}
dsd card′ = dsd card ∪ {set name 7→ n} B
AddDsdRoleMember: This command adds a role to a named DSD set of roles.
The cardinality associated with the role set remains unchanged. The command
is valid if and only if:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
268 • D. F. Ferraiolo et al.
—the DSD role set exists,
—the role to be added is a member of the ROLES data set but not a member of
the DSD role set, and
—the DSD constraint is satisfied after the addition of the role to the DSD role
set.
The following schema formally describes the command.
AddDsdRoleMember(set name: NAME; role: NAME) C
set name ∈ DSD; role ∈ ROLES; role 6∈ dsd set(set name)
∀s: SESSIONS; role subset:2dsd set(set name)∪{role} •
role subset ⊆ session roles(s)⇒ |role subset| < dsd card(set name)
dsd set′ = dsd set\{set name 7→ dsd set(set name)} ∪
{set name 7→ (dsd set(set name) ∪ {role)} B
DeleteDsdRoleMember: This command removes a role from a named DSD set
of roles. The cardinality associated with the role set remains unchanged. The
command is valid if and only if:
—the DSD role set exists,
—the role to be removed is a member of the DSD role set, and
—the cardinality associated with the DSD role set is less than the number of
elements of the DSD role set.
Note that the DSD constraint should be satisfied after the removal of the role
from the DSD role set. The following schema formally describes the command.
DeleteDsdRoleMember(set name: NAME; role: NAME) C
set name ∈ DSD; role ∈ dsd set(set name);
dsd card(set name) < |dsd set(set name)|
dsd set′ = dsd set\{set name 7→ dsd set(set name)} ∪
{set name 7→ (dsd set(set name)\{role})} B
DeleteDsdSet: This command deletes a DSD role set completely. The com-
mand is valid if and only if the DSD role set exists. The following schema
formally describes the command.
DeleteDsdSet(set name: NAME)
{
set name ∈ DSD
dsd card′ = dsd card\{set name 7→ dsd card(set name)}
dsd set′ = dsd set\{set name 7→ dsd set(set name)}
DSD′ = DSD\{set name}
}
SetDsdSetCardinality: This command sets the cardinality associated with a
given DSD role set. The command is valid if and only if:
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 269
—the DSD role set exists,
—the new cardinality is a natural number greater than or equal to 2 and less
than or equal to the number of elements of the DSD role set, and
—the DSD constraint is satisfied after setting the new cardinality.
The following schema formally describes the command.
SetDsdSetCardinality(set name: NAME; n:N) C
set name ∈ DSD; (n ≥ 2) ∧ (n ≤ |dsd set(set name)|)
∀s: SESSIONS; role subset:2dsd set(set name) •
role subset ⊆ session roles(s)⇒ |role subset| < n
dsd card′ = dsd card\{set name 7→ dsd card(set name)} ∪
{set name 7→ n} B
A.4a.2 System Functions for DSD Relations
This section redefines the functions CreateSession and AddActiveRole of Sec-
tion A.1.2. The other functions of Section A.1.2 remain valid.
CreateSession: This function creates a new session whose owner is the user
user and a given active role set. The function is valid if and only if:
—the user is a member of the USERS data set,
—the session’s active role set is a subset of the roles assigned to the session’s
owner, and
—the session’s active role set satisfies the DSD constraints.
The following schema formally describes the function. The session parame-
ter, which identifies the new session, is actually generated by the underlying
system.
CreateSession(user: NAME; ars:2NAME; session: NAME) C
user ∈ USERS; ars ⊆ {r: ROLES|(user 7→ r) ∈ UA}; session 6∈ SESSIONS
∀dset: DSD; rset:2NAME •
rset ⊆ dsd set(dset) ∧ rset ⊆ ars⇒ |rset| < dsd card(dset)
SESSIONS′ = SESSIONS ∪ {session}
user sessions′ = user sessions\{user 7→ user sessions(user)} ∪
{user 7→ (user sessions(user) ∪ {session})}
session roles′ = session roles ∪ {session 7→ ars} B
AddActiveRole: This function adds a role as an active role of a session whose
owner is a given user. The function is valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the session identifier is a member of the SESSIONS data set,
—the role is assigned to the user,
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
270 • D. F. Ferraiolo et al.
—the old active role set completed with the role to be activated satisfies the
DSD constraints, and
—the session is owned by that user.
The following schema formally describes the function.
AddActiveRole(user, session, role: NAME) C
user ∈ USERS; session ∈ SESSIONS; role ∈ ROLES;
session ∈ user sessions(user)
user ∈ assigned user(role); role 6∈ session roles(session)
∀dset: DSD; rset:2NAME •
rset ⊆ dsd set(dset) ∧ rset ⊆ session roles(sessions) ∪ {role} ⇒
|rset| < dsd card(dset)
session roles′ = session roles\{session 7→ session roles(session)} ∪
{session 7→ (session roles(session) ∪ {role})} B
A.4a.3 Review Functions for DSD Relations
All functions of Sections A.1.3 remain valid. In addition, this section defines
new specific functions.
DsdRoleSets: This function returns the list of all DSD role sets. The following
schema formally describes the function.
DsdRoleSets(out result:2NAME) C result = DSD B
DsdRoleSetRoles: This function returns the set of roles of a DSD role set. The
function is valid if and only if the role set exists. The following schema formally
describes the function.
DsdRoleSetRoles(set name: NAME; out result:2ROLES) C
set name ∈ DSD
result = dsd set(set name) B
DsdRoleSetCardinality: This function returns the cardinality associated
with a DSD role set. The function is valid if and only if the role set exists.
The following schema formally describes the function.
DsdRoleSetCardinality(set name: NAME; out result:N) C
set name ∈ DSD
result = dsd card(set name) B
A.4a.4 Advanced Review Functions for DSD Relations
All functions of Sections A.1.4 remain valid.
A.4b DSD Relations with Role Hierarchies
A.4b.1 Administrative Commands for DSD Relations with General Role Hier-
archies
All functions of Sections A.4a.1 and A.2a.1 remain valid.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 271
A.4b.2 System Functions for DSD Relations with General Role Hierarchies
This section redefines the functions CreateSession and AddActiveRole of
Section A.1.2 (or A.2a.2). All other functions of Section A.1.2 remain valid.
CreateSession: This function creates a new session whose owner is the user
user and a given active role set. The function is valid if and only if:
—the user is a member of the USERS data set,
—the session’s active role set is a subset of the roles authorized for the session’s
owner, and
—the session’s active role set satisfies the DSD constraints.
The underlying system generates a new session identifier, which is included in
the SESSIONS data set. The following schema formally describes the function.
CreateSession(user: NAME; ars:2NAME; session: NAME) C
user ∈ USERS; ars ⊆ {r, q: ROLES|(user 7→ q) ∈ UA ∧ q ≥ r • r};
session 6∈ SESSIONS
∀dset: DSD; rset:2NAME •
rset ⊆ dsd set(dset) ∧ rset ⊆ ars⇒ |rset| < dsd card(dset)
SESSIONS′ = SESSIONS ∪ {session}
user sessions′ = user sessions\{user 7→ user sessions(user)} ∪
{user 7→ (user sessions(user) ∪ {session})}
session roles′ = session roles ∪ {session 7→ ars} B
AddActiveRole: This function adds a role as an active role of a session whose
owner is a given user. The function is valid if and only if:
—the user is a member of the USERS data set,
—the role is a member of the ROLES data set,
—the session identifier is a member of the SESSIONS data set,
—the role is authorized for that user,
—the old active role set completed with the role to be activated satisfies the
DSD constraints, and
—the session is owned by that user.
The following schema formally describes the function.
AddActiveRole(user, session, role: NAME) C
user ∈ USERS; session ∈ SESSIONS; role ∈ ROLES;
session ∈ user sessions(user)
user ∈ authorized users(role); role 6∈ session roles(session)
∀dset: DSD; rset:2NAME •
rset ⊆ dsd set(dset) ∧ rset ⊆ session roles(session) ∪ {role} ⇒
|rset| < dsd card(dset)
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
272 • D. F. Ferraiolo et al.
session roles′ = session roles\{session 7→ session roles(session)} ∪
{session 7→ (session roles(session) ∪ {role})} B
A.4b.3 Review Functions for DSD Relations with General Role Hierarchies
All functions of Sections A.4a.3 and A.2a.3 remain valid.
A.4b.3 Advanced Review Functions for DSD Relations with General Role
Hierarchies
All functions of Section A.2a.4 remain valid.
A.4c DSD Relations with Limited Role Hierarchies
A.4c.1 Administrative Commands for DSD Relations with Limited Role
Hierarchies
All functions of Sections A.2b.1 and A.4a.1 remain valid.
A.4c.2 System Functions for DSD Relations with Limited Role Hierarchies
All functions of Section A.4b.2 remain valid.
A.4c.3 Review Functions for DSD Relations with Limited Role Hierarchies
All functions of Section A.4b.3 remain valid.
A.4c.4 Advanced Review Functions for DSD Relations with Limited Role
Hierarchies
All functions of Section A.2a.4 remain valid.
REFERENCES
AHN, G. AND SANDHU, R. 2000. Role-based authorization constraints specification. ACM Trans. Inf.
Syst. Sec. 3, 4 (Nov.).
BALDWIN, R. W. 1990. Naming and grouping privileges to simplify security management in large
databases. In Proceedings of the Symposium on Security and Privacy, IEEE Press, Los Alamitos,
Calif., 116–132.
BELL, D. AND LAPADULA. 1976. Secure computer systems: Unified exposition and MULTICS. Tech.
Rep. ESD-TR-75-306, The MITRE Corporation, Bedford, Mass., March.
BERTINO, E., BONATTI, P., AND FERRARI, E. 2000. TRBAC: A temporal role-based access control
model. In Proceedings of the Fifth ACM Workshop on Role Based Access Control, 21–30.
BREWER, D. AND NASH, M. 1989. The Chinese wall security policy. In Proceedings of the Symposium
on Security and Privacy, IEEE Press, Los Alamitos, Calif., 215–228.
CHANDRAMOULI, R. AND SANDHU, R. 1998. Role-based access control features in commercial database
management systems. In Proceedings of the NIST–NSA National (USA) Computer Security Con-
ference, 503–511.
CLARK, D. AND WILSON, D. 1987. A comparison of commercial and military computer security poli-
cies. In proceedings of the Symposium on Security and Privacy, IEEE Press, Los Alamitos, Calif.,
184–194.
FADEN, G. 1999. Rbac in Unix administration. In Proceedings of the Fourth ACM Workshop on
Role Based Access Control, 95–101.
FEINSTEIN, H. 1996. Final report: NIST small business innovative research (SBIR) grant: Role
based access control: phase 2. SETA Corp., October.
FERRAIOLO, D. AND KUHN, R. 1992. Role-based access control. In Proceedings of the NIST–NSA
National (USA) Computer Security Conference, 554–563.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
Proposed NIST Standard: Role-Based Access Control • 273
FERRAIOLO, D., BARKLEY, J., AND KUHN, R. 1999. A role-based access control model and reference
implementation within a corporate internet. ACM Trans. Inf. Syst. Sec. 2, 1.
FERRAIOLO, D., CUGINI, J., AND KUHN, R. 1995. Role-based access control: Features and motiva-
tions. In Proceedings of the Annual Computer Security Applications Conference, IEEE Press, Los
Alamitos, Calif.
FERRAIOLO, D., GILBERT, D., AND LYNCH, N. 1993. An examination of federal and commercial ac-
cess control policy needs. In Proceedings of the NIST–NSA National (USA) Computer Security
Conference, 107–116.
GAVRILA, S. AND BARKLEY, J. 1998. Formal specification for RBAC user/role and role relation-
ship management. In Proceedings of the Third ACM Workshop on Role Based Access Control,
81–90.
GIURI, L. AND IGLIO, P. 1996. A formal model for role based access control with constraints. In
Proceedings of the Computer Security Foundations Workshop, IEEE Press, Los Alamitos, Calif.,
136–145.
GLIGOR, V. D., GAVRILA, S. I., AND FERRAIOLO, D. F. 1998. On the formal definition of separation-of-
duty policies and their composition. In Proceedings of the Symposium on Security and Privacy,
IEEE Press, Los Alamitos, Calif.
HUANG, W. AND ATLURI, V. 1999. A secure web-based workflow management system. In Proceedings
of the Fourth ACM Workshop on Role Based Access Control, 83–84.
JAEQER, T. 1999. On the increased importance of constraints. In Proceedings of the Fourth ACM
Workshop on Role-Based Access Control (Oct.), 33–42.
JAEGER, T. AND TIDSWELL, J. 2000. Rebuttal to the NIST RBAC model proposal. In proceedings of
the Fifth ACM Workshop on Role-Based Access Control (Berlin, July), 65–66.
JOSHI, J. B. D., AREF, W. G., GHAFOOR, A., AND SPAFFORD, E.H. 2001a. Security models for web-based
applications. Commun. ACM, 44, 2, Feb. 38–44.
JOSHI, J., GHAFOOR, A., AREF, W. G., AND SPAFFORD, E. H. 2001b. Digital government security in-
frastructure design challenges. IEEE Comput. 33, 2, Feb. 66–72.
KUHN, D. R. 1998. Role based access control on MLS systems without kernel changes. In Proceed-
ings of the ACM Workshop on Role Based Access Control (Oct. 22–23), 25–32.
KUHN, R. 1997. Mutual exclusion as a means of implementing separation of duty requirements
in role based access control systems. In Proceedings of the Second ACM Workshop on Role Based
Access Control, 23–30.
LAMPSON, B. 1974. Protection. ACM Oper. Syst. Rev. 8, 1, 18–24.
MCCOLLUM, C., MESSING, J., AND NOTARGIACOMO, L. 1990. Beyond the pale of MAC and DAC—
Defining new forms of access control. In Proceedings of the Symposium on Security and Privacy,
IEEE Press, Los Alamitos, Calif., 190–900.
MOFFETT., J. D. 1998. Control principles and role hierarchies. In Proceedings of the Third ACM
Workshop on Role-Based Access Control (Fairfax, V., Oct. 22–23), 63–69.
NYANCHAMA, M. AND OSBORN, S. 1994. Access rights administration in role-based security systems.
In Database Security, VIII: Status and Prospects, J. Biskup, M. Morgenstern, and C. E. Landwehr,
Eds., North-Holland, 37–56.
NYANCHAMA, M. AND OSBORN, S. 1999. The graph model and conflicts of interest. ACM Trans. Inf.
Syst. Sec. 2, 1.
OSBORN, S., SANDHU, R., AND MUNAWER, Q. 2000. Configuring role-based access control to enforce
mandatory and discretionary access control policies. ACM Trans. Inf. Syst. Sec. 3, 2.
SANDHU, R. AND BHAMIDIPATI, V. 1997. Role-based administration of user-role assignment: The
URA97 model and its oracle implementation. J. Compu. Sec. 7.
SANDHU, R. 1998a. Role activation hierarchies. In Proceedings of the Third ACM Workshop on
Role-Based Access Control (Fairfax, V., Oct. 22–23), 33–40.
SANDHU, R. 1998b. Role-based access control. In Advances in Computers, vol. 46, M. Zelkowitz
Eds. Academic, 237–286.
SANDHU, R. 1988. Transaction control expressions for separation of duties. In Proceedings of the
Fourth Aerospace Computer Security Applications Conference (Orlando, Fla.). IEEE Computer
Society Press, Dec. Los Alamitos, Calif., 282–286.
SANDHU, R., BHAMIDIPATI, V., AND MUNAWER, Q. 1999. The ARBAC97 model for role-based adminis-
tration of roles. ACM Trans. Inf. Sys. Sec. 2, 1, (Feb.), 105–135.
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.
274 • D. F. Ferraiolo et al.
SANDHU, R., COYNE, E., FEINSTEIN, H., AND YOUMAN, C. 1996. Role-based access control models. IEEE
Comput., 29, (2), (Feb).
SANDHU, R., FERRAIOLO, D., AND KUHN, R. 2000. The NIST model for role-based access control:
Towards a unified standard. In Proceedings of the Fifth ACM Workshop on Role-Based Access
Control (Berlin, July), 47–63.
SIMON, R. AND ZURKO, R. 1997. Separation of duty in role based access control environments. In
Proceedings of New Security Paradigms Workshop, (Sept.).
SMITH, C., COYNE, E., YOUMAN, C., AND GANTA, S. 1996. Market analysis report: NIST small business
innovative research (SBIR) grant: Role based access control: Phase 2. A marketing survey of civil
federal government organizations to determine the need for role-based access control security
product, SETA Corp., July.
THOMSEN, D. J. 1991. Role-based application design and enforcement. In Database Security, IV:
Status and Prospects, S. Jajodia and C. E. Landwehr, Eds., North-Holland, 151–168.
TING, T. C., DEMURJIAN, S. A., AND HU, M. Y. 1992. Requirements capabilities and functionalities
of user-role based security for an object-oriented design model. In Database Security, IV: Status
and Prospects, S. Jajodia and C. E. Landwehr, Eds., North-Holland, 275–296.
Received November 2000; revised July 2000; accepted July 2001
ACM Transactions on Information and System Security, Vol. 4, No. 3, August 2001.

