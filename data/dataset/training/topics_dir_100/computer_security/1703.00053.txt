1
Verified Low-Level Programming
Embedded in F‚àó
JONATHAN PROTZENKO, Microsoft Research
JEAN-KARIM ZINZINDOHOU√â, Inria Paris
ASEEM RASTOGI, Microsoft Research
TAHINA RAMANANANDRO, Microsoft Research
PENG WANG, MIT CSAIL
SANTIAGO ZANELLA-B√âGUELIN, Microsoft Research
ANTOINE DELIGNAT-LAVAUD, Microsoft Research
CƒÇTƒÇLIN HRI≈¢CU, INRIA Paris
KARTHIKEYAN BHARGAVAN, INRIA Paris
C√âDRIC FOURNET, Microsoft Research
NIKHIL SWAMY, Microsoft Research
We present Low‚àó, a language for low-level programming and verication, and its application to high-assurance
optimized cryptographic libraries. Low‚àó is a shallow embedding of a small, sequential, well-behaved subset of
C in F‚àó, a dependently-typed variant of ML aimed at program verication. Departing from ML, Low‚àódoes not
involve any garbage collection or implicit heap allocation; instead, it has a structured memory model √† la
CompCert, and it provides the control required for writing ecient low-level security-critical code.
By virtue of typing, any Low‚àó program is memory safe. In addition, the programmer can make full use
of the verication power of F‚àó to write high-level specications and verify the functional correctness of
Low‚àó code using a combination of SMT automation and sophisticated manual proofs. At extraction time,
specications and proofs are erased, and the remaining code enjoys a predictable translation to C. We prove
that this translation preserves semantics and side-channel resistance.
We provide a new compiler back-end from Low‚àó to C and, to evaluate our approach, we implement
and verify various cryptographic algorithms, constructions, and tools for a total of about 28,000 lines of
code, specication and proof. We show that our Low‚àó code delivers performance competitive with existing
(unveried) C cryptographic libraries, suggesting our approach may be applicable to larger-scale low-level
software.
1 INTRODUCTION
In the pursuit of high performance, cryptographic software widely deployed throughout the internet
is still often subject to dangerous attacks (Int 2017; Dou 2017; Use 2017; Afek and Sharabani 2007;
AlFardan and Paterson 2013; Bhargavan et al. 2014; Bhargavan and Leurent 2016; B√∂ck 2016; B√∂ck
et al. 2016; Dobrovitski 2003; Duong and Rizzo 2011; Heartbleed 2014; M√∂ller et al. 2014; Pincus
and Baker 2004; Rizzo and Duong 2012; Smyth and Pironti 2014; Somorovsky 2016; Stevens et al.
2016; ≈öwiƒôcki 2016; Szekeres et al. 2013; Wagner and Schneier 1996). Recognizing a clear need,
the programming language, verication, and applied cryptography communities are devoting
signicant eorts to develop implementations proven secure by construction against broad classes
of these attacks.
This work is licensed under a Creative Commons Attribution 4.0 International License
¬© 2017 Copyright held by the owner/author(s).
ar
X
iv
:1
70
3.
00
05
3v
4 
 [
cs
.P
L
] 
 2
7 
Ju
n 
20
17
2 Protzenko et al.
Focusing on low-level attacks caused by violations of memory safety, several researchers have
used high-level, type-safe programming languages to implement standard protocols such as Trans-
port Layer Security (TLS). For example, Kaloper-Mer≈°injak et al. (2015) provide nqsbTLS, an
implementation of TLS in OCaml, which by virtue of its type and memory safety is impervious
to attacks (like Heartbleed (2014)) that exploit buer overows. Bhargavan et al. (2014) program
miTLS in F#, also enjoying type and memory safety, but go further using a renement type system
to prove various higher-level security properties of the protocol. While this approach is attractive
for its simplicity, to get acceptable performance, both nqsbTLS and miTLS link with fast, unsafe im-
plementations of complex cryptographic algorithms, such as those provided by nocrypto (2017), an
implementation that mixes C and OCaml, and libcrypto, a component of the widely used OpenSSL
library (2017). In the worst case, linking with vulnerable C code can void all the guarantees of the
high-level code.
In this paper, we aim to bridge the gap between high-level, safe-by-construction code, optimized
for clarity and ease of verication, and low-level code exerting ne control over data representations
and memory layout in order to achieve better performance. To this end, we introduce Low‚àó, a
domain-specic language for veried, ecient, low-level programming embedded within F‚àó (Swamy
et al. 2016), an ML-like language with dependent types designed for program verication. We use
F‚àó to prove functional correctness and security properties of high-level code. Where eciency is
paramount, we drop into its C-like Low‚àó subset while still relying on the verication capabilities
of F‚àó to prove our code is memory safe, functionally correct, and secure.
We have applied Low‚àó to program and verify a range of sequential low-level programs, including
libraries for multi-precision arithmetic and buers, and various cryptographic algorithms, construc-
tions, and protocols built on top of them. Our experiments indicate that compiled Low‚àó code yields
performance on par with existing C code. This code can be used on its own, or used within existing
software through the C ABI. In particular, our C code may be linked to F‚àó programs compiled to
OCaml, providing large speed-ups via its foreign-function interface (FFI) without compromising
safety or security.
An embedded DSL, compiled natively
Low‚àóprograms are a subset of F‚àó programs: the programmer writes Low‚àó code using regular F‚àó
syntax, against a library we provide that models a lower-level view of memory, akin to the structured
memory layout of a well-dened C program (this is similar to the structured memory model of
CompCert (Leroy 2009; Leroy et al. 2012), rather than the ‚Äúbig array of bytes‚Äù model systems
programmers sometimes use). Low‚àó programs interoperate naturally with other F‚àó programs,
and precise specications of Low‚àó and F‚àó code are intermingled when proving properties of their
combination. As usual in F‚àó, programs are type-checked and compiled to OCaml for execution,
after erasing their computationally irrelevant parts, such as proofs and specications, using a
process similar to Coq‚Äôs extraction mechanism (Letouzey 2002). In particular, our memory-model
library compiles to a simple, heap-based OCaml implementation.
Importantly, Low‚àóprograms have a second, equivalent but more ecient semantics via compi-
lation to C, with the predictable performance that comes with a native implementation of their
lower-level memory model. This compilation is implemented by KreMLin, a new compiler from
the Low‚àó subset of F‚àó to C. Figure 1 illustrates the high-level design of Low‚àó and its compilation to
native code. Our main contributions are as follows:
Libraries for low-level programming within F‚àó (¬ß2). At its core, F‚àó is a purely functional language
to which eects like state are added programmatically using monads. In this work, we instantiate
the state monad of F‚àó to use a CompCert-like structured memory model that separates the stack
Verified Low-Level Programming Embedded in F‚àó 3
F‚àó
Kremlin
GCC/Clang/CompCert
EMF‚àó Low‚àó
1st-order EMF‚àó
Œªow‚àóC‚àóClight
.c Exe
‚âà erase
¬ß3.0
partial ‚âà ¬ß3.1
hoist ‚âà
‚âà
¬ß3.2
‚âà
¬ß3.3
print
compile
Fig. 1. Low‚àó embedded in F‚àó, compiled to C, with soundness and security guarantees (details in ¬ß3)
and the heap, supporting bulk allocation and deallocation on the stack, and allocating and freeing
individual blocks on the heap. Both the heap and the stack are further divided into disjoint logical
regions, which enables us to manage the separation properties necessary for modular, stateful
verication. On top of this, we program a library of C-style arrays and structs passed by reference,
with support for pointer arithmetic and pointers to the interior of an array or a struct. By virtue of
F‚àó typing, our libraries and all their well-typed clients are guaranteed to be memory safe, e.g., they
never access out-of-bounds or deallocated memory.
Designing Low‚àó, a subset of F‚àó easily compiled to C. We intend to give Low‚àóprogrammers precise
control over the performance prole of the generated C code. As much as possible, we aim for the
programmer to control even the syntactic structure of the C code, to facilitate its review by security
experts unfamiliar with F‚àó. As such, to a rst approximation, Low‚àó programs are F‚àó programs
well-typed in the state monad described above, which, after all their computationally irrelevant
(ghost) parts have been erased, must meet several restrictions, as follows: the code (1) must be rst
order, to prevent the need to allocate closures in C; (2) must make any heap allocation explicit;
(3) must not use any recursive datatype, since these would have to be compiled using additional
indirections to C structs; and (4) must be monomorphic, since C does not support polymorphism
directly. Importantly, Low‚àóheavily leverages F‚àó‚Äôs capabilities for partial evaluation, hence allowing
the programmer to write high-level, reusable code that is normalized via meta-programming into
the Low‚àósubset before the restrictions are enforced. We emphasize that these restrictions apply only
to computationally relevant code‚Äîproofs and specications are free to use arbitrary higher-order,
dependently typed F‚àó, and very often they do.
A formal translation from Low‚àó to CompCert Clight (¬ß3). Justifying its dual interpretation as a
subset of F‚àó and a subset of C, we provide a formal model of Low‚àó, called Œªow‚àó, give a translation
from Œªow‚àó to Clight (Blazy and Leroy 2009) and show that it preserves trace equivalence with
respect to the original F‚àó semantics. In addition to ensuring that the functional behavior of a
program is preserved, our trace equivalence also guarantees that the compiler does not accidentally
introduce side-channels due to memory access patterns (as would be the case without the restrictions
above) at least until it reaches Clight, a useful sanity check for cryptographic code. Our theorems
cover the translation of standalone Œªow‚àó programs to C, proving that execution in C preserves the
original F‚àó semantics of the Œªow‚àó program.
KreMLin, a compiler from Low‚àó to C (¬ß4). Our formal development guides the implementation of
KreMLin, a new tool that emits C code from Low‚àó. KreMLin is designed to emit well-formatted,
idiomatic C code suitable for manual review. The resulting C programs can be compiled with
4 Protzenko et al.
CompCert for greatest assurance, and with mainstream C compilers, including GCC and Clang, for
greatest performance. We have used KreMLin to extract to C the 20,000+ lines of Low‚àó code we
have written so far. After compilation, our veried standalone C libraries can be integrated within
larger programs using standard means.
An empirical evaluation (¬ß5). We present a few developments of ecient, veried, interoperable
cryptographic libraries programmed in Low‚àó.
(1) We provide HACL‚àó, a ‚Äúhigh-assurance crypto library‚Äù implementing and proving (in ‚àº6,000
lines of Low‚àó) several cryptographic algorithms, including the Poly1305 MAC (Bernstein 2005), the
ChaCha20 cipher (Nir and Langley 2015), and multiplication on the Curve25519 elliptic curve (Bern-
stein 2006). We package these algorithms to provide the popular NaCl API (Bernstein et al. 2012),
yielding the rst performant implementation of NaCl veried for memory safety and side-channel
resistance, along with functional correctness proofs for its core components, including a veried
bignum library customized for safe, fast cryptographic use (¬ß5.1). Using this API, we build new
standalone applications such as PneuTube, a new secure, asynchronous, le transfer application
whose performance compares favorably with widely used, existing utilities like scp.
(2) Emphasizing the applicability of Low‚àó for high-level, cryptographic security proofs on low-
level code, we briey describe its use in programming and proving (in ‚àº14,000 lines of Low‚àó) the
Authenticated Encryption with Associated Data (AEAD) construction at the heart of the record layer
of the new TLS 1.3 Internet Standard. We prove memory safety, functional correctness, and crypto-
graphic security for its main ciphersuites, relying, where available, on veried implementations of
these ciphersuites provided by HACL‚àó. The C code extracted from our veried implementation is
easily integrated within other applications, including, for example, an implementation in F‚àó of TLS
separately veried and compiled to OCaml (through OCaml‚Äôs FFI).
Trusted computing base. To date, we have focused on designing and evaluating our methodology
of programming and verifying low-level code shallowly embedded within a high-level programming
language and proof assistant. We have yet to invest eort in minimizing the trusted computing
base of our work, an eort we plan to expend now that we have evidence that our methodology is
worthwhile. Currently, the trusted computing base of our veried libraries includes the implemen-
tation of the F‚àó typechecker and the Z3 SMT solver (de Moura and Bj√∏rner 2008). Additionally, we
trust the manual proofs of the metatheory relating the semantics of Œªow‚àó to CompCert Clight. The
KreMLin tool is informed by this metatheory, but is currently implemented in unveried OCaml,
and is also trusted. Finally, we inherit the trust assumptions of the C compiler used to compile the
code extracted from Low‚àó.
Supplementary materials. First, we provide, in the appendix, the hand proofs of the theorems
described in ¬ß3. The present paper is focused on the metatheory and tools; we also authored a
companion paper (Bhargavan et al. 2017) that describes the cryptographic model we used for the
record layer of TLS 1.3. Finally, we have an ongoing submission of a paper focused on our HACL‚àó
library (Zinzindohou√© et al. 2017), where we describe in greater detail our proof techniques for
reusing the bignum formalization across dierent algorithms and implementations, and provide a
substantial performance evaluation.
We also oer numerous software artifacts. Our tool KreMLin (Protzenko 2017) is actively
developed on GitHub, and so is HACL‚àó (Zinzindohou√© et al. 2017). Most of the Low‚àó libraries live
in the F‚àó repository, also on GitHub. The integration of HACL‚àó within miTLS is also available on
GitHub. For convenience, we oer a regularly-updated Docker image of Project Everest (Microsoft
Research and INRIA 2016), which bundles together F‚àó, miTLS, HACL‚àó, KreMLin. One may fetch it
Verified Low-Level Programming Embedded in F‚àó 5
1 let chacha20
2 (len: uint32{len ‚â§ blocklen})
3 (output: bytes{len = output.length})
4 (key: keyBytes)
5 (nonce: nonceBytes{disjoint [output; key; nonce]})
6 (counter: uint32) : Stack unit
7 (requires (Œª m0‚Üí output ‚àà m0 ‚àß key ‚àà m0 ‚àß nonce ‚àà m0))
8 (ensures (Œª m0 _m1‚Üímodifies1 output m0 m1 ‚àß
9 m1.[output] ==
10 Seq.prefix len (Spec.chacha20 m0.[key] m0.[nonce]) counter))) =
11 push_frame ();
12 let state = Buer.create 0ul 32ul in
13 let block = Buer.sub state 16ul 16ul in
14 chacha20_init block key nonce counter;
15 chacha20_update output state len;
16 pop_frame ()
1 void chacha20 (
2 uint32_t len,
3 uint8_t ‚àóoutput,
4 uint8_t ‚àókey,
5 uint8_t ‚àónonce,
6 uint32_t counter)
7
8
9
10
11 {
12 uint32_t state[32] = { 0 };
13 uint32_t ‚àóblock = state + 16;
14 chacha20_init(block, key, nonce, counter);
15 chacha20_update(output, state, len);
16 }
Fig. 2. A snippet from ChaCha20 in Low‚àó (le) and its C compilation (right)
via docker pull projecteverest/everest. The Docker image contains a README.md with an
overview of the proofs and the code.
2 A LOW‚àóTUTORIAL
At the core of Low‚àó is a library for programming with structures and arrays manually allocated on
the stack or the heap (¬ß2.2). Memory safety demands reasoning about the extents and liveness of
these objects, while functional correctness and security may require reasoning about their contents.
Our library provides specications to allow client code to be proven safe, correct and secure, while
KreMLin compiles such veried client code to C.
We illustrate the design of Low‚àó using several examples from our codebase. We show the
ChaCha20 stream cipher (Nir and Langley 2015), focusing on memory safety (¬ß2.1), and the
Poly1305 MAC (Bernstein 2005), focusing on functional correctness. (¬ß2.3). Going beyond functional
correctness, we explain how we prove a combination of ChaCha20 and Poly1305 cryptographically
secure (¬ß2.4). Throughout, we point out key benets of our approach, notably our use of dependently
typed metaprogramming to work at a relatively high-level of abstraction at little performance cost.
2.1 A first example: the ChaCha20 stream cipher
Figure 2 shows code snippets for the core function of ChaCha20 (Nir and Langley 2015), a modern
stream cipher widely used for fast symmetric encryption. This function computes a block of pseudo-
random bytes, usable for encryption, for example, by XORing them with a plaintext message. On
the left is our Low‚àó code; on the right its compilation to C. The function takes as arguments an
output length and buer, and some input key, nonce, and counter. It allocates 32 words of auxiliary,
contiguous state on the stack; then it calls a function to initialize the cipher block from the inputs
(passing an interior pointer to the state); and nally it calls another function that computes a cipher
block and copies its rst len bytes to the output buer.
Aside from the erased specications at lines 7‚Äì10, the C code is in one-to-one correspondence
with its Low‚àó counterpart. These specications capture the safe memory usage of chacha20. (Their
syntax is explained next, in ¬ß2.2.) For each argument passed by reference, and for the auxiliary
6 Protzenko et al.
state, they keep track of their liveness and size. They also capture its correctness, by describing the
nal state of the output buer using a pure function.
Lines 2‚Äì3 use type renements to require that the len argument equals the length of the output
buer and it does not exceed the block size. (Violation of these conditions would lead to a buer
overrun in the call to chacha20_update.) Similarly, types keyBytes and nonceBytes specify pointers to
xed-sized buers of bytes. The return type Stack unit on line 6 says that chacha20 returns nothing
and may allocate on the stack, but not on the heap (in particular, it has no memory leak). On the
next line, the pre-condition requires that all arguments passed by reference be live. On lines 8‚Äì10, the
post-condition rst ensures that the function modies at most the contents of output (and, implicitly,
that all buers remain live). We further explain this specication in the next subsection. The rest
of the post-condition species functional correctness: the output buer must contain a sequence of
bytes equal to the rst len bytes of the cipher specied by function Spec.chacha20 for the input values
of key, nonce, and counter.
As usual for symmetric ciphers, RFC 7539 species chacha20 as imperative pseudocode, and does
not further discuss its mathematical properties. We implement this pseudocode as a series of pure
functions in F‚àó, which can be extracted to OCaml and tested for conformance with the RFC test
vectors. Functions such as Spec.chacha20 then serve as logical specications for verifying our stateful
implementation. In particular, the last postcondition of chacha20 ensures that its result is determined
by its inputs. We describe more sophisticated functional correctness proofs for Poly1305 in ¬ß2.3.
2.2 Low‚àó: An embedded DSL for low-level code
As in ML, by default F‚àó does not provide an explicit means to reclaim memory or to allocate memory
on the stack, nor does it provide support for pointing to the interior of arrays. Next, we sketch
the design of a new F‚àó library that provides a structured memory model suitable for program
verication, while supporting low-level features like explicit freeing, stack allocation, and interior
pointers. In subsequent sections, we describe how programs type-checked against this library can
be compiled safely to C. First, however, we begin with some background on F‚àó.
Background: F‚àó is a dependently typed language with support for user-dened monadic eects.
Its types separate computations from values, giving the former computation types of the form
M t1 . . . tn where M is an eect label and t1 . . . tn are value types. For example, Stack unit (...) (...) on
lines 7‚Äì8 of Figure 2 is an instance of a computation type, while types like unit are value types.
There are two distinguished computation types: Tot t is the type of a total computation returning a
t-typed value; Ghost t, a computationally irrelevant computation returning a t-typed value. Ghost
computations are useful for specications and proofs but are erased when extracting to OCaml or
C.
To add state to F‚àó, one denes a state monad represented (as usual) as a function from some
initial memory m0:s to a pair of a result r:a and a nal memory m1:s, for some type of memory s.
Stateful computations are specied using the computation type:
ST (a:Type) (pre: s‚ÜíType) (post: s‚Üí a‚Üí s‚ÜíType)
Here, ST is a computation type constructor applied to three arguments: a result type a; a pre-
condition predicate on the initial memory, pre; and a post-condition predicate relating the ini-
tial memory, result and nal memory. We generally annotate the pre-condition with the key-
word requires and the post-condition with ensures for better readability. A computation e of type
ST a (requires pre) (ensures post), when run in an initial memory m0:s satisfying pre m, produces a result r:a
Verified Low-Level Programming Embedded in F‚àó 7
and nal memory m1:s satisfying post m0 r m1, unless it diverges.1 F‚àó uses an SMT solver to discharge
the verication conditions it computes when type-checking a program.
Hyper-stacks: A region-based memory model for Low‚àó. For Low‚àó, we instantiate the type s in the
state monad to HyperStack.mem (which we refer to as just ‚Äúhyper-stack‚Äù), a new region-based memory
model (Tofte and Talpin 1997) covering both stack and heap. Hyper-stacks are a generalization of
hyper-heaps, a memory model proposed previously for F‚àó (Swamy et al. 2016), designed to provide
lightweight support for separation and framing for stateful verication. Hyper-stacks augment
hyper-heaps with a shape invariant to indicate that the lifetime of a certain set of regions follow a
specic stack-like discipline. We sketch the F‚àó signature of hyper-stacks next.
A logical specication of memory. Hyper-stacks partition memory into a set of regions. Each
region is identied by an rid and regions are classied as either stack or heap regions, according
to the predicate is_stack_region‚Äîwe use the type abbreviation sid for stack regions and hid for heap
regions. A distinguished stack region, root, outlives all other stack regions. The snippet below is
the corresponding F‚àó code.
type rid
val is_stack_region: rid‚ÜíTot bool
type sid = r:rid{is_stack_region r}
type hid = r:rid{¬¨ (is_stack_region r)}
val root: sid
Next, we show the (partial) signature of mem, our model of the entire memory, which is equipped
with a select/update theory (McCarthy 1962) for typed references ref a. Additionally, we have a
function to refer to the region_of a reference, and a relation r ‚ààm to indicate that a reference is live in
a given memory.
type mem
type ref : Type‚ÜíType
val region_of: ref a‚ÜíGhost rid
val _ ‚àà _ : ref a‚Üímem‚ÜíTot Type (‚àó a ref is contained in a mem ‚àó)
val _ [_] : mem‚Üí ref a‚ÜíGhost a (‚àó selecting a ref ‚àó)
val _ [_]‚Üê _ : mem‚Üí ref a‚Üí a‚ÜíGhost mem (‚àó updating a ref ‚àó)
val rref r a = x:ref a {region_of x = r} (‚àó abbrev. for a ref in region r ‚àó)
Heap regions. By dening the ST monad over the mem type, we can program stateful primitives
for creating new heap regions, and allocating, reading, writing and freeing references in those
regions‚Äîwe show some of their signatures below. Assuming an innite amount of memory, alloc‚Äôs
pre-condition is trivial while its post-condition indicates that it returns a fresh reference in region r
initialized appropriately. Freeing and dereferencing (!) require their argument to be present in the
current memory, eliminating double-free and use-after-free bugs.
val alloc: r:hid‚Üí init:a‚Üí ST (rref r a) (ensures (Œª m0 x m1‚Üí x /‚àà m0 ‚àß x ‚ààm1 ‚àß m1 = (m0[x]‚Üê init)))
val free: r:hid‚Üí x:rref r a‚Üí ST unit (requires (Œª m‚Üí x ‚ààm)) (ensures (Œª m0 _ m1 ‚Üí x /‚àà m1 ‚àß ‚àÄy‚â† x. m0[y] = m1[y]))
val (!): x:ref a‚Üí ST a (requires (Œª m‚Üí x ‚ààm)) (ensures (Œª m0 y m1‚Üím0 = m1 ‚àß y = m1[x]))
Since we support freeing individual references within a region, our model of regions could seem
similar to Berger et al. (2002)‚Äôs reaps. However, at present, we do not support freeing heap objects
en masse by deleting heap regions; indeed, this would require using a special memory allocator.
Instead, for us heap regions serve only to logically partition the heap in support of separation and
1F‚àó recently gained support for proving stateful computations terminating. We have begun making use of this feature to
prove our code terminating, wherever appropriate, but make no further mention of this.
8 Protzenko et al.
modular verication, as is already the case for hyper-heaps (Swamy et al. 2016), and heap region
creation is currently compiled to a no-op by KreMLin.
Stack regions, which we will henceforth call stack frames, serve not just as a reasoning device,
but provide the ecient C stack-based memory management mechanism. KreMLin maps stack
frame creation and destruction directly to the C calling convention and lexical scope. To model
this, we extend the signature of mem to include a tip region representing the currently active stack
frame, ghost operations to push and pop frames on the stack of an explicitly threaded memory,
and their eectful analogs, push_frame and pop_frame that modify the current memory. In chacha20
in Fig. 2, the push_frame and pop_frame correspond precisely to the braces in the C program that
enclose a function body‚Äôs scope. We also provide a derived combinator, with_frame, which combines
push_frame and pop_frame into a single, well-scoped operation. Programmers are encouraged to use
the with_frame combinator, but, when more convenient for verication, may also use push_frame and
pop_frame directly. KreMLin ensures that all uses of push_frame and pop_frame are well-scoped. Finally,
we show the signature of salloc which allocates a reference in the current tip stack frame.
val tip: mem‚ÜíGhost sid
val push: mem‚ÜíGhost mem
val pop: m:mem{tip m ‚â† root}‚ÜíGhost mem
val push_frame: unit‚Üí ST unit (ensures (Œª m0 () m1‚Üím1 = push m0))
val pop_frame: unit‚Üí ST unit (requires (Œª m‚Üí tip m ‚â† root)) (ensures (Œª m0 () m1‚Üím1 = pop m0))
val salloc: init:a‚Üí ST (ref a) (ensures (Œª m0 x m1‚Üí x /‚àà m0 ‚àß x ‚ààm1 ‚àß region_of x = tip m1 ‚àß
tip m0 = tip m1 ‚àß m1 = (m0[x]‚Üê init)))
The Stack eect. The specication of chacha20 claims that it uses only stack allocation and has no
memory leaks, using the Stack computation type. This is straightforward to dene in terms of ST, as
shown below.
eect Stack a pre post = ST a (requires pre)
(ensures (Œª m0 x m1‚Üí post m0 x m1 ‚àß tip m0 = tip m1 ‚àß (‚àÄ r. r ‚ààm1‚áê‚áí r ‚ààm0)))
Stack computations are ST computations that leave the stack tip unchanged (i.e., they pop all frames
they may have pushed) and yield a nal memory with the same domain as the initial memory. This
ensures that Low‚àó code with Stack eect has explicitly deallocated all heap allocated references
before returning, ruling out memory leaks. As such, we expect all externally callable Low‚àó functions
to have Stack eect. Other code can safely pass pointers to objects allocated in their heaps into
Low‚àó functions with Stack eect since the denition of Stack forbids the Low‚àó code from freeing
these references.
Modeling arrays. Hyper-stacks separate heap and stack memory, but each region of memory still
only supports abstract, ML-style references. A crucial element of low-level programming is control
over the specic layout of objects, especially for arrays and structs. We describe rst our modeling
of arrays by implementing an abstract type for buers in Low‚àó, using just the references provided
by hyper-stacks. Relying on its abstraction, KreMLin compiles our buers to native C arrays.
The type ‚Äòbuer a‚Äô below is a single-constructor inductive type with 4 arguments. Its main content
argument holds a reference to a seq a, a purely functional sequence of a‚Äôs whose length is determined
by the rst argument max_length. The renement type b:buer uint32{length b = n} is translated to a C
declaration uint32_t b[n] by KreMLin and, relying on C pointer decay, further referred to via uint32_t ‚àó.
abstract type buer a =
| MkBuer: max_length:uint32
‚Üí content:ref (s:seq a{Seq.length s = max_length})
Verified Low-Level Programming Embedded in F‚àó 9
‚Üí idx:uint32
‚Üí length:uint32 {idx + length ‚â§ max_length}‚Üí buer a
The last two arguments of a buer are there to support creating smaller sub-buers from a larger
buer, via the Buer.sub operation below. A call to ‚ÄòBuer.sub b i l‚Äô returning b‚Ä≤ is compiled to C pointer
arithmetic b + i (as seen in Figure 2 line 13 in chacha20). To accurately model this, the content eld
is shared between b and b‚Ä≤, but idx and length dier, to indicate that the sub-buer b‚Ä≤ covers only
a sub-range of the original buer b. The sub operation has computation type Tot, meaning that it
does not read or modify the state. The renement on the result b‚Ä≤ indicates its length and, using
the includes relation, records that b and b‚Ä≤ are aliased.
val sub: b:buer a‚Üí i:uint32‚Üí len:uint32{i + len ‚â§ b.length}‚ÜíTot (b':buer a{b'.length = len ‚àß b includes b'})
We also provide statically bounds-checked operations for indexing and updating buers. The
signature of the index function below requires the buer to be live and the index location to be
within bounds. Its postcondition ensures that the memory is unchanged and describes what is
returned in terms of the logical model of a buer as a sequence.
let get (m:mem) (b:buer a) (i:uint32{i < b.length}) : Ghost a = Seq.index (m[b.content]) (b.idx + i)
val index: b:buer a‚Üí i:uint32{i < b.length}‚Üí Stack a
(requires (Œª m‚Üí b.content ‚ààm))
(ensures (Œª m0 z m1‚Üím1 = m0 ‚àß z = get m1 b i))
All lengths and indices are 32-bit machine integers, and refer to the number of elements in the
buer, not the number of bytes the buer occupies. This currently prevents addressing very large
buers on 64-bit platforms. (To this end, we may parameterize our development over a C data
model, wherein indices for buers would reect the underlying (proper) ptrdi_t type.)
Similarly, memory allocation remains platform-specic. It may cause a (fatal) error as it runs
out of memory. More technically, the type of create may not suce to prevent pointer-arithmetic
overow; if the element size is greater than a byte, and if the number of elements is 232, then the
argument passed to malloc will overow on a platform where sizeof size_t == 4. To prevent such cases,
KreMLin inserts defensive dynamic checks (which typically end up eliminated by the C compiler
since our stack-allocated buer lengths are compile-time constants). In the future, we may statically
prevent it by mirroring the C sizeof operator at the F‚àó level, and requiring that for each Buer.create
operation, the resulting allocation size, in bytes, is no greater than what size_t can hold.
Modeling structs. Generalizing ‚Äòbuer t‚Äô (abstractly, a reference to a nite map from natural
numbers to t), we model C-style structs as an abstract reference to a ‚Äòstruct key value‚Äô, that is, a map
from keys k:key to values whose type ‚Äòvalue k‚Äô depends on the key. For example, we represent the
type of a colored point as follows, using a struct with two elds X and Y for coordinates and one
eld Color, itself a nested struct of RGB values.
type color_fields = R | G | B
type color = struct color_fields (Œª R | G | B‚Üíuint32)
type colored_point_fields = X | Y | Color
type colored_point = struct colored_point_fields (Œª X | Y‚Üí int32 | Color‚Üí color)
C structs are atly allocated; the declaration above models a contiguous memory block that
holds 20 bytes or more, depending on alignment constraints. As such, we cannot directly perform
pointer arithmetic within that block; rather, we navigate it by referring to elds. To this end, our
library of structs provides an interface to manipulate pointers to these C-like structs, including
pointers that follow a path of elds throughout nested structs. The main type provided by our
library is the indexed type ptr shown below, encapsulating a base reference content: ref from and a
path p of elds leading to a value of type to.
10 Protzenko et al.
abstract type ptr: Type‚ÜíType = Ptr: #from:Type‚Üí content: ref from‚Üí #to: Type‚Üí p: path from to‚Üí ptr to
When allocating a struct on the stack, the caller provides a ‚Äòstruct k v‚Äô literal and obtains a
‚Äòptr (struct k v)‚Äô, a pointer to a struct literal in the current stack frame (a Ptr with an empty path).
The extend operator below supports extending the access path associated with a ‚Äòptr (struct k v)‚Äô to
obtain a pointer to one of its elds.
val extend: #key: eqtype‚Üí #value: (key‚ÜíTot Type)‚Üí p: ptr (struct key value)‚Üí fd: key‚Üí ST (ptr (value fd))
(requires (Œª h‚Üí live h p))
(ensures (Œª h0 p‚Ä≤ h1‚Üíh0 == h1 ‚àß p‚Ä≤ == field p fd))
Finally, the read and write operations allows accessing and mutating the eld referred to by a ptr.
val read: #a:Type‚Üí p: ptr a‚Üí ST value
(requires (Œª h‚Üí live h p))
(ensures (Œª h0 v h1‚Üí live h0 p ‚àß h0 == h1 ‚àß v == as_value h0 p))
val write: #a:Type‚Üí b:ptr a‚Üí z:a‚Üí ST unit
(requires (Œª h‚Üí live h b))
(ensures (Œª h0 _h1‚Üí live h0 b ‚àß live h1 b ‚àß modifies_1 b h0 h1 ‚àß as_value h1 b == z))
2.3 Using Low‚àó for proofs of functional correctness and side-channel resistance
This section and the next illustrate our ‚Äúhigh-level verication for low-level code‚Äù methodology.
Although programming at a low-level, we rely on features like type abstraction and dependently
typed meta-programming, to prove our code functionally correct, cryptographically secure, and
free of a class of side-channels.
We start with Poly1305 (Bernstein 2005), a Message Authentication Code (MAC) algorithm.2
Unlike chacha20, for which the main property of interest is implementation safety, Poly1305 has a
mathematical denition in terms of a polynomial in the prime eld GF(2130 ‚àí 5), against which
we prove our code functionally correct. Relying on correctness, we then prove injectivity lemmas
on encodings of messages into eld polynomials, and we nally prove cryptographic security of
a one-time MAC construction for Poly1305, specically showing unforgeability against chosen
message attacks (UF1CMA). This game-based proof involves an idealization step, justied by a
probabilistic proof on paper, following the methodology we explain in ¬ß2.4.
For side-channel resistance, we use type abstraction to ensure that our code‚Äôs branching and
memory access patterns are secret independent. This style of F‚àó coding is advocated by Zinzindo-
hou√© et al. (Zinzindohou√© et al. 2016); we place it on formal ground by showing that it is a sound
way of enforcing secret independence at the source level (¬ß3.1) and that our compilation carries
such properties to the level of Clight (¬ß3.3). To carry our results further down, one may validate the
output of the C compiler by relying on recent tools proving side-channel resistance at the assembly
level (Almeida et al. 2016a,b). We sketch our methodology on a small snippet from our specialized
arithmetic (bigint) library upon which we built Poly1305.
Representing eld elements using bigints. We represent elements of the eld underlying Poly1305
as 130-bit integers stored in Low‚àóbuers of machine integers called limbs. Spreading out bits evenly
across 32-bit words yields ve limbs `i , each holding 26 bits of signicant data. A ghost function
eval = ‚àë4i=0 `i √ó 226√ói maps each buer to the mathematical integer it represents. Ecient bigint
arithmetic departs signicantly from elementary school algorithms. Additions, for instance, can be
made more ecient by leveraging the extra 6 bits of data in each limb to delay carry propagation.
2Implementation bugs in Poly1305 are still a practical concern: in 2016 alone, the Poly1305 OpenSSL implementation
experienced two correctness bugs (Benjamin 2016; B√∂ck 2016) and a buer overow (CVE 2016).
Verified Low-Level Programming Embedded in F‚àó 11
1 let normalize (b:bigint) : Stack unit
2 (requires (Œª m0 ‚Üí compact m0 b))
3 (ensures (Œª m0 () m1 ‚Üí compact m1 b ‚àß modifies1 b m0 m1 ‚àß
4 eval m1 b = eval m0 b % (pow2 130 ‚àí 5)))
5 = let h0 = ST.get() in (‚àó a logical snapshot of the initial state ‚àó)
6 let ones = 67108863ul in (‚àó 2^26 ‚àí 1 ‚àó)
7 let m5 = 67108859ul in (‚àó 2^26 ‚àí 5 ‚àó)
8 let m = (eq_mask b.(4ul) ones) & (eq_mask b.(3ul) ones)
9 & (eq_mask b.(2ul) ones) & (eq_mask b.(1ul) ones)
10 & (gte_mask b.(0ul) m5) in
11 b.(0ul)‚Üê b.(0ul) ‚àí m5 & m;
12 b.(1ul)‚Üê b.(1ul) ‚àí b.(1ul) & m; b.(2ul)‚Üê b.(2ul) ‚àí b.(2ul) & m;
13 b.(3ul)‚Üê b.(3ul) ‚àí b.(3ul) & m; b.(4ul)‚Üê b.(4ul) ‚àí b.(4ul) & m;
14 lemma_norm h0 (ST.get()) b m (‚àó relates mask to eval modulo ‚àó)
1 val poly1305_mac:
2 tag:nbytes 16ul‚Üí
3 len:u32‚Üí
4 msg:nbytes len{disjoint tag msg}‚Üí
5 key:nbytes 32ul{disjoint msg key ‚àß
6 disjoint tag key}‚Üí
7 Stack unit
8 (requires (Œª m‚Üímsg ‚àà m ‚àß key ‚àà m ‚àß tag ‚àà m))
9 (ensures (Œª m0 _m1 ‚Üí
10 let r = Spec.clamp m0[sub key 0ul 16ul] in
11 let s = m0[sub key 16ul 16ul] in
12 modifies {tag} m0 m1 ‚àß
13 m1[tag] ==
14 Spec.mac_1305 (encode_bytes m0[msg]) r s))
Fig. 3. Unique representation of a Poly1305 bigint (le) and the top-level spec of Poly1305 (right)
For Poly1305, a bigint b is in compact form in state m (i.e., compact m b) when all its limbs t in
26 bits. Compactness does not guarantee uniqueness of representation as 2130 ‚àí 5 and 0 are the
same number in the eld but they have two dierent compact representations that both t in 130
bits‚Äîthis is true for similar reasons for the range [0, 5).
Abstracting integers as a side-channel mitigation. Modern cryptographic implementations are
expected to be protected against side-channel attacks (Kocher 1996). As such, we aim to show
that the branching behavior and memory accesses of our crypto code are independent of secrets.
To enforce this, we use an abstract type limb to represent limbs, all of whose operations reveal
no information about the contents of the limb, either through its result or through its branch-
ing behavior and memory accesses. For example, rather than providing a comparison operator,
eq_leak: limb‚Üí limb‚ÜíTot bool, whose boolean result reveals information about the input limbs, we use
a masking operation (eq_mask) to compute equality securely. Unlike OCaml, F‚àó‚Äôs equality is not
fully polymorphic, being restricted to only those types that support decidable equality, limb not
being among them.
val v : limb‚ÜíGhost nat (‚àó limbs only ghostly revealed as numbers ‚àó)
val eq_mask: x:limb‚Üí y:limb‚ÜíTot (z:limb{if v x ‚â† v y then v z = 0 else v z = pow2 26 ‚àí 1})
In the signature above, v is a function that reveals an abstract limb as a natural number, but only
in ghost code‚Äîa style referred to as translucent abstraction (Swamy et al. 2016). The signature of
eq_mask claims that it returns a zero limb if the two arguments dier, although computationally
relevant code cannot observe this fact. Note, the number of limbs in a Poly1305 bigint is a public
constant, i.e., bigint = b:(buer limb){b.length = 5}.
Proving normalize correct and side-channel resistant. The normalize function of Figure 3 modies a
compact bigint in-place to reduce it to its canonical representation. The code is rather opaque,
since it operates by strategically masking each limb in a secret independent manner. However,
its specication clearly shows its intent: the new contents of the input bigint is the same as the
original one, modulo 2130 ‚àí 5. At line 14, we see a call to a F‚àó lemma, which relates the masking
operations to the modular arithmetic in the specication‚Äîthe lemma is erased during extraction.
A top-level functional correctness spec. Using our bigint library, we implement poly1305_mac and
prove it functionally correct. Its specication (Figure 3, right) states that the nal value of the 16
12 Protzenko et al.
byte tag (m1[tag]) is the value of Spec.mac_1305, a polynomial of the message and the key encoded as
eld elements. We use this mathematical specication as a basis for the game-based cryptographic
proofs of constructions built on top of Poly1305, such as the AEAD construction, described next.
2.4 Cryptographic provable-security example: AEAD
Going beyond functional correctness, we sketch how we use Low‚àó to do security proofs in the
standard model of cryptography, using ‚Äúauthenticated encryption with associated data‚Äù (AEAD)
as a sample construction. AEAD is the main protection mechanism for the TLS record layer; it
secures most Internet trac.
AEAD has a generic security proof by reduction to two core functionalities: a stream cipher
(such as ChaCha20) and a one-time-MAC (such as Poly1305). The cryptographic, game-based
argument supposes that these two algorithms meet their intended ideal functionalities, e.g., that
the cipher is indistinguishable from a random function. Idealization is not perfect, but is supposed
to hold against computationally limited adversaries, except with small probabilities, say, ŒµChaCha20
and ŒµPoly1305. The argument then shows that the AEAD construction also meets its own ideal
functionality, except with probability, say, ŒµChacha20 + ŒµPoly1305.
To apply this security argument to our implementation of AEAD, we need to encode such
assumptions. To this end, we supplement our real Low‚àó code with ideal F‚àó code. For example, ideal
AEAD is programmed as follows:
‚óè encryption generates a fresh random ciphertext, and it records it together with the encryp-
tion arguments in a log.
‚óè decryption simply looks up an entry in the log that matches its arguments and returns the
corresponding plaintext, or reports an error.
These functions capture both condentiality (ciphertexts do not depend on plaintexts) and integrity
(decryption only succeeds on ciphertexts output by encryption). Their behaviors are precisely
captured by typing, using pre- and post-conditions about the ghost log shared between them, and
abstract types to protect plaintexts and keys. We show below the abstract type of keys and the
encryption function for idealizing AEAD.
type entry = cipher ‚àó data ‚àó nonce ‚àó plain
abstract type key = { key: keyBytes; log: if Flag.aead then ref (seq entry) else unit }
let encrypt (k:key) (n:nonce) (p:plain) (a:data) =
if Flag.aead then let c = random_bytes `c in k.log := (c, a, n, p) :: k.log; c
else encrypt k.key n p a
A module Flag declares a set of abstract booleans (idealization ags) that precisely capture each
cryptographic assumption. For every real functionality that we wish to idealize, we branch on the
corresponding ag. In the code above, for instance we idealize encryption when Flag.prf is set.
This style of programming heavily relies on the normalization capabilities of F‚àó. At verication
time, ags are kept abstract, so that we verify both the real and ideal versions of the code. At
extraction time, we reveal these booleans to be false, allowing the F‚àó normalizer to drop the then
branch, and replace the log eld with unit, meaning that both the high-level, list-manipulating code
and corresponding type denitions are erased, leaving only low-level code from the else branch to
be extracted.
Using this technique, we verify by typing that our AEAD code, when using any ideal cipher and
one-time MAC, perfectly implements ideal AEAD. We also rely on typing to verify that our code
complies with the pre-conditions of the intermediate proof steps. Finally, we also prove that our
code does not reuse nonces, a common cryptographic pitfall.
Verified Low-Level Programming Embedded in F‚àó 13
Inlining and Type Abstraction. In cryptographic constructions, we often rely on type abstraction
to protect private state that depends on keys and other secrets.
A typical C application, such as OpenSSL, achieves limited type abstraction as follows. The
library exposes a public C header le for its clients, relying on void ‚àó and opaque heap allocation
functions for type abstraction.
typedef void ‚àóKEY_HANDLE;
void KEY_init(KEY_HANDLE ‚àókey);
void KEY_release(KEY_HANDLE key);
Opportunities for mistakes abound, since the void ‚àó casts are unchecked. Furthermore, abstraction
only occurs at the public header boundary, not between internal translation units. Finally, this
pattern does not allow the caller to eciently allocate the actual key on the stack.
The Low‚àódiscipline allows the programmer to achieve type abstraction and modularity, while still
supporting ecient stack allocation. As an example, for computing one-time MACs incrementally,
we use an accumulator that holds the current value of a polynomial computation, which depends
on a secret key. For cryptographic soundness, we must ensure that no information about such
intermediate values leak to the rest of the code.
To this end, all operations on accumulators are dened in a single module of the form below‚Äîour
code is similar but more complex, as it supports MAC algorithms with dierent eld representations
and key formats, and also keeps track of the functional correctness of the polynomial computation.
module OneTimeMAC
type elem = lbytes (v accLen) (‚àó intermediate value (representing a a eld element) ‚àó)
abstract type key (i:macID) = elem
abstract type accum (i:macID) = elem
(‚àó newAcc allocates on the caller's frame ‚àó)
let newAcc (i:macID) : StackInline (accum i) (...) = Buer.create 0ul accLen
let extend (i:macID) (key: macKey i) (acc:accum i) (word:elem) : Stack unit (...) = add acc word; mul acc key
The index i is used to separate multiple instances of MACs; for instance, it prevents calls to
extend an accumulator with the wrong key. Our type-based separation between dierent kinds of
elements is purely static. At runtime, the accumulator, and probably the key, are just bytes on the
stack (or in registers), whereas the calls to add and mul are also likely to be have been inlined in the
code that uses MACs.
The newAcc function creates a new buer for a given index, initialized to 0. The function returns a
pointer to the buer it allocates. The StackInline eect indicates that the function does need to push
a frame before allocation, but instead allocates in its caller‚Äôs stack frame. KreMLin textually inlines
the function in its caller‚Äôs body at every call-site, ensuring that the allocation performed by newAcc
indeed happens in the caller‚Äôs stack frame. From the perspective of Low‚àó, newAcc is a function in a
separate module, and type abstraction is preserved.
3 A FORMAL TRANSLATION FROM LOW‚àóTO CLIGHT
Figure 1 on page 3 provides an overview of our translation from Low‚àó to CompCert Clight, starting
with emf‚ãÜ, a recently proposed model of F‚àó (Ahman et al. 2017); then Œªow‚àó, a formal core of Low‚àó
after all erasure of ghost code and specications; then C‚àó, an intermediate language that switches
the calling convention closer to C; and nally to Clight. In the end, our theorems establish that: (a)
the safety and functional correctness properties veried at the F‚àó level carry on to the generated
Clight code (via semantics preservation), and (b) Low‚àóprograms that use the secrets parametrically
enjoy the trace equivalence property, at least until the Clight level, thereby providing protection
against side-channels.
14 Protzenko et al.
œÑ ‚à∂‚à∂= int ‚à£ unit ‚à£ {
√ê√ê‚áÄ
f = œÑ} ‚à£ buf œÑ ‚à£ Œ±
v ‚à∂‚à∂= x ‚à£ n ‚à£ () ‚à£ {
√ê√ê‚áÄ
f = v} ‚à£ (b,n,
√ê‚áÄ
f )
e ‚à∂‚à∂= let x ‚à∂ œÑ = readbuf e1 e2 in e ‚à£ let _ = writebuf e1 e2 e3 in e
‚à£ let x = newbuf n (e1 ‚à∂ œÑ) in e2 ‚à£ subbuf e1 e2
‚à£ let x ‚à∂ œÑ = readstruct e1 in e ‚à£ let _ = writestruct e1 e2 in e
‚à£ let x = newstruct (e1 ‚à∂ œÑ) in e2 ‚à£ e1 ‚ñ∑ f
‚à£ withframe e ‚à£ pop e ‚à£ if e1 then e2 else e3
‚à£ let x ‚à∂ œÑ = d e1 in e2 ‚à£ let x ‚à∂ œÑ = e1 in e2 ‚à£ {
√ê√ê‚áÄ
f = e} ‚à£ e . f ‚à£ v
P ‚à∂‚à∂= ‚ãÖ ‚à£ let d = Œªy ‚à∂ œÑ1. e ‚à∂ œÑ2,P
Fig. 4. Œªow‚àó syntax
Prelude: Internal transformations in emf‚ãÜ. We begin by briey describing a few internal trans-
formations on emf‚ãÜ, focusing in the rest of this section on the pipeline from Œªow‚àó to Clight‚Äîthe
formal details are in the appendix. To express computational irrelevance, we extend emf‚ãÜ with a
primitive Ghost eect. An erasure transformation removes ghost subterms, and we prove that this
pass preserves semantics, via a logical relations argument. Next, we rely on a prior result (Ahman
et al. 2017) showing that emf‚ãÜ programs in the ST monad can be safely reinterpreted in emf‚ãÜst, a
calculus with primitive state. We obtain an instance of emf‚ãÜst suitable for Low‚àó by instantiating its
state type with HyperStack.mem. To facilitate the remainder of the development, we transcribe emf‚ãÜst
to Œªow‚àó, which is a restriction of emf‚ãÜst to rst-order terms that only use stack memory, leaving the
heap out of Œªow‚àó, since it is not a particularly interesting aspect of the proof. This transcription
step is essentially straightforward, but is not backed by a specic proof. We plan to ll this gap as
we aim to mechanize our entire proof in the future.
3.1 Œªow‚àó: A formal core of Low‚àópost-erasure
The meat of our formalization of Low‚àóbegins with Œªow‚àó, a rst-order, stateful language, whose state
is structured as a stack of memory regions. It has a simple calling convention using a traditional,
substitutive Œ≤-reduction rule. Its small-step operational semantics is instrumented to produce
traces that record branching and the accessed memory addresses. As such, our traces account
for side-channel vulnerabilities in programs based on the program counter model (Molnar et al.
2006) augmented to track potential leaks through cache behavior (Barthe et al. 2014). We dene a
simple type system for Œªow‚àó and prove that programs well-typed with respect to some values at an
abstract type produce traces independent of those values, e.g., our bigint library when translated to
Œªow‚àó is well-typed with respect to an abstract type of limbs and leaks no information about them
via their traces.
Syntax. Figure 4 shows the syntax of Œªow‚àó. A program P is a sequence of top-level function
denitions, d . We omit loops but allow recursive function denitions. Values v include constants,
immutable records, and buers (b,n, []) and mutable structures (b,n,
√ê‚áÄ
f ) passed by reference,
where b is the address of the buer or structure, n is the oset in the buer, and
√ê‚áÄ
f designates the
path to the structure eld to take a reference of (this path, as a list, can be longer than 1 in the case
of nested mutable structures.) Stack allocated buers (readbuf, writebuf, newbuf, and subbuf), and
their mutable structure counterparts (readstruct, writestruct, newstruct, ‚ñ∑), are the main feature
of the expression language, along with withframe e , which pushes a new frame on the stack for
the evaluation of e , after which it is popped (using pop e , an administrative form internal to the
calculus). Once a frame is popped, all its local buers and mutable structures become inaccessible.
Verified Low-Level Programming Embedded in F‚àó 15
P ‚ä¢ (H ,withframe e)‚Üí‚ãÖ (H ;{},pop e)
WF
P ‚ä¢ (H ; _,pop v)‚Üí‚ãÖ (H ,v)
Pop
P ‚ä¢ (H , if 0 then e1 else e2)‚ÜíbrF (H ,e2)
LIfF
P(f ) = Œªy ‚à∂ œÑ1. e1 ‚à∂ œÑ2
P ‚ä¢ (H , let x ‚à∂ œÑ = f v in e)‚Üí (H , let x ‚à∂ œÑ = e1[v/y] in e)
App
H(b,n + n1, []) = v ` = read(b,n + n1, [])
P ‚ä¢ (H , let x = readbuf (b,n, []) n1 in e)‚Üí` (H ,e[v/x])
LRd
b ‚àâ dom(H ;h) h1 = h[b ‚Ü¶ v
n
] e1 = e[(b, 0)/x] ` = write(b, 0), . . . ,write(b,n ‚àí 1)
P ‚ä¢ (H ;h, let x = newbuf n (v ‚à∂ œÑ) in e)‚Üí` (H ;h1,e1)
New
Fig. 5. Selected semantic rules from Œªow‚àó
Mutable structures can be nested, and stored into buers, in both cases without extra indirection.
However, the converse is not true, as Œªow‚àó currently does not allow arbitrary nesting of arrays
within mutable structures without explicit indirection via separately allocated buers. We leave
such generalization as future work.
Type system. Œªow‚àó types include the base types int and unit, record types {
√ê√ê‚áÄ
f = œÑ}, buer types
buf œÑ , mutable structure types struct œÑ , and abstract types Œ± . The typing judgment has the form,
ŒìP ;Œ£; Œì ‚ä¢ e ‚à∂ œÑ , where ŒìP includes the function signatures; Œ£ is the store typing; and Œì is the
usual context of variables. We elide the rules, as it is a standard, simply-typed type system. The
type system guarantees preservation, but not progress, since it does not attempt to account for
bounds checks or buer/mutable structure lifetime. However, memory safety (and progress) is a
consequence of Low‚àó typing and its semantics-preserving erasure to Œªow‚àó.
Semantics. We dene evaluation contexts E for standard call-by-value, left-to-right evaluation
order. The memory H is a stack of frames, where each frame maps addresses b to a sequence of
values √ê‚áÄv . The Œªow‚àó small-step semantics judgment has the form P ‚ä¢ (H ,e)‚Üí` (H ‚Ä≤,e‚Ä≤), meaning
that under the program P , conguration (H ,e) steps to (H ‚Ä≤,e‚Ä≤) emitting a trace `, including reads
and writes to buer references or mutable structure references, and branching behavior, as shown
below.
` ‚à∂‚à∂= ‚ãÖ ‚à£ read(b,n,
√ê‚áÄ
f ) ‚à£ write(b,n,
√ê‚áÄ
f ) ‚à£ brT ‚à£ brF ‚à£ `1, `2
Figure 5 shows selected reduction rules from Œªow‚àó. Rule WF pushes an empty frame on the
stack, and rule Pop pops the topmost frame once the expression has been evaluated. Rule LIfF is
standard, except for the trace brF recorded on the transition. Rule App is a standard, substitutive
Œ≤-reduction. Rule LRd returns the value at the (n +n1) oset in the buer at address b, and emits a
read(b,n +n1, []) event. Rule New initializes the new buer, and emits write events corresponding
to each oset in the buer.
Secret independence. A Œªow‚àó program can be written against an interface providing secrets at an
abstract type. For example, for the abstract type limb, one might augment the function signatures
ŒìP of a program with an interface for the abstract type Œìlimb = eq_mask : limb2 ‚Üí limb, and typecheck a
source program with free limb variables (Œì = secret:limb), and empty store typing, using the judgment
Œìlimb, Œìp ; ‚ãÖ; Œì ‚ä¢ e ‚à∂ œÑ . Given any representation œÑ for limb, an implementation for eq_mask whose trace
is input independent, and any pair of values v0 ‚à∂ œÑ ,v1 ‚à∂ œÑ , we prove that running e[v0/secret] and
16 Protzenko et al.
e[v1/secret] produces identical traces, i.e., the traces reveal no information about the secret vi . We
sketch the formal development next, leaving details to the appendix.
Given a derivation Œìs , ŒìP ;Œ£; Œì ‚ä¢ e ‚à∂ œÑ , let ‚àÜ map type variables in the interface Œìs to concrete
types and let Ps contain the implementations of the functions (from Œìs ) that operate on secrets.
To capture the secret independence of Ps , we dene a notion of an equivalence modulo secrets, a
type-indexed relation for values (v1 ‚â°œÑ v2) and memories (Œ£ ‚ä¢ H1 ‚â° H2). Intuitively two values
(resp. memories) are equivalent modulo secrets if they only dier in subterms that have abstract
types in the domain of the ‚àÜ map‚Äîwe abbreviate ‚Äúequivalent modulo secrets‚Äù as ‚Äúrelated‚Äù below.
We then require that each function f ‚àà Ps , when applied in related stores to related values, always
returns related results, while producing identical traces. Practically, Ps is a (small) library written
carefully to ensure secret independence.
Our secret-independence theorem is then as follows:
Theorem 3.1 (Secret independence). Given
(1) a program well-typed against a secret interface, Œìs , i.e, Œìs , ŒìP ;Œ£; Œì ‚ä¢ (H ,e) ‚à∂ œÑ ,
(2) a well-typed implementation of the Œìs interface, Œìs ;Œ£; ‚ãÖ ‚ä¢‚àÜ Ps , such that Ps is equivalent
modulo secrets,
(3) a pair (œÅ1, œÅ2) of well-typed substitutions for Œì,
then either:
(1) both programs cannot reduce further, i.e. Ps ,P ‚ä¢ (H ,e)[œÅ1]‚Üõ and Ps ,P ‚ä¢ (H ,e)[œÅ2]‚Üõ, or
(2) both programs make progress with the same trace, i.e. there exists Œ£‚Ä≤ ‚äá Œ£, Œì‚Ä≤ ‚äá Œì,H ‚Ä≤,e‚Ä≤, a pair
(œÅ‚Ä≤1, œÅ
‚Ä≤
2) of well-typed substitutions for Œì
‚Ä≤, and a trace ` such that
i) Ps ,P ‚ä¢ (H ,e)[œÅ1]‚Üí+` (H
‚Ä≤,e‚Ä≤)[œÅ‚Ä≤1] and Ps ,P ‚ä¢ (H ,e)[œÅ2]‚Üí
+
` (H
‚Ä≤,e‚Ä≤)[œÅ‚Ä≤2], and
ii) Œìs , ŒìP ;Œ£‚Ä≤; Œì‚Ä≤ ‚ä¢ (H ‚Ä≤,e‚Ä≤) ‚à∂ œÑ
3.2 C‚àó: An intermediate language
We move from Œªow‚àó to Clight in two steps. The C‚àó intermediate language retains Œªow‚àó‚Äôs explicit
scoping structure, but switches the calling convention to maintain an explicit call-stack of con-
tinuations (separate from the stack memory regions). C‚àó also switches to a more C-like syntax,
separates side eect-free expressions from eectful statements.
PÃÇ ‚à∂‚à∂=
√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
fun f (x ‚à∂ œÑ) ‚à∂ œÑ {√ê‚áÄs }
eÃÇ ‚à∂‚à∂= n ‚à£ () ‚à£ x ‚à£ eÃÇ + eÃÇ ‚à£ {
√ê√ê‚áÄ
f = eÃÇ} ‚à£ eÃÇ . f ‚à£ &eÃÇ ‚Üí f
s ‚à∂‚à∂= œÑ x = eÃÇ ‚à£ œÑ x = f (eÃÇ) ‚à£ if eÃÇ then√ê‚áÄs else√ê‚áÄs ‚à£ return eÃÇ
‚à£ {√ê‚áÄs } ‚à£ œÑ x[n] ‚à£ œÑ x = ‚àó[eÃÇ] ‚à£ ‚àó[eÃÇ] = eÃÇ ‚à£ memset eÃÇ n eÃÇ
The syntax is unsurprising, with two notable exceptions. First, despite the closeness to C syntax,
contrary to C and similarly to Œªow‚àó, block scopes are not required for branches of a conditional
statement, so that any local variable or local array declared in a conditional branch, if not enclosed
by a further block, is still live after the conditional statement. Second, non-array local variables are
immutable after initialization.
Operational semantics, in contrast to Œªow‚àó. A C‚àó evaluation conguration C consists of a stack S ,
a variable assignment V and a statement list√ê‚áÄs to be reduced. A stack is a list of frames. A frame
F includes frame memory M , local variable assignment V to be restored upon function exit, and
continuation E to be restored upon function exit. Frame memory M is optional: when it is ¬ñ, the
frame is called a ‚Äúcall frame‚Äù; otherwise a ‚Äúblock frame‚Äù, allocated whenever entering a statement
block and deallocated upon exiting such block. A frame memory is just a partial map from block
Verified Low-Level Programming Embedded in F‚àó 17
PÃÇ ‚ä¢ (S,V ,{√ê‚áÄs1 };√ê‚áÄs2 )‚Üù (S ; ({},V ,‚óª;√ê‚áÄs2 ),V ,√ê‚áÄs1 )
Block
PÃÇ ‚ä¢ (S ; (M,V ‚Ä≤,E),V , [])‚Üù (S,V ‚Ä≤,E [()])
Empty
‚ü¶eÃÇ‚üß(V ) = 0
PÃÇ ‚ä¢ (S,V , if eÃÇ then√ê‚áÄs1 else
√ê‚áÄs2 ;√ê‚áÄs )‚ÜùbrF (S,V ,
√ê‚áÄs2 ;√ê‚áÄs )
CIfF
PÃÇ(f ) = fun (y ‚à∂ œÑ1) ‚à∂ œÑ2 {
√ê‚áÄs1 } ‚ü¶eÃÇ‚üß(V ) = v
PÃÇ ‚ä¢ (S,V ,œÑ x = f eÃÇ;√ê‚áÄs )‚Üù (S ; (¬ñ,V ,œÑ x = ‚óª;√ê‚áÄs ),{}[y ‚Ü¶ v],√ê‚áÄs1 )
Call
‚ü¶eÃÇ‚üß(V ) = (b,n,
√ê‚áÄ
f ) Get(S, (b,n,
√ê‚áÄ
f )) = v ` = read (b,n,
√ê‚áÄ
f )
PÃÇ ‚ä¢ (S,V ,œÑ x = ‚àó[eÃÇ];√ê‚áÄs )‚Üù` (S,V [x ‚Ü¶ v],
√ê‚áÄs )
CRead
S = S‚Ä≤; (M,V ,E) b /‚àà S V ‚Ä≤ = V [x ‚Ü¶ (b, 0, [])]
PÃÇ ‚ä¢ (S,V ,œÑ x[n];√ê‚áÄs )‚Üù (S‚Ä≤; (M[b ‚Ü¶ ¬ñn],V ,E),V ‚Ä≤,√ê‚áÄs )
ArrDecl
Fig. 6. Selected semantic rules from C‚àó
identiers to value lists. Each C‚àó statement performs at most one function call, or otherwise, at
most one side eect. Thus, C‚àó is deterministic.
The semantics of C‚àó is shown to the right in Figure 6, also illustrating the translation from Œªow‚àó
to C‚àó. There are three main dierences. First, C‚àó‚Äôs calling convention (rule Call) shows an explicit
call frame being pushed on the stack, unlike Œªow‚àó‚Äôs Œ≤ reduction. Additionally, C‚àó expressions
do not have side eects and do not access memory; thus, their evaluation order does not matter
and their evaluation can be formalized as a big-step semantics; by themselves, expressions do not
produce events. This is apparent in rules like CIfF and CRead, where the expressions are evaluated
atomically in the premises. Finally, newbuf in Œªow‚àó is translated to an array declaration followed
by a separate initialization. In C‚àó, declaring an array allocates a fresh memory block in the current
memory frame, and makes its memory locations available but uninitialized. Memory write (resp.
read) produces a write (resp. read) event. memset eÃÇ1 m eÃÇ2 produces m write events, and can be
used only for arrays.
Correctness of the Œªow‚àó-to-C‚àó transformation. We proved that execution traces are exactly pre-
served from Œªow‚àó to C‚àó:
Lemma 3.2 (Œªow‚àó to C‚àó). Let P be a Œªow‚àó program and e be a Œªow‚àó entry point expression, and
assume that they compile: ‚áä (P) = PÃÇ for some C‚àó program PÃÇ and ‚Üì (e) = √ê‚áÄs ; eÃÇ for some C‚àó list of
statements √ê‚áÄs and expression eÃÇ .
Let V be a mapping of local variables containing the initial values of secrets. Then, the C‚àó program
PÃÇ terminates with trace ` and return value v , i.e., PÃÇ ‚ä¢ ([],V ,√ê‚áÄs ; return eÃÇ)
`,‚àó
‚Üí ([],V ‚Ä≤, return v) if, and
only if, so does the Œªow‚àó program: P ‚ä¢ ({},e[V ])
`,‚àó
‚Üí (H ‚Ä≤,v); and similarly for divergence.
In particular, if the source Œªow‚àó program is safe, then so is the target C‚àó program. It also follows
that the trace equality security property is preserved from Œªow‚àó to C‚àó. We prove this theorem by
bisimulation. In fact, it is enough to prove that any Œªow‚àó behavior is a C‚àó behavior, and ip the
diagram since C‚àó is deterministic. That C‚àó semantics use big-step semantics for C‚àó expressions
complicates the bisimulation proof a bit because Œªow‚àó and C‚àó steps may go out-of-sync at times.
18 Protzenko et al.
Within the proof we used a relaxed notion of simulation (‚Äúquasi-renement‚Äù) that allows this
temporary discrepancy by some stuttering, but still implies bisimulation.
3.3 From C‚àó to CompCert Clight and beyond
CompCert Clight is a deterministic (up to system I/O) subset of C with no side eects in expressions,
and actual byte-level representation of values. Clight has a realistic formal semantics (Blazy
and Leroy 2009; Leroy 2016) and tractable enough to carry out the correctness proofs of our
transformations from Œªow‚àó to C. More importantly, Clight is the source language of the CompCert
compiler backend, which we can thus leverage to preserve at least safety and functional correctness
properties of Low‚àóprograms down to assembly.3
Recall that we need to produce an event in the trace whenever a memory location is read
or written, and whenever a conditional branch is taken, to account for memory accesses and
statements in the semantics of the generated Clight code for the purpose of our noninterference
security guarantees. However, the semantics of CompCert Clight per se produces no events on
memory accesses; instead, CompCert provides a syntactic program annotation mechanism using
no-op built-in calls, whose only purpose is to add extra events in the trace. Thus, we leverage this
mechanism by prepending each memory access and conditional statement in the Clight generated
code with one such built-in call producing the corresponding events.
The main two dierences between C‚àó and Clight, which our translation deals with as described
below, are immutable local structures, and scope management for local variables.
Immutable local structures. C‚àó handles immutable local structures as rst-class values, whereas
Clight only supports non-compound data (integers, oating-points or pointers) as values.
If we naively translate immutable local C‚àó structures to C structures in Clight, then CompCert
will allocate them in memory. This increases the number of memory accesses, which not only
introduces discrepancies in the security preservation proof from C‚àó to Clight, but also introduces
signicant performance overhead compared to GCC, which optimizes away structures whose
addresses are never taken.
Instead, we split an immutable structure into the sequence of all its non-compound elds, each
of which is to be taken as a potentially non-stack-allocated local variable,4 except for functions
that return structures, where, as usual, we add, as an extra argument to the callee, a pointer to the
memory location written to by the callee and read by the caller.
Local variable hoisting. Scoping rules for C‚àó local arrays are not exactly the same as in C, in
particular for branches of conditional statements. So, it is necessary to hoist all local variables to
function-scope. CompCert 2.7.1 does support such hoisting but as an unproven elaboration step.
While existing formal proofs (e.g., Dockins‚Äô (Dockins 2012, ¬ß9.3)) only prove functional correctness,
we also prove preservation of security guarantees, as shown below.
Proof techniques. Contrary to the Œªow‚àó-to-C‚àó transformation, our subsequent passes modify the
memory layout leading to dierences in traces between C‚àó to Clight, due to pointer values. Thus,
we need to address security preservation separately from functional correctness.
For each pass changing the memory layout, we split it into three passes. First, we reinterpret
the program by replacing each pointer value in event traces with the function name and recursion
depth of its function call, the name of the corresponding local variable, and the array index and
3As a subset of C, Clight can be compiled by any C compiler, but only CompCert provides formal guarantees.
4Our benchmark without this structure erasure runs 20% slower than with structure erasure, both with CompCert 2.7.
Without structure erasure, code generated with CompCert is 60% slower than with gcc -O1. CompCert-generated code
without structure erasure may even segfault, due to stack overow, which structure erasure successfully overcomes.
Verified Low-Level Programming Embedded in F‚àó 19
structure eld name within this local variable. Then, we perform the actual transformation and
prove that it exactly preserves traces in this new ‚Äúabstract‚Äù trace model. Finally, we reinterpret
the generated code back to concrete pointer values. We successfully used this technique to prove
functional correctness and security preservation for variable hoisting.
For each pass that adds new memory accesses, we split it into two passes. First, a reinterpretation
pass produces new events corresponding to the provisional memory accesses (without actually
performing those memory accesses). Then, this pass is followed by the actual trace-preserving
transformation that goes back to the non-reinterpreted language but adds the actual memory
accesses into the program. We successfully used this technique to prove functional correctness
and security preservation for structure return, where we add new events and memory accesses
whenever a C‚àó function returns a structure value.
In both cases, we mean reinterpretation as dening a new language with the same syntax and
small-step semantic rules except that the produced traces are dierent, and relating executions
of the same program in the two languages. There, it is easy to prove functional correctness, but
for security preservation, we need to prove an invariant on two small-step executions of the same
program with dierent secrets, to show that two equal pointer values in event traces coming from
those two dierent executions will actually turn into two equal abstract pointer values in the
reinterpreted language.
Our detailed functional correctness and security preservation proofs from Œªow‚àó to Clight can be
found in the appendix.
Towards veried assembly code. We conjecture that our reinterpretation techniques can be gener-
alized to most passes of CompCert down to assembly. While we leave such generalization as future
work, some guarantees from C to assembly can be derived by instrumenting CompCert (Barthe
et al. 2014) and LLVM (Almeida et al. 2016b; Zhao et al. 2012, 2013) and turning them into certifying
(rather than certied) compilers where security guarantees are statically rechecked on the compiled
code through translation validation, thus re-establishing them independently of source-level secu-
rity proofs. In this case, rather than being fully preserved down to the compiled code, Low‚àó-level
proofs are still useful to practically reduce the risk of failures in translation validation.
4 KREMLIN: A COMPILER FROM LOW‚àóTO C
4.1 From Low‚àó to eicient, elegant C
As explained previously, Œªow‚àó is the core of Low‚àó, post erasure. Transforming Low‚àó into Œªow‚àó
proceeds in several stages. First, we rely on F‚àó‚Äôs existing normalizer and erasure and extraction
facility (similar to features in Coq (Letouzey 2008)), to obtain an ML-like AST for Low‚àó terms.
Then, we use our new tool KreMLin that transforms this AST further until it falls within the Œªow‚àó
subset formalized above. KreMLin then performs the Œªow‚àó to C‚àó transformation, followed by the
C‚àó to C transformation and pretty-printing to a set of C les. KreMLin generates C11 code that
may be compiled by GCC; Clang; Microsoft‚Äôs C compiler or CompCert. We describe the main
transformations performed by KreMLin, beyond those formalized in ¬ß3, next.
Structures by value. We described earlier (¬ß2.2) our Low‚àó struct library that grants the program-
mer ne-grained control over the memory layout, as well as mutability of interior elds. As an
alternative, KreMLin supports immutable, by-value structs. Such structures, being pure, come
with no liveness proof obligations. The performance of the generated C code, however, is less
predictable: in many cases, the C compiler will optimize and pass such structs by reference, but on
some ABIs (x86), the worst-case scenario may be costly.
20 Protzenko et al.
Concretely, the F‚àó programmer uses tuples and inductive types. Tuples are monomorphized into
specialized inductive types. Then, inductive types are translated into idiomatic C code: single-branch
inductive types (e.g., records) become actual C structs, inductives with only constant constructors
become C enums, and other inductives becomes C tagged unions, leveraging C11 anonymous
unions for syntactic elegance. Pattern matches become, respectively, switches, let-bindings, or a
series of cascading if-then-elses.
Whole-program transformations. KreMLin perform a series of whole-program transformations.
First, the programmer is free to use parameterized type abbreviations. KreMLin substitutes an
application of a type abbreviation with its denition, since C‚Äôs typedef does not support parameters.
(C++11 alias templates would support this use-case.) Second, KreMLin recursively inlines all
StackInline functions, as required for soundness (cf. ¬ß2.4). Third, KreMLin performs a reachability
analysis. Any function that is not reachable from the main function or, in the case of a library, from a
distinguished API module, is dropped. This is essential for generating palatable C code that does not
contain unused helper functions used only for verication. Fourth, KreMLin supports a concept of
‚Äúbundle‚Äù, meaning that several F‚àó modules may be grouped together into a single C translation unit,
marking all of the functions as static, except for those reachable via the distinguished API module.
This not only makes the code much more idiomatic, but also triggers a cascade of optimizations
that the C compiler is unable to perform across translation units.
Going to an expression language. F‚àó is, just like ML, an expression language. Two transformations
are required to go to a statement language: stratication and hoisting. Stratication places buer
allocations, assignments and conditionals in statement position before going to C‚àó. Hoisting, as
discussed in ¬ß3.3, deals with the discrepancy between C99 block scope and Low‚àówith_frame; a buer
allocated under a then branch must be hoisted to the nearest enclosing push_frame, otherwise its
lifetime would be shortened by the resulting C99 block after translation.
Readability. KreMLin puts a strong emphasis on generating readable C, in the hope that security
experts not familiar with F‚àó can review the generated C code. Names are preserved; we use enum and
switch whenever possible; functions that take unit are compiled into functions with no parameters;
functions that return unit are compiled into void-returning functions. The internal architecture relies
on an abstract C AST and what we believe is a correct C pretty-printer.
Implementation. KreMLin represents about 10,000 lines of OCaml, along with a minimal set
of primitives implemented in a few hundred lines of C. After F‚àó has extracted and erased the
AEAD development, KreMLin takes less than a second to generate the entire set of C les. The
implementation of KreMLin is optimized for readability and modularity; there was no specic
performance concern in this rst prototype version. KreMLin was designed to support multiple
backends; we are currently implementing a WebAssembly backend to provide veried, ecient
cryptographic libraries for the web.
4.2 Integrating KreMLin‚Äôs output
KreMLin generates a set of C les that have no dependencies, beyond a single .h le and C11
standard headers, meaning KreMLin‚Äôs output can be readily integrated into an existing source tree.
To allow code sharing and re-use, programmers may want to generate a shared library, that is,
a .dll or .so le that can be distributed along with a public header (.h) le. The programmer can
achieve this by writing a distinguished API module in F‚àó, exposing only carefully-crafted function
signatures. As exemplied earlier (Figure 2), the translation is predictable, meaning the programmer
can precisely control, in F‚àó, what becomes, in C, the library‚Äôs public header. The bundle feature of
Verified Low-Level Programming Embedded in F‚àó 21
KreMLin then generates a single C le for the library; upon compiling it into a shared object, the
only visible symbols are those exposed by the programmer in the header le.
We used this approach for our HACL‚àó library. Our public header le exposes functions that
have the exact same signature as their counterpart in the NaCL library. If an existing binary was
compiled against NaCL‚Äôs public header le, then one can congure the dynamic linker to use our
HACL‚àó library instead, without recompiling the original program (using the infamous ‚ÄúLD preload
trick‚Äù).
The functions exposed by the library comply with the C ABI for the chosen toolchain. This
means that one may use the library from a variety of programming languages, relying on foreign-
function interfaces to interoperate. One popular approach is to generate bindings for the C library
at run-time using the ctypes and the libi (Green 2014) libraries. This is an approach leveraged by
languages such as JavaScript, Python or OCaml, and requires no recompilation.
An alternative is to write bindings by hand, which allows for better performance and control
over how data is transformed at the boundary, but requires writing and recompiling potentially
error-prone C code. This is the historical way of writing bindings for many languages, including
OCaml. We plan to have KreMLin generate these bindings automatically. We used this approach in
miTLS, eectively making it a mixed C/OCaml project. We intend to eventually lower all of miTLS
into Low‚àó.
5 BUILDING VERIFIED LOW‚àóLIBRARIES AND APPLICATIONS
Codebase LoC C LoC %annot Verif. time
Low‚àó standard library 8,936 N/A N/A 8m
HACL‚àó 6,050 11,220 28% 12h
miTLS AEAD 13,743 14,292 56.5% 1h 10m
Table 1. Evaluation of verified Low‚àó libraries and applications (time reported on an Intel Core E5 1620v3 CPU)
In this section, we describe two examples (summarized in Table 1) that show how Low‚àó can be
used to build applications that balance complex verication goals with high performance. First, we
describe HACL‚àó, an ecient library of cryptographic primitives that are veried to be memory safe,
side-channel resistant, and, where there exists a simple mathematical specication, functionally
correct. Then, we show how to use Low‚àó for type-based cryptographic security verication by
implementing and verifying the AEAD construction in the Transport Layer Security (TLS) protocol.
We show how this Low‚àó library can be integrated within miTLS, an F‚àó implementation of TLS that
is compiled to OCaml.
5.1 HACL‚àó: A fast and safe cryptographic library
In the wake of numerous security vulnerabilities, Bernstein et al. (2012) argue that libraries like
OpenSSL are inherently vulnerable to attacks because they are too large, oer too many obsolete
options, and expose a complex API that programmers nd hard to use securely. Instead they
propose a new cryptographic API called NaCl that uses a small set of modern cryptographic
primitives, such as Curve25519 (Bernstein 2006) for key exchange, the Salsa family of symmetric
encryption algorithms (Bernstein 2008), which includes Salsa20 and ChaCha20, and Poly1305 for
message authentication (Bernstein 2005). These primitives were all designed to be fast and easy to
implement in a side-channel resistant coding style. Furthermore, the NaCl API does not directly
expose these low-level primitives to the programmer. Instead it recommends the use of simple
22 Protzenko et al.
composite functions for symmetric key authenticated encryption (secretbox/secretbox_open)
and for public key authenticated encryption (box/box_open).
The simplicity, speed, and robustness of the NaCl API has proved popular among developers.
Its most popular implementation is Sodium (lib 2017), which has bindings for dozens of program-
ming languages and is written mostly in C, with a few components in assembly. An alternative
implementation called TweetNaCl (Bernstein et al. 2014) seeks to provide a concise implementation
that is both readable and auditable for memory safety bugs, a useful point of comparison for our
work. With Low‚àó, we show how we can take this approach even further by placing it on formal,
machine-checked ground, without compromising performance.
A Veried NaCl Library. We implement the NaCl API, including all its component algorithms, in
a Low‚àó library called HACL‚àó, mechanically verifying that all our code is memory safe, functionally
correct, and side-channel resistant. The C code generated from HACL‚àó is ABI-compatible and can
be used as a drop-in replacement for Sodium or TweetNaCl in any application, in C or any other
language, that relies on these libraries. Our code is written and optimized for 64-bit platforms;
on 32-bit machines, we rely on a stub library for performing 64x64-bit multiplications and other
128-bit operations.
We implement and verify four cryptographic primitives: ChaCha20, Salsa20, Poly1305, and
Curve25519, and then use them to build three cryptographic constructions: AEAD, secretbox
and box. For all our primitives, we prove that our stateful optimized code matches a high-level
functional specication written in F‚àó. These are new veried implementations. Previously, Tomb
(2016) used SAW and Cryptol to verify C and Java implementations of Chacha20, Salsa20, Poly1305,
AES, and ECDSA. Using a dierent methodology, Bond et al. (2017) veries an assembly version of
Poly1305. Curve25519 has been veried before: Chen et al. (2014) veried an optimized low-level
assembly implementation using an SMT solver; Zinzindohou√© et al. (2016) wrote and veried a high-
level library of three curves, including Curve25519, in F* and generated an OCaml implementation
from it. Our veried Curve25519 code explores a third direction by targeting reference C code that
is both fast and readable.
A companion paper currently under review (Zinzindohou√© et al. 2017) is entirely devoted to
the HACL‚àó library, and contains an in-depth evaluation of the proof methodology, several new
algorithms that were veried since the present paper was written, along with a more comprehensive
performance analysis.
Algorithm HACL‚àó Sodium TweetNaCl OpenSSL eBACS Fastest
ChaCha20 6.17 cy/B 6.97 cy/B - 8.04 cy/B 1.23 cy/B
Salsa20 6.34 cy/B 8.44 cy/B 15.14 cy/B - 1.39 cy/B
Poly1305 2.07 cy/B 2.48 cy/B 32.32 cy/B 2.16 cy/B 0.68 cy/B
Curve25519 157k cy/mul 162k cy/mul 1663k cy/mul 359k cy/mul 145k cy/mul
AEAD-ChaCha20-Poly1305 8.37 cy/B 9.60 cy/B - 8.53 cy/B
SecretBox 8.43 cy/B 11.03 cy/B 50.56 cy/B -
Box 18.10 cy/B 20.97 cy/B 149.22 cy/B -
Table 2. Performance in CPU cycles: 64-bit HACL‚àó, 64-bit Sodium (pure C, no assembly), 32-bit TweetNaCl, 64-
bit OpenSSL (pure C, no assembly), and the fastest assembly implementation included in eBACS SUPERCOP.
All code was compiled using gcc -O3 optimized and run on a 64-bit Intel Xeon CPU E5-1630. Results are
averaged over 1000 measurements, each processing a random block of 214 bytes; Curve25519 was averaged
over 1000 random key-pairs.
Verified Low-Level Programming Embedded in F‚àó 23
Algorithm HACL‚àó OpenSSL CNG
Curve25519 17700 mul/s (œÉ = 246) 8033 mul/s (œÉ = 120) 7490 mul/s (œÉ = 114)
Table 3. Performance in operations per second: 64-bit HACL‚àó, 64-bit OpenSSL (assembly disabled) and
Microso‚Äôs ‚ÄúCrypto New Generation‚Äù (CNG) library on a 64-bit Windows 10 machine. These results were
obtained by writing an OpenSSL engine that calls back to either HACL‚àó, CNG, or OpenSSL itself (so
as to include the overhead of going through a pluggable engine). The speed ecdhx25519 command runs
multiplications for 10s, then counts the number of multiplications performed. We show the average over 10
runs of this command. The machine is a desktop machine with a 64-bit Intel Xeon CPU E5-1620 v2 nominally
clocked at 3.70Ghz.
Performance. Table 2 compares the performance of HACL‚àó to Sodium, TweetNaCl, and OpenSSL
by running each primitive on a 16KB input; we chose this size since it corresponds to the maximum
record size in TLS and represents a good balance between small network messages and large les.
We report averages over 1000 iterations expressed in cycles/byte. For Curve25519, we measure
the time taken for one call to scalar multiplication. For comparison with state-of-the-art assembly
implementations, for each primitive, we also include the best performance for any implementation
(assembly or C) included in the eBACS SUPERCOP benchmarking framework.5 These fastest
implementation are typically in architecture-specic assembly.
We performed these tests on a variety of 64-bit Intel CPUs (the most popular desktop congura-
tion) and these performance numbers were similar across machines. To conrm these measurements,
we also ran the full eBACS SUPERCOP benchmarks on our code, as well as the OpenSSL speed
benchmarks, and the results closely mirrored Table 2. However, we warn the performance numbers
could be quite dierent on (say) 32-bit ARM platforms.
We observe that for ChaCha20, Salsa20, and Poly1305, HACL‚àó achieves comparable performance
to the optimized C code in OpenSSL and Sodium and signicantly better performance than Tweet-
NaCl‚Äôs concise C implementation. Assembly implementations of these primitives are about 3-4
times faster; they typically rely on CPU-specic vector instructions and careful hand-optimizations.
Our Curve25519 implementation is about the same speed as Sodium‚Äôs 64-bit C implementation
(donna_c64) and an order of magnitude faster than TweetNaCl‚Äôs 32-bit code. It is also signicantly
faster than OpenSSL because even 64-bit OpenSSL uses a Curve25519 implementation that was
optimized for 32-bit integers, whereas the implementations in Sodium and HACL‚àó take advantage
of the 64x64-bit multiplier available on Intel‚Äôs 64-bit platforms. The previous F‚àó implementation of
Curve25519 (Zinzindohou√© et al. 2016) running in OCaml was not optimized for performance; it
is more than 100x slower than HACL‚àó. The fastest assembly code for Curve25519 on eBACS is
the one veried in (Chen et al. 2014). This implementation is only 1.08x faster than our C code,
at least on the platform on which we tested, which supported vector instructions up to 256 bits.
We anticipate that the assembly code may be signicantly faster on platforms that support larger
512-bit vector instructions.
AEAD and secretbox essentially amount to a ChaCha20/Salsa20 cipher sequentially followed
by Poly1305, and their performance reects the sum of the two primitives. Box uses Curve25519 to
compute a symmetric key, which it then uses to encrypt a 16KB input. Here, the cost of symmetric
encryption dominates over Curve25519.
In summary, our measurements show that HACL‚àó is as fast as (or faster than) state-of-the-
art C crypto libraries and within a small factor of hand-optimized assembly code. This nding
is not entirely unexpected, since we wrote our Low‚àó code by eectively porting the fastest C
5https://bench.cr.yp.to/supercop.html
24 Protzenko et al.
implementations to F‚àó, and any algorithmic optimization that is implemented in C can, in principle,
be written (and veried) in Low‚àó. What is perhaps surprising is that we get good performance even
though our Low‚àócode, and consequently the generated C, heavily relies on functional programming
patterns such as tail-recursion, and even though we try to write generic compact code wherever
possible, rather than trying to mimic the verbose inlined style of assembly code. We nd that
modern compilers like GCC and CLANG are able to optimize our code quite well, and we are able
to benet from their advancements, without having to change our coding style. Where needed,
KreMLin helps the C compiler by inserting attributes like const, static and inline that act as
optimization hints.
Balancing Trust and Performance. All the above performance numbers were obtained with GCC-6
with most architecture-specic optimizations turned on (-march=native). Consequently, any bug
in GCC or its plugins could break the correctness and security guarantees we proved in F‚àó for our
source code. For example, GCC has an auto-vectorizer that signicantly improves the performance
of our ChaCha20 and Salsa20 code in certain use cases, but does so by substantially changing its
structure to take advantage of the parallelism provided by SIMD vector instructions. To avoid
trusting this powerful but unveried mechanism, and for more consistent results across platforms,
we turned o auto-vectorization (-fno-tree-vectorize) for the numbers in Table 2. For similar
reasons, we turned o link-time optimization (-fno-lto) since it relies on an external linker plugin,
and can change the semantics of our library every time it is linked with a new application.
Ideally, we would completely remove the burden of trust on the C compiler by moving to
CompCert, but at signicant performance cost. Our Salsa20 and ChaCha20 code incurs a relatively
modest 3x slowdown when compiled with CompCert 3.0 (with -O3). However, our Poly1305 and
Curve25519 code incurs a 30-60x slowdown, which makes the use of CompCert impractical for our
library. We anticipate that this penalty will reduce as CompCert improves, and as we learn how to
generate C code that would be easier for CompCert to optimize. For now, we continue to use GCC
and CLANG and comprehensively test the generated code using third-party tools. For example, we
test our code against other implementations, and run all the tests packaged with OpenSSL. We also
test our compiled code for side-channel leaks using tools like DUDECT.6
PneuTube: Fast encrypted le transfer. Using HACL‚àó, we can build a variety of high-assurance
security applications directly in Low‚àó. PneuTube is a Low‚àóprogram that securely transfers les
from a host A to a host B across an untrusted network. Unlike classic secure channel protocols
like TLS and SSH, PneuTube is asynchronous, meaning that if B is oine, the le may be cached at
some untrusted cloud storage provider and retrieved later.
PneuTube breaks the le into blocks and encrypts each block using the box API in HACL‚àó (with
an optimization that caches the result of Curve25519). It also protects le metadata, including the
le name and modication time, and it hides the le size by padding the le before encryption to a
user-dened size. We verify that our code is memory-safe, side-channel resistant, and that it uses
the I/O libraries correctly (e.g., it only reads or writes a le or a socket between calling open and
close).
PneuTube‚Äôs performance is determined by a combination of the crypto library, disk access (to read
and write the le at each end) and network I/O. Its aynchronous design is particularly rewarding
on high-latency network connections, but even when transferring a 1GB le from one TCP port
to another on the same machine, PneuTube takes just 6s. In comparison, SCP (using SSH with
ChaCha20-Poly1305) takes 8 seconds.
6https://github.com/oreparaz/dudect
Verified Low-Level Programming Embedded in F‚àó 25
5.2 Cryptographically secure AEAD for miTLS
We use our cryptographically secure AEAD library (¬ß2.4) within miTLS (Bhargavan et al. 2013),
an existing implementation of TLS in F‚àó. In a previous verication eort, AEAD encryption was
idealized as a cryptographic assumption (concretely realized using bindings to OpenSSL) to show
that miTLS implements a secure authenticated channel. However, given vulnerabilities such as
CVE-2016-7054, this AEAD idealization is a leap of faith that can undermine security when the real
implementation diverges from its ideal behavior.
We integrated our veried AEAD construction within miTLS at two levels (Bhargavan et al. 2017).
First, we replace the previous AEAD idealization with a module that implements a similar ideal
interface but translates the state and buers to Low‚àó representations. This reduces the security of
TLS to the PRF and MAC idealizations in AEAD. We integrate AEAD at the C level by substituting
the OpenSSL bindings with bindings to the C-extracted version of AEAD. This introduces a slight
security gap, as a small adapter that translates miTLS bytes to Low‚àó buers and calls into AEAD in
C is not veried. We conrm that miTLS with our veried AEAD interoperates with mainstream
implementations of TLS 1.2 and TLS 1.3 on ChaCha20-Poly1305 ciphersuites.
6 RELATED WORK
Many approaches have been proposed for verifying the functional correctness and security of
ecient low-level code. A rst approach is to build verication frameworks for C using verication
condition generators and SMT solvers (Cohen et al. 2009; Jacobs et al. 2014; Kirchner et al. 2015).
While this approach has the advantage of being able to verify existing C code, this is very challenging:
one needs to deal with the complexity of C and with any possible optimization trick in the book.
Moreover, one needs an expressive specication language and escape hatches for doing manual
proofs in case SMT automation fails. So others have deeply embedded C, or C-like languages, into
proof assistants such as Coq (Appel 2015; Beringer et al. 2015; Chen et al. 2016) and Isabelle (Schirmer
2006; Winwood et al. 2009) and built program logics and verication infrastructure starting from
that. This has the advantage of using the full expressive power of the proof assistant for specifying
and verifying properties of low-level programs. This remains a very labor-intensive task though,
because C programs are very low-level and working with a deep embedding is often cumbersome.
Acknowledging that uninteresting low-level reasoning was a determining factor in the size of the
seL4 verication eort (Klein et al. 2009), Greenaway et al. (2012, 2014) have recently proposed
sophisticated tools for automatically abstracting the low-level C semantics into higher-level monadic
specications to ease reasoning. We take a dierent approach: we give up on verifying existing C
code and embrace the idea of writing low-level code in a subset of C shallowly embedded in F‚àó.
This shallow embedding has signicant advantages in terms of reducing verication eort and
thus scaling up verication to larger programs. This also allows us to port to C only the parts of an
F‚àó program that are a performance bottleneck, and still be able to verify the complete program.
Verifying the correctness of low-level cryptographic code is receiving increasing attention (Appel
2015; Beringer et al. 2015; Dodds 2016). The veried cryptographic applications we have written in
Low‚àóand use for evaluation in this paper are an order of magnitude larger than most previous work.
Moreover, for AEAD we target not only functional correctness, but also cryptographic security.
In order to prevent the most devastating low-level attacks, several researchers have advocated
dialects of C equipped with type systems for memory safety (Condit et al. 2007; Jim et al. 2002; Tarditi
2016). Others have designed new languages with type systems aimed at low-level programming,
including for instance linear types as a way to deal with memory management (Amani et al.
2016; Matsakis and Klock II 2014). One drawback is the expressiveness limitations of such type
systems: once memory safety relies on more complex invariants than these type systems can
26 Protzenko et al.
express, compromises need to be made, in terms of verication or eciency. Low‚àó can perform
arbitrarily sophisticated reasoning to establish memory safety, but does not enjoy the benets of
ecient decision procedures (rus 2017) and currently cannot deal with concurrency.
We are not the rst to propose writing ecient and veried C code in a high-level language.
LMS-Verify (Amin and Rompf 2017) recently extended the LMS meta-programming framework
for Scala with support for lightweight verication. Verication happens at the generated C level,
which has the advantage of taking the code generation machinery out of the TCB, but has the
disadvantage of being far away from the original source code.
Bedrock (Chlipala 2013) is a generative meta-programming tool for veried low-level program-
ming in Coq. The idea is to start from assembly and build up structured code generators that are
associated verication condition generators. The main advantage of this ‚Äúmacro assembly language‚Äù
view of low-level verication is that no performance is sacriced while obtaining some amount of
abstraction. One disadvantage is that the veried code is not portable.
Our companion paper ‚ÄúImplementing and Proving the TLS 1.3 Record Layer‚Äù (Bhargavan et al.
2017) is available online. It describes a cryptographic model and proof of security for AEAD using
a combination of F‚àó verication and meta-level cryptographic idealization arguments. To make the
point that veried code need not be slow, the paper mentions that the AEAD implementation can
be ‚Äúextracted to C using an experimental backend for F‚àó‚Äù, but makes no further claims about this
backend. The current work introduces the design, formalization, implementation, and experimental
evaluation of this C backend for F‚àó.
7 CONCLUSION
This paper advocates a new methodology for carrying out high-level proofs on low-level code. By
embedding a low-level language and memory model within F‚àó, the programmer not only enjoys
sophisticated proofs but also gets to write their low-level code in a more modular style, using
features functional programmers take for granted, including recursion and type abstraction. Our
toolchain, relying on partial evaluation and the latest advances in C compilers, shows that we can
write code in a style suitable for verication and enjoy the same performance as hand-written C
code.
We are currently making progress in three dierent directions. First, continuing our integration
of AEAD within miTLS, we aim to port the miTLS protocol layer to Low‚àó, in order to get an entire
veried, TLS library in C. Second, parts of our toolchain are unveried. We plan to formalize and
verify using F‚àó parts of the KreMLin tool, notably the Œªow‚àó to C‚àó transformation. Third, we are
working on embedding assembly instructions within Low‚àó, allowing us to selectively optimize our
code further towards closing the performance gap that still remains relative to architecture-specic,
hand-written assembly routines.
8 ACKNOWLEDGMENTS
We thank the anonymous reviewers for their excellent reviews. We also thank Abhishek Anand
and Mike Hicks, for useful feedback and discussion which helped shape the work presented here,
as well as Arma√´l Gu√©neau, for his work on a mechanized proof.
Verified Low-Level Programming Embedded in F‚àó 27
A BIG-STEPPING A SMALL-STEP SEMANTICS
Actual observable behaviors will not account for the detailed sequence of small-step transitions
taken. Given an execution rst represented as the sequence of its transition steps from the initial
state, we follow CompCert to derive an observable behavior by only characterizing termination
or divergence and collecting the event traces, thus erasing all remaining information about the
execution (number of transition steps, sequence of congurations, etc.) by big-stepping the small-
step semantics as shown in Figure 7.
s0
t0
‚Üí s1
t1
‚Üí ‚ãÖ ‚ãÖ ‚ãÖ
tn‚àí2
‚Üí sn‚àí1
tn‚àí1
‚Üí sn
s0 initial sn nal with return value r t = t0; t1; . . . ; tn‚àí2; tn‚àí1
Terminates(t , r)
s0
t0
‚Üí s1
t1
‚Üí . . . s0 initial T = t0; t1; . . .
Diverges(T )
s0
t0
‚Üí s1
t1
‚Üí ‚ãÖ ‚ãÖ ‚ãÖ
tn‚àí2
‚Üí sn‚àí1
tn‚àí1
‚Üí sn s0 initial sn not nal t = t0; t1; . . . ; tn‚àí2; tn‚àí1
GoesWrong(t)
Fig. 7. Big-stepping a small-step semantics
B C‚àó AND ŒªOW‚àó DEFINITION
Notations used in the document are summarized in Figure 8. Function name f and variable name x
are of dierent syntax classes. A term is closed if it does not contain unbound variables (but can
contain function names). The grammar of C‚àó and Œªow‚àó are listed in Figure 9 and 13 respectively.
C‚àó syntax is dened in such a way that C‚àó expressions do not have side eects (but can fail to
evaluate because of e.g. referring to a nonexistent variable). Locations, which only appear during
reduction, consist of a block id, an oset and a list of eld names (a ‚Äúeld path‚Äù). The ‚Äúgetting eld
address‚Äù syntax &e ‚Üí f d is for constructing a pointer to a eld of a struct pointed to by pointer e .
In Œªow‚àó syntax, buer allocation, buer write and function application (as well as mutable struct
allocation, mutable struct write) are distinctive syntax constructs (not special cases of let-binding).
In this way we force eectful operations to be in let-normal-form, to be aligned with C‚àó (C‚àó
does not allow eectfull expressions because of C‚Äôs nondeterministic expression evaluation order).
Let-binding and anonymous let-binding are also distinctive syntax constructs, because they need
to be translated into dierent C‚àó constructs. Locations and pop le only appear during reduction.
The operational semantics of C‚àó is listed in Figure 11 and 12. Because C expressions do not have
a deterministic evaluation order, in C‚àó we use a mixed big-step/small-step operational semantics,
where C‚àó expressions are evaluated with big-step semantics dened by the evaluation function
(interpreter) ‚ü¶e‚üß(p,V ), while C
‚àó statements are evaluated with small-step semantics. Denitions
used in C‚àó semantics are summarized in Figure 10. A C‚àó evaluation conguration C consist of a
stack S , a variable assignment V and a statement list ss to be reduced. A stack is a list of frames. A
frame F includes frame memory M , variable assignment V to be restored upon function exit, and
continuation E to be restored upon function exit. Frame memory M is optional: when it is none,
the frame is called a ‚Äúcall frame‚Äù; otherwise a ‚Äúblock frame‚Äù. A frame memory is just a partial map
from block ids to value lists.
28 Protzenko et al.
Both C‚àó and Œªow‚àó reductions generate traces that include memory read/write with the address,
and branching to true/false. Reduction steps that don‚Äôt have these eects are silent.
√ê‚áÄa list aÃÉ option a
¬ñ None ‚åäa‚åã Some a
n integer x variable name
f function name f d eld name
a ‚áÄ b partial map {} empty map
{x ‚Ü¶ a} singleton map m[x ‚Ü¶ a] map update
[] empty list a;b list concat or cons
[a/x]b substitute a for x in b
Fig. 8. Notations
B.1 C‚àó Definition
The following are the denitions of the syntax and operational semantics of C‚àó.
Verified Low-Level Programming Embedded in F‚àó 29
p ‚à∂‚à∂= program
√ê‚áÄ
d series of declarations
d ‚à∂‚à∂= declaration
fun f (x ‚à∂ t) ‚à∂ t { ss } top-level function
t x = v top-level value
ss ‚à∂‚à∂= statement lists
√ê‚áÄs
s ‚à∂‚à∂= statements
t x = e immutable variable declaration
t x[n] array declaration
memset e n e memory set
t x = f (e) application
t x = ‚àó[e] read
‚àó[e] = e write
if e then ss else ss conditional
{ss} block
e expression
return e return
e ‚à∂‚à∂= expressions
n integer constant
() unit value
x variable
e1 + e2 pointer add (e1 is a pointer and e2 is an int)
{
√ê√ê√ê‚áÄ
f d = e} struct
e . f d struct eld projection
&e ‚Üí f d struct eld address (e is a pointer)
loc location
loc ‚à∂‚à∂= locations
(b,n,
√ê‚áÄ
f d)
Fig. 9. C‚àó Syntax
30 Protzenko et al.
v ‚à∂‚à∂= values
n constant
() unit value
{
√ê√ê√ê‚áÄ
f d = v} constant struct
loc location
E ‚à∂‚à∂= evaluation ctx (plug expr to get stmts)
‚óª; ss discard returned value
t x = ‚óª; ss receive returned value
F ‚à∂‚à∂= frames
(¬ñ,V ,E) call frame
(‚åäM‚åã,V ,E) block frame
M ‚à∂‚à∂= memory
b ‚áÄ
√ê‚áÄ
vÃÉ map from block id to list of optional values
V ‚à∂‚à∂= variable assignments
x ‚áÄ v map from variable to value
S ‚à∂‚à∂= stack
√ê‚áÄ
F list of frames
C ‚à∂‚à∂= conguration
(S,V , ss)
l ‚à∂‚à∂= label
read loc read
write loc write
brT branch true
brF branch false
Fig. 10. C‚àó Semantics Definitions
‚ü¶e‚üß(p,V ) = v
V (x) = v
‚ü¶x‚üß(p,V ) = v
Var
‚ü¶e1‚üß(p,V ) = (b,n, []) ‚ü¶e2‚üß(p,V ) = n
‚Ä≤
‚ü¶e1 + e2‚üß(p,V ) = (b,n + n
‚Ä≤
, [])
PtrAdd
‚ü¶e‚üß(p,V ) = (b,n,
√ê‚áÄ
f d)
‚ü¶&e ‚Üí f d‚üß(p,V ) = (b,n,
√ê‚áÄ
f d ; f d)
PtrFd x /‚àà V p(x) = v
‚ü¶x‚üß(p,V ) = v
GVar
‚ü¶{
√ê√ê√ê‚áÄ
f d = e}‚üß
(p,V )
= {
√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
f d = ‚ü¶e‚üß(p,V )}
NonMutStruct
‚ü¶e‚üß(p,V ) = {
√ê√ê√ê‚áÄ
f d = v} {
√ê√ê√ê‚áÄ
f d = v}(f d‚Ä≤) = v‚Ä≤
‚ü¶e . f d‚Ä≤‚üß
(p,V ) = v
‚Ä≤ Proj
‚ü¶v‚üß(p,V ) = v
Val
Fig. 11. C‚àó Expression Evaluation
Verified Low-Level Programming Embedded in F‚àó 31
p ‚ä¢ C ‚Üùl C
‚Ä≤
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S,V , t x = e; ss)‚Üù (S,V [x ‚Ü¶ v], ss)
VarDecl
S = S‚Ä≤; (M,V ,E) b /‚àà S
p ‚ä¢ (S,V , t x[n]; ss)‚Üù (S‚Ä≤; (M[b ‚Ü¶ ¬ñn],V ,E),V [x ‚Ü¶ (b, 0, [])], ss)
ArrDecl
‚ü¶e1‚üß(p,V ) = (b,n, []) ‚ü¶e2‚üß(p,V ) = v Set(S, (b,n, []),v
m
) = S‚Ä≤
p ‚ä¢ (S,V ,memset e1 m e2; ss)‚Üùwrite (b,n,[]), ...,write (b,n+m‚àí1,[]) (S
‚Ä≤
,V , ss)
Memset
‚ü¶e‚üß(p,V ) = (b,n,
√ê‚áÄ
f d) Get(S, (b,n,
√ê‚áÄ
f d)) = v
p ‚ä¢ (S,V , t x = ‚àó[e]; ss)‚Üù
read (b,n,
√ê‚áÄ
f d)
(S,V [x ‚Ü¶ v], ss)
Read
‚ü¶e1‚üß(p,V ) = (b,n,
√ê‚áÄ
f d) ‚ü¶e2‚üß(p,V ) = v Set(S, (b,n,
√ê‚áÄ
f d),v) = S‚Ä≤
p ‚ä¢ (S,V ,‚àóe1 = e2; ss)‚Üùwrite (b,n,√ê‚áÄf d) (S
‚Ä≤
,V , ss)
Write
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S ; (¬ñ,V ‚Ä≤,E),V , return e; ss)‚Üù (S,V ‚Ä≤,E [v])
Ret
p(f ) = fun (y ‚à∂ t1) ‚à∂ t2 { ss1 } ‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S,V , t x = f e; ss)‚Üù (S ; (¬ñ,V , t x = ‚óª; ss),{}[y ‚Ü¶ v], ss1)
Call
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S ; (M,V ‚Ä≤,E),V , return e; ss)‚Üù (S,{}, return v)
RetBlk
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S,V ,e; ss)‚Üù (S,V , ss)
Expr
p ‚ä¢ (S ; (M,V ‚Ä≤,E),V , [])‚Üù (S,V ‚Ä≤,E [()])
Empty
p ‚ä¢ (S,V ,{ss1}; ss2)‚Üù (S ; ({},V ,‚óª; ss2),V , ss1)
Block
‚ü¶e‚üß(p,V ) = n n /= 0
p ‚ä¢ (S,V , if e then ss1 else ss2; ss)‚ÜùbrT (S,V , ss1; ss)
IfT
‚ü¶e‚üß(p,V ) = n n = 0
lp ‚ä¢ (S,V , if e then ss1 else ss2; ss)‚ÜùbrF (S,V , ss2; ss)
IfF
Fig. 12. C‚àó Configuration Reduction
32 Protzenko et al.
B.2 Œªow‚àó Definition
The following are the denitions of the syntax and operational semantics of Œªow‚àó.
lp ‚à∂‚à∂= program
√ê‚áÄ
ld series of declarations
ld ‚à∂‚à∂= declaration
let x = Œªy ‚à∂ t . le ‚à∂ t top-level function
let x ‚à∂ t = v top-level value
le ‚à∂‚à∂= expressions
n constant
() unit value
x variable
{
√ê√ê√ê√ê‚áÄ
f d = le} struct as value
le . f d immutable struct eld projection
le ‚ñ∑ f d sub-structure: mutable structure eld projection
subbuf le le sub-buer
if le then le else le conditional
let x ‚à∂ t = le in le let-binding
let _ = le in le anonymous let-binding
let x ‚à∂ t = f le in le application
let x = newbuf n (le ‚à∂ t) in le new buer
let x ‚à∂ t = readbuf le le in le read from buer
let _ = writebuf le le le in le write to buer
let x = newstruct (le ‚à∂ t) in le new mutable structure
let x ‚à∂ t = readstruct le in le read from mutable structure
let _ = writestruct le in le write to mutable structure
withframe le with-frame
pop le pop frame
loc location
Fig. 13. Œªow‚àó Syntax
Verified Low-Level Programming Embedded in F‚àó 33
values
lv ‚à∂‚à∂= n ‚à£ () ‚à£ {
√ê√ê√ê√ê‚áÄ
f d = lv} ‚à£ loc
evaluation contexts
LE ‚à∂‚à∂= ‚óª ‚à£ LE. f d ‚à£ LE ‚ñ∑ f d ‚à£ {
√ê√ê√ê√ê‚áÄ
f d = lv ; f d = LE;
√ê√ê√ê√ê‚áÄ
f d = le}
‚à£ subbuf LE le ‚à£ subbuf lv LE
‚à£ if LE then le else le
‚à£ let x ‚à∂ t = LE in le ‚à£ let _ = LE in le
‚à£ let x ‚à∂ t = f LE in le
‚à£ let x = newbuf n (LE ‚à∂ t) in le
‚à£ let x ‚à∂ t = readbuf LE le in le
‚à£ let x ‚à∂ t = readbuf lv LE in le
‚à£ let _ = writebuf LE le le in le
‚à£ let _ = writebuf lv LE le in le
‚à£ let _ = writebuf lv lv LE in le
‚à£ let x = newstruct (LE ‚à∂ t) in le
‚à£ let x ‚à∂ t = readstruct LE in le
‚à£ let _ = writestruct LE le in le
‚à£ let _ = writestruct lv LE in le
‚à£ pop LE
stack
H ‚à∂‚à∂=
√ê‚áÄ
h
stack frame
h ‚à∂‚à∂= b ‚áÄ√ê‚áÄv
Fig. 14. Œªow‚àó Semantics Definitions
34 Protzenko et al.
lp ‚ä¢ (H, le) _l (H ‚Ä≤, le ‚Ä≤) and lp ‚ä¢ (H, le)‚Üùl (H ‚Ä≤, le ‚Ä≤)
H(b, n + n‚Ä≤, []) = lv
lp ‚ä¢ (H, let x = readbuf (b, n, []) n‚Ä≤ in le) _read (b,n+n‚Ä≤,[]) (H, [lv/x]le)
ReadBuf
H(b, n,
√ê‚áÄ
f d) = lv
lp ‚ä¢ (H, let x = readstruct (b, n,
√ê‚áÄ
f d) in le) _
read (b,n,
√ê‚áÄ
f d)
(H, [lv/x]le)
ReadStruct
lp(f ) = Œªy ‚à∂ t1 . le1 ‚à∂ t2
lp ‚ä¢ (H, let x ‚à∂ t = f v in le) _ (H, let x ‚à∂ t = [v/y]le1 in le)
App
(b, n + n‚Ä≤, []) ‚àà H
lp ‚ä¢ (H, let _ = writebuf (b, n, []) n‚Ä≤ lv in le) _write (b,n+n‚Ä≤,[]) (H [(b, n + n
‚Ä≤
, [])‚Ü¶ lv], le)
WriteBuf
(b, n,
√ê‚áÄ
f d) ‚àà H
lp ‚ä¢ (H, let _ = writestruct (b, n,
√ê‚áÄ
f d) lv in le) _
write (b,n,
√ê‚áÄ
f d)
(H [(b, n,
√ê‚áÄ
f d)‚Ü¶ lv], le)
WriteStruct
lp ‚ä¢ (H, subbuf (b, n, []) n‚Ä≤ ) _ (H, (b, n + n‚Ä≤, []))
Subbuf
lp ‚ä¢ (H, (b, n,
√ê‚áÄ
f d)‚ñ∑ f d ‚Ä≤) _ (H, (b, n, (√ê‚áÄf d ; f d ‚Ä≤)))
StructField
lp ‚ä¢ (H, let x ‚à∂ t = v in le) _ (H, [v/x]le)
Let
lp ‚ä¢ (H, let _ = v in le) _ (H, le)
ALet
{
√ê√ê√ê√ê‚áÄ
f d = lv}(f d ‚Ä≤) = lv ‚Ä≤
lp ‚ä¢ (H, {
√ê√ê√ê√ê‚áÄ
f d = lv}.f d ‚Ä≤) _ (H, lv ‚Ä≤)
Proj
n /= 0
lp ‚ä¢ (H, if n then le1 else le2) _brT (H, le1)
IfT n = 0
lp ‚ä¢ (H, if n then le1 else le2) _brF (H, le2)
IfF
b /‚àà H
lp ‚ä¢ (H, let x = newbuf n (lv ‚à∂ t) in le) _write (b,0,[]), . . .,write (b,n‚àí1,[]) (H [b ‚Ü¶ lv
n
], [(b, 0, [])/x]le)
NewBuf
b /‚àà H
lp ‚ä¢ (H, let x = newstruct (lv ‚à∂ t) in le) _write (b,0,[]) (H [b ‚Ü¶ lv], [(b, 0, [])/x]le)
NewStruct
lp ‚ä¢ (H, withframe le) _ (H ;{}, pop le)
WF
lp ‚ä¢ (H ;h, pop lv) _ (H, lv)
Pop
lp ‚ä¢ (H, le) _l (H ‚Ä≤, le ‚Ä≤)
lp ‚ä¢ (H, LE [le])‚Üùl (H
‚Ä≤
, LE [le ‚Ä≤])
Step
Fig. 15. Œªow‚àó Atomic Reduction and Reduction
Verified Low-Level Programming Embedded in F‚àó 35
C ŒªOW‚àó TO C‚àó COMPILATION
The compilation procedure is dened in Figure 16 as inference rules, which should be read as a
function dened by pattern-matching, with earlier rules shadowing later rules. The compilation
is a partial function, encoding syntactic constraints on Œªow‚àó programs that can be compiled. For
example, compilable Œªow‚àó top-level functions must be wrapped in a withframe construct.
¬£ le = e and ‚Üì le = ss and ‚áä ld = d
¬£ n = n ¬£ (b, n, []) = (b, n, []) ¬£ {
√ê√ê√ê√ê‚áÄ
f d = le} = {
√ê√ê√ê√ê‚áÄ
f d =¬£ le} ¬£ x = x
¬£ subbuf le1 le2 =¬£ le1+ ¬£ le2
¬£ le ‚ñ∑ f d = & ¬£ le ‚Üí f d
¬£ le = e ‚Üì le1 = ss
‚Üì (let x ‚à∂ t = f le in le1) = (t x = f (e); ss)
¬£ lei = ei (i = 1, 2) ‚Üì le = ss
‚Üì let x ‚à∂ t = readbuf le1 le2 in le = (t x = ‚àó[e1 + e2]; ss)
¬£ lei = ei (i = 1) ‚Üì le = ss
‚Üì let x ‚à∂ t = readstruct le1 in le = (t x = ‚àó[e1]; ss)
¬£ lei = ei (i = 1, 2, 3) ‚Üì le = ss
‚Üì (let _ = writebuf le1 le2 le3 in le) = (‚àó[e1 + e2] = e3; ss)
¬£ lei = ei (i = 1, 2) ‚Üì le = ss
‚Üì (let _ = writestruct le1 le2 in le) = (‚àó[e1] = e2; ss)
¬£ le = e ‚Üì le1 = ss
‚Üì (let x = newbuf n (le ‚à∂ t) in le1) = (t x[n];memset x n e ; ss)
¬£ le = e ‚Üì le1 = ss
‚Üì (let x = newstruct (le ‚à∂ t) in le1) = (t x[1];memset x 1 e ; ss)
‚Üì (withframe le) = {‚Üì le}
¬£ le = e ‚Üì lei = ssi (i = 1, 2)
‚Üì (if le then le1 else le2) = (if e then ss1 else ss2)
¬£ le = e ‚Üì le1 = ss
‚Üì (let x ‚à∂ t = le in le1) = (t x = e ; ss)
¬£ le = e ‚Üì le1 = ss
‚Üì (let _ = le in le1) = (e ; ss) ‚Üì le =¬£ le
‚áä (let x ‚à∂ t = lv) = (t x =¬£ lv)
‚Üì le = ss ; e
‚áä (let f = Œªx ‚à∂ t1 . withframe le ‚à∂ t2) = fun f (x ‚à∂ t1) ‚à∂ t2 { ss ; return e }
Fig. 16. Œªow‚àó to C‚àó compilation
36 Protzenko et al.
D BISIMULATION PROOF
The main results are Theorem D.6 and D.7, in terms of some notions dened before them in this
section. The two theorems are proved by using the crucial Lemma D.12 to ‚Äúip the diagram‚Äù, i.e.,
proving C‚àó renes Œªow‚àó by proving Œªow‚àó renes C‚àó. The ipping relies on the fact that C‚àó is
deterministic modulo renaming of block identiers. An alternative way of determinization to
renaming of block identiers is to have the stream of random coins for choosing block identiers
as part of the conguration (state).
That C‚àó semantics use big-step semantics for C‚àó expressions complicates the bisimulation proof
a bit because Œªow‚àó and C‚àó steps may go out-of-sync at times. Within the proof we used a relaxed
notion of simulation (‚Äúquasi-renement‚Äù) that allows this temporary discrepancy by some stuttering,
but still implies bisimulation.
The specic relation between a Œªow‚àó conguration and its C‚àó counterpart is dened in Denition
D.14 as Relation R. It is dened in terms of a C‚àó-to-Œªow‚àó back-translation, listed in Fig 18. We need
a back-translation here instead of the Œªow‚àó-to-C‚àó forward-translation as dened before, because a
C‚àó conguration has a clear call-stack with each frame containing its own variable environment
and continuation, while a Œªow‚àó conguration contains one giant Œªow‚àó expression which makes
it impossible to recover the call-stack. Hence for relating two congurations in the middle of
reduction, only the C‚àó-to-Œªow‚àó direction is possible.
Denition D.1 ((Labelled) Transition System). A transition system is a 5-tuple (Œ£,L,‚Üù, s0, F),
where Œ£ is a set of states, L is a monoid which is the set of labels, ‚Üù ‚äÜ Œ£ √ó option L √ó Œ£ is the step
relation, s0 is the initial state, and F is a set of designated nal state.
In the following text, we use œµ to denote an empty label (the unit of the monoid L), l to range
over non-empty (non-œµ) labels and o to range over possibly empty labels. When the label is empty,
we can omit it. The label of multiple steps is the combined label of each steps, using the addition
operator of monoid L. We dene a ‚áìo a‚Ä≤
def
= a ‚Üù‚àóo a
‚Ä≤ and a‚Ä≤ ‚àà F .
Denition D.2 (Safety). A transition system A is safe i for all s so that s0 ‚Üù‚àó s , s is unstuck,
where unstuck(s) is dened as either s ‚àà F or there exists s‚Ä≤ so that s ‚Üù s‚Ä≤.
Denition D.3 (Renement). A transition system A renes a transition system B (with the same
label set) by R (or R is a renement for transition system A of transition system B) i
(1) there exists a well-founded measure ‚à£ ‚àí ‚à£b (indexed by a B-state b) dened on the set of
A-states {a ‚à∂ Œ£A ‚à£ a R b};
(2) a0 R b0, that is, the two initial states are in relation R;
(3) for all a ‚à∂ Œ£A and b ‚à∂ Œ£B such that a R b,
(a) if a ‚Üùo a‚Ä≤ for some a‚Ä≤ ‚à∂ Œ£A, then there exists b‚Ä≤ ‚à∂ Œ£B and n such that b ‚Üùno b‚Ä≤ and a‚Ä≤ R b‚Ä≤
and that n = 0 implies that ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b ;
(b) if a ‚àà FA, then there exists b‚Ä≤ ‚à∂ Œ£B such that b ‚áìœµ b‚Ä≤ and a R b‚Ä≤.
A renes B i there exists R so that A renes B by R.
Denition D.4 (Bisimulation). A transition systemA bisimulates a transition system B iA renes
B and B renes A.
Denition D.5 (Transition System of C‚àó and Œªow‚àó).
sysC‚àó(p,V , ss)
def
= (C,{
√ê‚áÄ
l },p ‚ä¢‚Üù, ([],V , ss),{([],V ‚Ä≤, return e)})
sysŒªow‚àó(lp, le)
def
= ({(H , le)},{
√ê‚áÄ
l }, lp ‚ä¢‚Üù, ([], le),{([], lv)})
Verified Low-Level Programming Embedded in F‚àó 37
In the following text, we treat label read/write (b,n) and read/write (b,n, []) as equal, and if
we have a Œªow‚àó value or substitution, we freely use it as a C‚àó one because coercion from Œªow‚àó
value to C‚àó value is straight-forward.
Theorem D.6 (Safety). For all Œªow‚àó program lp, closed expression le and closing substitution V ,
if ‚áä lp = p, ‚Üì le = ss and sysŒªow‚àó(lp,V (le)) is safe, then sysC‚àó(p,V , ss) is safe.
Proof. Appeal to Lemma D.12, Lemma D.16 and Lemma D.15. 
Theorem D.7 (Bisimulation). For all Œªow‚àó program lp, closed expression le and closing substitution
V , if ‚áä lp = p and ‚Üì le = ss , then sysC‚àó(p,V , ss) bisimulates sysŒªow‚àó(lp,V (le)).
Proof. Appeal to Corollary D.13, Lemma D.16 and Lemma D.15. 
Denition D.8 (Determinism). A transition system A is deterministic i for all s so that s0 ‚Üù‚àó s ,
s ‚àà F implies that s cannot take any step, and s ‚Üùo1 s1 and s ‚Üùo2 s2 implies that o1 = o2 and s1 = s2.
Denition D.9 (Quasi-Renement). A transition system A quasi-renes a transition system B
(with the same label set) by R (or R is a quasi-renement for transition system A of transition
system B) i
(1) there exists a well-founded measure ‚à£ ‚àí ‚à£b (indexed by a B-state b) dened on the set of
A-states {a ‚à∂ Œ£A ‚à£ a R b};
(2) a0 R b0, that is, the two initial states are in relation R;
(3) for all a ‚à∂ Œ£A and b ‚à∂ Œ£B such that a R b,
(a) if a ‚Üùo a‚Ä≤ for some a‚Ä≤ ‚à∂ Œ£A, then there exists a‚Ä≤‚Ä≤ ‚à∂ Œ£A, b‚Ä≤ ‚à∂ Œ£B and n such that a‚Ä≤ ‚Üù‚àóœµ a‚Ä≤‚Ä≤
and b ‚Üùno b‚Ä≤ and a‚Ä≤‚Ä≤ R b‚Ä≤ and that n = 0 implies that ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b ;
(b) if a ‚àà FA, then there exists b‚Ä≤ ‚à∂ Œ£B such that b ‚áìœµ b‚Ä≤ and a R b‚Ä≤.
A quasi-renes B i there exists R so that A quasi-renes B by R.
Lemma D.10 (asi-refine-Refine). If transition system A is deterministic, then A quasi-renes
transition system B implies that A renes B.
Proof. Let R be the quasi-renement for A of B.
Dene R‚Ä≤ to be: a R‚Ä≤ b i ‚àÉn. (‚àÉa‚Ä≤. a ‚Üùnœµ a‚Ä≤ ‚àß a‚Ä≤ R b).
We are to show that A renes B by R‚Ä≤. Unfold Denition D.3.
For Condition 1, dene ‚à£a‚à£b to be the minimal of the number n in the denition of R‚Ä≤, which uniquely
exists.
For Condition 2, we are to show a0 R‚Ä≤ b0. We know that a0 R b0, so it‚Äôs obviously true.
For Condition 3(a), we have a R‚Ä≤ b and a ‚Üùo a‚Ä≤.
We are to exhibit b‚Ä≤ and n so that b ‚Üùno b‚Ä≤ and a‚Ä≤ R‚Ä≤ b‚Ä≤ and that n = 0 implies ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b .
From a R‚Ä≤ b, we have a ‚Üùmœµ a‚Ä≤‚Ä≤ and a‚Ä≤‚Ä≤ R b.
Ifm = 0, we know a R b. Because A quasi-renes B by R, we have a‚Ä≤ ‚Üù‚àóœµ a2 and b ‚Üùno b‚Ä≤ and a2 R b‚Ä≤
and that n = 0 implies ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b .
Pick b‚Ä≤ to be b‚Ä≤ and n to be n. It suces to show a‚Ä≤ R‚Ä≤ b‚Ä≤, which is true because a‚Ä≤ ‚Üù‚àóœµ a2 and a2 R b‚Ä≤.
Ifm > 0, pick b‚Ä≤ to be b and n to be 0. Because A is deterministic, we know a‚Ä≤ R‚Ä≤ b withm ‚àí 1 and
‚à£a‚à£b =m and ‚à£a‚Ä≤‚à£b =m ‚àí 1.
For Condition 3(b), we have a R‚Ä≤ b and a ‚àà FA.
We are to exhibit b‚Ä≤ such that b ‚áìœµ b‚Ä≤ and a R‚Ä≤ b‚Ä≤.
Because A is deterministic and a ‚àà FA, we havem = 0 and a R b.
Because A quasi-renes B with R, we have b ‚áìœµ b‚Ä≤ and a R b‚Ä≤.
Pick b‚Ä≤ to be b‚Ä≤. It suces to show a R‚Ä≤ b‚Ä≤, which is trivially true.

38 Protzenko et al.
Lemma D.11 (Refine-Safety). If transition system A renes transition system B by R and for any
a and b we have a R b implies unstuck(a), then A is safe.
Proof. From Denition D.3 we know (‚àÉb . a R b) is an invariant of A. Hence unstuck(a) is also
an invariant of A. 
Lemma D.12 (Deterministic Reverse). If transition system A is deterministic and transition
system B is safe, then B renes A implies that A renes B and A is safe.
Proof. Appealing to Lemma D.11, we will exhibit the renement for A of B and show that it
implies unstuckness.
Let R be the renement for B of A. Dene R‚Ä≤ to be:
a R‚Ä≤ b i
b0 ‚Üù
‚àó b ‚àß ((‚àÉo b‚Ä≤. b ‚Üùo b
‚Ä≤ ‚àß ‚àÉn1 a2 a3 a4. (a ‚Üù
‚àó
œµ a2 ‚à® a2 ‚Üù
‚àó
œµ a) ‚àß b R a2 ‚àß a2 ‚Üù
‚àó
o a3 ‚àß a ‚Üù
n1
o
a3 ‚àß a3 ‚Üù
‚àó
œµ a4 ‚àß b
‚Ä≤ R a4) ‚à® (b ‚àà FB ‚àß ‚àÉn2 a2 a3. (a ‚Üù
‚àó
œµ a2 ‚à® a2 ‚Üù
‚àó
œµ a) ‚àß b R a2 ‚àß a2 ‚Üù
‚àó
œµ a3 ‚àß a ‚Üù
n2
œµ
a3 ‚àß a3 ‚àà FA ‚àß b R a3)).
Let‚Äôs rst prove the fact (Fact 1) that if b0 ‚Üù‚àó b and a ‚Üù‚àóœµ a‚Ä≤ and b R a, then a R‚Ä≤ b.
Because B is safe, we know that either b ‚Üùo b‚Ä≤ or b ‚àà FB .
In the rst case, because B renes A by R, we have a‚Ä≤ ‚Üùno a‚Ä≤‚Ä≤ and b R a‚Ä≤‚Ä≤.
It‚Äôs easy to show a R‚Ä≤ b by choosing the rst disjunct and picking o,b‚Ä≤,a2,a4 to be o,b‚Ä≤,a‚Ä≤,a‚Ä≤‚Ä≤. n1
and a3 exist in this case.
In the second case, because B renes A by R, we have a‚Ä≤ ‚áìœµ a‚Ä≤‚Ä≤ and b R a‚Ä≤‚Ä≤.
It‚Äôs easy to show a R‚Ä≤ b by choosing the second disjunt and picking a2,a3 to be a‚Ä≤,a‚Ä≤‚Ä≤. n2 obviously
exists.
Now we are to show A renes B by R‚Ä≤. Unfold Denition D.3.
For Condition 1, dene ‚à£a‚à£b to be lexicographic order of two numbers.
The rst number is the minimal of the number n2 in the denition of R‚Ä≤ if b is a value, which
uniquely exists; or 0 otherwise.
The second number is the minimal of the number n1 in the denition of R‚Ä≤ if b can take a step,
which uniquely exists; or 0 otherwise.
For Condition 2, we are to show a0 R‚Ä≤ b0, which is true because of b0 R a0 and Fact 1.
For Condition 3(a), we have a R‚Ä≤ b and a ‚Üùo a‚Ä≤.
We are to exhibit b‚Ä≤ and n such that b ‚Üùno b‚Ä≤ and a‚Ä≤ R b‚Ä≤ and that n = 0 implies ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b .
Unfold a R‚Ä≤ b, we have the two disjuncts.
In case o = l , only the rst disjunt is possible, and we have b ‚Üùl b‚Ä≤ and a‚Ä≤ ‚Üù‚àóœµ a4 and b‚Ä≤ R a4.
Pick b‚Ä≤,n to be b‚Ä≤, 1. From Fact 1, we know a‚Ä≤ R‚Ä≤ b‚Ä≤.
In case o = œµ , both disjuncts of a R‚Ä≤ b are possible.
If a R‚Ä≤ b because of the rst conjunct, we have b ‚Üùo‚Ä≤ b‚Ä≤ ‚àß (a ‚Üù‚àóœµ a2 ‚à® a2 ‚Üù‚àóœµ a) ‚àß b R a2 ‚àß a2 ‚Üù‚àóo‚Ä≤
a3 ‚àß a ‚Üù
n1
o‚Ä≤ a3 ‚àß a3 ‚Üù
‚àó
œµ a4 ‚àß b
‚Ä≤ R a4.
We case-analyse on whether o‚Ä≤ is œµ .
If o‚Ä≤ = l , let the second component of ‚à£a‚à£b (denoted by ‚à£a‚à£b .2) be m. We case-analyse on whether
m > 1.
Ifm > 1, pick b‚Ä≤,n to be b, 0 (i.e. do not move on the B side). We need to show a‚Ä≤ R‚Ä≤ b and ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b .
a‚Ä≤ R‚Ä≤ b because according tom > 1 and a ‚Üùœµ a‚Ä≤, we know that a‚Ä≤ is still before the l-label step.
‚à£a‚à£b > ‚à£a
‚Ä≤‚à£b is true because according tom > 1, it must be the case that ‚à£a‚Ä≤‚à£b .2 = ‚à£a‚à£b .2 ‚àí 1; and as for
‚à£a‚Ä≤‚à£b .1, which represents the minimal number of steps to terminate (or 0 otherwise), taking one
step will not increase it.
Verified Low-Level Programming Embedded in F‚àó 39
Ifm ‚â§ 1, we know that a ‚Üùl a‚Ä≤‚Ä≤ for some a‚Ä≤‚Ä≤. But we also have a ‚Üùœµ a‚Ä≤, so this case is impossible
because of A‚Äôs determinism.
If o‚Ä≤ = œµ , because B is safe and B renes A by R, we can step on the B side for nite steps
to reach b2 such that b‚Ä≤ ‚Üù‚àóœµ b2 and b2 R a and either b2 ‚Üùo‚Ä≤‚Ä≤ b3 ‚àß a ‚Üù+o‚Ä≤‚Ä≤ a
‚Ä≤‚Ä≤ ‚àß b3 R a
‚Ä≤‚Ä≤ or
b2 ‚àà FB ‚àß a ‚Üù
‚àó
œµ a
‚Ä≤‚Ä≤ ‚àß a‚Ä≤‚Ä≤ ‚àà FA ‚àß b2 R a
‚Ä≤‚Ä≤.
In the rst case, because A is deterministic, we have a ‚Üùœµ a‚Ä≤ ‚Üù‚àóo‚Ä≤‚Ä≤ a
‚Ä≤‚Ä≤.
If o‚Ä≤‚Ä≤ = œµ , pick b‚Ä≤ to be b3. Because of a‚Ä≤ ‚Üù‚àóœµ a‚Ä≤‚Ä≤ and b3 R a‚Ä≤‚Ä≤ and Fact 1, we get a‚Ä≤ R‚Ä≤ b3.
If o‚Ä≤‚Ä≤ = l , pick b‚Ä≤ to be b2. Since b ‚Üùœµ b‚Ä≤ ‚Üù‚àóœµ b2, we just need to show that a‚Ä≤ R‚Ä≤ b2, which is easy to
show by choosing the rst disjunct for R‚Ä≤ and picking b‚Ä≤,a2,a4 to be b3,a,a‚Ä≤‚Ä≤.
In the second case (b2 ‚àà FB ), it must be case that a ‚Üùœµ a‚Ä≤ ‚Üù‚àóœµ a‚Ä≤‚Ä≤ ‚àà FA. Pick b‚Ä≤ to be b2, we need to
show a‚Ä≤ R‚Ä≤ b2, which is true because a‚Ä≤ ‚Üù‚àóœµ a‚Ä≤‚Ä≤ and a‚Ä≤‚Ä≤ R‚Ä≤ b2.
If a R‚Ä≤ b because of the second conjunct, we have b ‚àà FB ‚àß (a ‚Üù‚àóœµ a2 ‚à® a2 ‚Üù‚àóœµ a) ‚àß b R a2 ‚àß a2 ‚Üù‚àóœµ
a3 ‚àß a ‚Üù
n2
œµ a3 ‚àß a3 ‚àà FA ‚àß b R a3.
Because A is deterministic, it must be the case that a ‚Üùœµ a‚Ä≤ ‚Üù‚àóœµ a3.
Pick b‚Ä≤,n to be b, 0. We need to show a‚Ä≤ R‚Ä≤ b and ‚à£a‚à£b > ‚à£a‚Ä≤‚à£b . a‚Ä≤ R‚Ä≤ b because a‚Ä≤ ‚Üù‚àóœµ a3 and a3 R‚Ä≤ b.
‚à£a‚à£b > ‚à£a
‚Ä≤‚à£b because ‚à£a‚à£b .1 > ‚à£a‚Ä≤‚à£b .1, which is true because a‚Ä≤ is one step closer to terminate.
For Condition 3(b), we have a R‚Ä≤ b and a ‚àà FA.
We are to exhibit b‚Ä≤ such that b ‚áìœµ b‚Ä≤ and a R‚Ä≤ b‚Ä≤.
If a R‚Ä≤ b because of the second disjunct, we have b ‚àà FB ‚àß a ‚Üù‚àóœµ a3 ‚àßb R a3. Because a ‚àà FA and A is
deterministic, we know that a3 = a
Pick b‚Ä≤ to be b. a R‚Ä≤ b is true because b R a and Fact 1.
If a R‚Ä≤ b because of the rst disjunct, we have b ‚Üùo b2 ‚àß a ‚Üù‚àóo a4 ‚àß b2 R a4.
Because a ‚àà FA and A is deterministic, we know that a4 = a and o = œµ .
If b2 ‚àà FB , pick b‚Ä≤ to be b2. a R‚Ä≤ b2 is true with the same reasoning as before.
Otherwise, because B is safe and B renes A by R, we can step b2 for nite steps (because a cannot
step and ‚à£b‚à£a > ‚à£b2‚à£a ) to have b2 ‚Üù‚àóœµ b3 ‚àß b3 R a.
Pick b‚Ä≤ to be b3. a R‚Ä≤ b3 is true with the same reasoning as before.
Now we prove that a R‚Ä≤ b implies unstuck(a) for any a and b.
Unfolding a R‚Ä≤ b, in both disjuncts we have a ‚Üùn a‚Ä≤ and b‚Ä≤ R a‚Ä≤ for some b‚Ä≤.
If n > 0, unstuck(a) is obviously true.
If n = 0, we have b‚Ä≤ R a. Because B is safe, we know that either b‚Ä≤ ‚Üù b‚Ä≤‚Ä≤ or b‚Ä≤ ‚àà FB .
In case b‚Ä≤ ‚àà FB , we know a ‚áìœµ a2. Because A is deterministic, unstuck(a) is true.
In case b‚Ä≤ ‚Üù b‚Ä≤‚Ä≤, because B renes A by R, we know a ‚Üùk a2 and b‚Ä≤‚Ä≤ R a2 and that k = 0 implies
‚à£b‚Ä≤‚à£a > ‚à£b
‚Ä≤‚Ä≤‚à£a .
Thus b‚Ä≤ can step nite number of k = 0 steps before hitting the b‚Ä≤ ‚àà FB case or the k > 0 case, in
both of which we have unstuck(a). 
Corollary D.13 (Deterministic Reverse). If transition system A is deterministic and transition
system B is safe, then B renes A implies that A bisimulates B and A is safe.
Denition D.14 (Relation R). For any p and lp, dene relation Rp,lp as: (H , le) Rp,lp (S,V , ss)
i there exists a minimal n such that (H , le) ‚Üùnlp (H , le
‚Ä≤) and (H , le‚Ä≤) =9 (S,V , ss), where 9
(S,V , ss)
def
= (mem(S),unravel(S,V (‚Üë (‚áì(p,V ) ss)))) and mem(S) is all the memory parts of S
collected together (and requiring that there is no ¬ñ in S‚Äôs memory parts).
40 Protzenko et al.
unravel(S, le) def= foldl unravel_frame le S
unravel_frame((M,V ,E), le) def=
‚éß‚é™‚é™
‚é®
‚é™‚é™‚é©
V ((‚Üü E) [le]) if M = ¬ñ
V ((‚Üü E) [pop le]) if M = ‚åä_‚åã
.
‚áì(p,V ) ss = ss
‚ü¶e‚üß(p,V ) = v
‚áì(p,V ) (t x = e; ss) = (t x = v ; ss)
‚ü¶e‚üß(p,V ) = v
‚áì(p,V ) (t x = f (e); ss) = (t x = f (v); ss)
‚áì(p,V ) (t x[n]; ss) = (t x[n]; ss)
‚ü¶e‚üß(p,V ) = v
‚áì(p,V ) (return e; ss) = (return v ; ss)
‚ü¶ei‚üß(p,V ) = vi (i = 1, 2)
‚áì(p,V ) (t x = ‚àó[e1]e2; ss) = (t x = ‚àó[v1]v2; ss)
‚ü¶ei‚üß(p,V ) = vi (i = 1, 2, 3)
‚áì(p,V ) (‚àó[e1 + e2] = e3; ss) = (‚àó[v1 +v2] = v3; ss)
‚ü¶e‚üß(p,V ) = v
‚áì(p,V ) (e; ss) = (v ; ss)
‚ü¶ei‚üß(p,V ) = vi (i = 1, 2)
‚áì(p,V ) (memset e1 n e2; ss) = (memset v1 n v2; ss)
Fig. 17. Normalize C‚àó head expression
Verified Low-Level Programming Embedded in F‚àó 41
¬© e = le and ‚Üë ss = le and ‚áà d = ld and ‚Üü E = LE
¬© n = n ¬© (b, n, []) = (b, n, []) ¬© {
√ê√ê√ê‚áÄ
f d = e} = {
√ê√ê√ê√ê‚áÄ
f d =¬© e} ¬© () = ()
¬© x = x
¬© lei = ei (i = 1, 2)
¬© (e1 + e2) = subbuf le1 le2
¬© lei = ei (i = 1)
¬© &e1 ‚Üí f d = le1 ‚ñ∑ f d
¬© e = le1 ‚Üë ss = le
‚Üë (t x = f (e); ss) = (let x ‚à∂ t = f le1 in le)
¬© e = le1 ‚Üë ss = le
‚Üë (t x[n];memset x n e ; ss) = (let x = newbuf n (le1 ‚à∂ t) in le)
¬© e = le1 ‚Üë ss = le t is a struct type
‚Üë (t x[1];memset x 1 e ; ss) = (let x = newstruct (le1 ‚à∂ t) in le)
¬© e = le1 ‚Üë ss = le
‚Üë (t x = e ; ss) = (let x ‚à∂ t = le1 in le)
¬© ei = lei (i = 1, 2) ‚Üë ss = le
‚Üë (t x = ‚àó[e1 + e2]; ss) = (let _ = readbuf le1 le2 in le)
¬© ei = lei (i = 1) ‚Üë ss = le
‚Üë (t x = ‚àó[e1]; ss) = (let _ = readstruct le1 in le)
¬© ei = lei (i = 1, 2, 3) ‚Üë ss = le
‚Üë (‚àó[e1 + e2] = e3; ss) = (let _ = writebuf le1 le2 le3 in le)
¬© ei = lei (i = 1, 2) ‚Üë ss = le
‚Üë (‚àó[e1] = e2; ss) = (let _ = writestruct le1 le2 in le)
‚Üë ss1 = le1 ‚Üë ss = le
‚Üë ({ss1}; ss) = (let _ = withframe le1 in le)
¬© e = le1 ‚Üë ss = le
‚Üë (e ; ss) = (let _ = le1 in le)
¬© e = le ‚Üë ssi = lei (i = 1, 2, 3)
‚Üë (if e then ss1 else ss2; ss3) = (let _ = if le then le1 else le2 in le3)
¬© e = le
‚Üë [e] = le ‚Üë [] = ()
‚áà (t x = v) = (let x ‚à∂ t =¬© v)
‚Üë (ss ; e) = le
‚áà (fun f (x ‚à∂ t1) ‚à∂ t2 { ss ; return e }) = (let f = Œªx ‚à∂ t1 . withframe le ‚à∂ t2)
‚Üë ss = le
‚Üü (‚óª; ss) = (let _ = ‚óª in le)
‚Üë ss = le
‚Üü (t x = ‚óª; ss) = (let x ‚à∂ t = ‚óª in le)
Fig. 18. C‚àó to Œªow‚àó back-translation
42 Protzenko et al.
Lemma D.15 (Œªow‚àó Refines C‚àó). For all Œªow‚àó program lp, closed expression le and closing substi-
tution V , if ‚áä lp = p and ‚Üì le = ss , then sysŒªow‚àó(lp,V (le)) renes sysC‚àó(p,V , ss).
Proof. We apply Lemma D.10 and D.17, and prove that sysŒªow‚àó(lp, le) quasi-renes sysC‚àó(p, ss).
We pick the relation Rp,lp in Denition D.14 to be the simulation relation and prove Rp,lp is a
quasi-renement for sysŒªow‚àó(lp, le) of sysC‚àó(p, ss).
Unfold Denition D.9.
For Condition 1, dene the well-founded measure ‚à£(H , le)‚à£(S,V ,ss) (where (H , le) R (S,V , ss)) to be
the minimal of the number n in R‚Äôs denition.
For condition 2, appeal to Lemma D.18.
Now prove Condition 3(a). Let (H , le) be the Œªow‚àó conguration and C = (S,V , ss) be the C‚àó
conguration.
We are to exhibit (H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) and C‚Ä≤ and n such that (H ‚Ä≤, le‚Ä≤) ‚Üù‚àó (H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) and C ‚Üùn C‚Ä≤ and
(H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) R C‚Ä≤ and that n = 0 implies ‚à£(H , le)‚à£C > ‚à£(H ‚Ä≤, le‚Ä≤)‚à£C .
For all the cases except Case Pop, we pick (H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) to be (H ‚Ä≤, le‚Ä≤) (i.e. do not use the extra exibility
oered by Quasi-Renement).
Induction on (H , le)‚Üù (H ‚Ä≤, le‚Ä≤).
Case Let: on case (H ,LE [let x ‚à∂ t = lv in le])‚Üù (H ,LE [[lv/x]le]).
We are to exhibit C‚Ä≤ such that (S,V , ss)‚Üù+ C‚Ä≤ and
(H ,LE [[lv/x]le]) R C‚Ä≤.
Apply Lemma D.20.
In the rst case, we have le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª), where v def= ‚ü¶e‚üß(p,V ).
The C‚àó side runs with nonzero steps to (S,V [x ‚Ü¶ v], ss‚Ä≤).
Pick C‚Ä≤ to be this conguration.
It suces to show that (H ,LE [[lv/x]le]) R (S,V [x ‚Ü¶ v], ss‚Ä≤).
Appealing to Lemma D.19, it suces to show that LE [[lv/x]le] = unravel(S,V [x ‚Ü¶ v](‚Üë ss‚Ä≤)),
which is true.
In the second case, the C‚àó side runs with nonzero steps to (S ‚Ä≤,V ‚Ä≤[x ‚Ü¶ v], ss‚Ä≤). The proof is the
same as the rst case.
End of case.
Case ALet: on case (H ,LE [let _ = lv in le])‚Üù (H ,LE [le]).
Appealing to Lemma D.21, the proof is similar to the previous case.
End of case.
Case App: on case (H ,LE [let x ‚à∂ t = f lv in le]) ‚Üù (H ,LE [let x ‚à∂ t = [lv/y]le1 in ]le) and
lp(f ) = Œªy ‚à∂ t1. le1 ‚à∂ t2.
Appealing to Lemma D.28, we have ss = (t x = f (v); ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v and
LE = unravel(S,‚óª).
Because ‚áä lp = p, we know le1 = withframe le2 and ‚Üì le2 = ss2;e and p(f ) = fun (y ‚à∂ t1) ‚à∂ t2 { ss1 }
and ss1 = (ss2; return e).
Appealing to Lemma D.32, we know ‚Üë ss1 = le2 hence ‚Üë {ss1} = le1.
Pick C‚Ä≤ to be (S ; (¬ñ,V , t x = ‚óª; ss‚Ä≤),{y ‚Ü¶ v},{ss1}).
It suces to show that
(H ,LE [let x ‚à∂ t = [lv/v]le1 in le]) R (S ; (¬ñ,V , t x = ‚óª; ss‚Ä≤),{y ‚Ü¶ v},{ss1}), which is true.
End of case.
Verified Low-Level Programming Embedded in F‚àó 43
Case Withframe:
on case (H ,LE [withframe le])‚Üù (H ;{},LE [pop le]).
Appealing to Lemma D.29, we have ss = {ss1}; ss2 and le = V (‚Üë ss1) and LE = unravel(S,V (‚Üü
(‚óª; ss2))).
Pack C‚Ä≤ to be (S ; ({},V ,‚óª; ss2),V , ss1).
It suces to show that
(H ;{},LE [pop le]) R (S ; ({},V ,‚óª; ss2),V , ss1), which is true.
End of case.
Case Newbuf : on case (H ;h,LE [let x = newbuf n (lv ‚à∂ t) in le]) ‚Üùwrite (b,0,[]), ...,write (b,n‚àí1,[])
(H ;h[b ‚Ü¶ lvn],LE [[(b, 0, [])/x]le]) and b /‚àà H ;h.
We have (H ;h,LE [let x = newbuf n (lv ‚à∂ t) in le]) R (S,V , ss).
We are to exhibit C‚Ä≤ so that
(H ;h[b ‚Ü¶ lvn], [(b, 0, [])/x]le) R C‚Ä≤ and (S,V , ss)‚Üù+ C‚Ä≤.
Appealing to Lemma D.22, we have ss = (t x[n];memset x n v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v
and LE = unravel(S,‚óª) and S = S ‚Ä≤; (M,V ‚Ä≤,E).
Pick C‚Ä≤ to be (S ‚Ä≤; (M[b ‚Ü¶ vn],V ‚Ä≤,E),V [x ‚Ü¶ (b, 0, [])], ss‚Ä≤).
It suces to show that (H ;h[b ‚Ü¶ lvn],LE [[(b, 0, [])/x]le]) R (S ‚Ä≤; (M[b ‚Ü¶ vn],V ‚Ä≤,E),V [x ‚Ü¶
(b, 0, [])], ss‚Ä≤), which is true.
End of case.
Case Newstruct: on case (H ;h,LE [let x = newstruct (lv ‚à∂ t) in le]) ‚Üùwrite (b,0,[]) (H ;h[b ‚Ü¶
lv], [(b, 0, [])/x]le) and b /‚àà H ;h.
We have (H ;h, let x = newstruct (lv ‚à∂ t) in le) R (S,V , ss).
We are to exhibit C‚Ä≤ so that
(H ;h[b ‚Ü¶ lv],LE [[(b, 0, [])/x]le]) R C‚Ä≤ and (S,V , ss)‚Üù+ C‚Ä≤.
Appealing to Lemma D.23, we have ss = (t x[1];memset x 1 v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v
and LE = unravel(S,‚óª) and S = S ‚Ä≤; (M,V ‚Ä≤,E).
Pick C‚Ä≤ to be (S ‚Ä≤; (M[b ‚Ü¶ v],V ‚Ä≤,E),V [x ‚Ü¶ (b, 0, [])], ss‚Ä≤).
It suces to show that (H ;h[b ‚Ü¶ lv],LE [[(b, 0, [])/x]le]) R (S ‚Ä≤; (M[b ‚Ü¶ v],V ‚Ä≤,E),V [x ‚Ü¶
(b, 0, [])], ss‚Ä≤), which is true.
End of case.
Case Readbuf : on case
(H ,LE [let x ‚à∂ t = readbuf (b,n, []) n‚Ä≤ in le]) ‚Üùread (b,n+n‚Ä≤,[]) (H ,LE [[lv/x]le]) and H(b,n +
n‚Ä≤, []) = lv .
Appealing to Lemma D.24, we have ss = (t x = (b,n, [])[n‚Ä≤]; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and LE =
unravel(S,‚óª).
Pick C‚Ä≤ to be (S,V [x ‚Ü¶ v], ss‚Ä≤) where v =¬£ lv .
We know C ‚Üù+read (b,n+n‚Ä≤,[]) C
‚Ä≤.
It suces to show that (H ,LE [[lv/x]le]) R (S,V [x ‚Ü¶ v], ss‚Ä≤), which is true because [lv/x]le =
V [x ‚Ü¶ v](‚Üë ss‚Ä≤).
End of case.
Case Readstruct: on case
(H ,LE [let x ‚à∂ t = readstruct (b,n,
√ê‚áÄ
f d) in le]) ‚Üù
read (b,n,
√ê‚áÄ
f d)
(H ,LE [[lv/x]le]) and H(b,n,
√ê‚áÄ
f d) =
lv .
44 Protzenko et al.
Appealing to Lemma D.25, we have ss = (t x = ‚àó[(b,n,
√ê‚áÄ
f d)]; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and LE =
unravel(S,‚óª).
Pick C‚Ä≤ to be (S,V [x ‚Ü¶ v], ss‚Ä≤) where v =¬£ lv .
We know C ‚Üù+
read (b,n,
√ê‚áÄ
f d)
C‚Ä≤.
It suces to show that (H ,LE [[lv/x]le]) R (S,V [x ‚Ü¶ v], ss‚Ä≤), which is true because [lv/x]le =
V [x ‚Ü¶ v](‚Üë ss‚Ä≤).
End of case.
Case Writebuf : on case
(H ,LE [let _ = writebuf (b,n, []) n‚Ä≤ lv in le]) ‚Üùwrite (b,n+n‚Ä≤,[]) (H[(b,n + n‚Ä≤, []) ‚Ü¶ lv],LE [le])
and (b,n + n‚Ä≤, []) ‚àà H .
Appealing to Lemma D.26, we have ss = ((b,n, [])[n‚Ä≤] = v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v and
LE = unravel(S,‚óª).
Pick C‚Ä≤ to be (S ‚Ä≤,V , ss‚Ä≤) where Set(S, (b,n, []),v) = S ‚Ä≤.
We know C ‚Üù+write (b,n+n‚Ä≤,[]) C
‚Ä≤.
It suces to show that (H[(b,n + n‚Ä≤, [])‚Ü¶ lv],LE [le]) R (S ‚Ä≤,V , ss‚Ä≤), which is true.
End of case.
Case Writestruct: on case
(H ,LE [let _ = writestruct (b,n,
√ê‚áÄ
f d) lv in le]) ‚Üù
write (b,n,
√ê‚áÄ
f d)
(H[(b,n,
√ê‚áÄ
f d) ‚Ü¶ lv],LE [le]) and
(b,n,
√ê‚áÄ
f d) ‚àà H .
Appealing to Lemma D.27, we have ss = (‚àó[(b,n,
√ê‚áÄ
f d)] = v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v and
LE = unravel(S,‚óª).
Pick C‚Ä≤ to be (S ‚Ä≤,V , ss‚Ä≤) where Set(S, (b,n,
√ê‚áÄ
f d),v) = S ‚Ä≤.
We know C ‚Üù+
write (b,n,
√ê‚áÄ
f d)
C‚Ä≤.
It suces to show that (H[(b,n,
√ê‚áÄ
f d)‚Ü¶ lv],LE [le]) R (S ‚Ä≤,V , ss‚Ä≤), which is true.
End of case.
Case Subbuf : on case (H ,LE [subbuf (b,n, []) n‚Ä≤ ])‚Üù (H ,LE [(b,n + n‚Ä≤, [])]).
Pick C‚Ä≤ to be (S,V , ss).
Because (H ,LE [subbuf (b,n, []) n‚Ä≤ ]) R C‚Ä≤ with some m, it must be the case that m ‚â• 1 and
(H ,LE [(b,n + n‚Ä≤, [])]) R C‚Ä≤ withm ‚àí 1.
End of case.
Case Structeld: on case (H ,LE [(b,n,
√ê‚áÄ
f d)‚ñ∑ f d ‚Ä≤])‚Üù (H ,LE [(b,n, (
√ê‚áÄ
f d ; f d ‚Ä≤))]).
Pick C‚Ä≤ to be (S,V , ss).
Because (H ,LE [(b,n,
√ê‚áÄ
f d) ‚ñ∑ f d ‚Ä≤]) R C‚Ä≤ with some m, it must be the case that m ‚â• 1 and
(H ,LE [(b,n, (
√ê‚áÄ
f d ; f d ‚Ä≤))]) R C‚Ä≤ withm ‚àí 1.
End of case.
Case IfTrue: on case (H ,LE [if n then le1 else le2])‚ÜùbrT (H ,LE [le1]) and n /= 0.
Appealing to Lemma D.30, we have ss = if e then ss1 else ss2; ss‚Ä≤ and ‚ü¶e‚üß(p,V ) = n and lei = V (‚Üë ssi)
(i = 1, 2) and LE = unravel(S,V (‚Üü (‚óª; ss‚Ä≤))).
Pick C‚Ä≤ to be (S,V , ss1; ss‚Ä≤).
Verified Low-Level Programming Embedded in F‚àó 45
We know C ‚Üù+brT C
‚Ä≤.
It suces to show that (H ,LE [le1]) R (S,V , ss1; ss‚Ä≤), which is true.
End of case.
Case IfFalse: on case (H ,LE [if n then le1 else le2])‚ÜùbrF (H ,LE [le2]) and n = 0.
Similar to previous case.
End of case.
Case Proj: on case (H ,LE [{
√ê√ê√ê√ê‚áÄ
f d = lv}. f d ‚Ä≤])‚Üù (H ,LE [lv‚Ä≤]) and {
√ê√ê√ê√ê‚áÄ
f d = lv}(f d ‚Ä≤) = lv‚Ä≤.
Pick C‚Ä≤ to be (S,V , ss).
Because (H ,LE [{
√ê√ê√ê√ê‚áÄ
f d = lv}. f d ‚Ä≤]) R C‚Ä≤ with somem, it must be the case thatm ‚â• 1 and (H ,LE [lv‚Ä≤]) R C‚Ä≤
withm ‚àí 1.
End of case.
Case Pop: on case (H ;h,LE [pop lv])‚Üù (H ,LE [lv]).
Apply Lemma D.31.
In the rst case, from LE = unravel(S ‚Ä≤,V ‚Ä≤(‚Üü ‚óª; ss‚Ä≤)) we know LE = (let _ = ‚óª in le) and
le = unravel(S ‚Ä≤,V ‚Ä≤(ss‚Ä≤)).
pick C‚Ä≤ to be (S ‚Ä≤,V ‚Ä≤, ss‚Ä≤) and (H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) to be (H , le).
Obviously (H ,LE [lv])‚Üù‚àó (H , le). It suces to show that (H , le) R (S ‚Ä≤,V ‚Ä≤, ss‚Ä≤), which is true.
In the second case, pick C‚Ä≤ to be (S ‚Ä≤,V ‚Ä≤,E [v]) and (H ‚Ä≤‚Ä≤, le‚Ä≤‚Ä≤) to be (H ,LE [lv]).
To suces to show (H ,LE [lv]) R (S ‚Ä≤,V ‚Ä≤,E [v]), which follows from LE = unravel(S ‚Ä≤,V ‚Ä≤(‚Üü E)).
For Condition 3(b), because Œªow‚àó and C‚àó‚Äôs values are almost the same (except that C‚àó loca-
tions have a eld-path component), every Œªow‚àó value has an obvious corresponding C‚àó value, so
condition 3(b) is trivially true. 
Lemma D.16 (C‚àó Deterministic). For all p and ss , transition system sysC‚àó(p, ss) is deterministic,
modulo renaming of block identiers.
Lemma D.17 (Œªow‚àó Deterministic). For all lp and le , transition system sysŒªow‚àó(lp, le) is deter-
ministic, modulo renaming of block identiers.
Lemma D.18 (Init). For all Œªow‚àó program lp, closed expression le and closing substitution V , if
‚áä lp = p and ‚Üì le = ss , then ([],V (le)) Rp,lp ([],V , ss).
Proof. Unfold R‚Äôs denition, it suces to show:
([],V (le))‚Üù‚àó ([],V (‚Üë (‚áì(p,{})‚Üì le))). 
Lemma D.19 (Eqal-Normalize). IfH = mem(S) and le = unravel(S,V (‚Üë ss)) and ‚áì(p,V ) ss = ss‚Ä≤,
then (H , le)‚Üù‚àó (H ,unravel(S,V (‚Üë ss‚Ä≤))).
Lemma D.20 (Invert Let). If (H ,LE [let x ‚à∂ t = lv in le]) R (S,V , ss), then either ss = (t x = e ; ss‚Ä≤)
and le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª), where v def= ‚ü¶e‚üß(p,V ) or S = S
‚Ä≤; (¬ñ,V ‚Ä≤, t x =
‚óª; ss‚Ä≤) and ss = return v and le = V ‚Ä≤(‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S ‚Ä≤,‚óª).
Lemma D.21 (Invert ALet). If (H ,LE [let _ = lv in le]) R (S,V , ss), then either ss = (e; ss‚Ä≤) and
le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª), where v def= ‚ü¶e‚üß(p,V ) or S = S
‚Ä≤; (¬ñ,V ‚Ä≤,‚óª; ss‚Ä≤) and
ss = return v and le = V ‚Ä≤(‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S ‚Ä≤,‚óª).
46 Protzenko et al.
Lemma D.22 (Invert Newbuf). If (H ;h,LE [let x = newbuf n (lv ‚à∂ t) in le]) R (S,V , ss),
then ss = (t x[n];memset x n v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª) and
S = S ‚Ä≤; (M,V ‚Ä≤,E).
Lemma D.23 (Invert Newstruct). If (H ;h,LE [let x = newstruct (lv ‚à∂ t) in le]) R (S,V , ss),
then ss = (t x[1];memset x 1 v; ss‚Ä≤) and le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª) and
S = S ‚Ä≤; (M,V ‚Ä≤,E).
Lemma D.24 (Invert Readbuf). If
(H ;h,LE [let x ‚à∂ t = readbuf (b,n, []) n‚Ä≤ in le]) R (S,V , ss), then ss = (t x = (b,n, [])[n‚Ä≤]; ss‚Ä≤) and
le = V (‚Üë ss‚Ä≤) and LE = unravel(S,‚óª).
Lemma D.25 (Invert Readstruct). If
(H ;h,LE [let x ‚à∂ t = readstruct (b,n,
√ê‚áÄ
f d) in le]) R (S,V , ss), then ss = (t x = ‚àó[(b,n,
√ê‚áÄ
f d)]; ss‚Ä≤) and
le = V (‚Üë ss‚Ä≤) and LE = unravel(S,‚óª).
Lemma D.26 (Invert Writebuf). If
(H ;h,LE [let _ = writebuf (b,n, []) n‚Ä≤ lv in le]) R (S,V , ss), then ss = ((b,n, [])[n‚Ä≤] = v; ss‚Ä≤) and
le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª).
Lemma D.27 (Invert Writestruct). If
(H ;h,LE [let _ = writestruct (b,n,
√ê‚áÄ
f d) lv in le]) R (S,V , ss), then ss = (‚àó[(b,n,
√ê‚áÄ
f d)] = v; ss‚Ä≤) and
le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª).
Lemma D.28 (Invert App). If (H ,LE [letx ‚à∂ t = f lv in le]) R (S,V , ss), then ss = (t x = f (v); ss‚Ä≤)
and le = V (‚Üë ss‚Ä≤) and lv =¬© v and LE = unravel(S,‚óª).
Lemma D.29 (Invert Withframe). If (H ,LE [withframe le]) R (S,V , ss), then ss = {ss1}; ss2
and le = V (‚Üë ss1) and LE = unravel(S,V (‚Üü (‚óª; ss2))).
Lemma D.30 (Invert If). If (H ,LE [if n then le1 else le2]) R (S,V , ss), then ss = if e then ss1 else ss2; ss‚Ä≤
and ‚ü¶e‚üß(p,V ) = n and lei = V (‚Üë ssi) (i = 1, 2) and LE = unravel(S,V (‚Üü (‚óª; ss
‚Ä≤))).
Lemma D.31 (Invert Pop). If (H ;h,LE [pop lv]) R (S,V , ss), then either ss = e and ‚ü¶e‚üß(p,V ) = v
and ¬© v = lv and S = S ‚Ä≤; (M,V ‚Ä≤,‚óª; ss‚Ä≤) and LE = unravel(S ‚Ä≤,V ‚Ä≤(‚Üü ‚óª; ss‚Ä≤)), or ss = return e and
‚ü¶e‚üß(p,V ) = v and ¬© v = lv and S = S
‚Ä≤; (M,V ‚Ä≤,E) and LE = unravel(S ‚Ä≤,V ‚Ä≤(‚Üü E)).
Lemma D.32 (Low2C-C2Low). If ‚Üì le = ss;e , then ‚Üë (ss; return e) = le .
E FROM C‚àó TO COMPCERT C AND BEYOND
To further back our claim that KreMLin oers a practical yet trustworthy way to preserve security
properties of F‚àó programs down to the executable code, we have to demonstrate that security
guarantees can be propagated from C‚àó down to assembly.
Our idea here is to use the CompCert veried C compiler (Leroy 2016, 2009). CompCert formally
proves the preservation of functional correctness guarantees from C down to assembly code (for
x86, PowerPC and ARM platforms.)
E.1 Reminder: CompCert Clight
CompCert Clight (Blazy and Leroy 2009) is a subset of C with no side eects in expressions, and
actual byte-level representation of values. Syntax in Figure 19. Semantics denitions in Figure 20.
Evaluation of expressions in Figure 21. Small-step semantics in Figure 22.
Verified Low-Level Programming Embedded in F‚àó 47
The semantics of a Clight program is given by the return value of its main function called with
no arguments.7 Thus, given a Clight program p, the initial conguration of a CompCert Clight
transition from p is ({}, [], [], [], int r = main()), and a conguration is nal with return value i if,
and only if, it is of the form ({}, _, _V , _, []) with _V (r) = i .
p ‚à∂‚à∂= program
√ê‚áÄ
d series of declarations
d ‚à∂‚à∂= declaration
fun f (x ‚à∂ t) ‚à∂ t {
√ê‚áÄ
ad, ss } top-level function
with stack-allocated local variables
√ê‚áÄ
ad
ad top-level value
ad ‚à∂‚à∂= array declaration
t x[n] uninitialized global variable
ss ‚à∂‚à∂= statement lists
√ê‚áÄs
s ‚à∂‚à∂= statements
_x = e assign rvalue to a non-stack-allocated local variable
_x = f (e) application
_x =t [e] memory read from lvalue
e =t e memory write rvalue to lvalue
annot(read, t ,e) annotation to produce read event
annot(write, t ,e) annotation to produce write event
if e then ss else ss conditional
{ss} block
return e return
e ‚à∂‚à∂= expressions
n integer constant (rvalue)
x stack-allocated variable (lvalue)
_x non-stack-allocated variable (rvalue)
e1 +t e2 pointer add (rvalue, e1 is a rvalue pointer to a value of type t
and e2 is a rvalue int)
e .t f d struct eld projection (lvalue, e lvalue)
&e address of a lvalue (rvalue, e lvalue)
*e pointer dereference (lvalue, e rvalue)
Fig. 19. Clight Syntax
Just like C, there are two ways to evaluate Clight expressions: in lvalue position or in rvalue
position. Roughly speaking, in an expression assignment el =t er , expression el is said to be at
lvalue position and thus must evaluate into a memory location, whereas er is said to be at rvalue
position and evaluates into a value (integer or pointer to memory location). The operation &e takes
an lvalue e and transforms it into a rvalue, namely the pointer to the memory location e designates
as an lvalue. Conversely, *e takes an rvalue e , which must evaluate to a pointer, and turns it into
the corresponding memory location as an lvalue.
7CompCert does not support semantics preservation with system arguments.
48 Protzenko et al.
Memory accesses in the trace. To account for memory accesses in the trace, we make each
statement perform at most one memory access in our generated Clight code. Then, we prepend
each such memory access statement with a built-in call, a no-op annotation annot(ev, t ,e) whose
semantics is merely to produce the corresponding memory access event ev(b,n) in the trace, where
e evaluates to the pointer to oset n within block e .
v ‚à∂‚à∂= values
n integer constant
(b,n) memory location
unkn dened but unknown value
v f ‚à∂‚à∂= value fragments
n byte constant
((b,n),n‚Ä≤) n‚Ä≤-th byte of pointer value (b,n)
unkn dened but unknown value fragment
V ‚à∂‚à∂= stack-allocated variable assignments
x ‚áÄ b map from variable to memory block identier
_V ‚à∂‚à∂= non-stack-allocated variable assignments
_x ‚áÄ v map from variable to value
E ‚à∂‚à∂= evaluation ctx (plug expr to get stmts)
‚óª; ss discard returned value
_x = ‚óª; ss receive returned value
F ‚à∂‚à∂= frames
(V , _V ,E) stack frame
S ‚à∂‚à∂= stack
√ê‚áÄ
F list of frames
M ‚à∂‚à∂= memory
(b,n)‚áÄ v f map from block id and oset to value fragment
C ‚à∂‚à∂= conguration
(S,V , _V ,M, ss)
Fig. 20. Clight Semantics Definitions
lv(e, (p, V , _V )) = (b, n) and rv(e, (p, V , _V )) = v
V (x) = b
lv(x, (p, V , _V )) = (b, 0)
Var x /‚àà V p(x) = b
lv(x, (p, V , _V )) = (b, 0)
GVar
lv(e, (p, V , _V )) = (b, n)
lv(e .t f d, (p, V , _V )) = (b, n + osetof(t, f d))
PtrFd rv(e, (p, V , _V )) = (b, n)
lv(*e, (p, V , _V )) = (b, n)
PtrDeref
_V (_x) = v
rv(_x, (p, V , _V )) = v
RVar
rv(e1, (p, V , _V )) = (b, n) rv(e2, (p, V , _V )) = n
‚Ä≤
rv(e1 + e2, (p, V )) = (b, n + n
‚Ä≤
)
PtrAdd
lv(e, (p, V , _V )) = (b, n)
rv(&e, (p, V , _V )) = (b, n)
AddrOf
Fig. 21. Clight Expression Evaluation
Verified Low-Level Programming Embedded in F‚àó 49
p ‚ä¢ C ‚Üùo C ‚Ä≤
lv(e, (p, V , _V )) = (b, n) Get(M, (b, n), sizeof(t)) = v
p ‚ä¢ (S, V , _V , M, _x =t [e] ; ss)‚Üù (S, V , _V [_x ‚Ü¶ v], M, ss)
Read
lv(e1, (p, V , _V )) = (b, n) rv(e2, (p, V , _V )) = v Set(M, (b, n), sizeof(t), v) = S
‚Ä≤
p ‚ä¢ (S, V , _V , M, e1 =t e2; ss)‚Üù (S
‚Ä≤
, V , _V , M, ss)
Write
lv(e, (p, V , _V )) = (b, n)
p ‚ä¢ (S, V , _V , M, annotev, e ; ss)‚Üùev (b,n) (S, V , _V , M, SS)
Annot
rv(e, (p, V , _V )) = v
p ‚ä¢ (S ; (V ‚Ä≤, _V ‚Ä≤, E), V , M, return e ; ss)‚Üù (S, V ‚Ä≤, _V ‚Ä≤, M, E [v])
Ret
p(f ) = fun (_y ‚à∂ t1) ‚à∂ t2 { ads ; ss1 } rv(e, (p, V , _V )) = v valloc(ads, ¬ñ, M) = (V
‚Ä≤
, M ‚Ä≤)
p ‚ä¢ (S, V , _V , M, _x = f e ; ss)‚Üù (S ; (V , _V , _x = ‚óª; ss), V ‚Ä≤, {}[_y ‚Ü¶ v], M ‚Ä≤, ss1)
Call
valloc([], V , M) = (V , M)
AllocNil
Alloc(M, n √ó sizeof(t)) = (b, M1) valloc(ads, V [x ‚Ü¶ (b, 0)], M1) = (V
‚Ä≤
, M ‚Ä≤)
valloc((t x[n];ads), V , M) = (V ‚Ä≤, M ‚Ä≤)
AllocCons
rv(e, (p, V , _V )) = v
p ‚ä¢ (S, V , _V , M, e ; ss)‚Üù (S, V , _V , M, ss)
Expr
p ‚ä¢ (S, V , _V , M, [])‚Üù (S, V , _V , M, return unkn)
Empty
p ‚ä¢ (S, V , _V , M, {ss1}; ss2)‚Üù (S ;V , _V , M, ss1; ss2)
Block
rv(e, (p, V , _V )) = v v /= 0 v /= unkn
p ‚ä¢ (S, V , _V , M, if e then ss1 else ss2; ss)‚ÜùbrT (S, V , ss1; ss)
IfT
rv(e, (p, V , _V )) = 0
p ‚ä¢ (S, V , _V , M, if e then ss1 else ss2; ss)‚ÜùbrF (S, V , _V , M, ss2; ss)
IfF
Fig. 22. Clight Configuration Reduction
The CompCert memory model. The semantics of CompCert Clight statements depends on the
CompCert memory model (Leroy and Blazy 2008). Here we need three operations: Get, Set and
Alloc, whose description follows.8
Get(M, (b,n),n‚Ä≤) reads n‚Ä≤ bytes from memory M at oset n within block b, and decodes the
obtained byte fragments into a value. It fails if not all locations from (b,n) to (b,n‚Ä≤ ‚àí 1) are dened.
It returns unkn if all locations are dened but the decoding fails.
Set(M, (b,n),n‚Ä≤,v) writes n‚Ä≤ bytes from memory M at oset n within block b corresponding to
encoding value v into n‚Ä≤ value fragments. It fails if not all locations from (b,n) to (b,n‚Ä≤ ‚àí 1) are
dened.
Alloc(M,n) returns a pair (b,M ‚Ä≤) where b /‚ààM is a fresh block identier and all locations from
(b, 0) to (b,n ‚àí 1) in M ‚Ä≤ contain unkn.
8In the current version of CompCert and its memory model (Leroy et al. 2012), each memory location is equipped with a
permission to more faithfully model the fact that the memory locations of a local variable cannot be read or coincidentally
reused in a Clight program after exiting the scope of the variable. To this end, thanks to this permission model, the CompCert
memory model also denes a free operation which invalidates memory accesses while preventing from reusing the memory
block for further allocations; although we do not describe it here, CompCert Clight actually uses this operator to free all
local variables upon function exit. Thus, it is also necessary to amend the semantics of C‚àó in a similar way.
50 Protzenko et al.
E.2 Issues
Local structures. The main dierence between C‚àó and Clight is that C‚àó allows structures as
values. Although converting a C‚àó value into a Clight value is no problem in terms of memory
representation (since the layout of Clight structures9 is already formalized in CompCert with basic
proofs such as the fact that two distinct elds of a structure designate disjoint sets of memory
locations), local structures cause issues in terms of managing memory accesses (due to our desire
for noninterference in terms of memory accesses), as we describe in Section E.6.
Stack-allocated local variables. Another dierence between C‚àó and Clight is that, whereas C‚àó
allows the user to stack-allocate local variables on the y, Clight mandates all local variables of
a function to be hoisted to the beginning of the function (in fact, the list of all stack-allocated
variables of a function is actually part of the function denition), and so they are allocated all at
once when entering the function.
Hoisting local variables is not supported in the veried part of CompCert.
Consider the following C‚àó example, for a given conditional expression e:
if e then int x[1]18; else {word x[1]42;‚àó[x + 0] = 1729}
After hoisting, following the same strategy as the corresponding unveried pass of CompCert, C‚àó
code will look like this:
int x1[1];word x2[1];
if e then ‚àó [x1 + 0] = 18; else {‚àó[x2 + 0] = 42;‚àó[x2 + 0] = 1729}
This example shows the following issue: when producing the trace, the memory blocks correspond-
ing to the accessed memory location will dier between the non-hoisted and the hoisted C‚àó code.
Indeed, in the non-hoisted C‚àó code, only one variable x is allocated in the stack, whereas in the
hoisted C‚àó code, two variables x1 and x2 corresponding to both branches will be allocated anyway,
regardless of the fact that only one branch is executed. Thus, in the C‚àó code before hoisting, allocat-
ing x will create, say, block 1, whereas after hoisting, two variables will be allocated, x1 at block 1,
and x2 at block 2. Thus, the statement ‚àó[x + 0] = 1729 in the C‚àó code before hoisting will produce
read (1, 0, []) on the trace, whereas its corresponding translation after hoisting, ‚àó[x2 + 0] = 1729,
will produce read (2, 0, []).
One quick solution to ensure that those event traces are exactly preserved, is to replace the actual
pointer (b,n, fd) on read and write events with (f , i,x ,n, fd) where f is the name of the function,
i is the recursion depth of the function (which would be maintained as a global variable, increased
whenever entering the function, and decreased whenever exiting) and x is the local variable being
accessed. (In concurrent contexts, one could add a parameter Œ∏ recording the identier of the
current thread within which f is run, and so the global variable maintaining recursion depth would
become an array indexed by thread identiers.)
Finally, we adopted this solution as we describe in Section E.4, and we heavily use it to prove the
correctness of hoisting within C‚àó in Section E.5.
E.3 Summary: from C‚àó to Clight
Given a C‚àó program p and an entrypoint ss , we are going to transform it into a CompCert Clight
program in such a way that both functional correctness and noninterference are preserved.
This will not necessarily mean that traces are exactly preserved between C‚àó and Clight, due
to the memory representation discrepancy described before. Instead, by functional correctness,
we mean that a safe C‚àó program is turned into a safe Clight program, and for such safe programs,
9which can be chosen when conguring CompCert with a suitable platform
Verified Low-Level Programming Embedded in F‚àó 51
termination, I/O events and return value are preserved; and by noninterference, we mean that if
two executions with dierent secrets produce identical (whole) traces in C‚àó, then they will also
produce identical traces in CompCert Clight (although the trace may have changed between C‚àó
and Clight.)
(1) In section E.4.1, we transform a C‚àó programs into a program with unambiguous variable
names, and we take advantage of such a syntactic property by enriching the conguration
of C‚àó with more information regarding variable names, thus yielding the C‚àó 2 language.
(2) In section E.4.2, we execute the obtained C‚àó 2 program with a dierent, more abstract, trace
model, as proposed above. This is not a program transformation, but only a reinterpretation
of the same C‚àó program with a dierent operational semantics, which we call C‚àó 3.
(3) In section E.5, we transform the C‚àó 3 program into a C‚àó 3 program where all local arrays
are hoisted from block-scope to function-scope. The abstract trace model critically helps in
the success of this proof where memory state representations need to change.
(4) In section E.6.1, we transform the obtained C‚àó 3 program into a C‚àó 3 program where
functions returning structures are replaced with functions taking a pointer to the return
location as additional argument. Thus, we need to account for an additional memory
access, which we do through the C‚àó 4 intermediate semantics, another reinterpretation of
the source C‚àó 3 program producing new events at functions returning structures. Then,
our reinterpreted C‚àó 4 program is translated back to C‚àó 3 with those additional memory
accesses made explicit.
(5) In section E.6.2, we reinterpret our obtained C‚àó 3 program with a dierent event model
where memory access events of structure type are replaced by the sequences of memory
access events of all their non-structure elds. We call this new language C‚àó 5.
(6) In section E.6.3, we transform our C‚àó 5 program back into C‚àó 3 by erasing all local structures
that are not local arrays, replacing them with their individual non-structure elds. Thus,
the more ‚Äúelementary‚Äù memory accesses introduced in the C‚àó 3 to C‚àó 5 reinterpretation
are made concrete.
(7) We then reinterpret the obtained C‚àó 3 program back into C‚àó 2 as described in E.4.2, reverting
to the traces with concrete memory locations at events, thus accounting for all memory
accesses.
(8) Finally, in section E.7, we compile the obtained C‚àó 2 program, now in the desired form,
into CompCert Clight.
E.4 Normalized event traces in C‚àó
As described above, traces where memory locations explicitly appear are notoriously hard to reason
about in terms of semantics preservation for veried compilation. Thus, it becomes desirable to
nd a common representation of traces that can be preserved between dierent memory layouts
across dierent intermediate languages.
In particular here, we would like to replace concrete pointers into abstract pointers representing
the local variable being modied in a given nested function call.
E.4.1 Disambiguation of variable names. To this end, we rst need to disambiguate the names
of the local variables of a C‚àó function:
Denition E.1 (Unambiguous local variables). We say that a list of C‚àó instructions has unambiguous
local variables if, and only if, it contains no two distinct array declarations with the same variable
name, and does not contain both an array declaration and a non-array declaration with the same
variable name.
52 Protzenko et al.
‚ü¶e‚üß(p,V ) = v S = S
‚Ä≤; (M,V ,E, f ‚Ä≤,A‚Ä≤) b /‚àà S
p ‚ä¢ (S,V , t x[n] = e; ss, f ,A)‚Üù (S‚Ä≤; (M[b ‚Ü¶ vn],V ,E, f ‚Ä≤,A‚Ä≤),V [x ‚Ü¶ (b, 0, [])], ss, f ,A ‚à™ {x})
ArrDecl2
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S ; (¬ñ,V ‚Ä≤,E, f ‚Ä≤,A‚Ä≤),V , return e; ss, f ,A)‚Üù (S,V ‚Ä≤,E [v], f ‚Ä≤,A‚Ä≤)
Ret2
p(f ) = fun (y ‚à∂ t1) ‚à∂ t2 { ss1 } ‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S,V , t x = f e; ss, f ‚Ä≤,A‚Ä≤)‚Üù (S ; (¬ñ,V , t x = ‚óª; ss, f ‚Ä≤,A‚Ä≤),{}[y ‚Ü¶ v], ss1, f ,{})
Call2
Fig. 23. C‚àó 2 Amended Configuration Reduction
We say that a C‚àó program has unambiguous local variables if, and only if, for each of its functions,
its body has unambiguous local variables.
We say that a C‚àó transition system sys(p,V , ss) has unambiguous local variables if, and only if,
p has unambiguous local variables, ss has unambiguous local variables, and V does not dene any
variable with the same name as an array declared in ss .
Lemma E.2 ( Disambiguation). There exists a transformation T on lists of instructions (extended
to programs by morphism) such that, for any C‚àó program p, and for any list of C‚àó instructions ss , for
any variable mappingV ‚Ä≤ such that sys(T (p),V ‚Ä≤,T (ss)) has unambiguous local variables, there exists
a variable mappingV such that sys(p,V , ss) and sys(T (p),V ‚Ä≤,T (ss)) have the same execution traces.
Proof. Œ±-renaming. 
The noninterference property can be proven to be stable by such Œ±-renaming:
Lemma E.3. Let p be a C‚àó program and ss be a list of instructions. Assume that for any V1,V2 such
that sys(p,V1, ss) and sys(p,V2, ss) are both safe, then they have the same execution traces.
Then, for any V ‚Ä≤1 ,V
‚Ä≤
2 such that sys(T (p),V
‚Ä≤
1 ,T (ss)) and sys(T (p),V
‚Ä≤
2 ,T (ss)) are both safe, they
have the same execution traces.
Proof. By Lemma E.2, there is some V1 such that sys(p,V1, ss) and sys(T (p),V ‚Ä≤1 ,T (ss)) have
the same execution traces, thus in particular, sys(p,V1, ss) is safe. Same for someV2. By hypothesis,
sys(p,V1, ss) and sys(p,V2, ss) have the same execution traces, thus the result follows by transitivity
of equality. 
Thus, we can now restrict our study to C‚àó programs whose functions have no two distinct array
declarations with the same variable names.
Let us rst enrich the conguration (S,V , ss) of C‚àó small-step semantics with additional infor-
mation recording the current function f being executed (or maybe ¬ñ) and the set A of the variable
names of local arrays currently declared in the scope. Thus, a C‚àó stack frame (¬ñ,V ,E) becomes
(¬ñ,V ,E, f ,A) where f is the caller, a block frame (M,V ,E) becomes (M,V ,E, f ,A) where f is the
enclosing function of the block, and the conguration (S,V , ss) becomes (S,V , ss, f ,A) where f is
the current function (with the frames of S changed accordingly.) Let us then change some rules
accordingly as described in Fig. 23, leaving other rules unchanged except with the corresponding f
and A components preserved.
Let us call C‚àó 2 the obtained language where the initial state of the transition system sys(p,V , ss)
shall now be ([],V , ss,¬ñ, []).
Then, it is easy to prove the following:
Verified Low-Level Programming Embedded in F‚àó 53
Lemma E.4 (C‚àó to C‚àó 2). If sys(p,V , ss) has unambiguous local variables and is safe in C‚àó, then it
has the same execution traces in C‚àó as in C‚àó 2 (and in particular, it is also safe in C‚àó 2.)
Thus, both functional correctness and noninterference are preserved from C‚àó to C‚àó 2.
Proof. Lock-step bisimulation where the common parts of the congurations (besides the C‚àó
2-specic f ,A parts) are equal between C‚àó and C‚àó 2. 
Then, we can prove an invariant over the small-step execution of a C‚àó 2 program:
Lemma E.5 (C‚àó 2 invariant). Let p be a C‚àó 2 program and V a variable environment such that
sys(p,V , ss) has unambiguous local variables.
Let n ‚àà N. Then, for any C‚àó 2 conguration (S,V ‚Ä≤, ss‚Ä≤, f ,A) obtained after n C‚àó 2 steps from
({},V , ss,¬ñ,{}), the following invariants hold:
(1) for any variable or array declaration x in ss‚Ä≤, it does not appear in A1
(2) any variable name in A or in an array declaration of ss‚Ä≤ is in an array declaration of ss (if
f = ¬ñ) or the body of f (otherwise.)
(3) for each frame of S of the form (_, _,E, f ‚Ä≤‚Ä≤,A‚Ä≤‚Ä≤), then any variable name or array declaration
in E does not appear in A‚Ä≤‚Ä≤, and any variable name in A‚Ä≤‚Ä≤ or in an array declaration of E is in
an array declaration in ss (if f ‚Ä≤‚Ä≤ = ¬ñ) or the body of f ‚Ä≤‚Ä≤ (otherwise.)
(4) if S = S ‚Ä≤; (M, _, _, f ‚Ä≤,A‚Ä≤) with M /= ¬ñ, then f ‚Ä≤ = f , A‚Ä≤ ‚äÜ A and for all block identiers b
dened inM , there exists a unique variable x ‚àà A such that V ‚Ä≤(x) = b
(5) for any two consecutive frames (M, _, _, f1,A1) just below (_,V2, _, f2,A2) withM /= ¬ñ, then
f1 = f2 and A1 ‚äÜ A2 and V1(x) = V2(x) for all variables x ‚àà A1, and for all block identiers b
dened inM , there exists a unique variable x ‚àà A2 such that V2(x) = b
(6) for any two dierent frames of S of the form (M1, _, _, _, _) and (M2, _, _, _, _) withM1 /= ¬ñ
andM2 /= ¬ñ, the sets of block identiers ofM1 andM2 are disjoint
Proof. By induction on n and case analysis on ‚Üù. 
Then, we can prove a strong invariant between two executions of the same C‚àó 2 program with
dierent secrets. This strong invariant will serve as a preparation towards changing the event
traces of C‚àó 2.
Lemma E.6 ( C‚àó 2 noninterference invariant). Let p be a C‚àó 2 program, and V1,V2 be two
variable environments such that sys(p,V1, ss) and sys(p,V2, ss) have unambiguous local variables,
are both safe and produce the same traces in C‚àó 2.
Let n ‚àà N. Then, for any two C‚àó 2 congurations (S1,V ‚Ä≤1 , ss1, f1,A1) and (S2,V
‚Ä≤
2 , ss2, f2,A2) obtained
after n C‚àó 2 execution steps, the following invariants hold:
‚óè ss1 = ss2
‚óè S1,S2 have the same length
‚óè f1 = f2
‚óè A1 = A2
‚óè V1(x) = V2(x) for each x ‚àà A1
‚óè for each i , if the i-th frames of S1,S2 are (M1,V ‚Ä≤‚Ä≤1 ,E1, f
‚Ä≤‚Ä≤
1 ,A
‚Ä≤‚Ä≤
1 ) and (M2,V
‚Ä≤‚Ä≤
2 ,E2, f
‚Ä≤‚Ä≤
2 ,A
‚Ä≤‚Ä≤
2 ), then
E1 = E2, f ‚Ä≤‚Ä≤1 = f
‚Ä≤‚Ä≤
2 and A
‚Ä≤‚Ä≤
1 = A
‚Ä≤‚Ä≤
2 and V
‚Ä≤‚Ä≤
1 (x) = V
‚Ä≤‚Ä≤
2 (x) for any x ‚àà A
‚Ä≤‚Ä≤
1 . Moreover,M1 = ¬ñ if and
only ifM2 = ¬ñ, and ifM1 /= ¬ñ, thenM1 andM2 have the same block domain.
Thus, the n + 1-th step in both executions applies the same C‚àó 2 rule.
Proof. By induction on n and case analysis on ‚Üù, also using the invariant of Lemma E.5. In
particular the equality of codes is a consequence of the fact that there are no function pointers
54 Protzenko et al.
Algorithm: VarOfBlock
Inputs:
‚óè C‚àó 2 conguration (S,V , _, _,A) such that the invariants of Lemma E.5 hold
‚óè Memory block b dened in S
Output: function, recursion depth and local variable corresponding to the memory block
Let S = S1; (M, _, _, f , _);S2 such that b dened in M . (Such a decomposition exists and is unique
because of Invariant 6. f may be ¬ñ.)
Let n be the number of frames in S1 of the form (¬ñ, _, _, f ‚Ä≤, _) with f ‚Ä≤ = f .
Let V ‚Ä≤ and A‚Ä≤ such that S2 = (_,V ‚Ä≤, _, _,A); _, or V ‚Ä≤ = V and A‚Ä≤ = A if S2 = {}.
Let x such that V ‚Ä≤(x) = (b, 0) (exists and is unique because of Invariants 4 and 5.)
Result: (f ,n,x)
Fig. 24. C‚àó 2: retrieving the local variable corresponding to a memory block
C = (S,V , t x = ‚àó[e]; ss, f ,A)
‚ü¶e‚üß(p,V ) = (b,n,
√ê‚áÄ
f d) Get(S, (b,n,
√ê‚áÄ
f d)) = v ` = VarOfBlock(C,b)
p ‚ä¢ C ‚Üù
read (`,n,
√ê‚áÄ
f d)
(S,V [x ‚Ü¶ v], ss, f ,A)
Read3
C = (S,V ,‚àóe1 = e2; ss, f ,A) ‚ü¶e1‚üß(p,V ) = (b,n,
√ê‚áÄ
f d) ‚ü¶e2‚üß(p,V ) = v
Set(S, (b,n,
√ê‚áÄ
f d),v) = S‚Ä≤ ` = VarOfBlock(C,b)
p ‚ä¢ C ‚Üù
write (`,n,
√ê‚áÄ
f d)
(S‚Ä≤,V , ss, f ,A)
Write3
Fig. 25. C‚àó 3 Amended Configuration Reduction
in C‚àó.10 Then, both executions apply the same C‚àó 2 rules since C‚àó 2 small-step rules are actually
syntax-directed. 
E.4.2 Normalized traces. Now, consider an execution of C‚àó 2 from some initial state. In fact, for
any block identier b dened in S , it is easy to prove that it actually corresponds to some variable
dened in the scope. The corresponding VarOfBlock algorithm is shown in Figure 24.
Then, let C‚àó 3 be the C‚àó 2 language where the Read and Write rules are changed according to
Figure 25, with event traces where the actual pointer is replaced into an abstract pointer obtained
using the VarOfBlock algorithm above.
Lemma E.7 (C‚àó 2 to C‚àó 3 functional correctness). If sys(p,V , ss) has no unambiguous vari-
ables, then sys(p,V , ss), has the same behaviors in C‚àó 2 with event traces with read,write removed, as
in C‚àó 3 with event traces with read,write removed.
Proof. Lock-step bisimulation with equal congurations. Steps Read and Write need the
invariant of Lemma E.5 on C‚àó 2 to prove that C‚àó 3 does not get stuck (ability to apply VarOfBlock.)

10If we were to allow function pointers in C‚àó, then we would have to add function call/return events into the C‚àó trace
beforehand, and assume that traces with those events are equal before renaming = prove that they are equal on the Low‚àó
program as well. This might have consequences in the proof of function inlining in the F‚àó-to-C‚àó translation.
Verified Low-Level Programming Embedded in F‚àó 55
Lemma E.8 (VarOfBlock inversion). Let C1,C2 two C‚àó 2 congurations such that invariants of
Lemma E.5 and Lemma E.6 hold. Then, for any block identiers b1,b2 such that VarOfBlock(C1,b1)
and VarOfBlock(C2,b2) are both dened and equal, then b1 = b2.
Proof. Assume VarOfBlock(C1,b1) = VarOfBlock(C2,b2) = (f ,n,x). When applying VarOfBlock,
consider the frames F1, F2 holding the memory states dening b1,b2. Consider the variable mapping
V ‚Ä≤2 in the frame just above F2 (or in C2 if such frame is missing.) Then, it is such that V ‚Ä≤2 (x) = b2.
‚óè If F1 and F2 are at the same level in their respective stacks, then the variable mappingV ‚Ä≤1 in
the frame directly above F1 (or in C1 if such frame is missing) is such that V ‚Ä≤1 (x) = b1, and
also V ‚Ä≤1 (x) = V ‚Ä≤2 (x) by the invariant, so b1 = b2.
‚óè Otherwise, without loss of generality (by symmetry), assume that F2 is strictly above F1
(i.e. F2 is strictly closer to the top of its own stack than F1 is in its own stack.) Thus, in the
stack of C1, all frames in between F1 and the frame F ‚Ä≤‚Ä≤1 corresponding to F2 are of the form
(M ‚Ä≤,V ‚Ä≤, _, f ‚Ä≤, _) with f ‚Ä≤ = f and M ‚Ä≤ /= ¬ñ (otherwise the functions and/or recursion depths
would be dierent.) By invariant 5 of Lemma E.5, it is easy to prove that V ‚Ä≤(x) = b1, and
thus also for the variable mapping V ‚Ä≤1 in the frame just above F ‚Ä≤‚Ä≤1 (or in C1 directly if there
is no such frame.) By invariants of Lemma E.6, we have V ‚Ä≤1 (x) = V ‚Ä≤2 (x), thus b1 = b2.

Lemma E.9 (C‚àó 2 to C‚àó 3 noninterference). Assume that sys(p,V1, ss) and sys(p,V2, ss) have
no unambiguous variables. Then, they are both safe in C‚àó 2 and produce the same traces in C‚àó 2, if
and only if they are both safe in C‚àó 3 and produce the same traces in C‚àó 3.
Proof. Use the invariants of Lemma E.5 and Lemma E.6. In fact, the congurations and steps
are the same in C‚àó 2 as in C‚àó 3, only the traces dier between C‚àó 2 and C‚àó 3. Read and Write
steps match between C‚àó 2 and C‚àó 3 thanks to Lemma E.8. 
Lemma E.10 (C‚àó 3 invariants). The invariants of Lemma E.5 and Lemma E.6 also hold in C‚àó 3.
E.5 Local variable hoisting
On C‚àó 3, hoisting can be performed, which will modify the structure of the memory (namely the
number of memory blocks allocated), which is ne thanks to the fact that event traces carry abstract
pointer representations instead of concrete pointer values.
Memory allocator and dangling pointers. However, we have to cope with dangling pointers whose
address should not be reused. Consider the following C‚àó code:
int x[1]18;
int ‚àó p[1]x ;
{
int y[1]42;
‚àó[p] = y;
}
{
int z[1]1729;
int ‚àó q = ‚àó[p];
f (q)
}
With a careless memory allocator which would reuse the space of y for z, the above program would
call f not with a dangling pointer to y, but instead with a valid pointer to z, which might not
56 Protzenko et al.
be expected by the programmer. Then, if f uses its argument to access memory, what should
the VarOfBlock algorithm compute? I claim that such a C‚àó 3 program generated from a safe F‚àó
program should never try to access memory through dangling pointers.
As far as I understood, a Low‚àóprogram obtained from a well-typed F‚àó program should be safe
with any memory allocator, including with a memory allocator which never reuses previously
allocated block identiers, as in CompCert.11 In particular, a Low‚àó program safe with such a
CompCert-style allocator will actually never try to access memory through a dangling pointer to a
local variable no longer in scope.
Then, traces with concrete pointer values are preserved from Low‚àó to C‚àó 2 with the allocator
xed in advance in all of Low‚àó, C‚àó and C‚àó 2; and functional correctness and noninterference are
also propagated down to C‚àó 3 using the same memory allocator.
There should be a way to prove the following:
Lemma E.11. If a C‚àó 3 program is safe with a CompCert-style memory allocator, then it is safe with
any memory allocator and the traces (with abstract pointer representations) are preserved by change
of memory allocator.
Proof. Lock-step simulation where the congurations have the same structure but a (functional
but not necessarily injective) renaming of block identiers from a CompCert-style allocator to any
allocator is maintained and augmented throughout the execution. In particular, we have to prove
that VarOfBlock is stable under such renaming. 
If so, then for the remainder of this paper, we can consider a CompCert-style allocator.
Hoisting.
Denition E.12 (Hoisting). For any list of statements ss with unambiguous local variables, the
hoisting operation hoist(ss) = (ads, ss‚Ä≤) is so that ads is the list of all array declarations in ss (re-
gardless of their enclosing code blocks) and ss‚Ä≤ is the list of statements ss with all array declarations
replaced with ().
Then, hoisting the local variables in the body ss of a function is dened as replacing ss with
the code block {ads; ss‚Ä≤} where hoist(ss) = (ads, ss‚Ä≤); and then, hoisting the local variables in a
program p, hoist(p), is dened as hoisting the local variables in each of its functions.
Denition E.13 (Renaming of block identiers). Let C1,C2 be two C‚àó 3 congurations. Block
identier b1 is said to correspond to block identier b2 from C1 to C2 if, and only if, either
VarOfBlock(C1,b1) is undened, or VarOfBlock(C1,b1) is dened and equal to VarOfBlock(C2,b2).
Then, value v1 corresponds to v2 from C1 to C2 if, and only if, either they are equal integers, or
they are pointers (b1,n1, f d1), (b2,n2, f d2) such that f d1 = f d2, n1 = n2 and b1 corresponds to b2
from C1 to C2, or they are structures with the same eld identiers and, for each eld f , the value
of the eld f in v1 corresponds to the value of the eld f in v2 from C to C‚Ä≤.
Theorem E.14 (Correctness of hoisting). If sys(p,V , ss) is safe in C‚àó 3 with a CompCert-style
allocator, then sys(p,V , ss) and sys(hoist(p),V ,hoist(ss)) have the same execution traces (and in
particular, the latter is also safe) in C‚àó 3 using the same CompCert-style allocator.
11Formally, a Low‚àó (or C‚àó) conguration should be augmented with a state Œ£ so that the Low‚àóNewBuf rule (or the C‚àó
ArrDecl rule), instead of picking a block identier b not in the domain of the memory, call an allocator alloc with two
parameters, the domain D of the memory and the state Œ£, and returning the fresh block b /‚àà D and a new state Œ£‚Ä≤ for future
allocations. Then, a CompCert-style allocator would, for instance, use N as the type of block identiers, as well as for the
type of Œ£, so that if alloc(D, Œ£) = (b, Œ£‚Ä≤), then it is ensured that b /‚àà D , Œ£ ‚â§ b and b < Œ£‚Ä≤. In that case, the domain of the
memory being always within Œ£, could then be easily proven as an invariant of Low‚àó (or C‚àó).
Verified Low-Level Programming Embedded in F‚àó 57
Proof. Forward downward simulation from C‚àó 3 before to C‚àó 3 after hoisting, where one step
before corresponds to one step after, except at function entry where at least two steps are required
in the compiled program (function entry, followed by entering the enclosing block that was added
at function translation, then allocating all local variables if any), and at function exit, where two
steps are required in the compiled program (exiting the added block before exiting the function.)
Then, since C‚àó 3 is deterministic, the forward downward simulation is ipped into an upward
simulation in the avor of CompCert; thus preservation of traces.
For the simulation diagram, we combine the invariants of Lemma E.5 with the following invariant
between congurationsC = (S,V , ss, f ,A) before hoisting andC‚Ä≤ = (S ‚Ä≤,V ‚Ä≤, ss‚Ä≤, f ‚Ä≤,A‚Ä≤) after hoisting:
‚óè for all variables x dened in V , V (x), if dened, corresponds to V ‚Ä≤(x) from C to C‚Ä≤
‚óè ss‚Ä≤ is obtained from ss by replacing all array declarations with ()
‚óè f ‚Ä≤ = f
‚óè A ‚äÜ A‚Ä≤
‚óè the set of variables declared in ss is included in A‚Ä≤
‚óè if a block identier b corresponds to b‚Ä≤ from C to C‚Ä≤, then the value Get(S,b,n, f ds), if
dened, corresponds to Get(S ‚Ä≤,b‚Ä≤,n, f d) from C to C‚Ä≤
Each frame of the form (¬ñ,V1,E, f1,A1) in S is replaced with two frames in S ‚Ä≤, namely (¬ñ,V ‚Ä≤1 ,E, f1,A‚Ä≤1); (M ‚Ä≤,V ‚Ä≤2 ,‚óª, f2,A‚Ä≤2)
where:
‚óè for all variables x dened in V1, V1(x) corresponds to V ‚Ä≤1 (x) from C to C‚Ä≤
‚óè all array declarations of E are present in A‚Ä≤1
‚óè E‚Ä≤ is obtained from E by replacing all array declarations with ()
‚óè f ‚Ä≤1 = f1
‚óè A1 ‚äÜ A
‚Ä≤
1
‚óè A‚Ä≤2 contains all variable names of arrays declared in f2, and is the block domain of M ‚Ä≤
‚óè V ‚Ä≤2 is dened for all variable names in A‚Ä≤2 as a block identier valid in M ‚Ä≤
‚óè all memory locations of arrays declared in f2 are valid in M ‚Ä≤
Each frame of the form (M,V1,E, f1,A1) in S with M /= ¬ñ is replaced with one frame in S ‚Ä≤, namely
({},V ‚Ä≤1 ,E
‚Ä≤, f ‚Ä≤1 ,A
‚Ä≤
1) where:
‚óè all blocks of M are dened in A‚Ä≤1
‚óè for all variables x dened in V1, V1(x), if dened, corresponds to V ‚Ä≤1 (x) from C to C‚Ä≤
‚óè all array declarations of E are present in A‚Ä≤1
‚óè E‚Ä≤ is obtained from E by replacing all array declarations with ()
‚óè f ‚Ä≤1 = f1
‚óè A1 ‚äÜ A
‚Ä≤
1
The fact that we are using a CompCert-style memory allocator is crucial here to ensure that, once
a source block identier b starts corresponding to a target one, it remains so forever, in particular
after its block has been freed (i.e. after its corresponding variable has fallen out of scope), since
in the latter case, it corresponds to any block identier and nothing has to be proven then (since
accessing memory through it will fail in the source, per the fact that the CompCert-style memory
allocator will never reuse b.) 
E.6 Local structures
C‚àó has structures as values, unlike CompCert C and Clight, which both need all structures to be
allocated in memory. With a naive C‚àó-to-C compilation phase, where C‚àó structures are compiled
as C structures and passed by value to functions, we experienced more than 60% slowdown with
CompCert compared to GCC -O1, using the Œªow‚àó benchmark in Figure 26, extracted to C as
58 Protzenko et al.
1 module StructErase
2 open FStar.Int32
3 open FStar.ST
4
5 type u = { le: Int32.t; right: Int32.t }
6
7 let rec f (r: u) (n: Int32.t): Stack unit (Œª _‚Üí true) (Œª ___‚Üí true) =
8 push_frame();
9 (
10 if lt n 1l
11 then ()
12 else
13 let r' : u = { le = sub r.right 1l ; right = add r.le 1l } in
14 f r' (sub n 1l)
15 );
16 pop_frame()
17
18 let test () =
19 let r : u = { le = 18l ; right = 42l } in
20 let z2 = mul 2l 2l in
21 let z4 = mul z2 z2 in
22 let z8 = mul z4 z4 in
23 let z16 = mul z8 z8 in
24 let z24 = mul z8 z16 in
25 let z = mul z24 2l in
26 f r z (‚àó without structure erasure, CompCert segfaults
27 if replaced with 2‚àóz ‚àó)
Fig. 26. Low‚àó benchmarking for structure erasure
Figure 27. This is because, unlike GCC, CompCert cannot detect that a structure is never taken
its address, which is mostly the case for local structures in code generated from C‚àó. This is due
to the fact that, even at the level of the semantics of C structures in CompCert, a eld access is
tantamount to reading in memory through a constant oset. In other words, CompCert has no view
of C structures other than as memory regions. To solve this issue, we replace local structures with
their individual non-compound elds, dubbed as structure erasure. Our benchmark after structure
erasure is shown in Figure 28.
In our noninterference proofs where we prove that memory accesses are the same between
two runs with dierent secrets, treating all local structures as memory accesses would become a
problem, especially whenever a eld of a local structure is read as an expression (in addition to
the performance decrease using CompCert.) This is another reason why, in this paper (although a
departure from our current KreMLin implementation), we propose an easier proof based on the
fact that C‚àó local structures should not be considered as memory regions in the generated C code.
In addition to buers (stack-allocated arrays), C‚àó uses local structures in three ways: as local
expressions, passed as an argument to a function by value, and returned by a function. Here we
claim that it is always possible to not take them as memory accesses, except for structures returned
by a function: in the latter case, it is necessary for the caller to allocate some space on its own stack
and pass a pointer to it to the callee, which will use this pointer to store its result; then, the caller
Verified Low-Level Programming Embedded in F‚àó 59
1 typedef struct {
2 int32_t le;
3 int32_t right;
4 } StructErase_u;
5
6 void StructErase_f(StructErase_u r, int32_t n) {
7 if (n < (int32_t )1) { } else {
8 StructErase_u r_ = {
9 .le = r.right ‚àí (int32_t )1,
10 .right = r.le + (int32_t )1
11 };
12 StructErase_f(r_, n ‚àí (int32_t )1);
13 }
14 }
15
16 void StructErase_test() {
17 StructErase_u r = {
18 .le = (int32_t )18,
19 .right = (int32_t )42
20 };
21 int32_t z2 = (int32_t )4;
22 int32_t z4 = z2 ‚àó z2;
23 int32_t z8 = z4 ‚àó z4;
24 int32_t z16 = z8 ‚àó z8;
25 int32_t z24 = z8 ‚àó z16;
26 int32_t z = z24 ‚àó z2;
27 StructErase_f(r, z);
28 return;
29 }
Fig. 27. Extracted C code, before structure erasure
will read the result back from this memory area. Thus, we claim that, at the level of CompCert
Clight, the only additional memory accesses due to local structures are structures returned by
value.
So we extend C‚àó 3 with the ability for functions to have several arguments, all of which shall be
passed at each call site (there shall be no partial applications.)
E.6.1 Structure return. To handle structure return, we also have to account for their memory
accesses by adding corresponding events in the trace. Instead of directly adding the memory accesses
and trying to prove both program transformation and trace transformation at the same time, we
will rst add new read and write events at function return, without those events corresponding to
actual memory accesses yet; then, in a second pass, we will actually introduce the corresponding
new stack-allocated variables.
We assume given a function FunResVar such that for any list of statements ss and any variable x ,
FunResVar(ss,x) is a local variable that does not appear in ss and is distinct from FunResVar(ss,x ‚Ä≤)
for any x ‚Ä≤ /= x .
Let p be a program p and ss be an entrypoint list of statements, so we dene FunResVar(f ,x) =
FunResVar(ss‚Äô, x) if f (_){ss‚Ä≤} is a function dened in p, and FunResVar(¬ñ,x) = FunResVar(ss,x).
60 Protzenko et al.
1 void StructErase_f(int32_t r_le, int32_t r_right, int32_t n) {
2 if (n < (int32_t )1) { } else {
3 int32_t r__le = r_right ‚àí (int32_t )1
4 int32_t r__right = r_le + (int32_t )1;
5 StructErase_f(r__le, r__right, n ‚àí (int32_t )1);
6 }
7 }
8
9 void StructErase_test() {
10 int32_t r_le = (int32_t )18;
11 int32_t r_right = (int32_t )42;
12 int32_t z2 = (int32_t )4;
13 int32_t z4 = z2 ‚àó z2;
14 int32_t z8 = z4 ‚àó z4;
15 int32_t z16 = z8 ‚àó z8;
16 int32_t z24 = z8 ‚àó z16;
17 int32_t z = z24 ‚àó z2;
18 StructErase_f(r_le, r_right, z);
19 return;
20 }
Fig. 28. Extracted C code, aer structure erasure
‚ü¶e‚üß(p,V ) = v FunResVar(f
‚Ä≤
,x) = x ‚Ä≤ Œ∏ = brT;write (x ‚Ä≤, 0, []); read (x ‚Ä≤, 0, [])
p ‚ä¢ (S ; (¬ñ,V ‚Ä≤, t x = ‚óª; ss‚Ä≤, f ‚Ä≤,A‚Ä≤),V , return e; ss, f ,A)‚ÜùŒ∏ (S,V
‚Ä≤
, t x = v ; ss‚Ä≤, f ‚Ä≤,A‚Ä≤)
Ret4Some
‚ü¶e‚üß(p,V ) = v
p ‚ä¢ (S ; (¬ñ,V ‚Ä≤,‚óª; ss‚Ä≤, f ‚Ä≤,A‚Ä≤),V , return e; ss, f ,A)‚ÜùbrF (S,V
‚Ä≤
, ss‚Ä≤, f ‚Ä≤,A‚Ä≤)
Ret4None
Fig. 29. C‚àó 4 Amended Configuration Reduction
Then, we dene C‚àó 4 as the language C‚àó 3 where the Ret2 function return rule is replaced with
two rules following Figure 29, adding the fake read and write. We do not produce any such memory
access event if the result is discarded by the caller; thus, we also need to check in the callee whether
the caller actually needs the result. To prepare for the second pass where this check will be done
by testing whether the return value pointer argument is null, we need to account for this test in
the event trace in C‚àó 4 as well.
Theorem E.15 (C‚àó 3 to C‚àó 4 functional correctness). If sys(p,V , ss) is safe in C‚àó 3 and has
unambiguous local variables, then it has the same behavior and trace as in C‚àó 4 with brT, brF, read
and write events removed.
Proof. With all such events removed, C‚àó 3 and C‚àó 4 are actually the same language. 
Lemma E.16 (C‚àó 4 invariants). The C‚àó 3 invariants of Lemma E.5 and E.6 also hold on C‚àó 4.
Proof. This is true because the invariants of Lemma E.5 actually do not depend on the traces
produced; and it is obvious to prove that, if two executions have the same traces in C‚àó 4, then they
have the same traces in C‚àó 3 (because in C‚àó 3, some events are just removed.) 
Verified Low-Level Programming Embedded in F‚àó 61
StructRet(_, return e,x) = { if x then ‚àó [x] = e else (); return () if x /= ¬ñ
return e otherwise
StructRet(f ‚Ä≤, t x = f (e), _) =
‚éß‚é™‚é™‚é™
‚é®
‚é™‚é™‚é™‚é©
t x ‚Ä≤[1]; f (x ‚Ä≤,e); t x = ‚àó[x ‚Ä≤] if t is a struct
and x ‚Ä≤ = FunRetVar(f ‚Ä≤,x)
t x = f (e) otherwise
StructRet(_, f (e), _) = { f (0,e) if the return type of f is a struct
f (e) otherwise
StructRet(fun f (x ‚à∂ t) ‚à∂ t ‚Ä≤ { ss }) =
‚éß‚é™‚é™‚é™
‚é®
‚é™‚é™‚é™‚é©
fun f (r ‚à∂ t ‚Ä≤‚àó,x ‚à∂ t) ‚à∂ unit{ {StructRet(f , ss, r)}} if t ‚Ä≤ is a struct
(r fresh)
fun f (x ‚à∂ t) ‚à∂ t ‚Ä≤ { {StructRet(f , ss,¬ñ)} } otherwise
Fig. 30. C‚àó 4 to C‚àó 3 structure return transformation
Theorem E.17 (C‚àó 3 to C‚àó 4 noninterference). If sys(p,V1, ss) and sys(p,V2, ss) are safe in C‚àó
3, have unambiguous local variables, and produce the same traces in C‚àó 3, then they also produce the
same traces in C‚àó 4.
Proof. Two such executions actually make the same C‚àó 4 steps. 
Then, we dene the StructRet structure return transformation from C‚àó 4 to C‚àó 3 in Figure 30,
thus removing all structure returns from C‚àó 3 programs.
Then, the transformation back to C‚àó 3 exactly preserves the traces of C‚àó 4 programs, so that we
obtain both functional correctness and noninterference at once:
Theorem E.18 (StructRet correctness). If sys(p,V , ss) is safe in C‚àó 4 and has unambiguous
local variables, then it has the same behavior and trace as sys(StructRet(p),V , StructRet(ss,¬ñ)).
Proof. Forward downward simulation, where the compilation invariant also involves block
identier renaming from Denition E.13 due to the new local arrays introduced by the transformed
program.
Each C‚àó 4 step is actually matched by the same C‚àó 3 step, except for function return and return
from block: for the RetBlock rule, the simulation diagram has to stutter as many times as the level
of block nesting in the source program before the actual application of a Ret4 rule. Then, when the
RetSome4 rule applies, the trace events are produced by the transformed program, the brT and the
write events from within the callee, then the callee blocks are exited, and nally the read event is
produced from within the caller.
Then, the diagram is turned into bisimulation since C‚àó 3 is deterministic. 
After a further hoisting pass, we can now restrict our study to those C‚àó 3 programs with
unambiguous local variables, functions with multiple arguments, function-scoped local arrays, and
no functions returning structures.
E.6.2 Events for accessing structure buers. Now, we transform an access to one structure into
the sequence of accesses to all of its individual atomic (non-structure) elds.
Consider the following transformation for C‚àó 3 read (and similarly for write) events:
62 Protzenko et al.
Jread (f , i,x , j,√ê‚áÄf d, t)K
= Jread (f , i,x , j,√ê‚áÄf d ; f d1, t1)K
; . . .
; Jread (f , i,x , j,√ê‚áÄf d ; f dn , tn)K
if t = struct{f d1 ‚à∂ t1, . . . , f dn ‚à∂ tn}
Jread (f , i,x , j,√ê‚áÄf d, t)K
= read (f , i,x , j,
√ê‚áÄ
f d, t)
otherwise
Then, let C‚àó 5 be the C‚àó 3 language obtained by replacing each read, write event with its
translation. Then, it is easy to show the following:
Lemma E.19 (C‚àó 3 to C‚àó 5 correctness). Let p be a C‚àó 3 program. Then, p has a trace t in C‚àó 5
if, and only if, there exists a trace t ‚Ä≤ such that p has trace t ‚Ä≤ in C‚àó 3 and Jt ‚Ä≤K = t .
Thus, this trace transformation preserves functional correctness; and, although this trace trans-
formation is not necessarily injective (since it is not possible to disambiguate between an access to
a 1-eld structure and an access to its unique eld), noninterference is also preserved.
After such transformation, all read and write events now are restricted to atomic (non-structure)
types.
E.6.3 Local structures. Now, we are removing all local structures, in such a way that the only
remaining structures are those of local arrays, and all structures are accessed only through their
atomic elds. In particular, we are replacing every local (non-array) variable x of type struct with
the sequence of variable names x_
√ê‚áÄ
f ds for all eld name sequences
√ê‚áÄ
f ds valid from x such that x .
√ê‚áÄ
f ds
is of non-struct type. (We omit the details as to how to construct names of the form x_
√ê‚áÄ
f ds so that
they do not clash with other variables; at worst, we could also rename other variables to avoid
clashes as needed.)
Using our benchmark in Figure 26, with C code after structure erasure in Figure 28, on a 4-core
Intel Core i7 1.7 GHz laptop with 8 Gb RAM, structure erasure saves 20% time with CompCert 2.7.
If we assume that we know about the type of a C‚àó expression, then it can be rst statically
reduced to a normal form as in Figure 31.
Lemma E.20 ( C‚àó structure erasure in expressions: correctness). For any value v of type t ,
if JeK(p,V ) = v and Œì ‚ä¢ e ‚Üìt e‚Ä≤ and V ‚Ä≤ is such that:
‚óè for any (x ‚Ä≤ ‚à∂ t ‚Ä≤) ‚àà Œì, V (x ‚Ä≤) exists, is of type t ‚Ä≤ and is equal to V (x)
‚óè for any (x ‚Ä≤ ‚à∂ t ‚Ä≤) ‚àà Œì that is a struct and for any
√ê‚áÄ
f ds such that x .
√ê‚áÄ
f ds is not a struct, then
V ‚Ä≤(x_
√ê‚áÄ
f ds) = V (x)(
√ê‚áÄ
f ds)
Then, Je‚Ä≤K(p,V ‚Ä≤) = v
Proof. By structural induction on ‚Üì. 
Denition E.21 (C‚àó expression without structures). A C‚àó expression e is said to be of type t without
structures if, and only if, one of the following is true:
‚óè e contains neither a structure eld projection nor a structure expression
‚óè e is of the form x .
√ê‚áÄ
f ds where x is a variable such that x .
√ê‚áÄ
f ds is of struct type
Verified Low-Level Programming Embedded in F‚àó 63
Œì ‚ä¢ n ‚ÜìInt n
Int (x ‚à∂ t) ‚àà Œì
Œì ‚ä¢ x ‚Üìt x
Var Œì ‚ä¢ e1 ‚Üì
t‚àó e ‚Ä≤1 Œì ‚ä¢ e2 ‚Üì
int e ‚Ä≤2
Œì ‚ä¢ e1 + e2 ‚Üì
t‚àó e ‚Ä≤1 + e
‚Ä≤
2
PtrAdd
Œì ‚ä¢ e ‚Üìstruct{f d ‚à∂t ;. . . }‚àó e ‚Ä≤
Œì ‚ä¢ &e ‚Üí f d ‚Üìt‚àó &e ‚Ä≤ ‚Üí f d
PtrFd
Œì ‚ä¢ e ‚Üìstruct{f d ‚à∂t ;. . . } x .
√ê‚áÄ
f ds t is a struct
Œì ‚ä¢ e .f d ‚Üìt x .
√ê‚áÄ
f ds .f d
StructFieldName
Œì ‚ä¢ e ‚Üìstruct{f d ‚à∂t ;. . . } x .
√ê‚áÄ
f ds t is not a struct
Œì ‚ä¢ e .f d ‚Üìt x_
√ê‚áÄ
f ds_f d
ScalarFieldName
Œì ‚ä¢ e ‚Üìstruct{f d ‚à∂t ;. . . } {f = e ‚Ä≤; . . . }
Œì ‚ä¢ e .f d ‚Üìt e ‚Ä≤
FieldProj
√ê√ê√ê√ê√ê√ê√ê‚áÄ
Œì ‚ä¢ ei ‚Üì
ti e ‚Ä≤i
Œì ‚ä¢ {
√ê√ê√ê√ê‚áÄ
f di = ei} ‚Üì
struct{
√ê√ê√ê‚áÄ
f di ‚à∂ti } {
√ê√ê√ê√ê‚áÄ
f di = e
‚Ä≤
i}
Struct
Fig. 31. C‚àó Structure Erasure: Expressions
‚óè t is of the form {
√ê√ê√ê‚áÄ
f di ‚à∂ ti} and e is of the form {
√ê√ê√ê√ê‚áÄ
f di = ei} where for each i , ei is of type ti
without structures
Lemma E.22 (C‚àó expression reduction: shape). If Œì ‚ä¢ e ‚Üìt e‚Ä≤, then e‚Ä≤ is of type t without
structures.
Proof. By structural induction on ‚Üì. 
Then, once structure expressions are reduced within an expression computing a non-structure
value, we can show that evaluating such a reduced expression no longer depends on any local
structures:
Lemma E.23. If JeK(p,V ) = v for some value v , and e is of type t without structures, and t is not a
struct type, then, for any variable mappingV ‚Ä≤ such thatV ‚Ä≤(x) = V (x) for all variables x of non-struct
types, JeK(p,V ‚Ä≤) = v .
Proof. By structural induction on JeK(p,V ). 
Now, we take advantage of this transformation to transform C‚àó 5 statements into C‚àó 3 statements
without structure assignments. This ‚Üì translation is detailed in Figure 32
In particular, each function parameter of structure type passed by value is replaced with its
recursive list of all non-structure elds.12
Theorem E.24 (C‚àó 5 to C‚àó 3 structure erasure: shape). If p ‚Üì p‚Ä≤ following Figure 32, then p‚Ä≤
no longer has any variables of local structure type, and no longer has any structure or eld projection
expressions.
Proof. By structural induction over ‚Üì, also using Lemma E.22. 
Theorem E.25 (C‚àó 5 to C‚àó 3 structure erasure: correctness). If p is a C‚àó 5 program (that is,
syntactically, a C‚àó program with unambiguous local variables, no block-scoped local arrays other than
function-scoped, and no functions returning structures) such that p is safe in C‚àó 5 and p ‚Üì p‚Ä≤ following
Figure 32, then p and p‚Ä≤ have the same execution traces.
12Our solution, although semantics-preserving as we show further down, yet causes ABI compliance issues. Indeed, in the
System V x86 ABI, structures passed by value must be replaced not with their elds, but with their sequence of bytes, some
of which may correspond to padding related to no eld of the original structure. CompCert does support this feature but as
an unveried elaboration pass over source C code. So, we should investigate whether we really need to expose functions
taking structures passed by value at the interface level.
64 Protzenko et al.
t not a struct Œì ‚ä¢ e ‚Üìt‚àó e ‚Ä≤
p, Œì ‚ä¢ t x = ‚àó[e] ‚Üì t x = ‚àó[e ‚Ä≤]
Œì[x]‚Üê t
ReadScalar
t not a struct
Œì ‚ä¢ e1 ‚Üìt‚àó e ‚Ä≤1 Œì ‚ä¢ e2 ‚Üìt e ‚Ä≤2
p, Œì ‚ä¢ ‚àó[e1] = e2 ‚Üì ‚àó[e ‚Ä≤1] = e ‚Ä≤2
WriteScalar
t = struct{√ê√ê√ê‚áÄfdi ‚à∂ ti} Œì ‚ä¢ e ‚Üìt‚àó e ‚Ä≤ (x, _) /‚àà Œì (x ‚Ä≤, _) /‚àà Œì√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
p, Œì ‚à™ (x ‚Ä≤ ‚à∂ t‚àó) ‚à™ (x_fdi ‚à∂ ti ) ‚ä¢ x_fdi = ‚àó[&x ‚Ä≤ ‚Üí fdi ] ‚Üì ssi
p, Œì ‚ä¢ t x = ‚àó[e] ‚Üì t ‚àó x ‚Ä≤ = e ‚Ä≤;√ê‚áÄssi Œì[x]‚Üê t
ReadStruct
t = struct{√ê√ê√ê‚áÄfdi ‚à∂ ti} Œì ‚ä¢ e1 ‚Üìt‚àó e ‚Ä≤1 Œì ‚ä¢ e2 ‚Üìt e ‚Ä≤2 (x ‚Ä≤, _) /‚àà Œì√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
p, Œì ‚à™ (x ‚Ä≤ ‚à∂ t‚àó) ‚ä¢ ‚àó[&x ‚Ä≤ ‚Üí fdi ] = e ‚Ä≤2 .fdi ‚Üì ssi
p, Œì ‚ä¢ ‚àó[e1] = e2 ‚Üì t ‚àó x ‚Ä≤ = e ‚Ä≤1;√ê‚áÄssi
WriteStruct
t not a struct Œì ‚ä¢ e ‚Üìt e ‚Ä≤
p, Œì ‚ä¢ return e ‚Üì return e ‚Ä≤ Ret
p, Œì ‚ä¢ ss ‚Üì ss ‚Ä≤
p, Œì ‚ä¢ {ss} ‚Üì {ss ‚Ä≤} Block
p(f ) = fun(√ê√ê‚áÄ_ ‚à∂ ti ) ‚à∂ t{_} t not a struct p, Œì ‚ä¢ (√ê‚áÄti , el) ‚Üì el‚Ä≤
p, Œì ‚ä¢ t x = f (el) ‚Üì t x = f (el‚Ä≤) Œì[x]‚Üê t Call
p, Œì ‚ä¢ ([], []) ‚Üì [] ArgNil
p, Œì ‚ä¢ (t, e) ‚Üì el1 p, Œì ‚ä¢ (tl, el) ‚Üì el2
p, Œì ‚ä¢ (t ; tl, e ; el) ‚Üì el1; el2
ArgCons
t not a struct Œì ‚ä¢ e ‚Üìt e ‚Ä≤
p, Œì ‚ä¢ (t, e) ‚Üì [e ‚Ä≤] ScalarArg
t = struct{√ê√ê√ê‚áÄfdi ‚à∂ ti} Œì ‚ä¢ e ‚Üìt e ‚Ä≤√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
p, Œì ‚ä¢ (ti , e ‚Ä≤ .fdi ) ‚Üì eli
p, Œì ‚ä¢ (t, e) ‚Üì √ê‚áÄeli
StructArg
t not a struct Œì ‚ä¢ e ‚Üìt e ‚Ä≤ √ê√ê√ê√ê√ê√ê√ê√ê‚áÄp, Œì ‚ä¢ ssi ‚Üì ss ‚Ä≤i
p, Œì ‚ä¢ if e then ss1 else ss2 ‚Üì if e ‚Ä≤ then ss ‚Ä≤1 else ss ‚Ä≤2
If
t not a struct
(x ‚à∂ t) ‚Üì (x ‚à∂ t) ScalarParam
t = struct{√ê√ê√ê‚áÄfdi ‚à∂ ti}√ê√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ(x_fdi ‚à∂ ti ) ‚Üì vti
(x ‚à∂ t) ‚Üì √ê‚áÄvti
StructParam
vt ‚Üì vt‚Ä≤ p, (vt ‚à™√ê√ê√ê√ê‚áÄxi ‚à∂ ti‚àó) ‚ä¢ ss ‚Üì ss‚Ä≤
fun(vt) ‚à∂ t{√ê√ê√ê√ê√ê√ê√ê‚áÄti xi [_] = {}; ss} ‚Üì fun(vt‚Ä≤) ‚à∂ t{
√ê√ê√ê√ê√ê√ê√ê‚áÄ
ti xi [_] = {}; ss‚Ä≤}
Fun
Fig. 32. C‚àó 5 to C‚àó 3 Structure Erasure: Statements
Proof. Forward downward simulation where one C‚àó 5 step triggers one or several C‚àó 3 steps.
Then, determinism of C‚àó 3 turns this forward downward simulation into bisimulation.
The compilation invariant is as follows: the code fragments are translated using ‚Üì, and variable
mapsV in source C‚àó 5 vs. their compiled C‚àó 3 counterpartsV ‚Ä≤ follow the conditions of Lemma E.20,
also using Lemma E.23. Memory states M are exactly preserved, as well as the structure of the
stack. 
Then, after a further Œ±-renaming pass, we obtain a C‚àó 3 program that no longer has any local
(non-stack-allocated) structures at all, and where all memory accesses are of non-structure type.
Verified Low-Level Programming Embedded in F‚àó 65
CintA (n) = n
CunitA (()) = 0
CtA(x) = &x
if x ‚àà A
CtA(x) = _x
if x /‚àà A
Ct‚àóA (e1 + e2) = C
t‚àó
A (e1) +t C
int
A (e2)
Ct‚àóA (&e ‚Üí f d) = &(‚àóC
t ‚Ä≤‚àó
A (e).t ‚Ä≤ fd)
if t ‚Ä≤ = struct{fd ‚à∂ t , . . . }
Fig. 33. C‚àó 2 to Clight: Expressions
The shape of this program is now suitable for translation to a CompCert Clight program in a
straightforward way, which we describe in the next subsection.
E.7 Generation of CompCert Clight code
Recall that going from C‚àó 3 (with abstract pointer events) back to C‚àó 2 (with concrete pointer
events) is possible thanks to the fact that Lemma E.7 and Lemma E.9 are actually equivalences.
Recall that a C‚àó n transition system is of the form sys(p,V , ss) where p is a list of functions13, ss
is a list of C‚àó statements with undeclared local variables, the values of which shall be taken from
the map V . ss is actually taken as the entrypoint of the program, and V is deemed to store the
initial values of secrets, ensuring that p and ss are syntactically secret-independent.
In CompCert Clight, it is not nominally possible to start with a set of undeclared variables and a
map to dene them. So, when translating the C‚àó entrypoint into Clight, we have to introduce a
secret-independent way of representing V and how they are read in the entrypoint. Fortunately,
CompCert introduces the notion of built-in functions, which are special constructs whose semantics
can be customized and that are guaranteed to be preserved by compilation down to the assembly.
Thus, we can populate the values of local non-stack-allocated variables of a C‚àó entrypoint by
uniformly calling builtins in Clight, and only the semantics of those builtins will depend on secrets,
so that the actually generated Clight code will be syntactically secret-independent.
Translating C‚àó 2 expressions with no structures or structure eld projections into CompCert
Clight is straightforward, as shown in Figure 33. For any C‚àó 2 expression e of type t , assuming that
A is a set of local variables to be considered as local arrays, we dene CtA(e) to be the compiled
Clight expression corresponding to e .
Lemma E.26. Let V be a C‚àó 2 local variable map, and A be a set of local variables to be considered
as local arrays. Assume that, for all x ‚àà A, there exists a block identier b such thatV (x) = (b, 0), and
dene V ‚Ä≤(x) be such block identier b. Then, dene _V ‚Ä≤(_x) = V (x) for all x /‚àà A.
Then, for any expression e with no structures or structure projections, rv(CtA(e), (p,V
‚Ä≤, _V ‚Ä≤)) =
JeK(p,V ).
Proof. By structural induction on e . 
Translating C‚àó 2 statements with no local array declarations, no read or write of structure type
and no functions returning structures into Clight is straightforward as well, as shown in Figure 34.
Let p be a C‚àó 2 program, and ss be a C‚àó 2 entrypoint sequence of statements. Assume that p and
ss have unambiguous local variables, no functions returning structures, no local arrays other than
13and global variables, although the semantics of C‚àó says nothing about how to actually initially allocate them in memory
66 Protzenko et al.
CA(t x = e) = t x = C
t
A(e)
CA(t x = f (
√ê‚áÄei )) = t x = f (
√ê√ê√ê‚áÄ
CtiA (ei))
if f is fun(
√ê√ê√ê‚áÄ
(_ ‚à∂ ti)) ‚à∂ _{_}
CA(t x = ‚àó[e]) = annot(read, t ,e); t x = [‚àóCt‚àóA (e)]
CA(‚àó[e1] = e2) = annot(write, t ,e);‚àóCt‚àóA (e1) = C
t
A(e2)
CA(if e then ss1 else ss2) = if CtA(e) then CA(ss1) else CA(ss2)
for some t not struct
CA({ss}) = {CA(ss)}
CA(return e) = return CtA(e)
Fig. 34. C‚àó 2 to Clight: Statements
C(p, ss)(f ) = fun (√ê√ê‚áÄx ‚à∂ t) ‚à∂ t ‚Ä≤{
√ê√ê√ê√ê‚áÄ
ti xi [ni ];C√ê‚áÄxi (ss
‚Ä≤)}
if p(f ) = fun (√ê√ê‚áÄx ‚à∂ t) ‚à∂ t ‚Ä≤{
√ê√ê√ê√ê‚áÄ
ti xi [ni ]; ss‚Ä≤}
C(p, ss)(main) = fun() ‚à∂ int{
√ê√ê√ê√ê‚áÄ
ti xi [ni ];
√ê√ê√ê√ê√ê√ê√ê√ê‚áÄ
_yi = get_yi();
C√ê‚áÄxi (ss
‚Ä≤)
}
if ss = {
√ê√ê√ê√ê‚áÄ
ti xi [ni ]; ss‚Ä≤}
with free variables √ê‚áÄyi
Fig. 35. C‚àó 2 to Clight: Program and Entrypoint
function-scoped arrays, and no local structures other than local arrays. Further assume that p has
no function called main, and no function with the same name as a built-in function. Then, we can
dene the compiled CompCert Clight program C(p, ss) as in Figure 35.
Theorem E.27 (C‚àó 2 to Clight: correctness). If sys(p,V , ss) is safe in C‚àó 2, then it has the
same execution trace as C(p, ss) in Clight, when the semantics of the built-in functions get_x are given
by V .
Proof. Forward downward simulation where one C‚àó 2 step corresponds to one or several Clight
steps. Then, since Clight is deterministic, the forward downward simulation diagram is turned into
a bisimulation.
The structure of the Clight stack is the same as in the C‚àó 2 stack, and the values of variables are
the same, as well as the memory block identiers. The only change is in the Clight representation
of C‚àó 2 structure values . A C‚àó 2 memory state M is said to correspond to a Clight memory state
M ‚Ä≤ if, for any block identier b, for any array index i , and for any eld sequence fds leading to a
non-structure value, M ‚Ä≤(b,n + osetof(fds)) =M(b,n)(fds). 
Thus, since both C‚àó 2 and Clight records all memory accesses in their traces, this theorem entails
both functional correctness and preservation of noninterference.
Verified Low-Level Programming Embedded in F‚àó 67
F PROOF OF THE SECRET INDEPENDENCE THEOREM
---------
Notations
---------
t ::= int | unit | { f_i : t_i } | buf t | a
v ::= x | n | () | { f_i = v_i } | (b, n) | stuck
P ::= Top level functions (same as lp)
G ::= x_i:t_i (type enviroment)
S ::= (b_i, n_i):t_i (store typing)
G_s = a_i, f_j:t_j -> t'_j (type variables and signature of functions that
manipulate secrets)
G_f = x_i:a_i (free variables of secret types)
q ::= a_i |-> t_i (instantiations of type variables)
p ::= x_i |-> v_i (substitutions of secret variables)
-----------
Judgments:
-----------
Remark: In the following judgments, we use the program P itself in the typing context,
rather than just the signatures, as we do in the main paper (G_p). This is equivalent
since the rule [T-App] below, which looks up the function signature in P, does not
rely on the function body.
P; S; G_s, G |- e : t (expression typing)
P; S; G_s |- P' (program typing)
G_s |- t (type well-formedness)
G_s |- q (well-formedness of type variables instantiations)
S; G_s, G |-_q p (well-typed substitutions)
P; S; G_s, G |- H (heap typing)
** Expression typing P; S; G_s, G |- e : t
68 Protzenko et al.
G(x) = t G_s |- t
--------------------------- [T-Var]
P; S; G_s, G |- x : t
-------------------------- [T-Int]
P; S; G_s, G |- n : int
---------------------------- [T-Unit]
P; S; G_s, G |- () : unit
-------------------------------- [T-Buf]
P; S; G_s, G |- (b, n) : S(b)
P; S; G_s, G |- e1 : buf t1
P; S; G_s, G |- e2 : int
P; S; G_s, G, x:t1 |- e : t
---------------------------------------------------- [T-Readbuf]
P; S; G_s, G |- let x:t1 = readbuf e1 e2 in e : t
P; S; G_s, G |- e1 : buf t1
P; S; G_s, G |- e2 : int
P; S; G_s, G |- e3 : t1
P; S; G_s, G |- e : t
----------------------------------------------------- [T-Writebuf]
P; S; G_s, G |- let _ = writebuf e1 e2 e3 in e : t
P; S; G_s, G |- e1 : t
P; S; G_s, G, x:buf t |- e2 : t2
----------------------------------------------------- [T-Newbuf]
P; S; G_s, G |- let x = newbuf n (e1:t) in e2 : t2
P; S; G_s, G |- e1 : buf t
P; S; G_s, G |- e2 : int
--------------------------------------- [T-Subbuf]
P; S; G_s, G |- subbuf e1 e2 : buf t
P; S; G_s, G |- e : t
---------------------------------- [T-Withframe]
P; S; G_s, G |- withframe e : t
P; S; G_s, G |- e : t
---------------------------- [T-Pop]
P; S; G_s, G |- pop e : t
Verified Low-Level Programming Embedded in F‚àó 69
P; S; G_s, G |- e : int
P; S; G_s, G |- e_i : t
------------------------------------------- [T-If]
P; S; G_s, G |- if e then e1 else e2 : t
P(d) = fun (x:t1) -> _:t \/ G_s(d) = t1 -> t
P; S; G_s, G |- e1 : t1
P; S; G_s, G, x:t |- e2 : t2
--------------------------------------------- [T-App]
P; S; G_s, G |- let x:t = d e1 in e2 : t2
P; S; G_s, G |- e1 : t
P; S; G_s, G, x:t |- e2 : t2
------------------------------------------ [T-Let]
P; S; G_s, G |- let x:t = e1 in e2 : t2
P; S; G_s, G |- e_i : t_i
------------------------------------------------ [T-Rec]
P; S; G_s, G |- { f_i : e_i } : { f_i : t_i }
P; S: G_s, G|- e : { f_i : t_i }
----------------------------------- [T-Proj]
P; S; G_s, G |- e.f_i : t_i
** Program typing P; S; G_s |- P'
----------------------- [P-Emp]
P; S; G_s |- .
G_s |- t_i
P; S; G_s, y:t1 |- e : t2
P; S; G_s |- P'
---------------------------------------------- [P-Fun]
P; S; G_s |- let d = fun(y:t1) -> e:t2, P'
-------------------------------------
Notion of equivalence-modulo-secrets
-------------------------------------
Equivalence of values:
----------------------
70 Protzenko et al.
A lax relation typing-wise.
V_int = { (n, n) }
V_unit = { ( (), () ) }
V_{ f_i : t_i } = { ({f_i = v_i}, {f_i = v_i'}) | forall i. (v_i, v_i') \in V_(t_i) }
V_(buf t) = { ( (b, n), (b, n) ) }
V_a = { (v1, v2) }
Equivalence of heaps:
---------------------
Again, a lax relation typing-wise. Further, S can contain type variables.
S |- H1 =eq= H2 iff
1. dom H1 = dom H2
2. forall (b, n) \in dom H1.
let buf t = S (b, n)
forall 0 <= i < n. (H1[(b, n)][i], H2[(b, n)][i]) \in V_t
Gen function for values:
-------------------------
Let v1 is closed, v2 is closed, and (v1, v2) \in V_t (t can have type variables)
Gen v1 v2 t = v, p1, p2, G
Gen n n int = (n, ., ., .)
Gen () () unit = ((), ., ., .)
Gen { f_i = v_i } { f_i = v'_i } { f_i : t_i } = ({f_i = v''_i}, p1, p2, G)
where forall i. Gen v_i v'_i t_i = (v''_i, p1_i, p2_i, G_i)
and p1 = compose_for_all_i p1_i
and p2 = compose_for_all_i p2_i
and G = compose_for_all_i G_i
(compose is a simple append in each case)
Gen (b, n) (b, n) (buf t) = ((b, n), ., ., .)
Gen v1 v2 a = (x, x |-> v1, x |-> v2, x:a)
Gen function for heaps:
------------------------
Verified Low-Level Programming Embedded in F‚àó 71
Let H1 is closed, H2 is closed, and S |- H1 =eq= H2
Gen H1 H2 S = (H, p1, p2, G)
s.t. dom H = dom H1 (= dom H2)
H[(b, n)][i] = v,
where Gen H1[(b, n)][i] H2[(b, n)][i] t = v, p1_b_n_i, p2_b_n_i, G_b_n_i
and p1 = compose of all p1_b_n_i and p2 = compose of all p2_b_n_i
and G = compose of all G_b_n_i
--------------------------------------------------------------------------------------
Remark: Gen does not preserve sharing, but we recover sharing after the substitition.
Further, substitution is just a proof device.
--------------------------------------------------------------------------------------
Assumption on secrets manipulating functions:
----------------------------------------------
If
(1) G_s (f) = t1 -> t2, where G_s |- t1 and G_s |- t2 (f has type t1 -> t2
in the signature,
t1 and t2 can have
type variables)
(2) S |- H1 =eq= H2 (H1 and H2 are closed heaps (see 6, 7 below)
and related under S)
(3) P; S[q]; G_s[q] |- v1 : t1[q] (v1 is a closed value of type t1[q])
(4) P; S[q]; G_s[q] |- v2 : t1[q] (so is v2)
(5) (v1, v2) \in V_t1 (v1 and v2 are related)
(6) P; S[q]; G_s[q] |- H1 (H1 is well-typed heap, and closed)
(7) P; S[q]; G_s[q] |- H2 (so is H2)
Then
(a) P, P_s |- (H1, (P_s (f)) v1) -m->tr (H1', v1') (f v1 terminates in m steps)
(b) P, P_s |- (H2, (P_s (f)) v2) -n->tr (H2', v2') (f v2 terminates in n steps
with same trace as f v1)
(c) S' |- H1' =eq= H2' (output heaps are equivalent modulo secrets)
(d) P; S'[q]; G_s[q] |- v1' : t2[q]
72 Protzenko et al.
(e) P; S'[q]; G_s[q] |- v2' : t2[q]
(f) (v1', v2') \in V_t2 (v1' and v2' are equivalent modulo secrets)
(g) P; S'[q]; G_s[q] |- H1'
(h) P; S'[q]; G_s[q] |- H2'
----------------------------------------
Remark: a separate lemma can show m = n
----------------------------------------
-------------------------------------
Lemma: Gen-function-lemma-for-values
-------------------------------------
If
(1) G_s |- t
(2) G_s |- q
(3) P; S[q]; G_s |- v1 : t[q]
(4) P; S[q]; G_s |- v2 : t[q]
(5) (v1, v2) \in V_t
Then
(a) Gen v1 v2 t = v, p1, p2, G
(b) P; S; G_s, G |- v : t
(c) S; G_s, G |-_q p1
(d) S; G_s, G |-_q p2
------------------------------------
Lemma: Gen-function-lemma-for-heaps
------------------------------------
If
(1) G_s |- q
(2) P; S[q]; G_s |- H1
Verified Low-Level Programming Embedded in F‚àó 73
(3) P; S[q]; G_s |- H2
(4) S |- H1 =eq= H2
Then
(a) Gen H1 H2 S = (H, p1, p2, G)
(b) P; S; G_s, G |- H
(c) S; G_s, G |-_q p1
(d) S; G_s, G |-_q p2
----------------------------
Substitution-lemma-for-Low*
----------------------------
If
(1) P; S; G_s, G, x:t |- e : t'
(2) P; S; G_s, G |- v : t
Then
(a) P; S; G_s, G |- e[v/x] : t'
-----------------------
Lemma: Value-inversion
-----------------------
(a) If P; S; G_s |- v : int, then v = n.
(b) If P; S; G_s |- v : buf t, then v = (b, n)
--------------------------
Subject reduction of Low*
--------------------------
If
(1) P; S; G_s |- P (program is well typed)
(2) P; S; G_s, G |- e : t (e has type t)
(3) .; S[q]; G_s[q] |- P_s (P_s is a well typed implementation
of the interface G_s)
74 Protzenko et al.
(4) P, P_s |- H, e -->tr H', e'
(5) P; S; G_s |- H
Then, exists S' \superset S s.t.
(a) P; S'; G_s, G |- e': t
(b) P; S'; G_s |- H'
Proof: Low* type system is a simply-typed type system, so the proofs go through
in an unsurprising manner.
Also, the type system ensures subject reduction, but does not ensure progress
since it does not track the buffer bounds.
-----------------------------------------
Lemma: Equivalence-modulo-secrets-values
-----------------------------------------
If
(1) P; S; G_s, G_f |- v : t (v is well-typed against the secrets interface)
(2) S; G_s, G_f |-_q p (p is a well-typed substitution of secret variables under
instantiations of type variables q)
(3) S; G_s, G_f |-_q p1 (p1 is also a well-typed substitution)
Then
(a) (v[p], v[p1]) \in V_t (the substituted values are related)
----------------------------------------
Lemma: Equivalence-modulo-secrets-heaps
----------------------------------------
(Explanation same as the above lemma)
If
(1) P; S; G_s, G_f |- H
(2) S; G_s, G_f |-_q p (p is a well-typed substitution of secret variables under
instantiations of type variables q)
(3) S; G_s, G_f |-_q p1 (p1 is also a well-typed substitution)
Verified Low-Level Programming Embedded in F‚àó 75
Then
(a) S |- H[p] =eq= H[p1]
-------------------------------
Lemma: Substituted-value-typing
-------------------------------
If
(1) P; S; G_s, G_f |- v : t (v is well-typed)
(2) S; G_s, G_f |-_q p (substitution p is well-typed
with type variables instantiations q)
Then
(a) P; S[q]; G_s[q] |- v[p] : t[q] (substituted value is well-typed and closed)
-------------------------------
Lemma: Substituted-heap-typing
-------------------------------
If
(1) P; S; G_s, G_f |- H (H is well-typed)
(2) S; G_s, G_f |-_q p (substitution p is well-typed
with type variables instantiations q)
Then
(a) P; S[q]; G_s[q] |- H[p] (substituted heap is well-typed and closed)
-------------------------------------
Lemma: Non-secret-value-substitution
-------------------------------------
If
(1) S; G_s, G_f |-_q p
(2) P; S; G_s, G_f |- v[p] : t
Then
(a) If t = int, then v = n.
76 Protzenko et al.
(b) If t = buf t, then v = (b, n)
-----------------------------------
Theorem: Secret-independent-traces
-----------------------------------
(Also assume G_s |- q, G_s and q do not vary with program execution)
If
(1) P; S; G_s, G_f |- (H, e) : t (only secret type variables are free)
(2) S; G_s, G_f |-_q p (substitution of secret typed variables is well-typed)
(3) S; G_s, G_f |-_q p1 (p1 is some other substitution that is also well-typed)
(4) .; S[q]; G_s[q] |- P_s (P_s is a well typed implementation
of the interface G_s)
Then either e is a value, or
exists m > 0, n > 0,
exists S' \superseteq S, G_f' \superseteq G_f, H', e', p' \superseteq p,
p1' \superseteq p1 s.t.
(a) P, P_s |- (H, e)[p] -m->tr (H1, e1) (it takes m steps, emitting the trace tr)
(b) (H', e')[p'] = (H1, e1) (the resulting H1 and e1 are some template
with some substitution)
(c) P; S'; G_s, G_f' |- (H', e') : t (H' and e' are well-typed)
(d) S'; G_s, G_f' |-_q p' (the resulting substitution is well-typed)
(e) P, P_s |- (H, e)[p1] -n->tr (H', e')[p1'] (running on p1 is basically
same trace and same template
with different substitution
for secrets)
(f) S'; G_s, G_f' |-_q p1' (the second resulting substitution
is also well-typed)
-------------------------
Proof: by induction on e
-------------------------
Case e = let x:t1 = e1 in e2
------------------------------
Subcase 1: e1 is not a value:
Verified Low-Level Programming Embedded in F‚àó 77
------------------------------
Inverting [E-Let] with (1), we get:
(5) P; S; G_s, G_f |- e1 : t1
Applying I.H. on (5), (2), and (3):
(6) P, P_s |- (H, e1)[p] -m->tr (H1, e11)
(7) (H', e1')[p'] = (H1, e11)
(8) P; S'; G_s, G_f' |- (H', e1') : t1
(9) S; G_s, G_f' |-_q p'
(10) P, P_s |- (H, e1)[p1] -n->tr (H', e1')[p1']
(11) S; G_s, G_f' |-_q p1'
Choose m = m, n = n.
Choose S' = S', G_f' = G_f', H' = H', e' = let x = e1' in e2, p' = p', p1' = p1'
And, choose the evaluation context LE = let x = <> in e2
Using [Step], the evaluation context stepping rule, we get (a):
(12) P, P_s |- (H, let x = e1 in e2)[p] -m->tr (H1, let x = e11 in e2[p])
Consider (H', let x = e1' in e2)[p'], since p' \supserseteq p, e2[p'] = e2[p],
hence we get (b).
(c) follows from applying [T-Let] with (8), and weakening lemmas.
(d) follows from (9).
(e) follows similar to deriving (a) above.
(f) follow from (11).
Subcase 2: e1 is a value
-------------------------
(5) e[p] = let x = e1[p] in e2[p]
Using [E-Let]:
(6) P, P_s |- (H[p], let x = e1[p] in e2[p]) --> (H[p], e2[p][e1[p]/x])
Choosing m = 1, H1 = H[p], e1 = e2[p][e1[p]/x], tr = ., we get (a).
78 Protzenko et al.
Choosing H' = H, e' = e2[e1/x], p' = p, we get (b).
Inverting [T-Let] with (1), we get:
(7) P; S; G_s, G_f |- e1 : t'
(6) P; S; G_s, G_f, x:t' |- e2 : t
Since e1 is a value, Using Lemma [Substitution-lemma-for-Low*], we get:
(8) P; S; G_s, G_f |- e2[e1/x] : t
Since H' = H, we get (c).
Since p' = p, we get (d) from (2).
(e) follows similar to above evaluation for p with n = 1
(p really did not play any role in the evaluation above).
(f) follows from (3), since p1' = p1.
Case e = let x = f e1 in e2
-----------------------------
Subcase 1: e1 is not a value:
-----------------------------
Inverting [T-App] with (1):
(5) P; S; G_s, G_f |- e1 : t1
Applying I.H. on (5), (2), and (3):
(6) P, P_s |- (H, e1)[p] -m->tr (H1, e11)
(7) (H', e1')[p'] = (H1, e11)
(8) P; S'; G_s, G_f' |- (H', e1') : t1
(9) S; G_s, G_f' |-_q p'
(10) P, P_s |- (H, e1)[p1] -n->tr (H', e1')[p1']
(11) S; G_s, G_f' |-_q p1'
Choose m = m, n = n.
Choose S' = S', G_f' = G_f', H' = H', e' = let x = f e1' in e2, p' = p', p1' = p1'
And, choose the evaluation context LE = let x = f <> in e2
Verified Low-Level Programming Embedded in F‚àó 79
Using [Step], the evaluation context stepping rule, we get (a):
(12) P, P_s |- (H, let x = f e1 in e2)[p] -m->tr (H1, let x = f e11 in e2[p])
Consider (H', let x = f e1' in e2)[p'], since p' \supserseteq p, e2[p'] = e2[p],
hence we get (b).
(c) follows from applying [T-App] with (8), and weakening lemmas.
(d) follows from (9).
(e) follows similar to deriving (a) above.
(f) follow from (11).
Subcase 2: e1 is a value
-------------------------
Subsubcase 1: f \in P:
----------------------
Inverting [T-App] with (1):
(5) P(f) = fun (x:t1) -> e:t
(6) P; S; G_s, G_f |- e1 : t1
(7) P; S; G_s, G_f, x:t |- e2 : t2
Using [App], we get:
(8) P, P_s |- (H, let x = f e1 in e2)[p] -0->. (H[p], let x = e[e1[p]/x] in e2[p])
which gives us (a).
Since e1 has no free secret variables,
(9) let x = e[e1[p]/x] in e2[p] = (let x = e[e1/x] in e2)[p]
Choose H' = H, e' = let x = e[e1/x] in e2, and p' = p to get (b).
Choose S' = S, G_f' = G_f
Using substitution lemma with weakening:
(10) P; S; G_s, G_f |- e[e1/x] : t (recall e1 is a value)
Applying [E-Let] with (10) and (7):
80 Protzenko et al.
(11) P; S; G_s, G_f |- let x = e[e1/x] in e2 : t2
And since H' = H, we get (c).
(d) follows since G_f' = G_f and p' = p.
(e) follows since m = n = 0, and tr = . .
(f) follows since p1' = p1.
Subsubcase 2: f:t1 -> t2 \in G_f
----------------------------------
Inverting (1):
(5) P; S; G_s, G_f |- H
(6) P; S; G_s, G_f |- e1 : t1
(7) P; S; G_s, G_f, x:t2 |- e2 : t
Using Lemma [Substituted-value-typing] with (2) and (6):
(8) P; S[q]; G_s[q] |- e1[p] : t1[q]
Using Lemma [Substituted-value-typing] with (3) and (6):
(9) P; S[q]; G_s[q] |- e1[p1] : t1[q]
Using Lemma [Substituted-heap-typing] with (2) and (5):
(10) P; S[q]; G_s[q] |- H[p]
Using Lemma [Substituted-heap-typing] with (3) and (5):
(11) P; S[q]; G_s[q] |- H[p1]
Using Lemma [Equivalence-modulo-secrets-heaps] with (5), (2), and (3):
(12) S |- H[p] =eq= H[p1]
Using Lemma [Equivalence-modulo-secrets-values] with (6), (2), and (3):
(13) (e1[p], e2[p]) \in V_t1
Using assumption about secret manipuating functions with
H1 = H[p], H2 = H[p1], v1 = e1[p], v2 = e1[p1]
and (12), (8), (9), (13), (10), and (11):
(14) P, P_s |- (H[p], f e1[p]) -m->tr (H1', v1')
Verified Low-Level Programming Embedded in F‚àó 81
(15) P, P_s |- (H[p1], f e1[p1]) -n->tr (H2', v2')
(16) S' |- H1' =eq= H2'
(17) P; S'[q]; G_s |- v1' : t2[q]
(18) P; S'[q]; G_s |- v2' : t2[q]
(19) (v1', v2') \in V_t2
(20) P; S'[q]; G_s |- H1'
(21) P; S'[q]; G_s |- H2'
Using Lemma [Gen-function-lemma-for-values] with (assume), (17), (18), (19):
(22) Gen v1' v2' t2 = v, p', p1', G
(22a) P; S; G_s, G |- v : t2
(23) S; G_s, G |-_q p'
(24) S; G_s, G |-_q p1'
Using Lemma [Gen-function-lemma-for-heaps] with (assume), (20), (21), (16):
(25) Gen H1 H2 S' = H', p_h, p_h1, G_h
(25a) P; S; G_s, G_h |- H'
(26) S; G_s, G_h |-_q p_h
(27) S; G_s, G_h |-_q p_h1
For theorem consequences, choose:
m = m, n = n, S' = S', G_f' = G_f \union G \union G_h, H' = H',
e' = let x = v in e2, p' = p \union p' \union p_h, p1' = p1 \union p1' \union p_h1
(a), (b), and (e) follow from [Context] rule of semantics and (22) and (25) above.
(d) and (f) follow from (23), (24), (26), and (27).
(c) follows from (22a) and (7) with [T-Let] and heap typing from (25a).
Case e = let _ = writebuf e1 e2 e3 in e
----------------------------------------
82 Protzenko et al.
Subcase 1: One of e1, e2, e3 is not a value: These are context cases proven similar
to the context cases of let and application above.
Subcase 2: e1, e2, e3 are values
---------------------------------
Inverting (1):
(4) P; S; G_s, G_f |- H
(5) P; S; G_s, G_f |- e1 : buf t1
(6) P; S; G_s, G_f |- e2 : int
(7) P; S; G_s, G_f |- e3 : t1
Using Lemma [Substituted-value-typing] with (5) and (2):
(8) P; S[q]; G_s[q] |- e1[p] : buf t1[q]
Using Lemma [Substituted-value-typing] with (6) and (2):
(9) P; S[q]; G_s[q] |- e2[p] : int
Using Lemma [Substituted-value-typing] with (7) and (2):
(10) P; S[q]; G_s[q] |- e3[p] : t1[q]
Using Lemma [Value-inversion], we get:
(11) e1[p] = (b, n), actually e1 = (b, n)
(12) e2[p] = n', actually e2 = n' (Lemma [Non-secret-value-substitution])
Using [E-Write]:
(13) P, P_s |- (H, let _ = write e1 e2 e3 in e)[p] ->write(b, n + n')
(H[p][(b, n + n') |-> e3[p]], e[p])
(the step can get stuck if the index is out of bound or the frame has been popped,
in which case we just step to stuck value)
For (a) and (b) choose m = 1, tr = write(b, n + n'), H' = H[(b, n + n') |-> e3],
e' = e, p' = p, S' = S, G_f' = G_f
(c) simply follows from the inversion of typing judgment (1),
and new heap is also well-typed.
(d) follows from (2).
We can do similar analysis with p1 as above and get that:
Verified Low-Level Programming Embedded in F‚àó 83
(13) P, P_s |- (H, let _ = write e1 e2 e3 in e)[p1] ->write(b, n + n')
(H[p1][(b, n + n') |-> e3[p1]], e[p1])
Note that e1 and e2 are independent of p or p1, as noted in (11) and (12) above.
So, choose n = 1 after which (e) follows. (f) follows from (3).
Case e = let x = newbuf n e1 in e2
-----------------------------------
Subcase 1: Either e1 or e2 is not a value: These are context cases proven
similar to the let and application cases above.
Subcase 2: Both e1 and e2 are values
-------------------------------------
Inverting (1):
(4) P; S; G_s, G_f |- H
(5) P; S; G_s, G_f |- e1 : t1
(6) P; S; G_s, G_f, x:buf t |- e2 : t
Using [E-NewBuf]:
(7) P, P_s |- (H[p], let x = n e1[p] in e2[p]) ->write (b, 0) ... (b, n - 1)
(H[p][b |-> e1[p]^n], e2[p][(b, 0)/x])
Choose m = 1, n = 1, S' = S[b |-> buf t1], G_f' = G_f, H' = H[b |-> e1^n],
e' = e2[(b, 0)/x], p' = p, p1' = p1, tr = write (b, 0) ... (b, n - 1)
(a) and (b) follow from (7).
(c) follows since H' is well-typed in S', and e' is well-typed after applying
Lemma [Substitution-lemma-for-Low*].
(d) follows from (2).
(e) follows with p1' = p1, and the trace is independent of the substitution p and p'
(f) follows from (3).
Case e = let x = readbuf e1 e2 in e
------------------------------------
Subcase 1: One of e1 or e2 is not a value: These are context cases proven
similar to the let and application cases above.
84 Protzenko et al.
Subcase 2: Both e1 and e2 are values
-------------------------------------
Inverting (1):
(4) P; S; G_s, G_f |- e1 : buf t1
(5) P; S; G_s, G_f |- e2 : int
(6) P; S; G_s, G_f, x:t1 |- e : t
Using Lemma [Substituted-value-typing] with (4) and (2), (5) and (2), and
Lemma [Substituted-heap-typing] with (6) and (2):
(7) P; S[q]; G_s[q] |- e1[p] : buf t1[q]
(8) P; S[q]; G_s[q] |- e2[p] : int
(9) P; S[q]; G_s[q] |- H[p]
Using Lemma [Non-secret-value-substitution] with (7) and (8):
(10) e1 = (b, n)
(11) e2 = n'
Using [E-Read]:
(12) P, P_s |- (H, let x = readbuf e1 e2 in e)[p] ->read (b, n + n')
(H[p], e[p][H[p](b, n + n')/x])
(the step can get stuck if the index is out of bound or the frame has been popped,
in which case we just step to stuck value)
Choose m = 1, n = 1.
Choose S' = S, G_f' = G_f, H' = H, e' = e[H(b, n + n')/x], p' = p, p1' = p1
(a) and (b) follow from (12).
(c) follows since H' = H, and e' is well-typed
after applying Lemma [Substitution-lemma-for-Low*].
(d) follows from (2).
(e) follows similar to (12).
(f) follows from (3).
Verified Low-Level Programming Embedded in F‚àó 85
REFERENCES
2008‚Äì2017. The Sodium crypto library (libsodium). (2008‚Äì2017). https://www.gitbook.com/book/jedisct1/libsodium/details
2010‚Äì2017. The Rust Programming Language. (2010‚Äì2017). https://www.rust-lang.org
2016. CVE-2016-7054: ChaCha20/Poly1305 heap-buer-overow. (Nov. 2016). http://cve.mitre.org/cgi-bin/cvename.cgi?
name=CVE-2016-7054
2017. Common Weakness Enumeration (CWE-190: Integer Overow or Wraparound). (2017). https://cwe.mitre.org/data/
denitions/190.html
2017. Common Weakness Enumeration (CWE-415: Double Free). (2017). http://cwe.mitre.org/data/denitions/415.html
2017. Common Weakness Enumeration (CWE-416: Use After Free). (2017). http://cwe.mitre.org/data/denitions/416.html
J. Afek and A. Sharabani. 2007. Dangling Pointer ‚Äì Smashing The Pointer For Fun And Prot. BlackHat USA. (July 2007).
Danel Ahman, CƒÉtƒÉlin Hri≈£cu, Kenji Maillard, Guido Mart√≠nez, Gordon Plotkin, Jonathan Protzenko, Aseem Rastogi, and
Nikhil Swamy. 2017. Dijkstra Monads for Free. In 44th ACM SIGPLAN Symposium on Principles of Programming Languages
(POPL). ACM, 515‚Äì529. https://doi.org/10.1145/3009837.3009878
Nadhem J. AlFardan and Kenneth G. Paterson. 2013. Lucky Thirteen: Breaking the TLS and DTLS Record Protocols. In 2013
IEEE Symposium on Security and Privacy. 526‚Äì540.
Jos√© Bacelar Almeida, Manuel Barbosa, Gilles Barthe, and Fran√ßois Dupressoir. 2016a. Veriable Side-Channel Security of
Cryptographic Implementations: Constant-Time MEE-CBC. In Fast Software Encryption - 23rd International Conference,
FSE 2016. 163‚Äì184.
Jos√© Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Fran√ßois Dupressoir, and Michael Emmi. 2016b. Verifying Constant-
Time Implementations. In 25th USENIX Security Symposium, USENIX Security 16. 53‚Äì70.
Sidney Amani, Alex Hixon, Zilin Chen, Christine Rizkallah, Peter Chubb, Liam O‚ÄôConnor, Joel Beeren, Yutaka Nagashima,
Japheth Lim, Thomas Sewell, and others. 2016. COGENT: Verifying High-Assurance File System Implementations.
In Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and
Operating Systems. ACM, 175‚Äì188.
Nada Amin and Tiark Rompf. 2017. LMS-Verify: Abstraction without Regret for Veried Systems Programming. To
appear in 44th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL‚Äô17). (2017). https:
//www.cs.purdue.edu/homes/rompf/papers/amin-draft2016b.pdf
Andrew W. Appel. 2015. Verication of a Cryptographic Primitive: SHA-256. ACM Trans. Program. Lang. Syst. 37, 2 (2015),
7.
Gilles Barthe, Gustavo Betarte, Juan Diego Campo, Carlos Daniel Luna, and David Pichardie. 2014. System-level Non-
interference for Constant-time Cryptography. In 2014 ACM SIGSAC Conference on Computer and Communications Security,
CCS 2014. 1267‚Äì1279.
David Benjamin. 2016. poly1305-x86.pl produces incorrect output. https://mta.openssl.org/pipermail/openssl-dev/
2016-March/006161. (2016).
Emery D. Berger, Benjamin G. Zorn, and Kathryn S. McKinley. 2002. Reconsidering Custom Memory Allocation. In
Proceedings of the 17th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications,
OOPSLA 2002. ACM, 1‚Äì12.
Lennart Beringer, Adam Petcher, Q Ye Katherine, and Andrew W Appel. 2015. Veried correctness and security of OpenSSL
HMAC. In 24th USENIX Security Symposium (USENIX Security 15). 207‚Äì221.
Daniel J Bernstein. 2005. The Poly1305-AES message-authentication code. In International Workshop on Fast Software
Encryption. Springer, 32‚Äì49.
Daniel J Bernstein. 2006. Curve25519: new Die-Hellman speed records. In International Workshop on Public Key Cryptog-
raphy. Springer, 207‚Äì228.
Daniel J Bernstein. 2008. The Salsa20 family of stream ciphers. In New stream cipher designs. Springer, 84‚Äì97.
Daniel J Bernstein, Tanja Lange, and Peter Schwabe. 2012. The security impact of a new cryptographic library. In International
Conference on Cryptology and Information Security in Latin America, LATINCRYPT 2012. Springer, 159‚Äì176.
Daniel J Bernstein, Bernard Van Gastel, Wesley Janssen, Tanja Lange, Peter Schwabe, and Sjaak Smetsers. 2014. TweetNaCl:
A crypto library in 100 tweets. In International Conference on Cryptology and Information Security in Latin America,
LATINCRYPT 2014. 64‚Äì83.
Karthikeyan Bhargavan, Antoine Delignat-Lavaud, C√©dric Fournet, , Alfredo Pironti, and Pierre-Yves Strub. 2014. Triple
Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS. In 2014 IEEE Symposium on Security and
Privacy. 98‚Äì113.
Karthikeyan Bhargavan, Antoine Delignat-Lavaud, C√©dric Fournet, Markulf Kohlweiss, Jianyang Pan, Jonathan Protzenko,
Aseem Rastogi, Nikhil Swamy, Santiago Zanella B√©guelin, and Jean Karim Zinzindohoue. 2017. Implementing and
Proving the TLS 1.3 Record Layer. IEEE Security & Privacy (2017).
86 Protzenko et al.
Karthikeyan Bhargavan, C√©dric Fournet, Markulf Kohlweiss, Alfredo Pironti, and P Strub. 2013. Implementing TLS with
veried cryptographic security. In IEEE Symposium on Security and Privacy. 445‚Äì459.
Karthikeyan Bhargavan, C√©dric Fournet, Markulf Kohlweiss, Alfredo Pironti, Pierre-Yves Strub, and Santiago Zanella-
B√©guelin. 2014. Proving the TLS handshake secure (as it is). In Advances in Cryptology‚ÄìCRYPTO 2014. Springer, 235‚Äì255.
Karthikeyan Bhargavan and Ga√´tan Leurent. 2016. On the Practical (In-)Security of 64-bit Block Ciphers: Collision Attacks
on HTTP over TLS and OpenVPN. Cryptology ePrint Archive, Report 2016/798. (2016). http://eprint.iacr.org/2016/798.
Sandrine Blazy and Xavier Leroy. 2009. Mechanized semantics for the Clight subset of the C language. Journal of Automated
Reasoning 43, 3 (2009), 263‚Äì288.
Hanno B√∂ck. 2016. Wrong results with Poly1305 functions. https://mta.openssl.org/pipermail/openssl-dev/2016-March/
006413. (2016).
Hanno B√∂ck, Aaron Zauner, Sean Devlin, Juraj Somorovsky, and Philipp Jovanovic. 2016. Nonce-Disrespecting Adversaries:
Practical Forgery Attacks on GCM in TLS. Cryptology ePrint Archive, Report 2016/475. (2016). http://eprint.iacr.org/
2016/475.
Barry Bond, Chris Hawblitzel, Manos Kapritsos, K. Rustan M. Leino, Jacob R. Lorch, Bryan Parno, Ashay Rane, Srinath
Setty, and Laure Thompson. 2017. Vale: Verifying High-Performance Cryptographic Assembly Code. In Proceedings of
the USENIX Security Symposium.
Hao Chen, Xiongnan (Newman) Wu, Zhong Shao, Joshua Lockerman, and Ronghui Gu. 2016. Toward compositional
verication of interruptible OS kernels and device drivers. In 37th ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2016. 431‚Äì447.
Yu-Fang Chen, Chang-Hong Hsu, Hsin-Hung Lin, Peter Schwabe, Ming-Hsien Tsai, Bow-Yaw Wang, Bo-Yin Yang, and
Shang-Yi Yang. 2014. Verifying curve25519 software. In ACM SIGSAC Conference on Computer and Communications
Security (CCS). 299‚Äì309.
Adam Chlipala. 2013. The Bedrock structured programming system: Combining generative metaprogramming and Hoare
logic in an extensible program verier. In ACM SIGPLAN Notices, Vol. 48. ACM, 391‚Äì402.
Ernie Cohen, Markus Dahlweid, Mark Hillebrand, Dirk Leinenbach, Micha≈Ç Moskal, Thomas Santen, Wolfram Schulte,
and Stephan Tobies. 2009. VCC: A practical system for verifying concurrent C. In International Conference on Theorem
Proving in Higher Order Logics. Springer, 23‚Äì42.
Jeremy Condit, Matthew Harren, Zachary Anderson, David Gay, and George C Necula. 2007. Dependent types for low-level
programming. In European Symposium on Programming. Springer, 520‚Äì535.
Leonardo Mendon√ßa de Moura and Nikolaj Bj√∏rner. 2008. Z3: An Ecient SMT Solver. In 14th International Conference on
Tools and Algorithms for the Construction and Analysis of Systems, TACAS (Lecture Notes in Computer Science), Vol. 4963.
Springer, 337‚Äì340. https://doi.org/10.1007/978-3-540-78800-3_24
I. Dobrovitski. 2003. Exploit for CVS double free() for Linux pserver. (Feb. 2003). http://archives.neohapsis.com/archives/
fulldisclosure/2003-q1/0545.html
Robert W. Dockins. 2012. Operational Renement for Compiler Correctness. Ph.D. Dissertation. Princeton University.
Joey Dodds. 2016. Part one: Verifying s2n HMAC with SAW. Galois Blog. (Sept. 2016). https://galois.com/blog/2016/09/
specifying-hmac-in-cryptol/
Thai Duong and Juliano Rizzo. 2011. Here Come The ‚äï Ninjas. Available at http://nerdoholic.org/uploads/dergln/beast_
part2/ssl_jun21.pdf. (May 2011).
Anthony Green. 2014. The lib home page. (2014). http://sourceware.org/lib
David Greenaway, June Andronick, and Gerwin Klein. 2012. Bridging the Gap: Automatic Veried Abstraction of C. In 3rd
International Conference on Interactive Theorem Proving, ITP 2012 (Lecture Notes in Computer Science), Vol. 7406. Springer,
99‚Äì115.
David Greenaway, Japheth Lim, June Andronick, and Gerwin Klein. 2014. Don‚Äôt sweat the small stu: formal verication of
C code without the pain. In ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2014.
ACM, 429‚Äì439.
Heartbleed. 2014. The Heartbleed Bug. http://heartbleed.com/. (2014).
Bart Jacobs, Jan Smans, and Frank Piessens. 2014. The VeriFast Program Verier: A Tutorial. iMinds-DistriNet, Department
of Computer Science, KU Leuven - University of Leuven, Belgium. (2014). https://people.cs.kuleuven.be/~bart.jacobs/
verifast/tutorial.pdf
Trevor Jim, J Gregory Morrisett, Dan Grossman, Michael W Hicks, James Cheney, and Yanling Wang. 2002. Cyclone: A Safe
Dialect of C.. In USENIX Annual Technical Conference, General Track. 275‚Äì288.
David Kaloper-Mer≈°injak, Hannes Mehnert, Anil Madhavapeddy, and Peter Sewell. 2015. Not-quite-so-broken TLS: Lessons
in re-engineering a security protocol specication and implementation. In 24th USENIX Security Symposium (USENIX
Security 15). 223‚Äì238.
Florent Kirchner, Nikolai Kosmatov, Virgile Prevosto, Julien Signoles, and Boris Yakobowski. 2015. Frama-C: A software
analysis perspective. Formal Asp. Comput. 27, 3 (2015), 573‚Äì609.
Verified Low-Level Programming Embedded in F‚àó 87
G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T.
Sewell, H. Tuch, and S. Winwood. 2009. seL4: Formal Verication of an OS Kernel. In Proceedings of the Symposium on
Operating Systems Principles. ACM, 207‚Äì220.
Paul C. Kocher. 1996. Timing Attacks on Implementations of Die-Hellman, RSA, DSS, and Other Systems. In Advances in
Cryptology ‚Äì CRYPTO 1996. Springer, 104‚Äì113.
Xavier Leroy. 2004‚Äì2016. The CompCert C veried compiler. http://compcert.inria.fr/. (2004‚Äì2016).
Xavier Leroy. 2009. Formal verication of a realistic compiler. Commun. ACM 52, 7 (2009), 107‚Äì115.
Xavier Leroy, Andrew W. Appel, Sandrine Blazy, and Gordon Stewart. 2012. The CompCert Memory Model, Version 2.
Research report RR-7987. INRIA. http://hal.inria.fr/hal-00703441
Xavier Leroy and Sandrine Blazy. 2008. Formal verication of a C-like memory model and its uses for verifying program
transformations. Journal of Automated Reasoning 41, 1 (2008), 1‚Äì31.
Pierre Letouzey. 2002. A new extraction for Coq. In Types for proofs and programs. Springer, 200‚Äì219.
Pierre Letouzey. 2008. Extraction in Coq: An Overview. In 4th Conference on Computability in Europe (Lecture Notes in
Computer Science), Vol. 5028. Springer, 359‚Äì369. https://doi.org/10.1007/978-3-540-69407-6_39
Nicholas D Matsakis and Felix S Klock II. 2014. The Rust language. In ACM SIGAda Ada Letters, Vol. 34. ACM, 103‚Äì104.
John McCarthy. 1962. Towards a Mathematical Science of Computation. In IFIP Congress. 21‚Äì28.
Microsoft Research and INRIA. 2016. Everest: VERiEd Secure Transport. https://project-everest.github.io/. (2016).
Bodo M√∂ller, Thai Duong, and Krzysztof Kotowicz. 2014. This POODLE Bites: Exploiting The SSL 3.0 Fallback. Available at
https://www.openssl.org/~bodo/ssl-poodle.pdf. (2014).
David Molnar, Matt Piotrowski, David Schultz, and David Wagner. 2006. The Program Counter Security Model: Automatic
Detection and Removal of Control-ow Side Channel Attacks. In 8th International Conference on Information Security
and Cryptology, ICISC 2005. Springer, 156‚Äì168.
Yoav Nir and Adam Langley. 2015. ChaCha20 and Poly1305 for IETF Protocols. IETF RFC 7539. (2015).
nocrypto. 2014‚Äì2017. nocrypto: OCaml cryptographic library. (2014‚Äì2017). https://github.com/mirleft/ocaml-nocrypto
OpenSSL library. 1998‚Äì2017. OpenSSL: Cryptography and SSL/TLS Toolkit. (1998‚Äì2017). https://www.openssl.org/
Jonathan D. Pincus and Brandon Baker. 2004. Beyond Stack Smashing: Recent Advances in Exploiting Buer Overruns.
IEEE Security & Privacy 2, 4 (2004), 20‚Äì27.
Jonathan Protzenko. 2017. The KreMLin compiler. (2017). https://www.github.com/FStarLang/kremlin
Julian Rizzo and Thai Duong. 2012. The CRIME Attack. (September 2012).
Norbert Schirmer. 2006. Verication of sequential imperative programs in Isabelle-HOL. Ph.D. Dissertation. Technical
University Munich.
Ben Smyth and Alfredo Pironti. 2014. Truncating TLS Connections to Violate Beliefs in Web Applications. Technical Report
hal-01102013. Inria. https://hal.inria.fr/hal-01102013
Juraj Somorovsky. 2016. Systematic fuzzing and testing of TLS libraries. In 23rd ACM Conference on Computer and
Communications Security, CCS 2016.
Marc Stevens, Pierre Karpman, and Thomas Peyrin. 2016. Freestart Collision for Full SHA-1. In Advances in Cryptology ‚Äì
EUROCRYPT 2016. Springer, 459‚Äì483.
Nikhil Swamy, CƒÉtƒÉlin Hri≈£cu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan
Bhargavan, C√©dric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, Jean-Karim Zinzindohou√©, and Santiago Zanella-
B√©guelin. 2016. Dependent Types and Multi-Monadic Eects in F*. In 43rd ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL). ACM, 256‚Äì270. https://www.fstar-lang.org/papers/mumon/
Robert ≈öwiƒôcki. 2016. ChaCha20/Poly1305 heap-buer-overow. CVE-2016-7054. (2016).
Laszlo Szekeres, Mathias Payer, Tao Wei, and Dawn Song. 2013. SoK: Eternal War in Memory. In IEEE Symposium on Security
and Privacy. IEEE Computer Society, 48‚Äì62.
David Tarditi. 2016. Extending C with bounds safety. Checked C Technical Report, Version 0.6. (Nov. 2016). https:
//github.com/Microsoft/checkedc
Mads Tofte and Jean-Pierre Talpin. 1997. Region-Based Memory Management. Inf. Comput. 132, 2 (Feb. 1997), 109‚Äì176.
A. Tomb. 2016. Automated Verication of Real-World Cryptographic Implementations. IEEE Security Privacy 14, 6 (2016),
26‚Äì33.
David Wagner and Bruce Schneier. 1996. Analysis of the SSL 3.0 Protocol. In 2nd USENIX Workshop on Electronic Commerce,
WOEC 1996. 29‚Äì40.
Simon Winwood, Gerwin Klein, Thomas Sewell, June Andronick, David Cock, and Michael Norrish. 2009. Mind the Gap.
In 22nd International Conference on Theorem Proving in Higher Order Logics, TPHOLs 2009 (Lecture Notes in Computer
Science), Vol. 5674. Springer, 500‚Äì515.
Jianzhou Zhao, Santosh Nagarakatte, Milo M. K. Martin, and Steve Zdancewic. 2012. Formalizing the LLVM intermediate
representation for veried program transformations. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (POPL). 427‚Äì440.
88 Protzenko et al.
Jianzhou Zhao, Santosh Nagarakatte, Milo M. K. Martin, and Steve Zdancewic. 2013. Formal verication of SSA-based
optimizations for LLVM. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI).
175‚Äì186.
Jean Karim Zinzindohou√©, Evmora-Iro Bartzia, and Karthikeyan Bhargavan. 2016. A Veried Extensible Library of Elliptic
Curves. In IEEE Computer Security Foundations Symposium (CSF).
Jean-Karim Zinzindohou√©, Karthikeyan Bhargavan, Jonathan Protzenko, and Benjamin Beurdouche. 2017. HACL*: A
Veried Modern Cryptographic Library. (2017). http://eprint.iacr.org/2017/536
Jean-Karim Zinzindohou√©, Karthikeyan Bhargavan, and Benjamin Beurdouche. 2017. HACL*: A Veried Modern Crypto-
graphic Library. (2017). https://www.github.com/mitls/hacl-star

