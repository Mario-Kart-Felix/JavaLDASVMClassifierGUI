Is my attack tree correct?
Extended version?
Maxime Audinot1,2, Sophie Pinchinat1,2, and Barbara Kordy1,3
1 IRISA, Rennes, France
2 University Rennes 1, Rennes, France
3 INSA Rennes, France
Abstract. Attack trees are a popular way to represent and evaluate potential se-
curity threats on systems or infrastructures. The goal of this work is to provide
a framework allowing to express and check whether an attack tree is consistent
with the analyzed system. We model real systems using transition systems and
introduce attack trees with formally specified node labels. We formulate the cor-
rectness properties of an attack tree with respect to a system and study the com-
plexity of the corresponding decision problems. The proposed framework can be
used in practice to assist security experts in manual creation of attack trees and
enhance development of tools for automated generation of attack trees.
1 Introduction
An attack tree is a graphical model allowing a security expert to illustrate and ana-
lyze potential security threats. Thanks to their intuitiveness, attack trees gained a lot
of popularity in the industrial sector [16], and organizations such as NATO [25] and
OWASP [21] recommend their use in threat assessment processes. The root of an at-
tack tree represents an attack objective, i.e., an attacker’s goal, and the rest of the tree
decomposes this goal into sub-goals that the attacker may need to reach in order to
perform his attack [27]. In this paper, we develop a formal framework to evaluate how
well an attack tree describes the attacker’s goal with respect to the system that is being
analyzed. This work has been motivated by the two following practical problems.
First, in the industrial context, attack trees are usually created manually by security
experts who may not have an exhaustive knowledge about all the facets (technical,
social, physical) of the analyzed system. This process is often supported by the use
of libraries containing generic models for standard security threats. Although using
libraries provides a good starting point, the resulting attack tree may not always be fully
consistent with the system that is being analyzed. This problem might be reinforced by
the fact that the node names in attack trees are often very short, and may thus lack
precision or be inaccurate and misleading. If the tree is incomplete or imprecise, the
results of its analysis (e.g., estimation of the attack’s cost or its probability) might be
inaccurate. If the tree contains branches that are irrelevant for the considered system,
the time of its analysis might be longer than necessary. This implies that a manually
? This is an extended version of [4].
ar
X
iv
:1
70
6.
08
50
7v
2 
 [
cs
.C
R
] 
 2
7 
Ju
n 
20
17
created tree needs to be validated against a system to be analyzed before it can be used
as a formal model on which the security of the system will be evaluated.
Second, to limit the burden of their manual creation, several academic proposals for
automated generation of attack trees have recently been made [31,24,12]. In particular,
we are currently developing the ATSyRA tool for assisted generation of attack trees
from system models [24]. Our experience shows that, due to the complexity and scal-
ability issues, a fully automated generation is impossible. Some generation steps must
thus be supported by humans. Such a semi-automated approach gives the expert a pos-
sibility of manually decomposing a goal, in such a way that an automated generation
of the subtrees can be performed. This work provides formal foundations for the next
version of our tool which will assist the expert in producing trees that, by design, are
correct with respect to the underlying system.
Contribution. To address the problems identified above, we introduce a mathematical
framework allowing us to formalize the notion of attack trees and to define as well as
verify their practically-relevant correctness properties with respect to a given system.
We model real-life systems using finite transition systems. The attack tree nodes are
labeled with formally specified goals formulated in terms of preconditions and post-
conditions over the possible states of the transition system. Formalizing the labels of
the attack tree nodes allows us to overcome the problem of imprecise or misleading
text-based node names and makes formal treatment of attack trees possible. We define
the notion of Admissibility of an attack tree with respect to a given system and introduce
the correctness properties for attack trees, called Meet, Under-Match, Over-Match, and
Match. These properties express the precision with which a given goal is refined into
sub-goals with respect to a given system. We then establish the complexity of verifying
the correctness properties to apprehend the nature of potential algorithmic solutions to
be implemented.
Related work. In order to use any modeling framework in practice, formal founda-
tions are necessary. Previous research on formalization of attack trees focused mainly
on mathematical semantics for attack tree-based models [20,14,15,13,11], and various
algorithms for their quantitative analysis [26,17,1]. However, all these formalizations
rely on an action-based approach, where the attacker’s goals represented by the labels
of the attack tree nodes are expressed using actions that the attacker needs to perform
to achieve his/her objective. In this work, we pioneer a state-based approach to attack
trees, where the attacker’s goals relate to the states of the modeled system. The advan-
tage of such a state-based approach is that it may benefit from verification and model
checking techniques, in a natural way, as this has already been done in the case of attack
graphs [29,22]. In our framework, the label of each node of an attack tree is formulated
in terms of preconditions and postconditions over the states of the modeled system:
intuitively speaking, the goal of the attacker is to start from any state in the system
that satisfies the preconditions and reach a state where the postconditions are met. The
idea of formalizing the labels of attack tree nodes in terms of preconditions and post-
conditions has already been explored in [23]. However there, the postcondition (i.e.,
consequence) of an action is represented by a parent node and its children model the
preconditions and the action itself.
Model checking of attack trees, especially using tools such as PRISM or UPPAAL,
has already been successfully employed, in particular to support their quantitative anal-
ysis, as in [9,18,2]. Such techniques provide an effective way of handling a multi-
parameter evaluation of attack scenarios, e.g., identifying the resources needed for a
successful attack or checking whether there exists an attack whose cost is lower than a
given value and whose probability of success is greater than a certain threshold. How-
ever, these approaches either do not consider any particular system beforehand, or they
rely on a model of the system that features explicit quantitative aspects. The link be-
tween the analyzed system and the corresponding attack tree is made explicit in works
dealing with automated generation of attack trees from system models [12,24]. The
systems considered in [12] capture locations, assets, processes, policies, and actors.
The goal of the attacker is to reach a given location or obtain an asset, and the attack
tree generation algorithm relies on invalidation of policies that forbid him to do so. In
the case of [24], the ATSyRA tool is used to effectively generate a transition system for
a real-life system: starting from a domain-specific language describing the original sys-
tem, ATSyRA compiles this description into a symbolic transition system specified in
the guarded action language GAL [30]. ATSyRA can already handle the physical layer
of a system (locations and connections/accesses between them) and we are currently
working on extending it with the digital layer. Since our experience shows that generat-
ing a transition system from a description in a domain-specific language is possible and
efficient, in this paper we suppose that the transition system for a real system has been
previously created and is available.
Finally, to the best of our knowledge, the problem of defining and verifying the cor-
rectness of an attack tree with respect to the analyzed system has only been considered
in [3] which has been the starting point for the work presented in this paper.
2 Motivating example
Before presenting our framework, we first introduce a motivating example on which we
will illustrate the notions and concepts employed in this paper.
The system modeled in our running example is a building containing a safe hold-
ing a confidential document. The goal of the attacker is to reach the safe without being
detected. We purposely keep this example small and intuitive to ease the understand-
ing of the proposed framework. The floor plan of the building is depicted in Fig. 1a.
It contains two rooms, denoted by Room1 and Room2, two doors – Door1 allowing to
move from outside of the building to Room1 and Door2 connecting Room1 and Room2
– as well as one window in Room2. Both doors are initially locked and it is left un-
specified whether the window is open or not. Such unspecified information expresses
that the analyst cannot predict whether the window will be open or closed in the case
of a potential attack or that he has a limited knowledge about the system. In both cases,
this lack of information needs to be taken into account during the analysis process. The
two doors can be unlocked by means of Key1 and Key2, respectively. We assume that
a camera that monitors Door2 is located in Room1. The camera is initially on but it can
be switched off manually. The safe is in Room2.
Key1
Key2
Door2
Door1
Window
Attacker
Camera
Safe
(a) Floor plan (b) Attack scenarios
Fig. 1: Running example building
The attacker is located outside of
the building and his goal is to reach
the safe without being detected by
the camera. In Fig. 1b, we have de-
picted three scenarios (that we will
call paths) allowing the attacker to
reach his goal. In the first scenario
(depicted using dotted line), the at-
tacker goes straight through the win-
dow, if it is open. In the remaining
two scenarios, the attacker gathers
the necessary keys and goes through
the two doors, switching off the cam-
era on his way. These two scenarios
differ only in the order in which the
concurrent actions are sequentially
performed. Since collecting Key2
and switching off the camera are in-
dependent actions, the attacker can
first collect Key2 and then switch the
camera off (dashed line), or switch the camera off before collecting Key2 (solid line).
The system in our example consists of the building and the attacker. It is modeled
using state variables whose values determine possible configurations of the system.
– Position – variable describing the attacker’s position, ranging over {Outside,
Room1, Room2};
– WOpen – Boolean variable describing whether the window is open (tt) or not (ff);
– Locked1 and Locked2 – Boolean variables to describe whether the respective
doors are locked or not;
– Key1 and Key2 – Boolean variables to describe whether the attacker possesses the
respective key;
– CamOn – Boolean variable describing if the camera is on;
– Detected – Boolean variable to describe if the camera detected the attacker, i.e.,
whether the attacker has crossed the area monitored by the camera while it was on.
Given a set of state variables, we express possible configurations of a system using
propositions. Propositions are either equalities of the form state_variable=value
or Boolean combinations of such equalities. Intuitively, a proposition expresses a con-
straint on the possible configurations. A configuration in which all the variables are left
unspecified is called the empty configuration. We denote it by >.
In order to analyze the security of a system, security experts often use the model
of attack trees. An attack tree is a tree in which each node represents an attacker ob-
jective, and the children of a node represent a decomposition of this objective into sub-
objectives. In this work, we consider attack trees with three types of nodes:
– OR nodes representing alternative choices – to achieve the goal of the node, the
attacker needs to achieve the goal of at least one child;
– AND nodes representing conjunctive decomposition – to achieve the goal of the
node, the attacker needs to achieve all of the goals represented by its children (the
children of an AND node are connected with an arc);
– SAND nodes representing sequential decomposition – to achieve the goal of the
node, the attacker needs to achieve all of the goals represented by its children in
the given order (the children of a SAND node are connected with an arrow).
Reach Room2
undetected
Go through
the window
Go through
the door
Deactivate
the camera
Reach
Room2
Unlock
Door1
Unlock
Door2
Enter
Room2
Fig. 2: Attack tree with informal,
text-based node names
The attack tree given in Fig. 2 illustrates that
in order to enter Room2 undetected (root node of
type OR), the attacker can either enter through the
window or through the doors. In order to use the
second alternative (node of type AND), he needs
to make sure that the camera is deactivated and
that he reaches Room2. To achieve the last objec-
tive (node of type SAND), he first needs to unlock
Room1, then unlock Room2, and finally enter to
Room2.
One of the most problematic aspects of attack
trees are the informal, text-based names of their
nodes. These names are often very short and thus
do not express all the information that the tree au-
thor had in mind while creating the tree. In partic-
ular, the textual names relate to the objective that
the attacker should reach, however, they usually
do not capture the information about the initial situation from which he starts.
To overcome the weakness of text-based node names, we propose to formalize the
attacker’s goal using two configurations: the initial configuration, usually denoted by
ι, is the configuration before the attack starts, i.e., represents preconditions; and the fi-
nal configuration, usually denoted by γ, represents postconditions, i.e., the state to be
reached to succeed in the attack. The goal with initial configuration ι and final configu-
ration γ is written 〈ι, γ〉.
In our running example, the initial configuration is ι := (Position = Outside) ∧
(Key1 = ff) ∧ (Key2 = ff) ∧ (Locked1 = tt) ∧ (Locked2 = tt) ∧ (CamOn = tt).
It describes that the attacker is originally outside of the building, he does not have any
of the keys, the two doors are locked, and the camera is on. The final configuration
is γ := (Position = Room2) ∧ (Detected = ff), i.e., the attacker reached Room2
without being detected.
Fig. 3 illustrates how such formally specified goals are used to label the nodes of
attack trees. The goal 〈ι, γ〉 introduced above is the label of the root node of the tree. It
is then refined into sub-goals 〈ιi, γi〉, where i reflects the position of the node in the tree.
Sub-goal 〈ι1, γ1〉: The attacker, who wants to reach the safe in Room2 without be-
ing detected, is located outside of the building and the window is initially open. We
let ι1 := (Position = Outside) ∧ (Key1 = ff) ∧ (Key2 = ff) ∧ (Locked1 =
tt) ∧ (Locked2 = tt) ∧ (CamOn = tt) ∧ (WOpen = tt) and γ1 := γ.
Sub-goal 〈ι2, γ2〉: This sub-goal is similar to the previous one, but the window is orig-
inally closed. We let ι2 := (Position = Outside) ∧ (Key1 = ff) ∧ (Key2 = ff) ∧
(Locked1 = tt) ∧ (Locked2 = tt) ∧ (CamOn = tt) ∧ (WOpen = ff) and γ2 := γ.
Sub-goal 〈ι21, γ21〉: The attacker, who might be in any initial configuration, wants to
deactivate the camera. We then let ι21 := > and γ21 := (CamOn = ff).
(ι, γ)
(ι1, γ1) (ι2, γ2)
(ι21, γ21) (ι22, γ22)
(ι221, γ221) (ι222, γ222) (ι223, γ223)
Fig. 3: Attack tree with formal labels
Sub-goal 〈ι22, γ22〉: Similar to sub-goal
〈ι2, γ2〉, with the difference that we do not
care whether the camera is initially on and
we no longer require that the attacker re-
mains undetected. We let ι22 := (Position =
Outside) ∧ (Key1 = ff) ∧ (Key2 = ff) ∧
(Locked1 = tt) ∧ (Locked2 = tt) ∧
(WOpen = ff) and γ22 := (Position =
Room2).
Sub-goal 〈ι221, γ221〉: The initial situation is
the same as in the sub-goal 〈ι22, γ22〉, but
we require that the attacker unlocks Door1
but not Door2: ι221 := ι22 and γ221 :=
(Locked1 = ff) ∧ (Locked2 = tt).
Sub-goal 〈ι222, γ222〉: Now, the objective is to go from a state where Door1 is unlocked
and Door2 is locked (like in the configuration γ221) to a state where both doors are un-
locked. We let ι222 := γ221 and γ222 := (Locked1 = ff) ∧ (Locked2 = ff).
Sub-goal 〈ι223, γ223〉: Finally, the last sub-goal is for the attacker, starting in a state
where both doors are unlocked, to reach Room2. We let ι223 := γ222 and γ223 := γ22.
3 Formal modeling
We now provide formal notations and definitions of transition systems and attack trees
that we have informally described in Sect. 2.
3.1 Transition systems
We model real-life systems using finite transition systems. Transition system is a sim-
ple, yet powerful formal tool to represent a dynamic behavior of a system by listing all
its possible states and transitions between them. The finiteness of the state transition
system is a reasonable and realistic assumption. A formal model can either be finite
because the real-life underlying system is intrinsically finite, or it can have a finite rep-
resentation obtained by standard abstraction techniques, as used in verification, static
analysis, and model-checking.
We fix the set Prop of propositions that we use to formalize possible configurations
of the real system. In the rest of the paper, we suppose that Prop contains propositions
of the form ι, γ, to denote preconditions (ι) and postconditions (γ) of the goals.
Definition 1 (Transition system).
A transition system over Prop is a tuple S = (S ,→, λ), where S is a finite set of states
(elements of S are denoted by s, si for i ∈ N),→⊆ S × S is the transition relation of the
system (which is assumed left-total), and λ : Prop→ 2S is the labeling function. We say
that a state s is labeled by p when s ∈ λ(p). The size of S is |S| = |S | + |→|.
For the rest of this paper, we assume that we are given a transition systemS over Prop. A
path in S is a non-empty sequence of states. We use typical elements π, π′, π1, . . . , ρ, . . .
to denote paths. The size of a path π, denoted by |π|, is its number of transitions, and π(i)
is the element at position i in π, for 0 ≤ i ≤ |π|. An empty path4 is a path of size 0. We
writeΠ(S) for the set of all paths inS. For ι, γ ∈ Prop, we shortly say that a path π “goes
from ι to γ” whenever π(0) ∈ λ(ι) and π(|π|) ∈ λ(γ). The set of direct successors of a set
of states S ′ ⊆ S is PostS(S ′) = {s ∈ S | ∃s′ ∈ S ′ such that (s′, s) ∈→}. The set of suc-
cessors of a set of states S ′ ⊆ S is Post∗S(S ′) = {s ∈ S | ∃π with π(0) ∈ S ′ and π(|π|) =
s}, and the set of predecessors of S ′ ⊆ S is Pre∗S(S ′) = {s ∈ S | ∃π with π(0) =
s and π(|π|) ∈ S ′}.
A factor of a path π is a subsequence composed of consecutive elements of π. For-
mally, a factor of a path π is a path π′, such that there exists 0 ≤ k ≤ |π| − |π′|, where
π(i + k) = π′(i), for 0 ≤ i ≤ |π′|. An anchoring of π′ in π is an interval [k, l] ⊆ [0, |π|]
where for all i ∈ [k, l], π′(i− k) = π(i) and l− k = |π′|. Notice that we may have |π′| = 0.
We denote by π[k, l] the factor of π of anchoring [k, l]. In other words, the anchorings
of π′ in π are the intervals [k, l] of positions in π such that π[k, l] = π′.
We now introduce concatenation and parallel decomposition of paths – two notions
that will serve us to define the semantics of sequential and conjunctive refinements in
attack trees, respectively.
Definition 2 (Concatenation of paths). Let π1, π2, . . . , πn ∈ Π(S) be paths, such that
πi(|πi|) = πi+1(0) for 0 ≤ i < n − 1. The concatenation of π1, π2, . . . , πn, denoted by
π1.π2. . . . .πn, is the path π, where π[
∑i−1
k=1 |πk | ,
∑i−1
k=1 |πk | + |πi|] = πi5. We generalize the
concatenation to sets of paths by letting Π.Π ′ = {π ∈ Π(S) | ∃i, 0 ≤ i ≤ |π| and π[0, i] ∈
Π and π[i, |π|] ∈ Π ′}.
Definition 3 (Parallel decomposition of paths). A set {π1, . . . , πn} ⊆ Π(S) is a parallel
decomposition of π ∈ Π(S) if for every 1 ≤ i ≤ n the path πi is a factor of π for some
anchoring [ki, li], such that every interval [ j, j + 1] ⊆ [0, |π|] is contained in [ki, li] for
some i ∈ {1, . . . , n} (which trivially holds if |π| = 0). We then say that the sequence
π1, . . . , πn is a parallel decomposition of π for the anchorings [k1, l1], . . . , [kn, ln].
Lemma 1. Given a path π ∈ Π(S), and a sequence k1, l1, . . . , kn, ln ∈ [0, |π|], decid-
ing whether π[k1, l1], . . . , π[kn, ln] is a parallel decomposition of π for the anchorings
[k1, l1], . . . , [kn, ln] can be done in time O(n |π|).
4 Since a path is a non-empty sequence of states, the empty path contains exactly one state.
5 We use the convention that
∑0
k=1 |πk | = 0.
Proof. Verifying that π[k1, l1], . . . , π[kn, ln] is a parallel decomposition of π for the an-
chorings [k1, l1], . . . , [kn, ln] amounts to checking that for every interval [ j, j + 1] ⊆
[0, |π|], there is an i ∈ [1, n] such that [ j, j + 1] ⊆ [ki, li]. This can clearly be done in time
O(n |π|) by a naive approach. ut
An example of a parallel decomposition is illustrated in Fig. 4, where π1 = π[0, 2],
π2 = π[3, 5], and π3 = π[1, 4].
s0
ι• s1
• s2
• π s3
• s4
• s5
γ
•
s0
ι1•
π1
s2
γ1• s3
ι2•
π2
s5
γ2•
s1
ι3•
π3
s4
γ3•
Fig. 4: Parallel decomposition of π into {π1, π2, π3}.
A cycle in a path π ∈ Π(S) is a factor π′ of π such that π′(0) = π′(|π′|). An elemen-
tary path is a path with no cycle. Remark that an elementary path π does not contain any
state more than once, so |π| ≤ |S|. Removing a cycle π′ of anchoring [k, l] from a path
π yields the path π[0, k].π[l, |π|]. Removing all the cycles from π consists in iteratively
removing cycles until the resulting path is elementary. Note that the resulting path may
depend on the order in which the cycles are removed.
We illustrate the notions defined in this section on our running example.
Example 1. We use the state variables introduced in Sect. 2 to describe the states of a
part of our building system. By z0 we denote the state where Position = Outside (the
attacker is outside); WOpen = ff (the window is closed); Locked1 = Locked2 = tt
(both doors are locked); Key1 = Key2 = ff (the attacker does not have any key);
CamOn = tt (the camera is on); Detected = ff (the attacker has not been detected).
Furthermore, we consider seven additional states zi, such that, for every 1 ≤ i ≤ 7, the
specification of zi is the same as the specification of zi−1, except one variable: state z1 is
as z0 but Key1 = tt (the attacker has Key1); state z2 is as z1 but Locked1 = ff (Door1
is unlocked); state z3 is as z2 but Position = Room1 (the attacker is in Room1); z4 is
as z3 but CamOn = ff (the camera is off); z5 is as z4 but Key2 = tt (the attacker has
Key2); state z6 is as z5 but Locked2 = ff (Door2 is unlocked); state z7 is as z6 but
Position = Room2 (the attacker is in Room2).
To model the dynamic behavior of the system, we set (zi−1, zi) ∈→, for all 1 ≤ i ≤ 7.
Given p = (Position = Outside)∧(Locked1 = tt) and p′ = (Position = Room1)∨
(Position = Room2), we have z0, z1 ∈ λ(p) and zi ∈ λ(p′), for 3 ≤ i ≤ 7.
The path ρ = z0z1z2z3z4z5z6z7, corresponds to the scenario depicted using solid line
in Fig. 1b. The set {z0z1z2z3z4, z3z4z5z6z7} is an example of parallel decomposition of
ρ. One can notice that ρ is an elementary path. To show that while being in Room1 the
attacker can turn off but also turn on the camera, we could add the transition (z4, z3) to
→. In this case, the attacker could also take the path ρ′ = z0z1z2z3z4z3z4z5z6z7 which is
not elementary because it contains the cycle z3z4z3.
3.2 Attack trees
To evaluate the security of systems, we use attack trees. An attack tree does not re-
place the state-transition system model – it complements it with additional information
on how the corresponding real-life system could be attacked. There exist a plethora of
methods and algorithms for quantitative and qualitative reasoning about security using
attack trees [16]. However, accurate results can only be obtained if the attack tree is in
some sense consistent with the analyzed system. Our goal is thus to validate the rele-
vance of an attack tree with respect to a given system. To make this validation possible,
we need a model capturing more information than just text-based names of the nodes.
In this section, we therefore introduce a formal definition of attack trees, where the dif-
ference with the classical definition is the presence of a goal of the form 〈ι, γ〉 at each
node.
Definition 4 (Attack tree). An attack tree T over the set of propositions Prop is either a
leaf 〈ι, γ〉, where ι, γ ∈ Prop, or a composed tree of the form (〈ι, γ〉, OP)(T1,T2, . . . ,Tn),
where ι, γ ∈ Prop, OP ∈ O has arity n ≥ 2, and T1, T2, . . . , Tn are attack trees. The main
goal of an attack tree T = (〈ι, γ〉, OP)(T1,T2, . . . ,Tn) is 〈ι, γ〉 and its operator is OP.
The size of an attack tree |T | is the number of the nodes in T . Formally, |〈ι, γ〉| = 1
and |(〈ι, γ〉, OP)(T1,T2, . . . ,Tn)| = 1 + Σni=1 |Ti|.
As an example, the tree in Fig. 3 is T = (〈ι, γ〉, OR)(T1,T2). The subtree T1 = 〈ι1, γ1〉
is a leaf and T2 = (〈ι2, γ2〉, AND)(〈ι21, γ21〉,T22) is a composed tree with
T22 = (〈ι22, γ22〉, SAND)(〈ι221, γ221〉, 〈ι222, γ222〉, 〈ι223, γ223〉).
Before introducing properties that address correctness of an attack tree, we need to
define the path semantics of goal expressions that arise from tree descriptions. A goal
expression is either a mere atomic goal of the form 〈ι, γ〉 or a composed goal of the form
OP(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉), where OP ∈ {OR, SAND, AND}. The path semantics of a
goal expression is defined as follows.
– J〈ι, γ〉KS = {π ∈ Π(S) | π goes from ι to γ}
– JOR(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS = J〈ι1, γ1〉KS ∪ J〈ι2, γ2〉KS ∪ . . . ∪ J〈ιn, γn〉KS
– JSAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS = J〈ι1, γ1〉KS.J〈ι2, γ2〉KS. . . . .J〈ιn, γn〉KS
– JAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS = {π ∈ Π(S) | ∀i ∈ {1, . . . , n} ∃πi ∈ J〈ιi, γi〉KS,
s.t. {π1, π2, . . . , πn} is a parallel decomposition of π}.
Consider the goal 〈ι, γ〉 of our running example, and letZ be the system introduced
in Example 1. We have J〈ι, γ〉KS = {z0z1z2(z3z4)kz5z6z7 | k ≥ 1}, where (z3z4)k is the
path composed of k executions of z3z4.
4 Correctness properties of attack trees
We now define four correctness properties for attack trees, illustrate them on our run-
ning example, and discuss their relevance for real-life security analysis.
4.1 Definitions
Before formalizing the correctness properties for attack trees, we wish to discard attack
trees with “useless” nodes. To achieve this, we define the admissibility of an attack tree
T w.r.t. the system S.
The property that an attack tree T is admissible w.r.t. a system S is inductively de-
fined as follows. A leaf tree 〈ι, γ〉 is admissible whenever J〈ι, γ〉KS , ∅. A composed tree
(〈ι, γ〉, OP)(T1, . . . ,Tn) is admissible whenever three conditions hold: (a) J〈ι, γ〉KS , ∅,
(b) JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅, where 〈ιi, γi〉 is the main goal of Ti (1 ≤ i ≤ n), and
(c) every subtree Ti is admissible.
We now propose four notions of correctness, that provide various formal meanings
to the local refinement of a goal in an admissible tree.
Definition 5 (Correctness properties).
Let T be a composed admissible attack tree of the form (〈ι, γ〉, OP)(T1,T2 . . . ,Tn), and
assume 〈ιi, γi〉 is the main goal of Ti, for i ∈ {1, . . . , n}. The tree T has the
1. Meet property if JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅.
2. Under-Match property if JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆ J〈ι, γ〉KS.
3. Over-Match property if JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊇ J〈ι, γ〉KS.
4. Match property if JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS = J〈ι, γ〉KS.
Clearly the Match property implies all other properties, whereas Under- and Over-
Match properties are incomparable – as illustrated in Sect. 4.2 – and they both imply
the Meet property. Note that a tree T has the Match property if, and only if, it has both
the Under-Match property and the Over-Match property.
The correctness properties of Definition 5 are local (at the root of the subtree), but
they can easily be made global by propagating their requirement to all of the subtrees.
As there are |T |many subtrees, the complexity of globally deciding these properties has
the same order of magnitude as in the local case.
4.2 Illustration on the running example
In the system Z defined in Example 1 and composed of the states z0, . . . , z7, we add
two states. First, the state z′0 that is similar to z0 except that we assume that the window
is open, i.e., WOpen = tt, and second, the state z′7 that is similar to z
′
0 except that we
assume that the attacker is in Room2, i.e., Position = Room2. As a consequence the
transitions of the system Z become z′0 → z0 → z1 → z2 → z3 ↔ z4 → z5 → z6 → z7
and z′0 → z′7, where the latter models that if the window is open, the attacker can reach
Room2 undetected by entering through the window.
Let us consider the attack tree T (〈ι, γ〉, OR)(〈ι1, γ1〉,T2) from Fig. 3, where the main
goal of T2 is 〈ι2, γ2〉. Since in systemZ, the set of paths J〈ι, γ〉KS is exactly the union of
J〈ι1, γ1〉KS and J〈ι2, γ2〉KS, the tree T has the Match property w.r.t. Z. This means that
in order to achieve goal 〈ι, γ〉, it is necessary and sufficient to achieve goal 〈ι1, γ1〉 or
goal 〈ι2, γ2〉 .
We now consider the sub-tree T2 of T rooted at the node labeled by 〈ι2, γ2〉 in Fig. 3.
The tree T2 is of the form (〈ι2, γ2〉, AND)(〈ι21, γ21〉,T ′2) where the main goal of T ′2 is
〈ι22, γ22〉. Our objective is to analyze the relationship between the main goal 〈ι2, γ2〉 of
T2 and the composed goal AND(〈ι21, γ21〉, 〈ι22, γ22〉). In other words, we ask how does
the aim of reaching Room2 undetected via building relates with turning off the camera
(〈ι21, γ21〉) and reaching Room2 (〈ι22, γ22〉). A quick analysis of systemZ shows that in-
deed achieving both subgoals 〈ι21, γ21〉 and 〈ι22, γ22〉 is necessary to achieve goal 〈ι2, γ2〉,
but actually it is not sufficient. Consider the path δ = z′0z0z1z2z3z4z5z6z7. This path
achieves goal AND(〈ι21, γ21〉, 〈ι22, γ22〉), as it can be decomposed into δ21 = z′0z0z1z2z3z4
and δ22 = z0z1z2z3z4z5z6z7, achieving 〈ι21, γ21〉 and 〈ι22, γ22〉, respectively. However,
δ < J〈ι2, γ2〉KS, since z′0 < λ(ι2) (recall that ι2 requires the window to be closed which
is not the case in z′0). This is what the Over-Match property reflects. As a consequence,
the main tree T does not have the global Match property w.r.t.Z.
Symmetrically to the Over-Match property, Under-Match reflects a sufficient but not
necessary condition. To illustrate the Under-Match property, let us extend the systemZ
with one more variable ROpen modeling that there is a window in the roof of Room2,
which is either open (ROpen = tt) or closed (ROpen = ff). In all previously considered
states, we assume that ROpen = ff, and we introduce two additional states
z8: is like z0 except that ROpen = tt;
z9: is like z0 except that ROpen = tt and Position = Room2.
The extended system, that we denote by Z′, contains all transitions already present in
Z, as well as z8 → z9 which models that it is also possible to reach Room2 undetected
by entering thorough the window located in the roof, if it is open.
Let us modify slightly the attack tree from Fig. 3 by adding to the preconditions ι1
and ι2 that the window in the roof is closed. Formally, we obtain ι′1 and ι
′
2 as follows
ι′1 :=(Position = Outside) ∧ (Key1 = ff) ∧ (Key2 = ff)
∧(Locked1 = tt) ∧ (Locked2 = tt) ∧ (CamOn = tt)
∧(WOpen = tt) ∧ (ROpen = ff)
ι′2 :=(Position = Outside) ∧ (Key1 = ff) ∧ (Key2 = ff)
∧(Locked1 = tt) ∧ (Locked2 = tt) ∧ (CamOn = tt)
∧(WOpen = ff ∧ (ROpen = ff).
We are now interested in validating (with respect to the extended systemZ′) the modi-
fied tree whose root 〈ι, γ〉 is refined into OR(〈ι′1, γ1〉, 〈ι′2, γ2〉). We observe that δ′ = z8z9
satisfies the goal 〈ι, γ〉 of its root, i.e., entering Room2 undetected starting from out-
side of the building, but δ′ does not satisfy the semantics of the disjunctive refine-
ment OR(〈ι′1, γ1〉, 〈ι′2, γ2〉) because z8 < λ(ι′1) nor z8 < λ(ι′2). We can thus conclude that
Z′ |= OR(〈ι′1, γ1〉, 〈ι′2, γ2〉) v 〈ι, γ〉 which shows that the modified tree has the Under-
Match property inZ′.
Regarding the Meet property, we invite the reader to consider the following discus-
sion on the relevance of the correctness properties we have proposed.
4.3 Relevance of the correctness properties
The main objective of introducing the four correctness properties is to be able to validate
an attack tree with respect to a system S, i.e., verify how faithfully the tree represents
potential threats on S. This is of special importance for the trees that are created manu-
ally or which are borrowed from an attack tree library.
In the perfect world, we would expect to work with attack trees having the (global)
Match property, i.e., where the refinement of every (sub-)goal covers perfectly all pos-
sible ways of reaching the (sub-)goal in the system. However, a tree created by a hu-
man will rarely have this property. The experts usually do not have perfect knowl-
edge about the system and might lack information about some relevant data. Trees
that have been created for similar systems are often reused but they might actually
be incomplete or inaccurate with respect to the current system. Finally, requiring the
(global) Match property might also be unrealistic for goals expressed only with a cou-
ple 〈precondition, postcondition〉. Therefore, Match is often too strong to be the
property expected by default.
In practice, experts base their trees on some example scenarios, which implies that
they obtain trees having the (global) Meet property. The Meet property – which ensures
that there is at least one path in the system satisfying both the parent goal and its refine-
ment – is the minimum that we expect from an attack tree so that we can consider that
it is (in some sense) correct and so that we can start reasoning about the security of the
underlying system.
However, in order to be able to perform a thorough and accurate analysis of security,
one needs stronger properties to hold. One of the purposes of attack trees is to provide
a summary of possible individual attack scenarios in order to quantify the security-
relevant parameters, such as their cost, their time or their probability. This helps the
security experts to compare and rank the different scenarios, to be able to deduce the
most probable ones and propose suitable countermeasures. The classical bottom-up al-
gorithm for quantification of attack trees, described for instance in [20], assigns the
parameter values to the leaf nodes and then propagates them up to the root, using func-
tions that depend on the type of the refinement used (in our case OR, AND, SAND). This
means that the value of the parent node depends solely on the values of its children. To
make such a bottom-up quantification meaningful from the attacker’s perspective, we
need to require at least the (global) Under-Match property. Indeed, this property stipu-
lates that all the paths satisfying a refinement of a node’s goal also satisfy the goal itself.
Under-Match corresponds thus to an under-approximation of the set of scenarios and it
is enough to consider it for the purpose of finding a vulnerability in the system.
To make the analysis meaningful from the point of view of the defender, we will
rather require the Over-Match property. This property means that all the paths satisfying
the parent goal also satisfy its decomposition into sub-goals. Since the Over-Match
property corresponds to an over-approximation of the set of scenarios, it is enough to
consider it for the purpose of designing countermeasures.
Our method to evaluate the correctness of an attack tree is to check Admissibility
and the (global) Meet property. If it holds, then we say that the attack tree construction is
correct w.r.t. to the analyzed system. We then look at the stronger properties. Depending
on the situation, the expert might want to ensure either the (global) Under-Match or
the (global) Over-Match property. If the tree fails to verify the desired property with
respect to a given system S, then it needs to be reshaped before it can be employed for
the security analysis of the real system modeled by S.
5 Complexity issues
In this section, we address the complexity of deciding our four correctness properties
introduced in Definition 5. For full proofs, we refer the reader to the extended version
of this work [5]. Table 1 gives an overview of the obtained results. In the case of the OR
and the SAND operators, all the correctness properties are decided in polynomial time,
which is promising in practice. However, for the AND operator, checking the Admissi-
bility property and the Meet property is NP-complete, and checking the Under-Match
property is co-NP-complete. These last two problems are therefore intractable [10], but
recall that their complexity in practice might be lower thanks to much favorable kinds
of instances (see for example [19]).
Admissibility Meet Under-Match Over-Match Match
OR P P P P P
SAND P P P P P
AND NP-c NP-c co-NP-c co-NP co-NP
Table 1: Complexities of the correctness properties.
We first state two lemmas that will be useful for our complexity analysis. Lemma 2
provides a bound to the size of paths we need to consider in the system for the verifica-
tion of correctness properties. Lemma 3 provides the complexity of checking if a path
reflects a particular combination of subgoals.
Lemma 2. Let S be a transition system, OP ∈ {OR, AND, SAND}, and ι1, γ1, . . . , ιn, γn ∈
Prop. For every path π in JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS, there exists a path π′ of linear size
in |S| and n that is also in JOP(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS and which preserves the ends of
π, i.e., π′(0) = π(0) and π′(|π′|) = π(|π|). More precisely, |π′| ∈ O((2n − 1) |S |).
Proof. Let us start with the following remark
Remark 1. Note that if π ∈ J〈ι, γ〉KS, then the path π′ obtained by removing all the cy-
cles of π is also in J〈ι, γ〉KS, and that π(0) = π′(0) and π(|π|) = π′(|π′|). By construction,
we also have |π′| ≤ |S |.
We make a proof for each on the three operators OR, SAND, and AND.
– Let π ∈ JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Then, there exists an i ∈ [1, n], such that π ∈
J〈ιi, γi〉KS. We apply Remark 1 to construct a path π′ with π(0) = π′(0), π(|π|) =
π′(|π′|), and |π′| ≤ |S | ∈ O((2n − 1) |S |).
– Let π ∈ JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Then, there exists a concatenation π =
π1.π2. . . . .πn, such that πi ∈ J〈ιi, γi〉KS, for all i ∈ [1, n]. By Remark 1, we can build
n elementary paths π′i each of them being an element of J〈ιi, γi〉KS preserving the
extremal states of their corresponding πi. The concatenation π′ = π′1π
′
2 . . . π
′
n is well
defined, and belongs to JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Since for each i,
∣∣∣π′i ∣∣∣ ≤ |S|,
we have |π′| ≤ n |S| ∈ O((2n − 1) |S |). Also note that π(0) = π1(0) = π′1(0) = π′(0)
and π(|π|) = πn(|πn|) = π′n(
∣∣∣π′n∣∣∣) = π′(|π′|).
– Let π ∈ JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Then, there exist the anchoring intervals
[k1, l1], . . . , [kn, ln] of a parallel decomposition of π, such that, for each 1 ≤ i ≤ n,
π(ki) ∈ λ(ιi) and π(li) ∈ λ(γi).
We let m1 ≤ m2 ≤ . . . ≤ m2n be the result of sorting the elements k1, l1, . . . , kn, ln.
Note that necessarily m1 = 0 and m2n = |π|, and that π equals to the concatenation
π[m1,m2].π[m2,m3]. . . . π[m2n−1,m2n]. For 1 ≤ r ≤ 2n − 1, let ρr be the elementary
path obtained from π[mr,mr+1] by removing all cycles (we may have get a single
state if π[mr,mr+1] was a cycle, so that |ρr | = 0).
Clearly, the concatenation π′ = ρ1 . . . ρ2n−1 is well-defined and |π′| ≤ (2n − 1) |S|,
since each ρr is of the size at most |S|. Also, by construction, we have π′(0) =
ρ1(0) = π(0) and π′(|π′|) = ρ2n−1(|ρ2n−1|) = π(|π|).
It remains to be proven that π′ ∈ JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS.
Note that, for all i ∈ [1, n], the states π(ki) and π(li) also occur in π′, at positions we
now characterize.
Let m′1 ≤ . . . ≤ m′2n be the positions in π′ defined by m′1 = 0 and m′r+1 = m′r + |ρr |,
for r ∈ [1, 2n− 1]. Note that π′(m′r) = π(mr) and that m′2n = |π′|. Also, if mr = mr+1,
then |ρr | = 0, so that m′r = m′r+1. This implies in particular that
if m′r < m
′
r+1, then mr < mr+1. (*)
Let k′i = m
′
r (resp. l
′
i = m
′
r) whenever ki = mr (resp. li = mr). Notice that k
′
i ≤ l′i ,
because ki ≤ li.
By construction, each factor π′i = π
′[k′i , l
′
i] ∈ J〈ιi, γi〉KS.
We finish the proof by showing that the intervals [k′1, l
′
1], . . . , [k
′
n, l
′
n] are the an-
chorings of a parallel decomposition of π′. This amounts to showing that, for any
[ j, j + 1] ⊆ [0, |π′|], there exists an i, such that [ j, j + 1] ⊆ [k′i , l′i].
Let j ∈ [0, |π′| − 1], we define r( j) as the greatest r ∈ [1, 2n], such that m′r ≤ j (it
exists since m′1 = 0). Moreover, we have r( j) < 2n since m
′
r( j) ≤ j < |π′| = m′2n.
Therefore, r( j) + 1 ≤ 2n so that m′r( j)+1 is well-defined and is such that we have
[ j, j + 1] ⊆ [m′r( j),m′r( j)+1].
We establish that this non-trivial [m′r( j),m
′
r( j)+1], which contains [ j, j + 1], is con-
tained in some [k′i , l
′
i].
Clearly since m′r( j) < m
′
r( j)+1, we have mr( j) < mr( j)+1 (see the condition (*) above).
By the fact that π ∈ JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS, there exists i, st. [mr( j),mr( j) +1] ⊆
[ki, li].
Let t1 and t2 be such that ki = mt1 and li = mt2 . Note that we have mr( j)+1 ≤ li:
indeed, because mr( j) < li = mt2 , we necessarily have r( j) + 1 ≤ t2, which implies
mr( j)+1 ≤ mt2 = li. Now, since ki = mt1 ≤ mr( j) < mr( j)+1 ≤ mt2 = li, we have
t1 ≤ r( j) and r( j) + 1 ≤ t2, so that k′i = m′t1 ≤ m′r( j) < m′r( j)+1 ≤ m′t2 = l′i which
concludes. ut
Lemma 3. Let S be a transition system, ι1, γ1, . . . , ιn, γn be propositions in Prop, and
let π ∈ Π(S). Determining whether π ∈ JOP(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS can be done
in time O(|π| + n), if OP = SAND, and in time O(|π| n), if OP = AND.
Proof. It is easy to show that π ∈ JSAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS if, and only if
we have π(0) ∈ λ(ι1), π(|π|) ∈ λ(γn), and there exists a sequence of positions 0 ≤ k1 ≤
k2 ≤ . . . ≤ kn−1 ≤ |π|, with π(ki) ∈ λ(γi) ∩ λ(ιi+1). The algorithm checks these three
properties with a linear exploration of π. One can easily show that it requires at most
n + |π| − 1 steps.
We show an algorithm to check if π ∈ JAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS. The
algorithm first verifies in time polynomial in O(n |π|) that, for each i ∈ [1, n], there
exist ki, li ∈ [0, |π|], such that π(ki) ∈ λ(ιi), and π( j) ∈ λ(γi), and ki ≤ li. If not, the
algorithm rejects. Otherwise, we have π[ki, li] ∈ J〈ιi, γi〉KS, and we can tune the algo-
rithm with the same complexity so that position ki (resp. li) along path π is as small
(resp. big) as possible. In other words, the factors π[ki, li] of π are the longest ones
among those in J〈ιi, γi〉KS. Now, we show that π ∈ JAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS
if, and only if {π[k1, l1], . . . , π[kn, ln]} is a parallel decomposition of π for the anchorings
[k1, l1], . . . , [kn, ln].
Clearly, if {π[k1, l1], . . . , π[kn, ln]} is a parallel decomposition of π, then we have
π ∈ JAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS.
Conversely, suppose that π ∈ JAND(〈ι1, γ1〉, 〈ι2, γ2〉, . . . , 〈ιn, γn〉)KS. Let {π1, . . . , πn}
be a parallel decomposition of π, with πi ∈ J〈ιi, γi〉KS, for i ∈ [1, n], and let [k′1, l′1],
[k′2, l
′
2], . . . , [k
′
n, l
′
n] be the respective anchorings of π1, . . . , πn in π. By the definition of
the ki’s and the li’s, we necessarily have ki ≤ k′i ≤ l′i ≤ li. Also, as {π1, . . . , πn} is a paral-
lel decomposition of π, from Definition 3, every [ j, j+1] ⊆ [0, |π|] is contained in [k′i , l′i],
hence in [ki, li]. We conclude that {π[k1, l1], . . . , π[kn, ln]} is a parallel decomposition of
π for the anchorings [k1, l1], . . . , [kn, ln].
We conclude the proof of Lemma 3 by resorting on Lemma 1 to check in time
O(n |π|) if {π[k1, l1], . . . , π[kn, ln]} is a parallel decomposition of π for the respective
anchorings [k1, l1], . . . , [kn, ln]. ut
5.1 Checking Admissibility (column 1 of Table 1)
We now investigate the complexity of deciding the admissibility of an attack tree. We
first establish two propositions.
Proposition 1. Given a system S and ι1, γ1, . . . , ιn, γn ∈ Prop, deciding J〈ι, γ〉KS , ∅,
deciding JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅, and deciding JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ,
∅ are decision problems in P.
Proof.
1. Determining if J〈ι, γ〉KS is not empty amounts to performing a standard reachability
analysis in S, which can be done in polynomial time.
2. By the path semantics of the OR operator, JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅ if and
only if there is i ∈ [1, n], such that J〈ι j, γ j〉KS , ∅, which by the case 1 of this proof,
yields a polynomial time algorithm.
3. Checking that JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅ can be done by a forward analysis:
for 1 ≤ i ≤ n, we define a sequence of state sets S i by induction over i as follows:
we let S 1 = λ(ι1). Next, for 2 ≤ i < n, S i+1 = λ(ιi+1) ∩ λ(γi) ∩ Post∗S(S i). Clearly,
JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅ if, and only if S n , ∅. Moreover, computing S n
takes at most n |S | steps, since each S i+1 is computed from S i in at most |S | steps.
ut
On the contrary, it is more complex to deal with the AND operator.
Proposition 2. Given a system S and ι1, γ1, . . . , ιn, γn ∈ Prop, deciding the non-empti-
ness JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅ is NP-complete.
Proof.
NP-easy:
We can use the algorithm of Lemma 3, with the algorithm guessing a path of polynomial
size according to Lemma 2.
NP-hard:
We recall that a set of clauses C over a set of (propositional) variables {p1, . . . , pr} is
composed of elements (the clauses) C ∈ C such that C is a set of literals, that is either
a variable pi or its negation ¬pi. The set C is satisfiable if there exists a valuation
of the variables p1, . . . , pr that renders all the clauses of C true. The SAT problem is:
given a set of clauses C , to decide if it is satisfiable. It is well-known that SAT is an
NP-complete problem [7].
Now, let C = {C1, . . . ,Cm} be a set of clauses over variables {p1, . . . , pr} (ordered
by their index) that is an input of the SAT problem. Classically, we let |C | be the sum of
the sizes of all the clauses in C , where the size of a clause is the number of its literals.
s
p
¬p
q
¬q
r
¬r
start
C1,C2
C1
C2
Fig. 5: The system S{C1,C2} where C1 = p ∨ ¬q and C2 = p ∨ r.
In the following, we let the symbol `i denote either pi or ¬pi, for every i ∈ {1, . . . , r}.
We define the labeled transition system SC = (S C ,→C , λC ) over the set of proposi-
tions {start,C1, . . . ,Cm}, where start is a fresh proposition, as follows. The set of states
is S C =
⋃r
i=1{pi,¬pi} ∪ {s}, where s is a fresh state; the transition relation is →C =
{(`i, `i+1) | i ∈ [1, r − 1]} ∪ {(s, `1)}; and the labeling of states λC : {start,C1, . . . ,Cm} →
2S is such that λC (start) = {s} and λC (Ci) = {` ∈ Ci} for 1 ≤ i ≤ m. Note that, by
definition, |SC | is polynomial in |C |. For example, the transition system corresponding
to the set formed by clauses C1 = p ∨ ¬q and C2 = p ∨ r is depicted in Fig. 5.
It is then easy to establish that JAND(〈start,C1〉, 〈start,C2〉, . . . , 〈start,Cm〉)KSC , ∅
if, and only if C is satisfiable. ut
According to the formal definition of the statement “T is admissible w.r.t. S” as defined
in Sect. 4, it is easy to combine the results of Propositions 1 and 2, to conclude that
verifying that a tree is admissible is an NP-complete problem.
5.2 Checking the Meet property (column 2 of Table 1)
Preliminaries on temporal logic. We consider a syntactic fragment of the temporal logic
CTL [6] where the only temporal operator is “eventually”, here denoted by symbol
3, and where Boolean operators are conjunction and disjunction. The syntax of the
formulas is ϕ F p | ϕ ∧ ϕ | ϕ ∨ ϕ | 3ϕ. The semantics of formulas is given with
regard to a labeled transition system S = (S ,→, λ): each formula ϕ denotes a subset of
states, which we note [ϕ]S, and which is defined by induction: [p]S = λ(p), [ϕ∧ϕ′]S =
[ϕ]S ∩ [ϕ′]S, [ϕ∨ ϕ′]S = [ϕ]S ∪ [ϕ′]S, and [3ϕ]S = Pre∗S([ϕ]S), where Pre∗S is defined
in Sect. 3.1. Recall that s ∈ [3ϕ]S if, and only if, there is a path in S starting from s
and that reaches a state in [ϕ]S. It is well-established that computing [ϕ]S can be done
in polynomial time in |S| and |ϕ| (see for example [28]).
We now turn to the complexity of verifying the Meet property.
Proposition 3. Given a system S and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop, the problem of de-
ciding JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅, and the problem of deciding
JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅ are in P.
Proof.
1. Let ϕOR :=
n∨
i=1
ι∧ιi∧3(γ∧γi). We claim that JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS∩J〈ι, γ〉KS ,
∅ iff [ϕOR]S , ∅. We easily conclude our proof from the claim and the fact that
computing [ϕOR]S can be done in polynomial time. We now turn to the proof of the
claim. Assume that JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅, and pick some path
π ∈ JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS. Then, π goes from ι to γ and π also goes
from ιi to γi, for some i ∈ [1, n]. By the semantics of the temporal operators, the
state π(0) is in [ι∧ ιi ∧3(γ ∧ γi)]S, entailing [ϕOR]S , ∅. Conversely, if [ϕOR]S , ∅,
then pick some s ∈ [ϕOR]S. By definition of ϕOR, there must exist an i ∈ [1, n],
such that s ∈ [ι ∧ ιi ∧ 3(γ ∧ γi)]S, entailing the existence of some path from s, in
λ(ι)∩ λ(ιi), to some state in λ(γ)∩ λ(γi). Clearly, π ∈ J〈ιi, γi〉KS ∩ J〈ι, γ〉KS which is
a subset of JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS.
2. Let ϕSAND := ι ∧ ι1 ∧3(γ1 ∧ ι2 ∧3(γ2 ∧ . . .3(γn ∧ γ))). We claim that
JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅ iff [ϕSAND]S , ∅. We easily conclude
our proof from the claim and the fact that computing [ϕSAND]S can be done in poly-
nomial time. It remains to prove the claim. Assume JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS∩
J〈ι, γ〉KS , ∅, and pick some path π ∈ JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS.
Then, π goes from ι to γ and it is a concatenation of n paths πi going from ιi to γi.
Hence, π successively visits ι ∧ ι1, γ1 ∧ ι2, . . . , and γn ∧ γ. So π ∈ [ϕSAND]S. Con-
versely, if [ϕSAND]S , ∅, then let us pick a state s ∈ [ϕSAND]S. By the semantics of the
temporal operator this shows the existence of a path π starting from s, which visits
a sequence of n states respectively in λ(ι)∩ λ(ι1), λ(γ1)∩ λ(ι2), . . . , λ(γn−1)∩ λ(ιn),
and λ(γn) ∩ λ(γ). Therefore, π ∈ JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS, which
concludes. ut
Again, the AND operator turns out to be intrinsically more complex to deal with.
Proposition 4. Given a system S and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop, deciding
JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅ is an NP-complete problem.
Proof.
NP-easy:
We describe a non-deterministic polynomial time algorithm. This algorithm guesses a
path π ∈ Π(S), of polynomial size in |S| and n (this is justified by Lemma 2), and checks
whether π ∈ JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS, which can be done in polynomial time in the
size of π, which is also in polynomial time in |S| and n by the choice of π (see Lemma 3).
NP-hard:
We now show that deciding JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ∩ J〈ι, γ〉KS , ∅ is NP-hard, by
reducing the problem of deciding JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅. Recall that the latter
is an NP-hard problem (Proposition 2).
Let S be a transition system, and let ι1, γ1, . . . , ιn, γn ∈ Prop. Consider two fresh
propositions, ι and γ, and define the system S′ = (S ,→, λ′) which is like S and such
that all the states are labeled by both ι and γ, that is λ′(ι) = λ′(γ) = S . Notice that |S′|
is polynomial in |S|.
It is then very easy to establish that JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS
′ ∩ J〈ι, γ〉KS′ if, and
only if, JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅, and this concludes the proof. ut
As a consequence of Propositions 3 and 4, it is NP-complete to verify that an attack
tree has the Meet property, but if we restrict to attack trees that contain only OR or SAND
operators, the problem becomes P.
5.3 Checking the Under-Match property (column 3 of Table 1)
The OR and SAND operators do not pose any problem.
Proposition 5. Given a system S and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop, deciding
JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆ J〈ι, γ〉KS, and deciding JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆
J〈ι, γ〉KS are decision problems in P.
Proof.
Case for OR:
Let S be a transition system and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop. By the path semantics of
the OR operator, checking the Under-Match property amounts to deciding⋃
i∈[1,n]
J〈ιi, γi〉KS ⊆ J〈ι, γ〉KS. (1)
We consider an algorithm that checks that for all i ∈ [1, n] the following holds
λ(ιi) ∩ Pre∗S(λ(γi)) ⊆ λ(ι) (2)
λ(γi) ∩ Post∗S(λ(ιi)) ⊆ λ(γ). (3)
It accepts the input S, ι, γ, ι1, γ1, . . . , ιn, γn if this is the case, and rejects it otherwise.
Notice that the computation of the set λ(ιi) ∩ Pre∗S(λ(γi)) and λ(γi) ∩ Post∗S(λ(ιi))
requires only polynomial time in |S| and so does the checking of inclusions in equa-
tions (2) and (3).
At this point, the termination of our algorithm is clear. Regarding its correctness,
it is enough to show that the conjunction of all equations (2) and (3) (for all i’s) is
equivalent to equation (1). The proof runs easily once one has noticed that the sets of
states λ(ιi)∩ Pre∗S(λ(γi)) and λ(γi)∩ Post∗S(λ(ιi)), for i ∈ [1, n], host the starting and the
ending points of all paths in J〈ιi, γi〉KS, respectively.
Case for SAND:
Claim: JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆ J〈ι, γ〉KS if, and only if [ϕSAND]S = ∅, where
ϕSAND := ¬ι ∧ ι1 ∧3(γ1 ∧ ι2 ∧ . . .3(γn))
∨
ι1 ∧3(γ1 ∧ ι2 ∧ . . .3(γn ∧ ¬γ)).
Assume JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS * J〈ι, γ〉KS. This is equivalent to saying that
there exists a path π which is the concatenation of paths π1, . . . , πn (where πi goes from
ιi to γi), but that does not go from ι to γ. The reader can easily deduce that necessarily
π(0) ∈ [ϕSAND]S, entailing [ϕSAND]S = ∅.
Conversely, let s ∈ [ϕSAND]S. By the semantics of [ϕSAND]S, one can easily verify that
there exists a path π starting from s and which is the concatenation of paths π1, . . . , πn
(where πi goes from ιi to γi) and such that either π does not start from ι, or π does not
end in γ.
Whichever latter case we are in, π is a witness that JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS is
not included in J〈ι, γ〉KS, which concludes. ut
As expected, the AND operator yields a more complex problem to solve.
Proposition 6. Given a system S and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop, deciding
JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆ J〈ι, γ〉KS is a co-NP-complete problem.
Proof. To prove the proposition, we explain how to reduce the problem of deciding
if JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS , ∅ (see Proposition 2), which is NP-hard, to the com-
plementary problem of deciding if JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊆ J〈ι, γ〉KS, which is to
decide the emptiness of JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS \ J〈ι, γ〉KS.
Let S be a transition system, and ι1, γ1, . . . , ιn, γn ∈ Prop. We let S′ be the transition
system S with two extra fresh propositions ι and γ that label none of the states.
It can easily be shown that JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS = ∅ if, and only if,
JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS
′ \ J〈ι, γ〉KS′ = ∅, which trivially holds since J〈ι, γ〉KS′ = ∅
by construction. ut
5.4 Checking the Over-Match property (column 4 of Table 1)
Again, the cases for the OR and AND operators are smooth, whereas the case of the AND
operator is more difficult.
Proposition 7. Given a system S and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop, deciding
JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊇ J〈ι, γ〉KS and deciding JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊇
J〈ι, γ〉KS are decision problems in P. On the contrary deciding
JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS ⊇ J〈ι, γ〉KS is a decision problem in co-NP.
Proof.
Case for OR:
Consider the following algorithm which aims at exhibiting a path in J〈ι, γ〉KS, going
from some state s to some state s′, and such that it is not in JOR(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS.
1: for all s ∈ λ(ι) do
2: R← Post∗S(s)
3: for all s′ ∈ R ∩ λ(γ) do
4: Witness← f alse
5: for all i ∈ [1, n] do
6: Witness← Witness ∨ (s ∈ λ(ιi) ∧ s′ ∈ λ(γi))
7: end for
8: if ¬Witness then return Reject
9: end if
10: end for
11: end for
12: return Accept
This algorithm clearly terminates. Also, it performs a polynomial amount of steps in
the size of S and n. Indeed, line 1 is executed at most |λ(ι)| ≤ |S | times, the computation
of R in line 2 takes polynomial time, line 3 is executed at most |λ(γ)| ≤ |S | times, and
line 5 is executed n times.
Moreover, one can easily see that the algorithm rejects if, and only if Witness eval-
uates to false because of some pair of connected states s and s′, entailing the existence
of a path in J〈ι, γ〉KS but not in any of the J〈ιi, γi〉KS’s.
Case for SAND:
Let S be a transition system, and ι, γ, ι1, γ1, . . . , ιn, γn ∈ Prop. We design an algorithm
based on the verification that J〈ι, γ〉KS \ JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS = ∅.
Note that, if π ∈ J〈ι, γ〉KS \ JSAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS, then either
1. π(0) ∈ λ(ι) \ λ(ι1), or
2. π(|π|) ∈ λ(γ) \ λ(γn), or
3. π(0) ∈ λ(ι)∩λ(ι1), π(|π|) ∈ λ(γ) but there is an 1 ≤ i ≤ n−1 such that no subsequence
of π visits the sets λ(γ1) ∩ λ(ι2), λ(γ2) ∩ λ(ι3), . . . , λ(γi) ∩ λ(ιi+1) in this order.
Notice that the existence of a path that satisfies condition 1 (resp.2) is equivalent
to Post∗S(λ(ι) \ λ(ι1)) ∩ λ(γ) , ∅ (resp. Pre∗S(λ(γ) \ λ(γn)) ∩ λ(ι) , ∅). These last two
non-emptiness properties can be verified in polynomial time in |S|, and this is what
our algorithm first checks. If one of the two non-emptiness properties holds, then the
algorithm rejects. Otherwise the algorithm proceeds by an iterated forward search to
exhibit a path satisfying condition 1, as follows:
For each i ∈ [1, n − 1], we denote by Inti (“intermediate states for i”) the set λ(γi)∩
λ(ιi+1). We now let (Si)i∈[1,n−1] be the transition systems that are the restrictions of S to
the set of states outside Inti, formally to the set S \ Inti.
We also define the sets of states Gi, for i ∈ [0, n − 1], by G0 = λ(ι) ∩ λ(ι1), and for
i ∈ [0, n − 2],
Gi+1 = (Gi ∪ PostS(Post∗Si+1 (Gi \ Inti+1))) ∩ Inti+1.
Intuitively, set Gi+1 is the set of states in S that can be reached by paths visiting a
state in Gi, thus in Inti, that end in Inti+1 and such that after their last state in Gi, theses
paths visit Inti+1 exactly once. This property is formally established by the following
lemma.
Lemma 4. Let i ∈ [0, n − 1], and s ∈ S . If s ∈ Gi, then there exsists a path π that goes
from G0 to s, and, if i ≥ 1 and |π| ≥ 1, π[0, |π| − 1] does not visit Int1, . . . , Inti in this
order.
Proof. We proceed by induction on i. The case for i = 0 is trivial, since π = s. Let i = 1
and s ∈ G1. Either s ∈ G0, then again π = s and we are done, or s < G0 and because
G1 = (G0∪PostS(Post∗S1 (G0 \ Int1)))∩ Int1, there exists a path π of size at least 1, from
G0 to s, such that π[0, |π| − 1] does not visit Int1, and we are done.
Let i > 1 and s ∈ Gi. If s ∈ Gi−1, then we conclude by induction hypothesis.
Otherwise s < Gi−1, therefore s ∈ PostS(Post∗Si (Gi−1). Thus, there exists a path π
′′
going from a state s′ ∈ Gi−1 to s, such that |π′′| ≤ 1, since s′ , s, and π′′[0, |π′′| − 1]
does not visit Inti.
Moreover, by induction hypothesis, there exists a path π′ that goes from G0 to s′ ∈
Gi−1, and if |π′| ≥ 1, π′[0, |π′| − 1] does not visit Int1, . . . , Inti−1 in this order. Let π =
π′.π′′, which goes from G0 to s. We conclude the proof by showing that π[0, |π| − 1]
does visit Int1, . . . , Inti in this order.
If |π′| ≥ 1, we know that π′[0, |π′| − 1] does not visit Int1, . . . , Inti−1 in this order,
which implies that π′[0, |π′| − 1] does not visit Int1, . . . , Inti in this order. Then, a visit
in π of sets Int1, . . . , Inti in this order would require to visit Inti in π′′ which cannot be
the case. ut
Now, for every i ∈ [1, n − 1], we let
Bi = Post∗Si (Gi−1 \ Inti) ∩ λ(γ).
Intuitively, a state s ∈ Bi is such that there is path from G0 to s, hence ending in
λ(γ), that visits all the G j’s, for j < i, in this order.
Lemma 5. There exists i ∈ [1, n − 1] such that Bi , ∅ iff there is a path that satisfies
condition (3).
Proof.
(⇒ )
Let i ∈ [1, n−1], such that Bi , ∅. By definition of Bi, there exists a path π′′ going from
a state s′ ∈ Gi−1 to s ∈ λ(γ) that does not visit Inti. Also, by Lemma 4, we have a path
π′ that goes from G0 to s′ ∈ Gi−1, such that, if i ≥ 1 and |π′| ≥ 1, π′[0, |π′| − 1] does
not visit Int1, . . . , Inti−1 in this order. So it is now easy to see that any sub-sequence of
states of π′.π′′ is either a sub-sequence of states of π′, or has its last state in π′′, so that
π′.π′′ satisfies condition 3, for i.
(⇐)
Let π be a path that satisfies condition 3. First, notice that if π does not visit Int1, then
B1 , ∅. Otherwise, there exists an i, such that π visits Int1, . . . , Inti in this order. Let i′
be the maximum of such i. We show that Bi′+1 , ∅.
For i ∈ [1, i′], we define j(i) ∈ [0, |π|] by induction over i: j(1) is the smallest j
such that π( j) ∈ Int1, and for i ∈ [2, i′], j(i) is the smallest j above j(i − 1) such that
π( j) ∈ Inti. One can verify by induction on i ∈ [1, i′] that j(i) is well defined and that
π( j(i)) ∈ Gi.
We conclude the proof of the lemma by noticing that by definition of i′, we have for
all i ≥ j(i′), π(i) < Inti′+1, so that π(|π|) ∈ Bi′+1. Hence Bi′+1 , ∅. ut
The algorithm iteratively computes in polynomial time the sets Gi and Bi and rejects
if one of the encountered Bi is empty. Otherwise the algorithm accepts.
Case for AND:
We exhibit a non-deterministic polynomial time algorithm to decide whether or not
AND(〈ι1, γ1〉, . . . , 〈ιn, γn〉) + 〈ι, γ〉.
The algorithm guesses a path π ∈ J〈ι, γ〉KS\JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Such a path
can be chosen cycle-free, since removing all its cycles still makes the resulting path an
element of J〈ι, γ〉KS, but cannot make it an element of JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS. Then
the algorithm checks that π(0) ∈ λ(ι) and π(|π|) ∈ λ(γ). Finally, the algorithm uses the
polynomial algorithm of Lemma 3 to answer whether π < JAND(〈ι1, γ1〉, . . . , 〈ιn, γn〉)KS.
ut
Finally, we can get an upper bound for column 5 of Table 1 (the Match property)
by taking the maximum between upper bound complexities for Under-Match and Over-
Match, which achieves the filling of Table 1.
6 Conclusion and future work
In this work, we have developed and studied a formal setting to assist experts in the
design of attack trees when a particular system is considered. The system is described
by a finite transition system that reflects its dynamics and whose finite paths (sequences
of states) denote attack scenarios. The attack tree nodes are labeled with pairs 〈ι, γ〉
expressing the attacker’s goals in terms of pre and postconditions. The semantics of
attack trees is based on sets of finite paths in the transition system. Such sets of paths can
be characterized as a mere reachability condition of the form “all paths from condition ι
to condition γ”, or by a combination of those by means of OR, AND, and SAND operators.
We have exhibited the Admissibility property which allows us to check whether it
makes sense to analyze a given attack tree in the context of a considered system. We
then propose four natural correctness properties on top of Admissibility, namely
– Meet – the node’s refinement makes sense in a given system;
– Under (resp. Over) Match – the node’s refinement under-approximates (resp. over-
approximates) the goal of the node in a given system; and
– Match – the node’s refinement expresses exactly the node’s goal in a given system.
While analyzing an attack tree with respect to a system, we propose to start by
checking whether each of its subtrees satisfies the Meet property – this is the minimum
that we require from a correct attack tree. If this is the case, we can then check how
well the tree refines the main attacker’s goal, using (Under- and Over-) Matching. Our
study reveals that the highest complexity in such analysis is due to conjunctive refine-
ments (i.e., the AND operator), as opposed to disjunctive and sequential refinements, cf.
Table 1. The reason is that the semantics that we use in our framework relies on paths
in a transition system and thus modeling and verification for paths’ concatenation (used
to formalize the SAND refinements) is much simpler than those for parallel decomposi-
tion (used to formalize the AND refinements). Indeed, the latter requires to analyze the
combinatorics of paths representing children of a conjunctively refined node.
The framework presented in this paper offers numerous possibilities for practical
applications in industrial setting. First, it can be used to estimate the quality of a refine-
ment of an attack goal, that an expert could borrow from an attack pattern library. The
correctness properties introduced in this work allow us to evaluate the relevance of often
generic refinements in the context of a given system. Second, classical attack trees use
text-based nodes that represent a desired configuration to be reached (our postcondition
γ) without specifying the initial configuration (our precondition ι) where the attack will
start from. Given a transition system S describing a real system to be analyzed, the text-
based goals can be straightforwardly translated into formal propositions expressing the
final configurations (i.e., γ) to be reached by the attacker. The expert may also specify
the initial configurations (i.e., ι), but if he does not do so, they can be automatically
generated from the transition system, by simply taking all states belonging to the set
Pre∗S(λ(γ)) of predecessors of λ(γ) in S.
For pedagogical reasons, we have focused on simple atomic goals (i.e., node labels)
that are definable in terms of a precondition and a postcondition. As one of the future
directions, we would like to enrich the language of atomic goals, for instance by adding
variables with history or invariants. Variables with history can be used to express proper-
ties such as "Once detected, the attacker will always stay detected". With invariants, we
may add constraints to the goals, as in "Reach Room2 undetected without ever crossing
Room1". If invariants are added to atomic goals, for instance using LTL formulas, the
complexity of some problems presented in this paper may increase. In that case, check-
ing that a path satisfies the semantics of a node might no longer be done in constant time,
but in polynomial time, or even in PSPACE-complete, if arbitrary LTL formulas are al-
lowed [8]. It would then be relevant to study the interplay between the expressiveness
of the atomic goals and the complexity of verifying these correctness properties.
It would also be interesting to extend our framework to capture more complex prop-
erties than those defined in Definition 5. Pragmatic examples of such properties would
be validities and tests expressed in an adequate logic. Validities would be formulas that
are true in any system. An example of a validity would look like AND(〈ι, γ〉, 〈ι′, γ′〉) w
SAND(〈ι, γ〉, 〈ι′, γ′〉), with the meaning that a sequential composition is a particular case
of parallel composition. Tests would be formulas which might be true in some sys-
tems, but not necessarily in all cases. For instance, a formula like AND(〈ι, γ〉, 〈ι′, γ′〉) v
SAND(〈ι, γ〉, 〈ι′, γ′〉) would mean that, in a given system, it is impossible to realize both
〈ι, γ〉 and 〈ι′, γ′〉 otherwise than sequentially in this particular order.
Finally, we are currently working on integrating the framework developed in this
work to the ATSyRA tool. The ultimate goal is to design software for generation of
attack trees satisfying the correctness properties that we have introduced. The short-
term objective is to validate the practicality of the proposed framework and its usability
with respect to the complexity results that we have proven in this work.
References
1. Aslanyan, Z., Nielson, F.: Pareto efficient solutions of attack-defence trees. In: POST. LNCS,
vol. 9036, pp. 95–114. Springer (2015)
2. Aslanyan, Z., Nielson, F.: Model checking exact cost for attack scenarios. In: International
Conference on Principles of Security and Trust. Springer (2017)
3. Audinot, M., Pinchinat, S.: On the Soundness of Attack Trees. In: Graphical Models for
Security. LNCS, vol. 9987, pp. 25–38. Springer (2016)
4. Audinot, M., Pinchinat, S., Kordy, B.: Is my attack tree correct? In: ESORICS. LNCS,
Springer (2017), (to appear)
5. Audinot, M., Pinchinat, S., Kordy, B.: Is my attack tree correct? (extended version). CoRR
abs/1706.08507 (2017), http://arxiv.org/abs/1706.08507
6. Clarke, E.M., Emerson, E.A.: Design and synthesis of synchronization skeletons using
branching time temporal logic. In: Workshop on Logic of Programs. pp. 52–71. Springer
(1981)
7. Cook, S.A.: The complexity of theorem-proving procedures. In: Proceedings of the third
annual ACM symposium on Theory of computing. pp. 151–158. ACM (1971)
8. De Giacomo, G., Vardi, M.Y.: Linear temporal logic and linear dynamic logic on finite traces.
In: IJCAI’13 Proceedings of the Twenty-Third international joint conference on Artificial
Intelligence. pp. 854–860. Association for Computing Machinery (2013)
9. Gadyatskaya, O., Hansen, R.R., Larsen, K.G., Legay, A., Olesen, M.C., Poulsen, D.B.: Mod-
elling attack–defense trees using timed automata. In: FORMATS. LNCS, vol. 9884, pp. 35–
50. Springer (2016)
10. Garey, M.R., Johnson, D.S.: Computers and intractability, vol. 29. W. H. Freeman and Com-
pany (2002)
11. Horne, R., Mauw, S., Tiu, A.: Semantics for specialising attack trees based on linear logic.
Fundam. Inform. 153(1-2), 57–86 (2017)
12. Ivanova, M.G., Probst, C.W., Hansen, R.R., Kammüller, F.: Transforming Graphical System
Models to Graphical Attack Models. In: Graphical Models for Security. LNCS, vol. 9390,
pp. 82–96. Springer (2015)
13. Jhawar, R., Kordy, B., Mauw, S., Radomirović, S., Trujillo-Rasua, R.: Attack Trees with
Sequential Conjunction. In: SEC. IFIP AICT, vol. 455, pp. 339–353. Springer (2015)
14. Jürgenson, A., Willemson, J.: Serial Model for Attack Tree Computations. In: ICISC. LNCS,
vol. 5984, pp. 118–128. Springer (2009)
15. Kordy, B., Mauw, S., Radomirovic, S., Schweitzer, P.: Attack–defense trees. J. Log. Comput.
24(1), 55–87 (2014)
16. Kordy, B., Piètre-Cambacédès, L., Schweitzer, P.: Dag-based attack and defense modeling:
Don’t miss the forest for the attack trees. Computer Science Review 13-14, 1–38 (2014)
17. Kordy, B., Pouly, M., Schweitzer, P.: Probabilistic reasoning with graphical security models.
Inf. Sci. 342, 111–131 (2016)
18. Kumar, R., Ruijters, E., Stoelinga, M.: Quantitative attack tree analysis via priced timed
automata. In: FORMATS. LNCS, vol. 9268, pp. 156–171. Springer (2015)
19. Leyton-Brown, K., Hoos, H.H., Hutter, F., Xu, L.: Understanding the empirical hardness of
NP-complete problems. Communications of the ACM 57(5), 98–107 (2014)
20. Mauw, S., Oostdijk, M.: Foundations of Attack Trees. In: ICISC. LNCS, vol. 3935, pp. 186–
198. Springer (2005)
21. OWASP: CISO AppSec Guide: Criteria for managing application security risks (2013)
22. Phillips, C.A., Swiler, L.P.: A graph-based system for network-vulnerability analysis. In:
Workshop on New Security Paradigms. pp. 71–79. ACM (1998)
23. Pieters, W., Padget, J., Dechesne, F., Dignum, V., Aldewereld, H.: Effectiveness of qualitative
and quantitative security obligations. J. Inf. Sec. Appl. 22, 3–16 (2015)
24. Pinchinat, S., Acher, M., Vojtisek, D.: ATSyRa: An Integrated Environment for Synthesizing
Attack Trees – (Tool Paper). In: Graphical Models for Security. LNCS, vol. 9390, pp. 97–
101. Springer (2015)
25. Research, N., (RTO), T.O.: Improving Common Security Risk Analysis. Tech. Rep.
AC/323(ISP-049)TP/193, North Atlantic Treaty Organisation, University of California,
Berkeley (2008)
26. Roy, A., Kim, D.S., Trivedi, K.S.: Attack countermeasure trees (ACT): towards unifying the
constructs of attack and defense trees. Security and Communication Networks 5(8), 929–943
(2012)
27. Schneier, B.: Attack Trees: Modeling Security Threats. Dr. Dobb’s Journal of Software Tools
24(12), 21–29 (1999)
28. Schnoebelen, P.: The complexity of temporal logic model checking. Advances in modal logic
4(393-436), 35 (2002)
29. Sheyner, O., Haines, J.W., Jha, S., Lippmann, R., Wing, J.M.: Automated Generation and
Analysis of Attack Graphs. In: IEEE S&P. pp. 273–284. IEEE Computer Society (2002)
30. Thierry-Mieg, Y.: Symbolic model-checking using its-tools. In: TACAS. LNCS, vol. 9035,
pp. 231–237. Springer (2015)
31. Vigo, R., Nielson, F., Nielson, H.R.: Automated Generation of Attack Trees. In: CSF. pp.
337–350. IEEE Computer Society (2014)

