Vol. 6, No. 9, Special Issue: TOOLS EUROPE 2007, October 2007
Reflecting on an Existing Programming
Language
Andreas Leitner, Dept. of Computer Science, ETH Zurich, Switzerland
Patrick Eugster, Dept. of Computer Science, Purdue University, USA
Manuel Oriol, Dept. of Computer Science, ETH Zurich, Switzerland
Ilinca Ciupa, Dept. of Computer Science, ETH Zurich, Switzerland
Reflection has proven to be a valuable asset for programming languages, es-
pecially object-oriented ones, by promoting adaptability and extensibility of pro-
grams. With more and more applications exceeding the boundary of a single
address space, reflection comes in very handy for instance for performing con-
formance tests dynamically.
The precise incentives and thus mechanisms for reflection vary strongly between
its incarnations, depending on the semantics of the considered programming lan-
guage, the architecture of its runtime environment, safety and security concerns,
etc. Another strongly influential factor is legacy, i.e., the point in time at which the
corresponding reflection mechanisms are added to the language. This parameter
tends to dictate the feasible breadth of the features offered by an implementation
of reflection.
This paper describes a pragmatic approach to reflection, consisting in adding
introspection to an existing object-oriented programming language a posteriori,
i.e., without extending the programming language, compiler, or runtime environ-
ment in any specific manner. The approach consists in a pre-compiler generating
specific code for types which are to be made introspectable, and an API through
which this code is accessed.
We present two variants of our approach, namely a homogeneous approach (for
type systems with a universal root type) and a heterogeneous approach (without
universal root type), and the corresponding generators. We discuss limitations
such as infinite recursion, and compare the code generated with these two ap-
proaches by Erl-G, a reflection library generator for the Eiffel programming lan-
guage, thereby quantifying the benefits of a universal root type. Erl-G is being
used by several tools for development in Eiffel.
1 INTRODUCTION
Reflection [15] has made its way into many programming languages in one form or an-
other. By enabling the reification of the structure of a program and its abstract data types,
structural reflection enables the program to reason about the very data it manipulates. In-
trospection is a subset of structural reflection focusing mainly on representing the runtime
structure of a program without supporting its alteration. Behavioral reflection consists in
Cite this document as follows: Cite this document as follows: Andreas Leitner, Patrick
Eugster, Manuel Oriol, Ilinca Ciupa: “Reflecting on an Existing Programming Language”,
in Journal of Object Technology, vol. 6, no. 9, Special Issue: TOOLS EUROPE 2007,
October 2007, pages 319-339, http://www.jot.fm/issues/issues 2007 10/paper16
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
reifying the very programming language semantics and the data used to execute a pro-
gram, thus providing the possibility to manipulate operational semantics at runtime. Dy-
namic invocations are a subset of behavioral reflection that allows to invoke code based
on the results given by structural reflection.
In the realm of object-oriented programming languages, reflection has become espe-
cially popular, as it further supports adaptability and extensibility of programs, two of
the inherent driving forces behind the object paradigm. With many distinguished charac-
teristics of a given application translating to the creation of differential object types and
subtypes, and more and more applications exceeding the boundary of a single address
space, introspection comes in very handy for performing conformance tests dynamically,
and hence for mediating between different type domains. Furthermore, introspection and
dynamic invocations allow a program to adapt its behavior dynamically, depending on
its internal state or on external stimuli, thus circumventing some of the limits present in
statically typed languages.
The incentives and thus mechanisms for reflection vary strongly between its incarna-
tions, depending on the semantics of the considered programming language, the architec-
ture of the runtime environment, safety and security concerns, etc. Another strongly in-
fluential factor is legacy, i.e., the point at which the corresponding reflection mechanisms
are added to the language. In the dynamically typed Smalltalk language [10], (structural)
reflection appeared from the start as an integral part of the computation model, going as
deep as affecting the very language foundations — more precisely the message dispatch-
ing mechanism — by providing each object with a “default method” (doesNotUnderstand)
executed in the absence of a more specific method able of handling a given invocation.
In Java [11], introspection was added gradually with hooks into the virtual machine and
only a limited flavor of behavioral reflection eventually appeared, without any support
from the runtime environment, in the form of dynamic proxies [25]. In the AspectJ [16]
extension of Java, the interface to behavioral reflection mechanisms (the “meta-object-
protocol”) has even made its way into the language syntax alike in 3-Lisp (level-shifting
processor) [8]. The new viewpoint offered thereby on program design and development
has even culminated in the coining of a term denoting an intriguing new development
methodology – “aspect-oriented software development”.
In this paper we describe a more pragmatic approach to reflection, consisting in adding
introspection to an existing object-oriented programming language a posteriori and with-
out extending the programming language, compiler, or runtime environment in any spe-
cific manner. To that end, we introduce (1) a concise API for programmers to use, and (2)
a pre-compiler which generates code for the introspectable types. This approach yields
the clear benefit of dealing inherently with the legacy factor, and supporting the use of
different compilers and runtime environments. We illustrate this approach through Erl-
G [17], a pre-compiler generating introspection code for the Eiffel language [21]. Broadly
speaking, Erl-G generates meta-classes akin to those found in Smalltalk’71 [23] for Eiffel
classes. Erl-G makes it possible to introspect programs written in the Eiffel programming
language, spanning many of the language constructs in a simple and uniform way, regard-
less of the compiler (ISE, SmartEiffel, etc.) or runtime environment (standard, .NET, etc.)
320 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
2 REFLECTION GENERATION
at hand.
We first introduce an abstract core language which we use to show the semantics
of two reflection code generation methods. The first, heterogeneous approach does not
require the existence of a universal root type (i.e., a type without super-type to which all
types in the system conform), whereas the second, more efficient, homogeneous approach
does rely on the presence of such a type. Introspection is accessible through a generic API,
whereby programs become entirely detached from the introspection code itself, removing
any explicit dependencies between programs using introspection and the generated code.1
We then illustrate through the Eiffel programming language how this simple language can
be mapped to a concrete one. We present the full functionalities of an implementation of
our approach in Eiffel, going by the name of Erl-G.
We discuss general and Eiffel-specific intricacies and limitations, and how to mitigate
these. For instance, we show how generic types can lead to infinite recursion and thus to
an infinite number of meta-classes being generated in the absence of a universal root type;
we also show what is the minimal support our approach requires from a programming
language, and how the case of Eiffel allows for introspection over generic arguments,
a lack in the recent addition of generics to Java which has made the subject of many
discussions.
Last but not least, we show experimental results quantifying the benefits of a universal
root type, by illustrating the significant decrease (averaging around an order of magnitude)
achieved in the number of generated meta-classes and in system compilation time when
introducing such a type.
Roadmap. Section 2 presents the semantics of our generation approaches based on a
simple abstract language. Section 3 illustrates how our approach can be mapped to a con-
crete programming language, by using Eiffel as an example. Section 4 then explains how
the generation approaches have been implemented in the Erl-G tool. Section 5 evaluates
our implementation on several real world programs in terms of efficiency, and discusses
the applicability of our approach. Section 6 discusses some of the benefits of the reflec-
tion capabilities offered by Erl-G by presenting examples of development tools that rely
on it. Finally, Section 8 draws conclusions.
2 REFLECTION GENERATION
Reflection offers a program the ability to query and/or modify its state and execution, as
well as change the semantics and implementation of the programming language that it is
written in. The two fundamental, complementary, aspects of full reflection are apparent
from this definition: structural reflection allows a program to inspect and modify its own
state as it would do with any other data that it manipulates; behavioral reflection allows
1In this sense, this generic API is similar to the interfaces of remote objects in Java RMI implemented
by proxies generated by the rmic pre-compiler, and only required at runtime.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 321
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
a program to modify its code, as well as the very semantics and execution model of
its source programming language. Both these levels of reflection require a process by
which execution state is represented and made available to the program as ordinary data;
this process is called reification. While the latter type of reflection has been devoted
much attention in the past (see Section 7), we focus in this paper on the former type of
reflection, more widely encountered in some form or another, yet still lacking support in
many languages.
Approach Overview. As mentioned, many languages have been initially devised with-
out support for reflection. In this paper we deal with the more compelling case where
a considered language is to be added reflective abilities, but should not change in any
way. As a consequence, the approach we propose is based on the generation of a set of
meta-classes which represent the structure and state of the program to be reflected upon.
These classes embody the necessary reification structure and make up a reflection library.
Programs access these reflective features through the use of a regular library. Its API
(described in detail in Section 3) offers the most common facilities needed for structural
reflection: retrieving a class by its name, creating new objects, calling a method, get-
ting the value of an attribute, etc. Note that this API so far is not biased by any feature
characteristic to any one particular programming language; rather, it allows for a set of
operations that are required for structural reflection in a large family of object-oriented
programming languages. The implementation of this API is then achieved through dif-
ferent means depending on the possibilities of the target language, and the API’s precise
semantics is obviously guided by the semantics of the target programming language.
A Simple Language. Figure 1 shows the syntax of a very simple abstract language on
which the transformations are defined. The supported features are inspired by the Eiffel
language, which is targeted by our main implementation. In particular, the proposed core
language includes multiple subtyping through multiple inheritance and generics, a feature
present already early in Eiffel, and which nowadays enjoys various levels of support in
many mainstream languages.
〈V, W, ...〉 represents a declaration which involves different literals V , W , etc. The
notation dX1, ..., Xnc denotes a list made of literals X1,...,Xn. The ⊕ operator denotes
list concatenation. Y ∗ denotes zero or more literals Y . Y + denotes one or more literals Y .
For example, a class is defined by a name and optional sets of (1) generic arguments, (2)
super types, (3) constructors, (4) fields, and (5) methods respectively. A type is defined by
a class (its so-called base class, see Section 3), and actual types for all generic arguments.
In other terms, a type is defined by a class, in which all generics have (recursively) been
linked to types. A class with “open” generic arguments gives rise to a family of types but
does not define a type by itself.
Traditionally names are considered to belong to different subsets of the names set
depending on the way they are used. This differentiation is however not relevant for the
scope of this paper and subsequently ignored. Note however that names can be handled
as expressions, by applying the ID() operator. The result can be viewed as a reification
322 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
2 REFLECTION GENERATION
names N ::= v | g | m | cl; ID(N) ∈ TNAME
application A ::= 〈dCL+c, create T.c(Void)〉
class CL ::= 〈cl, dG∗c, dT ∗c, dC∗c, dF ∗c, dM∗c〉
generic G ::= 〈g, T〉 | 〈g,⊥〉
attribute F ::= 〈V, E〉
variable V ::= 〈v, T〉 | 〈v, g〉
type T ::= 〈cl, dT ∗c〉
constructor C ::= 〈c, dV ∗c, E〉
method M ::= 〈m, dV ∗c, T, E〉 | 〈m, dV ∗c,⊥, E〉
| 〈m, dV ∗c, g, E〉
expression E ::= v | E.m(dE∗c) | ID(N) | v := E in E
| if E then E else E | ⊥ | Current
| create T.c(dE∗c) | E==E | Error
| E.v
Figure 1: Abstract language
of the name of some method or field, rather than its evaluation, and reflects the first-class
character strings found in many object-oriented programming languages.
The actual type system is not considered in detail at this point. A class can have several
super-classes, and a formal generic argument can optionally involve a bound. Any given
type system adds restrictions to the generation of meta-classes outlined in the following
paragraphs. The only distinction we make subsequently is between (1) a heterogeneous
and (2) a homogeneous approach. In the former case, we assume that there is no global
super-type to which everything conforms (akin to Ada’95, C++, Eiffel prior to becoming
an ECMA standard), and thus generate a meta-class for each type. In the presence of a
universal root type (e.g., Java modulo primitive types, Oberon, now also ECMA Eiffel),
we assume the same meta-class can be used to introspect a family of types by creating a
meta-class per class to reflect only. Ramifications of these approaches are discussed in
Section 4.
Heterogeneous Approach. In the first case mentioned above a class is generated for
each type that should be made introspectable. Figure 2 shows the semantics of the gener-
ation process MT J·K for a given meta-class. The operator MT J·K has a single argument,
which is a type. The operator generates a class containing three methods, namely (1)
attr val, (2) inv meth, and (3) cre obj, which respectively fetch the values of a given at-
tribute, invoke a given method, and instantiate the class through a given constructor.
Figure 3 shows how to extend the application and enable reflection for a given set
of types. The principle consists in generating a new class for each base class that needs
reflection and to use the relevant types in the input.
Note that in this approach a meta-class is generated for each type to be made intro-
spectable. In the absence of classes with generic arguments, there is a one-to-one cor-
respondence between classes and types. In the presence of generic classes, each class
allows for the construction of (potentially infinitely - see Section 5) many types.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 323
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
MT J·K : T → CL
MT JT0K =
〈mc T0, ∅, ∅, c0, ∅, dMattr val, Minv meth, Mcre objc〉
where:
T0 = 〈CL0, ...〉; c0 = 〈make, ∅, ∅〉
CL0 =
〈cl0, dG1...Gnc, dT1...Tmc, dC1...Cpc, dF1...Fqc, dM1...Mrc〉
Ci=1..p = 〈ci, ...〉; Fi=1..q = 〈〈vi, ...〉, ...〉; Mi=1..r = 〈mi, ...〉
Mattr val =
〈attr val, d〈attr name, Tv〉, 〈targ, TANY 〉c, TV AR, Eattr〉
Eattr =
if ID(v1)==attr name then targ.v1 else
...
if ID(vn)==attr name then targ.vn else Error
Minv meth =
〈inv meth, d〈meth name, TNAME〉,
〈targ, TANY , 〈args, TLIST [ANY ]〉〉c, TV AR, Eproc〉
Eproc =
if ID(m1)==meth name then targ.m1(args1..n) else
...
if ID(mm)==meth name then targ.mm(args1..n) else Error
Mcre obj =
〈cre obj, d〈cons name, Tc〉, 〈args, TLIST [ANY ]〉c, TANY ,
Econs〉
Econs =
if ID(c1)==cons name then create T0.c1(args1..n) else
...
if ID(ck)==cons name then create T0.ck(args1..n) else Error
Figure 2: Semantics per type
Homogeneous Approach. In the homogeneous approach, a meta-class is generated for
each class that should be made introspectable. Figure 4 depicts the semantics of the
generation process MCJ·, ·K. As opposed to the operator MT J·K in the heterogeneous
approach, MCJ·, ·K takes two arguments: a (base) class and a set of derived types for that
class (a type is derived from a class iff the class is the base class of the given type). This
set contains the types for which instances should be creatable via reflection.
The operatorMCJ·, ·K generates a class containing three methods, namely (1) attr val,
(2) inv meth, and (3) cre obj. Just like in the case of MT J·K, these fetch the values
of attributes, invoke methods and create instances, respectively, as shown in Figure 4.
Similarly to the heterogeneous approach, Figure 5 shows how to extend an application
and enable reflection.
MT appJ·, ·K : A× TLIST [T] → A
MT appJA0, dT1, ..., TmcK =
〈dCL1, ..., CLn,MT JT1K, ...,MT JTmKc, create T1.c(Void)〉
where:
A0 = 〈dCL1, ..., CLnc, create T1.c(Void)〉
Figure 3: Per-type reflection library generation
324 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
3 THE CASE OF EIFFEL
FLJ·K : T → TLIST [TNAME ]
FLJT0K = dcl0c ⊕ FLJT1K⊕ ...⊕FLJTmK
where:
T0 = 〈〈cl0, ...〉, dT1, ..., Tmc〉
MCJ·, ·K : CL × TLIST [T] → CL
MCJCL0, {TCR(1), ..., TCR(t)}K =
〈mc CL0, ∅, ∅, c0, ∅, dMattr val, Minv meth, Mcre objc〉
where:
CL0 =
〈cl0, dG1...Gnc, dT1...Tmc, dC1...Cpc, dF1...Fqc, dM1...Mrc〉
c = 〈make, ∅, ∅〉; TCR(i=1..t) = 〈CL0, ...〉
Ci=1..p = 〈ci, ...〉; Fi=1..q = 〈〈vi, ...〉, ...〉; Mi=1..r = 〈mi, ...〉
Mattr val =
〈attr val, d〈attr name, Tv〉, 〈targ, TANY 〉c, TANY , Eattr〉
Eattr =
if ID(v1)==attr name then target.v1 else
...
if ID(vn)==attr name then target.vn else Error
Minv meth =
〈inv meth, d〈meth name, TNAME〉, 〈targ, TANY 〉,
〈args, TLIST [ANY ]〉c, TANY , Eproc〉
Eproc =
if ID(m1)==meth name then targ.m1(args1..n) else
...
if ID(mm)==meth name then targ.mm(args1..n) else Error
Mcre obj =
〈cre obj, {〈cons name, Tc〉, 〈args, TLIST [ANY ]〉,
〈flat type, TLIST [TNAME ]〉}, TANY , Econs〉
Econs =
if flat type==FLJTCR(1)K then
if ID(c1)==cons name then create TCR(1).c1(args1..n) else
...
if ID(ck)==cons name then create TCR(1).ck(args1..n) else
Error
...
else if flat type==FLJTCR(t)K then
if ID(c1)==cons name then create TCR(t).c1(args1..n) else
...
if ID(ck)==cons name then create TCR(t).ck(args1..n) else
Error
else Error
Figure 4: Semantics per class
3 THE CASE OF EIFFEL
To illustrate the general solution described in the previous section, we present here its im-
plementation in the case of the Eiffel language [19]. In a nutshell, Eiffel is purely object-
oriented, strongly typed, and supports dynamic binding, (dynamic) single dispatch, and
multiple inheritance. Eiffel makes for a very illustrative target language, since it innately
only provides minimal support for reflection. We first overview the Eiffel language along
with its type system, depicting how it impacts the implementation of the previously out-
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 325
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
MCappJ·, ·K : A× TLIST [T] → A
MCappJA0, dT1, ..., TmcK =
〈dCL1, ..., CLn,MCJCL1, dT1, ..., Tmc/cl1K, ...,
MCJCLn, dT1, ..., Tmc/clnKc, create T1.c(V oid)〉
where:
A0 = 〈dCL1, ..., CLnc, create T1.c(V oid)〉
CLi=1..m = 〈cli, ...〉
dT1, ..., Tmc/cl0 = dTj=1..m|Tj = 〈〈cl0, ...〉, ...〉c
Figure 5: Per-class reflection library generation
〈cl, dG∗c, dT∗c, C∗, dF∗c, dM∗c〉 =̂ class cl[G1, ..., Gm]
inherit
T1, ..., Tn
feature
C1, ..., Cp, F1, ..., Fq , M1, ..., Mr
end
〈g, T〉 =̂ g−> T
〈g,⊥〉 =̂ g
〈v, T〉 =̂ v : T
〈v, g〉 =̂ v : g
〈V, E〉 =̂ V is E
〈cl, dT∗c〉 =̂ cl[T1, ..., Tn]
〈c, dV ∗c, E〉 =̂ create c(V1, ..., Vn) is
do E end
〈m, dV ∗c, T, E〉 =̂ m(V1, ..., Vn): T is
do E end
〈m, dV ∗c, g, E〉 =̂ m(V1, ..., Vn): g is
do E end
〈m, dV ∗c,⊥, E〉 =̂ m(V1, ..., Vn) is
do E end
Figure 6: Simplified Eiffel language syntax
lined introspection mechanisms, and then look at the API of the generated Eiffel reflection
library.
The Eiffel Language. Figure 6 overviews the core of the Eiffel language syntax, as a
“mapping” from the abstract syntax presented in Figure 1. In the case of optional declara-
tions (enclosed in d...c in Figure 1), leading keywords (e.g., inherit ) are omitted in case of
absence of corresponding declarations. The same goes for separating symbols (e.g. “ ,”)
in case of multiple declarations. Note that the list from Figure 1 does not appear here, as
it is replaced by the generic LIST type.
Types. Informally, types in Eiffel are divided into three categories:
References: If an entity x is declared of type T and T is a reference type, then the value of
x will be a reference to an object or Void.
Expanded: If an entity x is declared of type T and T is an expanded type (also called value
type), then the value of x will be an object. The predefined expanded types (such as
INTEGER, REAL, DOUBLE, BOOLEAN, and CHARACTER) are so-called basic types, but other
326 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
3 THE CASE OF EIFFEL
expanded types can also be created by using the expanded keyword. The basic types are
implemented by library classes, but, for obvious reasons of efficiency, compilers will
implement operations on them directly through machine operations, not through method
calls.
Formal generics: In the case of generic classes (also called parameterized types), a formal
generic represents a type parameter to be provided in actual uses of the class. The Eiffel
genericity mechanism allows for both unconstrained and constrained (bounded) generic
parameters; constraints in the latter case are expressed by the −> operator. An example
would be the second parameter of class HASH TABLE [G, H −> HASHABLE]. Any type
that is a valid generic derivation of this class must have, as the second actual generic
parameter, a type that conforms to HASHABLE.
Every type is based on a class, which is called the type’s “base class”. The difference
between types and classes appears only in the case of generic classes: such classes do not
describe a type, but a family of types. To obtain a type from a generic class, one must
provide actual generic parameters. For instance, the class declared as LIST [G] only yields
a type when a type existing in the system, such as INTEGER, is substituted for G; hence,
LIST [INTEGER] is a type.
Subtyping. Subtyping in Eiffel is defined as follows. A type V is a subtype of a type T
if and only if both:
1. The base class of V is a descendant of the base class of T.
2. If V is generically derived, its actual generic parameters must subtype those of T’s
corresponding ones.
More detailed rules are described in an associated technical report [18].
Our first implementation of the meta-class generator for Eiffel was aimed at the pre-
ECMA version of the Eiffel language, in which expanded types do not conform to ANY. As
a consequence a meta-class had to be generated for every type, mandating the heteroge-
neous code generation. The introduction of a universal root type (in the ECMA standard)
significantly improved the performance of the meta-class generator, since it meant that
the generation of a meta-class for every type was no longer necessary: the generation of
a meta-class for every class was sufficient. In Section 5 we assess the two approaches in
more detail in terms of performance and limitations.
The Erl-G Library API. As stated in Section 2, the introspection-enabling code is
generated as a library of meta-classes. One such meta-class (inheriting from ERL CLASS)
is generated for each class that requires introspection abilities.
The meta-model of the reflection API is represented in Figure 7. The main com-
ponents of this simple meta-model are the classes ERL CLASS and ERL UNIVERSE. Class
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 327
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
ERL SHARED UNIVERSE implements the singleton design pattern, by ensuring that only
one instance of ERL UNIVERSE exists and providing the access point to it. ERL CLASS is the
abstract ancestor of all generated meta-classes for the classes that must be introspectable.
It provides the methods for creating a new instance, retrieving the value of an attribute,
and calling a method. For brevity, the arguments to these methods are omitted in Figure 7;
they are however visible in Listing 1. The implementation of each method can be thought
of as a big switch on the name of the constructor, attribute, or method, respectively. For
languages supporting overloading the switch must be extended to also cover the types of
the method arguments. Note that, since Eiffel does not support overloading, we did not
need to consider this issue in our implementation.
class ERL CLASS
feature
attribute value (name: STRING; target : ANY): ANY
invoke method (name: STRING; target : ANY; args: ARRAY [ANY]): ANY
create object (name: STRING; type: STRING; args: ARRAY [ANY]): ANY
end
class ERL TYPE
feature
attribute value (name: STRING; target : VARIANT): VARIANT
invoke method (name: STRING; target : VARIANT; args: ARRAY [VARIANT]): VARIANT
create object (name: STRING; args: ARRAY [VARIANT]): VARIANT
end
Listing 1: Interface of ERL CLASS and ERL TYPE
Class ERL UNIVERSE provides methods for retrieving a meta-class through the name
of its corresponding class and through an object that is an instance of this class.
It should also be noted that a very limited set of features related to reflection was
already present in the Eiffel language, through class INTERNAL. This class can check
whether an object is an instance of a given type, can obtain the class name and type name
for a given object, can verify type conformance, and can query and set the values of fields.
The most notable capabilities missing are those of calling methods and constructors and
querying the arguments of a method. However, none of the features provided by INTERNAL
are necessary for our implementation, as explained in Section 5.
Figure 7: Meta-model for the homogeneous generation method
328 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
4 IMPLEMENTATION
4 IMPLEMENTATION
This section describes how the reflection library API for Eiffel presented in the previous
section can be implemented using a code generator. The general idea is to apply a pre-
compiler on the code that should be made introspectable and to generate a custom-fit
implementation for the generic reflection API.
Erl-G. Our generators presented above have been implemented in the Erl-G tool. More
precisely, this tool implements both the homogeneous and the heterogeneous meta-class
generation techniques. Erl-G is published as open source and can be downloaded as
binary and source [17]. Erl-G relies on the front-end of the Gobo Eiffel parser [2] for
Eiffel classes.
In the following we look at the high-level architecture of the tool, examine the details
of the heterogeneous and homogeneous code generation methods, and provide an example
to illustrate the approach.
General Architecture. Both methods of generating code share a common architec-
ture. The reflection library is generated via a pre-compiler before compilation. The
pre-compiler parses the system (much like the first phases of the actual compiler) and
then generates the corresponding meta-classes. In scenarios where reflection is be added
to a platform a posteriori, it is likely that one cannot or does not want to modify the
compiler itself. Our preprocessor is implemented using the Eiffel parser from the Gobo
package. This parser recognizes the same language as the parser of the target compiler.
The generated meta-code implements a predefined and static reflection API (described in
section 3). The compiler then compiles a program consisting of the actual system, the
reflection API, and the generated reflection implementation. Note that as soon as some
parts of an interface within the actual system change, the pre-compilation step needs to
be repeated. Figure 8 shows the relation between the various parts involved.
uses
implements
uses
Reflection API
Actual System
Generated
Reflection Implementation
Figure 8: System with introspection support
For the pre-compiler to parse the initial system it is necessary that this system can be
type-checked even before the pre-compiler has generated its meta-code. In order to solve
this problem, a “dummy” reflection implementation is used. Thus, the system can be type-
checked also before the real reflection implementation is available. As an added benefit,
the dummy implementation allows the initial program to compile and be self-contained
even if no meta-code has been generated yet.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 329
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
Introspectable Types in the Heterogeneous and Homogeneous Approaches. Sec-
tion 2 presented the two possibilities for generating meta-classes. Both instrumentations
require a list of types (to be made introspectable) to generate the meta-classes. In practice
this list is mostly generated automatically. In the heterogeneous approach, Erl-G gener-
ates a meta-class per type while the homogeneous approach has only one meta-class per
class but needs the list of types instantiatable via reflection.
For the heterogeneous approach, the default behavior is to derive: (1) one type per
non-generic class, (2) the most abstract derivation (i.e. the one where each formal generic
parameter is replaced by its constraining type) for each generic class, and (3) each type
that could be instantiated by the program at runtime. This last part is computed using
the dynamic type set algorithm [20], which produces an over-approximation of the set of
types that can be instantiated in the system.
For the homogeneous approach, the default behavior is to derive: (1) one type per
non-generic class, (2) the most abstract derivation for each generic class. All classes are
then introspectable. Non-generic classes can be instantiated and generic classes’ most
abstract derivations can be instantiated.
In practice, rather than redefining the default list, users can simply extend it.
Illustrations. To illustrate how Erl-G works, we use the example of a simple banking
application. The main class of this application is outlined in Listing 2. Implementation
details and contracts which are not germane to the subsequent presentation have been
omitted for brevity. As the homogeneous approach produces less meta-code, we use it for
this example.
class BANK ACCOUNT
feature
owner: PERSON
balance: INTEGER
make (p: PERSON; init bal: INTEGER)
make with default balance (p: PERSON)
withdraw (sum: INTEGER)
set owner (p: PERSON)
set balance (b: INTEGER)
end
Listing 2: Classes in the example
The homogeneous generation method creates a meta-class for each existing class and
then one class that serves as a lookup-point for all meta-classes. Due to size restrictions
we cannot show the generated code. Excerpts are publishes in the associated technical
report [18].
Listing 3 illustrates how the reflection library generated by Erl-G can be used. Note
that this code only uses the general interface described in section 3 and does not depend
in any manner on the way in which the actual meta-code is generated (e.g. the static type
ERL CLASS is used instead of the generated descendant class).
330 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
5 EVALUATION
class BANK REFLECTION
inherit ERL SHARED UNIVERSE
feature
execute is
local
c : ERL CLASS
p: ANY
ba: ANY
tmp: ANY
do
c := universe .class by name (”PERSON”)
p := c . create object (”make”, ””, <<35, ”John Doe”>>)
c := universe .class by name (”BANK ACCOUNT”)
ba := c . create object (”make”, ””, <<p, 300>>)
tmp := c . invoke method (”withdraw”, ba, <<20>>)
end
end
Listing 3: Use of reflection API
5 EVALUATION
This section evaluates the Erl-G tool and compares the two generation methods: the het-
erogeneous one (which generates a meta-class for every type) and the homogeneous one
(which generates a meta-class for every class). First we show the results of some tests we
performed using Erl-G and then discuss the applicability of the two methods.
Efficiency. We have used both the heterogeneous and the homogeneous generation
methods implemented by Erl-G to make a set of libraries introspectable. As entry point
for each library (in order to be able to generate an executable) we used a class implement-
ing an interpreter. This interpreter reads instructions from the standard input and then
uses the reflection API to execute the actual code (method calls, creation of objects, etc.).
Table 1 provides some figures illustrating the efficiency of both generation methods.
Table 2 shows the factor gained by using the homogeneous method over the heterogeneous
one. The tables show statistics of the application of Erl-G on three libraries: Base, the
Eiffel standard I/O and data-structure library for the ISE Eiffel compiler; Gobo, a portable
standard library and tool collection; Vision2, a multi-platform GUI library.
The tests were performed on a custom-built desktop PC equipped with an AMD
Athlon 64 dual core and 2 GB RAM using a 64 bits version of Ubuntu Linux.
The left part of table 1 shows the results for the heterogeneous generation and the
right part shows the results for the homogeneous generation. In each part the columns
represent: (1) Number of classes to be made introspectable, (2) Compilation time with
dummy reflection implementation, (3) Pre-compilation time, (4) Number of meta-classes
generated, (5) Compilation time with generated reflection implementation. All times are
given in the format hh:mm:ss.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 331
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
heterogeneous (code per type)
#classes compil. gener. #meta-cl. compil.
wo m.-c. time w m.-c.
Base 310 00:00:24 00:01:16 1902 03:12:28
Gobo 539 00:00:23 00:05:11 2841 06:14:34
Vision2 981 00:00:21 04:40:08 9144 error (>12h)
homogeneous (code per class)
#classes compil. gener. #meta-cl. compil.
wo m.-c. time w m.-c.
Base 285 00:00:32 00:00:02 286 00:05:38
Gobo 530 00:00:33 00:00:03 531 00:07:54
Vision2 965 00:00:37 00:00:07 966 00:18:54
Table 1: Code generation for reflection implementations
Note, that the compilation time with the dummy reflection generation is almost con-
stant. This is because the global analysis of the compiler determines that the executable
to produce is only dependent on a fixed number of classes: the interpreter and the dummy
implementation.
For the heterogeneous generation both the pre-compilation time and the full compi-
lation time increase with the number of types in the system (which is greater than the
number of classes). In the case of Vision2, the heterogeneous implementation takes over
4 hours to generate the meta-classes and the compilation of the full program fails due to
overload after 8 hours. Note that the number of classes is slightly different in both cases
for each library as the new version of the compiler was not backward compatible and thus
it was needed to process older versions for the heterogeneous approach. In each case,
the most recent version of the libraries that would still compile with the heterogeneous
compiler was used.
These results show that, due to efficiency reasons, the homogeneous method should
always be preferred over the heterogeneous one for languages with universally-rooted
type systems. For the other languages, the homogeneous method cannot be used.
Applicability. As one of the primary goals of our work was to develop an approach that
is applicable as widely as possible, our reflection generation method has a minimal set of
requirements: the target language must provide a means of obtaining the type of an object
(or, in its absence, a safe casting mechanism) and the source code for the introspectable
classes must be available. A higher resolution of the type information provided by the
system makes it easier to provide accurate information upon introspection. Consider the
case of Java; the absence of runtime support makes it hard to provide information on
332 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
6 APPLICATIONS
improvement factor of
homogeneous generation over heterogeneous generation
#classes compil. gener. #meta-cl compil.
wo m.-c. time w m.-c.
Base 1.08 0.75 38 6.65 36.16
Gobo 1.01 0.69 103.66 5.35 47.41
Vision2 1.02 0.56 2401.14 9.46 ∞
Table 2: Comparison of homogeneous and heterogeneous code generation implementa-
tions
actual generic arguments.
As explained in Section 4, any system contains at least as many types as classes.
Hence, the heterogeneous method generates more meta-code and causes longer generation
and compilation time, and a bigger memory foot-print. To compensate, a user can choose
to lower the number of types that should be introspectable and Erl-G provides built-in
facilities to easily customize the generation process.
In some circumstances it is not even possible to generate meta-code for all alive types
statically, since there are potentially infinitely many. Such a situation occurs for example
for a generic class SET [G], that includes a method that returns its powerset. The return
type of such a method is SET [SET [G]]. This method may be used in a loop, resulting in an
unknown number of types.
The heterogeneous method is limited to a fixed subset of the potentially infinite num-
ber of types. The homogeneous method does not suffer from this problem since all classes
can be made introspectable, but some types will not be instantiatable through the reflec-
tion library.
The pre-compiler approach makes it possible to add reflection a posteriori to a lan-
guage without the need to modify the language, the core libraries, or the execution en-
vironment. However, in the presence of dynamic class loading, pre-compilation is not
sufficient. When a new class is loaded, a new meta-class needs to be generated, loaded
into the program, and registered with the universe object. We did not implement such a
facility in Eiffel due to its lack of support for dynamic class loading.
6 APPLICATIONS
In this section we present two applications of the Erl-G library, namely a tool for experi-
menting with dispatching schemes, and a framework for automatic program testing.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 333
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
Teapot. A simple application of the reflection API consists in rerouting regular method
calls through the reflection API. It is then possible to profile method calls, marshal results,
and have, for example, a customized dynamic method dispatch mechanism.
The Teapot tool is an implementation of this idea. It currently allows to rewrite classes
and redirect the calls on an instance of a given class through the Erl-G library.
Currently Teapot mostly serves as a proof of concept but its refactoring capabilities
will be used further in various projects that are under development.
AutoTest. Another use of the Erl-G pre-compiler is the AutoTest tool [6], available
in source and binary from [7]. AutoTest is a fully automatic testing tool for contract-
equipped classes. It covers test case creation, execution, and evaluation. The user invokes
AutoTest by specifying a set of classes to be tested. AutoTest then tests these classes
and produces statistical results about the testing process and bug-reproducing witnesses
(fragments of code which, when run, will cause a failure, thus showing the presence of
the bugs).
For every class under test, AutoTest synthesizes a set of object creations and method
invocations to execute. During the execution of these instructions, the contracts (in the
form of preconditions, postconditions and invariants) are monitored for violations. De-
pending on the type of violation, AutoTest can decide whether a class was used improperly
or a bug has been found.
To increase robustness, AutoTest separates test case creation and execution into two
separate processes. The actual execution is performed by a special purpose interpreter.
This interpreter can receive (via standard input) and execute simple instructions, such as
calling a method on an object, creating a new object, assigning values to variables, etc.
The instructions are written in a subset of the Eiffel language.
Since this interpreter needs the ability to execute a method given by its name and the
Eiffel compiler used lacks the possibility to reflect methods, Erl-G is used to implement
the interpreter. Every instruction read from standard input is parsed, then the required
meta-class is looked up and the reflection interface is used to invoke the requested method.
7 RELATED WORK
Recent research in the area of reflection has been strongly centered around separation of
concerns and aspect-oriented programming (AOP). In the following we overview work
on reflection closely related to ours, which for the most predates AOP.
Inherent Support for Reflection. Reflection has traditionally been often either at the
core of a language or absent from the language. CLOS [3, 15] and Smalltalk [23] for
example integrate reflection as a core concept that guides the entire program execution.
In both CLOS and Smalltalk, reflection is embodied by a meta-object protocol (MOP).
334 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
7 RELATED WORK
Roughly, an MOP promotes meta-objects (and meta-classes) which allow the program-
mer to modify the behavior of the objects at runtime. To assist an MOP programmer,
any single construct involved in the MOP is reified (put into an object form) and can
be modified directly within the MOP. Depending on the type of modification allowed,
there are different types of reflection that are available to programmers. Terminologies
diverge in the literature. Generally, though, structural reflection implies a reification of
the data handled by the running program; in that context introspection refers to the ability
of reading that data, and intercession allows for alterations thereof. Dynamic invocation
facilities circumventing (static) type checking are commonly conceived as part of intro-
spection mechanisms. Behavioral reflection reifies the semantics of the program and the
execution, and is mostly interpreted as the ability to intercept/redirect calls. Both CLOS
and Smalltalk support all these kinds of reflection by design. Smalltalk for instance pro-
vides for any given object a default method doesNotUnderstand which is executed whenever
the object receives a call for which no method with matching signature exists – a likely
event given the dynamically typed nature of the Smalltalk language. Being interpreted,
Smalltalk allows for strong support for behavioral reflection in the form of first class parse
trees available to a program at runtime.
In a different setting (e.g. an existing language), it is not possible to change the core
of the language and this is where our approach has added value.
Add-Ons. For languages that include only marginal support for reflection or for which
no reflection support whatsoever is available, benefitting from (more advanced) reflective
structures means either changing the runtime or instrumenting the code.
C++ [24] and Objective-C [22] are examples of languages devoid of any reflective fea-
tures. Due to its widespread use, C++ has received particular care to accept a meta-object
protocol. Efforts for providing reflection for C++ through an MOP include OpenC++ [4],
Iguana [12] and MPC++ [14]. MPC++ and Open C++ claim to be meta-level, compile-
time frameworks respectively, but bear more resemblances to complex preprocessing tools
than to meta-object protocols, which by definition should allow run-time changes. Iguana
generates the reflective infrastructure for each of given types of meta-data. While this
infrastructure is the most complete one — combining introspection and behavioral reflec-
tion — it falls short in support for generics (i.e., templates in C++).
Extensions. In imperative languages like Eiffel [19], Java [1] or C# [13], reflective
structures allow mainly introspection. Even within these confines, there is usually a lack
of fine-grained enough features: Java does not provide a satisfactory mechanism to intro-
spect generics, C# enables reflection at the assembly level only, and Eiffel does not even
support dynamic invocations.
Reflection frameworks for Java (e.g. Kava [27], Reflex [26] and Javassist [5]) com-
plement the existing Java reflection APIs by adding further reflection support at load-time
through byte-code instrumentation. This load-time approach has been popularized by
Java thanks to its inherent dynamic code loading and linking facilities. A limited mecha-
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 335
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
nism for behavioral reflection with a load-time flavor has been officially added to Java at
1.3 through dynamic proxies [25]. A dynamic proxy is a program-controlled typed proxy
object implementing a set of types chosen by the program. It is created at runtime by gen-
erating a corresponding proxy class directly as byte-code and loading it. Due to its late
addition, and inherent limitations of such an extension approach (the proxy class imple-
ments the types it is created for, methods simply reify invocations to them) this approach
however only supports interface types [9].
Similarly, neither the inherent introspection capabilities nor any of the above-mentioned
frameworks provide support for generics due to their late addition to the Java language.
The Erl-G infrastructure handles generics by default. Erl-G also differs from the Java-
related frameworks in that it generates the reflective code and allows programmers to
modify it and apply further transformations to regular Eiffel code, providing more flex-
ibility and also safety (e.g., byte code additions and modifications end up being visible
through introspection in Java). On the downside, Erl-G does not yet cover behavioral
reflection.
8 CONCLUSIONS
Reflection has become a fundamental feature of programming languages, not only object-
oriented ones, going as far as impacting the very design and underlying computation
model of recent languages, and even advocating for novel software development paradigms [16].
Many programming languages however have been initially introduced without reflec-
tion capabilities, or have been extended after their inception with features not covered
by the initial reflection mechanisms. In particular languages compiled to native code,
devoid of a standardized compilation and runtime infrastructure, are very prone to such
extensions remaining beyond the reach of reflection. Even Java, in spite of its “compile
once, run everywhere” credo, is a popular example of such a shortage: it has been aug-
mented with generics lately but lacks support for introspection of corresponding generic
parameters.
This paper proposes a way out of such bottlenecks, by describing an approach for
the generation of introspection libraries leveraging static program analysis. We have de-
scribed our approach starting from a general context – a simple abstract language in-
cluding generics. We have presented two variants of our generation function, depending
on whether the type system of the target language has a universal root type (e.g., Java,
Oberon) or not (e.g., C++, Ada’95). We discussed consequences of these options in qual-
itative as well as quantitative terms – showing an order of magnitude gained in both time
(duration of program compilation) and space (number of meta-classes generated) when
a universal root type exists. We presented workarounds for limitations such as infinite
recursion, and discussed minimal support required from a target programming language.
The Eiffel language has been used in this paper as an illustration for all of our contri-
butions, as it has yielded the initial motivation for this work: only a very recent overhaul
of the language has provided its type system with a universal root type, and several in-
336 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
8 CONCLUSIONS
dependent, highly evolved, compilers exist for it. We have illustrated the benefits of our
approach in the Eiffel language for instance through AutoTest, an automatic program test-
ing tool. We are currently in the process of validating our approach with other languages,
and extending Erl-G with behavioral reflection.
REFERENCES
[1] ARNOLD, K., AND GOSLING, J. The Java programming panguage. The Java
Series. Addison-Wesley, 1996.
[2] BEZAULT, E. Gobo Eiffel tools library.
http://www.gobosoft.com/.
[3] BOBROW, D. G., DEMICHIEL, L. G., GABRIEL, R. P., KEENE, S. E., KICZALES,
G., AND MOON, D. A. Common Lisp object system specification. ACM SIGPLAN
Notices 23, SI (1988), 1–142.
[4] CHIBA, S. A metaobject protocol for C++. ACM SIGPLAN Notices 30, 10 (1995),
285–299.
[5] CHIBA, S. Load-time structural reflection in Java. In Proceedings of ECOOP 2000
(2000), vol. 1850 of LNCS, pp. 313–336.
[6] CIUPA, I., AND LEITNER, A. Automatic testing based on design by contract. In
Proceedings of the Net.ObjectDays 2005 (2005), pp. 545–557.
[7] CIUPA, I., AND LEITNER, A. AutoTest: a contract-based testing tool.
http://se.ethz.ch/people/leitner/auto test/, 2005.
[8] D. RIVIÈRES, J., AND SMITH, B. The implementation of procedurally reflective
languages. In LISP and Functional Programming (1984), pp. 331–347.
[9] EUGSTER, P. Uniform proxies for Java. In Proceedings of OOPSLA 2006 (2006),
pp. 139–152.
[10] GOLDBERG, A., AND ROBSON, A. Smalltalk-80: the language and its implemen-
tation. Addison-Wesley, 1983.
[11] GOSLING, J., JOY, B., STEELE, G., AND BRACHA, G. The Java language secifi-
cation, Third Edition. Addison-Wesley, 2005.
[12] GOWING, B., AND CAHILL, V. Meta-object protocols for C++: the Iguana ap-
proach. In Proceedings of Reflection ’96 (1996), pp. 137–152.
[13] HEJLSBERG, A., GOLDE, P., AND WILTAMUTH, S. C# language specification.
Addison Wesley, 2003.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 337
REFLECTING ON AN EXISTING PROGRAMMING LANGUAGE
[14] ISHIKAWA, Y., HORI, A., SATO, M., MATSUDA, M., NOLTE, J., TEZUKA, H.,
KONAKA, H., MAEDA, M., AND KUBOTA, K. Design and implementation of
metalevel architecture in C++ – MPC++ approach –. In Proceedings of Reflection’96
(1996), pp. 141–154.
[15] KICZALES, G., DES RIVIÈRES, J., AND BOBROW, D. The Art of the metaobject
protocol. MIT Press, 1991.
[16] KICZALES, G., HILSDALE, E., HUGUNIN, J., KERSTEN, M., PALM, J., AND
GRISWOLD, W. An overview of AspectJ. In Proceedings of ECOOP 2001 (2001),
pp. 327–353.
[17] LEITNER, A. ERL-G: the Eiffel reflection library generator.
http://se.inf.ethz.ch/people/leitner/erl g/, 2005.
[18] LEITNER, A., EUGSTER, P., ORIOL, M., CIUPA, I. Reflecting on Eiffel. Technical
report under submission
[19] MEYER, B. Applying design by contract. IEEE Computer 25, 10 (1992), 40–51.
[20] MEYER, B. Eiffel: the language. Object-Oriented Series. Prentice-Hall, 1992.
[21] MEYER, B. Object-oriented software construction, 2nd ed. Prentice-Hall, 1998.
[22] PRIES, J. Objective-c. J. Object Oriented Program. 1, 5 (1989), 77–80.
[23] RIVARD, F. Smalltalk: a reflective language. In Proceedings of Reflection’96
(1996), pp. 21–38.
[24] STROUSTRUP, B. The C++ programming language. Addison-Wesley, 1986.
[25] SUN. Dynamic proxy classes, 1999.
[26] TANTER, É., BOURAQADI, N., AND NOYÉ, J. Reflex — towards an open reflective
extension of Java. In Proceedings of Reflection 2001 (2001), pp. 25–43.
[27] WELCH, I., AND STROUD, R. Kava-using byte code rewriting to add behavioural
reflection to Java. In Proceedings of COOTS’01 (2001), pp. 119–130.
ABOUT THE AUTHORS
Andreas Leitner is a PhD student and research assistant at the Chair of
Software Engineering at the ETH Zurich, Switzerland. His research fo-
cus is on contract based testing and software engineering in general. He
received his masters degree from Graz University of Technology, Aus-
tria, in January 2005. He can be reached at andreas.leitner@inf.ethz.ch.
338 JOURNAL OF OBJECT TECHNOLOGY VOL 6, NO. 9
8 CONCLUSIONS
Patrick Eugster Patrick is an assistant professor at Purdue University.
He is interested in distributed programming, touching upon program-
ming abstractions and languages, middleware, and distributed systems.
Patrick holds both an M.S. and Ph.D. degree from the Swiss Federal In-
stitute of Technology in Lausanne, Switzerland (EPFL), and is a recipi-
ent of the NSF CAREER award. He can be reached at p@cs.purdue.edu.
Manuel Oriol Manuel is a postdoctoral researcher at the Chair of Soft-
ware Engineering at ETH Zurich. His main areas of interest are co-
ordination, middleware, components infrastructures, dynamic software
updating and software testing. He can be reached at moriol@inf.ethz.ch.
Ilinca Ciupa Ilinca Ciupa is a PhD student at the Chair of Software
Engineering working on developing and evaluating techniques for au-
tomated software testing based on the principles of Design by Con-
tract. She became a PhD student at the ETH in July 2005, after being
an academic guest in the group since October 2004 and graduating as
Dipl. Eng. from the Technical University of Cluj-Napoca, Romania, in
September 2004. She can be reached at ilinca.ciupa@inf.ethz.ch.
VOL 6, NO. 9 JOURNAL OF OBJECT TECHNOLOGY 339

