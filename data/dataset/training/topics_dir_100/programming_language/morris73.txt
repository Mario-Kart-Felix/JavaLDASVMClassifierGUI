Programming D. Gries 
Languages Editor 
Protection in 
Programming 
Languages 
James H. Morris Jr. 
University of California 
Linguistic mechanisms which can be used to protect 
one subprogram from another's malfunctioning are 
described. Function-producing functions and various 
type-tagging schemes are considered. An attempt is 
made to distinguish between access limitation and 
authentication. 
Key Words and Phrases: protection, types, 
environments, trademarks, seals, access keys, access 
control, authentication, secrecy 
CR Categories: 4.2, 4.3 
Copyright Â© 1973, Association lbr Computing Machinery, Inc. 
General permission to republish, but not for profit, all or part 
of this material is granted, provided that reference is made to this 
publication, to its date of issue, and to the fact that reprinting 
privileges were granted by permission of the Association for Com- 
puting Machinery. 
Author's address: Department of Computer Science, University 
of California, Berkeley, CA 94720. 
15 
1. Introduction 
The ability of a programming language or system to 
protect and isolate program modules is vital. As a set 
of coexisting and perhaps cooperating programs grows, 
the proper functioning of any particular program should 
not be endangered. 
This paper explores a few protection mechanisms as 
they exist or might exist in a programming language. 
In doing so we hope to illuminate certain devices 
found in operating systems (e.g. capabilities and access 
control)  as well as programming languages (e.g. func- 
tion-producing functions, programmer-defined data 
types). 
Who is to be protected from what? Although the 
need for protection is usually inspired by situations in- 
volving hostility (e.g. competing government agencies 
sharing a computer system), experienced programmers  
will attest that hostility is not a necessary precondition 
for catastrophic interference between programs. An un- 
debugged program, coexisting with other programs, 
might as well be regarded as having been written by a 
malicious enemy--even if all the programs have the same 
author! The protection problem to be dealt with here is: 
how does one allow programs to cooperate and com- 
municate and yet minimize the confusion attendant upon 
a program's  malfunctioning? There are other kinds of 
protection problems of a less microscopic nature (e.g. 
proprietary programs) that will not be dealt with here. 
We offer the following as a desideratum for a 
programming system: A programmer should be able to 
prove that his programs have various properties and do 
not malfunction, solely on the basis of what he can see 
from his private bailiwick. To make "his bailiwick" 
more precise we simply equate it with a single textual 
region of a larger program. While we realize that logis- 
tical problems prevent a large system of programs from 
Communications January 1973 
of Volume 16 
the ACM Number 1 
existing as one single program, we accept this artific- 
iality for the sake of precision. Thus we are only in- 
terested in those properties of  a subprogram which are 
invariant over all the possible program texts into which 
the subprogram might be inserted. For example, the 
distinction (in ALGOL 60) between an own variable and 
one declared in the outermost  block is vital given this 
criterion; a programmer can depend upon the privacy 
of his access to the former, but not the latter. 
2. Procedures as Objects 
The procedure or subroutine has always been a con- 
venient device for one programmer to make his work 
available to others. The essence of its power is that the 
user of a procedure need not be concerned with the de- 
tails of its operation, only the effect. If  we make this 
ignorance mandatory by arranging that users of  pro- 
cedures cannot discover anything about  them except 
by executing them, we have the basis for a very flexible 
protection mechanism. 
Execute-only procedures are, of course, the norm; 
both FORTRAN and ALGOL 60 enforce that restriction. 
However, in order to exploit this device to its fullest 
extent it is useful to make procedures full-fledged objects 
in the sense that they can be passed as parameters or 
values of  other procedures and be assigned to variables. 
Then, to make a particular object accessible to someone 
in a restricted way (e.g. read only), we make the object 
local to a procedure and pass the procedure to them in 
its stead. The first language to allow procedures to be 
passed about  was LISP, with its FUNARG lists [6]. Later 
languages, I S W I M  [5], PAL [2], and GEDANKEN [7], also 
have such procedures and have the execute-only re- 
striction (LISP does not).  Our example programs will be 
written in GEDANKEN as its definition is probably the 
most readily accessible to the reader. An appendix offers 
a brief description of GEDANKEN in terms of ALGOL 60. 
Example 1. The following GEDANKEN expression 
yields a procedure which will return as value the number 
of  times it has been called. The reference Count is in- 
accessible to users of  the procedure. 
[Count is Ref(O) ; 
X( ){Count := Count+ 1; 
Val(Count) }] [ ]  
3. Local Objects 
We wish to make precise the notion of an object 
being local to a particular part  of a program; i.e. its 
being inaccessible to other parts. For  example the ad- 
dress of a variable in a FORTRAN program is local to a 
subroutine if it does not appear in any COMMON dec- 
laration or as an actual parameter to a subroutine 
call. In general we define it as follows: An object is 
local to a textual region R if the only expressions that 
will ever have it as a value are part  of R. 
For example, the expression Ref(0)  in Example 1 is 
local to the whole expression. Obviously, an object can- 
not be local unless it is created by a unique object 
generator like Ref, or is defined in terms of such ob- 
jects. For example, neither the number 3 nor the 
function (kXX*3) can be local to any region. 
The advantage of an object's being local is that one 
can enumerate all the situations in which it plays a role 
by looking at a single (hopefully small) region of the 
program. 
Naturally, there can be no complete set of rules for 
proving that an object is local since we can easily con- 
struct a subprogram with a subexpression whose value 
is local iff some other, arbitrary, computat ion halts. 
However, consider the following general approach:  
Consider a region R and some expression in R known 
to produce a unique object every time it is evaluated 
(e.g. Ref(O) is such an expression). There are three 
ways in which a value Vofthis  expression could "escape" 
from R: It can be passed as a parameter  to a procedure 
not defined within R, it can be returned as a result of a 
procedure called from outside R, or it can be assigned to 
a reference which is not local to R. Therefore, to prove 
that V is local to R we must check each procedure call, 
procedure return, and assignment which might involve 
V and show that it does not escape. 
4. Memory Protection 
If  a memory  reference is local to R then only state- 
ments in R can assign to it or take its contents. However, 
any imaginable kind of restricted access (e.g. read-only, 
write-only, increment-only) can be allowed programs 
outside R by providing them with an appropriate  pro- 
cedure defined inside R. 
Example 2. Suppose a programmer  wishes to pro- 
vide some table-maintaining operations to the general 
community.  He writes the program shown in Figure 1 
and publishes the following set of instructions to users : 
To acquire a set of  table-maintaining procedures, call 
the (publicly available) procedure Createtable with the 
maximum number of  table entries you wish to allow. 
It will return a three-tuple of procedures 
Item, lndex, Save 
ltem(i) will return the ith smallest item in the table. 
Index(x) will return the index of x in the table (i.e. 
1tern (Index (x) ) = x) if it is there, otherwise 0. Save (x) 
will put x into the table if it is not already there. Ini- 
tially the table is empty. So much for the external 
specification. 
Inspection of the program reveals that the references 
created for Table and Count, as well as the procedures 
Locate and Move are local to the procedure body of 
Createtable. This implies that every assignment to the 
references is performed by statements inside the region 
and every call of the procedures is also from the region. 
16 Communica t ions  January  1973 
of  Volume 16 
the AC M Number  1 
Fig. 1. Table maintaining routines. 
Creatable is ~N 
[Table is Vector(1 ,N,M Ref(O)) ; 
Count is Ref(O) ; 
Locate is XX[ J is Ref( Count) ; 
Loop: if J= 0 then 0 else 
//The table 
//Number of entries 
//Returns index of X if present, 
//Otherwise negative of next 
smallest 
if Table(J) < X then -- J else 
if Table(J) = X then J else 
{J := J - l ;  go toLoop}]; 
Move is X(X,I) [if Count = N then go to Error* else 
//Inserts X after 
{ J is Ref(Count) ; //Position 1 
Mloop: if J = l  then Table(J+l) := X else 
(Table(J+ l) := Table(J); 
J : =  J--l;gotoM/oop); 
Count : = Count+ 1 } ]; 
Item is M* if 1 < 1 < Count then Val(Table(1))* 
else go to Error*; 
Index is XX[*I is Locate(X) 
if I > 0  then I else 0"]; 
Save is hX[*I is Locate(X) ; 
if 1 > 0  then NIL 
else Move (X, -- 1) * ]; 
Item, Index, Save*] 
Fig. 2. Interval manipulating routines. 
[Createint is X(X, Y) if X<_ Y then X, Y else Y,X; 
Min is XZ Z(1) ; 
Max is XZ Z(2) ; 
Sum is X(X,Y) (X(1) -+- Y(1)),(X(2) -q- Y(2)); 
Createint, Min, Max, Sum] 
Consider all the places marked with an asterisk (*) in 
Figure 1. At each we make the assertion 
Table( i ) ,  . . .  ,Table(Count )  
is in ascending order. Then we may prove, using what- 
ever degree of rigor deemed necessary, that if the asser- 
tion is true at each relevant entrance to this textual 
region (i.e. the entries to I tem,  Index,  and Save) ,  then 
it must be true at each exit (i.e. the exits of l t em,  lndex ,  
Save,  and Createtable and the Error exits). Now, because 
Table and C o u n t - - t h e  only objects the assertion deals 
with--are local, we may infer that the assertion really 
is true upon each entry to I tem,  lndex ,  and Save. [] 
FORTRAN local variables and ALGOL OWn variables 
offer limited versions of memory protection. Indeed, 
the programs in Figure 1 could be written as a FORTRAN 
subroutine with multiple entry points if it weren't for 
the fact that we may call Createtable many times. 
5.  T y p e  P r o t e c t i o n  
One of the fundamental ways in which one pro- 
grammer provides services to another is to implement a 
representation of a new kind of object. For example, a 
system programmer may represent files with disk-tracks 
and tape records, or a compiler writer may represent 
complex numbers with pairs of reals. Generally speak- 
ing, the first programmer writes some subroutines which 
create, alter, and otherwise deal with the new kind of 
objects. These new objects are represented by some older 
kinds. 
Suppose we wish to provide a new data type, in- 
tervals, to the general public. Among the primitive 
routines to be provided are Createint  ( x , y )  which creates 
an interval from x and y, M a x  and M i n  which yield the 
appropriate endpoints, and S u m  which adds two inter- 
vals to produce a new one. We might implement them 
as shown in Figure 2. 
Now the question arises: how is a user of these primi- 
tives to regard the objects that Createint  produces--  
as intervals or as common, ordinary pairs, which they 
obviously are? Most people would agree that he should 
do the former and would regard as a type violation any- 
thing assuming the latter. Specifically, there are three 
kinds of mishap which we might regard as type viola- 
tions--i.e, use of an object in a way not intended by its 
constructor. 
1. Alteration.  An object that involves references may 
be changed without use of the primitive functions pro- 
vided for the purpose. 
2. Discovery.  The properties of an object might be 
explored without using the primitive functions; e.g. we 
may select a component of a pair representing an 
interval. 
3. Impersonat ion.  An object, not intended to represent 
anything in particular, may be presented to a primitive 
function expecting an object representing something 
17 Communications January 1973 
of Volume 16 
the ACM Number 1 
quite specific; e.g. we might call Max with a pair not 
constructed by Createint or Sum. 
There are two parties involved in such mishaps: the 
programmer of the primitive procedures and the user 
(misuser, actually) of  them. Let us examine the impact 
upon them. 
I f  an alteration or impersonation occurs, the primi- 
tive functions might malfunction in a drastic way which 
would embarrass their programmer,  e.g. cause a mys- 
terious run-time error or never halt. For  example, if 
Max were called with something that was not even a 
pair, errors would result. While good programming 
practice might dictate that a programmer  make no as- 
sumptions about  input parameters and always perform 
checks, doing so can be difficult. Suppose, for example, 
that we chose to represent sets with sorted vectors. If  
the programmer were required to check each set- 
representing parameter  for well-formedness (i.e. being 
sorted),  there would be little point in using a fast search- 
ing method such as binary search to locate an item. For  
to check that a vector is sorted, we must examine each 
element and therefore might as well do the locating at 
that time. 
From the programmer ' s  point of view, discovery 
presents no direct threat. I f  in using programs other 
than his own, he simply looks at the objects being used 
as representing something, the proper functioning of 
his programs is not impaired. There are more subtle con- 
siderations, but we won' t  deal with them here. 
Now let us consider the user of  the primitive func- 
tions. First, if his violation of the type rules is genuinely 
a mistake, he wishes to be informed of it as soon as 
possible. I f  he really thinks of  the objects he deals with 
as intervals, there is no reason why he would wish a type 
violation to occur. However, if he is aware of the repre- 
sentation activity, he may wish to violate the type re- 
strictions for efficiency's sake. Also, a programmer may 
discover entirely unplanned for, yet quite useful, ap- 
plications of the primitive operations; e.g. using Sum 
to add pairs representing complex numbers. While 
recognizing that such activity is not entirely reprehen- 
sible, let us now consider devices for preventing it. 
These devices are basically generalizations of the type 
tags familiar to any implementor of  a language with 
dynamic data types. Here they are being made available 
to the general user. Our tagging operations are more 
general (and expensive) in two respects. First, they are 
"cascadable":  a tagged item may be retagged. This 
feature reflects our belief that representation can be a 
multilevel affair. Second, they are completely dynamic 
1 The use of a function-producing-function here is not essen- 
tial; Createseal could return a pair Iock~, key, where Iock~ and key~ 
are objects of special types usable by the generally available func- 
tions Seal and Unseal, respectively. 
in the sense that a running program could generate an 
arbitrarily large number of different type tags. The 
practical virtues of  this generality are not entirely clear. 
6. Seals 
Define a universally available function of no argu- 
ments, Createseal. Each time it is called, Createseal 
yields a pair 
Seal~, Unseal 
where i is a serial number which changes every time 
Createseal is called. SeaL(x) yields a new object x '  
such that any operation applied to x '  except Unseal~ 
results in an error (or some other abnormal  condition).  
UnseaL(x') yields x, if x '  was produced by Seal~, and 
results in error otherwise. The object x' may. of  course, 
be passed as a parameter  or value of a function, but its 
properties cannot be examined except by Unseal~ .1 
The interval manipulating functions can now be 
revised as shown in Figure 3. 
The programmer  of these functions may depend 
upon the following: 
I. The value of Unseal(E) had to have been an argu- 
ment of Seal at a previous time. Therefore, we have the 
inductive rule: to prove p(Unseal(E)) for all E prove 
that (VE)[o(Unseal(E))] implies p(F) for every F to 
which Seal is applied. (Proving this is easier if Seal is 
local to a small region.) 
2. I f  Unseal is local, applying Seal to an object x does 
not endanger its being local (even if Seal(x) is not local). 
In this particular case p(X) is "X  is a pair of  num- 
bers (X1, X2) and X1 _< )(2 ." By assuming it is true of 
P' and Q' in Sum, we can easily prove it is true of Seal's 
argument, ( ( P ' ( 1 ) ) + ( Q ' ( 1 ) ) ) , ( ( P ' ( 2 ) ) + ( Q ' ( 2 ) ) ) .  
Furthermore,  p is true of the expression if X < Y then 
X, Y else Y,X in Createint, so we have established by (1) 
that o is true of all objects produced by Unseal. 
Furthermore,  by (2), any user of  the primitive func- 
tions will not be able to examine the objects except 
through the functions provided. 
The Seal mechanism provides two separable func- 
tions of protection: authentication and limited access. 
The first is embodied in (1); the second in (2). 
7. Trademarks 
If  we are not concerned with limiting access to a class 
of  objects, we could make the Unseal operation publicly 
available. The same effect can bc achieved in a more con- 
venient way by use of  a new primitive function, Create- 
trademark. It is called with no arguments and returns 
a pair 
Markl , i 
18 Communications January 1973 
of Volume 16 
the ACM Number 1 
Fig. 3. Protected interval manipulating routines. 
[Seal, Unseal is Createseal ( ) ; 
Createint is ~(X, Y) Seal (if X_< Y then X, Y 
else Y,X) ; 
Min is :kP(Unseal(P) ) (1) ; 
Max is XP(Unseal(P)) (2) ; 
Sum is X(P,Q) IP' is Unseal(P) ; 
Q' is Unseal(Q) ; 
Seal ((P'(1) q-Q'(1)),(P'(2) +Q'(2)))]; 
Createint, Min, Max, Sum] 
Fig. 4. Simulation of Seals with trademarks. 
Createseal is â¢( ) 
[Mark l , I1 is Createtrademark ( ); 
Mark2, 12 is Createtrademark( ) ; 
Password is Mark2(N1L) ; 
Seal is ~,X 
Markl (hP if 12 E Trademarklist(P) 
then X 
else go to Error) ; 
Unseal is ~ Y 
if I1 E Trademarklist(Y) 
"then Y(Password) 
else go to Error; 
Seal, Unseal] 
(Note: The expression x E L is true iff x is on list L). 
19 
where i is an ever-changing serial number  as before. 
Mark~ (x)  yields an object x '  that behaves exactly like x 
except that it bears t rademark I. Trademarkl is t (x ' )  is a 
publicly available operation which yields a list of  the 
trademarks borne by x' .  (By lists we mean nested pairs.) 
Mark~ can be used in place of Seal~ and " i f  i E Trade- 
m a r k l i s t ( x ) t h e n  x else go to Error", in place of  Un- 
seal (x) .  A suitably rephrased version of the induction 
rule in (1) still applies. 
l f the  reader doubts the utility of  this device, stripped 
of any access limiting power, we urge him to consider 
how trademarks and other authenticating marks are 
used in the commercial /bureaucratic sphere. A mark  
from the Underwriters '  Laboratories attests that a par- 
ticular device may be used without risk, a fact that a 
user might discover only by extensive experience. A 
letter saying, "You have been drafted," is much more 
likely to be believed if it bears the mark  of a draft 
board. In neither case is limited access a consideration. 
The fact that marks can be forged in the real world is of  
no concern here. 
The access-limiting ability of the Seal mechanism 
is already present in the local variable conventions of 
GEDANKEN. We can use trademarks and function-pro- 
ducing functions to simulate Seals. Figure 4 displays 
the programs. When Createseal is called it creates two 
trademarks and then the functions Seal and Unseal 
which use them. A sealed object is represented by a 
t rademarked function which will divulge the original 
object only when called with a password. 
It is clear that this simulation provides the authenti- 
cation of the original Seal primitives, For, Unseal trans- 
fers to Error unless its argument bears t rademark 1 ; and 
an object can bear t rademark 1 only if it was produced 
by Seal, because Mark  1 is local. 
To show that access to sealed objects is limited to 
holders of  the Unseal function we argue as follows: 
F rom the argument in the preceding paragraph we know 
that any object bearing t rademark 1 is a function which 
arose from the k-expression in Seal. Therefore every Y 
applied to Password in Unseal is an incarnation of that 
k-expression. Hence P is the only other expression that 
can ever have the same value as Password. (Applying 
Trademarklist, a primitive, to P does not endanger this 
claim.) Therefore Password is local. Now suppose 
x'  = Sea l (x ) .  By inspection of Seal, the only way x 
can be recovered from x '  is to apply x '  to something 
marked by t rademark 2. Since Mark2  is local we see 
that Password is the only such object, and it is also local. 
Therefore, the only way to get x '  applied to an object 
bearing t rademark 2 is to apply Unseal to x ' .  
Since seals can be simulated by trademarks without 
undue loss of efficiency we are inclined to discard seals 
as a basic semantic unit, invoking Occam's razor, or- 
thogonality, or some other folk principle. 
There is another reason for preferring t rademarks to 
seals, however; they offer greater flexibility. Suppose we 
have some class of  objects (e.g. ordered pairs of  num- 
Communications January 1973 
of Volume 16 
the ACM Number 1 
bers) which are used to represent various other classes 
(e.g. intervals, points in the plane), in a variety of  ways 
(e.g. cartesian versus polar coordinates [3]). These ob- 
jects may in turn represent others (e.g. a point in the 
p l ane  might represent a complex number or a vertex in a 
geometrical figure). We can invent t rademarks to at- 
test to these various properties and attach them to ob- 
jects in any order we like. For  example, a complex 
number represented in the cartesian system might bear 
four marks:  pair, point-in-plane, cartesian, complex. 
Programs may examine these marks or not as they 
please; e.g. a routine that prints pairs is unconcerned 
with all but the pair tag. If  seals were used in this kind of 
situation great complications would result. Every routine 
that dealt with pairs would have to be equipped with a 
battery of  Unseal operations which it would use to un- 
lock all the nested seals; to make matters worse it would 
have to have a way of determining which Unseal was 
called for at each stage. 
Naturally, when we wish to limit access to a class of 
objects as  well as authenticate them, the full facilities of  
the Seal mechanism are called for. Only in situations 
involving no need for suppressing information is the 
t rademark best. 
8.  A c c e s s  K e y s  
Now let us examine the implications of making the 
Seal operation public and leaving Unseal private; e.g. 
Seal ( i ,x )  places seal number i on x and Createseal 
produces the pair 
UnseaL, i. 
I f  one puts such a seal on an object and leaves it in a 
public place, he is guaranteed that only the restricted 
group of programs holding Unseal~ can access it. Those 
programs, however, cannot depend upon an object thus 
sealed to have any particular properties since anyone 
can seal an object with any number. This mechanism is 
similar to the access key described in [4]; each Unseal~ 
plays the role of  an access key. 
Access keys are symmetric to t rademarks in the 
sense that they allow many unprivileged senders to give 
information to one privileged receiver, the holder of the 
Unseal operation. With t rademarks the sender of in- 
formation has the privilege. 
These new Createseal and Seal operations can also 
be simulated using the t rademark primitives. 
9.  A u t h e n t i c a t i o n  vs.  A c c e s s  C o n t r o l  
There seems to be a chicken-egg relation between 
these two notions that make them hard to disentangle. 
Access to the authentication operation, e.g. Mark,  must 
be controlled if it is to be useful. On the other hand, 
gaining access to things sometimes requires that a pro- 
Fig. 5. Simulation of trademarks with access control. 
[Oblist is Ref(NIL); //List of all Marked Objects, really nested 
//triples. 
Seriahmmber is Ref(O) ; 
Findob is XX[E is Ref(Oblist) ; 
Loop: if E= NIL then NIL else //E(1) is unique name 
if E(1) = X then E(2) else //E(2) is (TMlist,Object) 
{E:=E(3); go to Loop}]; //E(3) is next item 
Trademarklist is ~X 
[T is Findob( X) ; 
if T=NIL then NIL else T(1)]; 
Get is )~X 
IT is Findob(X) ; 
if  T =  NIL then X else T(2) ]; 
Createtrademark is ~( ) 
[I is Val(Serialnumber) ; 
Mark is ~X//Always add to Oblist 
ITis ( l, Trademarklist( X) ), Get(X); 
Oblist := Ref(NIL), T, Val(Oblist); 
Oblist(1)]; 
Serialnumber.= SeriahTumber q- 1; 
Mark, 1]; 
Createtrademark, Trademarklist, Get] 
gram provide authenticated evidence of its access rights. 
It seems clear that access control is a sine qua non of 
security; if every program has access to every object 
and operation there is no protection. The case is not so 
clear for authentication. Given the access control mech- 
anisms already present in GEDANKEN, i.e. local ref- 
erences, we can simulate the t rademark system if 
we require the user to use a function, Get, when 
accessing a marked object. (This is a minor incon- 
venience.) The idea is to hold all objects submitted to 
Mark  in a protected list (Oblist), paired with their trade- 
mark lists. Each such pair is given a unique name which 
is used to retrieve the object or its t rademark list. 
GEDANKEN'S R e f  operation is an admirable generator of  
unique names. The scheme works because access to the 
list is limited. Figure 5 shows an expression which 
evaluates to produce the functions Createtrademark, 
Trademarklist, and Get. The idea behind this program 
should be familiar to those who understand how C-lists 
[1] are used; basically, we are using memory protection 
(rather clumsily) to achieve type bit protection. 
This simulation of t rademarks is unsatisfactory in 
two respects. First, one can say that we really haven ' t  
started without type protection since we use references 
20 Communications January 1973 
of Volume 16 
the ACM Number 1 
to  s imula te  m a r k e d  objects  a n d  they  are p r e s u m a b l y  
m a r k e d  in some  way.  T o  avo id  this  charge  we cou ld  have  
used integers  ins tead ,  keep ing  a c o u n t e r  to genera te  new  
ones.  However ,  this  is n o t  en t i re ly  a d e q u a t e  since it 
wou ld  then  be imposs ib le  for a t r a d e m a r k e d  objec t  to be 
local  to a n y  region.  Th e  second  s h o r t c o m i n g  is t ha t  it is 
wildly inefficient:  a list m u s t  be  searched  ju s t  to access 
a n  object ,  a n d  m a r k e d  objects  will never  be ga rbage  
collected even af ter  all  references  ou t s ide  the  p ro tec ted  
reg ion  have d i sappeared .  A t  p resen t  we see n o  way of  
o v e r c o m i n g  these p rob l ems .  
W e  believe t h a t ' a u t h e n t i c a t i o n  is a n o t i o n  o r t h o g o n a l  
to l imi t a t i on  o f  access. Ou r  bel ief  rests u p o n  i n t u i t i o n  
a n d  the fact t ha t  the  fo rmer  seems difficult  to s imu la t e  
with the latter.  
R e m a r k s  
The ideas p resen ted  here are, in a sense, a r epackag-  
ing  o f  fami l ia r  n o t i o n s  f rom p r o g r a m m i n g  l anguages  
a n d  ope ra t i n g  systems : scope rules,  capabi l i t ies ,  m e m o r y  
pro tec t ion ,  a n d  type  bits.  W e  have  cons ide red  these  
devices in ex t remely  genera l  forms,  a n d  it  is en t i re ly  
poss ib le  tha t  less genera l  devices m a y  be sufficient  a n d  
e c o n o m i c a l l y  m o r e  r easonab le .  Specifically,  the  func-  
t i o n - p r o d u c i n g  func t ions ,  indef in i te ly  cascadab le  type  
tags,  a n d  r u n - t i m e  c rea t ion  of  types  en ta i l  subs t an t i a l  
costs  by  c u r r e n t  s t anda rds .  F i n d i n g  r e a s o n a b l e  c o m -  
p romises  be tween  these facilit ies a n d  ones  efficiently im-  
p l e m e n t a b l e  t o d a y  is a subjec t  o f  c o n t i n u i n g  research.  
This  w o r k  bu i lds  u p o n  the  ideas  of  m a n y  people ,  
mos t  no t ab ly ,  L a m p s o n  [4], L a n d i n  [5], R e y n o l d s  [7], 
a n d  D e n n i s  [1]. 
Acknowledgments. Ear l ie r  vers ions  of  this  pape r  were 
g iven sympa the t i c  r ead ings  by  But ler  W. L a m p s o n  a n d  
James  N.  Gray .  
Appendix .  A Br ie f  C o m p a r i s o n  o f  G e n d a n k e n  with 
A l g o l - 6 0  
The basic means of introducing new identifiers is the is-declara- 
tion which is used in three ways here: 
1. Count is Ref(O) is like integer Count; Count :=  0 
2. Locate is ~X[. --] is like integer procedure Locate(X); 
begin - . .  end 
3. I is Locate(X) is like integer I; I := Locate(X) 
except subsequent assignments to 1 are forbidden. The types of 
identifiers are never declared. The declaration and calls of param- 
eterless procedures employ the null parameter list, written "( )". 
References (addresses) are dealt with more explicitly. Ref is a 
function which returns a new reference, containing its argument. 
If r is a reference, Val(r) is its contents, and r := e changes its 
contents to e. A set of coercion rules (not given here) serve to insert 
applications of VAL so that, if Count is a reference, 
Count+ 1 means Val( Count) + 1 
I<_ Count means 1< Val(Count) 
Ref(Count) means Ref(Val(Count)) 
and Count(l) means (Val(Count))(l) 
Vectors and n-tuples are subsumed under the more general 
notion of functions. The expressions 
(2,4,6) 
and (~Xif l < X < 3  then 2*X 
else go to Error) 
and Vector(1,3,XX 2*)0 
all denote the same thing: a function Fsuch that F(1) = 2, F(2) = 4, 
F(3) = 6. If Createseal( ) returns a pair, the declaration 
Seal, Unseal is Createseal( ) 
serves to decompose it and bind the components to the two iden- 
tifiers. 
The general form for a (large) GEOANKEN expression is a 
sequence of (0 or more) is-declarations followed by (1 or more) 
expressions (X := y is an expression). 
[d l ; ' ' '  ;d,,;el;... ;e,~] 
The declarations and expressions are evaluated from left to right 
and the value of the whole expression is e~. The (textual) scope of 
the definitions is limited by the brackets. 
To make the programs more readable we write key words of 
GEDANKEN in boldface and capitalize the first letter of identifiers. 
Also variously-shaped brackets are used. Comments are written to 
the right of double slashes (//). 
Received June 1971 ; revised January 1972 
References 
1. Dennis, J. B., and Van Horn, E. Programming semantics for 
multiprogrammed computations. Comm. ACM 9, 3 (Mar. 1966), 
143-155. 
2. Evans, A. PAL--A language designed for teaching program- 
ming linguistics. Proc. ACM 23rd Nat. Conf. 1968, Brandon 
Systems Press, Princeton, N.J., pp. 395-403. 
3. Fischer, A.E., and Jorrand, P. BASEL: The base language 
for an extensible language facility. Rept. CA-6806-2811, Computer 
Associates, Wakefield, Mass., 1968. 
4. Lampson, Butler W. Dynamic protection structures. Proc. 
1969 FJCC. The Thompson Book Co. pp. 27-38. 
5. Landin, P.J. The next 700 programming languages. Comm. 
ACM9, 3 (Mar. 1966), 157-166. 
6. McCarthy, J., et al. LISP 1.5 Programmers' Manual, M.I.T. 
Press, Cambridge, Mass., 1962. 
7. Reynolds, J.C. GEDANKEN--A simple typeless language 
based on the principle of completeness and the reference concept. 
Comm. ,4CM 13, 5 (May 1970), 308-319. 
21 Communications January 1973 
of Volume 16 
the ACM Number 1 

