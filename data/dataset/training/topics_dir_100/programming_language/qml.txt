A functional quantum programming language
Thorsten Altenkirch and Jonathan Grattage
School of Computer Science and IT, Nottingham University
email: {txa,jjg}@cs.nott.ac.uk
Abstract
We introduce the language QML, a functional language
for quantum computations on finite types. Its design is
guided by its categorical semantics: QML programs are
interpreted by morphisms in the category FQC of finite
quantum computations, which provides a constructive se-
mantics of irreversible quantum computations realisable as
quantum gates. QML integrates reversible and irreversible
quantum computations in one language, using first order
strict linear logic to make weakenings explicit. Strict pro-
grams are free from decoherence and hence preserve super-
positions and entanglement â€“ which is essential for quan-
tum parallelism.
1 Introduction
The discovery of efficient quantum algorithms by Shor
[18] and Grover [6] has triggered much interest in the field
of quantum programming. However, it is still a very hard
task to find new quantum algorithms. One of the reasons
for this situation might be that quantum programs are very
low level: they are usually represented as quantum circuits,
or in some combinator language which gives rise to circuits.
Here we attempt to remedy this situation by introducing the
quantum programming language QML, which is based on
high-level constructs known from conventional functional
programming. Though functional (programs are expres-
sions), our language is first order and finitary; all datatypes
are finite. We will discuss possible extensions in the con-
clusions, but we believe that the approach presented here
represents a significant progress towards the goal of a natu-
ral quantum programming language.
We present a semantics of our language by interpreting
terms as morphisms in the category of finite quantum com-
putations FQC, which we introduce here. The FQC se-
mantics gives rise to a denotational semantics in terms of su-
peroperators, the accepted domain of irreversible quantum
computation, and at the same time to a compiler into quan-
tum circuits, an accepted operational semantics for quantum
programs.
As an illustration, one of the basic quantum circuits is
the Hadamard gate, which is usually defined by presenting
its matrix:
had =
1âˆš
2
(
1 1
1 âˆ’1
)
But what does this mean in programming terms? In QML
this operation is implemented by the following program
had : Q2 ( Q2
had x = ifâ—¦ x
then {qfalse | (âˆ’1) qtrue}
else {qfalse | qtrue}
We can read had as an operation which, depending on its
input qubit x, returns one of two superpositions of a qubit.
We can also easily calculate that applying had twice gets us
back where we started by cancelling out amplitudes.
An important feature of quantum programming is the
possibility to create superpositions which have non-local ef-
fects. A simple application of this idea is the algorithm in
figure 1 to determine whether two classical bits, represented
as qubits, are equal, which is based on Deutschâ€™s algorithm
(see [12], pp.32). It exploits quantum parallelism by query-
ing both inputs at the same time; this corresponds to the fact
that the expressions ifâ—¦ a and ifâ—¦ b in our program are not
nested. The famous algorithms by Shor and Grover rely on
a more subtle exploitation of this effect.
The reader may have noticed that we do not insist on
quantum programs being reversible. We will discuss this
further in section 3, by comparing classical and quantum
computation. It turns out that in both cases irreversible
computations can be reduced to reversible ones in a simi-
lar fashion. However, reversibility plays a more central role
in quantum computation due to the fact that forgetting infor-
mation leads to decoherence, which destroys entanglement,
and hence negatively affects quantum parallelism. Thus one
of the central features of our language is control of deco-
herence, which is achieved by keeping track of weakening
through the use of strict linear logic (or just strict logic) and
by offering different if-then-else (or, generally, case) opera-
tors, one that measures the qubit, if , and a second, ifâ—¦, that
doesnâ€™t â€“ but which can only be used in certain situations.
eq : Q2 ( Q2 ( Q2
eq a b = let (x , y) = ifâ—¦{qfalse | qtrue}
then (qtrue, ifâ—¦ a
then ({qfalse | (âˆ’1) qtrue}, (qtrue, b))
else ({(âˆ’1) qfalse | qtrue}, (qfalse, b)))
else (qfalse, ifâ—¦ b
then ({(âˆ’1) qfalse | qtrue}, (a, qtrue))
else ({qfalse | (âˆ’1) qtrue}, (a, qfalse)))
in had x
Figure 1. A variant of Deutschâ€™s algorithm
We hasten to add that this intrinsic decoherence is not re-
lated to the decoherence which is caused by thermal noise
in a hypothetical quantum computer. As one of the referees
has pointed out, control of decoherence is in spirit similar
to Reynoldâ€™s control of interference [13].
2 Related work
There are a number of papers on simulating or integrat-
ing quantum programming within conventional functional
programming, e.g. Mu and Birdâ€™s early proposal on mod-
elling quantum programming in a functional language [11],
Karczmarczukâ€™s use of functional programming to model
quantum systems [9] and Sabryâ€™s proposal to structure em-
bedded quantum programs using virtual values [14]. Yet an-
other approach was suggested by Sanders and Zuliani [22],
which extends the probabilistic guarded command language
[10] by quantum registers and operations on quantum reg-
isters.
Peter Selingerâ€™s influential paper [15] introduces a
single-assignment (essentially functional) quantum pro-
gramming language, which is based on the separation of
classical control and quantum data. This language com-
bines high-level classical structures with operations on
quantum data, and has a clear mathematical semantics in
the form of superoperators. Quantum data can be manipu-
lated by using unitary operators or by measurement, which
can affect the classical control flow. Recently, Selinger and
Valiron [17] have presented a functional language based on
the classical control and quantum data paradigm.
Selinger and Valironâ€™s approach is in some sense com-
plementary to ours: they use an affine type system (no con-
traction), while we use a strict system (no weakening). The
lack of contraction is justified by the no-cloning property
of quantum states. However, this does not apply to our ap-
proach, since we model contraction by sharing not by copy-
ing - this is also used in [4]. Indeed, also classical program-
ming languages do not implement contraction by copying
data but by sharing via pointers.
Andre van Tonder has proposed a quantum Î»-calculus
incorporating higher order [20, 19] programs, however he
is not considering measurements as part of his language. In
[19] he suggests a semantics for a strict higher order quan-
tum language based on vector bundles. At the current time
it is not clear to us, whether the details of this construction
work out.
Abramsky and Coecke [1] have investigated a categor-
ical semantics for quantum protocols using the compact
closed structure of the category of finite dimensional Hilbert
spaces. They suggest that their semantics may be relevant
for type systems for quantum programming language. It
remains to be seen how this relates to our work, since our
approach does not exploit compact closure.
All the previous approaches adopt a basically combina-
tory approach to quantum data: operations on quantum data
are given by combinators implementing unitary operators.
We believe that our work is novel in that we are proposing
high-level quantum control structures, i.e. we are aiming at
quantum control and quantum data.
3 Finite classical and quantum computation
It is frequently emphasised that quantum computation
relies on reversibility because quantum physics models re-
versible processes. This is true, but the same holds for clas-
sical computation â€” whether we base our notion of compu-
tation on Newtonian physics or Maxwellian electrodynam-
ics, the underlying physical processes are reversible for a
closed system. Hence we should explain irreversible classi-
cal computation based on a reversible mechanism. Here, we
will develop a picture which applies to classical and quan-
tum computation. This makes it easy to identify the essen-
tial differences and also guides the design of QML which re-
alises structures common to both computational paradigms
by syntactic constructs established in classical functional
programming.
We introduce the category FQC of finite quantum com-
putations and, for purposes of comparison, the category
FCC of finite classical computations1. We will interpret
1FCC may be viewed as a categorical account of a finite version of
QML programs by FQC morphisms. It is straightforward
to identify a classical sublanguage of QML which can be
interpreted in FCC; however we will not carry this out in
detail.
Objects of both categories are finite sets, for which we
use the letters A,B,C. While classical computations are
carried out on the elements of those sets, quantum compu-
tations take place in finite dimensional Hilbert spaces; we
write CA for the space generated by A, whose elements are
functions 2. A reversible finite computation, that is a closed
computational system, is modelled by a reversible operation
Ï†, which is a bijection of finite sets in the classical case,
and a unitary operator on the Hilbert spaces in the quantum
case. We write A (unitary B for the set of unitary operators
from the space generated by A to the space generated by
B, which in the finite-dimensional case correspond exactly
to norm-preserving linear isomorphisms. The initial state
of a computation is divided into the input A and the initial
heap H , and the final state into the output B and garbage
G; using cartesian product (Ã—) in the classical and tensor
product (âŠ—) in the quantum case. To actually perform a
computation we also need a heap initialisation constant h,
which intuitively sets all memory cells in a defined state,
e.g. 0. In the classical case this is just an element of the set
h âˆˆ H , while in the quantum case it is an element of the
vector space h âˆˆ CH . Such a computational system can be
visualised by the following diagram:
A B
Ï†
h

H G

Note that in the above diagram heap inputs are ini-
tialised with a `, and garbage outputs are terminated with
a a. To summarise, given finite sets A,B a morphism
(H,h,G, Ï†) âˆˆ FCCAB is given by:
â€¢ a finite set of initial heaps H ,
â€¢ an initial heap h âˆˆ H ,
â€¢ a finite set of garbage states G,
â€¢ a bijection Ï† âˆˆ AÃ—H ' B Ã—G,
while a morphism (H,h,G, Ï†) âˆˆ FQCAB is given by
â€¢ a finite set H , the basis of the space of initial heaps,
â€¢ a heap initialisation vector h âˆˆ CH ,
â€¢ a finite set G, the basis of the space of garbage states,
Bennetâ€™s results [5].
2CA gives rise to a Kleisli structure, [2], here bind is realised by matrix
multiplication. Its Kleisli category is the category of finite dimensional
vector spaces.
â€¢ a unitary operator Ï† âˆˆ AâŠ—H (unitary B âŠ—G.
Given two computational systems we can compose them by
combining initial and final heaps:
A
Ï†Î±
B
Ï†Î²
C
HÎ±

>>
>>
>>
88
88
8 GÎ±

HÎ²

      
 GÎ²
Ï†Î²â—¦Î±
More formally, given the morphisms Î± and Î²:
Î± = (HÎ±, hÎ±, GÎ±, Ï†Î±) âˆˆ FCCAB
Î² = (HÎ² , hÎ² , GÎ² , Ï†Î²) âˆˆ FCCBC
the composite morphism Î² â—¦ Î± = (H,h,G, Ï†) is given by:
H = HÎ± Ã—HÎ²
h = (hÎ±, hÎ²)
G = GÎ± Ã—GÎ²
Ï† = (GÎ± Ã— Ï†Î²) â—¦ (HÎ² Ã— Ï†Î±)
Note that we have omitted some obvious symmetric
monoidal isomorphisms for Ã— from the definition of Ï†. We
leave it to the reader to construct the identity computation.
Analogously, given morphisms
Î± = (HÎ±, hÎ±, GÎ±, Ï†Î±) âˆˆ FQCAB
Î² = (HÎ² , hÎ² , GÎ² , Ï†Î²) âˆˆ FQCBC
the composite Î² â—¦ Î± = (H,h,G, Ï†) is given by
H = HÎ± âŠ—HÎ²
h = hÎ± âŠ— hÎ²
G = GÎ± âŠ—GÎ²
Ï† = (GÎ± âŠ— Ï†Î²) â—¦ (HÎ² âŠ— Ï†Î±)
Note thatâŠ— is actuallyÃ— on the underlying finite sets, since
CA âŠ—CB ' CAÃ—B . However, we shall use the tensor sym-
bol because we interpret the constructed set as the basis of
the tensor product of the associated vector spaces. As in the
classical case we omit symmetric monoidal isomorphisms
for âŠ—.
We consider two computational systems as extensionally
equal if they map the same inputs to the same outputs. That
is, for FCC, a morphism Î± = (H,h,G, Ï†) âˆˆ FCCAB
gives rise to a function on finite sets UFCC Î± âˆˆ Aâ†’ B by
AÃ—H
Ï†
// B Ã—G
Ï€1

A
(âˆ’,h)
OO
UFCC Î±
// B
How do we do this for FQC? There is no sensible pro-
jection operation on tensor products. Indeed, forgetting a
part of a pure state (i.e. a vector of the Hilbert space) leads
to a mixed state, which is modelled by a density operator
Î´ âˆˆ A ( A. This is a positive operator, whose eigen-
values are interpreted as the probability that the system is
in the corresponding eigenstate. Extensionally, quantum
computations give rise to completely positive mappings,
also called superoperators, see [7], pp. 136 or [15] for
details. Given Î± = (H,h,G, Ï†) âˆˆ FQCAB we write
Ï†Ì‚ âˆˆ A âŠ— H (super B âŠ— G for the associated superop-
erator Ï†Ì‚ Ï = Ï† â—¦ Ï â—¦ Ï†â€ . The heap initialisation vector
h âˆˆ CH can be lifted to a density matrix hÌƒ âˆˆ DensH by
hÌƒ = |hã€‰ ã€ˆh|. Combining this with the partial trace operator
trG âˆˆ B âŠ—G (super B we obtain UFQC Î± âˆˆ A (super B
by
AâŠ—H
Ï†Ì‚
// B âŠ—G
trG

A
âˆ’âŠ—hÌƒ
OO
UFQC Î±
// B
in the category of superoperators.
We say that two computations Î±, Î² âˆˆ F AB are exten-
sionally equal (Î± =ext Î²), if the induced maps are equal;
UF Î± = UF Î² where F âˆˆ {FCC,FQC}. We define the
homsets of FCC,FQC as the quotients of the underlying
representation by extensional equality. It is straightforward
to verify that composition respects extensional equality.
As a consequence of our definition we obtain that the
assignment of maps to computations gives rise to forget-
ful functors UFCC âˆˆ FCC â†’ FinSet and UFQC âˆˆ
FQC â†’ Super. Both functors are full 3 and faithful.
Hence, our categories FCC and FQC can be viewed just
as different presentations of FinSet and Super. However,
going via FCC and FQC has the benefit that we get an
implementation of our programs as reversible circuits in the
classical case and quantum circuits in the quantum case.
An important class of morphisms are the ones which do
not produce garbage, i.e. where G = 1, they give rise sub-
categories FCCâ—¦,FQCâ—¦ of strict morphisms. All strict
maps are isometries, i.e. linear maps such that ã€ˆf v|f wã€‰ =
ã€ˆv|wã€‰. However, not all isometries arise from strict compu-
tations. 4
While FQC and FCC are very similar indeed, the fact
that FQC is based on wave mechanics enables non-local
interaction which is exploited in quantum programming.
However, there is also a new challenge: the possibility of
decoherence. Let Î´ âˆˆ 2 â†’ 2 Ã— 2 where 2 = {0, 1}
3In the case of FQC fullness is a consequence of Krausâ€™ decomposi-
tion theorem.
4This is only due to dimensional reasons, indeed in the domain of our
interpretation where all spaces are of a size 2n the functor is full.
be defined as Î´ x = (x, x); which can be easily realised
by a CNOT gate. The same implementation gives rise to
Q2 ( Q2 âŠ— Q2, writing Q2 for the object 2 in FQC. In
either case, we can compose this with Ï€1 âˆˆ 2 Ã— 2 â†’ 2 (or
Ï€1 âˆˆ Q2 âŠ— Q2 (super Q2) which leads to the following
picture:
2 â€¢ 2
0
  
Ï†Î´ Ï†Ï€1
Clearly, classically we have just defined an inefficient ver-
sion of the identity Ï€1 â—¦ Î´ = I; we copy a bit and then throw
the copy away. However, the situation is quite different in
the quantum case: while the implementation is given by the
same diagram by replacing classical reversible circuits with
quantum circuits, the composition is not the identity, it is
a measurement operation. That is, if we input a pure state
like R = { 1âˆš
2
|0ã€‰ + 1âˆš
2
|1ã€‰} the output is a mixed state
1
2{|0ã€‰}+
1
2{|1ã€‰} corresponding to a random qubit. We have
lost the advantage of quantum computation and are back in
the world of classical probabilistic computations.
As a consequence of this observation we draw the con-
clusion that one of the main issues a quantum programming
language has to address is the control of decoherence. This
is somehow the opposite of the common view which in-
sists that the no cloning theorem outlaws contraction. We
observe that the implementation of Î´ shares a qubit, but it
doesnâ€™t clone it; considering R again we obtain the EPR
state { 1âˆš
2
|00ã€‰+ 1âˆš
2
|11ã€‰} after executing only Î´. We claim
that this is a natural explanation of contraction because it
is completely uniform in both the classical and the quan-
tum case. Indeed, classical functional languages do not
implement contraction by copying data either. Î´ is strict
and therefor maps pure states to pure states. In contrast,
operations like Ï€1 are interpreted by a non-trivial partial
trace which introduces decoherence. Hence it is weakening
which deserves our attention, not contraction.
4 QML: Rules and semantics
We introduce here the typing rules and the denotational
semantics of QML, the latter gives rise to a compilation of
QML programs to quantum circuits. The compilation is pre-
sented diagramatically, implementing it requires some care
to make sure that the wires generated by subcomputations
match as intended.
4.1 Typing rules
We will only present the typed syntax of QML, which
is based on strict linear logic, the untyped syntax is im-
plicit in the typed one. We do allow explicit weakenings
annotating a term by by a context. This leads to an unam-
biguous type assignment. Any weakening will be translated
into the use of a non-trivial partial trace, and hence deco-
herence in the denotational semantics. Another source of
decoherence is the use of case, or its special instance if-
then-else. We make this explicit by introducing two dif-
ferent case-operators: one which observes a qubit and thus
leads to decoherence; and another which is free of deco-
herence but requires that we derive that the two alternatives
live in orthogonal spaces. For this purpose we introduce
a judgement t âŠ¥ u. Another novelty of our language is
a termâ€“former to create superpositions; we can,for exam-
ple, write {(qtrue, qtrue) | (qfalse, qfalse)}, to create an
EPR state. Note that we are ignoring the factor 1âˆš
2
which
can be automatically inserted by the compiler. The con-
struction of a superposition also requires to show that the
participating terms are orthogonal.
Our basic typing judgements are Î“ ` t : Ïƒ meaning that
t has type Ïƒ under context Î“. and Î“ `â—¦ t : Ïƒ for strict terms.
We embed `â—¦ in `:
Î“ `â—¦ t : Ïƒ
Î“ ` t : Ïƒ
To avoid repetition, we also use the schematic judgements
Î“ `a t : Ïƒ where a âˆˆ {âˆ’, â—¦}. We use Ïƒ,Ï„ and Ï to quantify
over types, which are generated by 1, Ïƒ âŠ• Ï„, Ïƒ âŠ— Ï„ . Qubits
are defined as Q2 = 1âŠ• 1.
Î“ is a context, i.e. a function from a finite set of variables
dom Î“ into the set of types. We write contexts as Î“ = x1 :
Ï„1, . . . , xn : Ï„n and use â€¢ for the empty context. Î“, x : Ï„
is the context Î“ extended by x : Ï„ . This operation is only
defined if Î“ does not already assign a type to x.
For the additive rules, we introduce the operator âŠ— map-
ping pairs of contexts to contexts:
Î“, x : Ïƒ âŠ—âˆ†, x : Ïƒ = (Î“âŠ—âˆ†), x : Ïƒ
Î“, x : Ïƒ âŠ—âˆ† = (Î“âŠ—âˆ†), x : Ïƒ if x /âˆˆ dom âˆ†
â€¢ âŠ—âˆ† = âˆ†
This operation is partial â€“ it is only well-defined if the two
contexts do not assign different types to the same variable.
4.2 Denotational semantics
We assign to every type Ïƒ the number |Ïƒ| which is the
size of a quantum register needed to store elements of Ïƒ, we
also interpret expressions of the form Ïƒ t Ï„ :
|1| = 0
|Ïƒ t Ï„ | = max {|Ïƒ|, |Ï„ |}
|Ïƒ âŠ• Ï„ | = |Ïƒ t Ï„ |+ 1
|Ïƒ âŠ— Ï„ | = |Ïƒ|+ |Ï„ |
The interpretation of a type is the FQC object of quan-
tum registers of the right size: JÏƒK = Q2|Ïƒ|. Contexts
Î“ = x1 : Ï„1, . . . , xn : Ï„n are interpreted as the tensor prod-
uct of their components JÎ“K = JÏ„1KâŠ— JÏ„2KâŠ— . . .âŠ— JÏ„nK. A
typing derivation Î“ ` t : Ïƒ is interpreted as an FQC mor-
phism JtK âˆˆ FQC JÎ“K JÏƒK, correspondingly, Î“ `â—¦ t : Ïƒ is
interpreted as JtK âˆˆ FQCâ—¦ JÎ“K JÏƒK.
The interpretation of orthogonality is more involved.
Given Î“ `â—¦ t : Ïƒ and Î“â€² `â—¦ u : Ïƒ where |Î“| = |Î“â€²|
we interpret a derivation t âŠ¥ u as a structure (S, f, g, Ïˆ)
where S is an object of FQC, l âˆˆ FQC JÎ“KS, g âˆˆ
FQC JÎ“â€²KS such that JtK = Ï† â—¦ (qtrue âŠ— âˆ’) â—¦ f and
JuK = Ï† â—¦ (qfalseâŠ—âˆ’) â—¦ g.
To interpret the operator âŠ— on contexts we define an
FQCâ—¦ morphism CÎ“,âˆ† âˆˆ FQCâ—¦ JÎ“âŠ—âˆ†K (JÎ“KâŠ— Jâˆ†K)
Î“âŠ—âˆ†
Ï†C
Î“
HÎ“,âˆ†

âˆ†
by induction over the definition of Î“ âŠ— âˆ†: If a variable
x : Ïƒ appears in both contexts we have to use Î´Ïƒ âˆˆ
FQCâ—¦ JÏƒK (JÏƒK âŠ— JÏƒK) which generalises Î´2, discussed
earlier, by applying it in parallel to all qubits. All the
other cases can be dealt with by applying monoidal isomor-
phisms. Similarly, we define an explicit weakening operator
WÎ“,âˆ† âˆˆ FQC JÎ“âŠ—âˆ†K JÎ“K.
4.3 Structural rules
We start with the strict variable rule and the non-strict
weakening and their interpretations
var
x : Ïƒ `â—¦ x : Ïƒ
Î“ ` t : Ïƒ
weak
Î“âŠ—âˆ† ` tdom âˆ† : Ïƒ
Ïƒ Ïƒ Î“âŠ—âˆ†
Ï†WÎ“,âˆ†
Î“
Ï†t
Ïƒ
55
55 Gt

Ht

				 GÎ“âˆ’âˆ†
Next, we introduce a let-rule which is also the basic vehicle
to define first order programs.
Î“ `a t : Ïƒ
âˆ†, x : Ïƒ `b u : Ï„
let
Î“âŠ—âˆ† `aub let x = t in u : Ï„
â—¦ u â—¦ = â—¦ and âˆ’ otherwise. We leave the condition that
Î“ âŠ— âˆ† is defined as an implicit precondition of this and
subsequent rules using âŠ—. The interpretation of the let-rule
is given by the following circuit:
Î“âŠ—âˆ†
Ï†C
Î“
99
99 âˆ†
Ï†uHÎ“,âˆ†

âˆ†

Ï†t
Ïƒ Ï„
Ht

99
99
9
33
33 Gt

Hu


 Gu

Weakenings can affect the meaning of a program. As an
example consider:
y : Q2 ` let x = y in x{} : Q2
This program will be interpreted as the identity circuit, in
particular it is decoherence-free. However, consider
y : Q2 ` let x = y in x{y} : Q2
This program is interpreted by a circuit equivalent to the one
corresponding to Ï€1 â—¦ Î´ shown earlier; hence it introduces a
measurement.
4.4 Rules for âŠ—
The rules for 1, âŠ— are the standard rules from linear
logic. In the case of 1 instead of an explicit elimination
rule we allow implicit weakening:
1âˆ’ intro
â€¢ `â—¦ () : 1
Î“, x : 1 `a t : Ïƒ
1âˆ’ weak
Î“ `a t : Ïƒ
The interpretation of the rules for 1 in terms of circuits is
invisible, since 1 doesnâ€™t carry any information. The inter-
pretation of the rules for âŠ— is more interesting â€” the intro-
duction rule simply merges the components
Î“ `a t : Ïƒ âˆ† `a u : Ï„
âŠ—âˆ’ intro
Î“âŠ—âˆ† `a (t, u) : Ïƒ âŠ— Ï„
Î“âŠ—âˆ†
Ï†C
Î“
Ï†t
Ïƒ Ïƒ
HÎ“,âˆ†

âˆ†
99
99
77
77
7 Ï„
Ht


Ï†u
Ï„
 Gt

Hu

Gu

The interpretation of the elimination rule is similar to the
let-rule:
Î“ `a t : Ïƒ âŠ— Ï„
âˆ†, x : Ïƒ, y : Ï„ `b u : Ï
âŠ—âˆ’ elim
Î“âŠ—âˆ† `aub let (x, y) = t in u : Ï
Î“âŠ—âˆ†
Ï†C
Î“
99
99 âˆ†
Ï†u
HÎ“,âˆ†

âˆ†

Ï†t
Ïƒ
Ï„ Ï
Ht

99
99
9
33
33 Gt

Hu


 Gu

As an example, here is a simple program which swaps two
qubits:
p : Q2 âŠ—Q2 ` let (x, y) = p in (y{}, x{}) : Q2 âŠ—Q2
Again it is important to mark the variables with the empty
set of variables. The alternative program
p : Q2 âŠ—Q2 ` let (x, y) = p in (y{p}, x{p}) : Q2 âŠ—Q2
would measure the qubits while swapping them.
4.5 Rules for âŠ•
We represent values in Ïƒ âŠ• Ï„ as words of fixed length,
as in classical computing. Unfolding our type interpretation
we have that JÏƒâŠ•Ï„K = Q2âŠ—JÏƒtÏ„K where JÏƒtÏ„K can store
a value either of JÏƒK or JÏ„K. To adjust the size we use an
easily definable padding operator PÏƒtÏ„ âˆˆ FQC JÏƒK JÏƒtÏ„K,
which simply sets unused bits to 0.
The introduction rules for âŠ• are the usual classical rules
for +; note that they preserve strictness.
Î“ `a s : Ïƒ
+ intro1
Î“ `a inl s : Ïƒ âŠ• Ï„
Î“
Ï†s
Ïƒ
Ï†PÏƒtÏ„
Hs

==
== ÏƒtÏ„
Htâˆ’s


33
33 Q2
Q2 X
 Gs

Î“ `a t : Ï„
+ intro2
Î“ `a inr t : Ïƒ âŠ• Ï„
Î“
Ï†t
Ï„
Ï†PÏ„tÏƒ
Ht

77
77
7 ÏƒtÏ„
Htâˆ’s


33
33 Q2
Q2

 Gt

where X is negation.
We define qtrueX = inl ()X : Q2 and qfalseX =
inr ()X : Q2. To be able to interpret case expressions
we introduce a biconditional operation on unitary operators.
Given Ï†, Ïˆ âˆˆ A (unitary B we construct
Ï†|Ïˆ âˆˆ Q2 âŠ—A (unitary Q2 âŠ—B
by the following matrix
Ï†|Ïˆ (true, a) (true, b) = Ï†a b
Ï†|Ïˆ (false, a) (false, b) = Ïˆ a b
Ï†|Ïˆ (x, a) (y, b) = 0 everywhere else
As already indicated we have two different elimination rules
â€” we begin with the one which measures a qubit, since it
is basically the classical rule modulo additivity of contexts.
Î“ ` c : Ïƒ âŠ• Ï„
âˆ†, x : Ïƒ ` t : Ï
âˆ†, y : Ï„ ` u : Ï
âŠ•âˆ’ elim
Î“âŠ—âˆ† ` case c of {inl xâ‡’ t | inr y â‡’ u} : Ï
We have JtK âˆˆ FQC Jâˆ† âŠ— ÏƒK JÏK and JuK âˆˆ
FQC Jâˆ†âŠ— Ï„K JÏK. By padding the input we turn them into
dJtKe, dJuKe âˆˆ FQC Jâˆ†âŠ— (Ïƒ t Ï„)K JÏK. There is no reason
why the size of the associated heap and garbage should be
the same, however, we have that Ht +Gu = Hu +Gt and
hence we can stretch both maps uniformly to H = HttHu
and G = Gt tGu giving rise to Ï†dJtKe and Ï†dJuKe of identi-
cal dimensions. Hence we can apply the choice operator to
construct Ïˆ = Ï†dJtKe|Ï†dJuKe, and with some plumbing we
obtain:
Î“âŠ—âˆ†
Ï†C
Î“
99
99
Ïˆ
HÎ“,âˆ†

âˆ†

Ï†c
Ïƒ t Ï„ Ï
Q2 Q2

Hc

CC
CC
C G
Htâˆ’u

{{{{{ Gc

We can derive if-then-else as
if b then t else u =
case b of {inl â‡’ t | inr â‡’ u }
and use this to implement a form of negation:
mnot : Q2 ( Q2
mnot x = if x then qfalse else qtrue
However, this program will measure the qubit before negat-
ing it. If we want to avoid this we have to use the
decoherence-free version of case, which relies on the or-
thogonality judgement: t âŠ¥ u, which is defined for terms in
the same type and context Î“ ` t, u : A. We will introduce
the rules for orthogonality later. Intuitively, t âŠ¥ u holds if
the outputs t and u are always orthogonal, e.g. we will be
able to derive qtrue{} âŠ¥ qfalse{}. Hence, we introduce
the strict case by:
Î“ `a c : Ïƒ âŠ• Ï„
âˆ†, x : Ïƒ `â—¦ t : Ï
âˆ†, y : Ï„ `â—¦ u : Ï t âŠ¥ u
âŠ•âˆ’ elimâ—¦
Î“âŠ—âˆ† `a caseâ—¦ c of
{inl xâ‡’ t | inr y â‡’ u} : Ï
It turns out that there is no sensible way to define caseâ—¦ if
Ïƒ and Ï„ have different sizes. Hence we define the orthogo-
nality judgement in a way that it only succeeds, if |Ïƒ| = |Ï„ |
and hence JÏƒK = JÏ„K.
To define the interpretation, w e have to exploit the data
from the orthogonality judgement Jt âŠ¥ uK = (S, f, g, Ï†)
where Ï† âˆˆ S âŠ—Q2 (unitary JÏK and f, g âˆˆ FQCâ—¦ (Jâˆ†K âŠ—
JÏƒK)S. We note that both morphisms must have the same
heap and hence we can construct
Ï†f |Ï†g âˆˆ FQCâ—¦ (Q2 âŠ— Jâˆ†KâŠ— JÏƒK) (Q2 âŠ— S).
Now, the main observation is that we just have to apply the
unitary operator Ï†tâŠ¥u to make the qubit disappear, leading
to the following diagram:
Î“âŠ—âˆ†
Ï†C
Î“
77
7
Ï†f |Ï†g
HÎ“,âˆ†

âˆ†

Ï†c
Ïƒ t Ï„ S
Ï†tâŠ¥u
Ï
Q2 Q2
Hc

DD
DD
Hfâˆ’g

{{{{{ Gc

Note that we only allow strict terms in the branches of a
strict case. In a previous draft of this paper we tried to
be more liberal, however, this causes problems because the
qubit we are branching over can be indirectly measured
by the garbage. This problem was pointed out by Peter
Selinger.
Using the decoherence-free version ifâ—¦ we can imple-
ment standard reversible and hence quantum operations
such as qnot :
qnot : Q2 ( Q2
qnot x = ifâ—¦ x
then qfalse
else qtrue
and the conditional not cnot :
cnot : Q2 ( Q2 ( Q2 âŠ—Q2
cnot c x = ifâ—¦ c
then (qtrue, qnot x )
else (qfalse, x )
and finally the Toffolli operator which is basically a condi-
tional cnot :
toff : Q2 ( Q2 ( Q2 ( Q2 âŠ— (Q2 âŠ—Q2)
toff c x y = ifâ—¦ c
then (qtrue, cnot x y)
else (qfalse, (x , y))
4.6 Superpositions
There is a simple syntactic translation we use to reduce
the superposition operator to the problem of creating an ar-
bitrary 1-qubit state:
Î“ `â—¦ t, u : Ïƒ t âŠ¥ u
||Î»||2 + ||Î»â€²||2 = 1 Î», Î»â€² 6= 0
Î“ `â—¦ {(Î»)t | (Î»â€²)u} : Ïƒ
â‰¡ ifâ—¦ {(Î»)qtrue | (Î»â€²)qfalse}
then t else u
The algorithm for the preparation of the one-qubit state to
a given degree of precision (which is a parameter of the
compilation) can be obtained from the one-qubit case of the
Kitaev-Solovay theorem, see [12], page 616-624.
4.7 Orthogonality
Given Î“ ` t : Ïƒ and âˆ† ` u : Ïƒ where |âˆ†| = |Î“|
we define t âŠ¥ u by the following rules. The idea of
t âŠ¥ u is that there is a boolean observation which tells
the two terms apart in every environment. The interpreta-
tion Jt âŠ¥ uK = (S, f, g, Ïˆ) is defined by induction over the
derivations. We present here a sound but incomplete for-
malisation of orthogonality, achieving completeness is sub-
ject of further work.
Î“ `â—¦ t : Ïƒ Î“ `â—¦ u : Ï„
inl t âŠ¥ inr u inr t âŠ¥ inl u
Here Ï = Ïƒ âŠ• Ï„ , we set S = Ïƒ t Ï„ . In both cases f is
obtained by interpreting t combined with padding and r is
given by the interpretation of u and padding. The circuits
for Ïˆ for these rules are given by:
S
Q2
Ï
ï£¼ï£½ï£¾ S
Q2 X
Ï
ï£¼ï£½ï£¾
t âŠ¥ u
inl t âŠ¥ inl u inr t âŠ¥ inr u
Let Î“ `â—¦ inl t, inl u : Ïƒ âŠ• Ï„ and let (S, f, g, Ïˆ) be the
interpretation of t âŠ¥ u. From this data we are constructing
the interpretation of inl t âŠ¥ inl u as (S, f â€², gâ€², Ïˆâ€²). We
set Sâ€² = S âŠ— Q2 âŠ—H where H is the heap needed by inl .
We construct f â€² and gâ€² by applying inl to l, r on the level
of semantics using the appropriate part of Sâ€² as the heap. Ïˆ
is given by the following diagram:
S
Ïˆ
Sâ€² Q2
77
77
7
77
77
7
ÏˆPÏƒtÏ„
H

==
==

Q2

Ï
ï£¼ï£½ï£¾
ï£±ï£´ï£´ï£²ï£´ï£´ï£³
The second rule for inr is done symmetrically.
t âŠ¥ u
(t, v) âŠ¥ (u,w) (v, t) âŠ¥ (w, u)
As above, let Î“ `â—¦ (t, v), (u,w) : Ïƒ âŠ— Ï„ and let (S, f, g, Ïˆ)
be the interpretation of t âŠ¥ u to construct the interpretation
of (t, v) âŠ¥ (u,w) as (Sâ€², f â€², gâ€², Ïˆâ€²). We set Sâ€² = SâŠ— Ï„ and
construct f â€² and gâ€² by pairing with v ,w , semantically.
The definition of Ïˆâ€² is given by the following diagram:
S
ÏˆSâ€²
Ï„
44
44 Ïƒ
Q2




 Ï„
Ï
ï£±ï£²ï£³ ï£¼ï£½ï£¾
t âŠ¥ u Î»âˆ—0Îº0 = âˆ’Î»âˆ—1Îº1
{(Î»0)t | (Î»1)u} âŠ¥ {(Îº0)t | (Îº1)u}
As before, assume as given the interpretation of t âŠ¥ u as
(S, f, g, Ïˆ). We construct the interpretation of the conclu-
sion as (S, f, g, Ïˆâ€²) where Ïˆâ€² is given as
S
Ïˆ
Ï
Q2 Ï†
using the rotation Ï† âˆˆ Q2 (unitary Q2 given by
Ï† =
(
Î»0 Î»1
Îº0 Îº1
)
4.8 Programs
So far we have introduced a language of expressions. It
is straightforward to extend this to a notion of first order
programs. E.g. we consider a program Î£ to be a sequence
of function definitions of the form F Î“ = t : Ïƒ, we have to
parameterise every judgement by Î£ and require that Î“ `Î£
t : Ïƒ for the definition to be a wellformed extension of Î£.
We also have to introduce a rule for function-application
which can just be translated into an iterated let-expression.
5 Conclusions and further work
We have introduced a language for finite quantum pro-
grams which uniformly extends a finitary classical lan-
guage. The classical part of our language may be of interest
for its own sake because it introduces a natural way to com-
pile functional terms into space efficient reversible circuits,
as we avoid creating unnecessary garbage. This uniformity
is one of the main design principles of our language, which,
we hope, makes it a natural vehicle to express quantum pro-
gramming and to develop quantum thinking.
We are currently implementing a compiler for QML
in Haskell. The compiler produces a representation of
quantum circuits which can be simulated (inefficiently, of
course) by our own simulator or by using a standard simu-
lator for quantum gates.
There are other design ideas for quantum programming
languages. A potential criticism of our approach is that we
leave contractions implicit, which is an operation which de-
pends on the choice of basis. However, our type assignment
system clearly fixes the places where contractions have to
happen, and moreover, and we believe more importantly, it
fixes the places where projections, or tracing, is happening.
A central feature of any quantum programming language
seems control of decoherence.
Having pointed this out it seems that decoherence is
something you always want to minimise. It is straightfor-
ward to design an inference algorithm which infers weak-
enings tdom Î“ such that decoherence is minimised. Maybe
this should be the default, which can be overridden, if the
programmer wants to enforce measurement.
We would like to have an orthogonality judgement which
is complete with respect to the denotational semantics. One
of the referees commented that we would need an inner
product judgement to achieve this. We plan to explore this
proposal in future work.
The restriction that caseâ—¦ is only allowed for balanced
coproducts is a direct reaction to the comments of the same
referee who pointed out that our previous approach, which
involved padding the data, is problematic. Indeed, this prob-
lem seems unfixable, if we branch overQ1âŠ—Q2 the garbage
which is created by padding may indirectly measure the
qubit we are branching over. Consequently, this approach
would not be compositional and hence should be rejected.
The inability to deal with quantum control over arbitrary
coproducts is a consequence of the fact that while we deal
with quantum data and control, the structure, i.e. the mem-
ory allocation, of our data is classical. One way to over-
come this limitation would be to use an operational seman-
tics which employs a quantum memory allocation. Such a
semantics would have to exploit an infinite state space, and
it is questionable whether such a system is physically plau-
sible. Another direction, which seems more feasible, would
be to index quantum structures by classical values at com-
pile time.
We have some doubts as to whether the understanding of
general recursion and partiality in quantum programming is
essential, because partiality is only interesting for systems
with infinite state spaces. Moreover, it is not clear how to
observe the termination of such a hypthothetical quantum
program of unknown runtime without disturbing the com-
putation.
Higher order programming would be a worthwhile ad-
dition to reflect the way many quantum algorithms are pre-
sented: e.g. the Quantum Fourier Transform can be parame-
terised by a function on quantum words. Recently, Selinger
investigated this problem [16] and it seems that currently
no canonical higher order structure on Super is known.
We are investigating whether the category of presheaves
over Super would provide a sound denotational model for
higher order quantum computation. This semantics would
employ Dayâ€™s construction to interpret tensorproducts.
Another line of work is to reap the benefits of the fact that
our language uses high level constructs, and develop high
level reasoning principles for QML programs. To achieve
this our next goal is to give a direct translation of QML to
superoperators which factors through the FQC semantics
presented here. This translation will be based on the im-
plementation of superoperators using arrows [8] in Haskell
[21]. A direct consequence of this construction is that the
translation presented here is compositional with respect to
the extensional equality.
In joint work with Sabry and Vizzotto we are currently
developing an equational theory for QML, an algebra for
quantum programming, which is sound and complete, with
repect to the denotational semantics suggested here. Since
the completeness proof relies on inverting evaluation, such
a proof also gives rise to normalisation; exploiting the ap-
proach developed in [3] for a classical system.
Acknowledgements
We would like to acknowledge interesting discussions on
the subject of this paper with Slava Belavkin, Martin Hof-
mann, Conor McBride, Alex Simpson and Thomas Stre-
icher. Amr Sabry and Juliana Vizotti provided extensive
feedback on previous drafts of this paper. Peter Selinger
pointed out a serious flaw in the definition of caseâ—¦ and
refuted our conjecture that strict maps classify monos in
Super. We would like to thank the anonymous referees
for their valuable feedback, especially one of the referees,
who provided very detailed and extremely useful technical
comments on our work.
References
[1] S. Abramsky and B. Coecke. A categorical semantics of
quantum protocols. In Proceedings of the 19th IEEE confer-
ence on Logic in Computer Science (LiCSâ€™04), 2004.
[2] T. Altenkirch and B. Reus. Monadic presentations of lambda
terms using generalized inductive types. In Computer Sci-
ence Logic, volume 1683, pages 453â€“468. Springer-Verlag,
1999.
[3] T. Altenkirch and T. Uustalu. Normalization by evaluation
for Î»â†’2. In Functional and Logic Programming, number
2998 in LNCS, pages 260 â€“ 275, 2004.
[4] P. Arrighi and G. Dowek. Operational semantics for a formal
tensorial calculus, 2004. Draft proceedings of the 2nd Inter-
national Workshop on Quantum Programming Languages.
[5] C. H. Bennett. Logical reversibility of computation. IBM
Journal of Research and Development, 17(6):525â€“532,
1973.
[6] L. Grover. Quantum mechanics helps in searching for a nee-
dle in a haystack. Physics Review Letters, 79(2):325â€“328,
1997.
[7] M. Hirvensalo. Quantum Computating. Springer-Verlag
NewYork, Inc., 2001.
[8] J. Hughes. Generalising monads to arrows. Science of Com-
puter Programming, 37:67â€“111, May 2000.
[9] J. Karczmarczuk. Structure and interpretation of quantum
mechanics: a functional framework. In Proceedings of the
ACM SIGPLAN workshop on Haskell, pages 50â€“61. ACM
Press, 2003.
[10] C. Morgan and A. McIver. pgcl: Formal reasoning for ran-
dom algorithms. South African Computer Journal, 1999.
[11] S.-C. Mu and R. S. Bird. Quantum functional program-
ming. In 2nd Asian Workshop on Programming Languages
and Systems, 2001.
[12] M. Nielsen and I. Chuang. Quantum Computation and
Quantum Information. Cambridge University Press, Cam-
bridge, 2000.
[13] J. C. Reynolds. Syntactic control of interference. In Pro-
ceedings of the 5th ACM SIGACT-SIGPLAN symposium on
Principles of programming languages, pages 39â€“46. ACM
Press, 1978.
[14] A. Sabry. Modeling quantum computing in haskell. In Pro-
ceedings of the ACM SIGPLAN workshop on Haskell, pages
39â€“49. ACM Press, 2003.
[15] P. Selinger. Towards a quantum programming language.
Mathematical Structures in Computer Science, 14(4):527â€“
586, 2004.
[16] P. Selinger. Towards a semantics for higher-order quantum
computation. Proceedings of the International Workshop on
Quantum Programming Languages, pages 127â€“143, 2004.
[17] P. Selinger and B. Valiron. A lambda calculus for quantum
computation with classical control. To appear in Proceed-
ings of the International Conference on Typed Lambda Cal-
culi and Applications, 2005.
[18] P. Shor. Algorithms for quantum computation: discrete log-
arithms and factoring. In Proceedings, 35th Annual Sympo-
sium on Foundations of Computer Science. CA: IEEE Press,
1994.
[19] A. van Tonder. Quantum computation, categorical semantics
and linear logic. quant-ph/0312174, 2003.
[20] A. van Tonder. A lambda calculus for quantum computation.
SIAM Journal of Computing, 33:1109â€“1135, 2004.
[21] J. K. Vizzotto, T.Altenkirch, and A. Sabry. Structuring quan-
tum effects: Superoperators as arrows. Submitted for publi-
cation, 2005.
[22] P. Zuliani. Quantum Programming. PhD thesis, Oxford Uni-
versity, 2001.

