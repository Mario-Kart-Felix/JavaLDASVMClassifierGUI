From SHIQ and RDF to OWL:
The Making of a Web Ontology Language
Ian Horrocks,1 Peter F. Patel-Schneider,2 and Frank van Harmelen3
1 Department of Computer Science
University of Manchester
Oxford Road, Manchester M13 9PL, UK
Email: horrocks@cs.man.ac.uk
2 Bell Labs Research
Lucent Technologies
600 Mountain Avenue, Murray Hill, New Jersey 07974 U.S.A.
Email: pfps@research.bell-labs.com
3 AI Department
Vrije Universiteit Amsterdam
de Boelelaan 1081a, 1081HV Amsterdam, The Netherlands
Email: Frank.van.Harmelen@cs.vu.nl
Abstract. The OWL Web Ontology Language is a new formal language
for representing ontologies in the Semantic Web. OWL has features from
several families of representation languages, including primarily Descrip-
tion Logics and frames. OWL also shares many characteristics with RDF,
the W3C base of the Semantic Web. In this paper we discuss how the
philosophy and features of OWL can be traced back to these older for-
malisms, with modifications driven by several other constraints on OWL.
Several interesting problems have arisen where these influences on OWL
have clashed.
Keywords: Ontologies, Semantic Web, Description Logics, Frames,
RDF.
1 Introduction
OWL [10] is a new ontology language for the Semantic Web, developed by the
World Wide Web Consortium (W3C) Web Ontology Working Group. OWL was
primarily designed to represent information about categories of objects and how
objects are interrelated—the sort of information that is often called an ontology.
OWL can also represent information about the objects themselves—the sort of
information that is often thought of as data.
OWL was not designed in a vacuum. There were many influences on OWL’s
design, some mandated by the charter of the Web Ontology Working Group,1. As
OWL is an effort in W3C’s Semantic Web activity, it had to fit into the Semantic
Web vision of a stack of languages including XML and RDF. As OWL is supposed
to be an ontology language, it had to be able to represent a useful group of
1 http://www.w3.org/2001/sw/WebOnt/charter
ontology features. As there were already several ontology languages designed for
use in the Web, OWL had to maintain as much compatibility as possible with
these existing languages, including SHOE [18], OIL [12], and DAML+OIL [9].
The multiple influences on OWL resulted in some difficult trade-offs. Also,
and somewhat surprisingly, considerable technical work had to be performed to
devise OWL in such a way that it could be shown to have various desirable
features, while still retaining sufficient compatibility with its roots. This paper
describes some of the trade-offs and design decisions that had to be made by
the Web Ontology Working Group during the design of OWL. Although many
of these decisions were based on the requirements drawn up for OWL [17], and
on solid scientific knowledge, some of them were necessarily based on softer
judgements, and some were simply a matter of taste.
This paper presents an account of the trade-offs and design decisions behind
OWL. The views presented are those of the authors, and are not necessarily
shared by all members of the Web Ontology Working Group.
After a brief introduction and quick survey of OWL, Sections 3 and 4 discuss
the historical roots of OWL. Section 5 then surveys some of the major prob-
lems that had to be resolved in the design of OWL, while Section 6 describes
the solutions and compromises that have been found. Section 7 describes how
these solutions have been incorporated in the final design of the OWL language,
Section 8 describes extensions of OWL that are already under discussion, and
Section 9 concludes.
2 OWL Overview
This paper is an account of the design choices and trade-offs that went into the
making of OWL, and is not meant as an exhaustive description of the OWL
language (for which the reader should turn to the OWL documents, including
the OWL Language Reference [10] and Guide [35].) Nevertheless, to make the
paper self-contained, it contains a short description of the language and its most
important uses.
In the context of the Semantic Web, ontologies are expected to play an im-
portant role in helping automated processes (so called “intelligent agents”) to
access information. In particular, ontologies are expected to be used to provide
structured vocabularies that explicate the relationships between different terms,
allowing intelligent agents (and humans) to interpret their meaning flexibly yet
unambiguously. For example, a suitable pizza ontology might include the infor-
mation that Mozzarella and Gorgonzola are kinds of cheese, that cheese is not a
kind of meat or fish, and that a vegetarian pizza is one whose toppings do not
include any meat or fish. This information allows the term “pizza topped with
(only) Mozzarella and Gorgonzola” to be unambiguously interpreted (by, e.g., a
pizza ordering agent) as a specialisation of the term “vegetarian pizza”.
Terms whose meaning are defined in ontologies can be used in seman-
tic markup that describes the content and functionality of web accessible re-
sources [3]. Ontologies and ontology-based semantic markup could be used
2
– in e-commerce [30], where they can facilitate communication between buying
and selling agents by providing a common vocabulary to describe goods (such
as pizzas) and services (see, e.g., http://www.verticalnet.com/);
– in search engines [31], where they can help in finding pages that contain
semantically similar but syntactically different words and phrases (see, e.g.,
http://www.hotbot.com/); and
– in web and grid services [32, 27], where they can provide rich service descrip-
tions that can help in locating suitable services.
In order to support these and other usage scenarios, OWL takes the basic
fact-stating ability of RDF [26] and the class- and property-structuring capa-
bilities of RDF Schema [6] and extends them in important ways. OWL can
declare classes, and organise these classes in a subsumption (“subclass”) hierar-
chy, as can RDF Schema. OWL classes can be specified as logical combinations
(intersections, unions, or complements) of other classes, or as enumerations of
specified objects, going beyond the capabilities of RDFS. OWL can also declare
properties, organize these properties into a “subproperty” hierarchy, and pro-
vide domains and ranges for these properties, again as in RDFS. The domains
of OWL properties are OWL classes, and ranges can be either OWL classes or
externally-defined datatypes such as string or integer. OWL can state that a
property is transitive, symmetric, functional, or is the inverse of another prop-
erty, here again extending RDFS.
OWL can express which objects (also called “individuals”) belong to which
classes, and what the property values are of specific individuals. Equivalence
statements can be made on classes and on properties, disjointness statements
can be made on classes, and equality and inequality can be asserted between
individuals.
However, the major extension over RDFS is the ability in OWL to provide
restrictions on how properties behave that are local to a class. OWL can define
classes where a particular property is restricted so that all the values for the
property in instances of the class must belong to a certain class (or datatype);
at least one value must come from a certain class (or datatype); there must be
at least certain specific values; and there must be at least or at most a certain
number of distinct values.
For example, using RDFS we can
– declare classes like Country, Person, Student and Canadian;
– state that Student is a subclass of Person;
– state that Canada and England are both instances of the class Country;
– declare Nationality as a property relating the classes Person (its domain)
and Country (its range);
– state that age is a property, with Person as its domain and integer as its
range; and
– state that Peter is an instance of the class Canadian, and that his age has
value 48.
With OWL we can additionally
3
– state that Country and Person are disjoint classes;
– state that Canada and England are distinct individuals;
– declare HasCitizen as the inverse property of Nationality;
– state that the class Stateless is defined precisely as those members of the
class Person that have no values for the property Nationality;
– state that the class MultipleNationals is defined precisely as those mem-
bers of the class Person that have at least 2 values for the property
Nationality;
– state that the class Canadian is defined precisely as those members of the
class Person that have Canada as a value of the property Nationality; and
– state that age is a functional property.
The above shows that OWL is quite a sophisticated language. OWL has
both an RDF/XML exchange syntax and an abstract frame-like syntax, and it
has three named sublanguages. This multiplicity is the direct result of trying to
satisfy a large number of sometimes conflicting influences and requirements, as
will be discussed throughout the remainder of this paper.
3 Influences on OWL
As mentioned above, the design of OWL has been subject to a variety of in-
fluences. These included influences from established formalisms and knowledge
representation paradigms, influences from existing ontology languages, and in-
fluences from existing Semantic Web languages.
Some of the most important influences on the design of OWL came, via its
predecessor DAML+OIL, from Description Logics, from the frames paradigm,
and from RDF. In particular, the formal specification of the language was influ-
enced by Description Logics, the surface structure of the language (as seen in
the abstract syntax) was influenced by the frames paradigm, and the RDF/XML
exchange syntax was influenced by a requirement for upwards compatibility with
RDF.
Each of these influences will be examined in more detail in the following
sections.
3.1 Description Logics
Description Logics are a family of class-based (concept-based) knowledge rep-
resentation formalisms [1]. They are characterised by the use of various con-
structors to build complex classes from simpler ones, an emphasis on the decid-
ability of key reasoning problems, and by the provision of sound, complete and
(empirically) tractable reasoning services. Description Logics, and insights from
Description Logic research, had a strong influence on the design of OWL, partic-
ularly on the formalisation of the semantics, the choice of language constructors,
and the integration of datatypes and data values. In fact OWL DL and OWL
Lite (two of the three species of OWL) can be viewed as expressive Description
Logics, with an ontology being equivalent to a Description Logic knowledge base.
4
Semantics A key feature of Description Logics is that they are logics, i.e., formal
languages with well defined semantics. The standard technique for specifying the
meaning of a Description Logic is via a model theoretic semantics, whose purpose
is to explicate the relationship between the language syntax and the intended
model(s) of the domain. A model consists of a domain (often written ∆I) and an
interpretation function (often written ·I), where the domain is a set of objects
and the interpretation function is a mapping from individual, class and property
names to elements of the domain, subsets of the domain and binary relations
on the domain, respectively. So, for an individual John, JohnI ∈ ∆I , for a class
Person, PersonI ⊆ ∆I , and for a property friend, friendI ⊆ ∆I ×∆I .
The interpretation function can be extended from class names to complex
class descriptions in the obvious way. For example, given two classes Male and
Person interpreted as the sets MaleI = {w, x, y} and PersonI = {x, y, z}, then
the intersection of Male and Person (i.e., male persons) is interpreted as the
intersection of {w, x, y} and {x, y, z}, i.e., (Male and Person)I = {x, y}.
Objects in the domain do not in themselves have any meaning, nor does
the choice of any particular set of objects that make up the domain—what is
important is the relationships between objects and sets of objects. In a given
model, for example, an individual i is an instance of a class C just in case i is
interpreted as an element of the interpretation of C (i.e., iI ∈ CI), and a class
C is a subclass of a class D just in case the interpretation of C is a subset of the
interpretation of D (i.e., CI ⊆ DI).
A Description Logic knowledge base consists of a set of axioms asserting,
e.g., that one class is a subclass of another, or that an individual is an instance
of a particular class. The meaning of these axioms is given by corresponding
constraints on models. If, for example, the knowledge base contains an axiom
stating that Person is a subclass of Animal (written Person v Animal), then in
a model of the knowledge base the interpretation of Person must always be a
subset of the interpretation of Animal. The meaning of a knowledge base derives
from features and relationships that are common to all possible models. If, for
example, the interpretation of a class must always be the empty set, then that
class is said to be inconsistent, while if there are no possible interpretations, the
knowledge base itself is said to be inconsistent. If the relationship specified by
a given axiom must hold in all interpretations of a knowledge base, then that
axiom is said to be entailed by the knowledge base, and if one knowledge base
entails every axiom in another knowledge base, then the first knowledge base
is said to entail the second knowledge base. A knowledge base containing the
axiom Person v Animal, for example, entails that the intersection of Male and
Person is also a subclass of Animal. This entailment is quite trivial, but with a
language as complex as OWL, checking entailments may, in general, be a very
hard task (see Section 6.5).
Like OIL and DAML+OIL, OWL uses a Description Logic style model theory
to formalise the meaning of the language. This was recognised as an essential
feature in all three languages, as it allows ontologies, and information using
vocabulary defined by ontologies, to be shared and exchanged without disputes
5
as to precise meaning. The need for this kind of formality was reinforced by
experience with early versions of the RDF and RDFS specification, where a lack
of formality soon led to arguments as to the meaning of language constructs
such as domain and range constraints [7]. In order to avoid such problems, the
meaning of RDF is now also defined in terms of a model theory [15].
Another advantage of formalising the meaning of the language in this way
is that automated reasoning techniques can be used to check the consistency
of classes and ontologies, and to check entailment relationships. This is crucial
if the full power of ontologies is to be exploited by intelligent agents, and the
ability to provide such reasoning support was a key design goal for OWL.
Language Constructors The expressive power of a language like OWL is
determined by the class (and property) constructors supported, and by the kinds
of axioms that can occur in an ontology. Of course increased expressive power
inevitably means increased computational complexity for key reasoning problems
such as entailment.
The design of OWL was influenced by more than 10 years of Description
Logic research, which has mapped out in considerable detail the complexity-
tractability landscape for a wide range of constructors and axioms, and their
various combinations [1]. This knowledge allowed the set of constructors and
axioms supported by OWL to be carefully chosen so as to balance the expressive
requirements of typical applications with a requirement for reliable and efficient
reasoning support.
A particular goal of this design process was to ensure that OWL entailment
would at least be decidable, i.e., that it would be possible to design an algorithm
that could guarantee to determine whether or not one OWL ontology entails
another (such an algorithm is often called a decision procedure). The availability
of practical decision procedures (for entailment), and even implemented systems,
was also an important consideration.
A suitable balance between these computational requirements and the expres-
sive requirements identified in [17] was achieved by basing the design of OWL on
the SH family of Description Logics [24]. The constructors and axioms supported
by SH are similar to those described in Section 2, and include the boolean con-
nectives (intersection, union and complement), restrictions on properties, tran-
sitive properties and a property hierarchy—i.e., equivalent to the ALC Descrip-
tion Logic [34] extended with transitive properties and a property hierarchy. The
property hierarchy is important for OWL as it is a feature of RDFS, while transi-
tive properties have been identified as an important requirement in many appli-
cations [17]. Members of the SH family include the influential SHIQ Description
Logic [23], which adds inverse properties and generalised cardinality restrictions,
and SHOQ(D) [22], which adds the ability to define a class by enumerating its
instances (e.g., the class {Monday, Tuesday, Wednesday, Thursday, Friday}) and
support for datatypes and values (e.g., integer and string datatypes, and values
such as “35”).
6
Datatypes As well as dealing with “abstract” classes such as Person and
Animal, many practical applications need to represent and reason about
datatypes and values such as integers and strings. The integration of datatypes
in the OWL language is again heavily influenced by Description Logic research,
which has demonstrated that care is required in order to avoid complexity blow-
ups or even undecidability being caused by datatypes2 [28]. In the SHOQ(D)
Description Logic it was shown that this could be achieved by strictly separating
the interpretation of datatypes and values from that of classes and individuals:
SHOQ(D) interpretations include an additional interpretation domain for data
values ∆ID which is disjoint from the domain of individuals ∆
I . Datatypes, such
as integer, are interpreted as a subset of ∆ID, and values such as the integer “35”
are interpreted as elements of ∆ID. The separation is further strengthened by
dividing properties into two disjoint sets of abstract and datatype properties.
Abstract properties such as brother are interpreted as binary relations on ∆I
(i.e., subsets of ∆I ×∆I), while datatype properties such as age are interpreted
as binary relations between ∆I and ∆ID (i.e., subsets of ∆
I ×∆ID).
This design has the advantage that reasoning with datatypes and values can
be almost entirely separated from reasoning with classes and individuals—a class
based reasoner simply needs access to a datatype “oracle” that can answer sim-
ple questions with respect to datatypes and values (e.g., “is -5 a nonNegative
Integer?”). Moreover, the language remains decidable if datatype and value rea-
soning is decidable, i.e., if the oracle can guarantee to answer all questions of the
relevant kind for supported datatypes. This can easily be achieved for a range
of common datatypes such as integers, decimals and strings [28].
As well as these practical considerations, it can also be argued that the
separation of classes and datatypes makes sense from a philosophical standpoint
as datatypes are already structured by built in predicates such as greater-than
and less-than. From this point of view, it does not make sense to use ontology
axioms to add further structure to datatypes or to form “hybrid” classes such
as the class of red integers.
3.2 Frames Paradigm
In the Semantic Web context, where users with a wide range of expertise might
be expected to create or modify ontologies, readability and general ease of use
are important considerations for an ontology language. In the design of OIL,
one of the languages on which OWL is based, these requirements were addressed
by providing a surface syntax based on the frames paradigm. Frames group to-
gether information about each class, making ontologies easier to read and under-
stand, particularly for users not familiar with (Description) Logics. The frames
paradigm has been used in a number of well known knowledge representation
systems including the Protégé ontology design tool [13] and the OKBC knowl-
edge model [8]. The design of OIL was influenced by XOL [25]—a proposal for
2 Reasoners for undecidable languages may have undesirable characteristics, including
poor performance and/or unpredictability.
7
an XML syntax for OKBC Lite (a cut down version of the OKBC knowledge
model).
In frame based languages, each class is described by a frame. The frame
includes the name of the class, identifies the more general class (or classes) that
it specialises, and lists a set of “slots”. A slot may consist of a property-value
pair, or a constraint on the values that can act as slot “fillers” (in this context,
value means either an individual or a data value). This structure was used in the
OIL language, with some enrichment of the syntax for specifying classes and slot
constraints so as to enable the full power of a Description Logic style language to
be captured. In addition, property frames were used to describe properties, e.g.,
specifying more general properties, range and domain constraints, transitivity
and inverse property relationships.
A class frame is semantically equivalent to a Description Logic axiom assert-
ing that the class being described by the frame is a subclass of each of the classes
that it specialises and of each of the property restrictions corresponding to the
slots. As well as a richer slot syntax, OIL also offered the possibility of asserting
that the class being described by the frame was exactly equivalent to the relevant
intersection class, (i.e., that they were mutually subsuming). A property frame
is equivalent to a set of axioms asserting the relevant subproperty relationships,
range and domain constraints etc. OIL was designed so that OIL frames could
easily be mapped to equivalent axioms in the SHOQ(D) Description Logic [11].
The formal specification and semantics of OWL are given by an abstract syn-
tax [33] that has been heavily influenced by frames in general and by the design
of OIL in particular. In the abstract syntax, axioms are compound constructions
that are very like an OIL-style frame. For classes, they consist of the name of
the class being described, a modality of “partial” or “complete” (indicating that
the axiom is asserting a subclass or equivalence relationship respectively), and
a sequence of property restrictions and names of more general classes. Similarly,
a property axiom specifies the name of the property and its various features.
The frame style of the abstract syntax makes it much easier to read (com-
pared to the RDF/XML syntax), and also easier to understand and to use.
Moreover, abstract syntax axioms have a direct correspondence with Descrip-
tion Logic axioms, and they can also be mapped to a set of RDF triples.
3.3 RDF Syntax
The third major influence on the design of OWL was the requirement to main-
tain the maximum upwards compatibility with existing web languages, and in
particular with RDF [29]. On the face of it this requirement made good sense
as RDF (and in particular RDF Schema) already included several of the basic
features of a class and property based ontology language, e.g., it allows subclass
and subproperty relationships to be asserted. Moreover, the development of RDF
preceded that of OWL, and it seemed reasonable to try to appeal to any user
community already established by RDF.
It may seem easy to meet this requirement simply by giving OWL an RDF-
based syntax. In order to provide maximum upwards compatibility, however, it
8
was also thought necessary to ensure that the semantics of OWL ontologies was
also consistent with the semantics of RDF. This proved to be difficult given the
greatly increased expressive power provided by OWL. This will be discussed in
more detail in Section 5.
4 Predecessors of OWL
OWL was not the first web-enabled ontology language, and its design was influ-
enced by several pre-existing languages including RDFS, SHOE, OIL, DAML-
ONT and DAML+OIL. DAML+OIL in particular was a major influence on
OWL, and the charter of the Web Ontology working group explicitly states that
the design of OWL should be based on DAML+OIL. DAML+OIL in turn was
heavily influenced by the OIL language, with additional influence from work on
DAML-ONT and RDFS.
4.1 SHOE
One of the first attempts at defining an ontology language for deployment on the
Web was SHOE [16]. SHOE is a frame-based language with an XML syntax that
could be safely embedded in existing HTML documents. SHOE used URI refer-
ences for names, an important innovation (see Section 7) that was subsequently
adopted by both DAML-ONT and DAML+OIL. SHOE also placed emphasis
on the fact that ontologies would be tightly interlinked and subject to change.
Consequently, SHOE included a number of directives which allowed importing
of other ontologies, local renaming of imported constants, and stating versioning
and compatibility information between ontologies. This line of thinking has in-
fluenced the extra-logical vocabulary of OWL that is designed to partially deal
with such issues. SHOE was of lesser influence on the syntactic and semantic
design of OWL since it was not based on RDF, and did not come with a formal
semantics.
4.2 DAML-ONT
In 1999 the DARPA Agent Markup Language (DAML) program3 was initi-
ated with the aim of providing the foundations of a next generation “semantic”
Web [19]. As a first step, it was decided that the adoption of a common ontology
language would facilitate semantic interoperability across the various projects
making up the program. RDFS (which had already been proposed as a W3C
standard) was seen as a good starting point, but was not sufficiently expressive
to meet DAML’s requirements. A new language called DAML-ONT was therefore
developed that extended RDF with language constructors from object-oriented
and frame-based knowledge representation languages.
DAML-ONT was tightly integrated with RDFS, and while this was useful
from a compatibility viewpoint, it led to some serious problems in the design of
3 http://www.daml.org/
9
the language. Like RDFS, DAML-ONT suffered from an inadequate semantic
specification, and it was soon realised that this could lead to disagreements, both
amongst humans and machines, as to the precise meaning of terms in a DAML-
ONT ontology. Moreover, DAML-ONT property restrictions had, like those of
RDFS, global rather than local scope, and while this was reasonable for the
domain and range constraints provided by RDFS, global cardinality constrains,
for example, are difficult to understand and of doubtful utility—in fact it seems
likely that this would have been recognised as a design flaw if the semantics of
the language had been adequately formalised.
4.3 OIL
At around the same time that DAML-ONT was being developed, a group of
(largely European) researchers with aims similar to those of the DAML re-
searchers had designed another Web oriented ontology language called OIL4 (the
Ontology Inference Layer) [12]. OIL was the first ontology language to combine
elements from Description Logics, frame languages and web standards such as
XML and RDF. OIL placed a strong emphasis on formal rigor, and the language
was explicitly designed so that its semantics could be specified via a mapping to
the SHIQ description logic [23]. The structure of the language was, however,
frame-based, using compound class “definitions” in the style described in Sec-
tion 3.2. OIL had both XML and RDF syntaxes, but although the RDF syntax
was designed to maintain compatibility with RDFS, it did not concern itself with
the precise details of RDF semantics, which had not at that time been formally
defined.
4.4 DAML+OIL
It became obvious to both the DAML-ONT and OIL groups that their ob-
jectives could best be served by combining their efforts, the result being the
merging of DAML-ONT and OIL to produce DAML+OIL. The development of
DAML+OIL was undertaken by a committee largely made up of members of the
two language design teams, and rather grandly titled the Joint US/EU ad hoc
Agent Markup Language Committee.5
The merged language has a formal semantics given by its own DL style model
theory instead of via a translation into a suitable DL. The DL derived language
constructors of OIL were retained in DAML+OIL, but the frame structure was
largely discarded in favour of DL style axioms, which were more easily integrated
with RDF syntax.
Influenced by DAML-ONT, DAML+OIL is more tightly integrated with
RDF. DAML+OIL, however, only provided a meaning for those parts of RDF
which were consistent with its own syntax and DL style model theory. This did
not seem to be too much of a problem given that RDF did not at that time have
4 http://www.ontoknowledge.org/oil
5 http://www.daml.org/committee
10
a formally specified meaning of its own, but was the cause of serious difficulties
when DAML+OIL was used as the basis for OWL.
5 Problems Along the Path
The multiple influences on OWL have lead to a number of problems. Some of
these problems are a result of conflicting requirements, as in the conflict between
using RDF/XML as the official OWL syntax and having an easy-to-read syntax.
Some of these problems arise from a need to extend previous solutions, as in the
problems arising in crafting an extension to RDF that incorporates information
that does not fit well into the RDF world view.
5.1 Syntactic Problems
For a number of reasons, including maintaining connections to frames and De-
scription Logics, OWL should have an easy-to-read syntax that can be easily
understood and easily created. However, it was a requirement of OWL that it
use XML as its normative syntax, and, moreover, use XML in the same way as
it is used in RDF [2]. This requirement had already been addressed by OIL and,
later, by DAML+OIL: OIL has both an RDF/XML and an XML syntax [20],
while DAML+OIL has only an RDF/XML syntax [9].
Taken just as a syntax for OWL, RDF in the form of RDF/XML has a
number of problems. These problems can be overcome, but they do make OWL
more complex that it might otherwise be.
One problem is that RDF/XML is extremely verbose. Compare for example,
information about a class as it would be given in a Description Logic syntax
Student = Person u> 1 enrolledIn
(a Student is a Person who is enrolledIn at least 1 thing), with how it would
most naturally be written using the OWL RDF/XML syntax6
<owl:Class rdf:ID="Student">
<owl:intersectionOf rdf:parsetype="Collection">
<owl:Class rdfs:about="Person" />
<owl:Restriction>
<owl:onProperty rdf:resource="enrolledIn" />
<owl:minCardinality rdfs:datatype="&xsd;Integer">
1
</owl:minCardinality>
</owl:Restriction>
<owl:intersectionOf>
</owl:Class>
6 Full details on the OWL RDF/XML syntax can be found in the OWL Reference
document [10].
11
Another problem is that RDF breaks everything down into RDF triples [26].7
This means that many OWL constructs, such as property restrictions, have to be
encoded as several triples. OWL generally uses an encoding similar to that used
by DAML+OIL. For example, an OWL value restriction that would be written
in Description Logic syntax as ∃child.person (the class whose instances have
some child that is a person) is encoded as two RDF triples something like
:x owl:onProperty ex:child .
:x owl:someValuesFrom ex:Person .
where _:x is a syntactic placeholder for the restriction as a whole.
A third problem is that all RDF triples are independent. This means, for
example, that as far as RDF is concerned there is no requirement that the two
above triples must always occur together. Similarly, there is no requirement that
there not be extra triples, so adding
:x owl:onProperty ex:friend .
:x owl:allValuesFrom ex:Doctor .
to the above two triples cannot be ruled out in RDF.
A fourth problem is that RDF triples are all accessible. This means that
circular and other unusual structures cannot be ruled out. For example, there is
no problem in RDF with collections of triples like
:x owl:onProperty ex:child .
:x owl:allValuesFrom :x .
These issues are not addressed in OIL, which provides no guidance as to what
should happen for collections of triples that don’t match the syntax productions
of the language. DAML+OIL takes a different approach, allowing unusual con-
structions but declining to give them a DAML+OIL meaning. OWL has roughly
followed the DAML+OIL solution, but with several modifications.
5.2 Semantic Problems
Once issues of syntax have been addressed, issues related to meaning still remain.
RDF provides a meaning for every triple, so if OWL is to be considered to be
an extension of RDF, the meaning that OWL provides for triples needs to be an
extension of this RDF meaning.
This was not as much of an issue when OIL and DAML+OIL were designed,
as the meaning of RDF was not very well specified. OIL in particular does
not bother to relate the RDF meaning of its RDF/XML syntax to the OIL
meaning of this syntax—the RDF/XML syntax for some OIL constructs does
7 The syntax for RDF triples here is one used in the RDF Semantics document [15].
An RDF triple is written as a subject, a predicate, and an object, in that order.
RDF URI references in triples are generally abbreviated as XML qualified names.
RDF blank nodes (anonymous objects) are written with a leading “ :”.
12
more-or-less line up with the RDF meaning of these constructs but this is by
no means the case for all such constructs. For example, OIL has a special prop-
erty (oil:hasSlotConstraint) used to relate a class to its slots, but the RDF
meaning [15] of this property, namely the standard meaning assigned to any
RDF triple is ignored by the OIL semantics.
DAML+OIL does a better job of abiding by the RDF meaning of its syntax.
The DAML+OIL model theory [37] includes a semantic condition for triples
that is close to the RDF meaning (as defined at that time) for triples. Further,
DAML+OIL uses the built-in RDF and RDFS vocabulary to a greater extent
than does OIL, and uses it in a way generally compatible with the RDF or RDFS
meaning (as defined at that time) for this vocabulary. For example DAML+OIL
uses rdfs:subClassOf to relate classes to superclasses, including DAML+OIL
restrictions, whereas OIL uses oil:hasSlotConstraint in some of these situa-
tions.
Even when DAML+OIL was being developed, however, there were some as-
pects of the meaning of RDFS that could not be reconciled with the appropriate
meaning in DAML+OIL. In particular, RDFS [5] then had an unusual meaning
for domains and ranges of properties. Only a single range was permitted for
properties and multiple domains were treated disjunctively. For example,
ex:foo rdfs:domain ex:Person .
ex:foo rdfs:domain ex:Rock .
would allow both people and rocks to participate in the foo property.
This disjunctive reading of domains caused problems for the DAML+OIL
semantics so a choice was made to change this to a conjunctive reading and
petition the newly-formed RDF Core Working Group to change RDFS to allow
multiple domains and ranges, both with a conjunctive reading. As part of its
clean-up of the RDF and RDFS semantics, the RDF Core working group has
decided to make this change, eliminating a problem for OWL.
While cleaning up problems with RDF and RDFS, the RDF Core working
group also decided to put RDF on a firmer semantic ground. It did this by
providing a model theory for RDF and RDFS, along with a standard treatment
of inference for RDF and RDFS. This has meant that there is now more meaning
provided for RDF and RDFS that OWL has to be compatible with. In particular,
all the triples that are used to encode the OWL syntax now have RDF meaning,
and this RDF meaning has to be taken into account by OWL if the semantics
of OWL are to be fully compatible with those of RDF and RDFS.
Neither OIL nor DAML+OIL provided a standard theory of inference. This
was common in the formalisms that influenced OIL and DAML+OIL. Frames
generally provided an interface to the internal data structures in lieu of any
other inferences or even queries. Description Logics do provide a formal theory
of querying, but this is somewhat different from a standard theory of inference.
The difference is that Description Logic querying could have been defined
for DAML+OIL in a way that would have helped to hide the RDF meaning of
triples. For example, asking whether an individual belonged to a class could add
13
the syntax used to specify the class to the premises of the query. However, a
standard theory of inferencing cannot do this.
The effects of this change can be seen in a simple example. Given the following
information
ex:John rdf:type ex:Student .
ex:John rdf:type ex:Employee .
it would have been fairly easy to arrange it so that asking whether John belonged
to the intersection of student and employee first ensured that this intersection
existed and then asked whether John belonged to it. However, turning this into
an entailment requires the above information to entail
:c owl:intersectionOf :l1 .
:l1 rdf:first ex:Student .
:l1 rdf:rest :l2 .
:l2 rdf:first ex:Employee .
:l2 rdf:rest rdf:nil .
ex:John rdf:type :c .
which, because of the RDF meaning ascribed to all triples, requires the existence
of the triples that encode the syntax.8
OWL thus has had to develop a method that augments the new RDF seman-
tics just enough to support the above inferences without being too strong, and
thus ending up with semantic paradoxes (this will be discussed in more detail in
Section 6.4).
5.3 Expressive Power
Because many things were expected of OWL (see the long list of design goals,
requirements and objectives in [17]), there were many demands for expressive
power going beyond that generally provided by Description Logics. For example,
many users wanted to be able to associate information with classes and properties
and to make classes belong to other classes, as is possible in RDF. Similarly,
there were many demands for expressive power going beyond RDF and RDFS.
For example, many users wanted to be able to provide local typing for property
values, as is possible in Description Logics. OWL had to be designed to somehow
allow these sorts of expressivity while still retaining connections to its roots.
When DAML+OIL was developed, the only datatype supported by RDF was
literals: roughly undifferentiated values given as strings. DAML+OIL thus had
to provide its own solution for datatypes, and did so by allowing the use of XML
Schema datatypes [4]. However, any reasonable solution to datatyping that uses
only RDF syntax needs help from RDF (i.e., an extension to RDF syntax), and
thus the DAML+OIL solution remained incomplete.
8 Note that OWL constructs such as intersectionOf and unionOf are encoded using
RDF lists constructed of rdf:first and rdf:rest triples—see the OWL Reference
document [10] for full details.
14
Recently RDF has added its own version of datatyping, similar to, but dif-
ferent from, the DAML+OIL solution. OWL has thus needed to move from
DAML+OIL datatyping to RDF datatyping.
5.4 Computational Problems
One aspect of OWL that distinguishes it from RDF and RDFS is that it supports
a rich set of inferences. Some of these inferences are quite obvious, such as the
example given above about students and employees, and thus appear to be easy
to compute. Other inferences supported by OWL, however, are quite complex,
requiring, e.g., reasoning by cases and following chains of properties.
Taking all the representational desires for OWL together would have created
a formalism where key inference problems were undecidable. For example, al-
lowing relationships to be asserted between property chains (such as saying that
an uncle is precisely a parent’s brother) would make OWL entailment undecid-
able.9 In addition, some aspects of RDF, such as the use of classes as instances,
interact with the rest of OWL to create computational difficulties, taking OWL
beyond the range of practical algorithms and implemented reasoning systems.
OWL has thus had to provide a solution for these computational issues while
still retaining upwards compatibility with RDF and RDFS.
6 Solutions
The Web Ontology working group spent the better part of a year overcoming
the basic tensions underlying the above problems. The difficulty lay not in each
problem in isolation, but in the combination of all the above problems and the
constraints placed on the design of OWL. It would have been much easier, for
example, to meet all the above requirements if only OWL could have used an
extension of the RDF syntax. If this had been allowed, OWL could have added
new, natural syntax for its constructs whose semantics would not have been
required to carry along an RDF triple meaning.
Nevertheless a viable solution has been found that satisfies all the above
requirements. Or, actually, it is more accurate to say that three solutions have
been found, each of which satisfies almost all of the above requirements.
OWL DL: If friendly syntax or decidable inference is considered of primary
importance, then OWL DL, a version of OWL with decidable inference that can
be written in a frame or Description Logic manner, is appropriate.
OWL Lite: If an even-simpler syntax and more tractable inference is consid-
ered of primary importance, then OWL Lite, a syntactic subset of OWL DL, is
appropriate.
9 It is easy to show that, if extended in this way, OWL could be used to encode the
word problem, which is well known to be undecidable [38].
15
OWL Full: If compatibility with RDF and RDFS is considered of primary im-
portance, then OWL Full, a syntactic and semantic extension of RDFS, is ap-
propriate.
The next section provides a more-detailed description of these versions
(species) of OWL, and explains how the problems described above have been
overcome.
6.1 Readability
As shown by the examples above, OWL is not very readable when written as
RDF/XML or even as RDF triples. Part of this problem is that RDF/XML is
extremely verbose, but the major part of the readability problem is the encoding
of OWL constructs into RDF/XML or RDF triples.
In part to address this problem, an abstract syntax (c.f., Section 7.1) was cre-
ated for OWL, along with a mapping from abstract syntax to RDF graphs. This
abstract syntax is closer to the syntax of OIL than of DAML+OIL, but with-
out OIL’s extreme emphasis on readability. In this abstract syntax the Student
example above would be written
Class(Student complete
Person
restriction(enrolledIn minCardinality(1))).
OWL DL was then defined as the syntactic subset of OWL induced by the
translation from the abstract syntax to RDF graphs. That is, an RDF graph is
an OWL DL ontology just when it is the translation of some ontology in the
abstract syntax. Users and tools that are more interested in readability than
in RDF/XML can use this abstract syntax internally, or even externally for
presentation to users, reserving the RDF/XML syntax for purposes of exchange
between applications.
6.2 Handling Malformed Graphs
Because OWL Full allows arbitrary RDF graphs, it must be able to handle
malformed OWL syntax. (OWL DL does not suffer from this problem as it is
defined in terms of the necessarily well-formed RDF graphs that can be generated
from the abstract syntax.) OWL uses an extension of the DAML+OIL solution:
only triples that together form well-formed OWL constructs are given an extra
meaning, so
:x owl:onProperty ex:child .
by itself does not have any special OWL meaning.
To handle the cases of too many triples, OWL again uses the DAML+OIL so-
lution of picking out all the well-formed subsets and giving them OWL meaning.
This has unusual consequences—for example
16
:x owl:onProperty ex:child .
:x owl:someValuesFrom ex:Person .
:x owl:onProperty ex:friend .
:x owl:allValuesFrom ex:Doctor .
ends up equating the extension of four different OWL restrictions (all possi-
ble combinations of the two properties with the two classes), which is almost
certainly not what was intended by the user. This solution, however, maintains
monotonicity, and the (possibly) non-intuitive meaning is a minor problem given
that such malformed constructions can easily be avoided.
The lack of structure in RDF graphs has to be handled by semantic means,
which are described next.
6.3 Providing a Viable Semantic Theory for OWL
As RDF now has a model theory, with a full-fledged notion of entailment, OWL
has to provide an upward-compatible model theory that appropriately handles
entailments over the OWL constructs. This would have been easy if OWL had
been able to extend the RDF syntax, as then these new bits of syntax could have
had an OWL-only meaning. However, it was a requirement that OWL had an
RDF syntax, and that this syntax carried all of its RDF meaning. This two-way
compatibility requirement is much stronger than that usually imposed between
weaker formalisms (like propositional logic) and stronger formalisms (like first-
order logic) where the stronger formalism is allowed to extend the syntax of the
weaker formalism.
The most severe aspect of this problem is that OWL syntactic constructs that
are encoded as multiple triples have to retain the RDF meaning for these triples.
As all RDF triples carry semantic conditions, they cannot just be inferred from
nothing. Instead, the OWL semantics has had to add special constraints that
essentially state that every OWL interpretation must include certain constructs.
(Such constraints are usually called comprehension principles.) For example, one
comprehension principle for OWL states that every model must include all finite
lists of classes; another states that every such list must have a corresponding
intersection class, by requiring that there is some class that is connected to the
list by an owl:intersectionOf property.
These comprehension principles support the entailment from
ex:John rdf:type ex:Student .
ex:John rdf:type ex:Employee .
to
:c owl:intersectionOf :l1 .
:l1 rdf:first ex:Student .
:l1 rdf:rest :l2 .
:l2 rdf:first ex:Employee .
:l2 rdf:rest rdf:nil .
ex:John rdf:type :c .
17
because :l1 can be the required list of Student and Employee, :l2 can be
the required tail of this list, and :c can be the required intersection of the list.
Additional (and more-usual) semantic conditions require that ex:John belong
to :c, finishing all that is required for the entailment to hold.
6.4 Avoiding Paradoxes
Comprehension principles are very powerful, as they create something from noth-
ing (or, at least, something from very little). This power can easily lead to serious
problems.
For example, the Russell paradox is a paradox precisely because of the com-
prehension principles built into an early version of set theory. This early version
of set theory had a comprehension principle that stated that a set could be con-
structed of the things that satisfied a formula with one free variable—e.g., the
formula of being a human, x ∈ human, could be used to construct the set of
humans, {x | x ∈ human}. Unfortunately, from the formula of not belonging to
oneself, x 6∈ x, the set {x | x 6∈ x} arises. This set causes problems wherever
it exists because it is impossible to determine whether it belongs to itself. The
comprehension principle mandates that it exists everywhere, thus causing this
early version of set theory to collapse.
A similar situation can arise with OWL. It seems natural to want to have
circular OWL-like constructs, for example classes whose instances are related
only to other instances of the class, such as in
:c owl:onProperty ex:child .
:c owl:allValuesFrom :c .
that might be used in a naive representation of some aspects of biology.
However, having comprehension principles for such circular classes can easily
lead to a requirement for the existence of classes like
:c owl:onProperty rdf:type .
:c owl:allValuesFrom : d .
:d owl:complementOf :l .
:l rdf:first :c .
:l rdf:rest rdf:nil .
which is the class of things that have no type relationship to the class itself.
Objects that belong to this class can’t belong to it, and vice versa, so if the
comprehension principles required the existence of this class, then every OWL
ontology would be paradoxical.
To avoid these paradoxes, the OWL comprehension principles never require
the existence of circular chains of reference like the one above. However, this does
mean that there are entailments that one might expect, such as ones involving
the construct with ex:child above, for example having a person with no children
belong to such a construct, that are not valid in OWL. Devising these compre-
hension principles took a surprising amount of effort (much of which involved
determining the ground rules for the principles).
18
6.5 Retaining Decidability
OWL Full is undecidable (for a number of reasons), and even OWL DL could
easily be undecidable if it included certain constructs known to cause undecid-
ability in Description Logics (see, e.g., [23]). Therefore OWL DL was carefully
crafted to remain decidable, and does not include, for example, relationships
between role chains, which would cause undecidability by embedding the word
problem in OWL DL.
This is not to say that inference in OWL DL is not hard. OWL DL has a
difficult entailment problem, as inference in SHOIN (D) is of worst-case non-
deterministic exponential time (NExpTime) complexity [36], and OWL DL
should have the same complexity. Worse, there is as of yet no known “prac-
tical” complete algorithm for inference in SHOIN (D), i.e., one that is likely
to perform well on the kinds of problem encountered in typical applications. In
default of such an algorithm, the behaviour of OWL DL reasoners is likely to be
less predictable (both in terms of the time taken to respond to queries, and the
use of system resources), and they may sometimes return the answer “Unknown”
in response to queries.
OWL Lite is better in this regard. Inference in SHIF(D) is of worst-case
deterministic exponential time (ExpTime) complexity [36], and OWL Lite has
the same complexity. Moreover, there are practical optimized algorithms for
inference in OWL Lite, such as the algorithm underlying the Description Logic
systems FaCT [21] and RACER [14]. These systems have been shown to work
well in realistic applications and to be able to reason with large ontologies.
7 OWL
This section describes how the solutions outlined above have been incorporated
in the final design of the OWL language. It is not intended as a full description
of the language—for this, readers should turn to the W3C documents on OWL
[35, 10, 33].
For various reasons, described in the preceding sections, there are two styles
of using OWL. In the first style, embodied in OWL DL and OWL Lite, only cer-
tain constructions are allowed, and these constructions can only be combined in
certain ways. The benefits of staying within these limitations include decidability
of inferences and the possibility of thinking of OWL in a more-standard fash-
ion, essentially as an expressive Description Logic. In the second style, embodied
in OWL Full, all RDF graphs are allowed. The benefits of this expansive style
include total upward compatibility with RDF and a greater expressive power.
Even the more-limited versions of OWL have some differences from stan-
dard Description Logics. These differences move these versions of OWL from
the formal Description Logic world to the Semantic Web world.
– OWL uses URI references as names, and constructs these URI refer-
ences in the same manner as that used by RDF. It is thus common
19
in OWL to use qualified names as shorthands for URI references, us-
ing, for example, the qualified name owl:Thing for the URI reference
http://www.w3.org/2002/07/owl#Thing.
– OWL gathers information into ontologies, which are generally stored as Web
documents written in RDF/XML. Ontologies can import other ontologies,
adding the information from the imported ontology to the current ontology.
– Even the DL/Lite style of using OWL allows RDF annotation properties to
be used to attach information to classes, properties, and ontologies, such as
owl:DeprecatedClass. These annotations are RDF triples, and are there-
fore required to carry a full semantic weight. They cannot be treated as
informal comments without a formal meaning. This partly breaks down the
firm Description Logic distinction between individuals, on the one hand, and
classes and properties, on the other.
– OWL uses the facilities of RDF datatypes and XML Schema datatypes to
provide datatypes and data values.
– The DL and Lite versions of OWL have a frame-like abstract syntax, whereas
RDF/XML is the official exchange syntax for all of OWL.
7.1 OWL as a Description Logic
OWL DL—the Description Logic style of using OWL—is very close to the
SHOIN (D) Description Logic which is itself an extension of the the influential
SHOQ(D) Description Logic [22] (extended with inverse roles and restricted
to unqualified number restrictions). OWL DL can form descriptions of classes,
datatypes, individuals and data values using the constructs shown in Figure 1. In
this table the first column gives the OWL abstract syntax for the construction,
while the second column gives the standard Description Logic syntax.
OWL DL uses these description-forming constructs in axioms that provide
information about classes, properties, and individuals, as shown in Figure 2.
Again, the frame-like abstract syntax is given in the first column, and the stan-
dard Description Logic syntax is given in the second column.
7.2 Semantics for OWL DL
A formal semantics, very similar to the semantics provided for Description Logics
(see Section 3.1), is provided for this style of using OWL. Full details on this
model theory can be found in the OWL Semantics and Abstract Syntax [33].
Because OWL includes datatypes, the semantics for OWL is very similar
to that of Description Logics that also incorporate datatypes, in particular
SHOQ(D). However, the particular datatypes used in OWL are taken from
RDF and XML Schema Datatypes [4]. Data values such as "44"^^xsd:integer
thus mean what they would mean as XML Schema data values.
The specific meaning given to OWL DL descriptions is shown in the third
column of Figure 1, where ∆I is the domain of individuals in a model and ∆ID
20
Abstract Syntax DL Syntax Semantics
Descriptions (C)
A (URI reference) A AI ⊆ ∆I
owl:Thing > owl:ThingI = ∆I
owl:Nothing ⊥ owl:NothingI = {}
intersectionOf(C1 C2 ...) C1 u C2 (C1 uD1)I = CI1 ∩DI2
unionOf(C1 C2 ...) C1 t C2 (C1 t C2)I = CI1 ∪ CI2
complementOf(C) ¬C (¬C)I = ∆I \ CI
oneOf(o1 ...) {o1, . . .} {o1, . . .}I = {oI1 , . . .}
restriction(R someValuesFrom(C)) ∃R.C (∃R.C)I = {x | ∃y.〈x, y〉 ∈ RI and y ∈ CI}
restriction(R allValuesFrom(C)) ∀R.C (∀R.C)I = {x | ∀y.〈x, y〉 ∈ RI → y ∈ CI}
restriction(R hasValue(o)) R : o (∀R.o)I = {x | 〈x, oI〉 ∈ RI}
restriction(R minCardinality(n)) > n R (> n R)I = {x | ]({y.〈x, y〉 ∈ RI}) > n}
restriction(R minCardinality(n)) 6 n R (> n R)I = {x | ]({y.〈x, y〉 ∈ RI}) 6 n}
restriction(U someValuesFrom(D)) ∃U.D (∃U.D)I = {x | ∃y.〈x, y〉 ∈ UI and y ∈ DD}
restriction(U allValuesFrom(D)) ∀U.D (∀U.D)I = {x | ∀y.〈x, y〉 ∈ UI → y ∈ DD}
restriction(U hasValue(v)) U : v (U : v)I = {x | 〈x, vI〉 ∈ UI}
restriction(U minCardinality(n)) > n U (> n U)I = {x | ]({y.〈x, y〉 ∈ UI}) > n}
restriction(U maxCardinality(n)) 6 n U (6 n U)I = {x | ]({y.〈x, y〉 ∈ UI}) 6 n}
Data Ranges (D)
D (URI reference) D DD ⊆ ∆ID
oneOf(v1 ...) {v1, . . .} {v1, . . .}I = {vI1 , . . .}
Object Properties (R)
R (URI reference) R RI ⊆ ∆I ×∆I
R− (R−)I = (RI)−
Datatype Properties (U)
U (URI reference) U UI ⊆ ∆I ×∆ID
Individuals (o)
o (URI reference) o oI ∈ ∆I
Data Values (v)
v (RDF literal) v vI = vD
Fig. 1. OWL DL Descriptions, Data Ranges, Properties, Indivdiuals, and Data Values
21
Abstract Syntax DL Syntax Semantics
Class(A partial C1 ...Cn) A v C1 u . . . u Cn AI ⊆ CI1 ∩ . . . ∩ CIn
Class(A complete C1 ...Cn) A = C1 u . . . u Cn AI = CI1 ∩ . . . ∩ CIn
EnumeratedClass(A o1 ...on) A = {o1, . . . , on} AI = {oI1 , . . . , oIn}
SubClassOf(C1 C2) C1 v C2 CI1 ⊆ CI2
EquivalentClasses(C1 ...Cn) C1 = . . . = Cn C
I
1 = . . . = C
I
n
DisjointClasses(C1 ...Cn) Ci u Cj = ⊥, i 6= j CIi ∩ CIj {}, i 6= j
Datatype(D) DI ⊆ ∆ID
DatatypeProperty(U super(U1)...super(Un) U v Ui UI ⊆ UIi
domain(C1) ...domain(Cm) > 1 U v Ci UI ⊆ CIi ×∆ID
range(D1) ...range(Dl) > v ∀U.Di UI ⊆ ∆I ×DIi
[Functional]) > v 6 1 U UI is functional
SubPropertyOf(U1 U2) U1 v U2 UI1 ⊆ UI2
EquivalentProperties(U1 ...Un) U1 = . . . = Un U
I
1 = . . . = U
I
n
ObjectProperty(R super(R1)...super(Rn) R v Ri RI ⊆ RIi
domain(C1) ...domain(Cm) > 1 R v Ci RI ⊆ CIi ×∆I
range(C1) ...range(Cl) > v ∀R.Ci RI ⊆ ∆I × CIi
[inverseOf(R0] R = (
−R0) R
I = (RI0 )
−
[Symmetric] R = (−R) RI = (RI)−
[Functional] > v 6 1 R RI is functional
[InverseFunctional] > v 6 1 R− (RI)− is functional
[Transitive]) Tr(R) RI = (RI)+
SubPropertyOf(R1 R2) R1 v R2 RI1 ⊆ RI2
EquivalentProperties(R1 ...Rn) R1 = . . . = Rn R
I
1 = . . . = R
I
n
AnnotationProperty(S)
Individual(o type(C1) ...type(Cn) o ∈ Ci oI ∈ CIi
value(R1 o1)...value(Rn on) 〈o, oi〉 ∈ Ri 〈oI , oIi 〉 ∈ RIi
value(U1 v1)...value(Un vn)) 〈o, vi〉 ∈ Ui 〈oI , vIi 〉 ∈ UIi
SameIndividual(o1 ...on) o1 = . . . = on o
I
i = o
I
j
DifferentIndividuals(o1 ...on) oi 6= oj , i 6= j oIi 6= oIj , i 6= j
Fig. 2. OWL DL Axioms and Facts
22
is the domain of data values. As usual, the meaning of axioms is given in terms
of constraints on models, as shown in the third column of Figure 2.
The semantics for OWL DL does include some unusual (for Description Log-
ics) aspects. Annotations are given a simple separate meaning, not shown here,
that can be used to associate information with classes, properties, and individu-
als in a manner compatible with the RDF semantics. Ontologies also live within
the semantics and can be given annotation information. Finally, owl:imports is
given a meaning that involves finding the referenced ontology (if possible) and
adding its meaning to the meaning of the current ontology.
What makes OWL DL a Semantic Web language, therefore, is not its se-
mantics, which are quite standard for a Description Logic, but instead the use
of URI references for names, the use of XML Schema datatypes for data values,
and the ability to connect to documents in the World Wide Web.
7.3 An Easier OWL: OWL Lite
OWL DL is related to SHOIN (D), a very expressive Description Logic. This
Description Logic is somewhat difficult to present to naive users, as it is possible
to build complex boolean descriptions using, for example, union and complement.
SHOIN (D) is also difficult to reason with, as key inference problems have
NExpTime complexity, and somewhat difficult to build even non-reasoning tools
for, because of the complex descriptions.
For these reasons, a subset of OWL DL has been identified that should be eas-
ier on all the above metrics; this subset is called OWL Lite. OWL Lite prohibits
unions and complements, restricts intersections to the implicit intersections in
the frame-like class axioms, limits all embedded descriptions to concept names,
does not allow individuals to show up in descriptions or class axioms, and limits
cardinalities to 0 or 1.
These restrictions make OWL Lite similar to the Description Logic
SHIF(D). Like SHIF(D), key inferences in OWL Lite can be computed in
worst case exponential time (ExpTime), and there are already several optimized
reasoners for logics equivalent to OWL Lite (see Section 6.5). This improvement
in tractability comes with relatively little loss in expressive power—although
OWL Lite syntax is more restricted than that of OWL DL it is still possible to
express complex descriptions by introducing new class names and exploiting the
implicit negations introduced by disjointness axioms. Using these techniques, all
OWL DL descriptions can be captured in OWL Lite except those containing
either individual names or cardinalities greater than 1.
7.4 OWL Full as an RDF Extension
OWL DL and OWL Lite are extensions of a restricted use of RDF and RDFS,
because, unlike RDF and RDFS, they do not allow classes to be used as individ-
uals, and the language constructors cannot be applied to the language itself. For
users who need these capabilities, a version of OWL that is upward compatible
with RDF and RDFS has been provided; this version is called OWL Full. In
23
OWL Full, all RDF and RDFS combinations are allowed. For example, in OWL
Full, it is possible to empose a cardinality constraint on rdfs:subClassOf, if so
desired.
OWL Full contains OWL DL, but goes well outside the standard Description
Logic framework. The penalty to be paid here is two-fold. First, reasoning in
OWL Full is undecidable (because restrictions required in order to maintain the
decidability of OWL DL do not apply to OWL full [23]). Second, the abstract
syntax for OWL DL is inadequate for OWL Full, and the official OWL exchange
syntax, RDF/XML, must be used.
7.5 Semantics for OWL Full
OWL Full has been given a model-theoretic semantics that is a vocabulary exten-
sion of the RDF model theory [33, 15]. A correspondence between this semantics
and the semantics of OWL DL has also been established: it has been shown that
the model theory for OWL DL has the same consequences as this RDF-style
model theory for those OWL ontologies that can be written in the OWL DL
abstract syntax [33].
The correspondence means that, given two OWL DL ontologies O1 and O2,
written in the abstract syntax, O1 entails O2 according to the OWL DL model
theory if and only if the mapping of O1 into RDF triples entails the mapping
of O2 into RDF triples according to the OWL Full model theory. The proof of
this correspondence is rather complex, and could break down, e.g., as a result
of (apparently) minor changes in the specification of OWL or RDF. In view of
the relative fragility of this correspondence, and in order to avoid any possible
confusion as to the meaning of OWL DL, the OWL Full model theory has been
given “non-normative” status (i.e., it is only informative) for OWL ontologies
that can be written in the abstract syntax. This means that the OWL DL model
theory will be taken as definitive should the correspondence break down or be
shown to be incomplete.
8 Future extensions
Clearly, OWL is not the final word on ontology languages for the Semantic
Web. A number of features were already identified in the OWL Requirements
Document [17], and many others are under discussion. In this section, we briefly
(and non-exhaustively) list a few of these possible extensions and improvements
to OWL as it stands:
modules and imports. Importing ontologies defined by others will be the norm
on the Semantic Web. However, the importing facility of OWL is very trivial:
it only allows to import an entire ontology, specified by location. Even if one
would only want to use a small portion of another ontology, one is forced to
import that entire ontology. Module-constructions in programming languages
are based on a notion of information hiding: the module promises to provide
24
some functionality to the outside world (the export-clause of the module), but the
importing module need not concern itself with how this functionality is achieved.
It is an open research question what a corresponding notion of information hiding
for ontologies could be, and how it could be used as the basis for a good import-
construction
Defaults. Many practical knowledge-representation systems allow inherited val-
ues to be overridden by more specific classes in the hierarchy, treating the in-
herited values as defaults. Although widely used in practical KR, no concensus
has been reached on the right formalisation for the non-monotonic behaviour of
default values.
Closed world assumption. The semantic of OWL currently adopts the standard
logical model of an open world assumption: a statement cannot be assumed true
on the basis of a failure to prove it. Clearly, on the huge and only partially
knowably World Wide Web this is the correct assumption. Nevertheless, the
opposite approach (a closed world assumption: a statement is true when its
negation cannot be proven) is also useful in certain applications. The closed
world assumption is closely tied to the notion of defaults, and leads to the same
non-monotonic behaviour, reason for it not to be included in OWL as it stands.
Unique names assumption. Typical database applications assume that individu-
als with different names are indeed different individuals. OWL follows the usual
logical paradigm where this is not the case. If two individuals (or classes, or
properties) have different names, we may still derive by inference that they must
be the same. As with the non-closed world assumption, the non-unique names
assumption is the most plausible one to make on the World Wide Web, but as
before, situations exist where the unique names assumption is useful. More sub-
tly, one may want to indicate portions of the ontology for which the assumption
does or does not hold.
Procedural attachment. A common concept in Knowledge Representation is to
define the meaning of a term not through explicit definitions in the language (as
is done in OWL), but by attaching a piece of code to be executed for computing
the meaning of the term. Although widely used, this concept does not lend itself
very well to integration in a system with a formal semantics, and has not been
included in OWL.
Property chaining, rules. As explained above, for reasons of decidability, OWL
does currently not allow the composition of properties, but of course in many
applications this is a useful operation. Even more general, one would want to
define properties as general rules (Horn or otherwise) over other properties.
Such integration of rule-based KR and DL-style KR is currently an active area
of research.
25
9 Summary
Because of the ambitious design goals for OWL, because of the multiple influ-
ences on OWL, and also because of the structural requirements constraining
OWL, the development of OWL has not been without problems. Through hard
work and compromise, these problems have largely been overcome, resulting in
a ontology language that is truly part of the Semantic Web.
It was not possible to simultaneously satisfy all of the constraints on OWL,
so two styles of using OWL have been developed, each suitable under different
circumstances.
If an expressive ontology language with decidable inference is the main con-
cern, then the OWL DL style is indicated. This style of using OWL loses some
compatibility with RDF, mostly having to do with using classes and properties
as individuals, but retains an expressive and useful ontology language. OWL DL
also has a frame-like alternative syntax that can be used to make working with
OWL easier.
Even though OWL DL is close to description logics, it includes features that
firmly place it in the Semantic Web. OWL DL uses the datatyping mechanisms
from RDF and many of the built-in XML Schema datatypes. OWL DL uses
RDF URI references as names, including the names from RDF, RDFS, and XML
Schema datatypes that are relevant. Entailment in OWL DL is compatible with
entailment in RDF and RDFS.
If a simpler ontology language is the main concern, then the OWL Lite subset
of OWL DL can be used. This sublanguage eliminates some of the things that
can be said in OWL DL, but has effectively-tractable inference, closely related
to the inference already implemented in several description logic systems, such
as FaCT [21] and RACER [14].
If, on the other hand, upward compatibility with RDF is the main concern,
then the OWL Full style is indicated. This style extends RDF and RDFS to a
full ontology language, with a well-specified entailment relationship that extends
entailment in RDF and RDFS, while avoiding any paradoxes that might arise.
However, entailment in OWL Full is undecidable, which can be a significant issue
in some circumstances. Also, the user-friendly alternative syntax is not adequate
for OWL Full, so RDF/XML must be used for OWL Full.
These styles of using OWL provide an ontology layer for the Semantic Web,
significantly extending the capabilities of RDF and RDFS, and expanding the
usefulness of the Semantic Web.
There remain, of course, significant issues that are deliberately not handled
by OWL, but which are definitely relevant to many Semantic Web use cases:
– OWL avoids anything related to nonmonotonicity (such as default reasoning
and localised closed world assumptions);
– OWL’s limited expressiveness excludes operations such as property-chaining,
or, more generally, axioms with variables (such as rules);
– OWL’s import mechanism is rather crude, and does not support fine-grained
operations (such as the importation of parts of ontologies); and
26
– OWL integrates data-types in a very clean way, but there is no notion of
operations on these datatypes (such integer arithmetic or string operations).
Extending the current Semantic Web with some or all of these features will
require not only a standardisation effort, but sets a significant research challenge
to the community.
Acknowledgements
Major groups involved in the development of OWL include the OIL and
DAML+OIL development teams, and the World Wide Web Consortium Web
Ontology Working Group. There are far too many people involved to list them
individually, even if limited to the major participants.10 The views on the de-
sign decisions of OWL expressed in this paper are those of the authors, and
not necessarily of any of the other individuals involved in the design of these
languages.
References
1. Franz Baader, Diego Calvanese, Deborah McGuinness, Daniele Nardi, and Peter
Patel-Schneider, editors. The Description Logic Handbook. Cambridge University
Press, 2002.
2. Dave Beckett. RDF/XML syntax specification (revised). W3C Working
Draft, 2002. Available at http://www.w3.org/TR/2002/WD-rdf-syntax-grammar-
20021108.
3. Tim Berners-Lee. Weaving the Web. Harper, San Francisco, 1999.
4. Paul V. Biron and Ashok Malhotra. XML Schema Part 2: Datatypes. W3C Rec-
ommendation, 2001. Available at http://www.w3.org/TR/2002/WD-xmlschema-
2-20010502/.
5. Dan Brickley and R. V. Guha. Resource Description Framework (RDF)
Schema Specification 1.0. W3C Recommendation, 27 March 2000. Available at
http://www.w3.org/TR/2000/CR-rdf-schema-20000327/.
6. Dan Brickley and R. V. Guha. RDF Vocabulary Description Language
1.0: RDF Schema. W3C Working Draft, 23 January 2003. Available at
http://www.w3.org/TR/2003/WD-rdf-schema-20030123/.
7. J. Broekstra, M. Klein, S. Decker, D. Fensel, F. van Harmelen, and I. Horrocks.
Enabling knowledge representation on the web by extending RDF schema. In
Proceedings of the tenth World Wide Web conference WWW’10, pages 467–478,
May 2001.
8. Vinay K. Chaudhri, Adam Farquhar, Richard Fikes, Peter D. Karp, and James
Rice. OKBC: A programmatic foundation for knowledge base interoperability. In
Proc. of the 15th Nat. Conf. on Artificial Intelligence (AAAI’98), pages 600–607,
1998.
10 See http://www.ontoknowledge.org/oil/misc.shtml#part,
http://www.daml.org/committee/ and
http://www.w3.org/2001/sw/WebOnt/#Membership.
27
9. Dan Connolly, Frank van Harmelen, Ian Horrocks, Deborah L. McGuinness,
Peter F. Patel-Schneider, and Lynn Andrea Stein. DAML+OIL (March
2001) reference description. W3C Note, 18 December 2001. Available at
http://www.w3.org/TR/2001/NOTE-daml+oil-reference-20011218.
10. Mike Dean, Dan Connolly, Frank van Harmelen, James Hendler, Ian Horrocks,
Deborah L. McGuinness, Peter F. Patel-Schneider, and Lynn Andrea Stein. OWL
web ontology language reference. W3C Working Draft, 31 March 2003. Available
at http://www.w3.org/TR/2003/WD-owl-ref-20030331.
11. Stefan Decker, Dieter Fensel, Frank van Harmelen, Ian Horrocks, Sergey Melnik,
Michel Klein, and Jeen Broekstra. Knowledge representation on the web. In Proc.
of the 2000 Description Logic Workshop (DL 2000), pages 89–97. CEUR Electronic
Workshop Proceedings, http://ceur-ws.org/Vol-33/, 2000.
12. Dieter Fensel, Frank van Harmelen, Ian Horrocks, Deborah L. McGuinness, and
Peter F. Patel-Schneider. OIL: An ontology infrastructure for the semantic web.
IEEE Intelligent Systems, 16(2):38–45, 2001.
13. W. E. Grosso, H. Eriksson, R. W. Fergerson, J. H. Gennari, S. W. Tu, and M. A.
Musen. Knowledge modelling at the millenium (The design and evolution of
Protégé-2000). In Proceedings of Knowledge Acqusition Workshop (KAW’99), 1999.
14. Volker Haarslev and Ralf Möller. RACER system description. In Proc. of the Int.
Joint Conf. on Automated Reasoning (IJCAR 2001), volume 2083 of Lecture Notes
in Artificial Intelligence, pages 701–705. Springer, 2001.
15. Patrick Hayes. RDF semantics. W3C Working Draft, 2003. Available at
http://www.w3.org/TR/2003/WD-rdf-mt-20030123.
16. J. Heflin and J. Hendler. Dynamic ontologies on the web. In Proceedings of
the Seventeenth National Conference on Artificial Intelligence (AAAI2000), pages
443–449, Menlo Park, CA, 2000. AAAI/MIT Press.
17. Jeff Heflin. Web ontology language (owl) use cases and requirements. W3C Work-
ing Draft, 31 March 2003. Available at http://www.w3.org/TR/2003/WD-webont-
req-20030331/.
18. Jeff Heflin, James Hendler, and Sean Luke. SHOE: A Knowledge Representation
Language for Internet Applications. Technical Report CS-TR-4078, University of
Maryland, Department of Computer Science, 1999.
19. James Hendler and Deborah L. McGuinness. The DARPA Agent Markup Lan-
guage”. IEEE Intelligent Systems, 15(6):67–73, 2000.
20. I. Horrocks, D. Fensel, J. Broekstra, S. Decker, M. Erdmann, C. Goble, F. van
Harmelen, M. Klein, S. Staab, R. Studer, and E. Motta. OIL: The Ontology
Inference Layer. Technical Report IR-479, Vrije Universiteit Amsterdam, Faculty
of Sciences, September 2000.
21. Ian Horrocks. Using an expressive description logic: FaCT or fiction? In Proc.
of the 6th Int. Conf. on Principles of Knowledge Representation and Reasoning
(KR’98), pages 636–647, 1998.
22. Ian Horrocks and Ulrike Sattler. Ontology reasoning in the SHOQ(D) description
logic. In Proc. of the 17th Int. Joint Conf. on Artificial Intelligence (IJCAI 2001),
pages 199–204, 2001.
23. Ian Horrocks, Ulrike Sattler, and Stephan Tobies. Practical reasoning for expressive
description logics. In Harald Ganzinger, David McAllester, and Andrei Voronkov,
editors, Proc. of the 6th Int. Conf. on Logic for Programming and Automated
Reasoning (LPAR’99), number 1705 in Lecture Notes in Artificial Intelligence,
pages 161–180. Springer, 1999.
28
24. Ian Horrocks, Ulrike Sattler, and Stephan Tobies. Practical reasoning for very
expressive description logics. J. of the Interest Group in Pure and Applied Logic,
8(3):239–264, 2000.
25. Peter D. Karp, Vinay K. Chaudhri, and Jerome Thomere. XOL: An XML-based
ontology exchange language. Technical Report SRI AI Technical Note 559, SRI
International, Menlo Park (CA, USA), 1999.
26. Graham Klyne and Jeremy J. Carroll. Resource Description Framework (RDF):
Concepts and abstract syntax. W3C Working Draft, 2003. Available at
http://www.w3.org/TR/2003/WD-rdf-concepts-20030123.
27. Lei Li and Ian Horrocks. A software framework for matchmaking based on semantic
web technology. In Proc. of the Twelfth International World Wide Web Conference
(WWW 2003), 2003. To appear.
28. Carsten Lutz. The Complexity of Reasoning with Concrete Domains. PhD thesis,
LuFG Theoretical Computer Science, RWTH Aachen, Germany, 2002.
29. Frank Manola and Eric Miller. Rdf primer. W3C Working Draft, 23 January 2003.
Available at http://www.w3.org/TR/rdf-primer/.
30. D. L. McGuinness. Ontological issues for knowledge-enhanced search. In Proc. of
FOIS, Frontiers in Artificial Intelligence and Applications. IOS-press, 1998.
31. D. L. McGuinness. Ontologies for electronic commerce. In Proc. of the AAAI ’99
Artificial Intelligence for Electronic Commerce Workshop, 1999.
32. S. McIlraith, T.C. Son, and H. Zeng. Semantic web services. IEEE Intelligent
Systems, 16(2):46–53, March/April 2001.
33. Peter F. Patel-Schneider, Patrick Hayes, and Ian Horrocks. OWL web ontology
language semantics and abstract syntax. W3C Working Draft, 31 March 2003.
Available at http://www.w3.org/TR/2003/WD-owl-semantics-20030331/.
34. Manfred Schmidt-Schauß and Gert Smolka. Attributive concept descriptions with
complements. Artificial Intelligence, 48(1):1–26, 1991.
35. Michael K. Smith, Chris Welty, and Deborah McGuinness. OWL web on-
tology language guide. W3C Working Draft, 31 March 2003. Available at
http://www.w3.org/TR/2003/WD-owl-guide-20030331/.
36. Stephan Tobies. Complexity Results and Practical Algorithms for Logics in Knowl-
edge Representation. PhD thesis, LuFG Theoretical Computer Science, RWTH-
Aachen, Germany, 2001.
37. Frank van Harmelen, Ian Horrocks, and Peter F. Patel-Schneider. A model-
theoretic semantics for DAML+OIL (March 2001). W3C Note, 18 December 2001.
Available at http://www.w3.org/TR/2001/NOTE-daml+oil-model-20011218.
38. M. Wessel. Obstacles on the way to qualitative spatial reasoning with descrip-
tion logics: Some undecidability results. In Proc. of the 2001 Description Logic
Workshop (DL 2001), 2001.
Biographies
Peter F. Patel-Schneider is a Member of Technical Staff in Bell Labs Re-
search. He received his Ph. D. from the University of Toronto in 1987. Peter was
a member of the AI Principles Research Department at AT&T Bell Laboratories
from 1988 to 1995, and went to AT&T Labs—Research when AT&T split up.
In August 1997 he rejoined Bell Labs. From 1983 to 1988 he worked in the AI
research group at Fairchild and Schlumberger. Peter has taught courses at both
the University of Toronto and Rutgers University.
29
Peter’s research interests center on the properties and use of description log-
ics. He has designed and implemented large sections of CLASSIC, a Description
Logic-based Knowledge Representation system. He designed and implemented
DLP, a heavily-optimized prover for expressive description logics and proposi-
tional modal logics. He is currently involved with the Web Ontology Working
Group of the World Wide Web Consortium, designing the OWL language for
representing ontologies in the semantic web.
Peter is also interested in rule-based systems, including more-standard sys-
tems derived from OPS as well as newer formalisms such as R++. He designed
many of the techniques used in R++ and the R++ translator, and wrote the
first several prototype implementations of the R++ translator.
Ian Horrocks received his PhD from the University of Manchester in 1997, and
is now a reader in Computer Science at the same institution. His primary research
interest is Knowledge Representation, in particular ontologies and ontology lan-
guages, tableaux algorithms for Description Logics, optimisation techniques for
such algorithms, and the application of all of the above to the Semantic Web. He
designed and implemented the well known FaCT reasoner, and has been involved
in the development of the OIL, DAML+OIL and OWL ontology languages.
Ian has given numerous invited talks, as well as keynote presentations at
several international conferences, including CADE and EDBT. He has published
widely (see http://www.cs.man.ac.uk/∼horrocks/), and is on the programme
committees and editorial boards of numerous conferences and journals; he was
the program chair of the 2002 International Semantic Web Conference and is
the Semantic Web Track Chair for the 2003 World Wide Web Conference. He
is also the coordinator of the EU IST WonderWeb project, and is a principal
investigator on several other EU, EPSRC and DARPA funded research projects.
Frank van Harmelen is a professor in Knowledge Representation & Reasoning
in the AI department (Faculty of Science) at the Vrije Universiteit Amsterdam.
After studying mathematics and computer science in Amsterdam, he moved to
the Department of AI in Edinburgh, where he was awarded a PhD in 1989 for his
research on meta-level reasoning. While in Edinburgh, he worked with Dr. Peter
Jackson on Socrates, a logic-based toolkit for expert systems, and with Prof. Alan
Bundy on proof planning for inductive theorem proving. After his PhD research,
he moved back to Amsterdam where he worked from 1990 to 1995 in the SWI
Department under Prof. Wielinga. He was involved in the REFLECT project
on the use of reflection in expert systems, and in the KADS project, where he
contributed to the development of the (ML)2 language for formally specifying
Knowledge-Based Systems. In 1995 he joined the AI research group at the Vrije
Universiteit Amsterdam, where he was appointed professor in 2002. His current
interests include Approximate reasoning, Semantic Web and Medical Protocols.
He has been involved in a multitude of European Research projects (REFLECT,
CommonKADS, IBROW, Protocure, On-To-Knowledge, SWAP, WonderWeb).
30
He has published three books (on meta-level inference, on knowledge-based
systems, and on the Semantic Web) and over 100 research papers, most of which
can be found on-line at http://www.cs.vu.nl/∼frankh.
31

