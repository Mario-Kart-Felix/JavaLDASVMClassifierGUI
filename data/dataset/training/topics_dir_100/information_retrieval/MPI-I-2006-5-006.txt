Yago: A Core of Semantic
Knowledge
Fabian M. Suchanek, Gjergji
Kasneci and Gerhard Weikum
MPI–I–2006–5-006 November 2006

Authors’ Addresses
Fabian M. Suchanek
Max-Planck-Institut für Informatik
Stuhlsatzenhausweg 85
66123 Saarbrücken
Germany
Gjergji Kasneci
Max-Planck-Institut für Informatik
Stuhlsatzenhausweg 85
66123 Saarbrücken
Germany
Gerhard Weikum
Max-Planck-Institut für Informatik
Stuhlsatzenhausweg 85
66123 Saarbrücken
Germany
Abstract
We present YAGO, a light-weight and extensible ontology with high cov-
erage and quality. YAGO builds on entities and relations and currently
contains roughly 900,000 entities and 5,000,000 facts. This includes the Is-
A hierarchy as well as non-taxonomic relations between entities (such as
hasWonPrize). The facts have been automatically extracted from the uni-
fication of Wikipedia and WordNet, using a carefully designed combination
of rule-based and heuristic methods described in this paper. The resulting
knowledge base is a major step beyond WordNet: in quality by adding knowl-
edge about individuals like persons, organizations, products, etc. with their
semantic relationships – and in quantity by increasing the number of facts by
more than an order of magnitude. Our empirical evaluation of fact correct-
ness shows an accuracy of about 95%. YAGO is based on a logically clean
model, which is decidable, extensible, and compatible with RDFS. Finally,
we show how YAGO can be further extended by state-of-the-art information
extraction techniques.
Keywords
Ontologies, Knowledge Extraction, Wikipedia, WordNet
Contents
1 Introduction 3
1.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 Contributions and Outline . . . . . . . . . . . . . . . . . . . . 4
2 The YAGO model 6
2.1 Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2 Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3 Relation to Other Formalisms . . . . . . . . . . . . . . . . . . 11
3 Sources for YAGO 13
3.1 WordNet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2 Wikipedia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
4 The YAGO system 14
4.1 Knowledge Extraction . . . . . . . . . . . . . . . . . . . . . . 14
4.1.1 The type relation . . . . . . . . . . . . . . . . . . . . 14
4.1.2 The subClassOf relation . . . . . . . . . . . . . . . . 15
4.1.3 The means relation . . . . . . . . . . . . . . . . . . . 17
4.1.4 Other relations . . . . . . . . . . . . . . . . . . . . . . 17
4.1.5 Meta-relations . . . . . . . . . . . . . . . . . . . . . . . 18
4.2 YAGO Storage . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.3 Enriching YAGO . . . . . . . . . . . . . . . . . . . . . . . . . 19
5 Evaluation and Experiments 21
5.1 Manual evaluation . . . . . . . . . . . . . . . . . . . . . . . . 21
5.1.1 Accuracy . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.1.2 Coverage . . . . . . . . . . . . . . . . . . . . . . . . . . 23
5.2 Sample facts . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.3 Enrichment experiment . . . . . . . . . . . . . . . . . . . . . . 25
6 Conclusion 27
1
A Proof of Theorem 1 28
B Proof of Theorem 2 29
2
1 Introduction
1.1 Motivation
Many applications in modern information technology utilize ontological back-
ground knowledge. This applies above all to applications in the vision of the
Semantic Web, but there are many other application fields. Machine transla-
tion (e.g. [5]) and word sense disambiguation (e.g. [3]) exploit lexical knowl-
edge, query expansion uses taxonomies (e.g. [15, 11, 27]), document clas-
sification based on supervised or semi-supervised learning can be combined
with ontologies (e.g. [14]), and [13] demonstrates the utility of background
knowledge for question answering and information retrieval. Furthermore,
ontological knowledge structures play an important role in data cleaning
(e.g., for a data warehouse) [6], record linkage (aka. entity resolution) [7],
and information integration in general [18].
But the existing applications typically use only a single source of back-
ground knowledge (mostly WordNet [10] or Wikipedia). They could boost
their performance, if a huge ontology with knowledge from several sources
was available. Such an ontology would have to be of high quality, with accu-
racy close to 100 percent, i.e. comparable in quality to an encyclopedia. It
would have to comprise not only concepts in the style of WordNet, but also
named entities like people, organizations, geographic locations, books, songs,
products, etc., and also relations among these such as what-is-located-where,
who-was-born-when, who-has-won-which-prize, etc. It would have to be ex-
tensible, easily re-usable, and application-independent. If such an ontology
were available, it could boost the performance of existing applications and
also open up the path towards new applications in the Semantic Web era.
1.2 Related Work
Knowledge representation is an old field in AI and has provided numerous
models from frames and KL-ONE to recent variants of description logics and
3
RDFS and OWL (see [21] and [23]). Numerous approaches have been pro-
posed to create general-purpose ontologies on top of these representations.
One class of approaches focusses on extracting knowledge structures auto-
matically from text corpora. These approaches use information extraction
technologies that include pattern matching, natural-language parsing, and
statistical learning [25, 9, 4, 1, 22, 19, 8]. These techniques have also been
used to extend WordNet by Wikipedia individuals [20]. Another project
along these lines is KnowItAll [9], which aims at extracting and compiling
instances of unary and binary predicate instances on a very large scale – e.g.,
as many soccer players as possible or almost all company/CEO pairs from the
business world. Although these approaches have recently improved the qual-
ity of their results considerably, the quality is still significantly below that
of a man-made knowledge base. Typical results contain many false positives
(e.g., IsA(Aachen Cathedral, City), to give one example from KnowItAll).
Furthermore, obtaining a recall above 90 percent for a closed domain typi-
cally entails a drastic loss of precision in return. Thus, information-extraction
approaches are only of little use for applications that need near-perfect on-
tologies (e.g. for automated reasoning). Furthermore, they typically do not
have an explicit (logic-based) knowledge representation model.
Due to the quality bottleneck, the most successful and widely employed
ontologies are still man-made. These include WordNet [10], Cyc or OpenCyc
[16], SUMO [17], and especially domain-specific ontologies and taxonomies
such as SNOMED1 or the GeneOntology2. These knowledge sources have
the advantage of satisfying the highest quality expectations, because they
are manually assembled. However, they suffer from low coverage, high cost
for assembly and quality assurance, and fast aging. No human-made ontology
knows the most recent Windows version or the latest soccer stars.
1.3 Contributions and Outline
This paper presents YAGO3, a new ontology that combines high coverage
with high quality. Its core is assembled from one of the most comprehen-
sive lexicons available today, Wikipedia. But rather than using information
extraction methods to leverage the knowledge of Wikipedia, our approach
utilizes the fact that Wikipedia has category pages. Category pages are lists
of articles that belong to a specific category (e.g., Zidane is in the cate-
gory of French football players4). These lists give us candidates for entities
1http://www.snomed.org
2http://www.geneontology.org/
3Yet Another Great Ontology
4Soccer is called football in some countries
4
(e.g. Zidane), candidates for concepts (e.g. IsA(Zidane, FootballPlayer)) and
candidates for relations (e.g. isCitizenOf(Zidane, France)). In an ontology,
concepts have to be arranged in a taxonomy to be of use. The Wikipedia
categories are indeed arranged in a hierarchy, but this hierarchy is barely
useful for ontological purposes. For example, Zidane is in the super-category
named ”Football in France”, but Zidane is a football player and not a foot-
ball. WordNet, in contrast, provides a clean and carefully assembled hierar-
chy of thousands of concepts. But the Wikipedia concepts have no obvious
counterparts in WordNet.
In this paper we present new techniques that link the two sources with
near-perfect accuracy. To the best of our knowledge, our method is the
first approach that accomplishes this unification between WordNet and facts
derived from Wikipedia with an accuracy of 97%. This allows the YAGO
ontology to profit, on one hand, from the vast amount of individuals known
to Wikipedia, while exploiting, on the other hand, the clean taxonomy of
concepts from WordNet. Currently, YAGO contains roughly 900,000 entities
and 5 million relations between them.
YAGO is based on a data model of entities and binary relations. But by
means of reification (i.e., introducing identifiers for relation instances) we can
also express relations between relation instances (e.g., popularity rankings of
pairs of soccer players and their teams) and general properties of relations
(e.g., transitivity or acyclicity). We show that, despite its expressiveness, the
YAGO data model is decidable.
YAGO is designed to be extendable by other sources – be it by other high
quality sources (such as gazetteers of geographic places and their relations),
by domain-specific extensions, or by data gathered through information ex-
traction from Web pages. We conduct an enrichment experiment with the
state-of-the-art information extraction system Leila[25]. We show that the
more facts YAGO contains, the better it can be extended. We observe that
this positive feedback loop could even accelerate future extensions.
The rest of this paper is organized as follows. In Chapter 2 we introduce
YAGO’s data model. Chapter 3 describes the sources from which the current
YAGO is assembled, namely, Wikipedia and WordNet. In Chapter 4 we
give an overview of the system behind YAGO. We explain our extraction
techniques and we show how YAGO can be extended by new data. Chapter
5 presents an evaluation, a comparison to other ontologies, an enrichment
experiment and sample facts from YAGO. We conclude with a summary in
Chapter 6.
5
2 The YAGO model
2.1 Structure
To accommodate the ontological data we already extracted and to be pre-
pared for future extensions, YAGO must be based on a thorough and expres-
sive data model. The model must be able to express entities, facts, relations
between facts and properties of relations. The state-of-the-art formalism in
knowledge representation is currently the Web Ontology Language OWL [23].
Its most expressive variant, OWL-full, can express properties of relations, but
is undecidable. RDFS, the basis of OWL, can also express properties of re-
lations, but provides only very primitive semantics (e.g. it does not know
transitivity). This is why we introduce a slight extension of RDFS, the YAGO
model. The YAGO model can express relations between facts and relations,
while it is at the same time decidable and computationally simple.
As in OWL and RDFS, all beings (e.g. cities, people, even URLs) are
represented as entities in the YAGO model. Two entities can stand in a
relation. For example, to state that Albert Einstein won the Nobel Prize, we
say that the entity Albert Einstein stands in the hasWonPrize relation
with the entity Nobel Prize. We write
AlbertEinstein hasWonPrize NobelPrize
Numbers, dates, strings and other literals are represented as entities as well.
This means that they can stand in relations to other entities. For example,
to state that Albert Einstein was born in 1879, we write:
AlbertEinstein bornInYear 1879
Entities are abstract ontological beings, which are language-independent in
the ideal case. Language uses words to refer to these entities. In the YAGO
model, words are entities as well. This makes it possible to express that a
certain word refers to a certain entity, like in the following example:
”Einstein” means AlbertEinstein
6
This allows us to deal with synonymy and ambiguity. The following line says
that ”Einstein” may also refer to the musicologist Alfred Einstein:
”Einstein” means AlfredEinstein
We use quotes to distinguish words from other entities. Similar entities are
grouped into classes. For example, the class physicist comprises all physi-
cists and the class word comprises all words. Each entity is an instance of at
least one class. We express this by the type relation:
AlbertEinstein type physicist
Classes are also entities. Thus, each class is itself an instance of a class,
namely of the class class. Classes are arranged in a taxonomic hierarchy,
expressed by the subClassOf relation:
physicist subClassOf scientist
In the YAGO model, relations are entities as well. This makes it possible
to represent properties of relations (like transitivity or subsumption) within
the model. The following line, e.g., states that the subClassOf relation is
transitive by making it an instance of the class transitiveRelation:
subclassOf type transitiveRelation
The triple of an entity, a relation and an entity is called a fact. The two enti-
ties are called the arguments of the fact. Each fact is given a fact identifier.
As RDFS, the YAGO model considers fact identifiers to be entities as well.
This allows us to represent for example that a certain fact was found at a
certain URL. For example, suppose that the above fact (Albert Einstein,
bornInYear, 1879) had the fact identifier #1, then the following line would
say that this fact was found in Wikipedia:
#1 foundIn http : //www.wikipedia.org/Einstein
We will refer to entities that are neither facts nor relations as common enti-
ties. Common entities that are not classes will be called individuals. Then, a
YAGO ontology over a finite set of common entities C, a finite set of relation
names R and a finite set of fact identifiers I is a function
y : I → (I ∪ C ∪ R)×R× (I ∪ C ∪ R)
A YAGO ontology y has to be injective and total to ensure that every fact
identifier of I is mapped to exactly one fact.
7
Some facts require more than two arguments (for example the fact
that Einstein won the Nobel Prize in 1921). One common way to
deal with this problem is to use n-ary relations (as for example in
won-prize-in-year(Einstein, Nobel-Prize, 1921)). In a relational
database setting, where relations correspond to tables, this has the disad-
vantage that much space will be wasted if not all arguments of the n-ary
facts are known. Worse, if an argument (like e.g. the place of an event) has
not been foreseen in the design phase of the database, the argument cannot
be represented. Another way of dealing with an n-ary relation is to introduce
a binary relation for each argument (e.g. winner, prize, time). Then, an
n-ary fact can be represented by a new entity that is linked by these binary
relations to all of its arguments (as it is proposed for OWL):
AlbertEinstein winner EinsteinWonNP1921
NobelPrize prize EinsteinWonNP1921
1921 time EinsteinWonNP1921
However, this method cannot deal with additional arguments for relations
that were designed to be binary. The YAGO model offers a simple solution
to this problem: It is based on the assumption that for each n-ary relation, a
primary pair of its arguments can be identified. For example, for the above
won-prize-in-year-relation, the pair of the person and the prize could be
considered a primary pair. The primary pair can be represented as a binary
fact with a fact identifier:
#1 : AlbertEinstein hasWonPrize NobelPrize
All other arguments can be represented as relations that hold between the
primary pair and the other argument:
#2 : #1 time 1921
2.2 Semantics
This section will give a model-theoretic semantics to YAGO. We first pre-
scribe that the set of relation names R for any YAGO ontology must con-
tain at least the relation names type, subClassOf, domain, range and sub-
RelationOf. The set of common entities C must contain at least the classes
entity, class, relation, acyclicTransitiveRelation and classes for all
literals (as evident from the following list). For the rest of the paper, we
assume a given set of common entities C and a given set of relations R.
The set of fact identifiers used by a YAGO ontology y is implicitly given by
I = domain(y). To define the semantics of a YAGO ontology, we consider
8
only the set of possible facts F = (I ∪ C ∪R)×R× (I ∪ C ∪R). We define
a rewrite system → ⊆ P(F) × P(F), i.e. → reduces one set of facts to
another set of facts. We use the shorthand notation {f1, ..., fn} ↪→ f to say
that
F ∪ {f1, ..., fn} → F ∪ {f1, ..., fn} ∪ {f}
for all F ⊆ F , i.e. if a set of facts contains the facts f1, ..., fn, then the
rewrite rule adds f to this set. Our rewrite system contains the following
(axiomatic) rules:1
∅ ↪→ (domain, domain, relation)
∅ ↪→ (domain, range, class)
∅ ↪→ (range, domain, relation)
∅ ↪→ (range, range, class)
∅ ↪→ (subClassOf, type, acyclicTransitiveRelation)
∅ ↪→ (subClassOf, domain, class)
∅ ↪→ (subClassOf, range, class)
∅ ↪→ (type, range, class)
∅ ↪→ (subRelationOf, type, acyclicTransitiveRelation)
∅ ↪→ (subRelationOf, domain, relation)
∅ ↪→ (subRelationOf, range, relation)
∅ ↪→ (boolean, subClassOf, literal)
∅ ↪→ (number, subClassOf, literal)
∅ ↪→ (rationalNumber, subClassOf, number)
∅ ↪→ (integer, subClassOf, rationalNumber)
∅ ↪→ (timeInterval, subClassOf, literal)
∅ ↪→ (dateTime, subClassOf, timeInterval)
∅ ↪→ (date, subClassOf, timeInterval)
∅ ↪→ (string, subClassOf, literal)
∅ ↪→ (character, subClassOf, string)
∅ ↪→ (word, subClassOf, string)
∅ ↪→ (URL, subClassOf, string)
Furthermore, it contains the following rules for all r, r1, r2 ∈ R,
x, y, c, c1, c2 ∈ I ∪ C ∪ R, r1 6= type, r2 6= subRelationOf, r 6=
subRelationOf, r 6= type, c 6= acyclicTransitiveRelation, c2 6=
acyclicTransitiveRelation:
(1) {(r1, subRelationOf, r2), (x, r1, y)} ↪→ (x, r2, y)
(2) {(r,type, acyclicTransitiveRelation), (x, r, y), (y, r, z)}
↪→ (x, r, z)
(3) {(r,domain, c), (x, r, c)} ↪→ (x,type, c)
1The class hierarchy of literals is inspired by SUMO[17]
9
(4) {(r,range, c), (x, r, y)} ↪→ (y,type, c)
(5) {(x,type, c1), (c1, subClassOf, c2)} ↪→ (x,type, c2)
Theorem 1: [Convergence of →]
Given a set of facts F ⊂ F , the largest set S with F →∗ S is
unique.
(The theorems are proven in the appendix.) Given a YAGO ontology y, the
rules of → can be applied to its set of facts, range(y). We call the largest set
that can be produced by applying the rules of → the set of derivable facts of
y, D(y). Two YAGO ontologies y1, y2 are equivalent if the fact identifiers in
y2 can be renamed so that
(y1 ⊆ y2 ∨ y2 ⊆ y1) ∧ D(y1) = D(y2)
The deductive closure of a YAGO ontology y is computed by adding the
derivable facts to y. Each derivable fact (x, r, y) needs a new fact identifier,
which is just fx,r,y. Using a relational notation for the function y, we can
write this as
y∗ := y ∪ { (fr,x,y, (r, x, y)) |
(x, r, y) ∈ D(y) , (r, x, y) 6∈ range(y) }
A structure for a YAGO ontology y is a triple of
• a set U (the universe)
• a function D : I ∪ C ∪ R → U (the denotation)
• a function E : D(R) → U × U (the extension function)
Like in RDFS, a YAGO structure needs to define the extensions of the re-
lations by the extension function E . E maps the denotation of a relation
symbol to a relation on universe elements. We define the interpretation Ψ
with respect to a structure < U ,D, E > as the following relation:
Ψ := {(e1, r, e2) | (D(e1),D(e2)) ∈ E(D(r))}
We say that a fact (e1, r, e2) is true in a structure, if it is contained in the
interpretation. A model of a YAGO ontology y is a structure such that
1. all facts of y∗ are true
2. if Ψ(x,type, literal) for some x, then D(x) = x
3. if Ψ(r,type, acyclicTransitiveRelation) for some r, then there ex-
ists no x such that Ψ(x, r, x)
10
A YAGO ontology y is called consistent iff there exists a model for it. Ob-
viously, a YAGO ontology is consistent iff
6 ∃x, r : (r,type, acyclicTransitiveRelation) ∈ D(y)
∧ (x, r, x) ∈ D(y)
Since D(y) is finite, the consistency of a YAGO ontology is decidable. A
base of a YAGO ontology y is any equivalent YAGO ontology b with b ⊆ y.
A canonical base of y is a base so that there exists no other base with less
elements.
Theorem 2: [Uniqueness of the Canonical Base]
The canonical base of a consistent YAGO ontology is unique.
In fact, the canonical base of a YAGO ontology can be computed by greedily
removing facts from the ontology. This makes the canonical base a natural
choice to efficiently store a YAGO ontology.
2.3 Relation to Other Formalisms
The YAGO model is very similar to RDFS. In RDFS, relations are called
properties. Just as YAGO, RDFS knows the properties domain, range,
subClassOf and subPropertyOf (i.e. subRelationOf). These properties
have a semantics that is equivalent to that of the corresponding YAGO re-
lations. RDFS also knows fact identifiers, which can occur as arguments of
other facts. The following excerpt shows how some sample facts of Chapter
2.1 can be represented in RDFS. Each fact of YAGO becomes a triple in
RDFS.
<rdf:Description
rdf:about="http://mpii.mpg.de/yago#Albert_Einstein">
<yago:bornIn rdf:ID="f1">1879</yago:bornIn>
</rdf:Description>
<rdf:Description
rdf:about="http://mpii.mpg.de/yago#f1">
<yago:foundIn rdf:ID="f2" rdf:resource="http:..."/>
</rdf:Description>
However, RDFS does not have a built-in transitive relation or an acyclic
transitive relation, as YAGO does. This entails that the property acyclic-
TransitiveRelation can be defined and used, but that RDFS would not
know its semantics.
YAGO uses fact identifiers, but it does not have built-in relations to
make logical assertions about facts (e.g. it does not allow to say that a
11
fact is false). If one relies on the denotation to map a fact identifier to the
corresponding fact element in the universe, one can consider fact identifiers as
simple individuals. This abandons the syntactic link between a fact identifier
and the fact. In return, it opens up the possibility of mapping a YAGO
ontology to an OWL ontology under certain conditions. OWL has built-
in counterparts for almost all built-in data types, classes, and relations of
YAGO. The only concept that does not have an exact built-in counterpart is
the acyclicTransitiveRelation. However, this is about to change. OWL
is currently being refined to its successor, OWL 1.1. The extended description
logic SROIQ [12], which has been adopted as the logical basis of OWL 1.1,
allows to express irreflexivity and transitivity. This allows to define acyclic
transitivity. We plan to investigate the relation of YAGO and OWL once
OWL 1.1 has been fully established.
12
3 Sources for YAGO
3.1 WordNet
WordNet is a semantic lexicon for the English language developed at the Cog-
nitive Science Laboratory of Princeton University. WordNet distinguishes be-
tween words as literally appearing in texts and the actual senses of the words.
A set of words that share one sense is called a synset. Thus, each synset
identifies one sense (i.e., semantic concept). Words with multiple meanings
(ambiguous words) belong to multiple synsets. As of the current version 2.1,
WordNet contains 81,426 synsets for 117,097 unique nouns. (Wordnet also
includes other types of words like verbs and adjectives, but we consider only
nouns in this paper.) WordNet provides relations between synsets such as
hypernymy/hyponymy (i.e., the relation between a sub-concept and a super-
concept) and holonymy/meronymy (i.e., the relation between a part and the
whole); for this paper, we focus on hypernyms/hyponyms. Conceptually, the
hypernymy relation in WordNet spans a directed acyclic graph (DAG) with
a single source node called Entity.
3.2 Wikipedia
Wikipedia is a multilingual, Web-based encyclopedia. It is written collabo-
ratively by volunteers and is available for free. We downloaded the English
version of Wikipedia in August 2006, which comprised 1,200,000 articles at
that time. Each Wikipedia article is a single Web page and usually describes
a single topic.
The majority of Wikipedia pages have been manually assigned to one
or multiple categories. The page about Albert Einstein, for example, is in
the categories German language philosophers, Swiss physicists, and 34
more. Conveniently, the categorization of Wikipedia pages and their link
structure are available as SQL tables, so that they can be exploited without
parsing the actual Wikipedia articles.
13
4 The YAGO system
Our system is designed to extract a YAGO ontology from WordNet and
Wikipedia. Currently, the relations of YAGO are fixed. Their properties
(such as domain and range) are described in Table 5.2.
YAGO is designed to be extendable, i.e. new facts from new sources
can be added to the ontology. For this purpose, each fact is tagged with a
confidence value. In the current YAGO, all facts have a confidence of 1.0,
but facts extracted by other techniques (e.g. based on statistical learning)
can have smaller confidence values.
4.1 Knowledge Extraction
4.1.1 The type relation
Since Wikipedia knows far more individuals than WordNet, the individuals
for YAGO are taken from Wikipedia. Each Wikipedia page title is a candi-
date to become an individual in YAGO. For example, the page title ”Albert
Einstein” is a candidate to become the individual AlbertEinstein in our
ontology. The page titles in Wikipedia are unique.
The Wikipedia Category System. To establish for each individual its
class, we exploit the category system of Wikipedia. There are different types
of categories: Some categories, the conceptual categories, indeed identify a
class for the entity of the page (e.g. Albert Einstein is in the category Nat-
uralized citizens of the United States). Other categories serve administrative
purposes (e.g. Albert Einstein is also in the category Articles with unsourced
statements), others yield relational information (like 1879 births) and again
others indicate merely thematic vicinity (like Physics).
Identifying Conceptual Categories. Only the conceptual categories
are candidates for serving as a class for the individual. The administrative
and relational categories are very few (less than a dozen) and can be ex-
cluded by hand. To distinguish the conceptual categories from the thematic
14
ones, we employ a shallow linguistic parsing of the category name (using the
Noun Group Parser of [26]). For example, a category name like Naturalized
citizens of the United States is broken into a pre-modifier (Naturalized), a
head (citizens) and a post-modifier (of the United States). Heuristically, we
found that if the head of the category name is a plural word, the category
is most likely a conceptual category. We used the Pling-Stemmer from [26]
to reliably identify and stem plural words. This gives us a (possibly empty)
set of conceptual categories for each Wikipedia page. Conveniently, articles
that do not describe individuals (like hub pages) do not have conceptual cat-
egories. Thus, the conceptual categories yield not only the type relation,
but also, as its domain, the set of individuals. It also yields, as its range, a
set of classes.
4.1.2 The subClassOf relation
The Wikipedia categories are organized in a directed acyclic graph, which
yields a hierarchy of categories. This hierarchy, however, reflects merely the
thematic structure of the Wikipedia pages (e.g., as mentioned in the intro-
duction, Zidane is in the category Football in France). Thus, the hierarchy
is of little use from an ontological point of view. WordNet, in contrast, offers
an ontologically well-defined taxonomy of synsets. Hence we use WordNet
to establish the hierarchy of classes in YAGO.
Integrating WordNet Synsets. Each synset of WordNet becomes a
class of YAGO. Care is taken to exclude the proper nouns known to WordNet,
which in fact would be individuals (Albert Einstein, e.g., is also known to
WordNet, but excluded). There are roughly 15,000 cases, in which an entity is
contributed by both WordNet and Wikipedia (i.e. a WordNet synset contains
a common noun that is the name of a Wikipedia page). In some of these
cases, the Wikipedia page describes an individual that bears a common noun
as its name (e.g. ”Time exposure” is a common noun for WordNet, but
an album title for Wikipedia). In the overwhelming majority of the cases,
however, the Wikipedia page is simply about the common noun (e.g. the
Wikipedia page ”Physicist” is about physicists). To be on the safe side, we
always give preference to WordNet and discard the Wikipedia individual in
case of a conflict. This way, we lose information about individuals that bear
a common noun as name, but it ensures that all common nouns are classes
and no entity is duplicated.
Establishing subClassOf. The subClassOf hierarchy of classes is
taken from the hyponymy relation from WordNet: A class is a subclass of
another one, if the first synset is a hyponym of the second. Now, the lower
classes extracted from Wikipedia have to be connected to the higher classes
extracted from WordNet. For example, the Wikipedia class American people
15
in Japan has to be made a subclass of the WordNet class person. To this
end, we use the following algorithm:
Function wiki2wordnet(c)
Input: Wikipedia category name c
Output: WordNet synset
1 head =headCompound(c)
2 pre =preModifier(c)
3 post =postModifier(c)
4 head =stem(head)
5 If there is a WordNet synset s for pre + head
6 return s
7 If there are WordNet synsets s1, ...sn for head
8 (ordered by their frequency for head)
9 return s1
10 fail
We first determine the head compound, the pre-modifier and the post-
modifier of the category name (lines 1-3). For the Wikipedia category Amer-
ican people in Japan, these are ”American”, ”people” and ”in Japan”, re-
spectively. We stem the head compound of the category name (i.e. people)
to its singular form (i.e. person) in line 4. Then we check whether there is
a WordNet synset for the concatenation of pre-modifier and head compound
(i.e. American person). If this is the case, the Wikipedia class becomes a
subclass of the WordNet class (lines 5-6). If this is not the case, we exploit
that the Wikipedia category names are almost exclusively endocentric com-
pound words (i.e. the category name is a hyponym of its head compound,
e.g. ”American person” is a hyponym of ”person”). The head compound
(person) has to be mapped to a corresponding WordNet synset (s1, ..., sn in
line 7). This mapping is non-trivial, since one word may refer to multiple
synsets in WordNet. We experimented with different disambiguation ap-
proaches. Among others, we mapped the co-occurring categories of a given
category to their possible synsets as well and determined the smallest sub-
graph of synsets that contained one synset for each category. WordNet stores
with each word the frequencies with which it refers to the possible synsets.
We found out that mapping the head compound simply to the most frequent
synset (s1) yields the correct synset in the overwhelming majority of cases.
This way, the Wikipedia class American people in Japan becomes a subclass
of the WordNet class person/human.
Exceptions. There were only a dozen prominent exceptions, which we
corrected manually. For example, all categories with the head compound
capital in Wikipedia mean the ”capital city”, but the most frequent sense in
WordNet is ”financial asset”. In summary, we obtain a complete hierarchy
16
of classes, where the upper classes stem from WordNet and the leaves come
from Wikipedia.
4.1.3 The means relation
Exploiting WordNet Synsets. Wikipedia and WordNet also yield infor-
mation on word meaning. WordNet for example reveals the meaning of words
by its synsets. For example, the words ”urban center” and ”metropolis” both
belong to the synset city. We leverage this information in two ways. First,
we introduce an entity for each noun known to WordNet (i.e. ”physicist”).
Second, we establish a means relation between each word of synset and the
corresponding class (i.e. (”physicist”, means, physicist)).
Exploiting Wikipedia Redirects. Wikipedia contributes names for
the individuals by its redirect system: a Wikipedia redirect is a virtual
Wikipedia page, which links to a real Wikipedia page. These links serve
to redirect users to the correct Wikipedia article. For example, if the user
typed ”Einstein, Albert” instead of ”Albert Einstein”, then there is a virtual
redirect page for ”Einstein, Albert” that links to ”Albert Einstein”. We ex-
ploit the redirect pages to give us alternative names for the entities. For each
redirect, we introduce a corresponding means fact (e.g. (”Einstein, Albert”,
means, Albert Einstein)).
Parsing Person Names. The YAGO hierarchy of classes allows us to
identify individuals that are persons. If the words used to refer to these in-
dividuals match the common pattern of a given name and a family name, we
extract the name components and establish the relations givenNameOf and
familyNameOf. For example, we know that Albert Einstein is a person,
so we introduce the facts (”Einstein”, familyNameOf, Albert Einstein)
and (”Albert”, givenNameOf, Albert Einstein). Both are subrelations
of means, so that the family name ”Einstein”, for example, also means
Albert Einstein. We used the Name Parser from [26] to identify and de-
compose the person names.
4.1.4 Other relations
Exploiting Wikipedia Categories. We exploit relational Wikipedia
categories for the extraction of the following relations: bornInYear,
diedInYear, establishedInYear, locatedIn, writtenInYear,
politicianOf, and hasWonPrize. For the extraction of the bornInYear
and diedInYear facts we make use of the categories ending with “ births”
and “ deaths” respectively. For example, if a page is in the category
“1879 births”, it means that the corresponding individual is a person born
in 1879.
17
The establishedInYear facts are extracted from categories end-
ing with “ establishments”. For example, if a page is in the category
1980 establishments, this means that the corresponding individual (mostly
an organization) was established in 1980. We normalize vague date expres-
sions (like “5’th century BC”) to a common form (e.g. -500).
The locatedIn facts are extracted from categories that imply that all
its members share a geographical location. For example, if a page is in the
category Cities in Germany, this indicates that the corresponding individual
is located in Germany. We make use of categories starting with Countries
in..., Rivers of..., Attractions in... and similar ones. Note that we do not
need to extract the classes for the individuals, since this information has
already been extracted within the scope of the type relation.
Further relations that we considered are the writtenInYear relation
which holds between books and the year in which they appeared, the politi-
cianOf relation which holds between politicians and states as well as the
hasWonPrize relation which concerns prize winners and the prizes they
won. The facts for these three relations were extracted analogously to the
afore mentioned facts.
Filtering the Results. Not all facts extracted this way constitute valid
facts in the YAGO ontology, because their arguments may not be entities,
but arbitrary Wikipedia pages. This is why a cleaning step is necessary, in
which we filter out all facts with arguments that are not in the domain of the
previously established type relation. Despite the huge number of extracted
facts, the actual extraction process took only a few hours. This is because it
is not necessary to access the Wikipedia pages themselves – let alone parse
them or POS-tag them. All information is derived from the category lists.
4.1.5 Meta-relations
Descriptions. Due to its generality, the YAGO ontology can store meta-
relations uniformly together with usual relations. For example, we store for
each individual the URL of the corresponding Wikipedia page. This will
allow future applications to provide the user with detailed information on
the entities. We introduce the describes relation between the individual
and its URL for this purpose.
Witnesses. YAGO is prepared to be extended by new facts. If a new
fact was extracted from a particular Web page, we call this page the witness
for the fact. We introduce the foundIn relation, which holds between a
fact and the URL of the witness page. We use the extractedBy relation
to identify the technique by which a fact was extracted. The information
about witnesses will enable applications to use, e.g., only facts extracted by
a certain technique, facts extracted from a certain source or facts of a certain
18
date.
Context. Last, we store for each individual the individuals it is linked
to in the corresponding Wikipedia page. For example, Albert Einstein is
linked to Relativity Theory. For this purpose, we introduce the context
relation between individuals. This will allow applications to use related terms
for disambiguation purposes. Different from a simple co-occurence table of
words, the context relation connects entities instead of words, i.e. its
arguments are already disambiguated.
4.2 YAGO Storage
The YAGO model itself is independent of a particular data storage format.
To produce minimal overhead, we decided to use simple text files as an inter-
nal format. We maintain a folder for each relation and each folder contains
files that list the entity pairs. We store only facts that cannot be derived
by the rewrite rules of YAGO (see 2.2), so that we store in fact the unique
canonical base of the ontology. We plan to make the files publicly available,
so that the YAGO ontology can be used freely for research purposes.
Furthermore, we provide conversion programs to convert the ontology to
different output formats. First, YAGO is available as a simple XML version
of the text files. Furthermore, YAGO can be converted to a database table.
The table has the simple schema
FACTS(factId,arg1,relation,arg2,confidence). We provide software to
load YAGO into an Oracle or MySQL database. For our experiments, we
used the Oracle version of YAGO. Last, we also provide an RDFS version of
YAGO, as explained in Chapter 2.3.
4.3 Enriching YAGO
YAGO is designed to be extendable by new facts. An application that adds
new facts to the YAGO ontology is required to obey the following protocol.
Suppose that the application wishes to add the fact (x, r, y). First, it has
to map x and y to existing entities in the YAGO ontology. This task is
essentially a word sense disambiguation problem, in which the “words” x and
y have to be disambiguated to YAGO entities. For the disambiguation, the
application can make use of the extensive information that YAGO provides
for the existing entities: the relations to other entities, the words used to refer
to the entities, and the context of the entities, as provided by the context
relation. If x or y do not yet exist in the ontology, they have to be added as
new entities. Next, r has to be mapped to a relation in the YAGO ontology.
19
Currently, YAGO comprises only a fixed set of relations, which simplifies
this task. The application should provide a confidence value c ∈ [0, 1] for the
proposed fact (x, r, y).
If (x, r, y) exists already in the ontology, the application merely adds a
new witness for this fact. Supposing that the fact identifier of the existing fact
is f and that the witness is w, the new fact would be (f, foundIn, w) with
confidence c. Then, the confidence of the existing fact has to be recomputed
as an aggregation of the confidences of the witnesses. We propose to take
the maximum, but other options can be considered. If (x, r, y) does not yet
exist in the ontology, the application has to add the fact together with a
new fact identifier. We propose to use name spaces as in OWL/RDFS: each
application has a universally unique id and the fact identifier is composed
of the application id and a running number. Chapter 5.3 shows how the
enrichment can be implemented in practice.
20
5 Evaluation and Experiments
5.1 Manual evaluation
5.1.1 Accuracy
We were interested in the accuracy of YAGO. To evaluate the accuracy of an
ontology, its facts have to be compared to some ground truth. Since there
is no computer-processable ground truth of suitable extent, we had to rely
on manual evaluation. We presented randomly selected facts of the ontol-
ogy to anonymous human judges and asked them to assess whether the facts
were correct. Since common sense often does not suffice to judge the correct-
ness of YAGO facts, we also presented them a snippet of the corresponding
Wikipedia page. Thus, our evaluation compared YAGO against the ground
truth of Wikipedia (i.e., it does not deal with the problem of Wikipedia con-
taining false information). Of course, it would be pointless to evaluate the
portion of YAGO that stems from WordNet, because we can assume human
accuracy here. Likewise, it would be pointless to evaluate the non-heuristic
relations in YAGO, such as describes, means, or context. This is why we
evaluated only those facts that constitute potentially weak points in the on-
tology. To be sure that our findings are significant, we computed the Wilson
intervals for α = 5%.
The evaluation shows very good results. Especially the crucial type relation
and the link between WordNet and Wikipedia, subClassOf, turned out
to be very accurate. Our heuristic algorithms cannot always achieve an
accuracy of 100%, tough. This may also have to do with the inconsistency
of the underlying sources. For example, for the relation bornInYear, most
false facts stem from erroneous Wikipedia categories (e.g. some person born
in 1802 is in the Wikipedia category 1805 births). In addition, the evaluation
of an ontology is sometimes a philosophical issue. To start with, even simple
relations suffer from vagueness (e.g. is Lake Victoria locatedIn Tanzania,
if Tanzania borders the lake? Is an economist who works in France a French
Economist, even if he was born in Ireland?). Next, it is not always clear
21
Table 5.1: Accuracy of YAGO
Relation # evalu- Accuracy
ated facts
subClassOf 298 97.70% ± 1.59%
type 343 94.54% ± 2.36%
familyNameOf 221 97.81% ± 1.75%
givenNameOf 161 97.62% ± 2.08%
establishedInYear 170 90.84% ± 4.28%
bornInYear 170 93.14% ± 3.71%
diedInYear 147 98.72% ± 1.30%
locatedIn 180 98.41% ± 1.52%
politicianOf 176 92.43% ± 3.93%
writtenInYear 172 94.35% ± 3.33%
hasWonPrize 122 98.47% ± 1.57%
whether an entity should be an individual or a class (e.g. a judge might decide
that physics is an individual, because it is an instance of science). YAGO,
however, in accordance with WordNet, sees abstract notions in general as
classes, because they can have subclasses (e.g., physics can have the subclass
astrophysics). Furthermore, not everybody may agree on the definition of
synsets in WordNet (e.g., a palace is in the same synset as a castle in
WordNet). Thus, the above results measure not only the correctness of the
facts in YAGO, but also the accuracy of Wikipedia category assignments, the
judges’ philosophical agreement with the YAGO semantics and the judges’
agreement with the definition of WordNet synsets. This type of disputability
is inherent even to human-made ontologies. Thus, we can be extremely
satisfied with our results. Further note that these values measure just the
potentially weakest point of YAGO, as all other facts were derived non-
heuristically.
It is difficult to compare YAGO to other information extraction ap-
proaches, because the approaches usually differ in the choice of relations
and in the choice of the sources. YAGO is tailored to Wikipedia and Word-
Net, but it comes with a multitude of interconnected relations. Furthermore,
accuracy can usually be varied at the cost of recall. Approaches that use pat-
tern matching (e.g. the Espresso System [19] or Leila [25]) typically achieve
accuracy rates of 50%-92%, depending on the extracted relation. State-of-
the-art taxonomy induction as described in [22] achieves an accuracy of 84%.
KnowItAll [9] and KnowItNow [4] are reported to have accuracy rates of 85%
and 80%, respectively.
22
5.1.2 Coverage
Table 5.2 shows the number of facts for each relation in YAGO. The overall
number of ontological facts is about 5 million. This number is completed by
the respective witness facts and approximately 40 million context facts.
Table 5.2: Coverage of YAGO (facts)
Relation Domain Range # Facts
subClassOf class class 126,792
type entity class 2,011,072
context entity entity ∼40,000,000
describes word entity 997,061
bornInYear person year 189,950
diedInYear person year 93,827
establishedInYear entity year 14,602
locatedIn object region 60,354
writtenInYear book year 4,399
politiciansOf organization person 3,618
hasWonPrize person prize 1,024
means word entity 2,166,891
familyNameOf word person 181,926
givenNameOf word person 177,291
Table 5.3 shows the number of entities in YAGO.
Table 5.3: Coverage of YAGO (entities)
Relations 14
Classes 84,513
Individuals (without words) 818,248
It is not easy to compare the coverage of YAGO to other ontologies, because
the ontologies usually differ in their structure, their relations and their do-
main. For informational purposes, we list the number of entities and facts
that are reported for some of the most important other domain-independent
ontologies in Table 5.4.
With the exception of Cyc (which is not publicly available), the facts of these
ontologies are in the hundreds of thousands, whereas the facts of YAGO are
in the millions.
23
Table 5.4: Coverage of other ontologies
Ontology Entities Facts
KnowItNow [4] N/A 25,860
KnowItAll [9] N/A 29,835
SUMO [17] 20,000 60,000
WordNet [10] 117,597 207,016
OpenCyc [16] 47,000 306,000
Cyc [16] 250,000 2,200,000
5.2 Sample facts
Table 5.5 shows some sample facts of YAGO. In YAGO, the word ”Paris”,
can refer to 71 distinct entities. We list some interesting ones. The football
player Zinedine Zidane, e.g., is an instance of 24 different classes in our
ontology. We list some of them. In the table, type+subclass means that
the individual is an instance of a class that is a subclass of the given class.
Table 5.5: Sample facts of YAGO
Zidane type+subclass football player
Zidane type Person from Marseille
Zidane type Legion d’honneur recipient
Zidane bornInYear 1972
”Paris” familyNameOf Priscilla Paris
”Paris” givenNameOf Paris Hilton
”Paris” means Paris, France
”Paris” means Paris, Texas
Paris, France locatedIn France
Paris, France type+subclass capital
Paris, France type Eurovision host city
Paris, France establishedInYear -300
We also provide an interface to query YAGO in a SPARQL-like fashion [28]
1. A query is a list of facts containing variables and regular expressions.
Preprocessing ensures that words in the query are considered in all their
possible meanings. The query algorithms are not in the scope of this paper
(see [24] for details). Here, we only show some sample queries to illustrate
the applicability of YAGO (Table 5.6).
1Available at http://www.mpii.mpg.de/∼suchanek
24
Table 5.6: Sample queries on YAGO
Query Result
When was ”Mostly Harmless” written? $y=1992
(Mostly Harmless,writtenInYear,$y)
Which humanists were born in 1879? $h=Albert Einstein
($h, type subClassOf*, humanist) and 2 more
($h, bornInYear, 1879)
Which locations in Texas and
Illinois bear the same name? $n=”Farmersville”
($t, locatedIn, Texas) and 121 more
($n, means, $t)
($n, means, $k)
($k, locatedIn, Illinois)
5.3 Enrichment experiment
To demonstrate how an application can add new facts to the YAGO on-
tology, we conducted an experiment with the knowledge extraction system
Leila [25]. Leila is a state-of-the-art system that uses pattern matching on
natural language text. It can extract facts of a certain given relation from
Web documents. We trained Leila for the headquarteredIn relation (as
described in [26]). This relation holds between a company and the city of its
headquarters. We ran Leila on a corpus of 150 news documents and had
it extract pairs of companies and headquarters (see [26] for details). Each
extracted pair is a candidate fact (e.g. if Leila extracted the pair Microsoft
/ Redmond, then (Microsoft, headquarteredIn, Redmond) is a candidate
fact). Since the headquarteredIn relation is not part of YAGO, no candi-
date fact is already present in YAGO. For each candidate fact, the company
and the city have to be mapped to the respective individuals in YAGO.
To disambiguate the company name, we proceeded as follows: By the
means relation, one can find out which individuals in YAGO the company
name refers to. If exactly one of these individuals is an instance of the
class company, we map the company name to this individual. If multiple
individuals are instances of the class company, we cannot be sure which one
is meant. In this case, we abandon the candidate fact, because we aim at a
high accuracy at the cost of a potentially lower coverage (this did not happen
in our experiment). If no individual is a company, we introduce the company
name as a new individual for YAGO.
To disambiguate the city name, we proceed similarly. We identify a set
of potential individuals by the means relation together with the constraint
that the individual be a city. If no individual is a city, we abandon the
25
fact because we assume that Wikipedia knows all major cities. If multiple
individuals are a city, we use a simple disambiguation heuristic: We pick
the city located in the state that is mentioned most frequently in the article.
If no such city exists, the fact is abandoned. This way, both the company
and the city get mapped to the respective YAGO individuals.
The confidence of the new fact is computed as a normalization of the
confidence score returned by Leila. Table 5.7 shows the number of company
names and headquarteredIn facts contributed by Leila.
Table 5.7: Leila headquarteredIn facts
Abandoned candidates
because of an unknown city 32
because of an ambiguous city 33
because of an ambiguous company 0
Total 65
Inserted candidates
with a known company name 10
with a new company name 70
Total 80
In the above merging process, entities that are already present in the ontology
help to disambiguate new entities. Thus, the more facts and entities YAGO
contains, the better it can be extended by new facts. The better YAGO
can be extended, the more facts it will contain. This mutual contribution
constitutes a positive re-enforcement loop, which could help future expansion.
26
6 Conclusion
In this paper, we presented YAGO, a light-weight and extendable ontology
of high quality and coverage. YAGO contains 900,000 entities and 5 mil-
lion facts – more than any other publicly available formal ontology. As our
evaluation shows, YAGO has a near-human accuracy around 95%.
Our data model defines a clear semantics for YAGO. It is decidable and
it guarantees that the smallest ontology in a set of equivalent ontologies is
unique, so that there is a canonical way to store a YAGO ontology.
We demonstrated how YAGO can be extended by facts extracted from
Web documents through state-of-the-art extraction techniques. We observed
that the more facts YAGO contains, the easier it is to extend it by further
facts. This positive feedback loop could facilitate the growth of the knowledge
base. YAGO will be made available in different export formats, including
plain text, XML, RDFS and SQL database formats.
YAGO opens the door to numerous new challenges. On the theoretical
side, we plan to investigate the relationship between OWL 1.1 and the YAGO
model, once OWL 1.1 has been fully developed. This might necessitate
extensions or additional semantic restrictions of the YAGO model. On the
practical side, we plan to enrich YAGO by further facts – including high
confidence facts from gazetteers, but also extracted information from Web
pages. In particular, we envisage to analyze and exploit the positive feedback
loop of data gathering. We hope that the availability of a huge, clean, and
high quality ontology can give new impulses to the Semantic Web vision.
27
Appendix A Proof of
Theorem 1
Be F a (finite) set of fact triples, as defined in Chapter 2.2. Be → the
rewrite system defined there (see [2] for a reference on term rewriting). All
rules of the rewrite system are of the form F → F ∪ {f}, where F ⊆ F and
f ∈ F . Hence → is monotone. Furthermore, F is finite. Hence → is finitely
terminating. It is easy to see that if F → F ∪ {f1} and F → F ∪ {f2} for
some F ⊆ F and f1, f2 ∈ F , then
F → F ∪ {f1} → F ∪ {f1, f2}
F → F ∪ {f2} → F ∪ {f1, f2}
Hence → is locally confluent. Since → is finitely terminating, → is glob-
ally confluent and convergent. Thus, given any set of facts F ⊆ F , the largest
set DF with F →∗ DF is unique and finite.
28
Appendix B Proof of
Theorem 2
A canonical base of a YAGO ontology y is any base b of y, such that there
exists no other base b′ of y with |b′| < |b|. This section will prove that,
for a consistent YAGO ontology, there exists exactly one such base. In the
following,→ denotes the rewrite system and F denotes the set of facts defined
in Chapter 2.2.
Lemma 1: [No circular rules ]
Be y a consistent YAGO ontology, be {f1, ..., fn} a set of facts.
Then there are no sets of facts F1, ..., Fn, such that that F1, ..., Fn ⊆
D(y) and
F1 ↪→ f1 with f2 ∈ F1
F2 ↪→ f2 with f3 ∈ F2
...
Fn ↪→ fn with f1 ∈ Fn
Proof: By analyzing all possible pairs of rule schemes (1)...(5), one finds
that the above rules must fall into one of the following categories:
• All rules are instances of (5). In this case, (c, subClassOf, c) ∈ D(y)
for some common entity c and hence y cannot be consistent.
• All rules are instances of (1). In this case, (c, subRelationOf, c) ∈
D(y) for some common entity c and hence y cannot be consistent.
• All rules are instances of (2). In this case, (c, r, c) ∈ D(y) for some
common entity c and relation r and (r,type,acyclicTransitive-
Relation)∈ D(y) and hence y cannot be consistent.
• n = 2, one rule is an instance of (1), and the other an instance of (2). In
this case, (c, r, c) ∈ D(y) for some common entity c and relation r and
29
(r,type,acyclicTransitiveRelation)∈ D(y) and hence y cannot be
consistent.
Lemma 2: [No derivable facts in canonical base]
Be y a consistent YAGO ontology. Be b a canonical base of y and
B = range(b). Be f ∈ D(y) a fact such that D(y)\{f} → D(y).
Then f 6∈ B.
Proof: Since b is a base, there is a sequence of sets of facts B0, ..., Bn such
that
B = B0 → B1 → B2 → . . . → Bn−1 → Bn = D(y)
This sequence is a sequence of rule applications, where each rule has the form
S ↪→ s, where S ⊆ F and s ∈ F . We call S the premise of the rule and
s its conclusion. We say that a fact t contributes to a set of facts T in the
sequence B0, ...Bn, if there is a sequence of rule applications r1, ...rm, so that
t is in the premise of r1, the conclusion of r1 is in the premise of r2 etc. and
the conclusion of rm is in T .
Now assume f ∈ B. Since D(y)\{f} → D(y), there must be a rule
G ↪→ f with G ⊆ D(y)\{f}. Be i ∈ [0, n] the smallest index such that
Bi ⊇ G. f cannot contribute to G, because then there would exist circular
rules in the sense of the preceding lemma. Hence f does not contribute to
G. Then B\{f} is also a base, because the above rule applications can be
re-ordered so that f is derived from Bi. Hence b cannot be a canonical base.
Now we are ready to prove Theorem 2:
Theorem 2: [Uniqueness of the Canonical Base]
The canonical base of a consistent YAGO ontology is unique.
Proof: Be b a canonical base of a consistent YAGO ontology y. Be B =
range(b). We define the set
C := D(y) \ {f | D(y)\{f} → D(y)}
Intuitively speaking, C contains only those facts that cannot be derived from
other facts in D(y). By the previous lemma, B ⊆ C. Assume B ⊂ C, i.e.
there exists a fact f ∈ C, f 6∈ B. Since C ⊆ D(y), f ∈ D(y). Since b is a
base, there exists a rule S ↪→ f for some S ⊆ D(y). Hence f 6∈ C, which is
a contradiction. Hence B = C and every canonical base equals b.
This theorem entails that the canonical base of a YAGO ontology can be
computed by removing all facts that can be derived from other facts in the
set of derivable facts.
30
Bibliography
[1] E. Agichtein and L. Gravano. Snowball: extracting relations from large
plain-text collections. In ICDL, 2000.
[2] F. Baader and T. Nipkow. Term rewriting and all that. Cambridge
University Press, New York, NY, USA, 1998.
[3] R. C. Bunescu and M. Pasca. Using encyclopedic knowledge for named
entity disambiguation. In EACL, 2006.
[4] M. J. Cafarella, D. Downey, S. Soderland, and O. Etzioni. KnowItNow:
Fast, scalable information extraction from the web. In EMNLP, 2005.
[5] N. Chatterjee, S. Goyal, and A. Naithani. Resolving pattern ambiguity
for english to hindi machine translation using WordNet. In Workshop
on Modern Approaches in Translation Technologies, 2005.
[6] S. Chaudhuri, V. Ganti, and R. Motwani. Robust identification of fuzzy
duplicates. In ICDE, 2005.
[7] W. W. Cohen and S. Sarawagi. Exploiting dictionaries in named en-
tity extraction: combining semi-markov extraction processes and data
integration methods. In KDD, 2004.
[8] H. Cunningham, D. Maynard, K. Bontcheva, and V. Tablan. GATE:
A framework and graphical development environment for robust NLP
tools and applications. In ACL, 2002.
[9] O. Etzioni, M. J. Cafarella, D. Downey, S. Kok, A.-M. Popescu,
T. Shaked, S. Soderland, D. S. Weld, and A. Yates. Web-scale informa-
tion extraction in KnowItAll. In WWW, 2004.
[10] C. Fellbaum, editor. WordNet: An Electronic Lexical Database. MIT
Press, 1998.
31
[11] J. Graupmann, R. Schenkel, and G. Weikum. The spheresearch engine
for unified ranked retrieval of heterogeneous XML and web documents.
In VLDB, 2005.
[12] I. Horrocks, O. Kutz, and U. Sattler. The even more irresistible SROIQ.
In KR, 2006.
[13] W. Hunt, L. Lita, and E. Nyberg. Gazetteers, wordnet, encyclopedias,
and the web: Analyzing question answering resources. Technical Report
CMU-LTI-04-188, Language Technologies Institute, Carnegie Mellon,
2004.
[14] G. Ifrim and G. Weikum. Transductive learning for text classification
using explicit knowledge models. In PKDD, 2006.
[15] S. Liu, F. Liu, C. Yu, and W. Meng. An effective approach to document
retrieval via utilizing wordnet and recognizing phrases. In SIGIR, 2004.
[16] C. Matuszek, J. Cabral, M. Witbrock, and J. DeOliveira. An introduc-
tion to the syntax and content of Cyc. In AAAI Spring Symposium,
2006.
[17] I. Niles and A. Pease. Towards a standard upper ontology. In FOIS,
2001.
[18] N. F. Noy, A. Doan, and A. Y. Halevy. Semantic integration. AI Mag-
azine, 26(1):7–10, 2005.
[19] P. Pantel and M. Pennacchiotti. Espresso: Leveraging generic patterns
for automatically harvesting semantic relations. In ACL, 2006.
[20] M. Ruiz-Casado, E. Alfonseca, and P. Castells. Automatic extraction of
semantic relationships for WordNet by means of pattern learning from
Wikipedia. In NLDB, pages 67–79, 2006.
[21] S. Russell and P. Norvig. Artificial Intelligence: a Modern Approach.
Prentice Hall, 2002.
[22] R. Snow, D. Jurafsky, and A. Y. Ng. Semantic taxonomy induction from
heterogenous evidence. In ACL, 2006.
[23] S. Staab and R. Studer. Handbook on Ontologies. Springer, 2004.
[24] F. Suchanek, G. Kasneci, M. Ramanath, and G. Weikum. Naga: Uncoil-
ing the Web. Research Report MPI-I-2006-5-007, Max-Planck-Institut
für Informatik, Germany, 2006.
32
[25] F. M. Suchanek, G. Ifrim, and G. Weikum. Combining linguistic and
statistical analysis to extract relations from web documents. In KDD,
2006.
[26] F. M. Suchanek, G. Ifrim, and G. Weikum. LEILA: Learning to Extract
Information by Linguistic Analysis. In Workshop on Ontology Popula-
tion at ACL/COLING, 2006.
[27] M. Theobald, R. Schenkel, and G. Weikum. TopX and XXL at INEX
2005. In INEX, 2005.
[28] W3C. Sparql, 2005. retrieved from http://www.w3.org/TR/rdf-sparql-
query/.
33
Below you find a list of the most recent technical reports of the Max-Planck-Institut für Informatik. They
are available by anonymous ftp from ftp.mpi-sb.mpg.de under the directory pub/papers/reports. Most
of the reports are also accessible via WWW using the URL http://www.mpi-sb.mpg.de. If you have any
questions concerning ftp or WWW access, please contact reports@mpi-sb.mpg.de. Paper copies (which
are not necessarily free of charge) can be ordered either by regular mail or by e-mail at the address below.
Max-Planck-Institut für Informatik
Library
attn. Anja Becker
Stuhlsatzenhausweg 85
66123 Saarbrücken
GERMANY
e-mail: library@mpi-sb.mpg.de
MPI-I-2006-5-006 F.M. Suchanek, G. Kasneci,
G. Weikum
Yago: A Core of Semantic Knowledge
MPI-I-2006-RG1-001 S. Hirth, C. Karl, C. Weidenbach Automatic Infrastructure for ..... Analysis
MPI-I-2006-5-005 R. Angelova, S. Siersdorfer A Neighborhood-Based Approach for Clustering of
Linked Document Collections
MPI-I-2006-5-004 F. Suchanek, G. Ifrim, G. Weikum Combining Linguistic and Statistical Analysis to
Extract Relations from Web Documents
MPI-I-2006-5-003 V. Scholz, M. Magnor Garment Texture Editing in Monocular Video
Sequences based on Color-Coded Printing Patterns
MPI-I-2006-5-002 H. Bast, D. Majumdar, R. Schenkel,
M. Theobald, G. Weikum
IO-Top-k: Index-access Optimized Top-k Query
Processing
MPI-I-2006-5-001 M. Bender, S. Michel, G. Weikum,
P. Triantafilou
Overlap-Aware Global df Estimation in Distributed
Information Retrieval Systems
MPI-I-2006-4-010 A. Belyaev, T. Langer, H. Seidel Mean Value Coordinates for Arbitrary Spherical
Polygons and Polyhedra in R3
MPI-I-2006-4-009 J. Gall, J. Potthoff, B. Rosenhahn ,
C. Schnoerr, H. Seidel
Interacting and Annealing Particle Filters:
Mathematics and a Recipe for Applications
MPI-I-2006-4-008 I. Albrecht, M. Kipp, M. Neff,
H. Seidel
Gesture Modeling and Animation by Imitation
MPI-I-2006-4-007 O. Schall, A. Belyaev, H. Seidel Feature-preserving Non-local Denoising of Static and
Time-varying Range Data
MPI-I-2006-4-006 C. Theobalt, N. Ahmed, H. Lensch,
M. Magnor, H. Seidel
Enhanced Dynamic Reflectometry for Relightable
Free-Viewpoint Video
MPI-I-2006-4-005 A. Belyaev, H. Seidel, S. Yoshizawa Skeleton-driven Laplacian Mesh Deformations
MPI-I-2006-4-004 V. Havran, R. Herzog, H. Seidel On Fast Construction of Spatial Hierarchies for Ray
Tracing
MPI-I-2006-4-003 E. de Aguiar, R. Zayer, C. Theobalt,
M. Magnor, H. Seidel
A Framework for Natural Animation of Digitized
Models
MPI-I-2006-4-002 G. Ziegler, A. Tevs, C. Theobalt,
H. Seidel
GPU Point List Generation through Histogram
Pyramids
MPI-I-2006-4-001 R. Mantiuk ?
MPI-I-2006-2-001 T. Wies, V. Kuncak, K. Zee,
A. Podelski, M. Rinard
On Verifying Complex Properties using Symbolic Shape
Analysis
MPI-I-2006-1-007 I. Weber ?
MPI-I-2006-1-006 M. Kerber Division-Free Computation of Subresultants Using
Bezout Matrices
MPI-I-2006-1-004 E. de Aguiar ?
MPI-I-2006-1-001 M. Dimitrios ?
MPI-I-2005-5-002 S. Siersdorfer, G. Weikum Automated Retraining Methods for Document
Classification and their Parameter Tuning
MPI-I-2005-4-006 C. Fuchs, M. Goesele, T. Chen,
H. Seidel
An Emperical Model for Heterogeneous Translucent
Objects
MPI-I-2005-4-005 G. Krawczyk, M. Goesele, H. Seidel Photometric Calibration of High Dynamic Range
Cameras
MPI-I-2005-4-004 C. Theobalt, N. Ahmed, E. De Aguiar,
G. Ziegler, H. Lensch, M.A.,. Magnor,
H. Seidel
Joint Motion and Reflectance Capture for Creating
Relightable 3D Videos
MPI-I-2005-4-003 T. Langer, A.G. Belyaev, H. Seidel Analysis and Design of Discrete Normals and
Curvatures
MPI-I-2005-4-002 O. Schall, A. Belyaev, H. Seidel Sparse Meshing of Uncertain and Noisy Surface
Scattered Data
MPI-I-2005-4-001 M. Fuchs, V. Blanz, H. Lensch,
H. Seidel
Reflectance from Images: A Model-Based Approach for
Human Faces
MPI-I-2005-2-004 Y. Kazakov A Framework of Refutational Theorem Proving for
Saturation-Based Decision Procedures
MPI-I-2005-2-003 H.d. Nivelle Using Resolution as a Decision Procedure
MPI-I-2005-2-002 P. Maier, W. Charatonik, L. Georgieva Bounded Model Checking of Pointer Programs
MPI-I-2005-2-001 J. Hoffmann, C. Gomes, B. Selman Bottleneck Behavior in CNF Formulas
MPI-I-2005-1-008 C. Gotsman, K. Kaligosi,
K. Mehlhorn, D. Michail, E. Pyrga
Cycle Bases of Graphs and Sampled Manifolds
MPI-I-2005-1-008 D. Michail ?
MPI-I-2005-1-007 I. Katriel, M. Kutz A Faster Algorithm for Computing a Longest Common
Increasing Subsequence
MPI-I-2005-1-003 S. Baswana, K. Telikepalli Improved Algorithms for All-Pairs Approximate
Shortest Paths in Weighted Graphs
MPI-I-2005-1-002 I. Katriel, M. Kutz, M. Skutella Reachability Substitutes for Planar Digraphs
MPI-I-2005-1-001 D. Michail Rank-Maximal through Maximum Weight Matchings
MPI-I-2004-NWG3-001 M. Magnor Axisymmetric Reconstruction and 3D Visualization of
Bipolar Planetary Nebulae
MPI-I-2004-NWG1-001 B. Blanchet Automatic Proof of Strong Secrecy for Security
Protocols
MPI-I-2004-5-001 S. Siersdorfer, S. Sizov, G. Weikum Goal-oriented Methods and Meta Methods for
Document Classification and their Parameter Tuning
MPI-I-2004-4-006 K. Dmitriev, V. Havran, H. Seidel Faster Ray Tracing with SIMD Shaft Culling
MPI-I-2004-4-005 I.P. Ivrissimtzis, W.-. Jeong, S. Lee,
Y.a. Lee, H.-. Seidel
Neural Meshes: Surface Reconstruction with a Learning
Algorithm
MPI-I-2004-4-004 R. Zayer, C. Rssl, H. Seidel r-Adaptive Parameterization of Surfaces
MPI-I-2004-4-003 Y. Ohtake, A. Belyaev, H. Seidel 3D Scattered Data Interpolation and Approximation
with Multilevel Compactly Supported RBFs
MPI-I-2004-4-002 Y. Ohtake, A. Belyaev, H. Seidel Quadric-Based Mesh Reconstruction from Scattered
Data
MPI-I-2004-4-001 J. Haber, C. Schmitt, M. Koster,
H. Seidel
Modeling Hair using a Wisp Hair Model
MPI-I-2004-2-007 S. Wagner Summaries for While Programs with Recursion
MPI-I-2004-2-002 P. Maier Intuitionistic LTL and a New Characterization of Safety
and Liveness
MPI-I-2004-2-001 H. de Nivelle, Y. Kazakov Resolution Decision Procedures for the Guarded
Fragment with Transitive Guards
MPI-I-2004-1-006 L.S. Chandran, N. Sivadasan On the Hadwiger’s Conjecture for Graph Products
MPI-I-2004-1-005 S. Schmitt, L. Fousse A comparison of polynomial evaluation schemes
MPI-I-2004-1-004 N. Sivadasan, P. Sanders, M. Skutella Online Scheduling with Bounded Migration
MPI-I-2004-1-003 I. Katriel On Algorithms for Online Topological Ordering and
Sorting
MPI-I-2004-1-002 P. Sanders, S. Pettie A Simpler Linear Time 2/3 - epsilon Approximation for
Maximum Weight Matching

