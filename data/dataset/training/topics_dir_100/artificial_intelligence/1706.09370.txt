DynASP2.5: Dynamic Programming on
Tree Decompositions in Actionâˆ—
Johannes K. Fichte, Markus Hecher, Michael Morak, Stefan Woltran
TU Wien, Vienna, Austria
lastname@dbai.tuwien.ac.at
June 29, 2017
Abstract
A vibrant theoretical research area are efficient exact parameterized algorithms. Very recent
solving competitions such as the PACE challenge show that there is also increasing practical
interest in the parameterized algorithms community. An important research question is whether
dedicated parameterized exact algorithms exhibit certain practical relevance and one can even beat
well-established problem solvers. We consider the logic-based declarative modeling language and
problem solving framework Answer Set Programming (ASP). State-of-the-art ASP solvers rely
considerably on Sat-based algorithms. An ASP solver (DynASP2), which is based on a classical
dynamic programming on tree decompositions, has been published very recently. Unfortunately,
DynASP2 can outperform modern ASP solvers on programs of small treewidth only if the question
of interest is to count the number of solutions. In this paper, we describe underlying concepts of our
new implementation (DynASP2.5) that shows competitive behavior to state-of-the-art ASP solvers
even for finding just one solution when solving problems as the Steiner tree problem that have been
modeled in ASP on graphs with low treewidth. Our implementation is based on a novel approach
that we call multi-pass dynamic programming (M-DPSINC).
1 Introduction
Answer set programming (ASP) is a logic-based declarative modelling language and problem solving
framework [18], where a program consists of sets of rules over propositional atoms and is interpreted
under an extended stable model semantics [23]. Problems are usually modelled in ASP in such a way that
the stable models (answer sets) of a program directly form a solution to the considered problem instance.
Computational problems for disjunctive, propositional ASP such as deciding whether a program has an
answer set are complete for the second level of the Polynomial Hierarchy [9]. In consequence, finding
answer sets usually involves a Sat part (finding a model of the program) and an Unsat part (minimality
check). A variety of CDCL-based ASP solvers have been implemented [19, 4] and proven to be very
successful in solving competitions [14]. Very recently, a dynamic programming based solver (DynASP2 )
that builds upon ideas from parameterized algorithmics was proposed [11]. For disjunctive input
programs, the runtime of the underlying algorithms is double exponential in the incidence treewidth
and linear in the input size (so-called fixed-parameter linear algorithms). DynASP2 (i) takes a tree
decomposition of a certain graph representation (incidence graph) of a given input program and (ii) solves
the program via dynamic programming (DP) on the tree decomposition by traversing the tree exactly
once. Both finding a model and checking minimality are considered at the same time. Once the root
node has been reached, complete solutions (if exist) for the input program can be constructed. This
approach pays off for counting answer sets, but is not competitive for outputting just one answer set.
âˆ—This is the authors self-archived copy including detailed proofs. Research was supported by the Austrian Science Fund
(FWF), Grant Y698.
1
ar
X
iv
:1
70
6.
09
37
0v
1 
 [
cs
.L
O
] 
 2
8 
Ju
n 
20
17
The reason for that lies in the exhaustive nature of dynamic programming as all potential values are
computed locally for each node of the tree decomposition. In consequence, space requirements can
be quite extensive resulting in long running times. Moreover, dynamic programming algorithms on
tree decompositions may yield extremely diverging run-times on tree decompositions of the exact same
width [1]. In this paper, we propose a multi-pass approach (M-DPSINC) for dynamic programming on
tree decompositions as well as a new implementation (DynASP2.5). In contrast to classical dynamic
programming algorithms for problems on the second level of the Polynomial Hierarchy, M-DPSINC traverses
the given tree decomposition multiple times. Starting from the leaves, we compute and store (i) sets of
atoms that are relevant for the Sat part (finding a model of the program) up to the root. Then we
go back again to the leaves and compute and store (ii) sets of atoms that are relevant for the Unsat
part (checking for minimality). Finally, we go once again back to the leaves and (iii) link sets from past
Passes (i) and (ii) that might lead to an answer set in the future. As a result, we allow for early cleanup
of candidates that do not lead to answer sets.
Further, we present technical improvements (including working on non-normalized tree decom-
positions) and employ dedicated customization techniques for selecting tree decompositions. Our
improvements are main ingredients to speedup the solving process for DP algorithms. Experiments
indicate that DynASP2.5 is competitive even for finding one answer set using the Steiner tree problem
on graphs with low treewidth. In particular, we are able to solve instances that have an upper bound on
the incidence treewidth of 14 (whereas DynASP2 solved instances of treewidth at most 9).
Our main contributions can be summarized as follows:
1. We establish a novel fixed-parameter linear algorithm (M-DPSINC), which works in multiple passes
and computes Sat and Unsat parts separately.
2. We present an implementation (DynASP2.5)1 and an experimental evaluation.
Related Work. Jakl, Pichler, and Woltran [17] have considered ASP solving when parameterized by the
treewidth of a graph representation and suggested fixed-parameter linear algorithms. Fichte et al. [11]
have established additional algorithms and presented empirical results on an implementation that is
dedicated to counting answer sets for the full ground ASP language. The present paper extends their
work by a multi-pass dynamic programming algorithm. Bliem et al. [5] have introduced a general multi-
pass approach and an implementation (D-FLATË†2) for dynamic programming on tree decompositions
solving subset minimization tasks. Their approach allows to specify dynamic programming algorithms
by means of ASP. In a way, one can see ASP in their approach as a meta-language to describe table
algorithms2, whereas our work presents a dedicated algorithm to find an answer set of a program. In
fact, our implementation extends their general ideas for subset minimization (disjunctive rules) to also
support weight rules. However, due to space constraints we do not report on weight rules in this paper.
Beyond that, we require specialized adaptions to the ASP problem semantics, including three valued
evaluation of atoms, handling of non-normalized tree decompositions, and optimizations in join nodes
to be competitive. Abseher, Musliu, and Woltran [2] have presented a framework that computes tree
decompositions via heuristics, which is also used in our solver. Other tree decomposition systems can be
found on the PACE challenge website [7]. Note that improved heuristics for finding a tree decomposition
of smaller width (if possible) directly yields faster results for our solver.
2 Formal Background
2.1 Tree Decompositions
Let G = (V,E) be a graph, T = (N,F, n) a rooted tree, and Ï‡ : N â†’ 2V a function that maps
each node t âˆˆ N to a set of vertices. We call the sets Ï‡(Â·) bags and N the set of nodes. Then,
the pair T = (T, Ï‡) is a tree decomposition (TD) of G if the following conditions hold: (i) for every
1The source code of our solver is available at https://github.com/daajoe/dynasp/releases/tag/v2.5.0.
2See Algorithm 1 for the concept of table algorithms.
2
vertex v âˆˆ V there is a node t âˆˆ N with v âˆˆ Ï‡(t); (ii) for every edge e âˆˆ E there is a node t âˆˆ N with
e âŠ† Ï‡(t); and (iii) for any three nodes t1, t2, t3 âˆˆ N , if t2 lies on the unique path from t1 to t3, then
Ï‡(t1) âˆ© Ï‡(t3) âŠ† Ï‡(t2). We call max{|Ï‡(t)| âˆ’ 1 | t âˆˆ N} the width of the TD. The treewidth tw(G) of a
graph G is the minimum width over all possible TDs of G.
Note that each graph has a trivial TD (T, Ï‡) consisting of the tree ({n}, âˆ…, n) and the mapping
Ï‡(n) = V . It is well known that the treewidth of a tree is 1, and a graph containing a clique of size k
has at least treewidth k âˆ’ 1. For some arbitrary but fixed integer k and a graph of treewidth at most k,
we can compute a TD of width 6 k in time 2O(k
3) Â· |V | [6]. Given a TD (T, Ï‡) with T = (N, Â·, Â·), for a
node t âˆˆ N we say that type(t) is leaf if t has no children; join if t has children tâ€² and tâ€²â€² with tâ€² 6= tâ€²â€²
and Ï‡(t) = Ï‡(tâ€²) = Ï‡(tâ€²â€²); int (â€œintroduceâ€) if t has a single child tâ€², Ï‡(tâ€²) âŠ† Ï‡(t) and |Ï‡(t)| = |Ï‡(tâ€²)|+ 1;
rem (â€œremovalâ€) if t has a single child tâ€², Ï‡(tâ€²) âŠ‡ Ï‡(t) and |Ï‡(tâ€²)| = |Ï‡(t)|+ 1. If every node t âˆˆ N has
at most two children, type(t) âˆˆ {leaf, join, int, rem}, and bags of leaf nodes and the root are empty, then
the TD is called nice. For every TD, we can compute a nice TD in linear time without increasing the
width [6]. Later, we traverse a TD bottom up, therefore, let post-order(T, t) be the sequence of nodes in
post-order of the induced subtree T â€² = (N â€², Â·, t) of T rooted at t.
2.2 Answer Set programming (ASP)
ASP is a declarative modelling and problem solving framework that combines techniques of knowledge
representation and database theory. A main advantage of ASP is its expressiveness and when using
non-ground programs the advanced declarative problem modelling capability. Prior to solving, non-
ground programs are usually compiled into grounded by a grounder. In this paper, we restrict ourselves
to ground ASP programs. For a comprehensive introduction, see, e.g., [18]. Let `, m, n be non-negative
integers such that ` â‰¤ m â‰¤ n, a1, . . ., an distinct propositional atoms and l âˆˆ {a1,Â¬a1}. A choice
rule is an expression of the form {a1; . . . ; a`} â† a`+1, . . . , am,Â¬am+1, . . . ,Â¬an, intuitively some subset
of {a1, . . . , a`} is true if all atoms a`+1, . . . , am are true and there is no evidence that any atom of
am+1, . . . , an is true. A disjunctive rule is of the form a1 âˆ¨ Â· Â· Â· âˆ¨ a` â† a`+1, . . . , am,Â¬ am+1, . . ., Â¬an,
intuitively at least one atom of a1, . . . , a` must be true if all atoms a`+1, . . . , am are true and there is no
evidence that any atom of am+1, . . . , an is true. An optimization rule is an expression of the form  l.
with the intuitive meaning that when literal l is true, this incurs a penalty of weight w. A rule is either
a disjunctive, a choice, or an optimization rule. For a choice or disjunctive rule r, let Hr := {a1, . . . , a`},
B+r := {a`+1, . . . , am}, and Bâˆ’r := {am+1, . . . , an}. Usually, if Bâˆ’r âˆª B+r = âˆ… we write for a rule r
simply Hr instead of Hr â† . For an optimization rule r, if l = a1, let B+r := {a1} and Bâˆ’r := âˆ…; and
if l = Â¬a1, let Bâˆ’r := {a1} and B+r := âˆ…. For a rule r, let at(r) := Hr âˆª B+r âˆª Bâˆ’r denote its atoms
and Br := B
+
r âˆª {Â¬b | b âˆˆ Bâˆ’r } its body. Let a program P be a set of rules, and at(P ) :=
â‹ƒ
râˆˆP at(r)
denote its atoms. and let CH(P ), DISJ(P ), and OPT(P ) denote the set of all choice, disjunctive, and
optimization rules in P , respectively. A set M âŠ† at(P ) satisfies a rule r if (i) (Hr âˆª Bâˆ’r ) âˆ©M 6= âˆ…
or B+r 6âŠ†M for r âˆˆ DISJ(P ) or (ii) r is a choice or optimization rule. M is a model of P , denoted by
M  P , if M satisfies every rule r âˆˆ P .
The reduct rM (i) of a choice rule r is the set {aâ† B+r | a âˆˆ Hr âˆ©M,Bâˆ’r âˆ©M = âˆ…} of rules, and
(ii) of a disjunctive rule r is the singleton {Hr â† B+r | Bâˆ’r âˆ©M = âˆ…}. PM :=
â‹ƒ
râˆˆP r
M is called GL
reduct of P with respect to M . A set M âŠ† at(P ) is an answer set of P if (i) M  P and (ii) there is no
M â€² (M such that M â€²  PM , that is, M is subset minimal with respect to PM .
We call cst(P,M) := |{r | r âˆˆ P, r is an optimization rule, (B+r âˆ©M) âˆª (Bâˆ’r \M) 6= âˆ…}| the cost of
answer set M for P . An answer set M of P is optimal if its cost is minimal over all answer sets.
Example 1. Consider program
P = {
rabï¸· ï¸¸ï¸¸ ï¸·
{eab};
rbcï¸· ï¸¸ï¸¸ ï¸·
{ebc};
rcdï¸· ï¸¸ï¸¸ ï¸·
{ecd};
radï¸· ï¸¸ï¸¸ ï¸·
{ead};
rbï¸· ï¸¸ï¸¸ ï¸·
ab â† eab;
rdï¸· ï¸¸ï¸¸ ï¸·
ad â† ead;
rc1ï¸· ï¸¸ï¸¸ ï¸·
ac â† ab, ebc;
rc2ï¸· ï¸¸ï¸¸ ï¸·
ac â† ad, ecd;
rÂ¬cï¸· ï¸¸ï¸¸ ï¸·
â† Â¬ac}.
The set A = {eab, ebc, ab, ac} is an answer set of P , since {eab, ebc, ab, ac} is the only minimal model
of PA = {eab â†; ebc â†; ab â† eab; ad â† ead; ac â† ab, ebc; ac â† ad, ecd}. Then, consider program
R = {a âˆ¨ c â† b; b â† c,Â¬g; c â† a; b âˆ¨ c â† e; h âˆ¨ i â† g,Â¬c; a âˆ¨ b; g â† Â¬i; c; {d} â† g}. The
set B = {b, c, d, g} is an answer set of R since {b, c, d, g} and {a, c, d, g} are the minimal models of
3
Solve local
probl. A(t, . . . )
Store results
in A-Tabs[t] 1. Construct graph G
Store witnesses
in W-Tabs[t]
Compute wit-
nesses of W(t, . . . )
Visit next node
t in post-order Done?
no
yes
2. Comp. TD T of G 3.I done?
no
yes
Visit next node
t in post-order
Purge non-witnesses
Store counter-wit-
nesses in C-Tabs[t]
Compute counter-
wits. of C(t, . . . )
3.II done?
no
yes
Visit next node
t in post-order
Purge non-
counter-witnesses
Store result in
W,C-Tabs[t]
Link counter-wits.
to witnesses
4. Print solution 3.III done?
no
yes
Visit next node
t in post-order
3.I. DPW(T )
3.II. DPC(T )
3.III. DPLW,C(T ,W-Tabs,C-Tabs)
3. DPA(T )
â†âˆ’DynASP2 DynASP2.5âˆ’â†’
Figure 1 Control flow for DP-based ASP solver (DynASP2, left) and for DynASP2.5 (right).
RB = {a âˆ¨ câ† b; câ† a; b âˆ¨ câ† e; a âˆ¨ b; g; c; dâ† g}.
Given a program P , we consider the problems of computing an answer set (called AS), outputting
the number of optimal answer sets (called #AspO), and listing all optimal answer sets of P (called
EnumAsp). Further, given a propositional formula F and an atom sol, we use the entailment problem
of listing every subset-minimal model M of F with sol âˆˆM (called EnumMinSAT1).
2.3 Graph Representations of Programs
In order to use TDs for ASP solving, we need dedicated graph representations of programs. The incidence
graph I(P ) of P is the bipartite graph that has the atoms and rules of P as vertices and an edge a r if
a âˆˆ at(r) for some rule r âˆˆ P [11]. The semi-incidence graph S(P ) of P is a graph that has the atoms
and rules of P as vertices and (i) an edge a r if a âˆˆ at(r) for some rule r âˆˆ P as well as (ii) an edge a b
for disjoint atoms a, b âˆˆ Hr where r âˆˆ P is a choice rule. Since for every program P the incidence
graph I(P ) is a subgraph of the semi-incidence graph, we have that tw(I(P )) â‰¤ tw(S(P )). Further,
by definition of a TD and the construction of a semi-incidence graph that head atoms of choice rules,
respectively, occur in at least one common bag of the TD.
2.4 Sub-Programs
Let T = (T, Ï‡) be a nice TD of graph representation S(P ) of a program P . Further, let T = (N, Â·, n) and
t âˆˆ N . The bag-program is defined as Pt := P âˆ©Ï‡(t). Further, the set atâ‰¤t := {a | a âˆˆ at(P )âˆ©Ï‡(tâ€²), tâ€² âˆˆ
post-order(T, t)} is called atoms below t, the program below t is defined as Pâ‰¤t := {r | r âˆˆ Ptâ€² , tâ€² âˆˆ
post-order(T, t)}, and the program strictly below t is P<t := Pâ‰¤t \ Pt. It holds that Pâ‰¤n = P<n = P and
atâ‰¤n = at(P ).
3 A Single Pass DP Algorithm
A dynamic programming based ASP solver, such as DynASP2 [11], splits the input program P into
â€œbag-programsâ€ based on the structure of a given nice tree decomposition for P and evaluates P in parts,
thereby storing the results in tables for each TD node. More precisely, the algorithm works as outlined
on the left and middle of Figure 1 and encompasses the following steps:
1. Construct a graph representation G(P ) of the given input program P .
2. Compute a TD T of the graph G(P ) by means of some heuristic, thereby decomposing G(P ) into
several smaller parts and fixing an ordering in which P will be evaluated.
4
Algorithm 1: Algorithm DPA(T ) for Dynamic Programming on TD T for ASP [11].
In: Table algorithm A, nice TD T = (T, Ï‡) with T = (N, Â·, n) of G(P ) according to A.
Out: A-Tabs: maps each TD node t âˆˆ T to some computed table Ï„t.
1 Child-Tabst := {A-Tabs[tâ€²] | tâ€² is a child of t in T}
2 for iterate t in post-order(T,n) do
3 A-Tabs[t]â† A(t, Ï‡(t), Pt, atâ‰¤t,Child-Tabst)
3. Algorithm 1 â€“ DPA(T ) â€“ sketches the general scheme for this step, assuming that an algorithm A,
which highly depends on the graph representation, is given. We usually call A the table algorithm3.
For every node t âˆˆ T in the tree decomposition T = ((T,E, n), Ï‡) (in a bottom-up traversal),
run A and compute A-Tabs[t], which are sets of tuples (or rows for short). Intuitively, algorithm A
transforms tables of child nodes of t to the current node, and solves a â€œlocal problemâ€ using
bag-program Pt. The algorithm thereby computes (i) sets of atoms called (local) witness sets and
(ii) for each local witness set M subsets of M called counter-witness sets [11], and directly follows
the definition of answer sets being (i) models of P and (ii) subset minimal with respect to PM .
4. For root n interpret the table A-Tabs[n] (and tables of children, if necessary) and print the solution
to the considered ASP problem.
Next, we propose a new table algorithm (SINC) for programs without optimization rules. Since our
algorithm trivially extends to counting and optimization rules by earlier work [11], we omit such rules.
The table algorithm SINC employs the semi-incidence graph and is depicted in Algorithm 2. DPSINC
merges two earlier algorithms for the primal and incidence graph [11] resulting in slightly different worst
case runtime bounds (c.f., Theorem 1).
Our table algorithm SINC computes and stores (i) sets of atoms (witnesses) that are relevant for the
Sat part (finding a model of the program) and (ii) sets of atoms (counter-witnesses) that are relevant
for the Unsat part (checking for minimality). In addition, we need to store for each set of witnesses as
well as its set of counter-witnesses satisfiability states (sat-states for short). For the following reason:
By Definition of TDs and the semi-incidence graph, it is true for every atom a and every rule r of a
program that if atom a occurs in rule r, then a and r occur together in at least one bag of the TD.
In consequence, the table algorithm encounters every occurrence of an atom in any rule. In the end,
on removal of r, we have to ensure that r is among the rules that are already satisfied. However, we
need to keep track whether a witness satisfies a rule, because not all atoms that occur in a rule occur
together in exactly one bag. Hence, when our algorithm traverses the TD and an atom is forgotten we
still need to store this sat-state, as setting the forgotten atom to a certain truth value influences the
satisfiability of the rule. Since the semi-incidence graph contains a clique on every set A of atoms that
occur together in choice rule head, those atoms A occur together in a common bag of any TD of the
semi-incidence graph. For that reason, we do not need to incorporate choice rules into the satisfiability
state, in contrast to the algorithm for the incidence graph [11]. We can see witness sets together with
its sat-state as witness. Then, in Algorithm 2 (SINC) a row in the table Ï„t is a triple ã€ˆM,Ïƒ, Cã€‰. The
set M âŠ† at(P )âˆ©Ï‡(t) represents a witness set. The family C of sets concerns counter-witnesses, which we
will discuss in more detail below. The sat-state Ïƒ for M represents rules of Ï‡(t) satisfied by a superset
of M . Hence, M witnesses a model M â€² âŠ‡M where M â€²  P<t âˆª Ïƒ. We use binary operator âˆª to combine
sat-states, which ensures that rules satisfied in at least one operand remain satisfied. We compute a new
sat-state Ïƒ from a sat-state and satisfied rules, formally, SatPr(RÌ‡,M) := {r | (r,R) âˆˆ RÌ‡,M  R} for
M âŠ† Ï‡(t) \ Pt and program RÌ‡(r) constructed by RÌ‡, mapping rules to local-programs (Definition 1).
Definition 1. Let P be a program, T = (Â·, Ï‡) be a TD of S(P ), t be a node of T and R âŠ† Pt. The
local-program R(t) is obtained from R âˆª {â† Br | r âˆˆ R is a choice rule, Hr ( atâ‰¤t}4 by removing from
every rule all literals a,Â¬a with a 6âˆˆ Ï‡(t). We define RÌ‡(t) : Râ†’ 2R(t) by RÌ‡(t)(r) := {r}(t) for r âˆˆ R.
3The table algorithm SINC for example is given in Algorithm 2.
4We require to add {â† Br | r âˆˆ R is a choice rule, Hr ( atâ‰¤t} in order to decide satisfiability for corner cases of choice
rules involving counter-witnesses of Line 3 in Algorithm 2.
5For set S and element s, we denote S+s :=S âˆª {s} and Sâˆ’s :=S \ {s}.
5
Algorithm 2: Table algorithm SINC(t, Ï‡t, Pt, atâ‰¤t,Child-Tabst).
In: Bag Ï‡t, bag-program Pt, atoms-below atâ‰¤t, child tables Child-Tabst of t. Out: Tab. Ï„t.
1 if type(t) = leaf then Ï„t â† {ã€ˆâˆ…, âˆ…, âˆ…ã€‰} /* Abbreviations see Footnote 5. */
2 else if type(t) = int, a âˆˆ Ï‡t \ Pt is introduced and Ï„ â€² âˆˆ Child-Tabst then
3 Ï„t â† {ã€ˆM+a , Ïƒ âˆª SatPr(PÌ‡
(t)
t ,M
+
a ), {ã€ˆC+a , Ï âˆª SatPr(PÌ‡
(t,M+a )
t , C
+
a )ã€‰ | ã€ˆC, Ïã€‰ âˆˆ C} âˆª
4 {ã€ˆC, Ï âˆª SatPr(PÌ‡ (t,M
+
a )
t , C)ã€‰ | ã€ˆC, Ïã€‰ âˆˆ C} âˆª {ã€ˆM,Ïƒ âˆª SatPr(PÌ‡
(t,M+a )
t ,M)ã€‰}ã€‰ | ã€ˆM,Ïƒ, Cã€‰ âˆˆ Ï„ â€²}
5 âˆª {ã€ˆM,Ïƒ âˆª SatPr(PÌ‡ (t)t ,M), {ã€ˆC, Ï âˆª SatPr(PÌ‡
(t,M)
t , C)ã€‰ | ã€ˆC, Ïã€‰ âˆˆ C}ã€‰ | ã€ˆM,Ïƒ, Cã€‰ âˆˆ Ï„ â€²}
6 else if type(t) = int, r âˆˆ Ï‡t âˆ© Pt is introduced and Ï„ â€² âˆˆ Child-Tabst then
7 Ï„t â† {ã€ˆM,Ïƒ âˆª SatPr({rÌ‡}(t),M), {ã€ˆC, Ï âˆª SatPr({rÌ‡}(t,M), C)ã€‰ | ã€ˆC, Ïã€‰ âˆˆ C}ã€‰ | ã€ˆM,Ïƒ, Cã€‰ âˆˆ Ï„ â€²}
8 else if type(t) = rem, a 6âˆˆ Ï‡t is removed atom and Ï„ â€² âˆˆ Child-Tabst then
9 Ï„t â† {ã€ˆMâˆ’a , Ïƒ, {ã€ˆCâˆ’a , Ïã€‰ | ã€ˆC, Ïã€‰ âˆˆ C}ã€‰ | ã€ˆM,Ïƒ, Cã€‰ âˆˆ Ï„ â€²}
10 else if type(t) = rem, r 6âˆˆ Ï‡t is removed rule and Ï„ â€² âˆˆ Child-Tabst then
11 Ï„t â† {ã€ˆM,Ïƒâˆ’r ,
{
ã€ˆC, Ïâˆ’r ã€‰ | ã€ˆC, Ïã€‰ âˆˆ C, r âˆˆ Ï
}
ã€‰ | ã€ˆM,Ïƒ, Cã€‰ âˆˆ Ï„ â€², r âˆˆ Ïƒ}
12 else if type(t) = join and Ï„ â€², Ï„ â€²â€² âˆˆ Child-Tabst with Ï„ â€² 6= Ï„ â€²â€² then
13 Ï„t â† {ã€ˆM,Ïƒâ€² âˆª Ïƒâ€²â€², {ã€ˆC, Ïâ€² âˆª Ïâ€²â€²ã€‰ | ã€ˆC, Ïâ€²ã€‰ âˆˆ Câ€², ã€ˆC, Ïâ€²â€²ã€‰ âˆˆ Câ€²â€²} âˆª {ã€ˆM,Ï âˆª Ïƒâ€²â€²ã€‰ | ã€ˆM,Ïã€‰ âˆˆ Câ€²} âˆª
14 {ã€ˆM,Ïƒâ€² âˆª Ïã€‰ | ã€ˆM,Ïã€‰ âˆˆ Câ€²â€²}ã€‰ | ã€ˆM,Ïƒâ€², Câ€²ã€‰ âˆˆ Ï„ â€², ã€ˆM,Ïƒâ€²â€², Câ€²â€²ã€‰ âˆˆ Ï„ â€²â€²}
Example 2. Observe P
(t4)
t4 = {â† ebc, rb} and P
(t5)
t5 = {câ†} for Pt4 and Pt5 of Figure 2.
In Example 3 we give an idea how we compute models of a given program using the semi-incidence
graph. The resulting algorithm MOD is obtained from SINC, by taking only the first two row positions
(red and green parts). The remaining position (blue part), can be seen as an algorithm (CMOD) that
computes counter-witnesses (see Example 5). Note that we discuss selected cases, and we assume row
numbers in each table Ï„t, i.e., the i
th-row corresponds to ut.i = ã€ˆMt.i, Ïƒt.iã€‰.
Example 3. Consider program P from Example 1, TD T = (Â·, Ï‡) in Figure 2, and the tables Ï„1,. . .,
Ï„34, which illustrate computation results obtained during post-order traversal of T by DPMOD. Note that
Figure 2 (left) does not show every intermediate node of TD T . Table Ï„1 = {ã€ˆâˆ…, âˆ…ã€‰} as type(t1) =
leaf (see Algorithm 2 L1). Table Ï„3 is obtained via introducing rule rab, after introducing atom eab
(type(t2) = type(t3) = int). It contains two rows due to two possible truth assignments using atom eab
(L3â€“5). Observe that rule rab is satisfied in both rows M3.1 and M3.2, since the head of choice rule rab is
in atâ‰¤t3 (see L7 and Definition 1). Intuitively, whenever a rule r is proven to be satisfiable, sat-state Ïƒt.i
marks r satisfiable since an atom of a rule of S(P ) might only occur in one TD bag. Consider table Ï„4
with type(t4) = rem and rab âˆˆ Ï‡(t3) \ Ï‡(t4). By definition (TDs and semi-incidence graph), we have
encountered every occurrence of any atom in rab. In consequence, MOD enforces that only rows where
rab is marked satisfiable in Ï„3, are considered for table Ï„4. The resulting table Ï„4 consists of rows of Ï„3
with Ïƒ4.i = âˆ…, where rule rab is proven satisfied (rab âˆˆ Ïƒ3.1, Ïƒ3.2, see L 11). Note that between nodes t6
and t10, an atom and rule remove as well as an atom and rule introduce node is placed. Observe that the
second row u6.2 = ã€ˆM6.2, Ïƒ6.2ã€‰ âˆˆ Ï„6 does not have a â€œsuccessor rowâ€ in Ï„10, since rb 6âˆˆ Ïƒ6.2. Intuitively,
join node t34 joins only common witness sets in Ï„17 and Ï„33 with Ï‡(t17) = Ï‡(t33) = Ï‡(t34). In general, a
join node marks rules satisfied, which are marked satisfied in at least one child (see L13â€“14).
Since we already explained how to obtain models, we only briefly describe how to compute counter-
witnesses. Family C consists of rows (C, Ï) where C âŠ† at(P ) âˆ© Ï‡(t) is a counter-witness set in t to M .
Similar to the sat-state Ïƒ, the sat-state Ï for C under M represents whether rules of the GL reduct PMt
are satisfied by a superset of C. We can see counter-witness sets together with its sat-state as counter-
witnesses. Thus, C witnesses the existence of C â€² (M â€² satisfying C â€²  (P<t âˆª Ï)M
â€²
since M witnesses
a model M â€² âŠ‡ M where M â€²  P<t. In consequence, there exists an answer set of P if the root table
contains ã€ˆâˆ…, âˆ…, âˆ…ã€‰. We require local-reducts for deciding satisfiability of counter-witness sets.
Definition 2. Let P be a program, T = (Â·, Ï‡) be a TD of S(P ), t be a node of T , R âŠ† Pt and M âŠ† at(P ).
We define local-reduct R(t,M) by [R(t)]
M
and RÌ‡(t,M) : Râ†’ 2R(t,M) by RÌ‡(t,M)(r) :={r}(t,M), r âˆˆ R.
Proposition 1 (c.f. [11]). Let P be a program and k :=tw(S(P )). Then, the algorithm DPSINC is correct
and runs in time O(22k+2 Â· â€–S(P )â€–).
6
âˆ… t1
eab t2
rab, eab t3
eab t4
rb, eab t5
rb, eab, ab
t6
rbc, ebc, ab
t10
rc1, ebc, ab
t12
rc1, act15
âˆ… t18
rad, ead t20
rd, ead, ad t23
rcd, ecd, ad t27
rc2, ecd, ad t29
rc2, ac t32
rÂ¬c, ac
t34
âˆ… t36T:
ã€ˆM3.i, Ïƒ3.iã€‰ Ï„3
ã€ˆ{eab}, {rab}ã€‰
ã€ˆâˆ…, {rab}ã€‰
ã€ˆM32.i, Ïƒ32.iã€‰
ã€ˆ{ac}, {rc2}ã€‰
ã€ˆâˆ…, {rc2}ã€‰
ã€ˆâˆ…, âˆ…ã€‰
Ï„32
ã€ˆM6.i, Ïƒ6.iã€‰ Ï„6
ã€ˆ{eab, ab}, {rb}ã€‰
ã€ˆ{eab}, âˆ…ã€‰
ã€ˆ{ab}, {rb}ã€‰
ã€ˆâˆ…, {rb}ã€‰
ã€ˆM12.i, Ïƒ12.iã€‰
ã€ˆ{ebc, ab}, âˆ…ã€‰
ã€ˆ{ebc}, {rc1}ã€‰
ã€ˆ{ab}, {rc1}ã€‰
ã€ˆâˆ…, {rc1}ã€‰
Ï„12
ã€ˆM1.i, Ïƒ1.iã€‰ Ï„1
ã€ˆâˆ…, âˆ…ã€‰
ã€ˆM3.i, Ïƒ3.i, C3.iã€‰ Ï„3
ã€ˆ{eab}, {rab}, {ã€ˆâˆ…, âˆ…ã€‰}ã€‰
ã€ˆâˆ…, {rab}, âˆ…ã€‰
ã€ˆM1.i, Ïƒ1.i, C1.iã€‰ Ï„1
ã€ˆâˆ…, âˆ…, âˆ…ã€‰
ã€ˆM6.i, Ïƒ6.i, C6.iã€‰ Ï„6
ã€ˆ{eab, ab}, {rb}, {
ã€ˆ{eab}, âˆ…ã€‰}ã€‰
ã€ˆ{eab}, âˆ…, âˆ…ã€‰
ã€ˆ{ab}, {rb}, {ã€ˆâˆ…, {rb}ã€‰}ã€‰
ã€ˆâˆ…, {rb}, âˆ…ã€‰
ã€ˆM12.i, Ïƒ12.i, C12.iã€‰ Ï„12
ã€ˆ{ebc, ab}, âˆ…, {ã€ˆ{ebc}, {rc1}ã€‰}ã€‰
ã€ˆ{ebc, ab}, âˆ…, âˆ…ã€‰
ã€ˆ{ebc}, {rc1}, âˆ…ã€‰
ã€ˆ{ab}, {rc1}, {ã€ˆâˆ…, {rc1}ã€‰}ã€‰
ã€ˆ{ab}, {rc1}, âˆ…ã€‰
ã€ˆâˆ…, {rc1}, âˆ…ã€‰
ã€ˆM32.i, Ïƒ32.i, C32.iã€‰
ã€ˆ{ac}, {rc2}, {
ã€ˆ{ac}, {rc2}ã€‰,
ã€ˆâˆ…, {rc2}ã€‰}ã€‰
ã€ˆ{ac}, {rc2}, {
ã€ˆâˆ…, {rc2}ã€‰}ã€‰
ã€ˆâˆ…, {rc2}, {
ã€ˆâˆ…, {rc2}ã€‰}ã€‰
ã€ˆâˆ…, {rc2}, âˆ…ã€‰
ã€ˆâˆ…, âˆ…, {ã€ˆâˆ…, {rc2}ã€‰}ã€‰
ã€ˆâˆ…, âˆ…, âˆ…ã€‰
Ï„32
Figure 2 A TD T of the semi-incidence graph S(P ) for program P from Example 1 (center). Selected
DP tables after DPMOD (left) and after DPSINC (right) for nice TD T .
4 DynASP2.5: Implementing a III Pass DP Algorithm
The classical DP algorithm DPSINC (Step 3 of Figure 1) follows a single pass approach. It computes
both witnesses and counter-witnesses by traversing the given TD exactly once. In particular, it stores
exhaustively all potential counter-witnesses, even those counter-witnesses where the witnesses in the
table of a node cannot be extended in the parent node. In addition, there can be a high number of
duplicates among the counter-witnesses, which are stored repeatedly. In this section, we propose a
multi-pass approach (M-DPSINC) for DP on TDs and a new implementation (DynASP2.5), which fruitfully
adapts and extends ideas from a different domain [5]. Our novel algorithm allows for an early cleanup
(purging) of witnesses that do not lead to answer sets, which in consequence (i) avoids to construct
expendable counter-witnesses. Moreover, multiple passes enable us to store witnesses and counter-
witnesses separately, which in turn (ii) avoids storing counter-witnesses duplicately and (iii) allows for
highly space efficient data structures (pointers) in practice when linking witnesses and counter-witnesses
together. Figure 1 (right, middle) presents the control flow of the new multi-pass approach DynASP2.5,
where M-DPSINC introduces a much more elaborate computation in Step 3.
4.1 The Algorithm
Our algorithm (M-DPSINC) executed as Step 3 runs DPMOD, DPCMOD and DPLMOD,CMOD in three passes (3.I,
3.II, and 3.III) as follows:
3.I. First, we run the algorithm DPMOD, which computes in a bottom-up traversal for every node t
in the tree decomposition a table MOD-Tabs[t] of witnesses for t. Then, in a top-down traversal
for every node t in the TD remove from tables MOD-Tabs[t] witnesses, which do not extend to a
witness in the table for the parent node (â€œPurge non-witnessesâ€); these witnesses can never be
used to construct a model (nor answer set) of the program.
3.II. For this step, let CMOD be a table algorithm computing only counter-witnesses of SINC (blue
parts of Algorithm 2). We execute DPCMOD, compute for all witnesses counter-witnesses at once
and store the resulting tables in CMOD-Tabs[Â·]. For every node t, table CMOD-Tabs[t] contains
counter-witnesses to witness being âŠ‚-minimal. Again, irrelevant rows are removed (â€œPurge
non-counter-witnessesâ€).
7
Algorithm 3: Algorithm DPLW,C(T ,W-Tabs,C-Tabs) for linking counter-witnesses to witnesses.
In: Nice TD T = (T, Ï‡) with T = (N, Â·, n) of a graph S(P ), and mappings W-Tabs[Â·], C-Tabs[Â·].
Out: W,C-Tabs: maps node t âˆˆ T to some pair (Ï„Wt , Ï„Ct ) with Ï„Wt âˆˆW-Tabs[t], Ï„Ct âˆˆ C-Tabs[t].
1 Child-Tabst :={W,C-Tabs[tâ€²] | tâ€² is a child of t in T}
/* Get for a node t tables of (preceeding) combined child rows (CCR) */
2 CCRt :=Î Ì‚Ï„ â€²âˆˆChild-TabstÏ„
â€² /* For Abbreviations see Footnote 6. */
/* Get for a row ~u its combined child rows (origins) */
3 origt(~u) :={S | S âˆˆ CCRt, ~u âˆˆ Ï„, Ï„ = W(t, Ï‡(t), Pt, atâ‰¤t, fw(S))}
/* Get for a table S of combined child rows its successors (evolution) */
4 evolt(S) :={~u | ~u âˆˆ Ï„, Ï„ = C(t, Ï‡(t), Pt, atâ‰¤t, Ï„ â€²), Ï„ â€² âˆˆ S}
5 for iterate t in post-order(T,n) do
6 /* Compute counter-witnesses (â‰º-smaller rows) for a witness set M */
7 subsâ‰º(f,M, S) :={~u | ~u âˆˆ C-Tabs[t], ~u âˆˆ evolt(f(S)), ~u = ã€ˆC, Â· Â· Â· ã€‰, C â‰ºM}
8 /* Link each witness ~u to its counter-witnesses and store the results */
9 W,C-Tabs[t]â† {(~u, subs((fw,M, S) âˆª subsâŠ†(fcw,M, S)) | ~uâˆˆW-Tabs[t], ~u= ã€ˆM, Â· Â· Â· ã€‰, S âˆˆ origt(u)}
ã€ˆM3.i, Ïƒ3.i, C3.iã€‰ Ï„3
ã€ˆ{a1, a2, f}, âˆ…, âˆ…ã€‰
ã€ˆ{a2, f}, âˆ…, âˆ…ã€‰
ã€ˆM2.i, Ïƒ2.i, C2.iã€‰ Ï„2
ã€ˆ{a1, a2, f}, {rf , r2}, âˆ…ã€‰
ã€ˆ{a1, a2}, {r2}, {
ã€ˆ{a1}, âˆ…ã€‰,
ã€ˆ{a2}, {r2}ã€‰, ã€ˆâˆ…, âˆ…ã€‰}ã€‰
ã€ˆ{a1, f}, {rf}, âˆ…ã€‰
ã€ˆ{a1}, âˆ…, {ã€ˆâˆ…, âˆ…ã€‰}ã€‰
ã€ˆ{a2, f}, {rf , r2}, âˆ…ã€‰
ã€ˆ{a2}, {r2}, {ã€ˆâˆ…, âˆ…ã€‰}ã€‰
ã€ˆ{f}, {rf}, âˆ…ã€‰
ã€ˆâˆ…, âˆ…, âˆ…ã€‰
ã€ˆM1.i, Ïƒ1.i, C1.iã€‰ Ï„1
ã€ˆ{a1, a2, f}, {rc, rcf}, {
ã€ˆ{a1, f}, {rcf}ã€‰, ã€ˆ{a2, f}, {rcf}ã€‰,
ã€ˆ{f}, {rcf}ã€‰, ã€ˆ{a1, a2}, {rc}ã€‰,
ã€ˆ{a1}, {rc}ã€‰, ã€ˆ{a2}, {rc}ã€‰, ã€ˆâˆ…, {rc}ã€‰}ã€‰
ã€ˆ{a1, a2}, {rc, rcf}, {ã€ˆ{a1}, {rc, rcf}ã€‰,
ã€ˆ{a2}, {rc, rcf}ã€‰, ã€ˆâˆ…, {rc, rcf}ã€‰}ã€‰
ã€ˆ{a1, f}, {rc, rcf}, {ã€ˆ{f}, {rcf}ã€‰,
ã€ˆ{a1}, {rc}ã€‰, ã€ˆâˆ…, {rc}ã€‰}ã€‰
ã€ˆ{a1}, {rc, rcf}, {ã€ˆâˆ…, {rc, rf}ã€‰}ã€‰
ã€ˆ{a2, f}, {rc, rcf}, {ã€ˆ{a2}, {rc}ã€‰,
ã€ˆ{f}, {rcf}ã€‰}ã€‰
ã€ˆ{a2}, {rc, rcf}, {ã€ˆâˆ…, {rc, rcf}ã€‰}ã€‰
ã€ˆ{f}, {rc, rcf}, {ã€ˆâˆ…, {rc}ã€‰}ã€‰
ã€ˆâˆ…, {rc, rcf}, âˆ…ã€‰
ã€ˆC1.i, Ï1.iã€‰ Ï„CMOD1
ã€ˆ{a1, f}, {rcf}ã€‰, ã€ˆ{a2, f}, {rcf}ã€‰,
ã€ˆ{f}, {rcf}ã€‰, ã€ˆ{a1, a2}, {rc}ã€‰, ã€ˆ{
a1}, {rc}ã€‰, ã€ˆ{a2}, {rc}ã€‰, ã€ˆâˆ…, {rc}ã€‰
ã€ˆM1.i, Ïƒ1.i, C1.iã€‰ Ï„1
ã€ˆ{a1, a2, f}, {rc, rcf}, âˆ…
ã€ˆ{a2, f}, {rc, rcf}, âˆ…ã€‰
ã€ˆM2.i, Ïƒ2.i, C2.iã€‰ Ï„2
ã€ˆ{a1, a2, f}, {rf , r2}, âˆ…ã€‰
ã€ˆ{a2, f}, {rf , r2}, âˆ…ã€‰
ã€ˆM3.i, Ïƒ3.i, C3.iã€‰ Ï„3
ã€ˆ{a1, a2, f}, âˆ…, âˆ…ã€‰
ã€ˆ{a2, f}, âˆ…, âˆ…ã€‰
Figure 3 Selected DP tables after DPSINC (left) and after M-DPSINC (right) for TD T .
3.III. Finally, in a bottom-up traversal for every node t in the TD, witnesses and counter-witnesses are
linked using algorithm DPLMOD,CMOD (see Algorithm 3). DPLMOD,CMOD takes previous results and
maps rows in MOD-Tabs[t] to a table (set) of rows in CMOD-Tabs[t].
We already explained the table algorithms DPMOD and DPCMOD in the previous section. The main
part of our multi-pass algorithm is the algorithm DPLMOD,CMOD based on the general algorithm DPLW,C
(Algorithm 3) with W = MOD, C = CMOD, which links those separate tables together. Before we
quickly discuss the core of DPLW,C in Lines 5â€“9, note that Lines 2â€“4 introduce auxiliary definitions. Line 2
combines rows of the child nodes of given node t, which is achieved by a product over sets6, where we
drop the order and keep sets only. Line 3 concerns determining for a row ~u its origins (finding preceding
combined rows that lead to ~u using table algorithm W). Line 4 covers deriving succeeding rows for a
certain child row combination its evolution rows via algorithm C. In an implementation, origin as well
as evolution are not computed, but represented via pointer data structures directly linking to W-Tabs[Â·]
or C-Tabs[Â·], respectively. Then, the table algorithm DPLW,C applies a post-order traversal and links
witnesses to counter-witnesses in Line 9. DPLW,C searches for origins (orig) of a certain witness ~u, uses
the counter-witnesses (fcw) linked to these origins, and then determines the evolution (evol) in order to
derive counter-witnesses (using subs) of ~u.
6For set I = {1, . . . , n} and sets Si, we define
âˆ
iâˆˆI Si :=S1 Ã— Â· Â· Â· Ã— Sn = {(s1, . . . , sn) : si âˆˆ Si}. Moreover, for
âˆ
iâˆˆI Si,
let
âˆÌ‚
iâˆˆISi :={{{s1}, . . . , {sn}} | (s1, . . . , sn) âˆˆ
âˆ
iâˆˆI Si}. If for each S âˆˆ
âˆÌ‚
iâˆˆISi and {si} âˆˆ S, si is a pair with a witness
and a counter-witness part, let fw(S) :=
â‹ƒ
{(Wi,Ci)}âˆˆS{{Wi}} and fcw(S) :=
â‹ƒ
{(Wi,Ci)}âˆˆS{{Ci}} restrict S to the resp.
(counter-)witness parts.
8
Theorem 1. For a program P of semi-incidence treewidth k := tw(S(P )), the algorithm M-DPSINC is
correct and runs in time O(22k+2 Â· â€–Pâ€–).
Proof (Sketch). Due to space constraints, we only sketch the proof idea for enumerating answer sets of
disjunctive ASP programs by means of M-DPSINC. Let P be a disjunctive program and k :=tw(S(P )).
We establish a reduction R(P, k) of EnumAsp to EnumMinSAT1, such that there is a one-to-one
correspondence between answer sets and models of the formula, more precisely, for every answer set M
of P and for the resulting instance (F, kâ€²) = R(P, k) the set M âˆª {sol} is a subset-minimal model of F
and kâ€² = tw(I(F )) with kâ€² â‰¤ 7k + 2. We compute in time 2O(kâ€²3) Â· â€–Fâ€– a TD of width at most kâ€² [6]
and add sol to every bag. Using a table algorithm designed for SAT [22] we compute witnesses and
counter-witnesses. Conceptually, one could also modify MOD for this task. To finally show correctness
of linking counter-witnesses to witnesses as presented in DPLMOD,MOD, we have to extend earlier work [5,
Theorem 3.25 and 3.26]. Therefore, we enumerate subset-minimal models of F by following each
witness set containing sol at the root having counter-witnesses âˆ… back to the leaves. This runs in
time O(22(7k+2)+2 Â· â€–Pâ€–), c.f., [5, 11]. A more involved (direct) proof, allows to decrease the runtime
to O(22k+2 Â· â€–Pâ€–) (even for choice rules).
Example 4. Let k be some integer and Pk be some program that contains the following rules rc :={a1, Â· Â· Â· , ak} â†
f , r2 := â† Â¬a2, . . ., rk := â† Â¬ak, and rf := â† Â¬f and rcf :={f} â† . The rules r1, . . ., rk simulate
that only certain subsets of {a1, Â· Â· Â· , ak} are allowed. Rules rf and rcf enforce that f is set to true. Let
T = (T, Ï‡, t3) be a TD of the semi-incidence graph S(Pk) of program Pk where T = (V,E) with V =
{t1, t2, t3}, E = {(t1, t2), (t2, t3)}, Ï‡(t1) = {a1, Â· Â· Â· , ak, f, rc, rcf}, Ï‡(t2) = {a1, Â· Â· Â· , ak, r2, Â· Â· Â· , rk, rf},
and Ï‡(t3) = âˆ…. Figure 3 (left) illustrates the tables for program P2 after DPSINC, whereas Figure 3 (right)
presents tables using M-DPSINC, which are exponentially smaller in k, mainly due to cleanup. Observe that
Pass 3.II M-DPSINC, â€œtemporarilyâ€ materializes counter-witnesses only for Ï„1, presented in table Ï„
CMOD
1 .
Hence, using multi-pass algorithm M-DPSINC results in an exponential speedup. Note that we can trivially
extend the program such that we have the same effect for a TD of minimum width and even if we take
the incidence graph. In practice, programs containing the rules above frequently occur when encoding
by means of saturation [9]. The program Pk and the TD T also reveal that a different TD of the same
width, where f occurs already very early in the bottom-up traversal, would result in a smaller table Ï„1
even when running DPSINC.
4.2 Implementation Details
Efficient implementations of dynamic programming algorithms on TDs are not a by-product of computa-
tional complexity theory and involve tuning and sophisticated algorithm engineering. Therefore, we
present additional implementation details of algorithm M-DPSINC into our prototypical multi-pass solver
DynASP2.5, including two variations (depgraph, joinsize TDs).
Even though normalizing a TD can be achieved without increasing its width, a normalization may
artificially introduce additional atoms. Resulting in several additional intermediate join nodes among
such artificially introduced atoms requiring a significant amount of total unnecessary computation in
practice. On that account, we use non-normalized tree decompositions. In order to still obtain a fixed-
parameter linear algorithm, we limit the number of children per node to a constant. Moreover, linking
counter-witnesses to witnesses efficiently is crucial. The main challenge is to deal with situations where
a row (witness) might be linked to different set of counter-witnesses depending on different predecessors
of the row (hidden in set notation of the last line in Algorithm 3). In these cases, DynASP2.5 eagerly
creates a â€œcloneâ€ in form of a very light-weighted proxy to the original row and ensures that only the
original row (if at all required) serves as counter-witness during pass three. Together with efficient caches
of counter-witnesses, DynASP2.5 reduces overhead due to clones in practice.
Dedicated data structures are vital. Sets of Witnesses and satisfied rules are represented in the
DynASP2.5 system via constant-size bit vectors. 32-bit integers are used to represent by value 1 whether
an atom is set to true or a rule is satisfied in the respective bit positions according to the bag. A
restriction to 32-bit integers seems reasonable as we assume for now (practical memory limitations)
9
1250
0 20 40 60
# instances
[s
]
C
P
U
 
C
P
U
 ti
m
e St (best TD)
250
500
750
1000
Clasp 3.3.0
DynASP2.5 
DynASP2.5 depgraph
DynASP2.5 joinsize
250
500
750
1000
1250
0 20 40 60
[s
]
Clasp 3.3.0
DynASP2.5 
DynASP2.5 depgraph
DynASP2.5 joinsize# instances
C
P
U
 
C
P
U
 ti
m
e St (avg TD)
solver\time
# Avg solved runtime
TO TD 3.I 3.II 3.III Î£
Clasp 3.3.0 34 - - - - 334.5
DynASP2 68 - - - - -
DynASP2.5 28 0.5 3.5 16.6 264.4 285.0
...depgraph 24 10.9 3.4 15.3 251.3 280.9
...joinsize 32 0.7 3.5 16.5 278.3 299.0
Figure 4 Cactus plots showing best and average runtime among five TDs (left). Number of Timeouts
(TO) and average runtime among solved instances (right).
that our approach works well on TDs of width â‰¤ 20. Since state-of-the-art computers handle such
constant-sized integers extremely efficient, DynASP2.5 allows for efficient projections and joins of rows,
and subset checks in general. In order to not recompute counter-witnesses (in Pass 3.II) for different
witnesses, we use a three-valued notation of counter-witness sets consisting of atoms set to true (T) or
false (F) or false but true in the witness set (TW) used to build the reduct. Note that the algorithm
enforces that only (TW)-atoms are relevant, i.e., an atom has to occur in a default negation or choice
rule.
Minimum width is not the only optimization goal when computing TDs by means of heuristics.
Instead, using TDs where a certain feature value has been maximized in addition (customized TDs)
works seemingly well in practice [1, 21]. While DynASP2.5 (M-DPSINC) does not take additional TD
features into account, we also implemented a variant (DynASP2.5 depgraph), which prefers one out of
ten TDs that intuitively speaking avoids to introduce head atoms of some rule r in node t, without
having encountered every body atom of r below t, similar to atom dependencies in the program [15].
The variant DynASP2.5 joinsize minimizes bag sizes of child nodes of join nodes, c.f. [2].
4.3 Experimental Evaluation
We performed experiments to investigate the runtime behavior of DynASP2.5 and its variants, in order
to evaluate whether our multi-pass approach can be beneficial and has practical advantages over the
classical single pass approach (DynASP2). Further, we considered the dedicated ASP solver Clasp 3.3.07.
Clearly, we cannot hope to solve programs with graph representations of high treewidth. However,
programs involving real-world graphs such as graph problems on transit graphs admit TDs of acceptable
width to perform DP on TDs. To get a first intuition, we focused on the Steiner tree problem (St) for
our benchmarks. Note that we support the most frequently used SModels input format [24] for our
implementation.
We mainly inspected the CPU time using the average over five runs per instance (five fixed
seeds allow certain variance for heuristic TD computation). For each run, we limited the environ-
ment to 16 GB RAM and 1200 seconds CPU time. We used Clasp with options â€œ--stats=2 --opt-
strategy=usc,pmres,disjoint,stratify --opt-usc-shrink=min -qâ€, which enable very recent improvements
for unsatisfiable cores [3], and disabled solution printing/recording. We also benchmarked Clasp with
branch-and-bound, which was, however, outperformed by the unsat. core options on all our instances.
Note that without the very recent unsatisfiable core advances Clasp timed out on almost every instance.
We refer to an extended version [12] for more details on the benchmark instances, encodings, and
benchmark environment. The left plot in Figure 4 shows the result of always selecting the best among
five TDs, whereas the right plot concerns average runtime. The table in Figure 4 reports on average
running times (TD computation and Passes 3.I, 3.II, 3.III) among the solved instances and the total
number of timeouts (TO). We consider an instance to time out, when all five TDs exceeded the limit. For
the variants depgraph and joinsize, runtimes for computing and selecting among ten TDs are included.
Our empirical benchmark results confirm that DynASP2.5 exhibits competitive runtime behavior even
for TDs of treewidth around 14. Compared to state-of-the-art ASP solver Clasp, DynASP2.5 is capable
7Clasp is available at https://github.com/potassco/clasp/releases/tag/v3.3.0.
10
of additionally delivering the number of optimal solutions. In particular, variant â€œdepgraphâ€ shows
promising runtimes.
5 Conclusion
In this paper, we presented a novel approach for ASP solving based on ideas from parameterized
complexity. Our algorithms runs in linear time assuming bounded treewidth of the input program. Our
solver applies DP in three passes, thereby avoiding redundancies. Experimental results indicate that our
ASP solver is competitive for certain classes of instances with small treewidth, where the latest version
of the well-known solver Clasp hardly keeps up. An interesting question for future research is whether a
linear amount of passes (incremental DP) can improve the runtime behavior.
References
[1] M. Abseher, F. Dusberger, N. Musliu, and S. Woltran. Improving the efficiency of dynamic
programming on tree decompositions via machine learning. JAIR, 58:829â€“858, 2017.
[2] M. Abseher, N. Musliu, and S. Woltran. htd â€“ a free, open-source framework for (customized) tree
decompositions and beyond. In CPAIORâ€™17, 2017. To appear.
[3] M. Alviano and C. Dodaro. Anytime answer set optimization via unsatisfiable core shrinking.
TPLP, 16(5-6):533â€”551, 2016.
[4] M. Alviano, C. Dodaro, W. Faber, N. Leone, and F. Ricca. WASP: A native ASP solver based on
constraint learning. In LPNMRâ€™13, volume 8148 of LNCS, pages 54â€“66. Springer, 2013.
[5] B. Bliem, G. Charwat, M. Hecher, and S. Woltran. D-FLATË†2: Subset minimization in dynamic
programming on tree decompositions made easy. Fund. Inform., 147:27â€“34, 2016.
[6] H. Bodlaender and A. M. C. A. Koster. Combinatorial optimization on graphs of bounded treewidth.
The Computer J., 51(3):255â€“269, 2008.
[7] H. Dell. The 2st parameterized algorithms and computational experiments challenge â€“ Track A:
Treewidth. Technical report, 2017.
[8] A. Durand, M. Hermann, and P. G. Kolaitis. Subtractive reductions and complete problems for
counting complexity classes. Th. Comput. Sc., 340(3), 2005.
[9] T. Eiter and G. Gottlob. On the computational cost of disjunctive logic programming: Propositional
case. Ann. Math. Artif. Intell., 15(3â€“4):289â€“323, 1995.
[10] J. K. Fichte, M. Hecher, M. Morak, and S. Woltran. Answer Set Solving using Tree Decompositions
and Dynamic Programming - The DynASP2 System -. Technical Report DBAI-TR-2016-101, TU
Wien, 2016.
[11] J. K. Fichte, M. Hecher, M. Morak, and S. Woltran. Answer set solving with bounded treewidth
revisited. In LPNMRâ€™17, 2017. To appear.
[12] J. K. Fichte, M. Hecher, and S. Woltran. DynASP2.5: Dynamic Programming on Tree Decomposi-
tions in Action. CoRR, abs/cs/arXiv:1702.02890, 2017.
[13] M. Gebser, J. Bomanson, and T. Janhunen. Rewriting optimization statements in answer-set
programs. Technical Communications of ICLP 2016, 2016.
[14] M. Gebser, M. Maratea, and F. Ricca. Whatâ€™s hot in the answer set programming competition. In
AAAIâ€™16, pages 4327â€“4329. The AAAI Press, 2016.
11
[15] Georg Gottlob, Francesco Scarcello, and Martha Sideri. Fixed-parameter complexity in AI and
nonmonotonic reasoning. AIJ, 138(1-2):55â€“86, 2002.
[16] M. Hermann and R. Pichler. Complexity of counting the optimal solutions. Th. Comput. Sc.,
410(38â€“40), 2009. URL: http://dx.doi.org/10.1016/j.tcs.2009.05.025.
[17] M. Jakl, R. Pichler, and S. Woltran. Answer-set programming with bounded treewidth. In IJCAIâ€™09,
2009.
[18] T. Janhunen and I. NiemelaÌˆ. The answer set programming paradigm. 2016.
[19] B. Kaufmann, M. Gebser, R. Kaminski, and T. Schaub. clasp â€“ a conflict-driven nogood learning
answer set solver, 2015.
[20] C. Koch and N. Leone. Stable model checking made easy. In IJCAIâ€™99, 1999.
[21] M. Morak, N. Musliu, R. Pichler, S. RuÌˆmmele, and S. Woltran. Evaluating tree-decomposition
based algorithms for answer set programming. In LIONâ€™12, LNCS, pages 130â€“144. Springer, 2012.
[22] M. Samer and S. Szeider. Algorithms for propositional model counting. J. Desc. Alg., 8(1), 2010.
[23] P. Simons, I. NiemelaÌˆ, and T. Soininen. Extending and implementing the stable model semantics.
AIJ, 138(1-2):181â€“234, 2002.
[24] T. SyrjaÌˆnen. Lparse 1.0 userâ€™s manual. tcs.hut.fi/Software/smodels/lparse.ps, 2002.
12
A Additional Example
We assume again row numbers per table Ï„t, i.e., ut.i = ã€ˆMt.i, Ïƒt.i, Ct.iã€‰ is the ith-row. Further, for each
counter-witness ã€ˆCt.i.j , Ït.i.jã€‰ âˆˆ Ct.i, j marks its â€œorderâ€ (as depicted in Figure 2 (right)) in set Ct.i.
Example 5. Again, we consider P of Example 1 and T = (Â·, Ï‡) of Figure 2 as well as tables Ï„1, . . ., Ï„34
of Figure 2 (right) using DPSINC. We only discuss certain tables. Table Ï„1 = {ã€ˆâˆ…, âˆ…, âˆ…ã€‰} as type(t1) = leaf.
Node t2 introduces atom eab, resulting in table {ã€ˆ{eab}, âˆ…, {(âˆ…, âˆ…)}ã€‰, ã€ˆâˆ…, âˆ…, âˆ…ã€‰} (compare to Algorithm 2
L3â€“5). Then, node t3 introduces rule rab, which is removed in node t4. Note that C3.1.1 = ã€ˆâˆ…, âˆ…ã€‰ âˆˆ C3.1.1
does not have a â€œsuccessor rowâ€ in table Ï„4 since rab is not satisfied (see L11 and Definition 2). Table Ï„6
is then the result of a chain of introduce nodes, and contains for each witness set M6.i every possible
counter-witness set C6.i.j with C6.i.j ( M6.i. We now discuss table Ï„12, intuitively containing (a
projection of) (counter-)witnesses of Ï„10, which satisfy rule rbc after introducing rule rc1. Observe that
there is no succeeding witness set for M6.2 = {eab} in Ï„10 (nor Ï„12), since eab âˆˆ M6.2, but ab 6âˆˆ M6.2
(required to satisfy rb). Rows u12.1, u12.4 form successors of u6.3, while rows u12.2, u12.5 succeed u6.1,
since counter-witness set C6.1.1 has no succeeding row in Ï„10 because it does not satisfy rb. Remaining
rows u12.3, u12.6 have â€œoriginâ€ u6.4 in Ï„6.
B Omitted Proofs
B.1 Correctness of DynASP2.5
Bliem et al. [5] have shown that augmentable W-Tabs can be transformed into W,W-Tabs, which easily
allows reading off subset-minimal solutions starting at the table W,W-Tabs[n] for TD root n. We follow
their concepts and define a slightly extended variant of augmentable tables. Therefore, we reduce the
problem of enumerating disjunctive programs to EnumMinSAT1 and show that the resulting tables
of algorithm MOD (see Algorithm 2) are augmentable. In the end, we apply an earlier theorem [5]
transforming MOD-Tabs obtained by DPMOD into MOD,MOD-Tabs via the augmenting function aug(Â·)
proposed in their work. To this extent, we use auxiliary definitions Child-Tabst, origt(Â·) and evolt(Â·)
specified in Algorithm 3.
Definition 3. Let T = (T, Ï‡) be a TD where T = (N, Â·, Â·), W be a table algorithm, t âˆˆ N , and
Ï„ âˆˆW-Tabs[t] be the table for node t. For tuple ~u = ã€ˆM,Ïƒ, Â· Â· Â· ã€‰ âˆˆ Ï„, we define Î±(~u) :=M , Î²(~u) :=Ïƒ. We
inductively define
Î±âˆ—(Ï„) :=
â‹ƒ
~uâˆˆÏ„
Î±(~u) âˆª
â‹ƒ
Ï„ â€²âˆˆChild-Tabst
Î±âˆ—(Ï„ â€²), and
Î²âˆ—(Ï„) :=
â‹ƒ
~uâˆˆÏ„
Î²(~u) âˆª
â‹ƒ
Ï„ â€²âˆˆChild-Tabst
Î²âˆ—(Ï„ â€²).
Moreover, we inductively define the extensions of a row ~u âˆˆ Ï„ as
E(~u) :=
{
{~u} âˆª U | U âˆˆ
â‹ƒ
{{~uâ€²1},...,{~uâ€²k}}âˆˆorigt(~u)
{Ï„1 âˆª Â· Â· Â· âˆª Ï„k | Ï„i âˆˆ E(~uâ€²i) for all 1 â‰¤ i â‰¤ k}
}
.
Remark 1. Any extension U âˆˆ E(~u) contains ~u and exactly one row from each table that is a descendant
of Ï„. If ~u is a row of a leaf table, E(~u) = {{~u}} since origt(~u) = {âˆ…} assuming
âˆ
iâˆˆâˆ… Si = {()}.
Definition 4. Let Ï„n be the table in W-Tabs for TD root n. We define the set sol(W-Tabs) of solutions
of W-Tabs as sol(W-Tabs) :={Î±âˆ—(U) | ~u âˆˆ Ï„n, U âˆˆ E(~u)}
Definition 5. Let Ï„ be a table in W-Tabs such that Ï„ â€²1, . . . , Ï„ â€²k are the child tables Child-Tabst and let
~u,~v âˆˆ Ï„. We say that x âˆˆ X(~u) has been Xâˆ’illegally introduced at ~u if there are {{~uâ€²1}, . . . , {~uâ€²k}} âˆˆ
origt(~u) such that for some 1 â‰¤ i â‰¤ k it holds that x /âˆˆ X(~uâ€²i) while x âˆˆ Xâˆ—(Ï„ â€²i). Moreover, we say that
x âˆˆ X(~v) \X(~u) has been Xâˆ’illegally removed at ~u if there is some U âˆˆ E(~u) such that x âˆˆ X(U).
13
Definition 6. We call a table Ï„ augmentable if the following conditions hold:
1. For all rows of the form ã€ˆM, Â· Â· Â· , Cã€‰, we have C = âˆ….
2. For all ~u,~v âˆˆ Ï„ with ~u 6= ~v it holds that Î±(~u) âˆª Î²(~u) 6= Î±(~v) âˆª Î²(v).
3. For all ~u = ã€ˆM,Ïƒ, Â· Â· Â· ã€‰ âˆˆ Ï„, {{~uâ€²1}, . . . , {~uâ€²k}} âˆˆ origt(~u), 1 â‰¤ i < j â‰¤ k, I âˆˆ E(~uâ€²i) and J âˆˆ E(~uâ€²j)
it holds that Î±âˆ—(I) âˆ© Î±âˆ—(J) âŠ†M and Î²âˆ—(I) âˆ© Î²âˆ—(J) âŠ† Ïƒ.
4. No element of Î±âˆ—(Ï„) has been Î±-illegally introduced and no element of Î²âˆ—(Ï„) has been Î²-illegally
introduced.
5. No element of Î±âˆ—(Ï„) has been Î±-illegally removed and no element of Î²âˆ—(Ï„) has been Î²-illegally
removed.
We call W-Tabs augmentable if all its tables are augmentable.
It is easy to see that MOD-Tabs are augmentable, that is, Algorithm 2 (DPMOD(Â·)) computes only
augmentable tables.
Observation 1. MOD-Tabs are augmentable, since DPMOD(Â·) computes augmentable tables. CMOD-Tabs
are augmentable, since DPCMOD(Â·) computes augmentable tables.
The following theorem establishes that we can reduce an instance of EnumAsp (restricted to disjunc-
tive input programs) when parameterized by semi-incidence treewidth to an instance of EnumMinSAT1
when parameterized by the treewidth of its incidence graph.
Lemma 1. Given a disjunctive program P of semi-incidence treewidth k = tw(S(P )). We can produce
in time O(â€–Pâ€–) a propositional formula F such that the treewidth kâ€² of the incidence graph I(F )8 is
kâ€² â‰¤ 7k + 2 and the answer sets of P and subset-minimal models of F * are in a particular one-to-
one correspondence. More precisely, M is an answer set of P if and only if M âˆªMaux âˆª {sol} is a
subset-minimal model of F where Maux is a set of additional variables occurring in F , but not in P and
variables introduced by Tseitin normalization.
Proof. Let P be a disjunctive program of semi-incidence treewidth k = tw(S(P )). First, we construct
a formula F consisting of a conjunction over formulas F r, F impl, F sol, Fmin followed by Tseitin
normalization of F to obtain F *. Among the atoms9 of our formulas will the atoms at(P ) of the program.
Further, for each atom a such that a âˆˆ Bâˆ’(r) for some rule r âˆˆ P , we introduce a fresh atom aâ€². In
the following, we denote by Z â€² the set {zâ€² : z âˆˆ Z} for any set Z and by Bâˆ’P :=
â‹ƒ
râˆˆP B
âˆ’
r . Hence, (B
âˆ’
P )
â€²
denotes a set of fresh atoms for atoms occurring in any negative body. Then, we construct the following
formulas:
F r(r) :=Hr âˆ¨ Â¬B+r âˆ¨ (Bâˆ’r )â€² for r âˆˆ P (1)
F impl(a) :=aâ†’ aâ€² for a âˆˆ Bâˆ’P (2)
F sol(a) :=solâ†’ (aâ€² â†’ a) for a âˆˆ Bâˆ’P (3)
Fmin :=Â¬solâ†’
âˆ¨
aâ€²âˆˆ(Bâˆ’P )â€²
(aâ€² âˆ§ Â¬a) (4)
F :=
âˆ§
râˆˆP
F r(r) âˆ§
âˆ§
aâˆˆBâˆ’P
F impl(a) âˆ§
âˆ§
aâˆˆBâˆ’P
F sol(a) âˆ§ Fmin (5)
Next, we show that M is an answer set of P if and only if M âˆª ([M âˆ©Bâˆ’P ])â€²âˆª{sol} is a subset-minimal
model of F .
8The incidence graph I(F ) of a propositional formula F in CNF is the bipartite graph that has the variables and
clauses of F as vertices and an edge v c if v is a variable that occurs in c for some clause c âˆˆ F [22].
9Note that we do not distinguish between atoms and propositional variables in terminology here.
14
(â‡’): Let M be an answer set of P . We transform M into Y :=M âˆª ([M âˆ©Bâˆ’P ])â€² âˆª{sol}. Observe that Y
satisfies all subformulas of F and therefore Y  F . It remains to show that Y is a minimal model of F .
Assume towards a contradiction that Y is not a minimal model. Hence, there exists X with X ( Y . We
distinguish the following cases:
1. sol âˆˆ X: By construction of F we have X  aâ€² â†” a for any aâ€² âˆˆ (Bâˆ’P )â€², which implies that
X âˆ© at(P )  PM . However, this contradicts our assumption that M is an answer set of P .
2. sol 6âˆˆ X: By construction of F there is at least one atom a âˆˆ Bâˆ’P with aâ€² âˆˆ X, but a 6âˆˆ X.
Consequently, X âˆ© at(P )  PM . This contradicts again that M is an answer set of P .
(â‡): Given a formula F that has been constructed from a program P as given above. Then, let Y be a
subset-minimal model of F such that sol âˆˆ Y . By construction we have for every aâ€² âˆˆ Y âˆ© (Bâˆ’P )â€² that
a âˆˆ Y . Hence, we let M = at(P ) âˆ© Y . Observe that M satisfies every rule r âˆˆ P according to (A1) and
is in consequence a model of P . It remains to show that M is indeed an answer set. Assume towards a
contradiction that M is not an answer set. Then there exists a model N (M of the reduct PM . We
distinguish the following cases:
1. N is not a model of P : We construct X :=N âˆª [Y âˆ© (Bâˆ’P )â€²] and show that X is indeed a model
of F . For this, for every r âˆˆ P where Bâˆ’(r) âˆ©M 6= âˆ… we have X  F r(r), since (Y âˆ© (Bâˆ’P )â€²) âŠ† X
by definition of X. For formulas (A1) constructed by F r(r) using remaining rules r, we also have
X  F r(r), since N  {r}M . In conclusion, X  F and X ( Y , and therefore X contradicts Y is
a subset-minimal model of F .
2. N is also a model of P : Observe that then X :=N âˆª [N âˆ©Bâˆ’P ]â€² âˆª {sol} is also a model of F , which
contradicts optimality of Y since X ( Y .
By Tseitin normalization, we obtain F âˆ—, thereby introducing fresh atoms laâ€² for each aâ€² âˆˆ (Bâˆ’P )â€²:
F r*(r) :=Hr âˆ¨ Â¬B+r âˆ¨ (Bâˆ’r )â€² for r âˆˆ P (A1*)
F impl*(a) :=Â¬a âˆ¨ aâ€² for a âˆˆ Bâˆ’P (A2*)
F sol*(a) :=Â¬sol âˆ¨ (Â¬aâ€² âˆ¨ a) for a âˆˆ Bâˆ’P (A3*)
Fmin1 :=sol âˆ¨
âˆ¨
aâ€²âˆˆBâˆ’
P â€²
(laâ€²) (A4.1*)
Fmin2 (a) :=Â¬aâ€² âˆ¨ a âˆ¨ laâ€² for a âˆˆ Bâˆ’P (A4.2*)
Fmin3 (a) :=Â¬laâ€² âˆ¨ aâ€² for a âˆˆ Bâˆ’P (A4.3*)
Fmin4 (a) :=Â¬laâ€² âˆ¨ Â¬a for a âˆˆ Bâˆ’P (A4.4*)
Observe that the Tseitin normalization is correct and that there is a bijection between models of F âˆ—
and F .
Observe that our transformations runs in linear time and that the size of F * is linear in â€–Pâ€–. It
remains to argue that tw(I(F *)) â‰¤ 7k + 2. For this, assume that T = (T, Ï‡, n) is an arbitrary but fixed
TD of S(P ) of width w. We construct a new TD T â€² :=(T, Ï‡â€², n) where Ï‡â€² is defined as follows. For each
TD node t,
Ï‡â€²(t) :=
â‹ƒ
aâˆˆBâˆ’P âˆ©Ï‡(t)
{aâ€², laâ€²} âˆª [Ï‡(t) âˆ© at(P )] âˆª {sol} âˆª cl(t)
where
cl(t) :=
â‹ƒ
aâˆˆBâˆ’P âˆ©Ï‡(t)
[F impl*(a), F sol*(a), Fmin2 (a), F
min
3 (a), F
min
4 (a)] âˆª {Fmin1 } âˆª
â‹ƒ
râˆˆPâˆ©Ï‡(t)
{F r*(r)}.
It is easy to see that T â€² is indeed a TD for I(F âˆ—) and that the width of T â€² is at most 7w + 2.
15
Definition 7. We inductively define an augmenting function aug(W-Tabs) that maps each table Ï„ âˆˆ
W-Tabs[t] for node t from an augmentable table to a table in W,W-Tabs[t]. Let the child tables of Ï„ be
called Ï„ â€²1, . . . , Ï„
â€²
k. For any 1 â‰¤ i â‰¤ k and ~u âˆˆ Ï„i, we write res(~u) to denote {~v âˆˆ aug(Ï„ â€²i) | Î±(~u) = Î±(~v)}.
We define aug(Ï„) as the smallest table that satisfies the following conditions:
1. For any ~u âˆˆ Ï„, {{~uâ€²1}, . . . , {~uâ€²k}} âˆˆ origt(~u) and {{~vâ€²1}, . . . , {~vâ€²k}} âˆˆ
âˆÌ‚
1â‰¤iâ‰¤k res(~u
â€²
i), there is a row
~v âˆˆ aug(Ï„) with Î±(~u) = Î±(~v) and {{~vâ€²1}, . . . , {~vâ€²k}} âˆˆ origt(~v).
2. For any ~u,~v âˆˆ aug(Ï„) with ~u = ã€ˆÂ· Â· Â· , Cã€‰ such that Î±(~v) âŠ† Î±(~u), {{~uâ€²1}, . . . , {~uâ€²k}} âˆˆ origt(~u) and
{{~vâ€²1}, . . . , {~vâ€²k}} âˆˆ origt(~v) the following holds: Let 1 â‰¤ i â‰¤ k with ~uâ€²i = ã€ˆÂ· Â· Â· , Ciã€‰, ~ci = ã€ˆCi, Â· Â· Â· ã€‰ âˆˆ
(Ci âˆª {~uâ€²i}) with Ci âŠ† Î±(~vâ€²i), and 1 â‰¤ j â‰¤ k with ~cj 6= ~uâ€²j or Î±(~v) ( Î±(~u). Then, there is a row
~c âˆˆ C with Î±(~c) âŠ† Î±(~v) if and only if ~c âˆˆ Ï„ and {{~c1}, . . . , {~ck}} âˆˆ origt(~c).
For W-Tabs, we write aug(W-Tabs) to denote the result isomorphic to W,W-Tabs where each table Ï„ in
W-Tabs corresponds to aug(Ï„).
Proposition 2. Let W-Tabs be augmentable. Then,
sol(aug(W-Tabs)) = {M âˆˆ sol(W-Tabs) | @M â€² âˆˆ sol(W-Tabs) : M â€² (M}.
Proof (Sketch). The proof follows previous work [5]. We sketch only differences from their work. Any
row ~u âˆˆ Ï„ of any table Ï„ not only consists of set Î±(~u) being subject to subset-minimization and relevant
to solving EnumAsp. In addition, our definitions presented above also allow â€œauxiliaryâ€ sets Î²(~u) per
row ~u, which are not subject to the minimization. Moreover, by the correctness of the table algorithm
INC by Fichte and Szeider [11], we only require to store a set C of counter-witnesses ã€ˆC, Â· Â· Â· ã€‰ âˆˆ C per
witness set M , where each C forms a strictly âŠ‚-smaller model of M . As a consequence, there is no need
to differ between sets of counter-witnesses, which are strictly included or not, see [5]. Finally, we do not
need to care about duplicate rows (solved via compression function compr(Â·) in [5]) in Ï„, since Ï„ is a set.
Theorem 2. EnumAsp when the input is restricted to disjunctive programs can be solved in time 22
(7k+4) Â·
â€–Pâ€– computing aug(DPMOD(Â·)), where k refers to the treewidth of S(P ).
Proof (Sketch). First, we use reduction R(P, k) = (F âˆ—, kâ€²) defined in Lemma 1 to construct an instance
of SAT given our disjunctive ASP program P . Note that kâ€² = tw(I(F âˆ—)) â‰¤ 7k + 2. Then, we can
compute in time 2O(k
â€²3) Â· |I(F âˆ—)| a tree decomposition of width at most kâ€² [6]. Note that since we require
to look for solutions containing sol at the root, we modify each bag of T such that it contains sol.
We call the resulting tree decomposition T â€². We compute aug(DPMOD(T â€²)) using formula F âˆ— (see
Algorithm 2). Finally, by Theorem 2 and Lemma 1, we conclude that answer sets of P correspond to
{M âˆˆ sol(aug(DPMOD(T â€²))) | sol âˆˆM, @M â€² âˆˆ sol(DPMOD(T â€²)) : M â€² (M}.
The complexity proof sketched in [5] only cares about the runtime being polynomial. In fact, the
algorithm can be carried out in linear time, following complexity proofs presented by Fichte et al. [11],
which leads to a worst-case runtime of 22
(7k+4) Â· â€–Pâ€–.
We can now even provide a â€œconstructive definitionâ€ of the augmenting function aug(Â·).
Proposition 3. The resulting table aug(W-Tabs) obtained via DPW(T ) for any TD T is equivalent to
the table DPLW,W(T ) as given in Algorithm 3.
Proof (Idea). Intuitively, (1.) of Definition 7 concerns completeness, i.e., ensures that no row is left out
during the augmentation, and is ensured by row 7 of Algorithm 3 since each ~u âˆˆW-Tabs is preserved.
The second condition (2.) enforces that there is no missing counter-witness for any witness, and the idea
is that whenever two witnesses ~u,~v âˆˆ Ï„ are in a subset relation (Î±(~v) âŠ† Î±(~u)) and their corresponding
linked counter-witnesses (fcw) of the corresponding origins (orig) are in a strict subset relation, then
there is some counter-witness c for u if and only if ~c âˆˆ Ï„ is the successor (evol) of these corresponding
linked counter-witnesses. Intuitively, we can not miss any counter-witnesses in DPLW,W(T ) required by
16
(2.), since this required that there are two rows ~uâ€², ~vâ€² âˆˆ Ï„ â€² with Î±(~v) = Î±(~u) for one table Ï„ â€². Now let
the corresponding succeeding rows ~u,~v âˆˆ Ï„ (i.e., ~u âˆˆ evolt({{~uâ€²}}), ~v âˆˆ evolt({{~vâ€²}}), respectively) with
Î±(~v) ( Î±(~u), Î²(~v) 6âŠ† Î²(~u) and Î²(~v) 6âŠ‡ Î²(~u), mark the first encounter of a missing counter-witness. Since
Î²(~v) is incomparable to Î²(~u), we conclude that the first encounter has to be in a table preceeding Ï„. To
conclude, one can show that DPLW,W(T ) does not contain â€œtoo manyâ€ rows, which do not fall under
conditions (1.) and (2.).
Theorem 2 works not only for disjunctive ASP via reduction to EnumMinSAT1, where witnesses
and counter-witnesses are derived with the same table algorithm MOD. In fact, one can also link
counter-witnesses to witnesses by means of DPLW,C(Â·), thereby using table algorithms W,C for computing
witnesses and counter-witnesses, respectively. In order to show correctness of algorithm DPLMOD,CMOD(Â·)
(Theorem 1) working for any ASP program, it is required to extend the definition of the augmenting
function aug(Â·) such that it is capable of using two different tables.
Proposition 4. Problem EnumAsp can be solved in time f(k)Â·â€–Pâ€– computing DPLMOD,CMOD(Â·), where k
refers to the treewidth of S(P ) and f is a computable function.
C Additional Information on the Benchmarks
C.1 Benchmark Sets
In this paper, we mainly presented10 the Steiner tree problem using public transport networks. We
also considered benchmarks for counting answer sets as carried out in earlier work [11]. DynASP2.5
performs slightly better than DynASP2 on those instances. Hence, we do not report them here.
C.1.1 Transit Graphs
The instance graphs have been extracted from publicly available mass transit data feeds and splited by
transportation type, e.g., train, metro, tram, combinations. We heuristically computed tree decomposi-
tions [2] and obtained relatively fast decompositions of small width unless detailed bus networks were
present. Among the graphs considered were public transit networks of the cities London, Bangladesh,
Timisoara, and Paris.
C.1.2 Steiner Tree Problem
Picture yourself as the head of a famous internet service provider, which is about to provide high-speed
internet for their most-prestigious customers in public administration in order to increase productivity
levels beyond usual standards. However, these well-paying customers have to be connected via expensive
fibre cables. The good news is that the city council already confirmed that you are allowed to use
existing cable ducts, which basically adhere to the cityâ€™s transit network. We assumed for simplicity,
that edges have unit costs, and randomly generated a set of terminal stations â€” which are compliant
with the customers â€” among our transit stations (vertices). The goal is to search for a set of transit
connections of minimal cardinality such that the customers can be connected for example when putting
fibre cables along the transit network.
An encoding for this problem is depicted in Listing 1 and assumes a specification of the graph
(via edge) and the facilities (terminalVertex ) of our customers in public administration as well as the
number (numVertices) of vertices. The encoding is based on the saturation technique [9] and in fact
outperformed a different encoding presented in Listing 2 on all our instances using both solvers, Clasp
and DynASP2.5. At first sight, this observation seems quite surprising, however, we benchmarked on
more than 60 graphs with 10 varying decompositions for each solver variant and additional configurations
and different encodings for Clasp.
10Benchmarks, encodings, and results are available at https://github.com/daajoe/dynasp experiments/tree/ipec2017.
17
%
%
%
vertex(X) â† edge(X,_).
vertex(Y) â† edge(_,Y).
edge(X,Y) â† edge(Y,X).
%
0 { selectedEdge(X,Y) } 1 â† edge(X,Y), X < Y.
%
s1(X) âˆ¨ s2(X) â† vertex(X).
%
saturate â† selectedEdge(X,Y), s1(X), s2(Y), X < Y.
saturate â† selectedEdge(X,Y), s2(X), s1(Y), X < Y.
%
%
saturate â† N #count{ X : s1(X), terminalVertex(X) }, numVertices(N).
saturate â† N #count{ X : s2(X), terminalVertex(X) }, numVertices(N).
s1(X) â† saturate , vertex(X).
s2(X) â† saturate , vertex(X).
â† not saturate.
%
#minimize{ 1,X,Y : selectedEdge(X,Y) }.
Listing 1 Encoding for St
%
%
edge(X,Y) â† edge(Y,X).
{ selectedEdge(X,Y) : edge(X,Y), X < Y }.
%
reached(Y) â† Y = #min{ X : terminalVertex(X) }.
reached(Y) â† reached(X), selectedEdge(X,Y).
reached(Y) â† reached(X), selectedEdge(Y,X).
â† terminalVertex(X), not reached(X).
%
#minimize{ 1,X,Y : selectedEdge(X,Y) }.
Listing 2 Alternative encoding for St
Example 6 (Steiner Tree). Let G = (V,E) be a graph and VT âŠ† V . A uniform Steiner tree on G is a
subgraph SG = (VS , ES) of G such that VT âŠ† VS and for each distinct pair v, w âˆˆ VT there is a path
from v to w. The Steiner tree problem Enum-St asks to output all uniform Steiner trees. We encode
Enum-St into an ASP program as follows: Among the atoms of our program will be an atom av for each
vertex v âˆˆ VT , and an atom evw for each edge vw âˆˆ E assuming v < w for an arbitrary, but fixed total
ordering < among V . Let s be an arbitrary vertex s âˆˆ VT . We generate program P (G,VT ) :={{evw} â†
;  evw | vw âˆˆ E} âˆª {av â† aw, evw; aw â† av, evw | vw âˆˆ E, v < w} âˆª {â† Â¬av | v âˆˆ VT } âˆª {as â†}.
It is easy to see that the answer sets of the program and the uniform Steiner trees are in a one-to-one
correspondence.
C.1.3 Other Graph Problems
We refer to the technical report [10] for comprehensive benchmark results using common graph problems
and comparing different table algorithms of DynASP2 and DynASP2.5. There we investigated various
18
graph problems including, but not limited to, variants of graph coloring, dominating set and vertex
cover. Note that, however, the cluster setup was slightly different.
C.2 Benchmark Environment
The experiments presented ran on an Ubuntu 16.04.1 LTS Linux cluster of 3 nodes with two Intel Xeon
E5-2650 CPUs of 12 physical cores each at 2.2 Ghz clock speed and 256 GB RAM. All solvers have been
compiled with gcc version 4.9.3 and executed in single core mode.
19

