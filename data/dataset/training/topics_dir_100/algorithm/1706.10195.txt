Agglomerative Clustering of Growing Squares∗
Thom Castermans1, Bettina Speckmann2, Frank Staals3, and
Kevin Verbeek4
1 Department of Computer Science, TU Eindhoven, Eindhoven, Netherlands
t.h.a.castermans@tue.nl
2 Department of Computer Science, TU Eindhoven, Eindhoven, Netherlands
b.speckmann@tue.nl
3 MADALGO, Aarhus University, Aarhus, Denmark
f.staals@cs.au.dk
4 Department of Computer Science, TU Eindhoven, Eindhoven, Netherlands
k.a.b.verbeek@tue.nl
Abstract
We study an agglomerative clustering problem motivated by interactive glyphs in geo-visualization.
Consider a set of disjoint square glyphs on an interactive map. When the user zooms out, the
glyphs grow in size relative to the map, possibly with different speeds. When two glyphs intersect,
we wish to replace them by a new glyph that captures the information of the intersecting glyphs.
We present a fully dynamic kinetic data structure that maintains a set of n disjoint growing
squares. Our data structure uses O(n(logn log logn)2) space, supports queries in worst case
O(log3 n) time, and updates in O(log7 n) amortized time. This leads to an O(nα(n) log7 n) time
algorithm to solve the agglomerative clustering problem. This is a significant improvement over
the current best O(n2) time algorithms.
1998 ACM Subject Classification I.3.5 Computational Geometry and Object Modeling
Keywords and phrases computational geometry, kinetic data structures, range tree
1 Introduction
We study an agglomerative clustering problem motivated by interactive glyphs in geo-
visualization. Our specific use case stems from the eHumanities, but similar visualizations are
used in a variety of application areas. GlamMap [5]1 is a visual analytics tool which allows
the user to interactively explore datasets which contain (at least) the following metadata
of a book collection: author, title, publisher, year of publication, and location (city) of
publisher. Each book is depicted by a square, color-coded by publication year, and placed
on a map according to the location of its publisher. Overlapping squares (many books are
published in Leipzig, for example) are recursively aggregated into a larger glyph until all
glyphs are disjoint (see Fig. 1). As the user zooms out, the glyphs “grow” relative to the
map to remain legible. As a result, glyphs start to overlap and need to be merged into
larger glyphs to keep the map clear and uncluttered. It is straightforward to compute the
resulting agglomerative clustering whenever a data set is loaded and to serve it to the user
as needed by the current zoom level. However, GlamMap allows the user to filter by author,
title, year of publication, or other applicable meta data. It is impossible to pre-compute the
∗ The Netherlands Organisation for Scientific Research (NWO) is supporting B.S. under project
no. 639.023.208, K.V. under project no. 639.021.541, and T.C. under project no. 314.99.117. The
Danish National Research Foundation is supporting F.S. under grant nr. DNRF84.
1 http://glammap.net/glamdev/maps/1, best viewed in Chrome.
© Thom Castermans, Bettina Speckmann, Frank Staals, and Kevin Verbeek;
licensed under Creative Commons License CC-BY
ar
X
iv
:1
70
6.
10
19
5v
1 
 [
cs
.D
S]
  3
0 
Ju
n 
20
17
2 Agglomerative Clustering of Growing Squares
Figure 1 Zooming out in GlamMap will merge overlapping squares. This figure shows a sequence
of three steps zooming out from the surroundings of Leipzig.
clustering for any conceivable combination of filter values. To allow the user to browse at
interactive speeds, we hence need an efficient agglomerative clustering algorithm for growing
squares (glyphs). Interesting bibliographic data sets (such as the catalogue of WorldCat,
which contains more than 321 million library records at hundreds of thousands of distinct
locations) are too large by a significant margin to be clustered fast enough with the current
state-of-the-art O(n2) time algorithms (here n is the number of squares or glyphs).
In this paper we formally analyze the problem and present a fully dynamic data structure
that uses O(n(logn log logn)2) space, supports updates in O(log7 n) amortized time, and
queries in O(log3 n) time, which allows us to compute the agglomerative clustering for n
glyphs in O(nα(n) log7 n) time. Here, α is the extremely slowly growing inverse Ackermann
function. To the best of our knowledge, this is the first fully dynamic clustering algorithm
which beats the classic O(n2) time bound.
Formal problem statement. Let P be a set of points in R2 (the locations of publishers
from our example). Each point p ∈ P has a positive weight pw (number of books published
in this city). Given a “time” parameter t, we interpret the points in P as squares. More
specifically, let p(t) be the square centered at p with width tpw. For ease of exposition we
assume all x and y to be unique. With some abuse of notation we may refer to P as a set of
squares rather than the set of center points of squares. Observe that initially, i.e. at t = 0,
all squares in P are disjoint. As t increases, the squares in P grow, and hence they may start
to intersect. When two squares p(t) and q(t) intersect at time t, we remove both p and
q and replace them by a new point z = αp + (1 − α)q, with α = wp/(wp + wq), of weight
zw = pw + qw (see Fig. 2).
t = 1, weights as
indicated
2
1
4
2
6
9
7
t = 1, merged square
in blue
t = 2621 t =
26
21 , final square
and merge tree
Figure 2 The timeline of squares that grow and merge as they touch.
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 3
Related Work. Funke, Krumpe, and Storandt [6] introduced so-called “ball tournaments”,
a related, but simpler, problem, which is motivated by map labeling. Their input is a set of
balls in Rd with an associated set of priorities. The balls grow linearly and whenever two balls
touch, the ball with the lower priority is eliminated. The goal is to compute the elimination
sequence efficiently. Bahrdt et al. [4] and Funke and Storandt [7] improved upon the initial
results and presented bounds which depend on the ratio ∆ of the largest to the smallest
radius. Specifically, Funke and Storandt [7] show how to compute an elimination sequence
for n balls in O(n log ∆(log +∆d−1)) time in arbitrary dimensions and in O(Cnpolylogn)
time for d = 2, where C denotes the number of different radii. In our setting eliminations
are not sufficient, since merged glyphs need to be re-inserted. Furthermore, as opposed to
typical map labeling problems where labels come in a fixed range of sizes, the sizes of our
glyphs can vary by a factor of 10.000 or more (Amsterdam with its many well-established
publishers vs. Kaldenkirchen with one obscure one).
Ahn et al. [2] very recently and independently developed the first sub-quadratic algorithms
to compute elimination orders for ball tournaments. Their results apply to balls and boxes
in two or higher dimensions. Specifically, for squares in two dimensions they can compute an
elimination order in O(n log4 n) time. Their results critically depend on the fact that they
know the elimination priorities at the start of their algorithm and that they only have to
handle deletions. Hence they do not have to run an explicit simulation of the growth process
and can achieve their results by the clever use of advanced data structures. In contrast, we
are handling the fully dynamic setting with both insertions and deletions, and without a
specified set of priorities.
Our clustering problem combines both dynamic and kinetic aspects: squares grow, which
is a restricted form of movement, and squares are both inserted and deleted. There are
comparatively few papers which tackle dynamic kinetic problems. Alexandron et al. [3]
present a dynamic and kinetic data structure for maintaining the convex hull of points (or
analogously, the lower envelope of lines) moving in R2. Their data structure processes (in
expectation) O(n2βs+2(n) logn) events in O(log2 n) time each. Here, βs(n) = λs(n)/n, and
λs(n) is the maximum length of a Davenport-Schinzel sequence on n symbols of order s.
Agarwal et al. [1] present dynamic and kinetic data structures for maintaining the closest
pair and all nearest neighbors. The expected number of events processed is again roughly
O(n2βs+2(n) polylogn), each of which can be handled in O(polylogn) expected time. We
are using some idea and constructions which are similar in flavor to the structures presented
in their paper.
Results. We present a fully dynamic data structure that can maintain a set P of disjoint
growing squares. Our data structure will produce an intersection event at every time t
when two squares p and q, with p, q ∈ P , start to intersect (i.e. at any time before t, all
squares in P remain disjoint). At such a time, we then have to delete some of the squares,
to make sure that the squares in P are again disjoint. At any time, our data structure
supports inserting a new square that is disjoint from the squares in P , or removing an existing
square from P . Our data structure can handle a sequence of m ≥ n updates in a total of
O(mα(n) log7 n) time, each update is performed in O(log7 n) amortized time.
The Main Idea. We develop a data structure that can maintain a dynamic set of disjoint
squares P , and produce an intersection event at every time t when q starts to intersect
with a square p of a point p ∈ P that dominates q. We say that a point p dominates q if
and only if qx ≤ px and qy ≤ py. We then combine four of these data structures, one for
4 Agglomerative Clustering of Growing Squares
each quadrant, to make sure that all squares in P remain disjoint. The main observation
that allows us to maintain P efficiently, is that we can maintain the points D(q) dominating
q in an order so that a prefix of D(q) will have their squares intersect the top side of
q first, and the remaining squares will intersect the right side of q first. We formalize
this in Section 2. We then present our data structure –essentially a pair of range trees
interlinked with linking certificates– in Section 3. While our data structure is conceptually
simple, the exact implementation is somewhat intricate, and the details are numerous. Our
initial analysis shows that our data structure maintains O(log6 n) certificates per square,
which yields an O(log7 n) amortized update time. This allows us to simulate the process of
growing the squares in P –and thus solve the agglomerative glyph clustering problem– in
O(nα(n) log7 n) time using O(n log5 n) space. In Section 4 we analyze the relation between
canonical subsets in dominance queries. We show that for two range trees TR and TB in Rd,
the number of pairs of nodes r ∈ TR and b ∈ TB for which r occurs in the canonical subset of
a dominance query defined by b and vice versa is only O(n(logn log logn)2), where n is the
total size of TR and TB . This implies that the number of linking certificates that our data
structure maintains, as well as the total space used, is actually only O(n(logn log logn)2).
Since the linking certificates actually provide an efficient representation of all dominance
relations between two point sets (or within a point set), we believe that this result is of
independent interest as well.
2 Geometric Properties
q
q
rq
`q
L−(q)  
γ
L(q)
L+(q)
D(q)
Figure 3 The squares and the projection of
their centers and relevant corners onto the line γ.
Let `q denote the bottom left vertex of a
square q, and let rq denote the top right
vertex of q. Furthermore, let D(q) denote
the subset of points of P dominating q, and
let L(q) = {`p | p ∈ D(q)} denote the set of
bottom left vertices of the squares of those
points.
I Observation 1. Let p ∈ D(q) be a point
dominating point q. The squares q(t) and
p(t) intersect at time t if and only if rq(t)
dominates `p(t) at time t.
Consider a line γ with slope minus one,
project all points in Z(t) = {rq(t)}∪L(q)(t),
for some time t, onto γ, and order them from
left to right. Observe that, since all points in Z move along lines with slope one, this order
does not depend on the time t. Moreover, for any point p, we have rp(0) = `p(0) = p, so we
can easily compute this order by projecting the centers of the squares onto γ and sorting
them. Let D−(q) denote the (ordered) subset of D(q) that occur before q in the order along
γ, and let D+(q) denote the ordered subset of D(q) that occur after q in the order along γ.
We define L−(q) and L+(q) analogously.
I Observation 2. Let p ∈ D(q) be a point dominating point q, and let t∗ be the first time
at which r = rq(t∗) dominates ` = `p(t∗). We then have that
`x < rx and `y = ry if and only if p ∈ D−(q), and
`x = rx and `y < ry if and only if p ∈ D+(q).
See Fig. 3 for an illustration.
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 5
Observation 2 implies that the points p in D−(q) will start to intersect q at some time
t∗ because the bottom left vertex `p of p will enter q through the top edge, whereas the
bottom left vertex of the (squares of the) points in D+(q) will enter q through the right
edge. We thus obtain the following result.
I Lemma 3. Let t∗ be the first time at which a square p of a point p ∈ D(q) intersects q.
We then have that
(i) rq(t∗)y = `p(t∗)y, and `p(t∗) is the point with
minimum y-coordinate among the points in
L−(q)(t∗) at time t∗, if and only if p ∈ D−(q), and
(ii) rq(t∗)x = `p(t∗)x, and `p(t∗) is the point with
minimum x-coordinate among the points in
L+(q)(t∗) at time t∗, otherwise (i.e. if and only if p ∈ D
+(q)).
3 A Kinetic Data Structure for Growing Squares
In this section we present a data structure that can detect the first intersection among a
dynamic set of disjoint growing squares. In particular, we describe a data structure that can
detect intersections between all pairs of squares p,q in P such that p ∈ D+(q). We build
an analogous data structure for when p ∈ D−(q). This covers all intersections between pairs
of squares p,q, where p ∈ D(q). We then use four copies of these data structures, one for
each quadrant, to detect the first intersection among all pairs of squares.
We describe the data structure itself in Section 3.1, and we briefly describe how to query
it in Section 3.2. We deal with updates, e.g. inserting a new square into P or deleting an
existing square from P , in Section 3.3. In Section 3.4 we analyze the total number of events
that we have to process, and the time required to do so, when we grow the squares.
3.1 The Data Structure
Our data structure consists of two three-layered trees TL and TR, and a set of certificates
linking nodes in TL to nodes in TR. These trees essentially form two 3D range trees on the
centers of the squares in P , taking third coordinate pγ of each point to be their rank in the
order along the line γ (ordered from left to right). The third layer of TL will double as a
kinetic tournament tracking the bottom left vertices of squares. Similarly, TR will track the
top right vertices of the squares.
The Layered Trees. The tree TL is a 3D-range tree storing the center points in P . Each
layer is implemented by a weight-balanced binary search tree (bb[α] tree) [9], and each node
µ corresponds to a canonical subset Pµ of points stored in the leaves of the subtree rooted
at µ. The points are ordered on x-coordinate first, then on y-coordinate, and finally on
γ-coordinate. Let Lµ denote the set of bottom left vertices of squares corresponding to the
set Pµ, for some node µ.
Consider the associated structure XLv of some secondary node v. We consider XLv as
a kinetic tournament on the x-coordinates of the points Lv [1]. More specifically, every
internal node w ∈ XLv corresponds to a set of points Pw consecutive along the line γ. Since
the γ-coordinates of a point p and its bottom left vertex `p are equal, this means w also
corresponds to a set of consecutive bottom left vertices Lw. Node w stores the vertex `p in
Lw with minimum x-coordinate, and will maintain certificates that guarantee this [1].
6 Agglomerative Clustering of Growing Squares
mzx
mzy
mzγ
γ
mwx
mwy
mwγ
w
rq
rq,x < `p,x
u′
v′
`p
u
v
z
Figure 4 The points mz and mw are defined by a pair of nodes z ∈ XRv′ , with v′ ∈ Tu′ , and
w ∈ XLv , with v ∈ Tu. If w ∈ QL(mz) and z ∈ Q(mw) then we add a linking certificate between the
rightmost upper right-vertex rq, q ∈ Pz, and the leftmost bottom left vertex `p, p ∈ Pw.
The tree TR has the same structure as TL: it is a three-layered range tree on the center
points in P . The difference is that a ternary structure XRv , for some secondary node v, forms
a kinetic tournament maintaining the maximum x-coordinate of the points in Rv, where Rv
are the top right vertices of the squares (with center points) in Pv. Hence, every ternary
node z ∈ XRv stores the vertex rq with maximum x-coordinate among Rv.
Let XL and XR denote the set of all kinetic tournament nodes in TL and TR, respectively.
Linking the Trees. Next, we describe how to add linking certificates between the kinetic
tournament nodes in the trees TL and TR that guarantee the squares are disjoint. More
specifically, we describe the certificates, between nodes w ∈ XL and z ∈ XR, that guarantee
that the squares p and q are disjoint, for all pairs q ∈ P and p ∈ D+(q).
Consider a point q. There are O(log2 n) nodes in the secondary trees of TL, whose
canonical subsets together represent exactly D(q). For each of these nodes v we can then
find O(logn) nodes in XLv representing the points in L+(q). So, in total q is interested in a
set QL(q) of O(log3 n) kinetic tournament nodes. It now follows from Lemma 3 that if we
were to add certificates certifying that rq is left of the point stored at the nodes in QL(q) we
can detect when q intersects with a square of a point in D+(q). However, as there may
be many points q interested in a particular kinetic tournament node w, we cannot afford to
maintain all of these certificates. The main idea is to represent all of these points q by a
number of canonical subsets of nodes in TR, and add certificates to only these nodes.
Consider a point p. Symmetric to the above construction, there are O(log3 n) nodes
in kinetic tournaments associated with TR that together exactly represent the (top right
corners of) the points q dominated by p and for which p ∈ D+(q). Let QR(p) denote this set
of kinetic tournament nodes.
Next, we extend the definitions of QL and QR to kinetic tournament nodes. To this
end, we first associate each kinetic tournament node with a (query) point in R3. Consider a
kinetic tournament node w in a tournament XLv , and let u be the node in the primary TL
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 7
for which v ∈ Tu. Let mw = (mina∈Pu ax,minb∈Pv by,minc∈Pw cγ) be the point associated
with w (note that we take the minimum over different sets Pu, Pv, and Pw for the different
coordinates), and define QR(w) = QR(mw). Symmetrically, for a node z in a tournament
XRv , with v ∈ Tu and u ∈ TR, we define mz = (maxa∈Pu ax,maxb∈Pv by,maxc∈Pz cγ) and
QL(z) = QL(mz).
We now add a linking certificate between every pair of nodes w ∈ XL and z ∈ XR for
which (i) w is a node in the canonical subset of z, that is w ∈ QL(z), and (ii) z is a node in
the canonical subset of w, z ∈ QR(w). Such a certificate will guarantee that the point rq
currently stored at z lies left of the point `p stored at w.
I Lemma 4. Every kinetic tournament node is involved in O(log3 n) linking certificates, and
thus every point p is associated with at most O(log6 n) certificates.
Proof. We start with the first part of the lemma statement. Every node w ∈ XL can
be associated with at most O(log3 n) linking certificates: one with each node in QR(w).
Analogously, every node z ∈ XR can be associated with at most O(log3 n) linking certificates:
one for each node in QL(z).
Every point p occurs in the canonical subset of at most O(log3 n) kinetic tournament
nodes in both XL and XR: p is stored in O(log2 n) leaves of the kinetic tournaments, and in
each such a tournament it can participate in O(logn) certificates (at most two tournament
certificates in O(logn) nodes). As we argued above, each such a node itself occurs in at most
O(log3 n) certificates. The lemma follows. J
What remains to argue is that we can still detect the first upcoming intersection.
I Lemma 5. Consider two sets of elements, say blue elements B and red elements R, stored
in the leaves of two binary search trees TB and TR, respectively, and let p ∈ B and q ∈ R,
with q < p, be leaves in trees TB and TR, respectively. There is a pair of nodes b ∈ TB and
r ∈ TR, such that
p ∈ Pb and b ∈ C(TB , [x′,∞)), and
q ∈ Pr and r ∈ C(TR, (−∞, x]),
where x′ = maxPr, x = minPb, and C(TS , I) denotes the minimal set of nodes in TS whose
canonical subsets together represent exactly the elements of S ∩ I.
q
p
b
r
TR
TB
Figure 5 The nodes b and
r in the trees TB and TR.
Proof. Let b be the first node on the path from the root of
TB to p such that the canonical subset Pb of b is contained in
the interval [q,∞), but the canonical subset of the parent of b
is not. We define b to be the root of TB if no such node exists.
We define r to be the first node on the path from the root of
TR to q for which Pr is contained in (−∞, x] but the canonical
subset of the parent is not. We again define r as the root of
TR if no such node exists. See Fig. 5. Clearly, we now directly
have that r is one of the nodes whose canonical subsets form
R ∩ (−∞, x], and that q ∈ Pr (as r lies on the search path to
q). It is also easy to see that p ∈ Pb, as b lies on the search
path to p. All that remains is to show that b is one of the
canonical subsets that together form B ∩ [x′,∞). This follows
from the fact that q ≤ x′ < x ≤ p —and thus Pb is indeed a
subset of [x′,∞)— and the fact that the subset of the parent
v of b contains an element smaller than q, and can thus not be a subset of [x′,∞). J
8 Agglomerative Clustering of Growing Squares
I Lemma 6. Let p and q, with p ∈ D+(q), be the first pair of squares to intersect, at
some time t∗, then there is a pair of nodes w, z that have a linking certificate that fails at
time t∗.
Proof. Consider the leaves representing p and q in TL and TR, respectively. By Lemma 5
we get that there is a pair of nodes u ∈ TL and u′ ∈ TR that, among other properties, have
p ∈ Pu and q ∈ Pu′ . Hence, we can apply Lemma 5 again on the associated trees of u and u′,
giving us nodes v ∈ Tu and v′ ∈ Tu′ which again have p ∈ Pv and q ∈ Pv′ . Finally, we apply
Lemma 5 once more on XLv and XRv′ giving us nodes w ∈ XLv and z ∈ XRv′ with p ∈ Pw and
q ∈ Pz. In addition, these three applications of Lemma 5 give us two points (x, y, γ) and
(x′, y′, γ′) such that:
Pu occurs as a canonical subset representing P ∩ ([x′,∞)× R2),
Pv occurs as a canonical subset representing Pu ∩ (R× [y′,∞)× R), and
Pw occurs as a canonical subset representing Pv ∩ (R2 × [γ′,∞)),
and such that
Pu′ occurs as a canonical subset representing P ∩ ((−∞, x]× R2),
Pv′ occurs as a canonical subset representing Pu′ ∩ (R× (−∞, y]× R), and
Pz occurs as a canonical subset representing Pv′ ∩ (R2 × (−∞, γ]).
Combining these first three facts, and observing that mz = (x′, y′, γ′) gives us that Pw occurs
as a canonical subset representing P ∩ ([x′,∞) × [y′,∞) × [γ′,∞)) = D+((x′, y′, γ′)), and
hence w ∈ QL(mz) = QL(z). Analogously, combining the latter three facts andmw = (x, y, γ)
gives us z ∈ QR(w). Therefore, w and z have a linking certificate. This linking certificate
involves the leftmost bottom left vertex `a for some point a ∈ Pw and the rightmost top
right vertex rb for some point b ∈ Pz. Since p ∈ Pw and q ∈ Pz, we have that rq ≤ rb and
`a ≤ `p, and thus we detect their intersection at time t∗. J
From Lemma 6 it follows that we can now detect the first intersection between a pair of
squares p,q, with p ∈ D+(q). We define an analogous data structure for when p ∈ D−(q).
Following Lemma 3, the kinetic tournaments will maintain the vertices with minimum and
maximum y-coordinate for this case. We then again link up the kinetic tournament nodes in
the two trees appropriately.
Space Usage. Our trees TL and TR are range trees in R3, and thus use O(n log2 n) space.
However, it is easy to see that this is dominated by the space required to store the certificates.
For allO(n log2 n) kinetic tournament nodes we store at mostO(log3 n) certificates (Lemma 4),
and thus the total space used by our data structure is O(n log5 n). In Section 4 we will show
that the number of certificates that we maintain is actually only O(n(logn log logn)2). This
means that our data structure also uses only O(n(logn log logn)2) space.
3.2 Answering Queries
The basic query that our data structure supports is testing if a query square q currently
intersects with a square p in P , with p ∈ D+(q). To this end, we simply select the O(log3 n)
kinetic tournament nodes whose canonical subsets together represent D+(q). For each such
a node w we check if the x-coordinate of the lower-left vertex `p stored at that node (which
has minimum x-coordinate among Lw) is smaller than the x-coordinate of rq. If so, the
squares intersect. The correctness of our query algorithm directly follows from Observation 2.
The total time required for a query is O(log3 n). Similarly, we can test if a given query point
q is contained in a square p, with p ∈ D+(q). Note that our full data structure will contain
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 9
trees analogous to TL that can be used to check if there is a square p ∈ P , with p ∈ D−(q),
or p in one of the other quadrants defined by q, that intersects q.
3.3 Inserting or Deleting a Square
At an insertion or deletion of a square p we proceed in three steps. First, we update the
individual trees TL and TR, making sure that they once again represent 3D range trees of all
center points in P , and that the ternary data structures are, by themselves, correct kinetic
tournaments. For each kinetic tournament node in XL affected by the update, we then query
TR to find a new set of linking certificates. We update the affected nodes in XR analogously.
Finally, we update the global event queue that stores all certificates.
I Lemma 7. Inserting a square into TL or deleting a square from TL takes O(log3 n)
amortized time.
Proof. We use the following standard procedure for updating the three-level bb[α] trees TL
in O(log3 n) amortized time. An update (insertion or deletion) in a ternary data structure
can easily be handled in O(logn) time. When we insert into or delete an element x in a bb[α]
tree that has associated data structures, we add or remove the leaf that contains x, rebalance
the tree by rotations, and finally add or remove x from the associated data structures. When
we do a left rotation around an edge (µ, ν) we have to build a new associated data structure
for node µ from scratch. See Fig. 6. Right rotations are handled analogously. It is well
known that if building the associated data structure at node µ takes O(|Pµ| logc |Pµ|) time,
for some c ≥ 0, then the costs of all rebalancing operations in a sequence of m insertions and
deletions takes a total of O(m logc+1 n) time, where n is the maximum size of the tree at any
time [8]. We can build a new kinetic tournament XLv for node v (using the associated data
structures at its children) in linear time. Note that this cost excludes updating the global
event queue. Building a new secondary tree Tv, including its associated kinetic tournaments,
takes O(|Tv| log |Tv|) time. It then follows that the cost of our rebalancing operations is at
most O(m log2 n). This is dominated by the total number of nodes created and deleted,
O(m log3 n), during these operations. Hence, we can insert or delete a point (square) in TL
in O(log3 n) amortized time. J
Analogous to Lemma 7 we can update TR in O(log3 n) amortized time. Next, we update
the linking certificates. We say that a kinetic tournament node w in TL is affected by an
update if (i) the update added or removed a leaf node in the subtree rooted at w, (ii) node
w was involved in a tree rotation, or (iii) w occurs in a newly built associated tree XLv (for
some node v). Let XLi denote the set of nodes affected by update i. Analogously, we define
the set of nodes XRi of TR affected by the update. For each node w ∈ XLi , we query TR to
find the set of O(log3 n) nodes whose canonical subsets represent QR(w). For each node z in
µ
ν
A
B C
µ
ν
A B
C
Tµ
Figure 6 After a left rotation around an edge (µ, ν), the associated data structure Tµ of node µ
(pink) has to be rebuilt from scratch as its canonical subset has changed. For node ν we can simply
use the old associated data of node µ. No other nodes are affected.
10 Agglomerative Clustering of Growing Squares
this set, we test if we have to add a linking certificate between w and z. As we show next,
this takes constant time for each node z, and thus O(
∑
i |XLi | log
3 n) time in total, for all
nodes w. We update the linking certificates for all nodes in XRi analogously.
We have to add a link between a node z ∈ QR(w) and w if and only if we also have
w ∈ QL(z). We test this as follows. Let v be the node whose associated tree XLv contains w,
and let u be the node in TL whose associated tree contains v. We have that w ∈ QL(z) if
and only if u ∈ C(TL, [mzx,∞)), v ∈ C(Tu, [mzy,∞)), and w ∈ C(XLv , [mzγ ,∞)). We can test
each of these conditions in constant time:
I Observation 8. Let q be a query point in R1, let w be a node in a binary search tree T ,
and let xp = minPp of the parent p of w in T , or xp = −∞ if no such node exists. We have
that w ∈ C(T, [q,∞)) if and only if q ≤ minPw and q > xp.
Finally, we delete all certificates involving no longer existing nodes from our global event
queue, and replace them by all newly created certificates. This takes O(logn) time per
certificate. We charge the cost of deleting a certificate to when it gets created. Since every
node w affected creates at most O(log3 n) new certificates, all that remains is to bound the
total number of affected nodes. We can show this using basically the same argument as we
used to bound the update time. This leads to the following result.
I Lemma 9. Inserting a disjoint square into P , or deleting a square from P takes O(log7 n)
amortized time.
Proof. An update visits at most O(log3 n) nodes itself (i.e. leaf nodes and nodes on the search
path). All other affected nodes occur as newly built trees due to rebalancing operations.
As in Lemma 7, the total number of nodes created due to rotations in a sequence of
m updates is O(m log2 n). It follows that the total number of affected nodes in such a
sequence is O(m log3 n). Therefore, we create O(m log6 n) linking certificates in total, and
we can compute them in O(m log6 n) time. Updating the event global queue therefore takes
O(m log7 n) time. J
3.4 Running the Simulation
All that remains is to analyze the number of events processed. We show that in a sequence
of m operations, our data structure processes at most O(mα(n) log3 n) events. This leads to
the following result.
I Theorem 10. We can maintain a set P of n disjoint growing squares in a fully dynamic
data structure such that we can detect the first time that a square q intersects with a square
p, with p ∈ D+(q). Our data structure uses O(n(logn log logn)2) space, supports updates
in O(log7 n) amortized time, and queries in O(log3 n) time. For a sequence of m operations,
the structure processes a total of O(mα(n) log3 n) events in a total of O(mα(n) log7 n) time.
Proof. We argued the bounds on the space, the query, and the update times before. All that
remains is to bound the number of events processed, and the time to do so.
We start by the observation that each failure of a linking certificate produces an inter-
section, and thus a subsequent update. It thus follows that the number of such events is at
most m.
To bound the number of events created by the tournament trees we extend the argument
of Agarwal et al. [1]. For any kinetic tournament node w in TL, the minimum x-coordinate
corresponds to a lower envelope of line-segments in the t, x-space. This envelope has
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 11
complexity O(|P ∗w|α(|P ∗w|)) = O(|P ∗w|α(n)), where P ∗w is the multiset of points that ever
occur in Pw, i.e. that are stored in a leaf of the subtree rooted at w at some time t. Hence,
the number of tournament events involving node w is also at most O(|P ∗w|α(n)). It then
follows that the total number of events is proportional to the size of these sets P ∗w, over all w
in our tree. As in Lemma 7, every update directly contributes one point to O(log3 n) nodes.
The remaining contribution is due to rebalancing operations, and this cost is again bounded
by O(m log2 n). Thus, the total number of events processed is O(mα(n) log3 n).
At every event, we have to update the O(log3 n) linking certificates of w. This can be
done in O(log4 n) time (including the time to update the global event queue). Thus, the total
time for processing all kinetic tournament events in TL is O(mα(n) log7 n). The analysis for
the kinetic tournament nodes z in TR is analogous. J
To simulate the process of growing the squares in P , we now maintain eight copies of the
data structure from Theorem 10: two data structures for each quadrant (one for D+, the
other for D−). We thus obtain the following result.
I Theorem 11. We can maintain a set P of n disjoint growing squares in a fully dynamic
data structure such that we can detect the first time that two squares in P intersect. Our
data structure uses O(n(logn log logn)2) space, supports updates in O(log7 n) amortized
time, and queries in O(log3 n) time. For a sequence of m operations, the structure processes
O(mα(n) log3 n) events in a total of O(mα(n) log7 n) time.
And thus we obtain the following solution to the agglomerative glyph clustering problem.
I Theorem 12. Given a set of n initial square glyphs P , we can compute an agglomerative
clustering of the squares in P in O(nα(n) log7 n) time using O(n(logn log logn)2) space.
4 Efficient Representation of Dominance Relations
The linking certificates of our data structure actually comprise an efficient representation of
all dominance relations between two point sets. We therefore think that this representation,
and in particular the tighter analysis in this section, is of independent interest.
Let R and B be two point sets in Rd with |R| = n and |B| = m, and let TR and TB be
range trees built on R and B, respectively. We assume that each layer of TR and TB consists
of a bb[α]-tree, although similar analyses can be performed for other types of balanced binary
search trees. By definition, every node u on the lowest layer of TR or TB has an associated
d-dimensional range Qu (the hyper-box, not the subset of points). For a node u ∈ TR, we
consider the subset of points in B that dominate all points in Qu, which can be comprised of
O(logdm) canonical subsets of B, represented by nodes in TB . Similarly, for a node v ∈ TB ,
we consider the subset of points in R that are dominated by all points in Qv, which can be
comprised of O(logd n) canonical subsets of R, represented by nodes in TR. We now link a
node u ∈ TR and a node v ∈ TB if and only if v represents such a canonical subset for u
and vice versa. By repeatedly applying Lemma 5 for each dimension, it can easily be shown
that these links represent all dominance relations between R and B.
As a d-dimensional range tree consists of O(n logd−1 n) nodes, a trivial bound on the
number of links is O(m log2d−1 n) (assuming n ≥ m). Below we show that the number of
links can be bounded by O(n(logn log logn)d−1). We first consider the case for d = 1.
12 Agglomerative Clustering of Growing Squares
4.1 Analyzing the Number of Links in 1D
Let R and B be point sets in R with |R| = n, |B| = m, and n ≥ m. Now, every associated
range of a node u in TR or TB is an interval Iu. We can extend the interval to infinity in
one direction; to the left for u ∈ TR, and to the right for u ∈ TB . For analysis purposes we
construct another range tree T on R∪B, where T is not a bb[α]-tree, but instead a perfectly
balanced tree with height dlog(n + m)e. For convenience we assume that the associated
intervals of T are slightly expanded so that all points in R ∪ B are always interior to the
associated intervals. We associate a node u in TR or TB with a node v in T if the endpoint
of Iu is contained in the associated interval Iv of v.
I Observation 13. Every node of TR or TB is associated with at most one node per level
of T .
For two intervals Iu = (−∞, a] and Iv = [b,∞), corresponding to a node u ∈ TR and a node
v ∈ TB, let [a, b] be the spanning interval of u and v. We now want to charge spanning
intervals of links to nodes of T . We charge a spanning interval Iuv = [a, b] to a node w of T
if and only if [a, b] is a subset of Iw, and [a, b] is cut by the splitting coordinate of w. Clearly,
every spanning interval can be charged to exactly one node of T .
Now, for a node u of T , let hR(u) be the height of the highest node of TR associated
with u, and let hB(u) be the height of the highest node of TB associated with u.
I Lemma 14. The number of spanning intervals charged to a node u of T is O(hR(u)·hB(u)).
Proof. Let x be the splitting coordinate of u and let r ∈ TR and b ∈ TB form a spanning
interval that is charged to u. We claim that, using the notation introduced in Lemma 5, r ∈
C(TR, (−∞, x]) (and symmetrically, b ∈ C(TB , [x,∞))). Let Ib = [x′,∞) be the associated
interval of b, where x′ > x. By definition, r ∈ C(TR, (−∞, x′]). If r /∈ C(TR, (−∞, x]), then
the right endpoint of Ir must lie between x and x′. But then the spanning interval of r and b
would not be charged to u. As a result, we can only charge spanning intervals between hR(u)
nodes of TR and hB(u) nodes of TB , of which there are at most O(hR(u) · hB(u)). J
Using Lemma 14, we count the total number of charged spanning intervals and hence,
links between TR and TB. We refer to this number as numLinks (TR, TB). This is simply∑
u∈T O(hR(u) · hB(u)) ≤
∑
u∈T O(hR(u)2 + hB(u)2). We can split the sum and assume
w.l.o.g. that numLinks (TR, TB) ≤ 2
∑
u∈T O(hR(u)2). Rewriting the sum based on heights
in TR gives
numLinks (TR, TB) ≤
height(TR)∑
hR = 0
nT (hR) ·O(h2R),
where nT (hR) is the number of nodes of T that have a node of height hR associated with it.
To bound nT (h) we use Observation 13 and the fact that TR is a bb[α] tree. Let c = 11−α ,
then we get that height(TR) ≤ logc(n) from properties of bb[α] trees. Therefore, the number
of nodes in TR that have height h is at most O( n
ch
).
I Lemma 15. nT (h) = O
(
(n+m)h
ch
)
.
Proof. As argued, there are at most O(n/ch) nodes in TR of height h. Consider cutting the
tree T at level log(n/ch). This results in a top tree of size O(n/ch), and O(n/ch) bottom
trees. Clearly, the top tree contributes at most its size to nT (h). All bottom trees have
height at most dlog(n+m)e − log(n/ch) = O(log(ch) + log(1 +m/n)) = O(h+m/n). Every
T. Castermans, B. Speckmann, F. Staals, and K. Verbeek 13
Figure 7 Two layered trees with two layers, and the links between them (sketched in black). We
are interested in bounding the number of such links.
node in TR of height h can, in the worst case, be associated with one distinct node per
level in the bottom trees by Observation 13. Hence, the bottom trees contribute at most
O(n(h+m/n)/ch) = O((nh+m)/ch) = O((n+m)h/ch) to nT (h). J
Using this bound on nT (h) in the sum we previously obtained gives:
numLinks (TR, TB) ≤
height(TR)∑
hR=0
O
(
(n+m)h3R
chR
)
≤ O(n+m)
∞∑
h=0
h3
ch
= O(n+m).
Where indeed,
∑∞
h=0
h3
ch
= O(1) because c > 1. Thus, we conclude:
I Theorem 16. The number of links between two 1-dimensional range trees TR and TB
containing n and m points, respectively, is bounded by O(n+m).
4.2 Extending to Higher Dimensions
We now extend the bound to d dimensions. The idea is very simple. We first determine the
links for the top-layer of the range trees. This results in links between associated range trees
of d− 1 dimensions (see Fig. 7). We then determine the links within the linked associated
trees, which number can be bounded by induction on d.
I Theorem 17. The number of links between two d-dimensional range trees TR and TB
containing n and m (n ≥ m) points, respectively, is bounded by O(n(logn log logn)d−1).
Proof. We show by induction on d that the number of links is bounded by the minimum of
O(n(logn log logn)d−1) and O(m log2d−1 n). The second bound is simply the trivial bound
given at the start of Section 4. The base case for d = 1 is provided by Theorem 16. Now
consider the case for d > 1. We first determine the links for the top-layer of TR and TB.
Now consider the links between an associated tree Tu in TR containing k points and other
associated trees T0, . . . , Tr that contain at most k points. Since Tu can be linked with only one
associated tree per level, and because both range trees use bb[α] trees, the number of points
m0, . . . ,mr in T0, . . . , Tr satisfy mi ≤ k/ci (0 ≤ i ≤ r) where c = 11−α . By induction, the
number of links between Tu and Ti is bounded by the minimum of O(k(logn log logn)d−2) and
O(mi log2d−3 n). Now let i∗ = logc(logd−1 n) = O(log logn). Then, for i ≥ i∗, we get that
O(mi log2d−3 n) = O(k logd−2 n). Since the sizes of the associated trees decrease geometrically,
the total number of links between Tu and Ti for i ≥ i∗ is bounded by O(k logd−2 n). The
links with the remaining trees can be bounded by O(k logd−2 n(log logn)d−1). Finally note
that the top-layer of each range tree has O(logn) levels, and that each level contains n points
in total. Thus, we obtain O(n logd−1 n(log logn)d−1) links in total. The remaining links for
which the associated tree in TB is larger than in TR can be bounded in the same way. J
14 Agglomerative Clustering of Growing Squares
It follows from Theorem 17 that our data structure from Section 3 actually maintains
only O(n(logn log logn)2) certificates. This directly implies that the space usage is only
O(n(logn log logn)2) as well.
5 Conclusion and Future Work
We presented an efficient fully dynamic data structure for maintaining a set of disjoint
growing squares. This leads to an efficient algorithm for agglomerative glyph clustering. The
main future challenge is to improve the analysis of the running time. Our analysis from
Section 4 shows that at any time, we need only few linking certificates. However, we would
like to bound the total number of linking certificates used throughout the entire sequence of
operations. An interesting question is if we can extend our argument to this case. This may
also lead to a more efficient algorithm for maintaining the linking certificates during updates.
References
1 P. K. Agarwal, H. Kaplan, and M. Sharir. Kinetic and Dynamic Data Structures for Closest
Pair and All Nearest Neighbors. ACM Transactions on Algorithms, 5(1):4:1–4:37, 2008.
2 H.-K. Ahn, S. W. Bae, J. Choi, M. Korman, W. Mulzer, E. Oh, J.-w. Park, A. van Renssen,
and A. Vigneron. Faster Algorithms for Growing Prioritized Disks and Rectangles. ArXiv
e-prints, 2017. arXiv:1704.07580.
3 G. Alexandron, H. Kaplan, and M. Sharir. Kinetic and dynamic data structures for convex
hulls and upper envelopes. Computational Geometry, 36(2):144–1158, 2007.
4 D. Bahrdt, M. Becher, S. Funke, F. Krumpe, A. Nusser, M. Seybold, and S. Storandt.
Growing Balls in Rd. In Proceedings of the 19th Workshop on Algorithm Engineering and
Experiments (ALENEX), pages 247–258. SIAM, 2017.
5 T. H. A. Castermans, B. Speckmann, K. A. B. Verbeek, M. A. Westenberg, A. Betti,
and H. van den Berg. GlamMap: Geovisualization for e-Humanities. In Workshop on
Visualization for the Digital Humanities (Vis4DH), 2016.
6 S. Funke, F. Krumpe, and S. Storandt. Crushing Disks Efficiently. In International Work-
shop on Combinatorial Algorithms (IWOCA), pages 43–54. Springer, 2016.
7 S. Funke and S. Storandt. Parametrized Runtimes for Ball Tournaments. In European
Workshop on Computational Geometry (EuroCG), pages 221–224, 2017.
8 K. Mehlhorn. Data Structures and Algorithms 1: Sorting and Searching. Springer-Verlag,
1984.
9 J. Nievergelt and E. M. Reingold. Binary Search Trees of Bounded Balance. SIAM Journal
on Computing (SICOMP), 2(1):33–43, 1973.

