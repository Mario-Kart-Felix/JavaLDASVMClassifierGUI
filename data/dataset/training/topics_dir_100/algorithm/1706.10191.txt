New Integer Linear Programming Models for the
Vertex Coloring Problem∗
Adalat Jabrayilov1 and Petra Mutzel2
1 Department of Computer Science, TU Dortmund University, Germany
adalat.jabrayilov@cs.tu-dortmund.de
2 Department of Computer Science, TU Dortmund University, Germany
petra.mutzel@cs.tu-dortmund.de
Abstract
The vertex coloring problem asks for the minimum number of colors that can be assigned to
the vertices of a given graph such that for all vertices v the color of v is different from the
color of any of its neighbors. The problem is NP-hard. Here, we introduce new integer linear
programming formulations based on partial orderings. They have the advantage that they are as
simple to work with as the classical assignment formulation, since they can be fed directly into a
standard integer linear programming solver. We evaluate our new models using Gurobi and show
that our new simple approach is a good alternative to the best state-of-the-art approaches for
the vertex coloring problem. In our computational experiments, we compare our formulations
with the classical assignment formulation and the representatives formulation on a large set
of benchmark graphs as well as randomly generated graphs of varying size and density. The
evaluation shows that one of the new models dominates both formulations for sparse graphs,
while the representatives formulation is the best for dense graphs.
1998 ACM Subject Classification G.1.6 Optimization: Integer Programming, G.2.2 Graph The-
ory: Graph algorithms, F.2.2 Nonnumerical Algorithms and Problems: Computations on discrete
structures
Keywords and phrases Graph coloring, vertex coloring problem, integer linear programming
Digital Object Identifier 10.4230/LIPIcs.CVIT.2016.23
1 Introduction
Graph coloring belongs to the classical optimization problems and has been studied for a long
time. We consider the vertex coloring problem in which colors are assigned to the vertices of
a graph such that no two adjacent vertices get the same color and the number of colors is
minimized. The minimum number of colors needed for a given graph is called its chromatic
number and denoted by χ. Computing the chromatic number of a graph is NP-hard [10].
Since the graph coloring problem has many applications, e.g., register allocation, scheduling,
frequency assignment and timetabling, there is a vast amount of literature on this problem
(see, e.g., [20] for a survey). However, in contrast to other classical combinatorial optimization
problems such as the Travelling Salesman Problem, where large instances can be solved to
optimality, this is not true for the vertex coloring problem. So far only relatively small vertex
coloring instances (up to 100 vertices) can be solved consistently to provable optimality by
exact algorithms.
∗ This work was partially supported by the German Research Foundation, RTG 1855.
© Adalat Jabrayilov and Petra Mutzel;
licensed under Creative Commons License CC-BY
42nd Conference on Very Important Topics (CVIT 2016).
Editors: John Q. Open and Joan R. Acces; Article No. 23; pp. 23:1–23:12
Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany
ar
X
iv
:1
70
6.
10
19
1v
1 
 [
cs
.C
G
] 
 3
0 
Ju
n 
20
17
23:2 New ILP Models for Vertex Coloring
There are three main directions followed by exact algorithms, two of which are based on
integer linear programming (ILP) formulations for the problem. The natural formulation
introduces binary variables that assign colors to vertices. A vertex v in the graph (V,E)
is assigned color i iff the corresponding binary variable xvi gets value 1. This assignment
formulation has the advantage that it is simple and easy to use. Since the number of variables
and constraints of this ILP model is only of quadratic size in |V |, it can be fed directly into
a (commercial) integer linear programming solver such as SCIP [1], LP_Solve [18], Cplex,
or Gurobi. Due to the inherent symmetry in the model (the colors are not distinguishable)
only small instances can be solved to optimality. However, additional constraints can be
added by which the symmetry can be reduced. The second approach has been suggested
by Mehrotra and Trick [21] and is based on the observation that each color class defines
an independent set (no two vertices in the set are adjacent) in the graph. The variables
correspond to independent sets and the ILP model searches for the minimum number of
these independent sets that cover the graph. Since the number of independent sets can be of
exponential size, the solution approach is based on column generation. Solution algorithms
based on this Set Covering Formulation are of complex nature. Mehrotra and Trick [21]
suggest a branch-and-price algorithm for solving the ILP model. Both formulations have been
studied and improved by additional ideas in the literature leading to complex branch-and-cut
algorithms using additional classes of constraints, special branching schemes, separation
procedures, and special procedures for providing good upper bounds. The computational
studies in the literature show that none of the ILP models dominates the other one.
ILP formulations based on partial orderings have shown to be practically successful in
the area of graph drawing [15]. Here, we suggest a new ILP formulation based on partial
orderings for the vertex coloring problem. It has the advantage that it is as simple to work
with as the natural assignment formulation, since it is of polynomial size and can be fed
directly into a standard integer linear programming solver. We further suggest a hybrid ILP
formulation which combines the advantages of the assignment formulation with those of the
partial ordering model.
We evaluate our new models using the ILP solver Gurobi and show that our new simple
approaches dominate the assignment formulation on the tested benchmark sets and are a
good alternative to the best state-of-the-art approaches for the vertex coloring problem.
Furthermore, we are able to solve some of the benchmark instances in the literature for
the first time to proven optimality. We also present the first experimental comparison with
the representatives formulation which has been suggested by Campelo et al. [5, 6]. Since
it introduces variables for every pair of non-adjacent vertices, this formulation seems to be
advantageous for dense graphs. Our computational results support this observation.
2 State-of-the-Art
Eppstein [9] has shown that it is possible to solve the vertex coloring problem by enumerating
all maximal independent sets in the graph in time O((4/3 + 34/3/4)|V |) which is about
2.4150|V |. In practice, the successful approaches are much faster than that. There are
three main lines of research concerning exact solution methods for the coloring problem:
branch-and-bound approaches based on enumeration (Section 2.1), the ILP-based assignment
model (Section 2.2), and the ILP-based set covering formulation (Section 2.4). From those,
the assignment model is the simplest one, since it can directly be fed into a standard
ILP-solver. There are also a lot of experimental evaluations of these methods. Altogether
they have not shown a superiority of one of the three lines of research. Another simple
A. Jabrayilov and P. Mutzel 23:3
ILP formulation is the so-called representatives ILP model (see Section 2.3). It seems that
there is no experimental evaluation concerning this model. In the following we describe
the state-of-the-art concerning these exact approaches. In the literature there also exist
alternative ILP models and alternative approaches (e.g., based on Constraint Programming
[12]). However, the aim of this work is to concentrate on simple ILP formulations that are
competitive with the best state-of-the-art approaches. There is also a vast literature on
heuristic approaches. For a detailed overview of heuristic and exact approaches, see the
survey by Malaguti and Toth [20] and Burke et al. [4].
2.1 Branch-and-bound based approaches
The first line is based on branch-and-bound. Brown [3] suggested a backtracking algorithm
that colors the vertices iteratively. He developes some methods in order to reduce redundant
partial solutions. Brélaz [2] has further developed the ideas of the Randall-Brown algorithm.
He suggested a heuristic based on the saturation degree of a vertex (the number of different
colors to which a vertex is adjacent in a partially colored graph). His heuristic, called Dsatur
algorithm, is exact for bipartite graphs. For solving the VCP for general graphs, he suggested
to start with an initial coloring of a large clique and a preprocessing step of using his Dsatur
heuristic. This approach is called DSATUR-based branch-and-bound in the literature or in
short DSATUR. Sewell [25] has further improved the approach by introducing a new tie
breaking strategy. Recently, Segundo [24] has suggested to apply this strategy only selectively
thus improving the overall performance. He studied the behaviour of his new algorithm
PASS on a subset of the DIMACS color benchmark and random graphs.
2.2 Assignment-based ILP model
The classical ILP model for a graph G = (V,E) is based on assigning color i to vertex v ∈ V .
For this, it introduces assignment variables xvi for each vertex v and color i (i = 1, . . . ,H),
with xvi = 1 if vertex v is assigned to color i and xvi = 0 otherwise. H is an upper bound of
the number of colors (e.g., the result of a heuristic) and is at most |V |. For modelling the
objective function, additional binary variables wi are needed which get value 1 if and only if
color i is used in the coloring (i = 1, . . . ,H). The model is given by:
(ASS-S) min
∑
1≤i≤H wi (1)
s.t.
∑H
i=1 xvi = 1 ∀v ∈ V (2)
xui + xvi ≤ wi ∀(u, v) ∈ E, i = 1, . . . ,H (3)
xvi, wi ∈ {0, 1} ∀v ∈ V, i = 1, . . . ,H (4)
The objective function minimizes the number of used colors. Equation (2) ensures that
each vertex receives exactly one color. For each edge there is a constraint (3) making sure
that adjacent vertices receive different colors. This model has the advantage that it is simple
and easy to use. It can be easily extended to generalizations and/or restricted variants of
the graph coloring problem. Since the number of variables is only quadratic in the input
size (it is bounded by H(|V | + 1)) and the number of constraints is quadratic (exactly
|V |+H|E| = O(|V ||E|) constraints of type 2 and 3), it can directly be used as input for a
standard ILP solver.
Malaguti and Toth mention two drawbacks of this model. The first one is the inherent
symmetry in the ILP model, since there are
(
H
χ
)
possibilities to select χ from H colors thus
leading to exponentially (in the number of colors) many equivalent solutions. Moreover,
CVIT 2016
23:4 New ILP Models for Vertex Coloring
the continuous LP-relaxation is extremely weak, since it has a feasible solution of value 2
independent of the graph. It is possible to set the values of all vertices v ∈ V as follows:
xv1 = xv2 = 0.5 and xvj = 0 for j = 3, . . . ,H, and w1 = w2 = 1 and all other wi = 0.
In order to overcome the symmetry problem with the (ASS-S) model, Mendez-Diaz and
Zabala [22, 23] suggest to add the following additional set of constraints:
wi ≤
∑
v∈V
xvi i = 1, . . . ,H (5)
wi ≤ wi−1 i = 2, . . . ,H (6)
These constraints ensure that the color i is only assigned to some vertex, if color i − 1 is
already assigned to another one. We call the extended model (ASS):
(ASS) min
∑
1≤i≤H wi
s.t. (2)− (6)
Moreover, they present several sets of constraints that arose from their studies of the polytope.
In order to solve the new strengthened ILP model, they developed a branch-and-cut algorithm.
2.3 Representatives ILP model
A vertex coloring divides the vertices into disjoint color classes. Campelo et al. [5, 6]
suggested a model in which each color class is represented by exactly one vertex. For this,
they suggest to introduce a binary variable xuv for each non-adjacent pair of vertices u, v ∈ V
which is 1 if and only if the color of v is represented by u. Additional binary variables xu,u
indicate if u is the representative of its color class. Let N̄(u) be the set of all vertices not
adjacent to vertex u. The constraints are as follows:
(REP) min
∑
u∈V xuu (7)∑
u∈N̄(v)∪v xuv ≥ 1 ∀v ∈ V (8)
xuv + xuw ≤ xuu ∀u ∈ V, ∀e = (v, w) ∈ G[N̄(u)] (9)
xuv ∈ {0, 1} ∀ non-adjacent vertex pairs u, v or u = v (10)
Inequality (8) requires that for any vertex v ∈ V , there must exist a color representative
which can be v itself or is in N̄(v). Inequality (9) states that a vertex u cannot be the
representative for both endpoints of an edge (v, w) and that in the case that xuv = 1 (u
is the representative of vertex v) also the variable xuu must be 1. The advantage of this
model is its simplicity and its compactness. It has exactly |Ē| + |V | variables and up to
|V |+ |V ||E| many constraints, where Ē is the set of non-adjacent vertex pairs of G = (V,E):
Ē = (V × V ) \ E. With growing density of the graphs, the number of constraints increases
but the number of variables decreases and converges towards |V |.
In [6], Campelo et al. mention that the symmetry in this model may lead to problems
with branch-and-bound based solvers. The reason for this lies in the fact that within a
color class any of the vertices in this class can be the representative. In order to circumvent
this, the authors define an ordering on the vertices and require that in each color class
only the vertex with the smallest number is allowed to be the representative of this class.
However, the ILP model arising from this requirement, called the asymmetric representatives
formulation, has up to exponentially many constraints. So this model is no more simple to
use. The authors [6] study the polytopes associated with both representative formulations.
They suggest to add constraints based on cliques, odd-holes, and anti-holes, and wheels, and
A. Jabrayilov and P. Mutzel 23:5
independent sets in order to strengthen the model. Moreover, they provide a comparison
with the set covering based formulation (see Section 2.4). In [7], Campos et al. study the
asymmetric representatives formulation and the corresponding polytope. Their results lead
to complete characterizations of the associated polytopes for some specific graph classes. Up
to our knowledge, no computational experiments have been published in the literature.
2.4 Set covering based ILP model
Mehrotra and Trick [21] suggested the set-covering formulation which is based on the
observation that the vertices receiving the same colors build an independent set. A set
of vertices is called independent set if no two of its vertices are adjacent. The aim of the
formulation is to cover the vertices of the graph with the minimum number of independent
sets. Let S a family of independent sets of the given graph G = (V,E). The ILP model uses
a binary variable xs for each independent set s ∈ S, with xs = 1 iff the independent set s is
part of the cover.
(COV) min
∑
s∈S xs (11)
s.t.
∑
s∈S:v∈s xs ≥ 1 ∀v ∈ V (12)
xs ∈ {0, 1} ∀s ∈ S (13)
The objective function minimizes the number of independent sets used for covering the
vertices. Constraint (12) ensures that each vertex is covered by at least one independent
set. Since the number of variables in this model can be of exponential size, this formulation
cannot be fed directly into a standard ILP-solver like SCIP, LP_Solve, Gurobi or CPLEX.
Mehrotra and Trick have suggested a branch-and-price algorithm for solving the model
which starts with a small number of variables and adds additional ones using a column
generation approach. Malaguti et al. [19] have provided further details such as metaheuristic
algorithms for initialization and column generation as well as new branching schemes. Held
et al. [14] have suggested new techniques in order to improve the numerical stability of the
branch-and-price method. A very similar formulation, the Set Packing formulation, has been
suggested by Hansen et al. [13]. Theoretical and empirical results show that both models
have a similar behavior.
3 Partial-Ordering Based ILP Models
3.1 A pure partial-ordering based ILP model: POP
Our new binary model considers the vertex coloring problem as partial ordering problem
(POP). We assume that the H colors (1, . . . ,H) are linearly ordered. Instead of directly
assigning a color to the vertices, we determine a partial order of the union of the vertex set
and the set of ordered colors. For this, we determine the relative order of each vertex with
respect to each color in the color ordering. More specific: for every color i and every vertex
v ∈ V our variables provide the information if v is smaller or larger than i. We denote these
relations by v ≺ i or v  i, resp. In other words, the colors and the vertices build a partially
ordered set in which all pairs of the form (v, i) with v ∈ V, i = 1, . . . ,H are comparable. We
CVIT 2016
23:6 New ILP Models for Vertex Coloring
define the following POP variables:
∀v ∈ V, i = 1, . . . ,H : yi,v =
{
1 v  i
0 otherwise.
∀v ∈ V, i = 1, . . . ,H : zv,i =
{
1 v ≺ i
0 otherwise.
If vertex v has been assigned to color i, then v is neither smaller nor larger than i and we
have yi,v = zv,i = 0. The connection with the assignment variables x from the (ASS) model
is as follows:
xvi = 1− (yi,v + zv,i) ∀v ∈ V, i = 1, . . . ,H (14)
We select an arbitrary vertex q ∈ V to represent the chromatic number of the graph and
formulate our new binary program as follows:
(POP) min 1 +
∑
1≤i≤H yi,q (15)
s.t. zv,1 = 0 ∀v ∈ V (16)
yH,v = 0 ∀v ∈ V (17)
yi,v − yi+1,v ≥ 0 ∀v ∈ V, i = 1, . . . ,H − 1 (18)
yi,v + zv,i+1 = 1 ∀v ∈ V, i = 1, . . . ,H − 1 (19)
yi,u + zu,i + yi,v + zv,i ≥ 1 ∀(u, v) ∈ E, i = 1, . . . ,H (20)
yi,q − yi,v ≥ 0 ∀v ∈ V, i = 1, . . . ,H − 1 (21)
yi,v, zv,i ∈ {0, 1} ∀v ∈ V, i = 1, . . . ,H (22)
I Lemma 1. The integer linear programming formulation (POP) described above is correct:
Any feasible solution of the ILP corresponds to a feasible vertex coloring and the value of the
objective function corresponds to the chromatic number of G.
Proof. All original vertices need to be embedded between the colors 1 and H. Constraints
(16) and (17) take care of this. By transitivity, a vertex that is larger than color i + 1 is
also larger than i (constraints (18)). Constraint (19) expresses that each vertex v is either
larger than i (i.e. yi,v = 1) or smaller than i+ 1 and not both. These constraints jointly with
constraints (18) ensure that each vertex will be assigned to exactly one color, i.e. there is no
color pair i 6= j with yi,v = zv,i = 0 and yj,v = zv,j = 0. We show this by contradiction. Let
yi,v = zv,i = 0. In the case that j < i, because of zv,i = 0 we have yj,v = 1 for each j < i by
(19) which is a contradiction to yj,v = 0. In the case that j > i, because of yi,v = 0 we have
yk,v = 0 for each k ≥ i by (18). Therefore we have zv,k+1 = 1 by (19) leading to zv,j = 1 for
each j ≥ i+ 1, which is a contradiction to zv,j = 0. Constraint (20) prevents assigning the
same color i to two adjacent vertices u and v. Constraint (21) takes care of the fact that
our chosen vertex q will be assigned to the largest chosen color. So if q is not larger than
color i then this will be true for all other vertices v ∈ V \ {q}. Because of this constraint,
the objective function indeed minimizes the number of assigned colors since it sums up the
number of colors smaller than q. In order to get the number of chosen colors, we need to add
one for the color assigned to q. We say that q represents the chromatic number of G. J
Comparison with the assignment model
(POP) has 2 ·H|V | binary variables and about 4|V |H + 2|V |+ |E| constraints. Note that
the equations (19), (16), and (17) can be used to eliminate (H + 1)|V | variables. Hence the
A. Jabrayilov and P. Mutzel 23:7
reduced model has (H − 1) · |V | variables, while the classical assignment model (ASS) has
H(|V |+ 1) variables.
Mendez-Diaz and Zabala [22] mention that the classical branching rule (to branch on
fractional assignment variables by setting them to 1 in one subproblem and to 0 in another
subproblem) produces quite unbalanced enumeration trees. This is the case because of setting
xv,i = 1 implies xv,j = 0 for all j 6= i, while setting xv,i = 0 does not provide any further
information. The model (POP) does not have this problem, since setting a POP-variable
yi,v = 0 implies yj,v = 0 for all j with j > i and setting yi,v = 1 implies yj,v = 1 for all j
with j < i because of constraint (18).
As already discussed, the original (ASS-S) model has inherent symmetries, which can be
resolved by additional constraints leading to the (ASS) model. In the new (POP) model,
this type of symmetry does not occur.
Similarly as for the (ASS) model, the continuous LP-relaxation of the (POP) model is
extremely weak, since it has a feasible solution of value 1.5 independent of the graph. It is
possible to set the values of all vertices v ∈ V as follows: y1,v = zv,2 = 0.5, and yj,v = 0 and
zv,k = 1 for all other j = 2, . . . ,H and k = 3, . . . ,H.
3.2 A hybrid partial-ordering based ILP model: POP2
Our second ILP formulation is a slight modification of the first model and can be seen as a
hybrid of the models (POP) and (ASS). It is the consequence of the observation that with
growing density the (POP) constraint matrix contains more nonzero elements than the (ASS)
constraint matrix. This is due to the constraints (20), which are responsible for the valid
coloring of adjacent vertices, and contain twice as many coefficients as the corresponding
(ASS) constraints (3).
Therefore, we use equation (14) to substitute (20) by (14) and the following constraints:
xui + xvi ≤ 1 ∀(u, v) ∈ E, i = 1, . . . ,H. (23)
This reduces the number of nonzero values from 4|E|H to 2|E|H + 3|V |H giving a reduction
ratio of about two in dense graphs. Although we added |V |H new assignment variables, the
dimension of the problem remains unchanged, since the new variables directly depend on the
POP-variables by equality (14).
4 Computational Experiments
In our computational experiments we are interested in answering the following questions:
(H1): Do our new partial-order based ILP formulations dominate the classical assignment
ILP model (ASS) on a set of benchmark instances?
(H2): Does one of the two (POP)-based models dominate the other one?
(H3): How do the simple models behave compared to the best state-of-the-art algorithms
on a benchmark set of graphs?
(H4): Does the model (REP) dominate the other approaches on dense instances?
We have computed the simple ILP models (ASS), (POP), (POP2), and (REP) and used
a standard commercial ILP-solver to solve a set of benchmark instances from the literature.
4.1 Algorithms and implementation issues
The preprocessing techniques (a)-(d) are widely used in the literature (e.g., [12, 13, 20, 22,
23, 19]).
CVIT 2016
23:8 New ILP Models for Vertex Coloring
(a) A vertex u is dominated by a vertex v, v 6= u, if the neighborhood of u is a subset of the
neighborhood of v. In this case, the vertex u can be deleted from G, the remaining graph
can be colored, and at the end, u can get the same color as v.
(b) To reduce the number of variables we are interested in getting a small upper bound H
for the number of needed colors.
(c) Since any clique represents a valid lower bound for the vertex coloring problem one can
select a clique and precolor it. This removes some variables, too.
(d) In the case of equal lower und upper bounds we have found the optimal value, hence no
ILP needs to be solved.
We extended (c) as follows:
(e) In (ASS), (POP), and (POP2) we can fix more variables if we try to find the clique Q
with max(|Q|H + |δ(Q)|), where δ(Q) := {(u, v) ∈ E : |{u, v} ∩Q| = 1}. The first term
|Q|H is due to the fact that we can fix H variables for each vertex in Q. After precoloring
all the vertices u ∈ Q, the neighbors v of u cannot receive the same color as u. For
example, if the assignment variable xui = 1 then xvi = 0. Hence we can fix one variable
for each edge (u, v) ∈ δ(Q).
To represent the chromatic number in (POP) and (POP2), we pick any vertex q from the
clique Q found in the preprocessing. The remaining vertices from the clique are precolored
with colors 1, · · · , |Q| − 1.
We have implemented the simple MIP models (ASS), (POP), (POP2), (REP) using the
Gurobi-python API. The source codes are available on our benchmark site [16]. As already
mentioned in subsection 3.1, in our implementation of (POP) and (POP2) we used the
equations (19), (16) (17) and eliminated all z variables.
To compute (b), (c) and (e) we used the python library http://networkx.readthedocs.
io. For (b) we used the function networkx.greedy_color(). To get a clique for (c) und
(e) we applied the randomised function networkx.maximal_independent_set() on the
complement graph, where the complement graph G′ of G has the same vertices as G but
contains an edge (u, v) for each vertex pair u, v iff G does not have this edge. Since this
function is randomised, we iterated it at most 300 · |E||V | times within a maximum time of 60 s
and selected the best one.
4.2 Test setup and benchmark set of graphs
For solving the ILP models, we used the Gurobi version 6.5 single-threadedly. Due to the
large benchmark set the experiments were performed on two computers:
M1 Intel Core i7-4790, 3.6GHz, with 32 GB of memory and running Ubuntu Linux 14.04.
(Benchmarks [8] user time: r500.5=4.14 s)
M2 Intel Xeon E5-2640, 2.60GHz, with 128 GB of memory and running Ubuntu Linux 14.04.
(Benchmarks [8] user time: r500.5=5.54 s)
In the literature, subsets of the DIMACS benchmark sets and randomly generated graphs
have been used. We used two benchmark sets, too. Both benchmark sets as well as our
codes are available at [16]. As first test set we have chosen the hard instances from 119
DIMACS [26] instances according to the Google benchmark site [11]. These 68 graphs have
between 79 and 10 000 vertices and between 156 and 990 000 edges. We compared the partial
ordering based approaches with (ASS) and (REP) on the DIMACS instances on computer
M1. Furthermore, the new approaches are also compared with the state-of-the-art algorithms
[22, 23, 19], which are of complex nature. They used the same DIMACS benchmark set and
A. Jabrayilov and P. Mutzel 23:9
the same preprocessing techniques (a)-(d). Table 1 contains 36 of the 68 instances, which
can be solved by at least one of the considered algorithms.
REP POP POP2 ASS+(c) ASS+(e) [22] [23] [19]
instance |V | |E| class lb ub time lb ub time lb ub time lb ub time lb ub time time time time
1-FullIns_4 93 593 NP-m 5 5 1.85 5 5 0.01 5 5 0.01 5 5 0.01 5 5 0.01 0.1 tl
1-FullIns_5 282 3247 NP-? 5 6 tl 6 6 6.01 6 6 1.54 6 6 1.82 6 6 2.12 tl tl
2-FullIns_4 212 1621 NP-m 6 6 2.14 6 6 0.02 6 6 0.01 6 6 0.01 6 6 0.01 tl 4 tl
2-FullIns_5 852 12201 NP-? 5 7 tl 7 7 5.02 7 7 72.45 7 7 326.61 7 7 14.74 tl tl
3-FullIns_3 80 346 NP-m 6 6 0.01 6 6 0.00 6 6 0.00 6 6 0.00 6 6 0.00 0.1 2.9
3-FullIns_4 405 3524 NP-? 7 7 3.92 7 7 0.03 7 7 0.02 7 7 0.02 7 7 0.03 tl tl
3-FullIns_5 2030 33751 - 7 8 tl 8 8 12.43 8 8 32.90 8 8 3489.97 8 8 27.23 tl tl
4-FullIns_3 114 541 NP-m 7 7 0.01 7 7 0.00 7 7 0.00 7 7 0.00 7 7 0.00 3 3.4
4-FullIns_4 690 6650 NP-? 8 8 4.61 8 8 0.05 8 8 0.02 8 8 0.03 8 8 0.02 tl tl
4-FullIns_5 4146 77305 - 7 9 tl 9 9 9.67 9 9 16.03 8 9 tl 9 9 78.17 tl tl
4-Insertions_3 79 156 NP-m 3 4 tl 4 4 9.62 4 4 15.75 4 4 141.48 4 4 54.04 4204 tl
5-FullIns_3 154 792 NP-m 8 8 0.01 8 8 0.00 8 8 0.00 8 8 0.00 8 8 0.00 20 4.6
5-FullIns_4 1085 11395 NP-? 9 9 12.36 9 9 0.05 9 9 0.05 9 9 0.04 9 9 0.04 tl tl
ash608GPIA 1216 7844 NP-m - - tl 4 4 34.84 4 4 51.63 4 4 575.23 4 4 821.74 692 2814.8
ash958GPIA 1916 12506 NP-m - - tl 4 4 90.11 4 4 105.77 4 6 tl 4 8 tl tl 4236 tl
DSJC125.5 125 3891 NP-h 14 21 tl 11 20 tl 13 22 tl 13 21 tl 13 21 tl tl 18050.8
DSJC125.9 125 6961 NP-h 44 44 1.72 36 50 tl 42 44 tl 42 45 tl 42 45 tl tl 3896.9
DSJR500.1c 500 121275 NP-h 85 85 0.33 - - tl 83 86 tl - - tl - - tl tl 288.5
DSJR500.5 500 58862 NP-h 122 497 tl - - tl 122 122 572.01 122 122 1748.11 - - tl tl 342.2
le450_15a 450 8168 NP-m 15 449 tl 15 16 tl 15 15 598.55 15 15 2439.49 15 15 801.94 tl 0.4
le450_15b 450 8169 NP-? 15 446 tl 15 15 2939.49 15 15 700.50 15 15 1393.29 15 15 1103.29 tl 0.2
le450_15c 450 16680 NP-? -∞ 450 tl - - tl - - tl - - tl 15 25 tl tl 3.1
le450_15d 450 16750 NP-? -∞ 450 tl 15 26 tl 15 26 tl - - tl - - tl tl 3.8
le450_25c 450 17343 NP-? 25 450 tl 25 30 tl 25 31 tl - - tl - - tl tl 1356.6
le450_25d 450 17425 NP-? 25 450 tl 25 30 tl 25 31 tl - - tl - - tl tl 66.6
le450_5a 450 5714 NP-? -∞ 450 tl 5 9 tl 5 5 21.17 5 5 83.65 5 5 52.03 tl 0.3
le450_5b 450 5734 NP-? -∞ 450 tl 5 7 tl 5 5 140.16 5 5 503.29 5 5 168.67 tl 0.2
mug100_1 100 166 NP-m 4 4 1.14 4 4 0.24 4 4 0.09 4 4 0.39 4 4 0.13 60 14.4
mug100_25 100 166 NP-m 4 4 1.10 4 4 0.45 4 4 0.31 4 4 0.31 4 4 0.31 60 12
qg.order40 1600 62400 NP-m - - tl 40 45 tl 40 40 534.83 40 46 tl 40 46 tl tl 2.9
qg.order60 3600 212400 NP-? - - tl - - tl - - tl -∞ 68 tl -∞ 68 tl tl 3.8
queen10_10 100 1470 NP-h 10 12 tl 10 12 tl 10 12 tl 10 12 tl 10 12 tl tl 686.9
queen11_11 121 1980 NP-h 11 13 tl 11 13 tl 11 13 tl 11 13 tl 11 13 tl tl 1865.7
school1_nsh 352 14612 NP-m 14 14 981.45 14 14 22.39 14 14 12.76 14 14 31.23 14 14 28.22 init 17
wap05a 905 43081 NP-m - - tl - - tl 50 50 1308.37 50 50 125.45 - - tl tl 293.2
wap06a 947 43571 NP-? - - tl - - tl - - tl - - tl - - tl tl 175
solved: 13 19 25 22 21 9 +2 25
Table 1 Results of the ILP models for the DIMACS benchmark set
The second benchmark set consists of 340 randomly generated graphs G(n, p), which
have n vertices and an edge between each vertex pair with probability p. These graphs are
evaluated on computer M2. This set consists of two subsets:
set100: This subset contains 100 instances with 70 vertices: 20 instances for each p =
0.1, 0.3, 0.5, 0.7, 0.9.
sparse240: This subset contains 240 instances, i.e. 20 instances for each n = 80, 90, 100 and
for each p = 0.1, 0.15, 0.2, 0.25.
4.3 Experimental evaluation
Table 1 shows the results for hard DIMACS benchmark instances for the ILP models (POP),
(POP2), (ASS), (REP) and the state-of-the-art algorithms [22, 23] and [19]. Columns 1-3
show the instance names and sizes. Column 4 describes the hardness of the instances
according to the Google site [11]. Columns 5–19 display the lower and upper bounds as well
as the running times of the simple models (REP), (POP), (POP2) and (ASS) that have
been obtained within a time limit of one hour. An entry tl indicates that the time limit is
reached. The times are provided in seconds for solving the reduced ILPs after prepocessing.
The preprocessing times were only a few seconds for most instances and not more than one
minute. Columns 5–7 show the results of (REP) with preprocessings (a)–(d). The model
(REP) does not need (b) directly, but indirectly due to (d). Columns 8–19 show appropriate
results for (POP), (POP2) and (ASS). Since (e) can reduce the number of assignment and
CVIT 2016
23:10 New ILP Models for Vertex Coloring
partial ordering variables, we implemented (ASS), (POP) and (POP2) also with (e) instead
of (c). For (POP) and (POP2) it turned out that (e) is better than (c). Due to space
restrictions we present the results corresponding to (e) only. For the (ASS) model we show
the results for both versions (c) and (e). The bold items in the table highlight the running
times of the simple models that are significantly faster compared to the others.
Columns 20 and 21 are obtained from [22, 23] and show the running times of two (ASS)-
based branch-and-cut algorithms suggested by Mendez-Diaz and Zabala. The column 21
([23]) contains only the additional solved instances, i.e. the instances which have not been
solved in [22] (column 20). Column 22 is obtained from [19] and shows the running times of
a (COV)-based branch-and-price algorithm suggested by Malaguti et al. [19]. Notice that
the comparison of running times is not quite fair, since [23] and [19] report the Benchmark
[8] user time for the instance r500.5 as 24 s and 7 s, respectively, while our machine M1
needs 4.14 s. However, [22, 23] and [19] used 2 h and 10 h as time limit respectively, while
we only used 1 h. Nevertheless, it is interesting to see the number of solved instances by
each algorithm. This is displayed in the last row of the table.
We can see that the hybrid model (POP2) and [19] solved the highest number (25 out of
68) instances to provable optimality. Notice that (POP2) used 1 hour as time limit, while
[19] needed more than 5 hours with a machine which is approximatively 1.7 times slower
than M1. The models (ASS)+(c), (ASS)+(e), (POP), (REP) have solved 22, 21, 19, 13
instances respectively, while the algorithms [22, 23] only solved 11 (9+2) instances. A closer
look at the running times shows that those of the (POP) model are often faster than that of
(POP2). However, for denser instances, the running times of the hybrid model are faster.
As indicated in our theoretical analysis of the two models (POP) and (POP2), the hybrid
model dominates the pure model for denser instances. The behaviour of the two different
versions of the (ASS) model shows a larger variation in running times: sometimes one of the
versions is much faster than the others, while on other instances it is much slower.
In order to study the behaviour of the implemented simple models for instances with
varying size and density, we first used the benchmark set100, for which the results are
displayed in Figure 1. Figure 1(a) shows the average runtime for each set G(70, p) for each
density p = 10, 30, 50, 70, 90, while Figure 1(b) shows the number of unsolved instances for
each set. (POP) and (ASS)+(e) were able to solve all instances of densities 10 and 30, where
the average runtime of (POP) is about 2 times shorter than that of (ASS)+(e). From density
50 on, the (POP) model seems to have more problems than the other models. The (ASS)+(c),
(ASS)+(e) and the (POP2) model deliver similar quality with similar running times for the
denser graphs. From density 70 on, the (REP) model clearly dominates all other models,
 0
 300
 600
 900
 1200
 1500
 1800
 2100
 2400
 2700
 3000
 3300
 3600
G(70,10)
G(70,30)
G(70,50)
G(70,70)
G(70,90)
POP
POP2
ASS+(c)
ASS+(e)
REP
(a) Average Execution Time [s]
 0
 5
 10
 15
 20
G(70,10)
G(70,30)
G(70,50)
G(70,70)
G(70,90)
POP
POP2
ASS+(c)
ASS+(e)
REP
(b) Number of unsolved instances
Figure 1 Comparison of the simple models on the benchmark set100
A. Jabrayilov and P. Mutzel 23:11
 0
 300
 600
 900
 1200
 1500
 1800
 2100
 2400
 2700
 3000
 3300
 3600
G(80,10)
G(90,10)
G(100,10)
G(80,15)
G(90,15)
G(100,15)
G(80,20)
G(90,20)
G(100,20)
G(80,25)
G(90,25)
G(100,25)
POP
POP2
ASS+(c)
ASS+(e)
REP
(a) Average Execution Time [s]
 0
 5
 10
 15
 20
G(80,10)
G(90,10)
G(100,10)
G(80,15)
G(90,15)
G(100,15)
G(80,20)
G(90,20)
G(100,20)
G(80,25)
G(90,25)
G(100,25)
POP
POP2
ASS+(c)
ASS+(e)
REP
(b) Number of unsolved instances
Figure 2 Comparison of the simple models on the benchmark sparse240
which was to be expected. Since both partial-ordering based models were the fastest models
on sparse graphs of set100, we decided to evaluate larger sparse graphs and generated the
set sparse240. The corresponding results are shown in Figure 2. For the larger instances, the
partial-ordering based models (POP) and (POP2) dominate the other models (see Fig 2).
The representative model already gets problems with the smallest problem instances in the
set.
Answering our questions from the beginning, we can say the following:
(H1): The hybrid (POP2) formulation is able to solve more DIMACS instances to provable
optimality than the (ASS) model. This is not true for the (POP) model. On the random
graphs the situation is similar: (POP2) clearly dominates (ASS). (POP) only dominates
(ASS) for the larger sparse instances.
(H2): The (POP2) model clearly dominates the original model (POP) on the tested
instances. The explanation lies in the fact discussed in section 3.2. It seems that the
(POP2) model combines the advantages of (POP) which is better for sparse graphs and
(ASS) which is better for dense graphs.
(H3): The simple models are able to solve very hard instances from the DIMACS
benchmark set. A comparison with the computational results of the state-of-the-art
algorithms (such as [21, 13, 17, 25, 19, 14, 20, 24, 23, 22]) shows that the quality of the
suggested algorithms is about the same (also see Table 1). Some of the approaches are
able to solve some of the instances faster, but they are slower on other instances.
(H4): The representatives model does clearly dominate the other models on dense
instances. This can be seen on the denser instances of the DIMACS graphs and on the
series of random graphs with increasing density.
References
1 T. Achterberg, T. Berthold, T. Koch, and K. Wolter. Constraint integer programming: A
new approach to integrate CP and MIP. In Laurent Perron and Michael A. Trick, editors,
CPAIOR 2008, volume 5015 of LNCS, pages 6–20. Springer, Berlin, 2008.
2 D. Brélaz. New methods to color the vertices of a graph. Communications of the ACM,
22(4):251–256, 1979.
3 J. R. Brown. Chromatic scheduling and the chromatic number problem. Management
Science, 19(4-part-1):456–463, 1972.
4 E. K. Burke, J. Mareček, Andrew J. Parkes, and H. Rudová. A supernodal formulation of
vertex colouring with applications in course timetabling. Annals of Operations Research,
179(1):105–130, 2010.
CVIT 2016
23:12 New ILP Models for Vertex Coloring
5 M. B. Campêlo, R. C. Corrêa, and Y. Frota. Cliques, holes and the vertex coloring polytope.
Inf. Process. Lett., 89(4):159–164, 2004. URL: http://dx.doi.org/10.1016/j.ipl.2003.
11.005, doi:10.1016/j.ipl.2003.11.005.
6 Manoel B. Campêlo, Victor A. Campos, and Ricardo C. Corrêa. On the asymmetric
representatives formulation for the vertex coloring problem. Discrete Applied Mathematics,
156(7):1097–1111, 2008.
7 V. Campos, R. C. Corrêa, D. Delle Donne, J. Marenco, and A. Wagler. Polyhedral studies
of vertex coloring problems: The asymmetric representatives formulation. ArXiv e-prints,
August 2015. arXiv:1509.02485.
8 Benchmarking machines and testing solutions, 2002. URL: http://mat.gsia.cmu.edu/
COLOR02/BENCHMARK/benchmark.tar.
9 D. Eppstein. Small maximal independent sets and faster exact graph coloring. Journal of
Graph Algorithms and Applications, 7(2):131–140, 2003.
10 M. R. Garey and D. S. Johnson. Computers and Intractability: A Guide to the Theory of
NP-Completeness. Freeman, San Francisco, CA, USA, 1979.
11 S. Gualandi and M. Chiarandini. Graph coloring instances, 2017. URL: https://sites.
google.com/site/graphcoloring/vertex-coloring.
12 S. Gualandi and F. Malucelli. Exact solution of graph coloring problems via constraint
programming and column generation. INFORMS J. on Computing, 24(1):81–100, 2012.
13 P. Hansen, M. Labbé, and D. Schindl. Set covering and packing formulations of graph
coloring: Algorithms and first polyhedral results. Discrete Optimization, 6(2):135 – 147,
2009.
14 S. Held, W. Cook, and E.C. Sewell. Maximum-weight stable sets and safe lower bounds for
graph coloring. Mathematical Programming Computation, 4(4):363–381, 2012.
15 A. Jabrayilov, S. Mallach, P. Mutzel, U. Rüegg, and R. von Hanxleden. Compact layered
drawings of general directed graphs. In Y. Hu and M. Nöllenburg, editors, Graph Drawing
and Network Visualization, volume 9801 of LNCS, pages 209–221. Springer, 2016.
16 A. Jabrayilov and P. Mutzel, 2017. URL: https://ls11-www.cs.tu-dortmund.de/
mutzel/colorbenchmarks.
17 D. S. Johnson and M. Trick, editors. Cliques, Coloring, and Satisfiability: Second DIMACS
Implementation Challenge, 1993, volume 26 of DIMACS Series in Discrete Mathematics
and Theoretical Computer Science. AMS, Providence, RI, USA, 1996.
18 LPSOLVE. URL: http://lpsolve.sourceforge.net/5.5/.
19 E. Malaguti, M. Monaci, and P. Toth. An exact approach for the vertex coloring problem.
Discrete Optimization, 8(2):174–190, 2011.
20 E. Malaguti and P. Toth. A survey on vertex coloring problems. International Transactions
in Operational Research, 17:1–34, 2010. doi:10.1111/j.1475-3995.2009.00696.x.
21 A. Mehrotra and M. Trick. A column generation approach for graph coloring. INFORMS
Journal On Computing, 8(4):344–354, 1996.
22 I. Méndez-Díaz and P. Zabala. A branch-and-cut algorithm for graph coloring. Discrete
Applied Mathematics, 154(5):826–847, 2006.
23 I. Méndez-Díaz and P. Zabala. A cutting plane algorithm for graph coloring. Discrete
Applied Mathematics, 156(2):159 – 179, 2008.
24 P. San Segundo. A new DSATUR-based algorithm for exact vertex coloring. Computers &
Operations Research, 39(7):1724 – 1733, 2012.
25 E.C. Sewell. An improved algorithm for exact graph coloring. In Johnson and Trick [17],
pages 359–373.
26 M. Trick. DIMACS graph coloring instances, 2002. URL: http://mat.gsia.cmu.edu/
COLOR02/.

