Parameterized Algorithms for Partitioning Graphs
into Highly Connected Clusters
Ivan Bliznets∗ Nikolai Karpov†
June 30, 2017
Abstract
Clustering is a well-known and important problem with numer-
ous applications. The graph-based model is one of the typical cluster
models. In the graph model, clusters are generally defined as cliques.
However, such an approach might be too restrictive as in some applica-
tions, not all objects from the same cluster must be connected. That is
why different types of cliques relaxations often considered as clusters.
In our work, we consider a problem of partitioning graph into clus-
ters and a problem of isolating cluster of a special type where by cluster
we mean highly connected subgraph. Initially, such clusterization was
proposed by Hartuv and Shamir. And their HCS clustering algorithm
was extensively applied in practice. It was used to cluster cDNA finger-
prints, to find complexes in protein-protein interaction data, to group
protein sequences hierarchically into superfamily and family clusters,
to find families of regulatory RNA structures. The HCS algorithm par-
titions graph in highly connected subgraphs. However, it is achieved by
deletion of not necessarily the minimum number of edges. In our work,
we try to minimize the number of edge deletions. We consider prob-
lems from the parameterized point of view where the main parameter
is a number of allowed edge deletions. The presented algorithms signif-
icantly improve previous known running times for the Highly Con-
nected Deletion (improved from O∗
(
81k
)
to O∗
(
3k
)
), Isolated
Highly Connected Subgraph (from O∗(4k) to O∗
(
kO(k
2/3)
)
),
Seeded Highly Connected Edge Deletion (from O∗
(
16k
3/4
)
to
O∗
(
k
√
k
)
) problems. Furthermore, we present a subexponential algo-
rithm for Highly Connected Deletion problem if the number of
clusters is bounded. Overall our work contains three subexponential
algorithms which is unusual as very recently there were known very
few problems admitting subexponential algorithms.
∗St. Petersburg Department of V.A. Steklov Institute of Mathematics of the Russian
Academy of Sciences, Russia,iabliznets@gmail.com.
†St. Petersburg Department of V.A. Steklov Institute of Mathematics of the Russian
Academy of Sciences, Russia,kimaska@gmail.com.
1
ar
X
iv
:1
70
6.
09
48
7v
1 
 [
cs
.D
S]
  2
8 
Ju
n 
20
17
1 Introduction
Clustering is a problem of grouping objects such that objects in one group are
more similar to each other than to objects in other groups. Clustering has
numerous applications, including: machine learning, pattern recognition,
image analysis, information retrieval, bioinformatics, data compression, and
computer graphics. Graph-based model is one of the typical cluster mod-
els. In a graph-based model most commonly cluster is defined as a clique.
However, in many applications, such definition of a cluster is too restric-
tive [17]. Moreover, clique model generally leads to computationally hard
problems. For example clique problem is W [1] − hard while s-club prob-
lem, with s ≥ 2, is fixed-parameter tractable with respect to the parameters
solution size and s [19]. Because of the two mentioned reasons researchers
consider different clique relaxation models [17, 20]. We mention just some
of the possible relaxations: s-club(the diameter is less than of equal to s),
s-plex (the smallest degree is at least |G| − s), s-defective clique (missing s
edges to complete graph), γ-quasi-clique (|E|/
(|V |
2
)
≥ γ), highly connected
graphs (smallest degree bigger than |G|/2) and others. With different degree
of details all these relaxations were studied: s-club[19, 20], s-plex [14, 1],
s-defective clique [21, 7], γ-quasi-clique [18, 16], highly connected graphs
[12, 11, 9].
In this work, we study the clustering problem based on highly connected
components model. A graph is highly connected if the edge connectivity
of a graph(the minimum number of edges whose deletion results in a dis-
connected graph) is bigger than n2 where n is the number of vertices in a
graph. An equivalent characterization is for each vertex has degree bigger
than n2 , it was proved in [3]. One of the reasons for this choice is a huge
success in applications of the Highly Connected Subgraphs(HCS) clustering
algorithm proposed by Hartuv and Shamir and the second reason is the
lack of research for this model compared with the standard clique model.
HCS algorithm was used [11] to cluster cDNA fingerprints [8], to find com-
plexes in protein-protein interaction data [10], to group protein sequences
hierarchically into superfamily and family clusters [13], to find families of
regulatory RNA structures [15].
Hüffner et al. [11] noted that while Hartuv and Shamirs algorithm par-
titions a graph into highly connected components, it does not delete the
minimum number of edges required for such partitioning. That is why they
initiated study of the following problem
Highly Connected Deletion
Instance: Graph G = (V,E).
Task: Find edge subset E′ ⊆ E of the minimum size such that each
connected component of G′ = (V,E \ E′) is highly connected.
For this problem, Hüffner et al. [11] proposed an algorithm which is based
2
on the dynamic programming technique with the running time bounded by
O∗(3n) where n is the number of vertices. For parameterized version of
the problem they proposed an algorithm with the running time O∗(81k)
where k is an upper bound on the size of E′. Additionally, they proved that
the problem admits a kernel with the size O(k1.5). Moreover, they proved
conditional lower bound on the running time of algorithms for Highly Con-
nected Deletion , in particular, the problem cannot be solved in time
2o(k)·nO(1), 2o(n)·nO(1) , or 2o(m)·nO(1) unless the exponential-time hypothesis
(ETH) fails.
Moreover, in another work Hüffner et al. [12] studied a parameterized
complexity of related problem of finding highly connected components in a
graph.
Isolated Highly Connected Subgraph
Instance: Graph G = (V,E), integer k, integer s.
Task: Is there a set of vertices S such that |S| = s, G[S] is highly
connected graph and |E(S, V \ S)| ≤ k.
Seeded Highly Connected Edge Deletion
Instance: Graph G = (V,E), subset S ⊆ V , integer a, integer k.
Task: Is there a subset of edges E′ ⊆ E of size at most k such that G−
E′ contains only isolated vertices and one highly connected component
C with S ⊆ V (C) and |V (C)| = |S|+ a.
They proposed algorithms with the running time O∗(4k) and O∗(16k
3/4
)
respectively.
Our results: We propose algorithms which significantly improve previ-
ous upper bounds. Running times of algorithms may be found in a Table 1.
We would like to note that three of the algorithms have subexponential
running time which is not common. Until very recently there were very few
problems admitting subexponential running time. To our mind in algorithm
for Isolated Highly Connected Subgraph problem we have an unusual
branching procedure as in one branch parameter is not decreasing. How-
ever, the value of subsequent decrementation of parameter in this branch is
increasing which leads to subexponential running time. We find the fact in-
teresting as we have not met such behavior of branching procedures before.
Presented analysis for this case might be useful in further development of
subexponential algorithms.
2 Algorithms for partitioning
2.1 Highly Connected Deletion
In this section we present an algorithm for Highly Connected Dele-
tion problem. Our algorithm is based on the fast subset convolution. Let
f, g : 2X → {0, 1, . . .M} be two functions and |X| = n. Björklund et al. in
3
Problem Previous result Our result
Highly Connected Deletion (exact) O∗ (3n) O∗ (2n)
Highly Connected Deletion (parameterized) O∗
(
81k
)
O∗
(
3k
)
p-Highly Connected Deletion - O∗
(
2O(
√
pk)
)
Isolated Highly Connected Subgraph O∗(4k) O∗
(
kO(k
2/3)
)
Seeded Highly Connected Edge Deletion O∗
(
16k
3/4
)
O∗
(
k
√
k
)
Table 1: Results
[2] proved that function f ∗ g : 2X → {0, . . . , 2M}, where (f ∗ g)(S) =
min
T⊆S
(f(T ) + g(S \ T )), can be computed on all subsets S ⊆ X in time
O(2npoly(n,M)).
Theorem 1. There is a O∗(2n) time algorithm for Highly Connected
Deletion problem.
Proof. Let define function f in the following way
f(S) =
{
|E(S, V \ S)| if G[S] is highly connected
∞ otherwise
Consider function f∗k(V ) = f ∗ · · · ∗ f︸ ︷︷ ︸
k times
. Note that f∗k(V ) = min
S1t···tSk=V
(f(S1) + · · ·+ f(Sk)).
Hence, to solve the problem it is enough to find minimum of f∗k(V ) over all
1 ≤ k ≤ n. Note that if f∗k(V ) = ∞ then it is not possible to partition V
into k highly connected components. So if the minimum value of f∗k(V ) is
∞ then there is no partitioning of G into highly connected components.
Our algorithm contains the following steps.
1. Compute f , i.e. compute value f(S) for all S ⊂ V . It takes O(2n(n+
m)) time.
2. Using Björklund et al.[2] algorithm iteratively compute f∗i for all 1 ≤
i ≤ n.
3. Find k such that f∗k(V ) is minimal.
After we perform above steps we will know values of functions f∗i on
each subset S ⊆ X. Let S1 tS2 t · · · tSk be an optimum partitioning of X
into highly connected components. Knowing values of function f∗k−1 and f
it is straightforward to restore Sk in time 2
n. Moreover, knowing f∗k−1, Sk
we can find value of Sk−1. Proceeding this way we obtain the optimum
partitioning. As k ≤ n, we spent at most O(n2n) time to find all Si.
4
It is left to show how to compute all f∗i within O∗(2n) time. The only
obstacle why we cannot straightforwardly apply Björklund’s algorithm is
that f sometimes takes infinite value. It is easy to fix the problem by
replacing infinity value with 2m+1. We know that each convolution require
O(2npoly(n,M)) time and above we show that we can put M to be equal
2m+ 1. As we need to perform n subset convolutions. So, the running time
of second step is O∗(2n). Hence, the overall running time is O∗(2n).
Now we consider parameterized version of Highly Connected Dele-
tion problem (one is asked whether it is possible to delete at most k edges
and get a vertex disjoint union of highly connected subgraphs).
Theorem 2. There is an algorithm for Highly Connected Deletion
problem with running time O∗(3k).
Proof. Before we proceed with the proof of the theorem we list several sim-
plification rules and lemmas proved by Hüffner et al. in [11].
Rule 1. If G contains a connected component C which is highly connected
then replace original instance with instance (G[V \ V (C)], k).
Lemma 1. Let G be a highly connected graph and u, v ∈ V (G) be two
different vertices from V (G). If uv ∈ E, then |N(u)∩N(v)| ≥ 1. If uv 6∈ E
then |N(u) ∩N(v)| ≥ 3.
Rule 2. If u, v ∈ E and N(u)∩N(v) = ∅ then delete edge uv and decrease
parameter k by 1. The obtained instance is ((V,E \ {uv}), k − 1).
Definition 1. Let us call vertices u, v k-connected if any cut separating
these two vertices has size bigger than k.
Rule 3. Let S be an inclusion maximal set of pairwise k-connected vertices
and |S| > 2k. If the induced graph G[S] is not highly connected then our
instance is a NO-instance(it is not possible to delete k edges and obtain
vertex disjoint union of higly connected subgraphs). Otherwise, we replace
original instance with an instance (G[V \ S], k − |E(S, V \ S)|).
Lemma 2. If G is highly connected then diam(G) ≤ 2.
It was shown in [11] that all of the above rules are applicable in polyno-
mial time.
Without loss of generality assume that G is connected. Otherwise, we
consider several independent problems. One problem for each connected
component. For each connected component we find minimum number of
edges that we have to delete in order to partition this component into highly
connected subgraphs. Note that in order to find a minimum number for each
subproblem we simply consider all possible values of parameter starting from
0 to k.
5
From Lemma 2 follows that if dist(u, v) (distance between two vertices
u, v) is bigger than 2 then in optimal partitioning u and v belong to different
connected components. Hence, if dist(u, v) ≥ 3 then at least one edge from
the shortest path between u and v belongs to E′. If diam(G) > 2 then
it is possible to find two vertices u, v such that dist(u, v) = 3. So given
the shortest path u, x, y, v we can branch to three instances (G \ ux, k − 1),
(G\xy, k−1), (G\yv, k−1). We apply such branching exhaustively. Finally,
we obtain instance with a graph G′ of diameter 2.
Now, for our algorithm it is enough to consider a case when graph G
has the following properties: (i) diam(G) ≤ 2; (ii) there are no subsets S of
pairwise k-connected vertices with |S| > 2k; (iii) G is not highly connected.
From now on we assume that G has above mentioned properties. Sup-
pose C1tC2t· · ·tC` is an optimum partitioning of G into highly connected
graphs and E′ is a subset of removed edges. We call vertex affected if it is
incident with an edge from E′. Otherwise, it is unaffected. Denote by U the
set of all unaffected vertices and by T the set of all affected vertices. By
C(v) we denote a cluster Ci for which v ∈ Ci. Note that for affected vertex
u there is vertex v such that uv ∈ E(G) and v /∈ C(u).
Lemma 3. Let G be a graph with diameter 2 then for any optimum parti-
tioning C1 t C2 t · · · t C` of G into highly connected graphs there is an i
such that U is contained in Ci.
Proof. Assume that there are two unaffected vertices u, v ∈ U and C(v) 6=
C(u). Note that any path between u and v must contain an edge from E′
and two different edges contained in C(u), C(v) and incident to u and v
correspondingly. So, the shortest path between u and v contains at least
three edges which contradict our assumption that diam(G) ≤ 2. Hence,
there is an i such that U ⊆ Ci.
Lemma 4. Let G be a graph with diameter 2 and optimum partitioning
C1 t C2 t · · · t C` into highly connected graphs. If U is not empty then
|E′| ≥ n− |Ci| where U ⊆ Ci.
Proof. Consider an arbitrary unaffected vertex u. For any v ∈ V we have
dist(v, u) ≤ 2. Hence, for any v /∈ C(u) there is an edge connecting com-
ponent C(u) with vertex v as otherwise we have dist(u, v) > 2. So we have
|E′| ≥ n− |C(u)|.
For any YES-instance we have k ≥ |E′| ≥ |T |2 , n = |T | + |U |, and
|U | ≤ 2k.The inequality |U | ≤ 2k follows from the simplification Rule 3
and Lemma 3. As otherwise highly connected component which contains U
is bigger than 2k and hence simplification Rule 3 can be applied which leads
to contradiction. So, it means that n = |T |+ |U | ≤ 4k.
6
Below we present two algorithms. One of these algorithms solves the
problem under assumption that optimum partitioning contains at least one
unaffected vertex, the other one solves the problem under assumption that
all vertices are affected in optimum partitioning. In order to estimate run-
ning time of the algorithms we use the following lemma.
Lemma 5. [5] For any non-negative integer a, b we have
(
a+b
b
)
≤ 22
√
ab.
At first, consider a case when there is at least one unaffected vertex in
optimum partitioning.
Lemma 6. Let G be a connected graph with diameter at most 2. If there is
an optimum partitioning C1tC2t· · ·tC` of G into highly connected graphs
such that set of unaffected vertices is not empty then Highly Connected
Deletion can be solved in O∗(2
3k
2 ) time.
Proof. Let us fix some unaffected vertex u (in algorithm we simply brute-
force all n possible values for unaffected vertex u). By Lemma 4 highly
connected graph C(u) contains at least n − k vertices. As u is unaffected
then N(u) ⊂ C(u) and |N(u)| > |C(u)|2 . Consider set V \N [u]. And partition
it into two subsets W1,2 tW≥3, where W1,2 = {v|1 ≤ |N(u) ∩ N(v)| ≤ 2},
and W≥3 = {v|3 ≤ |N(u) ∩ N(v)|}. From lemma 1 follows that W1,2 ∩
C(u) = ∅. Note that knowing set Cpart = C(u) ∩ W≥3 we can find set
C(u) = Cpart ∪ N [u] and after this simply run algorithm from Theorem 1
on set V (G) \ C(u). We implement this approach.
We know that N [u] t Cpart = C(u) and C(u) ≤ 2k. As |Cpart| ≤ C(u)2 it
follows that |Cpart| ≤ k. Brute-force over all possible values of s = |Cpart|.
Having fixed value of s we enumerate all subsets of W≥3 of size s. All such
subsets are potential candidates for a Cpart role. It is possible to enumerate
candidates with polynomial delay i.e. in O∗(
( |W≥3|
|Cpart|
)
) time.
For each listed candidate we run algorithm from Theorem 1. Let R =
W≥3 \ Cpart. Hence, the overall running time for a fixed |Cpart| is bounded
by O∗(2|R∪W1,2|)
( |W≥3|
|Cpart|
)
= O∗(2|R∪W1,2|)
(|Cpart|+|R|
|Cpart|
)
. By Lemma 5 we have:
O∗(2|R∪W1,2|)
(|Cpart|+|R|
|Cpart|
)
= O∗(22
√
|Cpart||R|+|R|+|W1,2|).
We know that |Cpart| ≤ k, 3|R|+|W1,2| ≤ k, henceO∗(22
√
|Cpart||R|+|R|+|W1,2|) ≤
O∗(22
√
k|R|−2|R|+k). The function g(t) = 2
√
kt− 2t+ k attains it maximum
when t = k4 . So the running time in the worst case is O
∗(21.5k).
The following Algorithm 1 illustrates the proof of last Lemma.
It is left to construct an algorithm for a case in which all vertices are
affected in optimum partitioning. First of all note that if n ≤ 1.57k ≤
k log2 3 we can simply run Algorithm 1 and it finds an answer in O
∗(2n) =
O∗(3k) time. Taking into account that all vertices are affected we have that
n ≤ 2k. So we may assume that 1.57k ≤ n ≤ 2k.
7
Algorithm 1
function UNAFFECTED(G = (V,E), k)
for u ∈ V do
W1,2 = {v|v ∈ V \N [u], |N(v) ∩N(u)| ≤ 2}
W≥3 = {v|v ∈ V \N [s], |N(v) ∩N(u)| ≥ 3}
for s : s < |N(u)| & s ≤ k & 3(|W≥3| − s) + |W1,2| ≤ k do
for Cpart ⊆W≥3 & |Cpart| = s do
Q = N [u] ∪ Cpart
if G[Q] is highly connected then
if EXACT (G[V \Q], k − |E(Q,V \Q)|) then
return YES
return NO
Lemma 7. Let G be a graph with diameter 2 and |V (G)| ≥ 1.57k. Moreover,
(G, k) Highly Connected Deletion problem admits correct partitioning
into highly connected components C1tC2t· · ·tC` such that all vertices are
affected in this partitioning. Then there are two highly connected components
Ci, Cj such that |Ci|+ |Cj | ≥ n− k.
Proof. Let E′ be set of deleted edges for partitioning C1 t C2 t · · · t C`.
From n ≥ 1.57k follows that in graph (V (G), E′) there is a vertex s of
degree 1, let st ∈ E′ be the edge. We prove that C(s), C(t) are desired
highly connected components. As diam(G) ≤ 2 then for any vertex v ∈
V (G) \C(s) \C(t) there is path of length at most 2 from s to v. Hence, any
vertex v ∈ V (G)\C(s)\C(t) should be connected with C(s)∪C(t) in graph
G. As |E′| ≤ k then V (G)\(C(s)∪C(t)) ≤ k. So |C(s)|+ |C(t)| ≥ n−k.
Now we brute-force all vertices as candidates for a role of vertex s, i.e.
vertex of degree 1 in solution E′. Consider two possibilities either |C(s)| >
2n− 3.14k or |C(s)| ≤ 2n− 3.14k.
Consider the first case, if |C(s)| > 2n − 3.14k, then we find solution in
O∗(2n−
|C(s)|
2 ) = O∗(3k) time. In order to do this we consider degG(s) cases.
Each case correspond to a different edge st incident with s. Such an edge we
treat as the only edge incident with s from E′. Having fixed an edge st being
from E′ we know that all other edges incident with s belong to E(C(s)).
Denote the set of endpoints of these edges to be U . So we can identify at
least |C(s)|2 vertices from C(s). Now we can apply the same technique as in
proof of Theorem 1.
We define three functions f, g, h over subsets of W = V \ U .
• f(S) = |E(S,W \ S)| if G[S] is highly connected, otherwise it is equal
to ∞.
• h(S) = min
i
(f∗i(S)).
8
• g(S) = 2|E(W \S,U)|+ |E(S,W \S)| if G[U ∪ S] is highly connected
otherwise it is ∞.
Let us provide some intuition standing behind the formulas. Value f(S)
indicate number of vertices that we have to delete in order to separate highly
connected graph G[S]. h(S) is a number of edges needed to be deleted in
order to separateG[S] into highly connected components. g(S) in some sense
is a number of edge deletion needed to create a highly connected component
U ∪ S which contains vertex s. We show that to solve the problem it is
enough to compute (g ∗ h)(W ). In similar way to Theorem 1 (g ∗ h)(W )/2
equals to a number of optimum edge deletions. Note that all deleted edges
not having endpoints in C(s) will be calculated two times, one for each of
its incident highly connected component, see definition of function h. Each
edge of E′ having an endpoint in U is counted twice in first term of function
g. And finally each edge from E′ having endpoint in C(s) \ U is counted
twice, once in second term of the formula of g, and once in the formula of
h. So (g ∗ h)(W )/2 is required number of edge deletions.
Second case, if |C(s)| ≤ 2n − 3.14k then n − k ≤ |C(s)| + |C(t)| ≤
2n− 3.14k + |C(t)|.
It follows that |C(t)|+ 2n− 3.14k ≥ n− k. Hence, C(t) ≥ 2.14k − n ≥
0.14k. It means that in C(t) there is a vertex of degree at most 7 in graph
(V (G), E′). We brute-force all candidates for such vertex and for such edges
from E′. Having fixed the candidates, vertex t′ and at most seven edges,
we identify more than a half vertices from C(t′) = C(t) in the following
way. All edges incident to t′ except just fixed set of candidates belong to
C(t). Denote the endpoints of these edges as Ut. In the same way, all
edges incident with s except st belong to C(s). Denote by Us endpoints of
edges incident with s except the edge st ∈ E′. Let U = Us ∪ Ut. Below
we show how to solve obtained problem in O∗
(
2n−
1
2
(|C(s)|+|C(t)|)
)
time. As
in previous case we apply idea similar to algorithm from Theorem 1. Now
we present only functions which convolution give an answer. As the further
details are identical to Theorem 1.
Our functions are defined over subsets of a set W = V \ U .
• f(S) = |E(S,W \ S)| if G[S] is highly connected, otherwise ∞.
• h(S) = min
i
(
f∗i(S)
)
.
• gs(S) = 2|E(S,Ut)| + |E(S,W \ S)| if G[S ∪ Us] is highly connected,
otherwise ∞.
• gt(S) = 2|E(S,Us)| + |E(S,W \ S)| if G[S ∪ Ut] is highly connected,
otherwise ∞.
The only difference from previous case is that we constructed two func-
tions gs, gt instead of just one function g as now we know two halves of two
9
guessed highly connected components. Minimum number of edge deletions
in YES-instance separating clusters C(s), C(t) (Us ⊆ C(s), Ut ⊆ C(t)) is
(h ∗ gs ∗ gt)(W )/2. So in this case we need O∗(2|W |) running time which is
O∗
(
2n−
(n−k)
2
)
= O∗
(
2
3k
2
)
.
Pseudo-code for algorithm from previous lemma is shown in Algorithm 2.
Algorithm 2
function AFFECTED((V,E), k)
if |V | ≤ 1.57k then
return EXACT ((V,E), k)
if |V | > 2k then
return NO
for st ∈ E do
U(s) = N [s] \ {t}
if |U(s)| > n− 1.57k then
Compute f, h, g, g ∗ h for all subsets of V \ U(s)
if (g ∗ h)(V \ U(s)) ≤ 2k then
return YES
else
for 0 ≤ l ≤ 7, (t′y1, . . . , t′yl) ∈ El do
U(t′) = N [t′] \ {y1, . . . , yl}
U = U(s) ∪ U(t)
if U(s) ∩ U(t′) = ∅ ∧ |U | ≥ n−k2 then
Compute f, h, gs, gt, h ∗ gs ∗ gt for all subsets of V \ U
if (h∗gs ∗ gt)(V \ U) ≤ 2(k − |E(U(s), U(t′))| then
return YES
return NO
2.2 p-Highly Connected Deletion
p-Highly Connected Deletion
Instance: Graph G = (V,E), integer numbers p and k.
Task: Is there a subset of edges E′ ⊂ E of size at most k such that
G − E′ contains at most p connected components and each component
is highly connected?
Our algorithm for p-Highly Connected Deletion is insipired by al-
gorithm for p-Cluster Editing by Fomin et al. [5].
First of all, we prove an upper bound on the number of small cuts in
highly connected graph.
10
Lemma 8. Let G = (V,E) be highly connected graph, X = arg min
S⊂V
|V |
4
≤|S|≤ 3|V |
4
|E(S, V \
S)|, and Y = V \X, then
i) If |E(X,Y )| ≥ |V |
2
100 then for any partition of V = A t B we have
|E(A,B)| ≥ |A|·|B|100 .
ii) If |E(X,Y )| < |V |
2
100 then for any partition of V = A tB we have:
|E(A ∩X,B ∩X)| ≥ |X∩A|·|X∩B|100 , |E(A ∩ Y,B ∩ Y )| ≥
|Y ∩A|·|Y ∩B|
100 ,
|E(A,B)| ≥ |X∩A|·|X∩B|100 +
|Y ∩A|·|Y ∩B|
100 .
Proof. i) Let V = A tB. Without loss of generality |A| < |B|.
If |V |4 ≤ |A| then |E(X,Y )| ≤ |E(A,B)|. Hence, |E(A,B)| ≥ |E(X,Y )| ≥
|V |2
100 ≥
|A|·|B|
100 .
If |A| < |V |4 then |E(A,B)| ≥
∑
v∈A
(deg(v)− |A|). As deg(v) > |V |2 for all
v ∈ V (G), we have |E(A,B)| ≥ |A|
(
|V |
2 − |A|
)
≥ |A|·|V |4 ≥
|A|·|B|
4 ≥
|A|·|B|
100 .
ii) Note that |E(A,B)| ≥ |E(A ∩ X,B ∩ X)| + |E(A ∩ Y,B ∩ Y )| . So
it is enough to prove that |E(A ∩ X,B ∩ X)| ≥ |A∩X|·|B∩X|50 , as the proof
of |E(A ∩ Y,B ∩ Y )| ≥ |A∩Y |·|B∩Y |50 is analogous. The sum of these two
inequalities gives the proof of the theorem.
Without loss of generality |B ∩X| ≤ |A∩X|. Hence, |V |8 ≤ |A∩X| and
|B ∩X| ≤ 3|V |8 . Consider two cases: |A ∩X| ≥
|V |
4 and |A ∩X| <
|V |
4 .
Consider case when |A∩X| ≥ |V |4 . At first we prove |E(A∩X,B∩X)| ≥
|E(B ∩X,Y )|. It is known that:
|E(A∩X,V \(A ∩X))| = |E(X,Y )|−|E(B∩X,Y )|+|E(A∩X,B∩X)| , (1)
|A ∩ X| ≥ |V |4 , and |V \ (A ∩X) | ≥ |Y | ≥
|V |
4 , it means |E(A ∩ X,V \
(A ∩X))| ≥ |E(X,Y )|. The last inequality and (1) imply |E(A ∩ X,B ∩
X)| ≥ |E(B ∩X,Y )|. It follows that 2|E(A ∩X,B ∩X)| ≥ |E(B ∩X,A ∩
X)|+ |E(B ∩X,Y )| = |E(B ∩X,V \ (B ∩X) |.
As 3|V |8 ≥ |B∩X| and |E(B∩X,V \(B ∩X))| ≥ |B∩X|
(
|V |
2 − |B ∩X|
)
we have |E(B ∩X,V \ (B ∩X))| ≥ |B∩X|·|V |8 . Hence, |E(A ∩X,B ∩X)| ≥
|B∩X|·|V |
16 ≥
|B∩X|·|V |
100 .
It is left to consider case |A ∩ X| < |V |4 . Note that |E(A ∩ X,B ∩
X)| = |E(A ∩X,V \ (A ∩X))| − |E(A ∩X,Y )|. As |V |4 > |A ∩X| we have
|E(A ∩X,V \ (A ∩X))| ≥ |A ∩X|
(
|V |
2 − |A ∩X|
)
≥ |V |8 ·
|V |
4 ≥
|V |2
32 . We
know that |E(A ∩ X,Y )| ≤ |E(X,Y )| ≤ |V |
2
100 , hence |E(A ∩ X,B ∩ X) ≥
|V |2
32 −
|V |2
100 >
|V |2
50 ≥
|A∩X|·|B∩X|
100 .
11
Definition 2. A partition of V = V1tV2 is called a k-cut of G if |E(V1, V2)| ≤
k .
The following lemma limits number of k-cuts in a disjoint union of highly
connected graphs.
Lemma 9. If G = (V,E) is a union of p disjoint highly connected compo-
nents and p ≤ k then the number of k-cuts in G is bounded by 2O(
√
pk) .
Proof. Let G be a disjoint union of highly connected components C1, . . . , Cp.
For each Ci we consider sets Xi, Yi where E(Xi, Yi) is a minimum cut of Ci
and Ci = Xi t Yi. We construct a new partition C ′1, . . . , C ′q of V (G). The
new partition is obtained from partition C1 t . . . tCp in the following way:
if |E(Xi, Yi)| < |C2i |/100 then we split Ci into two sets Xi, Yi otherwise we
take Ci without splitting. Note that p ≤ q ≤ 2p as we either split Ci into to
parts or leave it as is.
We bound number of k-cuts of graph G in two steps. In first step we
bound number of cuts V1, V2 such that |V1∩C ′i| = xi and |V2∩C ′i| = yi where
xi, yi are some fixed integers. In second step we bound number of tuples
(x1, . . . , xq, y1, . . . , yq) for which there is at least one k-cut V1, V2 satisfying
conditions |V1 ∩ C ′i| = xi, |V2 ∩ C ′i| = yi.
If xi, yi are fixed and xi+yi = |C ′i| the number of partitions of C ′i is equal
to
(
xi+yi
xi
)
. Note that by Lemma 5 we have
(
xi+yi
xi
)
≤ 2
√
xiyi . Observe that
there are at least xiyi100 edges between V1 ∩ C
′
i and V2 ∩ C ′i by Lemma 8. So
if V1 t V2 is partition of V then
q∑
i=1
xiyi ≤ 100k. Applying CauchySchwarz
inequality we infer that
q∑
i=1
√
xiyi ≤
√
q ·
√∑q
i=1 xiyi ≤
√
200pk. There-
fore, the number of considered cuts is at most
q∏
i=1
(
xi+yi
xi
)
≤ 22
∑q
i=1
√
xiyi ≤
2
√
800pk.
Now we show bound for a second step i.e. number of possible tuples
(x1, . . . , xq, y1, . . . , yq) generating at least one k-cut. Note that min{xi, yi} ≤
√
xiyi. Hence,
q∑
i=1
min(xi, yi) ≤
√
100qk . Tuple (x1, . . . , xq, y1, . . . , yq) can
be generated in the following way: at first we choose which value is smaller
xi or yi. Then we express
√
b100qkc as a sum of q+1 non-negative numbers:
min{xi, yi} for 1 ≤ i ≤ q and the rest
√
b100qkc −
q∑
i=1
min(xi, yi).
The number of choices in the first step of generation is equal to 2q ≤
2
√
2qk, and number of ways to expreess
√
100qk as a sum of q+ 1 number is
at most
(√
100qk+q+1
q
)
≤ 2
√
100qk+q+1 ≤ 2
√
100qk+
√
2qk+1. Therefore, the total
number of partitions is bounded by 2c
√
pk for some constant c.
The last ingredient for our algorithm is the following lemma proved by
Fomin et al.[5]
12
Lemma 10. [5] All cuts (V1, V2) such that |E(V1, V2)| ≤ k of a graph G can
be enumerated with polynomial time delay.
Now we are ready to present a final theorem.
Theorem 3. There is a O∗(2O(
√
pk)) time algorithm for p-Highly Con-
nected Deletion problem.
Proof. First of all we solve the problem in case of connected graph. Denote
by N set of all k-cuts in graph G. All elements of set N can be enumerated
with a polynomial time delay. If G is a union of p clusters plus some edges
then the size of N is bounded by 2c
√
pk by Lemma 9 (as additional edges only
decrease number of k-cuts). Thus, we enumerate N in time O∗(2O(
√
pk)).
If we exceed the bound 2c
√
pk given by Lemma 9 we know that we can
terminate our algorithm and return answer NO. So we may assume that we
enumerate the whole N and it contains at most 2c
√
pk elements.
We construct a directed graph D, whose vertices are elements of a set
N × {0, 1, . . . , p} × {0, 1, . . . , k}, note that |V (D)| = 2O(
√
pk). We add arcs
going from ((V1, V2), j, l) to ((V
′
1 , V
′
2), j + 1, l
′), where V1 ⊂ V ′1 , G[V ′1 \ V1] is
highly connected graph, j ∈ {0, 1, . . . , p − 1}, and l′ = l + |E(V1, V ′1 \ V1)|.
The arcs can be constructed in 2O(
√
pk) time. We claim that the answer
for an instance (G, p, k) is equivalent to existence of path from a vertex
((V,∅), 0, 0) to a vertex ((∅, V ), p′, k′) for some p′ ≤ p, k′ ≤ k.
In one direction, if there is a path from ((∅, V ), 0, 0) to ((V,∅), p′, k′) for
some k′ ≤ k and p′ ≤ p, then the consecutive sets V ′1 \V1 along the path form
highly connected components. Moreover, number of deleted edges from G
is equal to last coordinate which is smaller than k.
Let us prove the opposite direction. Let assume that we can delete at
most k edges and get a graph with highly connected components C1, . . . , Cp.
Let us denote Ti = ∪j<iV (Ci), li+1 = li + |E(Ti+1 \Ti, Ti)| then the vertices
((Ti, V \ Ti), i− 1, li) constitute desired path in graph D.
Reachability in a graph can be tested in a linear time with respect to
the number of vertices and arcs. To concude the algorithm we simply test
the reachability in the graph D.
It is left co consider a case when G is not connected. Let assume that
G consist of q connected components C1, . . . , Cq then for each connected
component Ci we find all p
′ ≤ p and k′ ≤ k such that (Ci, p′, k′) is YES-
instance. After this we construct auxiliary directed graph Q with a set of
vertices {0, . . . , q}× {0, . . . , p}× {0, . . . , k}. We add arcs going from (i, a, b)
to (i+1, a+p′, b+k′) if (Ci, p
′, k′) is a YES-instance. Using similar arguments
as before it could be shown that reachability of vertex (q, p′, k′) from vertex
(0, 0, 0) is equivalent to possibility delete k′ edges and get p′ highly connected
components.
13
3 Algorithms for finding a subgraph
3.1 Seeded Highly Connected Edge Deletion
Seeded Highly Connected Edge Deletion
Instance: Graph G = (V,E), subset S ⊆ V and integer numbers a
and k.
Task: Is there a subset of edges E′ ⊆ E of size at most k such that G−
E′ contains only isolated vertices and one highly connected component
C with S ⊆ V (C) and |V (C)| = |S|+ a.
Hüffner et al. [12] constructed an algorithm with running timeO(16k
0.75
+
k2nm) for Seeded Highly Connected Edge Deletion problem. We
improve the result to
O∗
(
2O(
√
k log k)
)
time algorithm.
Theorem 4. There is O∗(2O(
√
k log k)) time algorithm for Seeded Highly
Connected Edge Deletion problem.
We rely on the following theorem proved in [12].
Theorem 5. [12] Any instance of Seeded Highly Connected Edge
Deletion problem can be transformed in O(k2nm) time into equivalent
instance with at most 2k + 4ka vertices and at most
(
2k
2
)
+ k edges.
Proof of theorem 4. By Theorem 5 we construct an equivalent instance with
at most 2k+ 4ka vertices and at most
(
2k
2
)
+ k edges. We consider two cases
a ≤ 2
√
k and a > 2
√
k.
Case 1: a ≤ 2
√
k.
In order to solve the problem we simply brute-force over all possible
candidates. We consider all vertex subsets V ′ of size at most 2
√
k and in
each branch check whether S ∪ V ′ is an answer. It is easy to see that the
algorithm is correct. Up to polynomial factor the running time of such
algorithm is equal to number of candidates V ′. Hence, the running time is
at most O∗
((
2k+ 4k
a
a
))
≤
(
6k
a
)
≤ (6k)a ≤ 2O(
√
k log k).
Case 2: a > 2
√
k.
Since a > 2
√
k then the size of highly connected component from the
solution is at least 2
√
k. So, if deg(w) <
√
k then w does not belong to the
highly connected component from solution. In this case we delete vertex
w and all its edges, decreasing parameter k by deg(w). Hence, we can
assume that degree of all vertices is at least
√
k. However, in such case at
most 2
√
k vertices are not present in highly connected component of the
solution. As otherwise we have to delete more than 2
√
k ·
√
k edges. So
now, we simply brute-force all subsets of vertices F that are no part of a
14
highly connected graph. In order to do this we have to consider at most
O∗
(∑
i≤2
√
k
(
n
i
))
= O∗
(( 6k
2
√
k
))
= O∗
(
2O(
√
k log k)
)
cases.
So the running time for Case 2 match with the running time of case
Case 1. Hence, the running time of the whole algorithm is O∗(2O(
√
k log k)).
3.2 Isolated Highly Connected Subgraph
Isolated Highly Connected Subgraph
Instance: Graph G = (V,E), integer k, integer s.
Task: Is there a set of vertices S such that |S| = s, G[S] is highly
connected graph and |E(S, V \ S)| ≤ k.
Hüffner et al. [12] proposed O∗(4k) algorithm for Isolated Highly
Connected Subgraph problem, in this work we construct subexponential
algorithm for the same problem with running time O∗(kO(k
2/3)).
In order to solve Isolated Highly Connected Subgraph problem
Hüffner et al. in [12] constructed algorithm for a more general problem:
f -Isolated Highly Connected Subgraph
Instance: Graph G = (V,E), integer k, integer s, function f : V → N.
Task: Is there a set of vertices S such that |S| = s, G[S] is highly
connected and |E(S, V \ S)|+
∑
v∈S
f(v) ≤ k.
Our algorithm uses reduction rules proposed in [12]. Here, we state the
reduction rules without proof, as the proofs can be found in [12].
Rule 4. If G contains connected component C of size smaller than s then
delete C i.e. solve instance (G \ C, f, k).
Rule 5. Let G contains connected component C = (V ′, E′) with minimal
cut bigger than k. If C is highly connected graph, |V ′| = s and
∑
s∈V ′
f(s) ≤ k
then output a trivial YES-instance otherwise remove C, i.e. consider instance
(G \ C, f, k) of f -Isolated Highly Connected Subgraph problem.
Rule 6. Let G contains connected component C with minimal cut (A,B) of
size at most s2 . We define function f
′ in the following way: for each vertex
v ∈ A f ′(v) := f(v) + |N(v) ∩B| and for each v ∈ B we let f ′(v) := f(v) +
|N(v)∩A|. Replace original instance with an instance (G \ E(A,B), f ′, k).
Lemma 11. Rules 4, 5, 6 can be exhaustively applied in time O((sn+k)m).
If rules 4, 5, 6 are not applicable then k > s2 .
We also use following Fomin and Villanger’s result.
Proposition 1. [6] For each vertex v in graph G and integers b, f ≥ 0
number of connected induced subgraphs B ⊆ V (G) satisfying the following
15
properties v ∈ B, |B| = b + 1, |N(B)| = f ; is at most
(
b+f
b
)
. Moreover, all
these sets can be enumerated in time O
((
b+f
b
)
(n+m)b(b+ f)
)
.
Now we have all ingredients for out algorithm.
Theorem 6. f -Isolated Highly Connected Subgraph can be solved
in time 2O(k
2/3 log k).
Proof. First of all we exhaustively apply reduction rules 4, 5, 6. From
Lemma 11 follows that we may assume 2k > s. We consider two cases
either k2/3 < s or k2/3 ≥ s.
Case 1: s ≤ k2/3. Enumerate all induced connected subgraphs G′ =
(V ′, E′) such that |V ′| = s and N(V ′) ≤ k. If desired S exists than it is
among enumerated sets. From Proposition 1 follows that number of such
sets is at most nkO∗(
(
s+k
s
)
). As s < 2k and s < k2/3 we have nkO∗(
(
s+k
s
)
) ≤
O∗((s+k)s) ≤ O∗(2k2/3 log k). Hence, in time O∗(2k2/3 log k) we can enumerate
all potential candidates S′. For each candidate we check in polynomial time
whether G[S′] is highly connected and |E(S′, V \S′)|+
∑
v∈S′
f(v) ≤ k.
Case 2: k
2
3 < s. Let set S be a solution. Define edge set E′ = E(S, V \
S). Consider function d : S → N where d(v) = |N(v)∩(V \S)|. As
∑
v∈S
d(v) =
|E(S, V \S)| ≤ k then there is a vertex v ∈ S such that d(v) ≤ ks < k
1
3 . Note
that for such v we have |N(v)| = |N(v)∩S|+ |N(v)\S| ≤ s+k
1
3 . We branch
on possible values of such vertex and a set of its neighbors that do not belong
to S. In order to do this we have to consider at most n
∑
i≤k1/3
(
s+k1/3
i
)
≤
nk1/322
√
(s+k1/3−i)i ≤ nk1/322
√
3k4/3 = n2O(k
2/3) cases. Knowing vertex
v ∈ S and N(v) \ S we find N(v) ∩ S. So we already identified at least
s
2 + 1 vertices from S, let denote this set by W . Now we start branching
procedure that in right branch extend set W into a solution set S. Branching
procedure takes as an input tuple (G, k, s′,W,B) where W is a set of vertices
determined to be in solution S, B is a set of vertices determined to be not
in solution, k number of allowed edge deletions, s′ = s − |W | number of
vertices that is left to add. The procedure pick a vertex w /∈ W ∪ B and
consider two cases either w ∈ S,w /∈ B or w /∈ S,w ∈ B. The first call of the
procedure is performed on tuple (G, k − |E(W,N(v) \W )|, s− |W |,W,∅).
Consider arbitrary vertex x ∈ V \(W ∪B). If x ∈ S then |N(x)∩S| ≥ s2 .
Hence, |N(x) ∩W | ≥ |N(x) ∩ S| − |S \W | ≥ s2 − (s− |W |) = |W | −
s
2 . So
any vertex x such that |N(x) ∩W | < |W | − s2 cannot belong to solution
S and we safely put x to B. Otherwise, we run our procedure on tuples
(G, k − |N(x) ∩ B|, s′ − 1,W ∪ x,B) and (G, k − |N(x) ∩W |, s′,W,B ∪ x).
Note that we stop computation in a branch if k′ ≤ 0 or s′ = 0. It is easy to
see that the algorithm is correct.
16
It is left to determine the running time of the algorithm. Note that
procedure contains two parameters k and s′. In one branch we decrease
value of s′ by one in the other branch we decrease value of k by E(x,W ).
Note that in first branch we not only decrease value of s′ but we also increase
a lower bound on |N(x) ∩W | by 1 as |N(x) ∩W | ≥ |W | − s2 .
Let us consider a path (x1, x2, . . . xl) from root to leaf in our branching
tree. To each node we assign a vertex xi on which we are branching at this
node. For each such path we construct unique sequence a1, a2, . . . , am and a
number b. We put b equal to the number of vertices from set {x1, x2, . . . , xl}
that was assigned to solution S. And ai − 1 is a number of vertices that
was assigned to W in a sequence x1, x2, . . . xj where xj is an i−th vertex
assigned to B in this sequence. Note that |N(xj) ∩W | ≥ ai, so
∑
i ai ≤ k.
Note that for any path from root to leaf we can construct a corresponding
sequence ai and number b. Moreover, any sequence a1, a2, . . . am and number
b correspond to at most one path from root to node.
Proposition 2. Given number b and non-decreasing sequence a1, a2, . . . , am
we can uniquely determine a corresponding path in a branching tree.
Proof. For a notation convenience we let a0 = 1. For 1 ≤ i ≤ m we perform
the following operation: we make ai − ai−1 steps of assigning vertices to a
solution set, i.e. to set W and make one step in branch assigning vertex to a
set B. After m such iterations we perform b−m steps of assigning vertices
to solution. As a1, a2, . . . am is non-decreasing sequence we have constructed
a unique path in branching tree. It is easy to see that the original sequence
a1, . . . , am and number b correspond to a constructed path. So for each path
from root to leaf there is a corresponding sequence and for each sequence
with a number there is at most one corresponding path from root to node
in a tree.
Lemma 12. The number of tuples (a1, . . . , am, b) where 0 ≤ b ≤ s, 1 ≤ ai ≤
ai+1 for i < m, and
∑
i ai ≤ k is bounded by O∗
(
2O(
√
k)
)
Proof. For fixed l, tuples (a1, . . . , am) such that
∑
i ai = l are well-known
and are called partitions of l. Pribitkin [4] gave a simple upper bound e2.57
√
l
on the number of partitions of l. Hence, number of tuples (a1, . . . , am)
is bounded by
k∑
i=0
e2.57
√
i ≤ (k + 1)e2.57
√
k. Moreover, we know that 0 ≤
b ≤ s. It means that the number of tuples (a1, . . . , am, b) is bounded by
(s+ 1)(k + 1)2O(
√
k).
From Proposition 2 and Lemma 12 follows that the number of nodes in a
branching tree is at most s2O(
√
k). Hence, the running time of the procedure
is at most s2O(
√
k).
17
Now, we compute required time for algorithm in this case(case 2). At
first, we branch on a vertex and its neighbors from solution set S. We did
it by creating at most O∗
(
2O(k
2/3)
)
subcases. In each subcase we run a
procedure with running time O∗
(
2O(
√
k)
)
. So, the overall runnning time
equals to O∗
(
2O(
√
k)2O(k
2/3)
)
= O∗
(
2O(k
2/3)
)
.
The worst running time has Case 1, so the running time of the whole
algorithms is O∗
(
kO(k
2/3)
)
.
References
[1] Balabhaskar Balasundaram, Sergiy Butenko, and Illya V Hicks. Clique
relaxations in social network analysis: The maximum k-plex problem.
Operations Research, 59(1):133–142, 2011.
[2] Andreas Björklund, Thore Husfeldt, Petteri Kaski, and Mikko Koivisto.
Fourier meets möbius: fast subset convolution. In Proceedings of the
39th Annual ACM Symposium on Theory of Computing, San Diego,
California, USA, June 11-13, 2007, pages 67–74, 2007. URL: http:
//doi.acm.org/10.1145/1250790.1250801, doi:10.1145/1250790.
1250801.
[3] Gary Chartrand. A graph-theoretic approach to a communications
problem. SIAM Journal on Applied Mathematics, 14(4):778–781, 1966.
[4] Wladimir de Azevedo Pribitkin. Simple upper bounds for par-
tition functions. The Ramanujan Journal, 18(1):113–119, 2009.
URL: http://dx.doi.org/10.1007/s11139-007-9022-z, doi:10.
1007/s11139-007-9022-z.
[5] Fedor V. Fomin, Stefan Kratsch, Marcin Pilipczuk, Michal Pilipczuk,
and Yngve Villanger. Tight bounds for parameterized complexity of
cluster editing with a small number of clusters. J. Comput. Syst. Sci.,
80(7):1430–1447, 2014. URL: http://dx.doi.org/10.1016/j.jcss.
2014.04.015, doi:10.1016/j.jcss.2014.04.015.
[6] Fedor V. Fomin and Yngve Villanger. Treewidth computation
and extremal combinatorics. Combinatorica, 32(3):289–308, 2012.
URL: http://dx.doi.org/10.1007/s00493-012-2536-z, doi:10.
1007/s00493-012-2536-z.
[7] Jiong Guo, Iyad A Kanj, Christian Komusiewicz, and Johannes
Uhlmann. Editing graphs into disjoint unions of dense clusters. Al-
gorithmica, 61(4):949–970, 2011.
18
[8] Erez Hartuv, Armin O Schmitt, Jörg Lange, Sebastian Meier-Ewert,
Hans Lehrach, and Ron Shamir. An algorithm for clustering cdna fin-
gerprints. Genomics, 66(3):249–256, 2000.
[9] Erez Hartuv and Ron Shamir. A clustering algorithm based
on graph connectivity. Inf. Process. Lett., 76(4-6):175–181, 2000.
URL: http://dx.doi.org/10.1016/S0020-0190(00)00142-3, doi:
10.1016/S0020-0190(00)00142-3.
[10] Wayne Hayes, Kai Sun, and Nataša Pržulj. Graphlet-based mea-
sures are suitable for biological network comparison. Bioinformatics,
29(4):483–491, 2013.
[11] Falk Hüffner, Christian Komusiewicz, Adrian Liebtrau, and Rolf Nie-
dermeier. Partitioning biological networks into connected clusters
with maximum edge coverage. IEEE/ACM Trans. Comput. Biology
Bioinform., 11(3):455–467, 2014. URL: http://dx.doi.org/10.1109/
TCBB.2013.177, doi:10.1109/TCBB.2013.177.
[12] Falk Hüffner, Christian Komusiewicz, and Manuel Sorge. Finding
highly connected subgraphs. In SOFSEM 2015: Theory and Prac-
tice of Computer Science - 41st International Conference on Current
Trends in Theory and Practice of Computer Science, Pec pod Sněžkou,
Czech Republic, January 24-29, 2015. Proceedings, pages 254–265,
2015. URL: http://dx.doi.org/10.1007/978-3-662-46078-8_21,
doi:10.1007/978-3-662-46078-8_21.
[13] Antje Krause, Jens Stoye, and Martin Vingron. Large scale hierarchical
clustering of protein sequences. BMC bioinformatics, 6(1):15, 2005.
[14] Hannes Moser, Rolf Niedermeier, and Manuel Sorge. Algorithms and
experiments for clique relaxationsfinding maximum s-plexes. In In-
ternational Symposium on Experimental Algorithms, pages 233–244.
Springer, 2009.
[15] Brian J Parker, Ida Moltke, Adam Roth, Stefan Washietl, Jiayu Wen,
Manolis Kellis, Ronald Breaker, and Jakob Skou Pedersen. New families
of human regulatory rna structures identified by comparative analysis
of vertebrate genomes. Genome research, 21(11):1929–1943, 2011.
[16] Jeffrey Pattillo, Alexander Veremyev, Sergiy Butenko, and Vladimir
Boginski. On the maximum quasi-clique problem. Discrete Applied
Mathematics, 161(1):244–257, 2013.
[17] Jeffrey Pattillo, Nataly Youssef, and Sergiy Butenko. On clique re-
laxation models in network analysis. European Journal of Operational
Research, 226(1):9–18, 2013.
19
[18] Jeffrey Pattillo, Nataly Youssef, and Sergiy Butenko. On clique re-
laxation models in network analysis. European Journal of Operational
Research, 226(1):9–18, 2013. URL: http://dx.doi.org/10.1016/j.
ejor.2012.10.021, doi:10.1016/j.ejor.2012.10.021.
[19] Alexander Schäfer. Exact algorithms for s-club finding and related prob-
lems. PhD thesis, Friedrich-Schiller-University Jena, 2009.
[20] Shahram Shahinpour and Sergiy Butenko. Distance-based clique re-
laxations in networks: s-clique and s-club. In Models, algorithms, and
technologies for network analysis, pages 149–174. Springer, 2013.
[21] Haiyuan Yu, Alberto Paccanaro, Valery Trifonov, and Mark Gerstein.
Predicting interactions in protein networks by completing defective
cliques. Bioinformatics, 22(7):823–829, 2006.
20

