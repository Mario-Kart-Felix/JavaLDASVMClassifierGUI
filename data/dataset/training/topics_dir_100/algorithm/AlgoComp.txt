Algorithms and Complexity
Herbert S. Wilf
University of Pennsylvania
Philadelphia, PA 19104-6395
Copyright Notice
Copyright 1994 by Herbert S. Wilf. This material may be reproduced for any educational purpose, multiple
copies may be made for classes, etc. Charges, if any, for reproduced copies must be just enough to recover
reasonable costs of reproduction. Reproduction for commercial purposes is prohibited. This cover page must
be included in all distributed copies.
Internet Edition, Summer, 1994
This edition of Algorithms and Complexity is available at the web site <http://www/cis.upenn.edu/ wilf>.
It may be taken at no charge by all interested persons. Comments and corrections are welcome, and should
be sent to wilf@math.upenn.edu
A Second Edition of this book was published in 2003 and can be purchased now. The Second Edition contains
solutions to most of the exercises.
CONTENTS
Chapter 0: What This Book Is About
0.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
0.2 Hard vs. easy problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.3 A preview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Chapter 1: Mathematical Preliminaries
1.1 Orders of magnitude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.2 Positional number systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.3 Manipulations with series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
1.4 Recurrence relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.5 Counting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.6 Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
Chapter 2: Recursive Algorithms
2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.2 Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
2.3 Recursive graph algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2.4 Fast matrix multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.5 The discrete Fourier transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.6 Applications of the FFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
2.7 A review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Chapter 3: The Network Flow Problem
3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.2 Algorithms for the network flow problem . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.3 The algorithm of Ford and Fulkerson . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.4 The max-flow min-cut theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
3.5 The complexity of the Ford-Fulkerson algorithm . . . . . . . . . . . . . . . . . . . . . 70
3.6 Layered networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
3.7 The MPM Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
3.8 Applications of network flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Chapter 4: Algorithms in the Theory of Numbers
4.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.2 The greatest common divisor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.3 The extended Euclidean algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
4.4 Primality testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.5 Interlude: the ring of integers modulo n . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.6 Pseudoprimality tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
4.7 Proof of goodness of the strong pseudoprimality test . . . . . . . . . . . . . . . . . . . . 94
4.8 Factoring and cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.9 Factoring large integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.10 Proving primality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
iii
Chapter 5: NP-completeness
5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
5.2 Turing machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.3 Cookâ€™s theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.4 Some other NP-complete problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.5 Half a loaf ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.6 Backtracking (I): independent sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
5.7 Backtracking (II): graph coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
5.8 Approximate algorithms for hard problems . . . . . . . . . . . . . . . . . . . . . . . . 128
iv
Preface
For the past several years mathematics majors in the computing track at the University of Pennsylvania
have taken a course in continuous algorithms (numerical analysis) in the junior year, and in discrete algo-
rithms in the senior year. This book has grown out of the senior course as I have been teaching it recently.
It has also been tried out on a large class of computer science and mathematics majors, including seniors
and graduate students, with good results.
Selection by the instructor of topics of interest will be very important, because normally Iâ€™ve found
that I canâ€™t cover anywhere near all of this material in a semester. A reasonable choice for a first try might
be to begin with Chapter 2 (recursive algorithms) which contains lots of motivation. Then, as new ideas
are needed in Chapter 2, one might delve into the appropriate sections of Chapter 1 to get the concepts
and techniques well in hand. After Chapter 2, Chapter 4, on number theory, discusses material that is
extremely attractive, and surprisingly pure and applicable at the same time. Chapter 5 would be next, since
the foundations would then all be in place. Finally, material from Chapter 3, which is rather independent
of the rest of the book, but is strongly connected to combinatorial algorithms in general, might be studied
as time permits.
Throughout the book there are opportunities to ask students to write programs and get them running.
These are not mentioned explicitly, with a few exceptions, but will be obvious when encountered. Students
should all have the experience of writing, debugging, and using a program that is nontrivially recursive,
for example. The concept of recursion is subtle and powerful, and is helped a lot by hands-on practice.
Any of the algorithms of Chapter 2 would be suitable for this purpose. The recursive graph algorithms are
particularly recommended since they are usually quite foreign to studentsâ€™ previous experience and therefore
have great learning value.
In addition to the exercises that appear in this book, then, student assignments might consist of writing
occasional programs, as well as delivering reports in class on assigned readings. The latter might be found
among the references cited in the bibliographies in each chapter.
I am indebted first of all to the students on whom I worked out these ideas, and second to a num-
ber of colleagues for their helpful advice and friendly criticism. Among the latter I will mention Richard
Brualdi, Daniel Kleitman, Albert Nijenhuis, Robert Tarjan and Alan Tucker. For the no-doubt-numerous
shortcomings that remain, I accept full responsibility.
This book was typeset in TEX. To the extent that itâ€™s a delight to look at, thank TEX. For the deficiencies
in its appearance, thank my limitations as a typesetter. It was, however, a pleasure for me to have had the
chance to typeset my own book. My thanks to the Computer Science department of the University of
Pennsylvania, and particularly to Aravind Joshi, for generously allowing me the use of TEX facilities.
Herbert S. Wilf
v
Chapter 0: What This Book Is About
0.1 Background
An algorithm is a method for solving a class of problems on a computer. The complexity of an algorithm
is the cost, measured in running time, or storage, or whatever units are relevant, of using the algorithm to
solve one of those problems.
This book is about algorithms and complexity, and so it is about methods for solving problems on
computers and the costs (usually the running time) of using those methods.
Computing takes time. Some problems take a very long time, others can be done quickly. Some problems
seem to take a long time, and then someone discovers a faster way to do them (a â€˜faster algorithmâ€™). The
study of the amount of computational effort that is needed in order to perform certain kinds of computations
is the study of computational complexity.
Naturally, we would expect that a computing problem for which millions of bits of input data are
required would probably take longer than another problem that needs only a few items of input. So the time
complexity of a calculation is measured by expressing the running time of the calculation as a function of
some measure of the amount of data that is needed to describe the problem to the computer.
For instance, think about this statement: â€˜I just bought a matrix inversion program, and it can invert
an n Ã— n matrix in just 1.2n3 minutes.â€™ We see here a typical description of the complexity of a certain
algorithm. The running time of the program is being given as a function of the size of the input matrix.
A faster program for the same job might run in 0.8n3 minutes for an n Ã— n matrix. If someone were
to make a really important discovery (see section 2.4), then maybe we could actually lower the exponent,
instead of merely shaving the multiplicative constant. Thus, a program that would invert an n Ã— n matrix
in only 7n2.8 minutes would represent a striking improvement of the state of the art.
For the purposes of this book, a computation that is guaranteed to take at most cn3 time for input of
size n will be thought of as an â€˜easyâ€™ computation. One that needs at most n10 time is also easy. If a certain
calculation on an nÃ— n matrix were to require 2n minutes, then that would be a â€˜hardâ€™ problem. Naturally
some of the computations that we are calling â€˜easyâ€™ may take a very long time to run, but still, from our
present point of view the important distinction to maintain will be the polynomial time guarantee or lack of
it.
The general rule is that if the running time is at most a polynomial function of the amount of input
data, then the calculation is an easy one, otherwise itâ€™s hard.
Many problems in computer science are known to be easy. To convince someone that a problem is easy,
it is enough to describe a fast method for solving that problem. To convince someone that a problem is
hard is hard, because you will have to prove to them that it is impossible to find a fast way of doing the
calculation. It will not be enough to point to a particular algorithm and to lament its slowness. After all,
that algorithm may be slow, but maybe thereâ€™s a faster way.
Matrix inversion is easy. The familiar Gaussian elimination method can invert an nÃ— n matrix in time
at most cn3.
To give an example of a hard computational problem we have to go far afield. One interesting one is
called the â€˜tiling problem.â€™ Suppose* we are given infinitely many identical floor tiles, each shaped like a
regular hexagon. Then we can tile the whole plane with them, i.e., we can cover the plane with no empty
spaces left over. This can also be done if the tiles are identical rectangles, but not if they are regular
pentagons.
In Fig. 0.1 we show a tiling of the plane by identical rectangles, and in Fig. 0.2 is a tiling by regular
hexagons.
That raises a number of theoretical and computational questions. One computational question is this.
Suppose we are given a certain polygon, not necessarily regular and not necessarily convex, and suppose we
have infinitely many identical tiles in that shape. Can we or can we not succeed in tiling the whole plane?
That elegant question has been proved* to be computationally unsolvable. In other words, not only do
we not know of any fast way to solve that problem on a computer, it has been proved that there isnâ€™t any
* See, for instance, Martin Gardnerâ€™s article in Scientific American, January 1977, pp. 110-121.
* R. Berger, The undecidability of the domino problem, Memoirs Amer. Math. Soc. 66 (1966), Amer.
Chapter 0: What This Book Is About
Fig. 0.1: Tiling with rectangles
Fig. 0.2: Tiling with hexagons
way to do it, so even looking for an algorithm would be fruitless. That doesnâ€™t mean that the question is
hard for every polygon. Hard problems can have easy instances. What has been proved is that no single
method exists that can guarantee that it will decide this question for every polygon.
The fact that a computational problem is hard doesnâ€™t mean that every instance of it has to be hard. The
problem is hard because we cannot devise an algorithm for which we can give a guarantee of fast performance
for all instances.
Notice that the amount of input data to the computer in this example is quite small. All we need to
input is the shape of the basic polygon. Yet not only is it impossible to devise a fast algorithm for this
problem, it has been proved impossible to devise any algorithm at all that is guaranteed to terminate with
a Yes/No answer after finitely many steps. Thatâ€™s really hard!
0.2 Hard vs. easy problems
Letâ€™s take a moment more to say in another way exactly what we mean by an â€˜easyâ€™ computation vs. a
â€˜hardâ€™ one.
Think of an algorithm as being a little box that can solve a certain class of computational problems.
Into the box goes a description of a particular problem in that class, and then, after a certain amount of
time, or of computational effort, the answer appears.
A â€˜fastâ€™ algorithm is one that carries a guarantee of fast performance. Here are some examples.
Example 1. It is guaranteed that if the input problem is described with B bits of data, then an answer
will be output after at most 6B3 minutes.
Example 2. It is guaranteed that every problem that can be input with B bits of data will be solved in at
most 0.7B15 seconds.
A performance guarantee, like the two above, is sometimes called a â€˜worst-case complexity estimate,â€™
and itâ€™s easy to see why. If we have an algorithm that will, for example, sort any given sequence of numbers
into ascending order of size (see section 2.2) it may find that some sequences are easier to sort than others.
For instance, the sequence 1, 2, 7, 11, 10, 15, 20 is nearly in order already, so our algorithm might, if
it takes advantage of the near-order, sort it very rapidly. Other sequences might be a lot harder for it to
handle, and might therefore take more time.
Math. Soc., Providence, RI
2
0.2 Hard vs. easy problems
So in some problems whose input bit string has B bits the algorithm might operate in time 6B, and on
others it might need, say, 10B logB time units, and for still other problem instances of length B bits the
algorithm might need 5B2 time units to get the job done.
Well then, what would the warranty card say? It would have to pick out the worst possibility, otherwise
the guarantee wouldnâ€™t be valid. It would assure a user that if the input problem instance can be described
by B bits, then an answer will appear after at most 5B2 time units. Hence a performance guarantee is
equivalent to an estimation of the worst possible scenario: the longest possible calculation that might ensue
if B bits are input to the program.
Worst-case bounds are the most common kind, but there are other kinds of bounds for running time.
We might give an average case bound instead (see section 5.7). That wouldnâ€™t guarantee performance no
worse than so-and-so; it would state that if the performance is averaged over all possible input bit strings of
B bits, then the average amount of computing time will be so-and-so (as a function of B).
Now letâ€™s talk about the difference between easy and hard computational problems and between fast
and slow algorithms.
A warranty that would not guarantee â€˜fastâ€™ performance would contain some function of B that grows
faster than any polynomial. Like eB, for instance, or like 2
âˆš
B , etc. It is the polynomial time vs. not
necessarily polynomial time guarantee that makes the difference between the easy and the hard classes of
problems, or between the fast and the slow algorithms.
It is highly desirable to work with algorithms such that we can give a performance guarantee for their
running time that is at most a polynomial function of the number of bits of input.
An algorithm is slow if, whatever polynomial P we think of, there exist arbitrarily large values of B,
and input data strings of B bits, that cause the algorithm to do more than P (B) units of work.
A computational problem is tractable if there is a fast algorithm that will do all instances of it.
A computational problem is intractable if it can be proved that there is no fast algorithm for it.
Example 3. Here is a familiar computational problem and a method, or algorithm, for solving it. Letâ€™s see
if the method has a polynomial time guarantee or not.
The problem is this. Let n be a given integer. We want to find out if n is prime. The method that we
choose is the following. For each integer m = 2, 3, . . . , b
âˆš
nc we ask if m divides (evenly into) n. If all of the
answers are â€˜No,â€™ then we declare n to be a prime number, else it is composite.
We will now look at the computational complexity of this algorithm. That means that we are going to
find out how much work is involved in doing the test. For a given integer n the work that we have to do can
be measured in units of divisions of a whole number by another whole number. In those units, we obviously
will do about
âˆš
n units of work.
It seems as though this is a tractable problem, because, after all,
âˆš
n is of polynomial growth in n. For
instance, we do less than n units of work, and thatâ€™s certainly a polynomial in n, isnâ€™t it? So, according to
our definition of fast and slow algorithms, the distinction was made on the basis of polynomial vs. faster-
than-polynomial growth of the work done with the problem size, and therefore this problem must be easy.
Right? Well no, not really.
Reference to the distinction between fast and slow methods will show that we have to measure the
amount of work done as a function of the number of bits of input to the problem. In this example, n is not
the number of bits of input. For instance, if n = 59, we donâ€™t need 59 bits to describe n, but only 6. In
general, the number of binary digits in the bit string of an integer n is close to log2 n.
So in the problem of this example, testing the primality of a given integer n, the length of the input bit
string B is about log2 n. Seen in this light, the calculation suddenly seems very long. A string consisting of
a mere log2 n 0â€™s and 1â€™s has caused our mighty computer to do about
âˆš
n units of work.
If we express the amount of work done as a function of B, we find that the complexity of this calculation
is approximately 2B/2, and that grows much faster than any polynomial function of B.
Therefore, the method that we have just discussed for testing the primality of a given integer is slow.
See chapter 4 for further discussion of this problem. At the present time no one has found a fast way
to test for primality, nor has anyone proved that there isnâ€™t a fast way. Primality testing belongs to the
(well-populated) class of seemingly, but not provably, intractable problems.
In this book we will deal with some easy problems and some seemingly hard ones. Itâ€™s the â€˜seeminglyâ€™
that makes things very interesting. These are problems for which no one has found a fast computer algorithm,
3
Chapter 0: What This Book Is About
but also, no one has proved the impossibility of doing so. It should be added that the entire area is vigorously
being researched because of the attractiveness and the importance of the many unanswered questions that
remain.
Thus, even though we just donâ€™t know many things that weâ€™d like to know in this field , it isnâ€™t for lack
of trying!
0.3 A preview
Chapter 1 contains some of the mathematical background that will be needed for our study of algorithms.
It is not intended that reading this book or using it as a text in a course must necessarily begin with Chapter
1. Itâ€™s probably a better idea to plunge into Chapter 2 directly, and then when particular skills or concepts
are needed, to read the relevant portions of Chapter 1. Otherwise the definitions and ideas that are in that
chapter may seem to be unmotivated, when in fact motivation in great quantity resides in the later chapters
of the book.
Chapter 2 deals with recursive algorithms and the analyses of their complexities.
Chapter 3 is about a problem that seems as though it might be hard, but turns out to be easy, namely the
network flow problem. Thanks to quite recent research, there are fast algorithms for network flow problems,
and they have many important applications.
In Chapter 4 we study algorithms in one of the oldest branches of mathematics, the theory of num-
bers. Remarkably, the connections between this ancient subject and the most modern research in computer
methods are very strong.
In Chapter 5 we will see that there is a large family of problems, including a number of very important
computational questions, that are bound together by a good deal of structural unity. We donâ€™t know if
theyâ€™re hard or easy. We do know that we havenâ€™t found a fast way to do them yet, and most people suspect
that theyâ€™re hard. We also know that if any one of these problems is hard, then they all are, and if any one
of them is easy, then they all are.
We hope that, having found out something about what people know and what people donâ€™t know, the
reader will have enjoyed the trip through this subject and may be interested in helping to find out a little
more.
4
1.1 Orders of magnitude
Chapter 1: Mathematical Preliminaries
1.1 Orders of magnitude
In this section weâ€™re going to discuss the rates of growth of different functions and to introduce the five
symbols of asymptotics that are used to describe those rates of growth. In the context of algorithms, the
reason for this discussion is that we need a good language for the purpose of comparing the speeds with
which different algorithms do the same job, or the amounts of memory that they use, or whatever other
measure of the complexity of the algorithm we happen to be using.
Suppose we have a method of inverting square nonsingular matrices. How might we measure its speed?
Most commonly we would say something like â€˜if the matrix is nÃ—n then the method will run in time 16.8n3.â€™
Then we would know that if a 100Ã— 100 matrix can be inverted, with this method, in 1 minute of computer
time, then a 200 Ã— 200 matrix would require 23 = 8 times as long, or about 8 minutes. The constant â€˜16.8â€™
wasnâ€™t used at all in this example; only the fact that the labor grows as the third power of the matrix size
was relevant.
Hence we need a language that will allow us to say that the computing time, as a function of n, grows
â€˜on the order of n3,â€™ or â€˜at most as fast as n3,â€™ or â€˜at least as fast as n5 logn,â€™ etc.
The new symbols that are used in the language of comparing the rates of growth of functions are the
following five: â€˜oâ€™ (read â€˜is little oh ofâ€™), â€˜Oâ€™ (read â€˜is big oh ofâ€™), â€˜Î˜â€™ (read â€˜is theta ofâ€™), â€˜âˆ¼â€™ (read â€˜is
asymptotically equal toâ€™ or, irreverently, as â€˜twiddlesâ€™), and â€˜â„¦â€™ (read â€˜is omega ofâ€™).
Now letâ€™s explain what each of them means.
Let f(x) and g(x) be two functions of x. Each of the five symbols above is intended to compare the
rapidity of growth of f and g. If we say that f(x) = o(g(x)), then informally we are saying that f grows
more slowly than g does when x is very large. Formally, we state the
Definition. We say that f(x) = o(g(x)) (xâ†’ âˆž) if limxâ†’âˆž f(x)/g(x) exists and is equal to 0.
Here are some examples:
(a) x2 = o(x5)
(b) sinx = o(x)
(c) 14.709
âˆš
x = o(x/2 + 7 cosx)
(d) 1/x = o(1) (?)
(e) 23 logx = o(x.02)
We can see already from these few examples that sometimes it might be easy to prove that a â€˜oâ€™
relationship is true and sometimes it might be rather difficult. Example (e), for instance, requires the use of
Lâ€™Hospitalâ€™s rule.
If we have two computer programs, and if one of them inverts nÃ— n matrices in time 635n3 and if the
other one does so in time o(n2.8) then we know that for all sufficiently large values of n the performance
guarantee of the second program will be superior to that of the first program. Of course, the first program
might run faster on small matrices, say up to size 10, 000 Ã— 10, 000. If a certain program runs in time
n2.03 and if someone were to produce another program for the same problem that runs in o(n2 logn) time,
then that second program would be an improvement, at least in the theoretical sense. The reason for the
â€˜theoreticalâ€™ qualification, once more, is that the second program would be known to be superior only if n
were sufficiently large.
The second symbol of the asymptotics vocabulary is the â€˜O.â€™ When we say that f(x) = O(g(x)) we
mean, informally, that f certainly doesnâ€™t grow at a faster rate than g. It might grow at the same rate or it
might grow more slowly; both are possibilities that the â€˜Oâ€™ permits. Formally, we have the next
Definition. We say that f(x) = O(g(x)) (x â†’ âˆž) if âˆƒC, x0 such that |f(x)| < Cg(x) (âˆ€x > x0).
The qualifier â€˜x â†’ âˆžâ€™ will usually be omitted, since it will be understood that we will most often be
interested in large values of the variables that are involved.
For example, it is certainly true that sinx = O(x), but even more can be said, namely that sinx = O(1).
Also x3 + 5x2 + 77 cosx = O(x5) and 1/(1 + x2) = O(1). Now we can see how the â€˜oâ€™ gives more precise
information than the â€˜O,â€™ for we can sharpen the last example by saying that 1/(1 + x2) = o(1). This is
5
Chapter 1: Mathematical Preliminaries
sharper because not only does it tell us that the function is bounded when x is large, we learn that the
function actually approaches 0 as xâ†’ âˆž.
This is typical of the relationship between O and o. It often happens that a â€˜Oâ€™ result is sufficient for
an application. However, that may not be the case, and we may need the more precise â€˜oâ€™ estimate.
The third symbol of the language of asymptotics is the â€˜Î˜.â€™
Definition. We say that f(x) = Î˜(g(x)) if there are constants c1 > 0, c2 > 0, x0 such that for all x > x0
it is true that c1g(x) < f(x) < c2g(x).
We might then say that f and g are of the same rate of growth, only the multiplicative constants are
uncertain. Some examples of the â€˜Î˜â€™ at work are
(x+ 1)2 = Î˜(3x2)
(x2 + 5x+ 7)/(5x3 + 7x+ 2) = Î˜(1/x)
âˆš
3 +
âˆš
2x = Î˜(x
1
4 )
(1 + 3/x)x = Î˜(1).
The â€˜Î˜â€™ is much more precise than either the â€˜Oâ€™ or the â€˜o.â€™ If we know that f(x) = Î˜(x2), then we know
that f(x)/x2 stays between two nonzero constants for all sufficiently large values of x. The rate of growth
of f is established: it grows quadratically with x.
The most precise of the symbols of asymptotics is the â€˜âˆ¼.â€™ It tells us that not only do f and g grow at
the same rate, but that in fact f/g approaches 1 as xâ†’ âˆž.
Definition. We say that f(x) âˆ¼ g(x) if limxâ†’âˆž f(x)/g(x) = 1.
Here are some examples.
x2 + x âˆ¼ x2
(3x+ 1)4 âˆ¼ 81x4
sin 1/x âˆ¼ 1/x
(2x3 + 5x+ 7)/(x2 + 4) âˆ¼ 2x
2x + 7 logx+ cosx âˆ¼ 2x
Observe the importance of getting the multiplicative constants exactly right when the â€˜âˆ¼â€™ symbol is used.
While it is true that 2x2 = Î˜(x2), it is not true that 2x2 âˆ¼ x2. It is, by the way, also true that 2x2 = Î˜(17x2),
but to make such an assertion is to use bad style since no more information is conveyed with the â€˜17â€™ than
without it.
The last symbol in the asymptotic set that we will need is the â€˜â„¦.â€™ In a nutshell, â€˜â„¦â€™ is the negation of
â€˜o.â€™ That is to say, f(x) = â„¦(g(x)) means that it is not true that f(x) = o(g(x)). In the study of algorithms
for computers, the â€˜â„¦â€™ is used when we want to express the thought that a certain calculation takes at least
so-and-so long to do. For instance, we can multiply together two n Ã— n matrices in time O(n3). Later on
in this book we will see how to multiply two matrices even faster, in time O(n2.81). People know of even
faster ways to do that job, but one thing that we can be sure of is this: nobody will ever be able to write
a matrix multiplication program that will multiply pairs n Ã— n matrices with fewer than n2 computational
steps, because whatever program we write will have to look at the input data, and there are 2n2 entries in
the input matrices.
Thus, a computing time of cn2 is certainly a lower bound on the speed of any possible general matrix
multiplication program. We might say, therefore, that the problem of multiplying two nÃ—nmatrices requires
â„¦(n2) time.
The exact definition of the â€˜â„¦â€™ that was given above is actually rather delicate. We stated it as the
negation of something. Can we rephrase it as a positive assertion? Yes, with a bit of work (see exercises 6
and 7 below). Since â€˜f = o(g)â€™ means that f/g â†’ 0, the symbol f = â„¦(g) means that f/g does not approach
zero. If we assume that g takes positive values only, which is usually the case in practice, then to say that
f/g does not approach 0 is to say that âˆƒ > 0 and an infinite sequence of values of x, tending to âˆž, along
which |f |/g > . So we donâ€™t have to show that |f |/g >  for all large x, but only for infinitely many large
x.
6
1.1 Orders of magnitude
Definition. We say that f(x) = â„¦(g(x)) if there is an  > 0 and a sequence x1, x2, x3, . . . â†’ âˆž such that
âˆ€j : |f(xj)| > g(xj).
Now letâ€™s introduce a hierarchy of functions according to their rates of growth when x is large. Among
commonly occurring functions of x that grow without bound as xâ†’ âˆž, perhaps the slowest growing ones are
functions like log logx or maybe (log logx)1.03 or things of that sort. It is certainly true that log logxâ†’ âˆž
as xâ†’ âˆž, but it takes its time about it. When x = 1, 000, 000, for example, log logx has the value 2.6.
Just a bit faster growing than the â€˜snailsâ€™ above is logx itself. After all, log (1, 000, 000) = 13.8. So if
we had a computer algorithm that could do n things in time logn and someone found another method that
could do the same job in time O(log logn), then the second method, other things being equal, would indeed
be an improvement, but n might have to be extremely large before you would notice the improvement.
Next on the scale of rapidity of growth we might mention the powers of x. For instance, think about
x.01. It grows faster than logx, although you wouldnâ€™t believe it if you tried to substitute a few values of x
and to compare the answers (see exercise 1 at the end of this section).
How would we prove that x.01 grows faster than logx? By using Lâ€™Hospitalâ€™s rule.
Example. Consider the limit of x.01/logx for xâ†’ âˆž. As xâ†’ âˆž the ratio assumes the indeterminate form
âˆž/âˆž, and it is therefore a candidate for Lâ€™Hospitalâ€™s rule, which tells us that if we want to find the limit
then we can differentiate the numerator, differentiate the denominator, and try again to let x â†’ âˆž. If we
do this, then instead of the original ratio, we find the ratio
.01xâˆ’.99/(1/x) = .01x.01
which obviously grows without bound as xâ†’ âˆž. Therefore the original ratio x.01/logx also grows without
bound. What we have proved, precisely, is that logx = o(x.01), and therefore in that sense we can say that
x.01 grows faster than logx.
To continue up the scale of rates of growth, we meet x.2, x, x15, x15 log2 x, etc., and then we encounter
functions that grow faster than every fixed power of x, just as logx grows slower than every fixed power of
x.
Consider elog
2 x. Since this is the same as xlogx it will obviously grow faster than x1000, in fact it will
be larger than x1000 as soon as logx > 1000, i.e., as soon as x > e1000 (donâ€™t hold your breath!).
Hence elog
2 x is an example of a function that grows faster than every fixed power of x. Another such
example is e
âˆš
x (why?).
Definition. A function that grows faster than xa, for every constant a, but grows slower than cx for
every constant c > 1 is said to be of moderately exponential growth. More precisely, f(x) is of moderately
exponential growth if for every a > 0 we have f(x) = â„¦(xa) and for every  > 0 we have f(x) = o((1 + )x).
Beyond the range of moderately exponential growth are the functions that grow exponentially fast.
Typical of such functions are (1.03)x, 2x, x97x, and so forth. Formally, we have the
Definition. A function f is of exponential growth if there exists c > 1 such that f(x) = â„¦(cx) and there
exists d such that f(x) = O(dx).
If we clutter up a function of exponential growth with smaller functions then we will not change the
fact that it is of exponential growth. Thus e
âˆš
x+2x/(x49 + 37) remains of exponential growth, because e2x is,
all by itself, and it resists the efforts of the smaller functions to change its mind.
Beyond the exponentially growing functions there are functions that grow as fast as you might please.
Like n!, for instance, which grows faster than cn for every fixed constant c, and like 2n
2
, which grows much
faster than n!. The growth ranges that are of the most concern to computer scientists are â€˜betweenâ€™ the very
slowly, logarithmically growing functions and the functions that are of exponential growth. The reason is
simple: if a computer algorithm requires more than an exponential amount of time to do its job, then it will
probably not be used, or at any rate it will be used only in highly unusual circumstances. In this book, the
algorithms that we will deal with all fall in this range.
Now we have discussed the various symbols of asymptotics that are used to compare the rates of growth
of pairs of functions, and we have discussed the pecking order of rapidity of growth, so that we have a small
catalogue of functions that grow slowly, medium-fast, fast, and super-fast. Next letâ€™s look at the growth of
sums that involve elementary functions, with a view toward discovering the rates at which the sums grow.
7
Chapter 1: Mathematical Preliminaries
Think about this one:
f(n) =
nâˆ‘
j=0
j2
= 12 + 22 + 32 + Â· Â· Â·+ n2.
(1.1.1)
Thus, f(n) is the sum of the squares of the first n positive integers. How fast does f(n) grow when n is
large?
Notice at once that among the n terms in the sum that defines f(n), the biggest one is the last one,
namely n2. Since there are n terms in the sum and the biggest one is only n2, it is certainly true that
f(n) = O(n3), and even more, that f(n) â‰¤ n3 for all n â‰¥ 1.
Suppose we wanted more precise information about the growth of f(n), such as a statement like f(n) âˆ¼ ?.
How might we make such a better estimate?
The best way to begin is to visualize the sum in (1.1.1) as shown in Fig. 1.1.1.
Fig. 1.1.1: How to overestimate a sum
In that figure we see the graph of the curve y = x2, in the x-y plane. Further, there is a rectangle drawn
over every interval of unit length in the range from x = 1 to x = n. The rectangles all lie under the curve.
Consequently, the total area of all of the rectangles is smaller than the area under the curve, which is to say
that
nâˆ’1âˆ‘
j=1
j2 â‰¤
âˆ« n
1
x2dx
= (n3 âˆ’ 1)/3.
(1.1.2)
If we compare (1.1.2) and (1.1.1) we notice that we have proved that f(n) â‰¤ ((n+ 1)3 âˆ’ 1)/3.
Now weâ€™re going to get a lower bound on f(n) in the same way. This time we use the setup in Fig.
1.1.2, where we again show the curve y = x2, but this time we have drawn the rectangles so they lie above
the curve.
From the picture we see immediately that
12 + 22 + Â· Â· Â·+ n2 â‰¥
âˆ« n
0
x2dx
= n3/3.
(1.1.3)
Now our function f(n) has been bounded on both sides, rather tightly. What we know about it is that
âˆ€n â‰¥ 1 : n3/3 â‰¤ f(n) â‰¤ ((n+ 1)3 âˆ’ 1)/3.
From this we have immediately that f(n) âˆ¼ n3/3, which gives us quite a good idea of the rate of growth of
f(n) when n is large. The reader will also have noticed that the â€˜âˆ¼â€™ gives a much more satisfying estimate
of growth than the â€˜Oâ€™ does.
8
1.1 Orders of magnitude
Fig. 1.1.2: How to underestimate a sum
Letâ€™s formulate a general principle, for estimating the size of a sum, that will make estimates like the
above for us without requiring us each time to visualize pictures like Figs. 1.1.1 and 1.1.2. The general idea
is that when one is faced with estimating the rates of growth of sums, then one should try to compare the
sums with integrals because theyâ€™re usually easier to deal with.
Let a function g(n) be defined for nonnegative integer values of n, and suppose that g(n) is nondecreasing.
We want to estimate the growth of the sum
G(n) =
nâˆ‘
j=1
g(j) (n = 1, 2, . . .). (1.1.4)
Consider a diagram that looks exactly like Fig. 1.1.1 except that the curve that is shown there is now the
curve y = g(x). The sum of the areas of the rectangles is exactly G(n âˆ’ 1), while the area under the curve
between 1 and n is
âˆ« n
1
g(t)dt. Since the rectangles lie wholly under the curve, their combined areas cannot
exceed the area under the curve, and we have the inequality
G(nâˆ’ 1) â‰¤
âˆ« n
1
g(t)dt (n â‰¥ 1). (1.1.5)
On the other hand, if we consider Fig. 1.1.2, where the graph is once more the graph of y = g(x),
the fact that the combined areas of the rectangles is now not less than the area under the curve yields the
inequality
G(n) â‰¥
âˆ« n
0
g(t)dt (n â‰¥ 1). (1.1.6)
If we combine (1.1.5) and (1.1.6) we find that we have completed the proof of
Theorem 1.1.1. Let g(x) be nondecreasing for nonnegative x. Then
âˆ« n
0
g(t)dt â‰¤
nâˆ‘
j=1
g(j) â‰¤
âˆ« n+1
1
g(t)dt. (1.1.7)
The above theorem is capable of producing quite satisfactory estimates with rather little labor, as the
following example shows.
Let g(n) = logn and substitute in (1.1.7). After doing the integrals, we obtain
n lognâˆ’ n â‰¤
nâˆ‘
j=1
log j â‰¤ (n + 1) log (n + 1) âˆ’ n. (1.1.8)
9
Chapter 1: Mathematical Preliminaries
We recognize the middle member above as logn!, and therefore by exponentiation of (1.1.8) we have
(
n
e
)n â‰¤ n! â‰¤ (n+ 1)
n+1
en
. (1.1.9)
This is rather a good estimate of the growth of n!, since the right member is only about ne times as large as
the left member (why?), when n is large.
By the use of slightly more precise machinery one can prove a better estimate of the size of n! that is
called Stirlingâ€™s formula, which is the statement that
x! âˆ¼ (x
e
)x
âˆš
2xÏ€. (1.1.10)
Exercises for section 1.1
1. Calculate the values of x.01 and of logx for x = 10, 1000, 1,000,000. Find a single value of x > 10 for
which x.01 > logx, and prove that your answer is correct.
2. Some of the following statements are true and some are false. Which are which?
(a) (x2 + 3x+ 1)3 âˆ¼ x6
(b) (
âˆš
x+ 1)3/(x2 + 1) = o(1)
(c) e1/x = Î˜(1)
(d) 1/x âˆ¼ 0
(e) x3(log logx)2 = o(x3 logx)
(f)
âˆš
logx+ 1 = â„¦(log logx)
(g) sinx = â„¦(1)
(h) cos x/x = O(1)
(i)
âˆ« x
4
dt/t âˆ¼ logx
(j)
âˆ« x
0
eâˆ’t
2
dt = O(1)
(k)
âˆ‘
jâ‰¤x 1/j
2 = o(1)
(l)
âˆ‘
jâ‰¤x 1 âˆ¼ x
3. Each of the three sums below defines a function of x. Beneath each sum there appears a list of five
assertions about the rate of growth, as x â†’ âˆž, of the function that the sum defines. In each case state
which of the five choices, if any, are true (note: more than one choice may be true).
h1(x) =
âˆ‘
jâ‰¤x
{1/j + 3/j2 + 4/j3}
(i) âˆ¼ logx (ii) = O(x) (iii) âˆ¼ 2 logx (iv) = Î˜(logx) (v) = â„¦(1)
h2(x) =
âˆ‘
jâ‰¤
âˆš
x
{log j + j}
(i) âˆ¼ x/2 (ii) = O(
âˆš
x) (iii) = Î˜(
âˆš
x logx) (iv) = â„¦(
âˆš
x) (v) = o(
âˆš
x)
h3(x) =
âˆ‘
jâ‰¤
âˆš
x
1/
âˆš
j
(i) = O(
âˆš
x) (ii) = â„¦(x1/4) (iii) = o(x1/4) (iv) âˆ¼ 2x1/4 (v) = Î˜(x1/4)
4. Of the five symbols of asymptotics O, o,âˆ¼,Î˜,â„¦, which ones are transitive (e.g., if f = O(g) and g = O(h),
is f = O(h)?)?
5. The point of this exercise is that if f grows more slowly than g, then we can always find a third function
h whose rate of growth is between that of f and of g. Precisely, prove the following: if f = o(g) then there
10
1.2 Positional number systems
is a function h such that f = o(h) and h = o(g). Give an explicit construction for the function h in terms
of f and g.
6. {This exercise is a warmup for exercise 7.} Below there appear several mathematical propositions. In
each case, write a proposition that is the negation of the given one. Furthermore, in the negation, do not use
the word â€˜notâ€™ or any negation symbols. In each case the question is, â€˜If this isnâ€™t true, then what is true?â€™
(a) âˆƒx > 0 3 f(x) 6= 0
(b) âˆ€x > 0, f(x) > 0
(c) âˆ€x > 0, âˆƒ > 0 3 f(x) < 
(d) âˆƒx 6= 0 3 âˆ€y < 0, f(y) < f(x)
(e) âˆ€x âˆƒy 3 âˆ€z : g(x) < f(y)f(z)
(f) âˆ€ > 0 âˆƒx 3 âˆ€y > x : f(y) < 
Can you formulate a general method for negating such propositions? Given a proposition that contains â€˜âˆ€,â€™
â€˜âˆƒ,â€™ â€˜3,â€™ what rule would you apply in order to negate the proposition and leave the result in positive form
(containing no negation symbols or â€˜notâ€™s).
7. In this exercise we will work out the definition of the â€˜â„¦.â€™
(a) Write out the precise definition of the statement â€˜limxâ†’âˆž h(x) = 0â€™ (use â€˜â€™s).
(b) Write out the negation of your answer to part (a), as a positive assertion.
(c) Use your answer to part (b) to give a positive definition of the assertion â€˜f(x) 6= o(g(x)),â€™ and
thereby justify the definition of the â€˜â„¦â€™ symbol that was given in the text.
8. Arrange the following functions in increasing order of their rates of growth, for large n. That is, list them
so that each one is â€˜little ohâ€™ of its successor:
2
âˆš
n, elog n
3
, n3.01, 2n
2
,
n1.6, logn3 + 1,
âˆš
n!, n3 log n,
n3 logn, (log logn)3, n.52n, (n+ 4)12
9. Find a function f(x) such that f(x) = O(x1+) is true for every  > 0, but for which it is not true that
f(x) = O(x).
10. Prove that the statement â€˜f(n) = O((2 + )n) for every  > 0â€™ is equivalent to the statement â€˜f(n) =
o((2 + )n) for every  > 0.â€™
1.2 Positional number systems
This section will provide a brief review of the representation of numbers in different bases. The usual
decimal system represents numbers by using the digits 0, 1, . . ., 9. For the purpose of representing whole
numbers we can imagine that the powers of 10 are displayed before us like this:
. . . , 100000, 10000,1000, 100,10,1.
Then, to represent an integer we can specify how many copies of each power of 10 we would like to have. If
we write 237, for example, then that means that we want 2 100â€™s and 3 10â€™s and 7 1â€™s.
In general, if we write out the string of digits that represents a number in the decimal system, as
dmdmâˆ’1 Â· Â· Â·d1d0, then the number that is being represented by that string of digits is
n =
mâˆ‘
i=0
di10i.
Now letâ€™s try the binary system. Instead of using 10â€™s weâ€™re going to use 2â€™s. So we imagine that the
powers of 2 are displayed before us, as
. . . , 512, 256, 128,64,32,16,8,4,2, 1.
11
Chapter 1: Mathematical Preliminaries
To represent a number we will now specify how many copies of each power of 2 we would like to have. For
instance, if we write 1101, then we want an 8, a 4 and a 1, so this must be the decimal number 13. We will
write
(13)10 = (1101)2
to mean that the number 13, in the base 10, is the same as the number 1101, in the base 2.
In the binary system (base 2) the only digits we will ever need are 0 and 1. What that means is that if
we use only 0â€™s and 1â€™s then we can represent every number n in exactly one way. The unique representation
of every number, is, after all, what we must expect and demand of any proposed system.
Letâ€™s elaborate on this last point. If we were allowed to use more digits than just 0â€™s and 1â€™s then we
would be able to represent the number (13)10 as a binary number in a whole lot of ways. For instance, we
might make the mistake of allowing digits 0, 1, 2, 3. Then 13 would be representable by 3 Â· 22 + 1 Â· 20 or by
2 Â· 22 + 2 Â· 21 + 1 Â· 20 etc.
So if we were to allow too many different digits, then numbers would be representable in more than one
way by a string of digits.
If we were to allow too few different digits then we would find that some numbers have no representation
at all. For instance, if we were to use the decimal system with only the digits 0, 1, . . ., 8, then infinitely many
numbers would not be able to be represented, so we had better keep the 9â€™s.
The general proposition is this.
Theorem 1.2.1. Let b > 1 be a positive integer (the â€˜baseâ€™). Then every positive integer n can be written
in one and only one way in the form
n = d0 + d1b+ d2b2 + d3b3 + Â· Â· Â·
if the digits d0, d1, . . . lie in the range 0 â‰¤ di â‰¤ bâˆ’ 1, for all i.
Remark: The theorem says, for instance, that in the base 10 we need the digits 0, 1, 2, . . . , 9, in the base
2 we need only 0 and 1, in the base 16 we need sixteen digits, etc.
Proof of the theorem: If b is fixed, the proof is by induction on n, the number being represented. Clearly
the number 1 can be represented in one and only one way with the available digits (why?). Suppose,
inductively, that every integer 1, 2, . . . , nâˆ’ 1 is uniquely representable. Now consider the integer n. Define
d = n mod b. Then d is one of the b permissible digits. By induction, the number nâ€² = (nâˆ’ d)/b is uniquely
representable, say
nâˆ’ d
b
= d0 + d1b+ d2b2 + . . .
Then clearly,
n = d+
nâˆ’ d
b
b
= d+ d0b+ d1b2 + d2b3 + . . .
is a representation of n that uses only the allowed digits.
Finally, suppose that n has some other representation in this form also. Then we would have
n = a0 + a1b+ a2b2 + . . .
= c0 + c1b+ c2b2 + . . .
Since a0 and c0 are both equal to n mod b, they are equal to each other. Hence the number nâ€² = (nâˆ’ a0)/b
has two different representations, which contradicts the inductive assumption, since we have assumed the
truth of the result for all nâ€² < n.
The bases b that are the most widely used are, aside from 10, 2 (â€˜binary systemâ€™), 8 (â€˜octal systemâ€™)
and 16 (â€˜hexadecimal systemâ€™).
The binary system is extremely simple because it uses only two digits. This is very convenient if youâ€™re
a computer or a computer designer, because the digits can be determined by some component being either
â€˜onâ€™ (digit 1) or â€˜offâ€™ (digit 0). The binary digits of a number are called its bits or its bit string.
12
1.2 Positional number systems
The octal system is popular because it provides a good way to remember and deal with the long bit
strings that the binary system creates. According to the theorem, in the octal system the digits that we
need are 0, 1, . . . , 7. For instance,
(735)8 = (477)10.
The captivating feature of the octal system is the ease with which we can convert between octal and binary.
If we are given the bit string of an integer n, then to convert it to octal, all we have to do is to group the
bits together in groups of three, starting with the least significant bit, then convert each group of three bits,
independently of the others, into a single octal digit. Conversely, if the octal form of n is given, then the
binary form is obtainable by converting each octal digit independently into the three bits that represent it
in the binary system.
For example, given (1101100101)2. To convert this binary number to octal, we group the bits in threes,
(1)(101)(100)(101)
starting from the right, and then we convert each triple into a single octal digit, thereby getting
(1101100101)2 = (1545)8.
If youâ€™re a working programmer itâ€™s very handy to use the shorter octal strings to remember, or to write
down, the longer binary strings, because of the space saving, coupled with the ease of conversion back and
forth.
The hexadecimal system (base 16) is like octal, only more so. The conversion back and forth to binary
now uses groups of four bits, rather than three. In hexadecimal we will need, according to the theorem
above, 16 digits. We have handy names for the first 10 of these, but what shall we call the â€˜digits 10 through
15â€™? The names that are conventionally used for them are â€˜A,â€™ â€˜B,â€™...,â€˜F.â€™ We have, for example,
(A52C)16 = 10(4096) + 5(256) + 2(16) + 12
= (42284)10
= (1010)2(0101)2(0010)2(1100)2
= (1010010100101100)2
= (1)(010)(010)(100)(101)(100)
= (122454)8.
Exercises for section 1.2
1. Prove that conversion from octal to binary is correctly done by converting each octal digit to a binary
triple and concatenating the resulting triples. Generalize this theorem to other pairs of bases.
2. Carry out the conversions indicated below.
(a) (737)10 = (?)3
(b) (101100)2 = (?)16
(c) (3377)8 = (?)16
(d) (ABCD)16 = (?)10
(e) (BEEF )16 = (?)8
3. Write a procedure convert (n, b:integer, digitstr:string), that will find the string of digits that represents
n in the base b.
13
Chapter 1: Mathematical Preliminaries
1.3 Manipulations with series
In this section we will look at operations with power series, including multiplying them and finding their
sums in simple form. We begin with a little catalogue of some power series that are good to know. First we
have the finite geometric series
(1 âˆ’ xn)/(1 âˆ’ x) = 1 + x+ x2 + Â· Â· Â·+ xnâˆ’1. (1.3.1)
This equation is valid certainly for all x 6= 1, and it remains true when x = 1 also if we take the limit
indicated on the left side.
Why is (1.3.1) true? Just multiply both sides by 1 âˆ’ x to clear of fractions. The result is
1 âˆ’ xn = (1 + x+ x2 + x3 + Â· Â· Â·+ xnâˆ’1)(1 âˆ’ x)
= (1 + x+ x2 + Â· Â· Â·+ xnâˆ’1) âˆ’ (x+ x2 + x3 + Â· Â· Â·+ xn)
= 1 âˆ’ xn
and the proof is finished.
Now try this one. What is the value of the sum
9âˆ‘
j=0
3j ?
Observe that we are looking at the right side of (1.3.1) with x = 3. Therefore the answer is (310 âˆ’ 1)/2. Try
to get used to the idea that a series in powers of x becomes a number if x is replaced by a number, and if
we know a formula for the sum of the series then we know the number that it becomes.
Here are some more series to keep in your zoo. A parenthetical remark like â€˜(|x| < 1)â€™ shows the set of
values of x for which the series converges.
âˆžâˆ‘
k=0
xk = 1/(1âˆ’ x) (|x| < 1) (1.3.2)
ex =
âˆžâˆ‘
m=0
xm/m! (1.3.3)
sinx =
âˆžâˆ‘
r=0
(âˆ’1)rx2r+1/(2r + 1)! (1.3.4)
cos x =
âˆžâˆ‘
s=0
(âˆ’1)sx2s/(2s)! (1.3.5)
log (1/(1âˆ’ x)) =
âˆžâˆ‘
j=1
xj/j (|x| < 1) (1.3.6)
Can you find a simple form for the sum (the logarithms are â€˜naturalâ€™)
1 + log2 + (log2)2/2! + (log2)3/3! + Â· Â· Â·?
Hint: Look at (1.3.3), and replace x by log 2.
Aside from merely substituting values of x into known series, there are many other ways of using known
series to express sums in simple form. Letâ€™s think about the sum
1 + 2 Â· 2 + 3 Â· 4 + 4 Â· 8 + 5 Â· 16 + Â· Â· Â·+N2Nâˆ’1. (1.3.7)
14
1.3 Manipulations with series
We are reminded of the finite geometric series (1.3.1), but (1.3.7) is a little different because of the multipliers
1, 2, 3, 4, . . ., N .
The trick is this. When confronted with a series that is similar to, but not identical with, a known
series, write down the known series as an equation, with the series on one side and its sum on the other.
Even though the unknown series involves a particular value of x, in this case x = 2, keep the known series
with its variable unrestricted. Then reach for an appropriate tool that will be applied to both sides of that
equation, and whose result will be that the known series will have been changed into the one whose sum we
needed.
In this case, since (1.3.7) reminds us of (1.3.1), weâ€™ll begin by writing down (1.3.1) again,
(1 âˆ’ xn)/(1 âˆ’ x) = 1 + x+ x2 + Â· Â· Â·+ xnâˆ’1 (1.3.8)
Donâ€™t replace x by 2 yet, just walk up to the equation (1.3.8) carrying your tool kit and ask what kind
of surgery you could do to both sides of (1.3.8) that would be helpful in evaluating the unknown (1.3.7).
We are going to reach into our tool kit and pull out â€˜ d
dx
.â€™ In other words, we are going to differentiate
(1.3.8). The reason for choosing differentiation is that it will put the missing multipliers 1, 2, 3, . . ., N into
(1.3.8). After differentiation, (1.3.8) becomes
1 + 2x+ 3x2 + 4x3 + Â· Â· Â·+ (nâˆ’ 1)xnâˆ’2 = 1 âˆ’ nx
nâˆ’1 + (nâˆ’ 1)xn
(1 âˆ’ x)2 . (1.3.9)
Now itâ€™s easy. To evaluate the sum (1.3.7), all we have to do is to substitute x = 2, n = N + 1 in (1.3.9), to
obtain, after simplifying the right-hand side,
1 + 2 Â· 2 + 3 Â· 4 + 4 Â· 8 + Â· Â· Â·+N2Nâˆ’1 = 1 + (N âˆ’ 1)2N . (1.3.10)
Next try this one:
1
2 Â· 32
+
1
3 Â· 33
+ Â· Â· Â· (1.3.11)
If we rewrite the series using summation signs, it becomes
âˆžâˆ‘
j=2
1
j Â· 3j .
Comparison with the series zoo shows great resemblance to the species (1.3.6). In fact, if we put x = 1/3 in
(1.3.6) it tells us that
âˆžâˆ‘
j=1
1
j Â· 3j
= log (3/2). (1.3.12)
The desired sum (1.3.11) is the result of dropping the term with j = 1 from (1.3.12), which shows that the
sum in (1.3.11) is equal to log (3/2) âˆ’ 1/3.
In general, suppose that f(x) =
âˆ‘
anx
n is some series that we know. Then
âˆ‘
nanx
nâˆ’1 = f â€²(x) andâˆ‘
nanx
n = xf â€²(x). In other words, if the nth coefficient is multiplied by n, then the function changes from
f to (x d
dx
)f . If we apply the rule again, we find that multiplying the nth coefficient of a power series by n2
changes the sum from f to (x d
dx
)2f . That is,
âˆžâˆ‘
j=0
j2xj/j! = (x
d
dx
)(x
d
dx
)ex
= (x
d
dx
)(xex)
= (x2 + x)ex.
15
Chapter 1: Mathematical Preliminaries
Similarly, multiplying the nth coefficient of a power series by np will change the sum from f(x) to
(x d
dx
)pf(x), but thatâ€™s not all. What happens if we multiply the coefficient of xn by, say, 3n2 + 2n + 5? If
the sum previously was f(x), then it will be changed to {3(x d
dx
)2 + 2(x d
dx
) + 5}f(x). The sum
âˆžâˆ‘
j=0
(2j2 + 5)xj
is therefore equal to {2(x ddx )
2 + 5}{1/(1âˆ’x)}, and after doing the differentiations we find the answer in the
form (7x2 âˆ’ 8x+ 5)/(1 âˆ’ x)3.
Here is the general rule: if P (x) is any polynomial then
âˆ‘
j
P (j)ajxj = P (x
d
dx
){
âˆ‘
j
ajx
j}. (1.3.13)
Exercises for section 1.3
1. Find simple, explicit formulas for the sums of each of the following series.
(a)
âˆ‘
jâ‰¥3 log 6
j/j!
(b)
âˆ‘
m>1(2m+ 7)/5
m
(c)
âˆ‘19
j=0(j/2
j)
(d) 1 âˆ’ x/2! + x2/4! âˆ’ x3/6! + Â· Â· Â·
(e) 1 âˆ’ 1/32 + 1/34 âˆ’ 1/36 + Â· Â· Â·
(f)
âˆ‘âˆž
m=2(m
2 + 3m + 2)/m!
2. Explain why
âˆ‘
râ‰¥0(âˆ’1)rÏ€2r+1/(2r + 1)! = 0.
3. Find the coefficient of tn in the series expansion of each of the following functions about t = 0.
(a) (1 + t+ t2)et
(b) (3tâˆ’ t2) sin t
(c) (t+ 1)2/(t âˆ’ 1)2
1.4 Recurrence relations
A recurrence relation is a formula that permits us to compute the members of a sequence one after
another, starting with one or more given values.
Here is a small example. Suppose we are to find an infinite sequence of numbers x0, x1, . . . by means of
xn+1 = cxn (n â‰¥ 0; x0 = 1). (1.4.1)
This relation tells us that x1 = cx0, and x2 = cx1, etc., and furthermore that x0 = 1. It is then clear that
x1 = c, x2 = c2, . . . , xn = cn, . . .
We say that the solution of the recurrence relation (= â€˜difference equationâ€™) (1.4.1) is given by xn = cn
for all n â‰¥ 0. Equation (1.4.1) is a first-order recurrence relation because a new value of the sequence is
computed from just one preceding value (i.e., xn+1 is obtained solely from xn, and does not involve xnâˆ’1 or
any earlier values).
Observe the format of the equation (1.4.1). The parenthetical remarks are essential. The first one
â€˜n â‰¥ 0â€™ tells us for what values of n the recurrence formula is valid, and the second one â€˜x0 = 1â€™ gives the
starting value. If one of these is missing, the solution may not be uniquely determined. The recurrence
relation
xn+1 = xn + xnâˆ’1 (1.4.2)
needs two starting values in order to â€˜get going,â€™ but it is missing both of those starting values and the range
of n. Consequently (1.4.2) (which is a second-order recurrence) does not uniquely determine the sequence.
16
1.4 Recurrence relations
The situation is rather similar to what happens in the theory of ordinary differential equations. There,
if we omit initial or boundary values, then the solutions are determined only up to arbitrary constants.
Beyond the simple (1.4.1), the next level of difficulty occurs when we consider a first-order recurrence
relation with a variable multiplier, such as
xn+1 = bn+1xn (n â‰¥ 0; x0 given). (1.4.3)
Now {b1, b2, . . .} is a given sequence, and we are being asked to find the unknown sequence {x1, x2, . . .}.
In an easy case like this we can write out the first few xâ€™s and then guess the answer. We find, successively,
that x1 = b1x0, then x2 = b2x1 = b2b1x0 and x3 = b3x2 = b3b2b1x0 etc. At this point we can guess that the
solution is
xn = {
nâˆ
i=1
bi}x0 (n = 0, 1, 2, . . .). (1.4.4)
Since that wasnâ€™t hard enough, weâ€™ll raise the ante a step further. Suppose we want to solve the
first-order inhomogeneous (because xn = 0 for all n is not a solution) recurrence relation
xn+1 = bn+1xn + cn+1 (n â‰¥ 0; x0 given). (1.4.5)
Now we are being given two sequences b1, b2, . . . and c1, c2, . . ., and we want to find the xâ€™s. Suppose we
follow the strategy that has so far won the game, that is, writing down the first few xâ€™s and trying to guess
the pattern. Then we would find that x1 = b1x0 + c1, x2 = b2b1x0 + b2c1 + c2, and we would probably tire
rapidly.
Here is a somewhat more orderly approach to (1.4.5). Though no approach will avoid the unpleasant
form of the general answer, the one that we are about to describe at least gives a method that is much
simpler than the guessing strategy, for many examples that arise in practice. In this book we are going to
run into several equations of the type of (1.4.5), so a unified method will be a definite asset.
The first step is to define a new unknown function as follows. Let
xn = b1b2 Â· Â· Â· bnyn (n â‰¥ 1; x0 = y0) (1.4.6)
define a new unknown sequence y1, y2, . . . Now substitute for xn in (1.4.5), getting
b1b2 Â· Â· Â·bn+1yn+1 = bn+1b1b2 Â· Â· Â· bnyn + cn+1.
We notice that the coefficients of yn+1 and of yn are the same, and so we divide both sides by that coefficient.
The result is the equation
yn+1 = yn + dn+1 (n â‰¥ 0; y0 given) (1.4.7)
where we have written dn+1 = cn+1/(b1 Â· Â· Â·bn+1). Notice that the dâ€™s are known.
We havenâ€™t yet solved the recurrence relation. We have only changed to a new unknown function that
satisfies a simpler recurrence (1.4.7). Now the solution of (1.4.7) is quite simple, because it says that each y
is obtained from its predecessor by adding the next one of the dâ€™s. It follows that
yn = y0 +
nâˆ‘
j=1
dj (n â‰¥ 0).
We can now use (1.4.6) to reverse the change of variables to get back to the original unknowns x0, x1, . . .,
and find that
xn = (b1b2 Â· Â· Â·bn){x0 +
nâˆ‘
j=1
dj} (n â‰¥ 1). (1.4.8)
It is not recommended that the reader memorize the solution that we have just obtained. It is recom-
mended that the method by which the solution was found be mastered. It involves
(a) make a change of variables that leads to a new recurrence of the form (1.4.6), then
17
Chapter 1: Mathematical Preliminaries
(b) solve that one by summation and
(c) go back to the original unknowns.
As an example, consider the first-order equation
xn+1 = 3xn + n (n â‰¥ 0; x0 = 0). (1.4.9)
The winning change of variable, from (1.4.6), is to let xn = 3nyn. After substituting in (1.4.9) and simplifying,
we find
yn+1 = yn + n/3n+1 (n â‰¥ 0; y0 = 0).
Now by summation,
yn =
nâˆ’1âˆ‘
j=1
j/3j+1 (n â‰¥ 0).
Finally, since xn = 3nyn we obtain the solution of (1.4.9) in the form
xn = 3n
nâˆ’1âˆ‘
j=1
j/3j+1 (n â‰¥ 0). (1.4.10)
This is quite an explicit answer, but the summation can, in fact, be completely removed by the same method
that you used to solve exercise 1(c) of section 1.3 (try it!).
That pretty well takes care of first-order recurrence relations of the form xn+1 = bn+1xn + cn+1, and
itâ€™s time to move on to linear second order (homogeneous) recurrence relations with constant coefficients.
These are of the form
xn+1 = axn + bxnâˆ’1 (n â‰¥ 1; x0 and x1 given). (1.4.11)
If we think back to differential equations of second-order with constant coefficients, we recall that there
are always solutions of the form y(t) = eÎ±t where Î± is constant. Hence the road to the solution of such a
differential equation begins by trying a solution of that form and seeing what the constant or constants Î±
turn out to be.
Analogously, equation (1.4.11) calls for a trial solution of the form xn = Î±n. If we substitute xn = Î±n
in (1.4.11) and cancel a common factor of Î±nâˆ’1 we obtain a quadratic equation for Î±, namely
Î±2 = aÎ±+ b. (1.4.12)
â€˜Usuallyâ€™ this quadratic equation will have two distinct roots, say Î±+ and Î±âˆ’, and then the general solution
of (1.4.11) will look like
xn = c1Î±n+ + c2Î±
n
âˆ’ (n = 0, 1, 2, . . .). (1.4.13)
The constants c1 and c2 will be determined so that x0, x1 have their assigned values.
Example. The recurrence for the Fibonacci numbers is
Fn+1 = Fn + Fnâˆ’1 (n â‰¥ 1; F0 = F1 = 1). (1.4.14)
Following the recipe that was described above, we look for a solution in the form Fn = Î±n. After substituting
in (1.4.14) and cancelling common factors we find that the quadratic equation for Î± is, in this case, Î±2 = Î±+1.
If we denote the two roots by Î±+ = (1 +
âˆš
5)/2 and Î±âˆ’ = (1 âˆ’
âˆš
5)/2, then the general solution to the
Fibonacci recurrence has been obtained, and it has the form (1.4.13). It remains to determine the constants
c1, c2 from the initial conditions F0 = F1 = 1.
From the form of the general solution we have F0 = 1 = c1 + c2 and F1 = 1 = c1Î±+ + c2Î±âˆ’. If we solve
these two equations in the two unknowns c1, c2 we find that c1 = Î±+/
âˆš
5 and c2 = âˆ’Î±âˆ’/
âˆš
5. Finally, we
substitute these values of the constants into the form of the general solution, and obtain an explicit formula
for the nth Fibonacci number,
Fn =
1âˆš
5
{(
1 +
âˆš
5
2
)n+1
âˆ’
(
1 âˆ’
âˆš
5
2
)n+1}
(n = 0, 1, . . .). (1.4.15)
18
1.4 Recurrence relations
The Fibonacci numbers are in fact 1, 1, 2, 3, 5,8, 13, 21, 34, . . . It isnâ€™t even obvious that the formula
(1.4.15) gives integer values for the Fnâ€™s. The reader should check that the formula indeed gives the first few
Fnâ€™s correctly.
Just to exercise our newly acquired skills in asymptotics, letâ€™s observe that since (1 +
âˆš
5)/2 > 1 and
|(1 âˆ’
âˆš
5)/2| < 1, it follows that when n is large we have
Fn âˆ¼ ((1 +
âˆš
5)/2)n+1/
âˆš
5.
The process of looking for a solution in a certain form, namely in the form Î±n, is subject to the same
kind of special treatment, in the case of repeated roots, that we find in differential equations. Corresponding
to a double root Î± of the associated quadratic equation Î±2 = aÎ±+ b we would find two independent solutions
Î±n and nÎ±n, so the general solution would be in the form Î±n(c1 + c2n).
Example. Consider the recurrence
xn+1 = 2xn âˆ’ xnâˆ’1 (n â‰¥ 1; x0 = 1; x1 = 5). (1.4.16)
If we try a solution of the type xn = Î±n, then we find that Î± satisfies the quadratic equation Î±2 = 2Î±âˆ’ 1.
Hence the â€˜twoâ€™ roots are 1 and 1. The general solution is xn = 1n(c1 + nc2) = c1 + c2n. After inserting the
given initial conditions, we find that
x0 = 1 = c1; x1 = 5 = c1 + c2
If we solve for c1 and c2 we obtain c1 = 1, c2 = 4, and therefore the complete solution of the recurrence
(1.4.16) is given by xn = 4n+ 1.
Now letâ€™s look at recurrent inequalities, like this one:
xn+1 â‰¤ xn + xnâˆ’1 + n2 (n â‰¥ 1; x0 = 0; x1 = 0). (1.4.17)
The question is, what restriction is placed on the growth of the sequence {xn} by (1.4.17)?
By analogy with the case of difference equations with constant coefficients, the thing to try here is
xn â‰¤ KÎ±n. So suppose it is true that xn â‰¤ KÎ±n for all n = 0, 1, 2, . . . , N . Then from (1.4.17) with n = N
we find
xN+1 â‰¤ KÎ±N +KÎ±Nâˆ’1 + N2.
Let c be the positive real root of the equation c2 = c + 1, and suppose that Î± > c. Then Î±2 > Î±+ 1 and so
Î±2 âˆ’ Î±âˆ’ 1 = t, say, where t > 0. Hence
xN+1 â‰¤ KÎ±Nâˆ’1(1 + Î±) +N2
= KÎ±Nâˆ’1(Î±2 âˆ’ t) +N2
= KÎ±N+1 âˆ’ (tKÎ±Nâˆ’1 âˆ’N2).
(1.4.18)
In order to insure that xN+1 < KÎ±N+1 what we need is for tKÎ±Nâˆ’1 > N2. Hence as long as we choose
K > max
Nâ‰¥2
{
N2/tÎ±Nâˆ’1
}
, (1.4.19)
in which the right member is clearly finite, the inductive step will go through.
The conclusion is that (1.4.17) implies that for every fixed  > 0, xn = O((c+)n), where c = (1+
âˆš
5)/2.
The same argument applies to the general situation that is expressed in
19
Chapter 1: Mathematical Preliminaries
Theorem 1.4.1. Let a sequence {xn} satisfy a recurrent inequality of the form
xn+1 â‰¤ b0xn + b1xnâˆ’1 + Â· Â· Â·+ bpxnâˆ’p +G(n) (n â‰¥ p)
where bi â‰¥ 0 (âˆ€i),
âˆ‘
bi > 1. Further, let c be the positive real root of * the equa tion cp+1 = b0cp + Â· Â· Â·+ bp.
Finally, suppose G(n) = o(cn). Then for every fixed  > 0 we have xn = O((c+ )n).
Proof: Fix  > 0, and let Î± = c + , where c is the root of the equation shown in the statement of the
theorem. Since Î± > c, if we let
t = Î±p+1 âˆ’ b0Î±p âˆ’ Â· Â· Â· âˆ’ bp
then t > 0. Finally, define
K = max
{
|x0|,
|x1|
Î±
, . . . ,
|xp|
Î±p
, max
nâ‰¥p
{ G(n)
tÎ±nâˆ’p
}}
.
Then K is finite, and clearly |xj| â‰¤ KÎ±j for j â‰¤ p. We claim that |xn| â‰¤ KÎ±n for all n, which will complete
the proof.
Indeed, if the claim is true for 0, 1, 2, . . . , n, then
|xn+1| â‰¤ b0|x0| + Â· Â· Â·+ bp|xnâˆ’p| + G(n)
â‰¤ b0KÎ±n + Â· Â· Â·+ bpKÎ±nâˆ’p + G(n)
= KÎ±nâˆ’p{b0Î±p + Â· Â· Â·+ bp} + G(n)
= KÎ±nâˆ’p{Î±p+1 âˆ’ t} +G(n)
= KÎ±n+1 âˆ’ {tKÎ±nâˆ’p âˆ’ G(n)}
â‰¤ KÎ±n+1
.
Exercises for section 1.4
1. Solve the following recurrence relations
(i) xn+1 = xn + 3 (n â‰¥ 0; x0 = 1)
(ii) xn+1 = xn/3 + 2 (n â‰¥ 0; x0 = 0)
(iii) xn+1 = 2nxn + 1 (n â‰¥ 0; x0 = 0)
(iv) xn+1 = ((n+ 1)/n)xn + n + 1 (n â‰¥ 1; x1 = 5)
(v) xn+1 = xn + xnâˆ’1 (n â‰¥ 1; x0 = 0; x1 = 3)
(vi) xn+1 = 3xn âˆ’ 2xnâˆ’1 (n â‰¥ 1; x0 = 1; x1 = 3)
(vii) xn+1 = 4xn âˆ’ 4xnâˆ’1 (n â‰¥ 1; x0 = 1; x1 = Î¾)
2. Find x1 if the sequence x satisfies the Fibonacci recurrence relation and if furthermore x0 = 1 and
xn = o(1) (n â†’ âˆž).
3. Let xn be the average number of trailing 0â€™s in the binary expansions of all integers 0, 1, 2, . . ., 2n âˆ’ 1.
Find a recurrence relation satisfied by the sequence {xn}, solve it, and evaluate limnâ†’âˆž xn.
4. For what values of a and b is it true that no matter what the initial values x0, x1 are, the solution of the
recurrence relation xn+1 = axn + bxnâˆ’1 (n â‰¥ 1) is guaranteed to be o(1) (n â†’ âˆž)?
5. Suppose x0 = 1, x1 = 1, and for all n â‰¥ 2 it is true that xn+1 â‰¤ xn + xnâˆ’1. Is it true that âˆ€n : xn â‰¤ Fn?
Prove your answer.
6. Generalize the result of exercise 5, as follows. Suppose x0 = y0 and x1 = y1, where yn+1 = ayn +
bynâˆ’1 (âˆ€n â‰¥ 1). If furthermore, xn+1 â‰¤ axn + bxnâˆ’1 (âˆ€n â‰¥ 1), can we conclude that âˆ€n : xn â‰¤ yn? If
not, describe conditions on a and b under which that conclusion would follow.
7. Find the asymptotic behavior in the form xn âˆ¼? (nâ†’ âˆž) of the right side of (1.4.10).
* See exercise 10, below.
20
1.5 Counting
8. Write out a complete proof of theorem 1.4.1.
9. Show by an example that the conclusion of theorem 1.4.1 may be false if the phrase â€˜for every fixed
 > 0 . . .â€™ were replaced by â€˜for every fixed  â‰¥ 0 . . ..â€™
10. In theorem 1.4.1 we find the phrase â€˜... the positive real root of ...â€™ Prove that this phrase is justified, in
that the equation shown always has exactly one positive real root. Exactly what special properties of that
equation did you use in your proof?
1.5 Counting
For a given positive integer n, consider the set {1, 2, . . .n}. We will denote this set by the symbol [n],
and we want to discuss the number of subsets of various kinds that it has. Here is a list of all of the subsets
of [2]: âˆ…, {1}, {2}, {1, 2}. There are 4 of them.
We claim that the set [n] has exactly 2n subsets.
To see why, notice that we can construct the subsets of [n] in the following way. Either choose, or donâ€™t
choose, the element â€˜1,â€™ then either choose, or donâ€™t choose, the element â€˜2,â€™ etc., finally choosing, or not
choosing, the element â€˜n.â€™ Each of the n choices that you encountered could have been made in either of 2
ways. The totality of n choices, therefore, might have been made in 2n different ways, so that is the number
of subsets that a set of n objects has.
Next, suppose we have n distinct objects, and we want to arrange them in a sequence. In how many
ways can we do that? For the first object in our sequence we may choose any one of the n objects. The
second element of the sequence can be any of the remaining n âˆ’ 1 objects, so there are n(n âˆ’ 1) possible
ways to make the first two decisions. Then there are n âˆ’ 2 choices for the third element, and so we have
n(nâˆ’ 1)(nâˆ’ 2) ways to arrange the first three elements of the sequence. It is no doubt clear now that there
are exactly n(nâˆ’ 1)(nâˆ’ 2) Â· Â· Â·3 Â· 2 Â· 1 = n! ways to form the whole sequence.
Of the 2n subsets of [n], how many have exactly k objects in them? The number of elements in a
set is called its cardinality. The cardinality of a set S is denoted by |S|, so, for example, |[6]| = 6. A set
whose cardinality is k is called a â€˜k-set,â€™ and a subset of cardinality k is, naturally enough, a â€˜k-subset.â€™ The
question is, for how many subsets S of [n] is it true that |S| = k?
We can construct k-subsets S of [n] (written â€˜S âŠ† [n]â€™) as follows. Choose an element a1 (n possible
choices). Of the remaining n âˆ’ 1 elements, choose one (n âˆ’ 1 possible choices), etc., until a sequence of k
different elements have been chosen. Obviously there were n(nâˆ’ 1)(nâˆ’ 2) Â· Â· Â· (nâˆ’ k + 1) ways in which we
might have chosen that sequence, so the number of ways to choose an (ordered) sequence of k elements from
[n] is
n(n âˆ’ 1)(nâˆ’ 2) Â· Â· Â· (nâˆ’ k + 1) = n!/(nâˆ’ k)!.
But there are more sequences of k elements than there are k-subsets, because any particular k-subset S
will correspond to k! different ordered sequences, namely all possible rearrangements of the elements of the
subset. Hence the number of k-subsets of [n] is equal to the number of k-sequences divided by k!. In other
words, there are exactly n!/k!(nâˆ’ k)! k-subsets of a set of n objects.
The quantities n!/k!(nâˆ’ k)! are the famous binomial coefficients, and they are denoted by
(
n
k
)
=
n!
k!(nâˆ’ k)! (n â‰¥ 0; 0 â‰¤ k â‰¤ n). (1.5.1)
Some of their special values are
(
n
0
)
= 1 (âˆ€n â‰¥ 0);
(
n
1
)
= n (âˆ€n â‰¥ 0);
(
n
2
)
= n(nâˆ’ 1)/2 (âˆ€n â‰¥ 0);
(
n
n
)
= 1 (âˆ€n â‰¥ 0).
It is convenient to define
(
n
k
)
to be 0 if k < 0 or if k > n.
We can summarize the developments so far with
21
Chapter 1: Mathematical Preliminaries
Theorem 1.5.1. For each n â‰¥ 0, a set of n objects has exactly 2n subsets, and of these, exactly
(
n
k
)
have
cardinality k ( âˆ€k = 0, 1, . . ., n). There are exactly n! different sequences that can be formed from a set of n
distinct objects.
Since every subset of [n] has some cardinality, it follows that
nâˆ‘
k=0
(
n
k
)
= 2n (n = 0, 1, 2, . . .). (1.5.2)
In view of the convention that we adopted, we might have written (1.5.2) as
âˆ‘
k
(
n
k
)
= 2n, with no restriction
on the range of the summation index k. It would then have been understood that the range of k is from
âˆ’âˆž to âˆž, and that the binomial coefficient
(
n
k
)
vanishes unless 0 â‰¤ k â‰¤ n.
In Table 1.5.1 we show the values of some of the binomial coefficients
(
n
k
)
. The rows of the table
are thought of as labelled â€˜n = 0,â€™ â€˜n = 1,â€™ etc., and the entries within each row refer, successively, to
k = 0, 1, . . . , n. The table is called â€˜Pascalâ€™s triangle.â€™
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
...................................................
..
Table 1.5.1: Pascalâ€™s triangle
Here are some facts about the binomial coefficients:
(a) Each row of Pascalâ€™s triangle is symmetric about the middle. That is,
(
n
k
)
=
(
n
nâˆ’ k
)
(0 â‰¤ k â‰¤ n; n â‰¥ 0).
(b) The sum of the entries in the nth row of Pascalâ€™s triangle is 2n.
(c) Each entry is equal to the sum of the two entries that are immediately above it in the triangle.
The proof of (c) above can be interesting. What it says about the binomial coefficients is that
(
n
k
)
=
(
nâˆ’ 1
k âˆ’ 1
)
+
(
nâˆ’ 1
k
)
((n, k) 6= (0, 0)). (1.5.3)
There are (at least) two ways to prove (1.5.3). The hammer-and-tongs approach would consist of expanding
each of the three binomial coefficients that appears in (1.5.3), using the definition (1.5.1) in terms of factorials,
and then cancelling common factors to complete the proof.
That would work (try it), but hereâ€™s another way. Contemplate (this proof is by contemplation) the
totality of k-subsets of [n]. The number of them is on the left side of (1.5.3). Sort them out into two piles:
those k-subsets that contain â€˜1â€™ and those that donâ€™t. If a k-subset of [n] contains â€˜1,â€™ then its remaining
kâˆ’ 1 elements can be chosen in
(
nâˆ’1
kâˆ’1
)
ways, and that accounts for the first term on the right of (1.5.3). If a
k-subset does not contain â€˜1,â€™ then its k elements are all chosen from [n âˆ’ 1], and that completes the proof
of (1.5.3).
22
1.5 Counting
The binomial theorem is the statement that âˆ€n â‰¥ 0 we have
(1 + x)n =
nâˆ‘
k=0
(
n
k
)
xk. (1.5.4)
Proof: By induction on n. Eq. (1.5.4) is clearly true when n = 0, and if it is true for some n then multiply
both sides of (1.5.4) by (1 + x) to obtain
(1 + x)n+1 =
âˆ‘
k
(
n
k
)
xk +
âˆ‘
k
(
n
k
)
xk+1
=
âˆ‘
k
(
n
k
)
xk +
âˆ‘
k
(
n
k âˆ’ 1
)
xk
=
âˆ‘
k
{(n
k
)
+
(
n
k âˆ’ 1
)}
xk
=
âˆ‘
k
(
n+ 1
k
)
xk
which completes the proof.
Now letâ€™s ask how big the binomial coefficients are, as an exercise in asymptotics. We will refer to the
coefficients in row n of Pascalâ€™s triangle, that is, to
(
n
0
)
,
(
n
1
)
, . . . ,
(
n
n
)
as the coefficients of order n. Then, by (1.5.2) (or by (1.5.4) with x = 1), the sum of all of the coefficients
of order n is 2n. It is also fairly apparent, from an inspection of Table 1.5.1, that the largest one(s) of the
coefficients of order n is (are) the one(s) in the middle.
More precisely, if n is odd, then the largest coefficients of order n are
(
n
(nâˆ’1)/2
)
and
(
n
(n+1)/2
)
, whereas
if n is even, the largest one is uniquely
(
n
n/2
)
.
It will be important, in some of the applications to algorithms later on in this book, for us to be able
to pick out the largest term in a sequence of this kind, so letâ€™s see how we could prove that the biggest
coefficients are the ones cited above.
For n fixed, we will compute the ratio of the (k+ 1)st coefficient of order n to the kth. We will see then
that the ratio is larger than 1 if k < (nâˆ’ 1)/2 and is < 1 if k > (nâˆ’ 1)/2. That, of course, will imply that
the (k + 1)st coefficient is bigger than the kth, for such k, and therefore that the biggest one(s) must be in
the middle.
The ratio is (
n
k+1
)
(
n
k
) = n!/{(k + 1)!(nâˆ’ k âˆ’ 1)!}
n!/{k!(nâˆ’ k)!}
=
k!(nâˆ’ k)!
(k + 1)!(nâˆ’ k âˆ’ 1)!
= (n âˆ’ k)/(k + 1)
and is > 1 iff k < (nâˆ’ 1)/2, as claimed.
OK, the biggest coefficients are in the middle, but how big are they? Letâ€™s suppose that n is even, just
to keep things simple. Then the biggest binomial coefficient of order n is
(
n
n/2
)
=
n!
(n/2)!2
âˆ¼
(ne )
n
âˆš
2nÏ€
{( n
2e
)n2
âˆš
nÏ€}2
=
âˆš
2
nÏ€
2n
(1.5.5)
23
Chapter 1: Mathematical Preliminaries
where we have used Stirlingâ€™s formula (1.1.10).
Equation (1.5.5) shows that the single biggest binomial coefficient accounts for a very healthy fraction
of the sum of all of the coefficients of order n. Indeed, the sum of all of them is 2n, and the biggest one is
âˆ¼
âˆš
2/nÏ€2n. When n is large, therefore, the largest coefficient contributes a fraction âˆ¼
âˆš
2/nÏ€ of the total.
If we think in terms of the subsets that these coefficients count, what we will see is that a large fraction
of all of the subsets of an n-set have cardinality n/2, in fact Î˜(nâˆ’.5) of them do. This kind of probabilistic
thinking can be very useful in the design and analysis of algorithms. If we are designing an algorithm that
deals with subsets of [n], for instance, we should recognize that a large percentage of the customers for that
algorithm will have cardinalities near n/2, and make every effort to see that the algorithm is fast for such
subsets, even at the expense of possibly slowing it down on subsets whose cardinalities are very small or very
large.
Exercises for section 1.5
1. How many subsets of even cardinality does [n] have?
2. By observing that (1 + x)a(1 + x)b = (1 + x)a+b, prove that the sum of the squares of all binomial
coefficients of order n is
(
2n
n
)
.
3. Evaluate the following sums in simple form.
(i)
âˆ‘n
j=0 j
(
n
j
)
(ii)
âˆ‘n
j=3
(
n
j
)
5j
(iii)
âˆ‘n
j=0(j + 1)3
j+1
4. Find, by direct application of Taylorâ€™s theorem, the power series expansion of f(x) = 1/(1âˆ’x)m+1 about
the origin. Express the coefficients as certain binomial coefficients.
5. Complete the following twiddles.
(i)
(
2n
n
)
âˆ¼ ?
(ii)
(
n
blog2 nc
)
âˆ¼ ?
(iii)
(
n
bÎ¸nc
)
âˆ¼ ?
(iv)
(
n2
n
)
âˆ¼ ?
6. How many ordered pairs of unequal elements of [n] are there?
7. Which one of the numbers {2j
(
n
j
)
}nj=0 is the biggest?
1.6 Graphs
A graph is a collection of vertices, certain unordered pairs of which are called its edges. To describe a
particular graph we first say what its vertices are, and then we say which pairs of vertices are its edges. The
set of vertices of a graph G is denoted by V (G), and its set of edges is E(G).
If v and w are vertices of a graph G, and if (v, w) is an edge of G, then we say that vertices v, w are
adjacent in G.
Consider the graph G whose vertex set is {1, 2, 3, 4, 5} and whose edges are the set of pairs (1,2), (2,3),
(3,4), (4,5), (1,5). This is a graph of 5 vertices and 5 edges. A nice way to present a graph to an audience
is to draw a picture of it, instead of just listing the pairs of vertices that are its edges. To draw a picture of
a graph we would first make a point for each vertex, and then we would draw an arc between two vertices v
and w if and only if (v, w) is an edge of the graph that we are talking about. The graph G of 5 vertices and
5 edges that we listed above can be drawn as shown in Fig. 1.6.1(a). It could also be drawn as shown in
Fig. 1.6.1(b). Theyâ€™re both the same graph. Only the pictures are different, but the pictures arenâ€™t â€˜reallyâ€™
the graph; the graph is the vertex list and the edge list. The pictures are helpful to us in visualizing and
remembering the graph, but thatâ€™s all.
The number of edges that contain (â€˜are incident withâ€™) a particular vertex v of a graph G is called the
degree of that vertex, and is usually denoted by Ï(v). If we add up the degrees of every vertex v of G we will
have counted exactly two contributions from each edge of G, one at each of its endpoints. Hence, for every
24
1.6 Graphs
Fig. 1.6.1(a) Fig. 1.6.1(b)
graph G we have âˆ‘
vâˆˆV (G)
Ï(v) = 2|E(G)|. (1.6.1)
Since the right-hand side is an even number, there must be an even number of odd numbers on the left side
of (1.6.1). We have therefore proved that every graph has an even number of vertices whose degrees are odd.*
In Fig. 1.6.1 the degrees of the vertices are {2, 2, 2, 2,2} and the sum of the degrees is 10 = 2|E(G)|.
Next weâ€™re going to define a number of concepts of graph theory that will be needed in later chapters.
A fairly large number of terms will now be defined, in rather a brief space. Donâ€™t try to absorb them all
now, but read through them and look them over again when the concepts are actually used, in the sequel.
A path P in a graph G is a walk from one vertex of G to another, where at each step the walk uses an
edge of the graph. More formally, it is a sequence {v1, v2, . . . , vk} of vertices of G such that âˆ€i = 1, k âˆ’ 1 :
(vi, vi+1) âˆˆ E(G).
A graph is connected if there is a path between every pair of its vertices.
A path P is simple if its vertices are all distinct, Hamiltonian if it is simple and visits every vertex of G
exactly once, Eulerian if it uses every edge of G exactly once.
A subgraph of a graph G is a subset S of its vertices to gether with a subset of just those edges of G
both of whose endpoints lie in S. An induced subgraph of G is a subset S of the vertices of G together with
all edges of G both of whose endpoints lie in S. We would then speak of â€˜the subgraph induced by S.â€™
In a graph G we can define an equivalence relation on the vertices as follows. Say that v and w are
equivalent if there is a path of G that joins them. Let S be one of the equivalence classes of vertices of G
under this relation. The subgraph of G that S induces is called a connected component of the graph G. A
graph is connected if and only if it has exactly one connected component.
A cycle is a closed path, i.e., one in which vk = v1. A cycle is a circuit if v1 is the only repeated vertex
in it. We may say that a circuit is a simple cycle. We speak of Hamiltonian and Eulerian circuits of G as
circuits of G that visit, respectively, every vertex, or every edge, of a graph G.
Not every graph has a Hamiltonian path. The graph in Fig. 1.6.2(a) has one and the graph in Fig.
1.6.2(b) doesnâ€™t.
Fig. 1.6.2(a) Fig. 1.6.2(b)
* Did you realize that the number of people who shook hands an odd number of times yesterday is an
even number of people?
25
Chapter 1: Mathematical Preliminaries
Fig. 1.6.3(a) Fig. 1.6.3(b)
Likewise, not every graph has an Eulerian path. The graph in Fig. 1.6.3(a) has one and the graph in
Fig. 1.6.3(b) doesnâ€™t.
There is a world of difference between Eulerian and Hamiltonian paths, however. If a graph G is given,
then thanks to the following elegant theorem of Euler, it is quite easy to decide whether or not G has an
Eulerian path. In fact, the theorem applies also to multigraphs, which are graphs except that they are allowed
to have several different edges joining the same pair of vertices.
Theorem 1.6.1. A (multi-)graph has an Eulerian circuit (resp. path) if and only if it is connected and has
no (resp. has exactly two) vertices of odd degree.
Proof: Let G be a connected multigraph in which every vertex has even degree. We will find an Eulerian
circuit in G. The proof for Eulerian paths will be similar, and is omitted.
The proof is by induction on the number of edges of G, and the result is clearly true if G has just one
edge.
Hence suppose the theorem is true for all such multigraphs of fewer than m edges, and let G have m
edges. We will construct an Eulerian circuit of G.
Begin at some vertex v and walk along some edge to a vertex w. Generically, having arrived at a vertex
u, depart from u along an edge that hasnâ€™t been used yet, arriving at a new vertex, etc. The process halts
when we arrive for the first time at a vertex vâ€² such that all edges incident with vâ€² have previously been
walked on, so there is no exit.
We claim that vâ€² = v, i.e., weâ€™re back where we started. Indeed, if not, then we arrived at vâ€² one more
time than we departed from it, each time using a new edge, and finding no edges remaining at the end. Thus
there were an odd number of edges of G incident with vâ€², a contradiction.
Hence we are indeed back at our starting point when the walk terminates. Let W denote the sequence
of edges along which we have so far walked. If W includes all edges of G then we have found an Euler tour
and we are finished.
Else there are edges of G that are not in W . Erase all edges of W from G, thereby obtaining a (possibly
disconnected multi-) graph Gâ€². Let C1, . . . , Ck denote the connected components of Gâ€². Each of them has
only vertices of even degree because that was true of G and of the walk W that we subtracted from G.
Since each of the Ci has fewer edges than G had, there is, by induction, an Eulerian circuit in each of the
connected components of Gâ€².
We will thread them all together to make such a circuit for G itself.
Begin at the same v and walk along 0 or more edges of W until you arrive for the first time at a vertex
q of component C1. This will certainly happen because G is connected. Then follow the Euler tour of the
edges of C1, which will return you to vertex q. Then continue your momentarily interrupted walk W until
you reach for the first time a vertex of C2, which will surely happen because G is connected, etc., and the
proof is complete.
It is extremely difficult computationally to decide if a given graph has a Hamilton path or circuit. We
will see in Chapter 5 that this question is typical of a breed of problems that are the main subject of that
chapter, and are perhaps the most (in-)famous unsolved problems in theoretical computer science. Thanks
to Eulerâ€™s theorem (theorem 1.6.1) it is easy to decide if a graph has an Eulerian path or circuit.
Next weâ€™d like to discuss graph coloring, surely one of the prettier parts of graph theory. Suppose that
there are K colors available to us, and that we are presented with a graph G. A proper coloring of the
vertices of G is an assignment of a color to each vertex of G in such a way that âˆ€e âˆˆ E(G) the colors of
26
1.6 Graphs
the two endpoints of e are different. Fig. 1.6.4(a) shows a graph G and an attempt to color its vertices
properly in 3 colors (â€˜R,â€™ â€˜Yâ€™ and â€˜Bâ€™). The attempt failed because one of the edges of G has had the same
color assigned to both of its endpoints. In Fig. 1.6.4(b) we show the same graph with a successful proper
coloring of its vertices in 4 colors.
Fig. 1.6.4(a) Fig. 1.6.4(b)
The chromatic number Ï‡(G) of a graph G is the minimum number of colors that can be used in a proper
coloring of the vertices of G. A bipartite graph is a graph whose chromatic number is â‰¤ 2, i.e., it is a graph
that can be 2-colored. That means that the vertices of a bipartite graph can be divided into two classes â€˜Râ€™
and â€˜Yâ€™ such that no edge of the graph runs between two â€˜Râ€™ vertices or between two â€˜Yâ€™ vertices. Bipartite
graphs are most often drawn, as in Fig. 1.6.5, in two layers, with all edges running between layers.
Fig. 1.6.5: A bipartite graph
The complement G of a graph G is the graph that has the same vertex set that G has and has an edge
exactly where G does not have its edges. Formally,
E(G) = {(v, w) | v, w âˆˆ V (G); v 6= w; (v, w) /âˆˆ E(G)}.
Here are some special families of graphs that occur so often that they rate special names. The complete
graph Kn is the graph of n vertices in which every possible one of the
(
n
2
)
edges is actually present. Thus
K2 is a single edge, K3 looks like a triangle, etc. The empty graph Kn consists of n isolated vertices, i.e.,
has no edges at all.
The complete bipartite graph Km,n has a set S of m vertices and a set T of n vertices. Its edge set
is E(Km,n) = S Ã— T . It has |E(Km,n)| = mn edges. The n-cycle, Cn, is a graph of n vertices that are
connected to form a single cycle. A tree is a graph that (a) is connected and (b ) has no cycles. A tree is
shown in Fig. 1.6.6.
Fig. 1.6.6: A tree
27
Chapter 1: Mathematical Preliminaries
It is not hard to prove that the following are equivalent descriptions of a tree.
(a) A tree is a graph that is connected and has no cycles.
(b) A tree is a graph G that is connected and for which |E(G)| = |V (G)| âˆ’ 1.
(c) A tree is a graph G with the property that between every pair of distinct vertices there is a unique
path.
If G is a graph and S âŠ† V (G), then S is an independent set of vertices of G if no two of the vertices in
S are adjacent in G. An independent set S is maximal if it is not a proper subset of another independent set
of vertices of G. Dually, if a vertex subset S induces a complete graph, then we speak of a complete subgraph
of G. A maximal complete subgraph of G is called a clique.
A graph might be labeled or unlabeled. The vertices of a labeled graph are numbered 1, 2, . . . , n. One
difference that this makes is that there are a lot more labeled graphs than there are unlabeled graphs. There
are, for example, 3 labeled graphs that have 3 vertices and 1 edge. They are shown in Fig. 1.6.7.
Fig. 1.6.7: Three labeled graphs...
There is, however, only 1 unlabeled graph that has 3 vertices and 1 edge, as shown in Fig. 1.6.8.
Fig. 1.6.8: ... but only one unlabeled graph
Most counting problems on graphs are much easier for labeled than for unlabeled graphs. Consider the
following question: how many graphs are there that have exactly n vertices? Suppose first that we mean
labeled graphs. A graph of n vertices has a maximum of
(
n
2
)
edges. To construct a graph we would decide
which of these possible edges would be used. We can make each of these
(
n
2
)
decisions independently, and
for every way of deciding where to put the edges we would get a different graph. Therefore the number of
labeled graphs of n vertices is 2(
n
2) = 2n(nâˆ’1)/2.
If we were to ask the corresponding question for unlabeled graphs we would find it to be very hard.
The answer is known, but the derivation involves Burnsideâ€™s lemma about the action of a group on a set,
and some fairly delicate counting arguments. We will state the approximate answer to this question, which
is easy to write out, rather than the exact answer, which is not. If gn is the number of unlabeled graphs of
n vertices then
gn âˆ¼ 2(
n
2)/n!.
Exercises for section 1.6
1. Show that a tree is a bipartite graph.
2. Find the chromatic number of the n-cycle.
3. Describe how you would find out, on a computer, if a given graph G is bipartite.
4. Given a positive integer K. Find two different graphs each of whose chromatic numbers is K.
5. Exactly how many labeled graphs of n vertices and E edges are there?
6. In how many labeled graphs of n vertices do vertices {1, 2, 3} form an independent set?
7. How many cliques does an n-cycle have?
8. True or false: a Hamilton circuit is an induced cycle in a graph.
9. Which graph of n vertices has the largest number of independent sets? How many does it have?
10. Draw all of the connected, unlabeled graphs of 4 vertices.
11. Let G be a bipartite graph that has q connected components. Show that there are exactly 2q ways to
properly color the vertices of G in 2 colors.
12. Find a graph G of n vertices, other than the complete graph, whose chromatic number is equal to 1 plus
the maximum degree of any vertex of G.
28
1.6 Graphs
13. Let n be a multiple of 3. Consider a labeled graph G that consists of n/3 connected components, each
of them a K3. How many maximal independent sets does G have?
14. Describe the complement of the graph G in exercise 13 above. How many cliques does it have?
15. In how many labeled graphs of n vertices is the subgraph that is induced by vertices {1, 2, 3} a triangle?
16. Let H be a labeled graph of L vertices. In how many labeled graphs of n vertices is the subgraph that
is induced by vertices {1, 2, . . . , L} equal to H?
17. Devise an algorithm that will decide if a given graph, of n vertices and m edges, does or does not contain
a triangle, in time O(max(n2,mn)).
18. Prove that the number of labeled graphs of n vertices all of whose vertices have even degree is equal to
the number of all labeled graphs of nâˆ’ 1 vertices.
29
Chapter 2: Recursive Algorithms
Chapter 2: Recursive Algorithms
2.1 Introduction
Here are two different ways to define n!, if n is a positive integer. The first definition is nonrecursive,
the second is recursive.
(1) â€˜n! is the product of all of the whole numbers from 1 to n, inclusive.â€™
(2) â€˜If n = 1 then n! = 1, else n! = n Â· (nâˆ’ 1)!.â€™
Letâ€™s concentrate on the second definition. At a glance, it seems illegal, because weâ€™re defining something,
and in the definition the same â€˜somethingâ€™ appears. Another glance, however, reveals that the value of n! is
defined in terms of the value of the same function at a smaller value of its argument, viz. n âˆ’ 1. So weâ€™re
really only using mathematical induction in order to validate the assertion that a function has indeed been
defined for all positive integers n.
What is the practical import of the above? Itâ€™s monumental. Many modern high-level computer
languages can handle recursive constructs directly, and when this is so, the programmerâ€™s job may be
considerably simplified. Among recursive languages are Pascal, PL/C, Lisp, APL, C, and many others.
Programmers who use these languages should be aware of the power and versatility of recursive methods
(conversely, people who like recursive methods should learn one of those languages!).
A formal â€˜functionâ€™ module that would calculate n! nonrecursively might look like this.
function fact(n);
{computes n! for given n > 0}
fact := 1;
for i := 1 to n do fact := i Â· fact;
end.
On the other hand a recursive n! module is as follows.
function fact(n);
if n = 1 then fact := 1
else fact := n Â· fact(n âˆ’ 1);
end.
The hallmark of a recursive procedure is that it calls itself, with arguments that are in some sense
smaller than before. Notice that there are no visible loops in the recursive routine. Of course there will
be loops in the compiled machine-language program, so in effect the programmer is shifting many of the
bookkeeping problems to the compiler (but it doesnâ€™t mind!).
Another advantage of recursiveness is that the thought processes are helpful. Mathematicians have
known for years that induction is a marvellous method for proving theorems, making constructions, etc.
Now computer scientists and programmers can profitably think recursively too, because recursive compilers
allow them to express such thoughts in a natural way, and as a result many methods of great power are being
formulated recursively, methods which, in many cases, might not have been developed if recursion were not
readily available as a practical programming tool.
Observe next that the â€˜trivial case,â€™ where n = 1, is handled separately, in the recursive form of the n!
program above. This trivial case is in fact essential, because itâ€™s the only thing that stops the execution of
the program. In effect, the computer will be caught in a loop, reducing n by 1, until it reaches 1, then it will
actually know the value of the function fact, and after that it will be able to climb back up to the original
input value of n.
The overall structure of a recursive routine will always be something like this:
30
2.2 Quicksort
procedure calculate(list of variables);
if {trivialcase} then do {trivialthing}
else do
{call calculate(smaller values of the variables)};
{maybe do a few more things}
end.
In this chapter weâ€™re going to work out a number of examples of recursive algorithms, of varying
sophistication. We will see how the recursive structure helps us to analyze the running time, or complexity,
of the algorithms. We will also find that there is a bit of art involved in choosing the list of variables that
a recursive procedure operates on. Sometimes the first list we think of doesnâ€™t work because the recursive
call seems to need more detailed information than we have provided for it. So we try a larger list, and then
perhaps it works, or maybe we need a still larger list ..., but more of this later.
Exercises for section 2.1
1. Write a recursive routine that will find the digits of a given integer n in the base b. There should be no
visible loops in your program.
2.2 Quicksort
Suppose that we are given an array x[1], . . ., x[n] of n numbers. We would like to rearrange these
numbers as necessary so that they end up in nondecreasing order of size. This operation is called sorting the
numbers.
For instance, if we are given {9, 4, 7, 2, 1}, then we want our program to output the sorted array
{1, 2, 4, 7, 9}.
There are many methods of sorting, but we are going to concentrate on methods that rely on only
two kinds of basic operations, called comparisons and interchanges. This means that our sorting routine is
allowed to
(a) pick up two numbers (â€˜keysâ€™) from the array, compare them, and decide which is larger.
(b) interchange the positions of two selected keys.
Here is an example of a rather primitive sorting algorithm:
(i) find, by successive comparisons, the smallest key
(ii) interchange it with the first key
(iii) find the second smallest key
(iv) interchange it with the second key, etc. etc.
Here is a more formal algorithm that does the job above.
procedure slowsort(X: array[1..n]);
{sorts a given array into nondecreasing order}
for r := 1 to nâˆ’ 1 do
for j := r + 1 to n do
if x[j] < x[r] then swap(x[j], x[r])
end.{slowsort}
If you are wondering why we called this method â€˜primitive,â€™ â€˜slowsort,â€™ and other pejorative names, the
reason will be clearer after we look at its complexity.
What is the cost of sorting n numbers by this method? We will look at two ways to measure that cost.
First letâ€™s choose our unit of cost to be one comparison of two numbers, and then we will choose a different
unit of cost, namely one interchange of position (â€˜swapâ€™) of two numbers.
31
Chapter 2: Recursive Algorithms
How many paired comparisons does the algorithm make? Reference to procedure slowsort shows that it
makes one comparison for each value of j = r+1, . . . , n in the inner loop. This means that the total number
of comparisons is
f1(n) =
nâˆ’1âˆ‘
r=1
nâˆ‘
j=r+1
1
=
nâˆ’1âˆ‘
r=1
(n âˆ’ r)
= (n âˆ’ 1)n/2.
The number of comparisons is Î˜(n2), which is quite a lot of comparisons for a sorting method to do. Not
only that, but the method does that many comparisons regardless of the input array, i.e. its best case and
its worst case are equally bad.
The Quicksort* method, which is the main object of study in this section, does a maximum of cn2
comparisons, but on the average it does far fewer, a mere O(n logn) comparisons. This economy is much
appreciated by those who sort, because sorting applications can be immense and time consuming. One
popular sorting application is in alphabetizing lists of names. It is easy to imagine that some of those lists
are very long, and that the replacement of Î˜(n2) by an average of O(n logn) comparisons is very welcome.
An insurance company that wants to alphabetize its list of 5,000,000 policyholders will gratefully notice the
difference between n2 = 25, 000, 000,000,000 comparisons and n logn = 77, 124, 740 comparisons.
If we choose as our unit of complexity the number of swaps of position, then the running time may
depend strongly on the input array. In the â€˜slowsortâ€™ method described above, some arrays will need no
swaps at all while others might require the maximum number of (nâˆ’ 1)n/2 (which arrays need that many
swaps?). If we average over all n! possible arrangements of the input data, assuming that the keys are
distinct, then it is not hard to see that the average number of swaps that slowsort needs is Î˜(n2).
Now letâ€™s discuss Quicksort. In contrast to the sorting method above, the basic idea of Quicksort is
sophisticated and powerful. Suppose we want to sort the following list:
26, 18, 4, 9, 37, 119,220,47,74 (2.2.1)
The number 37 in the above list is in a very intriguing position. Every number that precedes it is smaller
than it is and every number that follows it is larger than it is. What that means is that after sorting the list,
the 37 will be in the same place it now occupies, the numbers to its left will have been sorted but will still be
on its left, and the numbers on its right will have been sorted but will still be on its right.
If we are fortunate enough to be given an array that has a â€˜splitter,â€™ like 37, then we can
(a) sort the numbers to the left of the splitter, and then
(b) sort the numbers to the right of the splitter.
Obviously we have here the germ of a recursive sorting routine.
The fly in the ointment is that most arrays donâ€™t have splitters, so we wonâ€™t often be lucky enough to
find the state of affairs that exists in (2.2.1). However, we can make our own splitters, with some extra work,
and that is the idea of the Quicksort algorithm. Letâ€™s state a preliminary version of the recursive procedure
as follows (look carefully for how the procedure handles the trivial case where n=1).
procedure quicksortprelim(x : an array of n numbers);
{sorts the array x into nondecreasing order}
if n â‰¥ 2 then
permute the array elements so as to create a splitter;
let x[i] be the splitter that was just created;
quicksortprelim(the subarray x1, . . . , xiâˆ’1) in place;
quicksortprelim(the subarray xi+1, . . . , xn) in place;
end.{quicksortprelim}
* C. A. R. Hoare, Comp. J., 5 (1962), 10-15.
32
2.2 Quicksort
This preliminary version wonâ€™t run, though. It looks like a recursive routine. It seems to call itself twice
in order to get its job done. But it doesnâ€™t. It calls something thatâ€™s just slightly different from itself in
order to get its job done, and that wonâ€™t work.
Observe the exact purpose of Quicksort, as described above. We are given an array of length n, and
we want to sort it, all of it. Now look at the two â€˜recursive calls,â€™ which really arenâ€™t quite. The first one
of them sorts the array to the left of xi. That is indeed a recursive call, because we can just change the â€˜nâ€™
to â€˜i âˆ’ 1â€™ and call Quicksort. The second recursive call is the problem. It wants to sort a portion of the
array that doesnâ€™t begin at the beginning of the array. The routine Quicksort as written so far doesnâ€™t have
enough flexibility to do that. So we will have to give it some more parameters.
Instead of trying to sort all of the given array, we will write a routine that sorts only the portion of the
given array x that extends from x[left] to x[right], inclusive, where left and right are input parameters.
This leads us to the second version of the routine:
procedure qksort(x:array; left, right:integer);
{sorts the subarray x[left], . . . , x[right]}
if right âˆ’ left â‰¥ 1 then
create a splitter for the subarray in the ith array position;
qksort(x, left, i âˆ’ 1);
qksort(x, i + 1, right)
end.{qksort}
Once we have qksort, of course, Quicksort is no problem: we call qksort with left := 1 and right := n.
The next item on the agenda is the little question of how to create a splitter in an array. Suppose we
are working with a subarray
x[left], x[left + 1], . . . , x[right].
The first step is to choose one of the subarray elements (the element itself, not the position of the element)
to be the splitter, and the second step is to make it happen. The choice of the splitter element in the
Quicksort algorithm is done very simply: at random. We just choose, using our favorite random number
generator, one of the entries of the given subarray, letâ€™s call it T , and declare it to be the splitter. To repeat
the parenthetical comment above, T is the value of the array entry that was chosen, not its position in the
array. Once the value is selected, the position will be what it has to be, namely to the right of all smaller
entries, and to the left of all larger entries.
The reason for making the random choice will become clearer after the smoke of the complexity discussion
has cleared, but briefly itâ€™s this: the analysis of the average case complexity is realtively easy if we use the
random choice, so thatâ€™s a plus, and there are no minuses.
Second, we have now chosen T to be the value around which the subarray will be split. The entries of
the subarray must be moved so as to make T the splitter. To do this, consider the following algorithm.*
* Attributed to Nico Lomuto by Jon Bentley, CACM 27 (April 1984).
33
Chapter 2: Recursive Algorithms
procedure split(x, left, right, i)
{chooses at random an entry T of the subarray
[xleft, xright], and splits the subarray around T}
{the output integer i is the position of T in the
output array: x[i] = T};
1 L := a random integer in [left, right];
2 swap(x[left], x[L]);
3 {now the splitter is first in the subarray}
4 T := x[left];
5 i := left;
6 for j := left + 1 to right do
begin
7 if x[j] < T then
begin
8 i := i + 1
swap(x[i], x[j])
end;
end
9 swap(x[left], x[i])
10 end.{split}
We will now prove the correctness of split.
Theorem 2.2.1. Procedure split correctly splits the array x around the chosen value T .
Proof: We claim that as the loop in lines 7 and 8 is repeatedly executed for j := left + 1 to right, the
following three assertions will always be true just after each execution of lines 7, 8:
(a) x[left] = T and
(b) x[r] < T for all left < r â‰¤ i and
(c) x[r] â‰¥ T for all i < r â‰¤ j
Fig. 2.2.1 illustrates the claim.
Fig. 2.2.1: Conditions (a), (b), (c)
To see this, observe first that (a), (b), (c) are surely true at the beginning, when j = left + 1. Next, if
for some j they are true, then the execution of lines 7, 8 guarantee that they will be true for the next value
of j.
Now look at (a), (b), (c) when j = right. It tells us that just prior to the execution of line 9 the
condition of the array will be
(a) x[left] = T and
(b) x[r] < T for all left < r â‰¤ i and
(c) x[r] â‰¥ T for all i < r â‰¤ right.
When line 9 executes, the array will be in the correctly split condition.
Now we can state a â€˜finalâ€™ version of qksort (and therefore of Quicksort too).
34
2.2 Quicksort
procedure qksort(x:array; left, right:integer);
{sorts the subarray x[left], . . . , x[right]};
if right âˆ’ left â‰¥ 1 then
split(x, left, right, i);
qksort(x, left, i âˆ’ 1);
qksort(x, i + 1, right)
end.{qksort}
procedure Quicksort(x :array; n:integer)
{sorts an array of length n};
qksort(x, 1, n)
end.{Quicksort}
Now letâ€™s consider the complexity of Quicksort. How long does it take to sort an array? Well, the
amount of time will depend on exactly which array we happen to be sorting, and furthermore it will depend
on how lucky we are with our random choices of splitting elements.
If we want to see Quicksort at its worst, suppose we have a really unlucky day, and that the random
choice of the splitter element happens to be the smallest element in the array. Not only that, but suppose
this kind of unlucky choice is repeated on each and every recursive call.
If the splitter element is the smallest array entry, then it wonâ€™t do a whole lot of splitting. In fact, if
the original array had n entries, then one of the two recursive calls will be to an array with no entries at all,
and the other recursive call will be to an array of nâˆ’ 1 entries. If L(n) is the number of paired comparisons
that are required in this extreme scenario, then, since the number of comparisons that are needed to carry
out the call to split an array of length n is nâˆ’ 1, it follows that
L(n) = L(nâˆ’ 1) + nâˆ’ 1 (n â‰¥ 1;L(0) = 0).
Hence,
L(n) = (1 + 2 + Â· Â· Â·+ (nâˆ’ 1)) = Î˜(n2).
The worst-case behavior of Quicksort is therefore quadratic in n. In its worst moods, therefore, it is as bad
as â€˜slowsortâ€™ above.
Whereas the performance of slowsort is pretty much always quadratic, no matter what the input is,
Quicksort is usually a lot faster than its worst case discussed above.
We want to show that on the average the running time of Quicksort is O(n logn).
The first step is to get quite clear about what the word â€˜averageâ€™ refers to. We suppose that the entries
of the input array x are all distinct. Then the performance of Quicksort can depend only on the sequence of
size relationships in the input array and the choices of the random splitting elements.
The actual numerical values that appear in the input array are not in themselves important, except that,
to simplify the discussion we will assume that they are all different. The only thing that will matter, then,
will be the set of outcomes of all of the paired comparisons of two elements that are done by the algorithm.
Therefore, we will assume, for the purposes of analysis, that the entries of the input array are exactly the
set of numbers 1, 2, . . ., n in some order.
There are n! possible orders in which these elements might appear, so we are considering the action of
Quicksort on just these n! inputs.
Second, for each particular one of these inputs, the choices of the splitting elements will be made by
choosing, at random, one of the entries of the array at each step of the recursion. We will also average over
all such random choices of the splitting elements.
Therefore, when we speak of the function F (n), the average complexity of Quicksort, we are speaking of
the average number of pairwise comparisons of array entries that are made by Quicksort, where the averaging
35
Chapter 2: Recursive Algorithms
is done first of all over all n! of the possible input orderings of the array elements, and second, for each such
input ordering, we average also over all sequences of choices of the splitting elements.
Now letâ€™s consider the behavior of the function F (n). What we are going to show is that F (n) =
O(n logn).
The labor that F (n) estimates has two components. First there are the pairwise comparisons involved
in choosing a splitting element and rearranging the array about the chosen splitting value. Second there are
the comparisons that are done in the two recursive calls that follow the creation of a splitter.
As we have seen, the number of comparisons involved in splitting the array is nâˆ’ 1. Hence it remains
to estimate the number of comparisons in the recursive calls.
For this purpose, suppose we have rearranged the array about the splitting element, and that it has
turned out that the splitting entry now occupies the ith position in the array.
Our next remark is that each value of i = 1, 2, . . . , n is equally likely to occur. The reason for this is that
we chose the splitter originally by choosing a random array entry. Since all orderings of the array entries are
equally likely, the one that we happened to have chosen was just as likely to have been the largest entry as
to have been the smallest, or the 17th-from-largest, or whatever.
Since each value of i is equally likely, each i has probability 1/n of being chosen as the residence of the
splitter.
If the splitting element lives in the ith array position, the two recursive calls to Quicksort will be on
two subarrays, one of which has length iâˆ’ 1 and the other of which has length nâˆ’ i. The average numbers
of pairwise comparisons that are involved in such recursive calls are F (iâˆ’ 1) and F (nâˆ’ i), respectively. It
follows that our average complexity function F satisfies the relation
F (n) = n âˆ’ 1 + 1
n
nâˆ‘
i=1
{F (iâˆ’ 1) + F (nâˆ’ i)} (n â‰¥ 1). (2.2.2)
together with the initial value F (0) = 0.
How can we find the solution of the recurrence relation (2.2.2)? First letâ€™s simplify it a little by noticing
that
nâˆ‘
i=1
{F (nâˆ’ i)} = F (nâˆ’ 1) + F (nâˆ’ 2) + Â· Â· Â·+ F (0)
=
nâˆ‘
i=1
{F (iâˆ’ 1)}
(2.2.3)
and so (2.2.2) can be written as
F (n) = nâˆ’ 1 + 2
n
nâˆ‘
i=1
F (i âˆ’ 1). (2.2.4)
We can simplify (2.2.4) a lot by getting rid of the summation sign. This next step may seem like a trick
at first (and it is!), but itâ€™s a trick that is used in so many different ways that now we call it a â€˜method.â€™
What we do is first to multiply (2.2.4) by n, to get
nF (n) = n(n âˆ’ 1) + 2
nâˆ‘
i=1
F (i âˆ’ 1). (2.2.5)
Next, in (2.2.5) we replace n by nâˆ’ 1, yielding
(nâˆ’ 1)F (nâˆ’ 1) = (nâˆ’ 1)(n âˆ’ 2) + 2
nâˆ’1âˆ‘
i=1
F (i âˆ’ 1). (2.2.6)
Finally we subtract (2.2.6) from (2.2.5), and the summation sign obligingly disappears, leaving behind just
nF (n) âˆ’ (nâˆ’ 1)F (nâˆ’ 1) = n(n âˆ’ 1) âˆ’ (nâˆ’ 1)(n âˆ’ 2) + 2F (nâˆ’ 1). (2.2.7)
36
2.2 Quicksort
After some tidying up, (2.2.7) becomes
F (n) = (1 +
1
n
)F (nâˆ’ 1) + (2 âˆ’
2
n
). (2.2.8)
which is exactly in the form of the general first-order recurrence relation that we discussed in section 1.4.
In section 1.4 we saw that to solve (2.2.8) the winning tactic is to change to a new variable yn that is
defined, in this case, by
F (n) =
n+ 1
n
n
nâˆ’ 1
nâˆ’ 1
nâˆ’ 2
Â· Â· Â· 2
1
yn
= (n+ 1)yn.
(2.2.9)
If we make the change of variable F (n) = (n+ 1)yn in (2.2.8), then it takes the form
yn = ynâˆ’1 + 2(nâˆ’ 1)/n(n+ 1) (n â‰¥ 1) (2.2.10)
as an equation for the ynâ€™s (y0 = 0).
The solution of (2.2.10) is obviously
yn = 2
nâˆ‘
j=1
j âˆ’ 1
j(j + 1)
= 2
nâˆ‘
j=1
{
2
j + 1
âˆ’
1
j
}
= 2
nâˆ‘
j=1
1
j
âˆ’ 4n/(n+ 1).
Hence from (2.2.9),
F (n) = 2(n+ 1){
nâˆ‘
j=1
1/j} âˆ’ 4n (2.2.11)
is the average number of pairwise comparisons that we do if we Quicksort an array of length n. Evidently
F (n) âˆ¼ 2n logn (nâ†’ âˆž) (see (1.1.7) with g(t) = 1/t), and we have proved
Theorem 2.2.2. The average number of pairwise comparisons of array entries that Quicksort makes when
it sorts arrays of n elements is exactly as shown in (2.2.11), and is âˆ¼ 2n logn (n â†’ âˆž).
Quicksort is, on average, a very quick sorting method, even though its worst case requires a quadratic
amount of labor.
Exercises for section 2.2
1. Write out an array of 10 numbers that contains no splitter. Write out an array of 10 numbers that
contains 10 splitters.
2. Write a program that does the following. Given a positive integer n. Choose 100 random permutations
of [1, 2, . . . , n],* and count how many of the 100 had at least one splitter. Execute your program for n =
5, 6, . . . , 12 and tabulate the results.
3. Think of some method of sorting n numbers that isnâ€™t in the text. In the worst case, how many comparisons
might your method do? How many swaps?
* For a fast and easy way to do this see A. Nijenhuis and H. S. Wilf, Combinatorial Algorithms, 2nd ed. (New
York: Academic Press, 1978), chap. 6.
37
Chapter 2: Recursive Algorithms
4. Consider the array
x = {2, 4, 1, 10, 5, 3,9,7,8, 6}
with left = 1 and right = 10. Suppose that the procedure split is called, and suppose the random integer
L in step 1 happens to be 5. Carry out the complete split algorithm (not on a computer; use pencil and
paper). Particularly, record the condition of the array x after each value of j is processed in the for j = . . .
loop.
5. Suppose H(0) = 1 and H(n) â‰¤ 1 + 1n
âˆ‘n
i=1H(i âˆ’ 1) (n â‰¥ 1). How big might H(n) be?
6. If Q(0) = 0 and Q(n) â‰¤ n2 +
âˆ‘n
i=1Q(iâˆ’ 1) (n â‰¥ 1), how big might Q(n) be?
7. (Research problem) Find the asymptotic behavior, for large n, of the probability that a randomly chosen
permutation of n letters has a splitter.
2.3 Recursive graph algorithms
Algorithms on graphs are another rich area of applications of recursive thinking. Some of the problems
are quite different from the ones that we have so far been studying in that they seem to need exponential
amounts of computing time, rather than the polynomial times that were required for sorting problems.
We will illustrate the dramatically increased complexity with a recursive algorithm for the â€˜maximum
independent set problem,â€™ one which has received a great deal of attention in recent years.
Suppose a graph G is given. By an independent set of vertices of G we mean a set of vertices no two of
which are connected by an edge of G. In the graph in Fig. 2.3.1 the set {1, 2, 6} is an independent set and so
is the set {1, 3}. The largest independent set of vertices in the graph shown there is the set {1, 2, 3, 6}. The
problem of finding the size of the largest independent set in a given graph is computationally very difficult.
All algorithms known to date require exponential amounts of time, in their worst cases, although no one has
proved the nonexistence of fast (polynomial time) algorithms.
If the problem itself seems unusual, and maybe not deserving of a lot of attention, be advised that in
Chapter 5 we will see that it is a member in good standing of a large family of very important computational
problems (the â€˜NP-completeâ€™ problems) that are tightly bound together, in that if we can figure out better
ways to compute any one of them, then we will be able to do all of them faster.
Fig. 2.3.1
Here is an algorithm for the independent set problem that is easy to understand and to program,
although, of course, it may take a long time to run on a large graph G.
We are looking for the size of the largest independent set of vertices ofG. Suppose we denote that number
by maxset(G). Fix some vertex of the graph, say vertex vâˆ—. Letâ€™s distinguish two kinds of independent sets
of vertices of G. There are those that contain vertex vâˆ— and those that donâ€™t contain vertex vâˆ—.
If an independent set S of vertices contains vertex vâˆ—, then what does the rest of the set S consist of?
The remaining vertices of S are an independent set in a smaller graph, namely the graph that is obtained
from G by deleting vertex vâˆ— as well as all vertices that are connected to vertex vâˆ— by an edge. This latter
set of vertices is called the neighborhood of vertex vâˆ—, and is written Nbhd(vâˆ—).
The set S consists, therefore, of vertex vâˆ— together with an independent set of vertices from the graph
Gâˆ’ {vâˆ—} âˆ’Nbhd(vâˆ—).
Now consider an independent set S that doesnâ€™t contain vertex vâˆ—. In that case the set S is simply an
independent set in the smaller graph Gâˆ’ {vâˆ—}.
38
2.3 Recursive graph algorithms
We now have all of the ingredients of a recursive algorithm. Suppose we have found the two numbers
maxset(Gâˆ’{vâˆ—}) and maxset(Gâˆ’{vâˆ—}âˆ’Nbhd(vâˆ—)). Then, from the discussion above, we have the relation
maxset(G) = max
{
maxset(G âˆ’ {vâˆ—}), 1 +maxset(G âˆ’ {vâˆ—} âˆ’Nbhd(vâˆ—))
}
.
We obtain the following recursive algorithm.
function maxset1(G);
{returns the size of the largest independent set of
vertices of G}
if G has no edges
then maxset1 := |V (G)|
else
choose some nonisolated vertex vâˆ— of G;
n1 := maxset1(G âˆ’ {vâˆ—});
n2 := maxset1(G âˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—));
maxset1 := max(n1, 1 + n2)
end.{maxset1}
Example:
Here is an example of a graph G and the result of applying the maxset1 algorithm to it. Let the graph
G be a 5-cycle. That is, it has 5 vertices and its edges are (1, 2), (2, 3), (3, 4), (4,5), (1,5). What are the two
graphs on which the algorithm calls itself recursively?
Suppose we select vertex number 1 as the chosen vertex v in the algorithm. Then G âˆ’ {1} and G âˆ’
{1} âˆ’ Nbhd(1) are respectively the two graphs shown in Fig. 2.3.2.
2 3 4 5 3 4
Fig. 2.3.2: Gâˆ’ {1} Gâˆ’ {1} âˆ’Nbhd(1)
The reader should now check that the size of the largest independent set of G is equal to the larger of
the two numbers maxset1(G âˆ’ {1}), 1 +maxset1(G âˆ’ {1} âˆ’Nbhd(1)) in this example.
Of course the creation of these two graphs from the original input graph is just the beginning of the
story, as far as the computation is concerned. Unbeknownst to the programmer, who innocently wrote the
recursive routine maxset1 and then sat back to watch, the compiler will go ahead with the computation by
generating a tree-full of graphs. In Fig. 2.3.3 we show the collection of all of the graphs that the compiler
might generate while executing a single call to maxset1 on the input graph of this example. In each case,
the graph that is below and to the left of a given one is the one obtained by deleting a single vertex, and the
one below and to the right of each graph is obtained by deleting a single vertex and its entire neighborhood.
Now we are going to study the complexity of maxset1. The results will be sufficiently depressing that
we will then think about how to speed up the algorithm, and we will succeed in doing that to some extent.
To open the discussion, letâ€™s recall that in Chapter 0 it was pointed out that the complexity of a
calculation is usefully expressed as a function of the number of bits of input data. In problems about graphs,
however, it is more natural to think of the amount of labor as a function of n, the number of vertices of the
graph. In problems about matrices it is more natural to use n, the size of the matrix, and so forth.
Do these distinctions alter the classification of problems into â€˜polynomial time do-ableâ€™ vs. â€˜hardâ€™? Take
the graph problems, for instance. How many bits of input data does it take to describe a graph? Well,
certainly we can march through the entire list of n(nâˆ’ 1)/2 pairs of vertices and check off the ones that are
actually edges in the input graph to the problem. Hence we can describe a graph to a computer by making
39
Chapter 2: Recursive Algorithms
Fig. 2.3.3: A tree-full of graphs is created
a list of n(nâˆ’ 1)/2 0â€™s and 1â€™s. Each 1 represents a pair that is an edge, each 0 represents one that isnâ€™t an
edge.
Thus Î˜(n2) bits describe a graph. Since n2 is a polynomial in n, any function of the number of input
data bits that can be bounded by a polynomial in same, can also be bounded by a polynomial in n itself.
Hence, in the case of graph algorithms, the â€˜easinessâ€™ vs. â€˜hardnessâ€™ judgment is not altered if we base the
distinction on polynomials in n itself, rather than on polynomials in the number of bits of input data.
Hence, with a clear conscience, we are going to estimate the running time or complexity of graph
algorithms in terms of the number of vertices of the graph that is input.
Now letâ€™s do this for algorithm maxset1 above.
The first step is to find out if G has any edges. To do this we simply have to look at the input data.
In the worst case we might look at all of the input data, all Î˜(n2) bits of it. Then, if G actually has some
edges, the additional labor needed to process G consists of two recursive calls on smaller graphs and one
computation of the larger of two numbers.
If F (G) denotes the total amount of computational labor that we do in order to find maxset1(G), then
we see that
F (G) â‰¤ cn2 + F (Gâˆ’ {vâˆ—}) + F (Gâˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—)). (2.3.1)
Next, let f(n) = max|V (G)|=n F (G), and take the maximum of (2.3.1) over all graphs G of n vertices. The
result is that
f(n) â‰¤ cn2 + f(n âˆ’ 1) + f(n âˆ’ 2) (2.3.2)
because the graph Gâˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—) might have as many as nâˆ’ 2 vertices, and would have that many
if vâˆ— had exactly one neighbor.
Now itâ€™s time to â€˜solveâ€™ the recurrent inequality (2.3.2). Fortunately the hard work has all been done,
and the answer is in theorem 1.4.1. That theorem was designed expressly for the analysis of recursive
algorithms, and in this case it tells us that f(n) = O((1.619n)). Indeed the number c in that theorem is
(1 +
âˆš
5)/2 = 1.61803.... We chose the â€˜â€™ that appears in the conclusion of the theorem simply by rounding
c upwards.
What have we learned? Algorithm maxset1 will find the answer in a time of no more than O(1.619n)
units if the input graph G has n vertices. This is a little improvement of the most simple-minded possible
40
2.3 Recursive graph algorithms
algorithm that one might think of for this problem, which is to examine every single subset of the vertices of
of G and ask if it is an independent set or not. That algorithm would take Î˜(2n) time units because there
are 2n subsets of vertices to look at. Hence we have traded in a 2n for a 1.619n by being a little bit cagey
about the algorithm. Can we do still better?
There have in fact been a number of improvements of the basic maxset1 algorithm worked out. Of
these the most successful is perhaps the one of Tarjan and Trojanowski that is cited in the bibliography at
the end of this chapter. We are not going to work out all of those ideas here, but instead we will show what
kind of improvements on the basic idea will help us to do better in the time estimate.
We can obviously do better if we choose vâˆ— in such a way as to be certain that it has at least two
neighbors. If we were to do that then although we wouldnâ€™t affect the number of vertices of Gâˆ’{vâˆ—} (always
nâˆ’ 1) we would at least reduce the number of vertices of Gâˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—) as much as possible.
So, as our next thought, we might replace the instruction â€˜choose some nonisolated vertex vâˆ— of Gâ€™ in
maxset1 by an instruction â€˜choose some vertex vâˆ— of G that has at least two neighbors.â€™ Then we could be
quite certain that Gâˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—) would have at most nâˆ’ 3 vertices.
What if there isnâ€™t any such vertex in the graph G? Then G would contain only vertices with 0 or 1
neighbors. Such a graph G would be a collection of E disjoint edges together with a number m of isolated
vertices. The size of the largest independent set of vertices in such a graph is easy to find. A maximum
independent set contains one vertex from each of the E edges and it contains all m of the isolated vertices.
Hence in this case, maxset = E +m = |V (G)| âˆ’ |E(G)|, and we obtain a second try at a good algorithm in
the following form.
procedure maxset2(G);
{returns the size of the largest independent set of
vertices of G}
if G has no vertex of degree â‰¥ 2
then maxset2 := |V (G)| âˆ’ |E(G)|
else
choose a vertex vâˆ— of degree â‰¥ 2;
n1 := maxset2(Gâˆ’ {vâˆ—});
n2 := maxset2(Gâˆ’ {vâˆ—} âˆ’ Nbhd(vâˆ—) );
maxset2 := max(n1, 1 + n2)
end.{maxset2}
How much have we improved the complexity estimate? If we apply to maxset2 the reasoning that led
to (2.3.2) we find
f(n) â‰¤ cn2 + f(n âˆ’ 1) + f(n âˆ’ 3) (f(0) = 0; n = 2, 3, . . .), (2.3.3)
where f(n) is once more the worst-case time bound for graphs of n vertices.
Just as before, (2.3.3) is a recurrent inequality of the form that was studied at the end of section 1.4,
in theorem 1.4.1. Using the conclusion of that theorem, we find from (2.3.3) that f(n) = O((c+ )n) where
c = 1.46557.. is the positive root of the equation c3 = c2 + 1.
The net result of our effort to improve maxset1 to maxset2 has been to reduce the running-time bound
from O(1.619n) to O(1.47n), which isnâ€™t a bad dayâ€™s work. In the exercises below we will develop maxset3,
whose running time will be O(1.39n). The idea will be that since in maxset2 we were able to insure that vâˆ—
had at least two neighbors, why not try to insure that vâˆ— has at least 3 of them?
As long as we have been able to reduce the time bound more and more by insuring that the selected
vertex has lots of neighbors, why donâ€™t we keep it up, and insist that vâˆ— should have 4 or more neighbors?
Regrettably the method runs out of steam precisely at that moment. To see why, ask what the â€˜trivial caseâ€™
would then look like. We would be working on a graph G in which no vertex has more than 3 neighbors.
Well, what â€˜trivialthingâ€™ shall we do, in this â€˜trivial caseâ€™?
The fact is that there isnâ€™t any way of finding the maximum independent set in a graph where all
vertices have â‰¤ 3 neighbors thatâ€™s any faster than the general methods that weâ€™ve already discussed. In fact,
if one could find a fast method for that restricted problem it would have extremely important consequences,
because we would then be able to do all graphs rapidly, not just those special ones.
41
Chapter 2: Recursive Algorithms
We will learn more about this phenomenon in Chapter 5, but for the moment letâ€™s leave just the
observation that the general problem of maxset turns out to be no harder than the special case of maxset
in which no vertex has more than 3 neighbors.
Aside from the complexity issue, the algorithm maxset has shown how recursive ideas can be used to
transform questions about graphs to questions about smaller graphs.
Hereâ€™s another example of such a situation. Suppose G is a graph, and that we have a certain supply
of colors available. To be exact, suppose we have K colors. We can then attempt to color the vertices of G
properly in K colors (see section 1.6).
If we donâ€™t have enough colors, and G has lots of edges, this will not be possible. For example, suppose
G is the graph of Fig. 2.3.4, and suppose we have just 3 colors available. Then there is no way to color the
vertices without ever finding that both endpoints of some edge have the same color. On the other hand, if
we have four colors available then we can do the job.
Fig. 2.3.4
There are many interesting computational and theoretical problems in the area of coloring of graphs.
Just for its general interest, we are going to mention the four-color theorem, and then we will turn to a study
of some of the computational aspects of graph coloring.
First, just for general cultural reasons, letâ€™s slow down for a while and discuss the relationship between
graph colorings in general and the four-color problem, even though it isnâ€™t directly relevant to what weâ€™re
doing.
The original question was this. Suppose that a delegation of Earthlings were to visit a distant planet
and find there a society of human beings. Since that race is well known for its squabbling habits, you can
be sure that the planet will have been carved up into millions of little countries, each with its own ruling
class, system of government, etc., and of course, all at war with each other. The delegation wants to escape
quickly, but before doing so it draws a careful map of the 5,000,000 countries into which the planet has
been divided. To make the map easier to read, the countries are then colored in such a way that whenever
two countries share a stretch of border they are of two different colors. Surprisingly, it was found that the
coloring could be done using only red, blue, yellow and green.
It was noticed over 100 years ago that no matter how complicated a map is drawn, and no matter how
many countries are involved, it seems to be possible to color the countries in such a way that
(a) every pair of countries that have a common stretch of border have different colors and
(b) no more than four colors are used in the entire map.
It was then conjectured that four colors are always sufficient for the proper coloring of the countries
of any map at all. Settling this conjecture turned out to be a very hard problem. It was finally solved in
1976 by K. Appel and W. Haken* by means of an extraordinary proof with two main ingredients. First they
showed how to reduce the general problem to only a finite number of cases, by a mathematical argument.
Then, since the â€˜finite numberâ€™ was over 1800, they settled all of those cases with quite a lengthy computer
calculation. So now we have the â€˜Four Color Theorem,â€™ which asserts that no matter how we carve up the
plane or the sphere into countries, we will always be able to color those countries with at most four colors
so that countries with a common frontier are colored differently.
We can change the map coloring problem into a graph coloring problem as follows. Given a map. From
the map we will construct a graph G. There will be a vertex of G corresponding to each country on the
map. Two of these vertices will be connected by an edge of the graph G if the two countries that they
correspond to have a common stretch of border (we keep saying â€˜stretch of borderâ€™ to emphasize that if the
two countries have just a single point in common they are allowed to have the same color). As an illustration
* Every planar map is four colorable, Bull. Amer. Math. Soc., 82 (1976), 711-712.
42
2.3 Recursive graph algorithms
Fig. 2.3.5(a) Fig. 2.3.5(b)
of this construction, we show in Fig. 2.3.5(a) a map of a distant planet, and in Fig. 2.3.5(b) the graph that
results from the construction that we have just described.
By a â€˜planar graphâ€™ we mean a graph G that can be drawn in the plane in such a way that two edges
never cross (except that two edges at the same vertex have that vertex in common). The graph that results
from changing a map of countries into a graph as described above is always a planar graph. In Fig. 2.3.6(a)
we show a planar graph G. This graph doesnâ€™t look planar because two of its edges cross. However, that isnâ€™t
the graphâ€™s fault, because with a little more care we might have drawn the same graph as in Fig. 2.3.6(b), in
which its planarity is obvious. Donâ€™t blame the graph if it doesnâ€™t look planar. It might be planar anyway!
Fig. 2.3.6(a) Fig. 2.3.6(b)
The question of recognizing whether a given graph is planar is itself a formidable problem, although the
solution, due to J. Hopcroft and R. E. Tarjan,* is an algorithm that makes the decision in linear time, i.e.
in O(V ) time for a graph of V vertices.
Although every planar graph can be properly colored in four colors, there are still all of those other
graphs that are not planar to deal with. For any one of those graphs we can ask, if a positive integer K is
given, whether or not its vertices can be K-colored properly.
As if that question werenâ€™t hard enough, we might ask for even more detail, namely about the number
of ways of properly coloring the vertices of a graph. For instance, if we have K colors to work with, suppose
G is the empty graph Kn, that is, the graph of n vertices that has no edges at all. Then G has quite a large
number of proper colorings, Kn of them, to be exact. Other graphs of n vertices have fewer proper colorings
than that, and an interesting computational question is to count the proper colorings of a given graph.
We will now find a recursive algorithm that will answer this question. Again, the complexity of the
algorithm will be exponential, but as a small consolation we note that no polynomial time algorithm for this
problem is known.
Choose an edge e of the graph, and let its endpoints be v and w. Now delete the edge e from the graph,
and let the resulting graph be called G âˆ’ {e}. Then we will distinguish two kinds of proper colorings of
Gâˆ’{e}: those in which vertices v and w have the same color and those in which v and w have different colors.
Obviously the number of proper colorings of Gâˆ’ {e} in K colors is the sum of the numbers of colorings of
each of these two kinds.
* Efficient planarity testing, J. Assoc. Comp. Mach. 21 (1974), 549-568.
43
Chapter 2: Recursive Algorithms
Consider the proper colorings in which vertices v and w have the same color. We claim that the number
of such colorings is equal to the number of all colorings of a certain new graph G/{e}, whose construction
we now describe:
The vertices of G/{e} consist of the vertices of G other than v or w and one new vertex that we will
call â€˜vwâ€™ (so G/{e} will have one less vertex than G has).
Now we describe the edges of G/{e}. First, if a and b are two vertices of G/{e} neither of which is the
new vertex â€˜vwâ€™, then (a, b) is an edge of G/{e} if and only if it is an edge of G. Second, (vw, b) is an edge
of G/{e} if and only if either (v, b) or (w, b) (or both) is an edge of G.
We can think of this as â€˜collapsingâ€™ the graph G by imagining that the edges of G are elastic bands,
and that we squeeze vertices v and w together into a single vertex. The result is G/{e} (anyway, it is if we
replace any resulting double bands by single ones!).
In Fig. 2.3.7(a) we show a graph G of 7 vertices and a chosen edge e. The two endpoints of e are v
and w. In Fig. 2.3.7(b) we show the graph G/{e} that is the result of the construction that we have just
described.
Fig. 2.3.7(a) Fig. 2.3.7(b)
The point of the construction is the following
Lemma 2.3.1. Let v and w be two vertices of G such that e = (v, w) âˆˆ E(G). Then the number of proper
K-colorings of Gâˆ’ {e} in which v and w have the same color is equal to the number of all proper colorings
of the graph G/{e}.
Proof: Suppose G/{e} has a proper K-coloring. Color the vertices of Gâˆ’ {e} itself in K colors as follows.
Every vertex of Gâˆ’{e} other than v or w keeps the same color that it has in the coloring of G/{e}. Vertex v
and vertex w each receive the color that vertex vw has in the coloring of G/{e}. Now we have a K-coloring
of the vertices of Gâˆ’ {e}.
It is a proper coloring because if f is any edge of G âˆ’ {e} then the two endpoints of f have different
colors. Indeed, this is obviously true if neither endpoint of f is v or w because the coloring of G/{e} was a
proper one. There remains only the case where one endpoint of f is, say, v and the other one is some vertex
x other than v or w. But then the colors of v and x must be different because vw and x were joined in
G/{e} by an edge, and therefore must have gotten different colors there.
To get back to the main argument, we were trying to compute the number of proper K-colorings of
G âˆ’ {e}. We observed that in any K-coloring v and w have either the same or different colors. We have
shown that the number of colorings in which they receive the same color is equal to the number of all proper
colorings of a certain smaller (one less vertex) graph G/{e}. It remains to look at the case where vertices v
and w receive different colors.
Lemma 2.3.2. Let e = (v, w) be an edge of G. Then the number of proper K-colorings of Gâˆ’{e} in which
v and w have different colors is equal to the number of all proper K-colorings of G itself.
Proof: Obvious (isnâ€™t it?).
Now letâ€™s put together the results of the two lemmas above. Let P (K;G) denote the number of ways of
properly coloring the vertices of a given graph G. Then lemmas 2.3.1 and 2.3.2 assert that
P (K;Gâˆ’ {e}) = P (K;G/{e}) + P (K;G)
44
2.3 Recursive graph algorithms
or if we solve for P (K;G), then we have
P (K;G) = P (K;Gâˆ’ {e}) âˆ’ P (K;G/{e}). (2.3.4)
The quantity P (K;G), the number of ways of properly coloring the vertices of a graph G in K colors,
is called the chromatic polynomial of G.
We claim that it is, in fact, a polynomial in K of degree |V (G)|. For instance, if G is the complete
graph of n vertices then obviously P (K,G) = K(K âˆ’ 1) Â· Â· Â· (K âˆ’ n+ 1), and that is indeed a polynomial in
K of degree n.
Proof of claim: The claim is certainly true if G has just one vertex. Next suppose the assertion is true for
graphs of < V vertices, then we claim it is true for graphs of V vertices also. This is surely true if G has V
vertices and no edges at all. Hence, suppose it is true for all graphs of V vertices and fewer than E edges,
and let G have V vertices and E edges. Then (2.3.4) implies that P (K;G) is a polynomial of the required
degree V because Gâˆ’{e} has fewer edges than G does, so its chromatic polynomial is a polynomial of degree
V . G/{e} has fewer vertices than G has, and so P (K;G/{e}) is a polynomial of lower degree. The claim is
proved, by induction.
Equation (2.3.4) gives a recursive algorithm for computing the chromatic polynomial of a graph G, since
the two graphs that appear on the right are both â€˜smallerâ€™ than G, one in the sense that it has fewer edges
than G has, and the other in that it has fewer vertices. The algorithm is the following.
function chrompoly(G:graph): polynomial;
{computes the chromatic polynomial of a graph G}
if G has no edges then chrompoly:=K |V (G)|
else
choose an edge e of G;
chrompoly:=chrompoly(G âˆ’ {e})âˆ’chrompoly(G/{e})
end.{chrompoly}
Next we are going to look at the complexity of the algorithm chrompoly (we will also refer to it as â€˜the
delete-and-identifyâ€™ algorithm). The graph G can be input in any one of a number of ways. For example,
we might input the full list of edges of G, as a list of pairs of vertices.
The first step of the computation is to choose the edge e and to create the edge list of the graph Gâˆ’{e}.
The latter operation is trivial, since all we have to do is to ignore one edge in the list.
Next we call chrompoly on the graph Gâˆ’ {e}.
The third step is to create the edge list of the collapsed graph G/{e} from the edge list of G itself. That
involves some work, but it is rather routine, and its cost is linear in the number of edges of G, say c|E(G)|.
Finally we call chrompoly on the graph G/{e}.
Let F (V,E) denote the maximum cost of calling chrompoly on any graph of at most V vertices and at
most E edges. Then we see at once that
F (V,E) â‰¤ F (V,E âˆ’ 1) + cE + F (V âˆ’ 1, E âˆ’ 1) (2.3.5)
together with F (V, 0) = 0. If we put, successively, E = 1, 2, 3, we find that F (V, 1) â‰¤ c, F (V, 2) â‰¤ 4c, and
F (V, 3) â‰¤ 11c. Hence we seek a solution of (2.3.5) in the form F (V,E) â‰¤ f(E)c, and we quickly find that if
f(E) = 2f(E âˆ’ 1) +E (f(0) = 0) (2.3.6)
then we will have such a solution.
Since (2.3.6) is a first-order difference equation of the form (1.4.5), we find that
f(E) = 2E
Eâˆ‘
j=0
j2âˆ’j
âˆ¼ 2E+1.
(2.3.7)
45
Chapter 2: Recursive Algorithms
The last â€˜âˆ¼â€™ follows from the evaluation
âˆ‘
j2âˆ’j = 2 that we discussed in section 1.3.
To summarize the developments so far, then, we have found out that the chromatic polynomial of a graph
can be computed recursively by an algorithm whose cost is O(2E) for graphs of E edges. This is exponential
cost, and such computations are prohibitively expensive except for graphs of very modest numbers of edges.
Of course the mere fact that our proved time estimate is O(2E) doesnâ€™t necessarily mean that the
algorithm can be that slow, because maybe our complexity analysis wasnâ€™t as sharp as it might have been.
However, consider the graph G(s, t) that consists of s disjoint edges and t isolated vertices, for a total of
2s + t vertices altogether. If we choose an edge of G(s, t) and delete it, we get G(s âˆ’ 1, t+ 2), whereas the
graph G/{e} is G(sâˆ’ 1, t+ 1). Each of these two new graphs has s âˆ’ 1 edges.
We might imagine arranging the computation so that the extra isolated vertices will be â€˜free,â€™ i.e., will
not cost any additional labor. Then the work that we
do on G(s, t) will depend only on s, and will be twice as much as the work we do on G(sâˆ’1, Â·). Therefore
G(s, t) will cost at least 2s operations, and our complexity estimate wasnâ€™t a mirage, there really are graphs
that make the algorithm do an amount 2|E(G)| of work.
Considering the above remarks it may be surprising that there is a slightly different approach to the
complexity analysis that leads to a time bound (for the same algorithm) that is a bit sharper than O(2E) in
many cases (the work of the complexity analyst is never finished!). Letâ€™s look at the algorithm chrompoly
in another way.
For a graph G we can define a number Î³(G) = |V (G)| + |E(G)|, which is rather an odd kind of thing
to define, but it has a nice property with respect to this algorithm, namely that whatever G we begin with,
we will find that
Î³(G âˆ’ {e}) = Î³(G) âˆ’ 1; Î³(G/{e}) â‰¤ Î³(G) âˆ’ 2. (2.3.8)
Indeed, if we delete the edge e then Î³ must drop by 1, and if we collapse the graph on the edge e then we
will have lost one vertex and at least one edge, so Î³ will drop by at least 2.
Hence, if h(Î³) denotes the maximum amount of labor that chrompoly does on any graph G for which
|V (G)|+ |E(G)| â‰¤ Î³ (2.3.9)
then we claim that
h(Î³) â‰¤ h(Î³ âˆ’ 1) + h(Î³ âˆ’ 2) (Î³ â‰¥ 2). (2.3.10)
Indeed, if G is a graph for which (2.3.9) holds, then if G has any edges at all we can do the delete-and-identify
step to prove that the labor involved in computing the chromatic polynomial of G is at most the quantity
on the right side of (2.3.10). Else, if G has no edges then the labor is 1 unit, which is again at most equal
to the right side of (2.3.10), so the result (2.3.10) follows.
With the initial conditions h(0) = h(1) = 1 the solution of the recurrent inequality (2.3.10) is obviously
the relation h(Î³) â‰¤ FÎ³ , where FÎ³ is the Fibonacci number. We have thereby proved that the time complexity
of the algorithm chrompoly is
O(F|V (G)|+|E(G)|) = O
(
(
1 +
âˆš
5
2
)|V (G)|+|E(G)|
)
= O(1.62|V (G)|+|E(G)|).
(2.3.11)
This analysis does not, of course, contradict the earlier estimate, but complements it. What we have
shown is that the labor involved is always
O
(
min(2|E(G)|, 1.62|V (G)|+|E(G)|)
)
. (2.3.12)
On a graph with â€˜fewâ€™ edges relative to its number of vertices (how few?) the first quantity in the parentheses
in (2.3.12) will be the smaller one, whereas if G has more edges, then the second term is the smaller one. In
either case the overall judgment about the speed of the algorithm (itâ€™s slow!) remains.
46
2.4 Fast matrix multiplication
Exercises for section 2.3
1. Let G be a cycle of n vertices. What is the size of the largest independent set of vertices in V (G)?
2. Let G be a path of n vertices. What is the size of the largest independent set of vertices in V (G)?
3. Let G be a connected graph in which every vertex has degree 2. What must such a graph consist of?
Prove.
4. Let G be a connected graph in which every vertex has degree â‰¤ 2. What must such a graph look like?
5. Let G be a not-necessarily-connected graph in which every vertex has degree â‰¤ 2. What must such a
graph look like? What is the size of the largest independent set of vertices in such a graph? How long would
it take you to calculate that number for such a graph G? How would you do it?
6. Write out algorithm maxset3, which finds the size of the largest independent set of vertices in a graph.
Its trivial case will occur if G has no vertex of degree â‰¥ 3. Otherwise, it will choose a vertex vâˆ— of degree
â‰¥ 3 and proceed as in maxset2.
7. Analyze the complexity of your algorithm maxset3 from exercise 6 above.
8. Use (2.3.4) to prove by induction that P (K;G) is a polynomial in K of degree |V (G)|. Then show that
if G is a tree then P (K;G) = K(K âˆ’ 1)|V (G)|âˆ’1.
9. Write out an algorithm that will change the vertex adjacency matrix of a graph G to the vertex adjacency
matrix of the graph G/{e}, where e is a given edge of G.
10. How many edges must G have before the second quantity inside the â€˜Oâ€™ in (2.3.12) is the smaller of the
two?
11. Let Î±(G) be the size of the largest independent set of vertices of a graph G, let Ï‡(G) be its chromatic
number, and let n = |V (G)|. Show that, for every G, Î±(G) â‰¥ n/Ï‡(G).
2.4 Fast matrix multiplication
Everybody knows how to multiply two 2 Ã— 2 matrices. If we want to calculate
(
c11 c12
c21 c22
)
=
(
a11 a12
a21 a22
) (
b11 b12
b21 b22
)
(2.4.1)
then, â€˜of course,â€™
ci,j =
2âˆ‘
k=1
ai,kbk,j (i, j = 1, 2). (2.4.2)
Now look at (2.4.2) a little more closely. In order to calculate each one of the 4 ci,jâ€™s we have to do 2
multiplications of numbers. The cost of multiplying two 2 Ã— 2 matrices is therefore 8 multiplications of
numbers. If we measure the cost in units of additions of numbers, the cost is 4 such additions. Hence, the
matrix multiplication method that is shown in (2.4.1) has a complexity of 8 multiplications of numbers and
4 additions of numbers.
This may seem rather unstartling, but the best ideas often have humble origins.
Suppose we could find another way of multiplying two 2 Ã— 2 matrices in which the cost was only 7
multiplications of numbers, together with more than 4 additions of numbers. Would that be a cause for
dancing in the streets, or would it be just a curiosity, of little importance? In fact, it would be extremely
important, and the consequences of such a step were fully appreciated only in 1969 by V. Strassen, to whom
the ideas that we are now discussing are due.*
What weâ€™re going to do next in this section is the following:
(a) describe another way of multiplying two 2Ã— 2 matrices in which the cost will be only 7 multipli-
cations of numbers plus a bunch of additions of numbers, and
(b) convince you that it was worth the trouble.
The usefulness of the idea stems from the following amazing fact: if two 2Ã—2 matrices can be multiplied
with only 7 multiplications of numbers, then two N Ã— N matrices can be multiplied using only O(N2.81...)
* V. Strassen, Gaussian elimination is not optimal, Numerische Math. 13 (1969), 354-6.
47
Chapter 2: Recursive Algorithms
multiplications of numbers instead of the N3 such multiplications that the usual method involves (the number
â€˜2.81...â€™ is log2 7).
In other words, if we can reduce the number of multiplications of numbers that are needed to multiply two
2Ã—2 matrices, then that improvement will show up in the exponent of N when we measure the complexity of
multiplying two N Ã—N matrices. The reason, as we will see, is that the little improvement will be pyramided
by numerous recursive calls to the 2 Ã— 2 procedureâ€“ but we get ahead of the story.
Now letâ€™s write out another way to do the 2 Ã— 2 matrix multiplication that is shown in (2.4.1). Instead
of doing it aÌ laÌ€ (2.4.2), try the following 11-step approach.
First compute, from the input 2 Ã— 2 matrices shown in (2.4.1), the following 7 quantities:
I = (a12 âˆ’ a22) Ã— (b21 + b22)
II = (a11 + a22) Ã— (b11 + b22)
III = (a11 âˆ’ a21) Ã— (b11 + b12)
IV = (a11 + a12) Ã— b22
V = a11 Ã— (b12 âˆ’ b22)
V I = a22 Ã— (b21 âˆ’ b11)
V II = (a21 + a22) Ã— b11
(2.4.3)
and then calculate the 4 entries of the product matrix C = AB from the 4 formulas
c11 = I + II âˆ’ IV + V I
c12 = IV + V
c21 = V I + V II
c22 = II âˆ’ III + V âˆ’ V II.
(2.4.4)
The first thing to notice about this seemingly overelaborate method of multiplying 2 Ã— 2 matrices is that
only 7 multiplications of numbers are used (count the â€˜Ã—â€™ signs in (2.4.3)). â€˜Well yes,â€™ you might reply, â€˜but
18 additions are needed, so where is the gain?â€™
It will turn out that multiplications are more important than additions, not because computers can do
them faster, but because when the routine is called recursively each â€˜Ã—â€™ operation will turn into a multipli-
cation of two big matrices whereas each â€˜Â±â€™ will turn into an addition or subtraction of two big matrices,
and thatâ€™s much cheaper.
Next weâ€™re going to describe how Strassenâ€™s method (equations (2.4.3), (2.4.4)) of multiplying 2 Ã— 2
matrices can be used to speed up multiplications of N Ã—N matrices. The basic idea is that we will partition
each of the large matrices into four smaller ones and multiply them together using (2.4.3), (2.4.4).
Suppose that N is a power of 2, say N = 2n, and let there be given two N Ã— N matrices, A and B.
We imagine that A and B have each been partitioned into four 2nâˆ’1 Ã— 2nâˆ’1 matrices, and that the product
matrix C is similarly partitioned. Hence we want to do the matrix multiplication that is indicated by
(
C11 C12
C21 C22
)
=
(
A11 A12
A21 A22
) (
B11 B12
B21 B22
)
(2.4.5)
where now each of the capital letters represents a 2nâˆ’1 Ã— 2nâˆ’1 matrix.
To do the job in (2.4.5) we use exactly the 11 formulas that are shown in (2.4.3) and (2.4.4), except
that the lower-case letters are now all upper case. Suddenly we very much appreciate the reduction of the
number of â€˜Ã—â€™ signs because it means one less multiplication of large matrices, and we donâ€™t so much mind
that it has been replaced by 10 more â€˜Â±â€™ signs, at least not if N is very large.
This yields the following recursive procedure for multiplying large matrices.
48
2.4 Fast matrix multiplication
function MatrProd(A, B: matrix; N :integer):matrix;
{MatrProd is AB, where A and B are N Ã— N}
{uses Strassen method}
if N is not a power of 2 then
border A and B by rows and columns of 0â€™s until
their size is the next power of 2 and change N ;
if N = 1 then MatrProd := AB
else
partition A and B as shown in (2.4.5);
I := MatrProd(A11 âˆ’ A22, B21 +B22, N/2);
II := MatrProd(A11 +A22, B11 + B22, N/2);
etc. etc., through all 11 of the formulas
shown in (2.4.3), (2.4.4), ending with ...
C22 := II âˆ’ III + V âˆ’ V II
end.{MatrProd}
Note that this procedure calls itself recursively 7 times. The plus and minus signs in the program each
represent an addition or subtraction of two matrices, and therefore each one of them involves a call to a
matrix addition or subtraction procedure (just the usual method of adding, nothing fancy!). Therefore the
function MatrProd makes 25 calls, 7 of which are recursively to itself, and 18 of which are to a matrix
addition/subtraction routine.
We will now study the complexity of the routine in two ways. We will count the number of multiplications
of numbers that are needed to multiply two 2n Ã— 2n matrices using MatrProd (call that number f(n)), and
then we will count the number of additions of numbers (call it g(n)) that MatrProd needs in order to
multiply two 2n Ã— 2n matrices.
The multiplications of numbers are easy to count. MatrProd calls itself 7 times, in each of which it
does exactly f(n âˆ’ 1) multiplications of numbers, hence f(n) = 7f(n âˆ’ 1) and f(0) = 1 (why?). Therefore
we see that f(n) = 7n for all n â‰¥ 0. Hence MatrProd does 7n multiplications of numbers in order to do one
multiplication of 2n Ã— 2n matrices.
Letâ€™s take the last sentence in the above paragraph and replace â€˜2nâ€™ by N throughout. It then tells
us that MatrProd does 7log N/ log 2 multiplications of numbers in order to do one multiplication of N Ã— N
matrices. Since 7log N/ log 2 = N log 7/ log 2 = N2.81..., we see that Strassenâ€™s method uses only O(N2.81)
multiplications of numbers, in place of the N3 such multiplications that are required by the usual formulas.
It remains to count the additions/subtractions of numbers that are needed by MatrProd.
In each of its 7 recursive calls to itself MatrProd does g(n âˆ’ 1) additions of numbers. In each of its
18 calls to the procedure that adds or subtracts matrices it does a number of additions of numbers that is
equal to the square of the size of the matrices that are being added or subtracted. That size is 2nâˆ’1, so each
of the 18 such calls does 22nâˆ’2 additions of numbers. It follows that g(0) = 0 and for n â‰¥ 1 we have
g(n) = 7g(nâˆ’ 1) + 18 Â· 4nâˆ’1
= 7g(nâˆ’ 1) +
9
2
4n.
We follow the method of section 1.4 on this first-order linear difference equation. Hence we make the
change of variable g(n) = 7nyn (n â‰¥ 0) and we find that y0 = 0 and for n â‰¥ 1,
yn = ynâˆ’1 +
9
2
(4/7)n.
If we sum over n we obtain
yn =
9
2
nâˆ‘
j=1
(4/7)j
â‰¤ 9
2
âˆžâˆ‘
j=0
(4/7)n
= 21/2.
49
Chapter 2: Recursive Algorithms
Finally, g(n) = 7nyn â‰¤ (10.5)7n = O(7n), and this is O(N2.81) as before. This completes the proof of
Theorem 2.4.1. In Strassenâ€™s method of fast matrix multiplication the number of multiplications of num-
bers, of additions of numbers and of subtractions of numbers that are needed to multiply together two NÃ—N
matrices are each O(N2.81) (in contrast to the Î˜(N3) of the conventional method).
In the years that have elapsed since Strassenâ€™s original paper many researchers have been whittling
away at the exponent of N in the complexity bounds. Several new, and more elaborate algorithms have
been developed, and the exponent, which was originally 3, has progressed downwards through 2.81 to values
below 2.5. It is widely believed that the true minimum exponent is 2 + , i.e., that two N Ã—N matrices can
be multiplied in time O(N2+), but there seems to be a good deal of work to be done before that result can
be achieved.
Exercises for section 2.4
1. Suppose we could multiply together two 3 Ã— 3 matrices with only 22 multiplications of numbers. How
fast, recursively, would we then be able to multiply two N Ã— N matrices?
2. (cont.) With what would the â€˜22â€™ in problem 1 above have to be replaced in order to achieve an
improvement over Strassenâ€™s algorithm given in the text?
3. (cont.) Still more generally, with how few multiplications would we have to be able to multiply two
M Ã—M matrices in order to insure that recursively we would then be able to multiply two N Ã—N matrices
faster than the method given in this section?
4. We showed in the text that if N is a power of 2 then two N Ã— N matrices can be multiplied in at most
time CN log2 7, where C is a suitable constant. Prove that if N is not a power of 2 then two N Ã—N matrices
can be multiplied in time at most 7CN log2 7.
2.5 The discrete Fourier transform
It is a lot easier to multiply two numbers than to multiply two polynomials.
If you should want to multiply two polynomials f and g, of degrees 77 and 94, respectively, you are
in for a lot of work. To calculate just one coefficient of the product is already a lot of work. Think about
the calculation of the coefficient of x50 in the product, for instance, and you will see that about 50 numbers
must be multiplied together and added in order to calculate just that one coefficient of fg, and there are
171 other coefficients to calculate!
Instead of calculating the coefficients of the product fg it would be much easier just to calculate the
values of the product at, say, 172 points. To do that we could just multiply the values of f and of g at each
of those points, and after a total cost of 172 multiplications we would have the values of the product.
The values of the product polynomial at 172 distinct points determine that polynomial completely, so
that sequence of values is the answer. Itâ€™s just that we humans prefer to see polynomials given by means of
their coefficients instead of by their values.
The Fourier transform, that is the subject of this section, is a method of converting from one representa-
tion of a polynomial to another. More exactly, it converts from the sequence of coefficients of the polynomial
to the sequence of values of that polynomial at a certain set of points. Ease of converting between these two
representations of a polynomial is vitally important for many reasons, including multiplication of polynomi-
als, high precision integer arithmetic in computers, creation of medical images in CAT scanners and NMR
scanners, etc.
Hence, in this section we will study the discrete Fourier transform of a finite sequence of numbers,
methods of calculating it, and some applications.
This is a computational problem which at first glance seems very simple. What weâ€™re asked to do,
basically, is to evaluate a polynomial of degree n âˆ’ 1 at n different points. So what could be so difficult
about that?
If we just calculate the n values by brute force, we certainly wonâ€™t need to do more than nmultiplications
of numbers to find each of the n values of the polynomial that we want, so we surely donâ€™t need more than
O(n2) multiplications altogether.
50
2.5 The discrete Fourier transform
The interesting thing is that this particular problem is so important, and turns up in so many different
applications, that it really pays to be very efficient about how the calculation is done. We will see in this
section that if we use a fairly subtle method of doing this computation instead of the obvious method, then
the work can be cut down from O(n2) to O(n logn). In view of the huge arrays on which this program is
often run, the saving is very much worthwhile.
One can think of the Fourier transform as being a way of changing the description, or coding of a
polynomial, so we will introduce the subject by discussing it from that point of view.
Next we will discuss the obvious way of computing the transform.
Then we will describe the â€˜Fast Fourier Transformâ€™, which is a rather un-obvious, but very fast, method
of computing the same creature.
Finally we will discuss an important application of the subject, to the fast multiplication of polynomials.
There are many different ways that might choose to describe (â€˜encodeâ€™) a particular polynomial. Take
the polynomial f(t) = t(6 âˆ’ 5t + t2), for instance. This can be uniquely described in any of the following
ways (and a lot more).
It is the polynomial whose
(i) coefficients are 0, 6, âˆ’5, 1 or whose
(ii) roots are 0, 2 and 3, and whose highest coefficient is 1 or whose
(iii) values at t = 0, 1, 2, 3 are 0, 2, 0, 0, respectively, or whose
(iv) values at the fourth-roots of unity 1, i,âˆ’1,âˆ’i are 2, 5 + 5i, âˆ’12, 5 âˆ’ 5i, or etc.
We want to focus on two of these ways of representing a polynomial. The first is by its coefficient
sequence; the second is by its sequence of values at the nth roots of unity, where n is 1 more than the degree
of the polynomial. The process by which we pass from the coefficient sequence to the sequence of values at
the roots of unity is called forming the Fourier transform of the coefficient sequence. To use the example
above, we would say that the Fourier transform of the sequence
0, 6,âˆ’5, 1 (2.5.1)
is the sequence
2, 5 + 5i,âˆ’12, 5âˆ’ 5i. (2.5.2)
In general, if we are given a sequence
x0, x1, . . . , xnâˆ’1 (2.5.3)
then we think of the polynomial
f(t) = x0 + x1t+ x2t2 + Â· Â· Â·+ xnâˆ’1tnâˆ’1 (2.5.4)
and we compute its values at the nth roots of unity. These roots of unity are the numbers
Ï‰j = e2Ï€ij/n (j = 0, 1, . . ., nâˆ’ 1). (2.5.5)
Consequently, if we calculate the values of the polynomial (2.5.4) at the n numbers (2.5.5), we find the
Fourier transform of the given sequence (2.5.3) to be the sequence
f(Ï‰j ) =
nâˆ’1âˆ‘
k=0
xkÏ‰j
k
=
nâˆ’1âˆ‘
k=0
xke
2Ï€ijk/n (j = 0, 1, . . .n âˆ’ 1).
(2.5.6)
Before proceeding, the reader should pause for a moment and make sure that the fact that (2.5.1)-(2.5.2)
is a special case of (2.5.3)-(2.5.6) is clearly understood. The Fourier transform of a sequence of n numbers
is another sequence of n numbers, namely the sequence of values at the nth roots of unity of the very same
polynomial whose coefficients are the members of the original sequence.
51
Chapter 2: Recursive Algorithms
The Fourier transform moves us from coefficients to values at roots of unity. Some good reasons for
wanting to make that trip will appear presently, but for the moment, letâ€™s consider the computational side
of the question, namely how to compute the Fourier transform efficiently.
We are going to derive an elegant and very speedy algorithm for the evaluation of Fourier transforms.
The algorithm is called the Fast Fourier Transform (FFT) algorithm. In order to appreciate how fast it is,
letâ€™s see how long it would take us to calculate the transform without any very clever procedure.
What we have to do is to compute the values of a given polynomial at n given points. How much work
is required to calculate the value of a polynomial at one given point? If we want to calculate the value of
the polynomial x0 + x1t + x2t2 + . . .+ xnâˆ’1tnâˆ’1 at exactly one value of t, then we can do (think how you
would do it, before looking)
function value(x :coeff array; n:integer; t:complex);
{computes value := x0 + x1t+ Â· Â· Â·+ xnâˆ’1tnâˆ’1}
value := 0;
for j := nâˆ’ 1 to 0 step âˆ’1 do
value := t Â· value + xj
end.{value}
This well-known algorithm (= â€˜synthetic divisionâ€™) for computing the value of a polynomial at a single
point t obviously runs in time O(n).
If we calculate the Fourier transform of a given sequence of n points by calling the function value n
times, once for each point of evaluation, then obviously we are looking at a simple algorithm that requires
Î˜(n2) time.
With the FFT we will see that the whole job can be done in time O(n logn), and we will then look
at some implications of that fact. To put it another way, the cost of calculating all n of the values of a
polynomial f at the nth roots of unity is much less than n times the cost of one such calculation.
First we consider the important case where n is a power of 2, say n = 2r. Then the values of f , a
polynomial of degree 2r âˆ’ 1, at the (2r)th roots of unity are, from (2.5.6),
f(Ï‰j) =
nâˆ’1âˆ‘
k=0
xkexp{2Ï€ijk/2r} (j = 0, 1, . . ., 2r âˆ’ 1). (2.5.7)
Letâ€™s break up the sum into two sums, containing respectively the terms where k is even and those where k
is odd. In the first sum write k = 2m and in the second put k = 2m+ 1. Then, for each j = 0, 1, . . . , 2r âˆ’ 1,
f(Ï‰j) =
2râˆ’1âˆ’1âˆ‘
m=0
x2me
2Ï€ijm/2râˆ’1 +
2râˆ’1âˆ’1âˆ‘
m=0
x2m+1e
2Ï€ij(2m+1)/2r
=
2râˆ’1âˆ’1âˆ‘
m=0
x2me
2Ï€ijm/2râˆ’1 + e2Ï€ij/2
r
2râˆ’1âˆ’1âˆ‘
m=0
x2m+1e
2Ï€ijm/2râˆ’1 .
(2.5.8)
Something special just happened. Each of the two sums that appear in the last member of (2.5.8) is
itself a Fourier transform, of a shorter sequence. The first sum is the transform of the array
x[0], x[2], x[4], . . . , x[2r âˆ’ 2] (2.5.9)
and the second sum is the transform of
x[1], x[3], x[5], . . ., x[2r âˆ’ 1]. (2.5.10)
The stage is set (well, almost set) for a recursive program.
52
2.5 The discrete Fourier transform
There is one small problem, though. In (2.5.8) we want to compute f(Ï‰j ) for 2r values of j, namely for
j = 0, 1, . . . , 2r âˆ’ 1. However, the Fourier transform of the shorter sequence (2.5.9) is defined for only 2râˆ’1
values of j, namely for j = 0, 1, . . . , 2râˆ’1 âˆ’ 1. So if we calculate the first sum by a recursive call, then we
will need its values for jâ€™s that are outside the range for which it was computed.
This problem is no sooner recognized than solved. Let Q(j) denote the first sum in (2.5.8). Then we
claim that Q(j) is a periodic function of j, of period 2râˆ’1, because
Q(j + 2râˆ’1) =
2râˆ’1âˆ’1âˆ‘
m=0
x2mexp{2Ï€im(j + 2râˆ’1)/2râˆ’1}
=
2râˆ’1âˆ’1âˆ‘
m=0
x2mexp{2Ï€imj/2râˆ’1}e2Ï€im
=
2râˆ’1âˆ’1âˆ‘
m=0
x2mexp{2Ï€imj/2râˆ’1}
= Q(j)
(2.5.11)
for all integers j. If Q(j) has been computed only for 0 â‰¤ j â‰¤ 2râˆ’1 âˆ’ 1 and if we should want its value for
some j â‰¥ 2râˆ’1 then we can get that value by asking for Q(j mod 2râˆ’1).
Now we can state the recursive form of the Fast Fourier Transform algorithm in the (most important)
case where n is a power of 2. In the algorithm we will use the type complexarray to denote an array of
complex numbers.
function FFT (n:integer; x :complexarray):complexarray;
{computes fast Fourier transform of n = 2k numbers x }
if n = 1 then FFT [0] := x[0]
else
evenarray := {x[0], x[2], . . ., x[nâˆ’ 2]};
oddarray := {x[1], x[3], . . . , x[nâˆ’ 1]};
{u[0], u[1], . . .u[n
2
âˆ’ 1]} := FFT (n/2, evenarray);
{v[0], v[1], . . .v[n
2
âˆ’ 1]} := FFT (n/2, oddarray);
for j := 0 to nâˆ’ 1 do
Ï„ := exp{2Ï€ij/n};
FFT [j] := u[j mod n2 ] + Ï„v[j mod
n
2 ]
end.{FFT}
Let y(k) denote the number of multiplications of complex numbers that will be done if we call FFT on
an array whose length is n = 2k. The call to FFT (n/2, evenarray) costs y(k âˆ’ 1) multiplications as does
the call to FFT (n/2, oddarray). The â€˜for j:= 0 to nâ€™ loop requires n more multiplications. Hence
y(k) = 2y(k âˆ’ 1) + 2k (k â‰¥ 1; y(0) = 0). (2.5.12)
If we change variables by writing y(k) = 2kzk, then we find that zk = zkâˆ’1 + 1, which, together with z0 = 0,
implies that zk = k for all k â‰¥ 0, and therefore that y(k) = k2k. This proves
Theorem 2.5.1. The Fourier transform of a sequence of n complex numbers is computed using only
O(n logn) multiplications of complex numbers by means of the procedure FFT , if n is a power of 2.
Next* we will discuss the situation when n is not a power of 2.
The reader may observe that by â€˜padding outâ€™ the input array with additional 0â€™s we can extend the
length of the array until it becomes a power of 2, and then call the FFT procedure that we have already
* The remainder of this section can be omitted at a first reading.
53
Chapter 2: Recursive Algorithms
discussed. In a particular application, that may or may not be acceptable. The problem is that the original
question asked for the values of the input polynomial at the nth roots of unity, but after the padding, we
will find the values at the N th roots of unity, where N is the next power of 2. In some applications, such as
the multiplication of polynomials that we will discuss later in this section, that change is acceptable, but in
others the substitution of N th roots for nth roots may not be permitted.
We will suppose that the FFT of a sequence of n numbers is wanted, where n is not a power of 2, and
where the padding operation is not acceptable. If n is a prime number we will have nothing more to say,
i.e. we will not discuss any improvements to the obvious method for calculating the transform, one root of
unity at a time.
Suppose that n is not prime (n is â€˜compositeâ€™). Then we can factor the integer n in some nontrivial
way, say n = r1r2 where neither r1 nor r2 is 1.
We claim, then, that the Fourier transform of a sequence of length n can be computed by recursively
finding the Fourier transforms of r1 different sequences, each of length r2. The method is a straightforward
generalization of the idea that we have already used in the case where n was a power of 2.
In the following we will write Î¾n = e2Ï€i/n. The train of â€˜=â€™ signs in the equation below shows how the
question on an input array of length n is changed into r1 questions about input arrays of length r2. We
have, for the value of the input polynomial f at the jth one of the n nth roots of unity, the relations
f(e2Ï€ij/n) =
nâˆ’1âˆ‘
s=0
xsÎ¾n
js
=
r1âˆ’1âˆ‘
k=0
r2âˆ’1âˆ‘
t=0
{xtr1+kÎ¾nj(tr1+k)}
=
r1âˆ’1âˆ‘
k=0
r2âˆ’1âˆ‘
t=0
{xtr1+kÎ¾ntjr1Î¾nkj}
=
r1âˆ’1âˆ‘
k=0
{r2âˆ’1âˆ‘
t=0
xtr1+kÎ¾r2
tj
}
Î¾n
kj
=
r1âˆ’1âˆ‘
k=0
ak(j)Î¾nkj.
(2.5.13)
We will discuss (2.5.13), line-by-line. The first â€˜=â€™ sign is the definition of the jth entry of the Fourier
transform of the input array x. The second equality uses the fact that every integer s such that 0 â‰¤ s â‰¤ nâˆ’1
can be uniquely written in the form s = tr1 + k, where 0 â‰¤ t â‰¤ r2 âˆ’ 1 and 0 â‰¤ k â‰¤ r1 âˆ’ 1. The next â€˜=â€™ is
just a rearrangement, but the next one uses the all-important fact that Î¾nr1 = Î¾r2 (why?), and in the last
equation we are simply defining a set of numbers
ak(j) =
r2âˆ’1âˆ‘
t=0
xtr1+kÎ¾r2
tj (0 â‰¤ k â‰¤ r1 âˆ’ 1; 0 â‰¤ j â‰¤ nâˆ’ 1). (2.5.14)
The important thing to notice is that for a fixed k the numbers ak(j) are periodic in n, of period r2, i.e.,
that ak(j+r2) = ak(j) for all j. Hence, even though the values of the ak(j) are needed for j = 0, 1, . . . , nâˆ’1,
they must be computed only for j = 0, 1, . . ., r2 âˆ’ 1.
Now the entire job can be done recursively, because for fixed k the set of values of ak(j) (j =
0, 1, . . . , r2 âˆ’ 1) that we must compute is itself a Fourier transform, namely of the sequence
{xtr1+k} (t = 0, 1, . . . , r2 âˆ’ 1). (2.5.15)
Let g(n) denote the number of complex multiplications that are needed to compute the Fourier transform
of a sequence of n numbers. Then, for k fixed we can recursively compute the r2 values of ak(j) that we need
with g(r2) multiplications of complex numbers. There are r1 such fixed values of k for which we must do the
54
2.5 The discrete Fourier transform
computation, hence all of the necessary values of ak(j) can be found with r1g(r2) complex multiplications.
Once the ak(j) are all in hand, then the computation of the one value of the transform from (2.5.13) will
require an additional r1 âˆ’ 1 complex multiplications. Since n = r1r2 values of the transform have to be
computed, we will need r1r2(r1 âˆ’ 1) complex multiplications.
The complete computation needs r1g(r2) + r21r2 âˆ’ r1r2 multiplications if we choose a particular factor-
ization n = r1r2. The factorization that should be chosen is the one that minimizes the labor, so we have
the recurrence
g(n) = min
n=r1r2
{r1g(r2) + r21r2} âˆ’ n. (2.5.16)
If n = p is a prime number then there are no factorizations to choose from and our algorithm is no help
at all. There is no recourse but to calculate the p values of the transform directly from the definition (2.5.6),
and that will require pâˆ’ 1 complex multiplications to be done in order to get each of those p values. Hence
we have, in addition to the recurrence formula (2.5.16), the special values
g(p) = p(pâˆ’ 1) (if p is prime). (2.5.17)
The recurrence formula (2.5.16) together with the starting values that are shown in (2.5.17) completely
determine the function g(n). Before proceeding, the reader is invited to calculate g(12) and g(18).
We are going to work out the exact solution of the interesting recurrence (2.5.16), (2.5.17), and when
we are finished we will see which factorization of n is the best one to choose. If we leave that question in
abeyance for a while, though, we can summarize by stating the (otherwise) complete algorithm for the fast
Fourier transform.
function FFT (x:complexarray; n:integer):complexarray;
{computes Fourier transform of a sequence x of length n}
if n is prime
then
for j:=0 to nâˆ’ 1 do
FFT [j] :=
âˆ‘nâˆ’1
k=0 x[k]Î¾n
jk
else
let n = r1r2 be some factorization of n;
{see below for best choice of r1, r2}
for k:=0 to r1 âˆ’ 1 do
{ak[0], ak[1], . . ., ak[r2 âˆ’ 1]}
:= FFT ({x[k], x[k+ r1], . . . , x[k+ (r2 âˆ’ 1)r1]}, r2);
for j:=0 to nâˆ’ 1 do
FFT [j] :=
âˆ‘r1âˆ’1
k=0 ak[j mod r2]Î¾
kj
n
end.{FFT}
Our next task will be to solve the recurrence relations (2.5.16), (2.5.17), and thereby to learn the best
choice of the factorization of n.
Let g(n) = nh(n), where h is a new unknown function. Then the recurrence that we have to solve takes
the form
h(n) =
{
mind{h(n/d) + d} âˆ’ 1, if n is composite;
nâˆ’ 1, if n is prime. (2.5.18)
In (2.5.18), the â€˜minâ€™ is taken over all d that divide n other than d = 1 and d = n.
The above relation determines the value of h for all positive integers n. For example,
h(15) = min
d
(h(15/d) + d)âˆ’ 1
= min(h(5) + 3, h(3) + 5) âˆ’ 1
= min(7, 7)âˆ’ 1 = 6
55
Chapter 2: Recursive Algorithms
and so forth.
To find the solution in a pleasant form, let
n = pa11 p
a2
2 Â· Â· Â·pass (2.5.19)
be the canonical factorization of n into primes. We claim that the function
h(n) = a1(p1 âˆ’ 1) + a2(p2 âˆ’ 1) + Â· Â· Â·+ as(ps âˆ’ 1) (2.5.20)
is the solution of (2.5.18) (this claim is obviously (?) correct if n is prime).
To prove the claim in general, suppose it to be true for 1, 2, . . . , nâˆ’ 1, and suppose that n is not prime.
Then every divisor d of n must be of the form d = pb11 p
b2
2 Â· Â· Â·pbss , where the primes pi are the same as those
that appear in (2.5.19) and each bi is â‰¤ ai. Hence from (2.5.18) we get
h(n) = min
b
{(a1 âˆ’ b1)(p1 âˆ’ 1) + Â· Â· Â·+ (as âˆ’ bs)(ps âˆ’ 1) + pb11 Â· Â· Â·pb
s
s } âˆ’ 1 (2.5.21)
where now the â€˜minâ€™ extends over all admissible choices of the bâ€™s, namely exponents b1, . . . , bs such that
0 â‰¤ bi â‰¤ ai (âˆ€i = 1, s) and not all bi are 0 and not all bi = ai.
One such admissible choice would be to take, say, bj = 1 and all other bi = 0. If we let H(b1, . . . , bs)
denote the quantity in braces in (2.5.21), then with this choice the value of H would be a1(p1 âˆ’ 1) + Â· Â· Â· +
as(ps âˆ’ 1) + 1, exactly what we need to prove our claim (2.5.20). Hence what we have to show is that the
above choice of the biâ€™s is the best one. We will show that if one of the bi is larger than 1 then we can reduce
it without increasing the value of H.
To prove this, observe that for each i = 1, s we have
H(b1, . . . , bi + 1, . . . , bs) âˆ’H(b1, . . . , bs) = âˆ’pi + d(pi âˆ’ 1)
= (dâˆ’ 1)(pi âˆ’ 1).
Since the divisor d â‰¥ 2 and the prime pi â‰¥ 2, the last difference is nonnegative. Hence H doesnâ€™t increase
if we decrease one of the bâ€™s by 1 unit, as long as not all bi = 0. It follows that the minimum of H occurs
among the prime divisors d of n. Further, if d is prime, then we can easily check from (2.5.21) that it doesnâ€™t
matter which prime divisor of n that we choose to be d, the function h(n) is always given by (2.5.20). If we
recall the change of variable g(n) = nh(n) we find that we have proved
Theorem 2.5.2. (Complexity of the Fast Fourier Transform) The best choice of the factorization n = r1r2
in algorithm FFT is to take r1 to be a prime divisor of n. If that is done, then algorithm FFT requires
g(n) = n(a1(p1 âˆ’ 1) + a2(p2 âˆ’ 1) + Â· Â· Â·+ as(ps âˆ’ 1))
complex multiplications in order to do its job, where n = pa11 Â· Â· Â·pass is the canonical factorization of the
integer n.
Table 2.5.1 shows the number g(n) of complex multiplications required by FFT as a function of n. The
saving over the straightforward algorithm that uses n(nâˆ’ 1) multiplications for each n is apparent.
If n is a power of 2, say n = 2q, then the formula of theorem 2.5.2 reduces to g(n) = n logn/ log 2, in
agreement with theorem 2.5.1. What does the formula say if n is a power of 3? if n is a product of distinct
primes?
2.6 Applications of the FFT
Finally, we will discuss some applications of the FFT. A family of such applications begins with the
observation that the FFT provides the fastest game in town for multiplying two polynomials together.
Consider a multiplication like
(1 + 2x+ 7x2 âˆ’ 2x3 âˆ’ x4) Â· (4 âˆ’ 5xâˆ’ x2 âˆ’ x3 + 11x4 + x5).
56
2.6 Applications of the FFT
n g(n) n g(n)
2 2 22 242
3 6 23 506
4 8 24 120
5 20 25 200
6 18 26 338
7 42 27 162
8 24 28 224
9 36 29 812
10 50 30 210
11 110 31 930
12 48 32 160
13 156 33 396
14 98 34 578
15 90 35 350
16 64 36 216
17 272 37 1332
18 90 38 722
19 342 39 546
20 120 40 280
21 168 41 1640
Table 2.5.1: The complexity of the FFT
We will study the amount of labor that is needed to do this multiplication by the straightforward algorithm,
and then we will see how the FFT can help.
If we do this multiplication in the obvious way then there is quite a bit of work to do. The coefficient of
x4 in the product, for instance, is 1 Â· 11 + 2 Â· (âˆ’1) + 7 Â· (âˆ’1) + (âˆ’2) Â· (âˆ’5) +(âˆ’1) Â·4 = 8, and 5 multiplications
are needed to compute just that single coefficient of the product polynomial.
In the general case, we want to multiply
{
nâˆ‘
i=0
aix
i} Â· {
mâˆ‘
j=0
bjx
j}. (2.6.1)
In the product polynomial, the coefficient of xk is
min(k,n)âˆ‘
r=max(0,kâˆ’m)
arbkâˆ’r. (2.6.2)
For k fixed, the number of terms in the sum (2.6.2) is min(k, n)âˆ’max(0, kâˆ’m) + 1. If we sum this amount
of labor over k = 0,m + n we find that the total amount of labor for multiplication of two polynomials of
degrees m and n is Î˜(mn). In particular, if the polynomials are of the same degree n then the labor is
Î˜(n2).
By using the FFT the amount of labor can be reduced from Î˜(n2) to Î˜(n logn).
To understand how this works, letâ€™s recall the definition of the Fourier transform of a sequence. It is
the sequence of values of the polynomial whose coefficients are the given numbers, at the nth roots of unity,
where n is the length of the input sequence.
Imagine two universes, one in which the residents are used to describing polynomials by means of their
coefficients, and another one in which the inhabitants are fond of describing polynomials by their values at
roots of unity. In the first universe the locals have to work fairly hard to multiply two polynomials because
they have to carry out the operations (2.6.2) in order to find each coefficient of the product.
57
Chapter 2: Recursive Algorithms
In the second universe, multiplying two polynomials is a breeze. If we have in front of us the values
f(Ï‰) of the polynomial f at the roots of unity, and the values g(Ï‰) of the polynomial g at the same roots
of unity, then what are the values (fg)(Ï‰) of the product polynomial fg at the roots of unity? To find each
one requires only a single multiplication of two complex numbers, because the value of fg at Ï‰ is simply
f(Ï‰)g(Ï‰).
Multiplying values is easier than finding the coefficients of the product.
Since we live in a universe where people like to think about polynomials as being given by their coefficient
arrays, we have to take a somewhat roundabout route in order to do an efficient multiplication.
Given: A polynomial f , of degree n, and a polynomial g of degree m; by their coefficient arrays. Wanted:
The coefficients of the product polynomial fg, of degree m + n.
Step 1: Let N âˆ’ 1 be the smallest integer that is a power of 2 and is greater than m + n+ 1.
Step 2. Think of f and g as polynomials each of whose degrees is N âˆ’ 1. This means that we should
adjoin N âˆ’ n more coefficients, all = 0, to the coefficient array of f and N âˆ’m more coefficients, all = 0, to
the coefficient array of g. Now both input coefficient arrays are of length N .
Step 3. Compute the FFT of the array of coefficients of f . Now we are looking at the values of f at the
N th roots of unity. Likewise compute the FFT of the array of coefficients of g to obtain the array of values
of g at the same N th roots of unity. The cost of this step is O(N logN ).
Step 4. For each of the N th roots of unity Ï‰ multiply the number f(Ï‰) by the number g(Ï‰). We now
have the numbers f(Ï‰)g(Ï‰), which are exactly the values of the unknown product polynomial fg at the N th
roots of unity. The cost of this step is N multiplications of numbers, one for each Ï‰.
Step 5. We now are looking at the values of fg at the N th roots, and we want to get back to the
coefficients of fg because that was what we were asked for. To go backwards, from values at roots of unity
to coefficients, calls for the inverse Fourier transform, which we will describe in a moment. Its cost is also
O(N logN ).
The answer to the original question has been obtained at a total cost of O(N logN ) = O((m +
n) log (m+ n)) arithmetic operations. Itâ€™s true that we did have to take a walk from our universe to the next
one and back again, but the round trip was a lot cheaper than the O((m+n)2) cost of a direct multiplication.
It remains to discuss the inverse Fourier transform. Perhaps the neatest way to do that is to juxtapose
the formulas for the Fourier transform and for the inverse tranform, so as to facilitate comparison of the two,
so here they are. If we are given a sequence {x0, x1, . . . , xnâˆ’1} then the Fourier transform of the sequence is
the sequence (see (2.5.6))
f(Ï‰j) =
nâˆ’1âˆ‘
k=0
xke
2Ï€ijk/n (j = 0, 1, . . . , nâˆ’ 1). (2.6.3)
Conversely, if we are given the numbers f(Ï‰j) (j = 0, . . . , nâˆ’1) then we can recover the coefficient sequence
x0, . . . , xnâˆ’1 by the inverse formulas
xk =
1
n
nâˆ’1âˆ‘
j=0
f(Ï‰j)eâˆ’2Ï€ijk/n (k = 0, 1, . . . , nâˆ’ 1). (2.6.4)
The differences between the inverse formulas and the original transform formulas are first the appearance of
â€˜1/nâ€™ in front of the summation and second the â€˜âˆ’â€™ sign in the exponential. We leave it as an exercise for
the reader to verify that these formulas really do invert each other.
We observe that if we are already in possession of a computer program that will find the FFT, then we
can use it to calculate the inverse Fourier transform as follows:
(i) Given a sequence {f(Ï‰)} of values of a polynomial at the nth roots of unity, form the complex
conjugate of each member of the sequence.
(ii) Input the conjugated sequence to your FFT program.
(iii) Form the complex conjugate of each entry of the output array, and divide by n. You now have the
inverse transform of the input sequence.
The cost is obviously equal to the cost of the FFT plus a linear number of conjugations and divisions
by n.
58
2.7 A review
An outgrowth of the rapidity with which we can now multiply polynomials is a rethinking of the methods
by which we do ultrahigh-precision arithmetic. How fast can we multiply two integers, each of which has
ten million bits? By using ideas that developed directly (though not at all trivially) from the ones that we
have been discussing, SchoÌˆnhage and Strassen found the fastest known method for doing such large-scale
multiplications of integers. The method relies heavily on the FFT, which may not be too surprising since
an integer n is given in terms of its bits b0, b1, . . . , bm by the relation
n =
âˆ‘
iâ‰¥0
bi2i. (2.6.5)
However the sum in (2.6.5) is seen at once to be the value of a certain polynomial at x = 2. Hence in asking
for the bits of the product of two such integers we are asking for something very similar to the coefficients
of the product of two polynomials, and indeed the fastest known algorithms for this problem depend upon
the Fast Fourier Transform.
Exercises for section 2.6
1. Let Ï‰ be an nth root of unity, and let k be a fixed integer. Evaluate
1 + Ï‰k + Ï‰2k + Â· Â· Â·+ Ï‰k(nâˆ’1).
2. Verify that the relations (2.6.3) and (2.6.4) indeed are inverses of each other.
3. Let f =
âˆ‘nâˆ’1
j=0 ajx
j. Show that
1
n
âˆ‘
Ï‰n=1
|f(Ï‰)|2 = |a0|2 + Â· Â· Â·+ |anâˆ’1|2
4. The values of a certain cubic polynomial at 1, i,âˆ’1,âˆ’i are 1, 2, 3, 4, respectively. Find its value at 2.
5. Write a program that will do the FFT in the case where the number of data points is a power of 2.
Organize your program so as to minimize additional array storage beyond the input and output arrays.
6. Prove that a polynomial of degree n is uniquely determined by its values at n+ 1 distinct points.
2.7 A review
Here is a quick review of the algorithms that we studied in this chapter.
Sorting is an easy computational problem. The most obvious way to sort n array elements takes time
Î˜(n2). We discussed a recursive algorithm that sorts in an average time of Î˜(n logn).
Finding a maximum independent set in a graph is a hard computational problem. The most obvious
way to find one might take time Î˜(2n) if the graph G has n vertices. We discussed a recursive method that
runs in time Î˜(1.39n). The best known methods run in time Î˜(2n/3).
Finding out if a graph is K-colorable is a hard computational problem. The most obvious way to do it
takes time Î˜(Kn), if G has n vertices. We discussed a recursive method that runs in time O(1.62n+E) if G
has n vertices and E edges. One recently developed method * runs in time O((1 + 3
âˆš
3)n). We will see in
section 5.7 that this problem can be done in an average time that is O(1) for fixed K.
Multiplying two matrices is an easy computational problem. The most obvious way to do it takes time
Î˜(n3) if the matrices are n Ã— n. We discussed a recursive method that runs in time O(n2.82). A recent
method ** runs in time O(nÎ³) for some Î³ < 2.5.
* E. Lawler, A note on the complexity of the chromatic number problem, Information Processing Letters
5 (1976), 66-7.
** D. Coppersmith and S. Winograd, On the asymptotic complexity of matrix multiplication, SIAM J.
Comp. 11 (1980), 472-492.
59
Chapter 2: Recursive Algorithms
Finding the discrete Fourier transform of an array of n elements is an easy computational problem. The
most obvious way to do it takes time Î˜(n2). We discussed a recursive method that runs in time O(n logn)
if n is a power of 2.
When we write a program recursively we are making life easier for ourselves and harder for the compiler
and the computer. A single call to a recursive program can cause it to execute a tree-full of calls to itself
before it is able to respond to our original request.
For example, if we call Quicksort to sort the array
{5, 8, 13, 9,15,29,44,71,67}
then the tree shown in Fig. 2.7.1 might be generated by the compiler.
Fig. 2.7.1: A tree of calls to Quicksort
Again, if we call maxset1 on the 5-cycle, the tree in Fig. 2.3.3 of calls may be created.
A single invocation of chrompoly, where the input graph is a 4-cycle, for instance, might generate the
tree of recursive calls that appears in Fig. 2.7.2.
Fig. 2.7.2: A tree of calls to chrompoly
60
2.7 A review
Fig. 2.7.3: The recursive call tree for FFT
Finally, if we call the â€˜power of 2â€™ version of the FFT algorithm on the sequence {1, i,âˆ’i, 1} then FFT
will proceed to manufacture the tree shown in Fig. 2.7.3.
It must be emphasized that the creation of the tree of recursions is done by the compiler without any
further effort on the part of the programmer. As long as weâ€™re here, how does a compiler go about making
such a tree?
It does it by using an auxiliary stack. It adopts the philosophy that if it is asked to do two things at
once, well after all, it canâ€™t do that, so it does one of those two things and drops the other request on top of
a stack of unfinished business. When it finishes executing the first request it goes to the top of the stack to
find out what to do next.
Example
Letâ€™s follow the compiler through its tribulations as it attempts to deal with our request for maximum
independent set size that appears in Fig. 2.3.3. We begin by asking for the maxset1 of the 5-cycle. Our
program immediately makes two recursive calls to maxset1, on each of the two graphs that appear on the
second level of the tree in Fig. 2.3.3. The stack is initially empty.
The compiler says to itself â€˜I canâ€™t do these both at onceâ€™, and it puts the right-hand graph (involving
vertices 3,4) on the stack, and proceeds to call itself on the left hand graph (vertices 2,3,4,5).
When it tries to do that one, of course, two more graphs are generated, of which the right-hand one
(4,5) is dropped onto the stack, on top of the graph that previously lived there, so now two graphs are on
the stack, awaiting processing, and the compiler is dealing with the graph (3,4,5).
This time the graph of just one vertex (5) is dropped onto the stack, which now holds three graphs, as
the compiler works on (4,5).
Next, that graph is broken up into (5), and an empty graph, which is dutifully dropped onto the stack,
so the compiler can work on (5).
Finally, something fruitful happens: the graph (5) has no edges, so the program maxset1 gives, in its
trivial case, very specific instructions as to how to deal with this graph. We now know that the graph that
consists of just the single vertex (5) has a maxset1 values of 1.
The compiler next reaches for the graph on top of the stack, finds that it is the empty graph, which has
no edges at all, and therefore its maxset size is 0.
It now knows the n1 = 1 and the n2 = 0 values that appear in the algorithm maxset1, and therefore it
can execute the instruction maxset1 := max(n1, 1 + n2), from which it finds that the value of maxset1 for
the graph (4,5) is 1, and it continues from there, to dig itself out of the stack of unfinished business.
In general, if it is trying to execute maxset1 on a graph that has edges, it will drop the graph G âˆ’
{vâˆ—} âˆ’ Nbhd(vâˆ—) on the stack and try to do the graph Gâˆ’ {vâˆ—}.
The reader should try to write out, as a formal algorithm, the procedure that we have been describing,
whereby the compiler deals with a recursive computation that branches into two sub-computations until a
trivial case is reached.
61
Chapter 2: Recursive Algorithms
Exercise for section 2.7
1. In Fig. 2.7.3, add to the picture the output that each of the recursive calls gives back to the box above it
that made the call.
Bibliography
A definitive account of all aspects of sorting is in
D. E. Knuth, The art of computer programming, Vol. 3: Sorting and searching, Addison Wesley, Reading
MA, 1973.
All three volumes of the above reference are highly recommended for the study of algorithms and discrete
mathematics.
A O(2n/3) algorithm for the maximum independent set problem can be found in
R. E. Tarjan and A. Trojanowski, Finding a maximum independent set, SIAM J.Computing 6 (1977), 537-
546.
Recent developments in fast matrix multiplication are traced in
Victor Pan, How to multiply matrices faster, Lecture notes in computer science No. 179, Springer-Verlag,
1984.
The realization that the Fourier transform calculation can be speeded up has been traced back to
C. Runge, Zeits. Math. Phys., 48 (1903) p. 443.
and also appears in
C. Runge and H. KoÌˆnig, Die Grundlehren der math. Wissensch., 11, Springer Verlag, Berlin 1924.
The introduction of the method in modern algorithmic terms is generally credited to
J. M. Cooley and J. W. Tukey, An algorithm for the machine calculation of complex Fourier series, Mathe-
matics of Computation, 19 (1965), 297-301.
A number of statistical applications of the method are in
J. M. Cooley, P. A. W. Lewis and P. D. Welch, The Fast Fourier Transform and its application to time series
analysis, in Statistical Methods for Digital Computers, Enslein, Ralston and Wilf eds., John Wiley & Sons,
New York, 1977, 377-423.
The use of the FFT for high precision integer arithmetic is due to
A SchoÌˆnhage and V. Strassen, Schnelle Multiplikation grosser Zahlen, Computing, 7 (1971), 281-292.
An excellent account of the above as well as of applications of the FFT to polynomial arithmetic is by
A. V. Aho, J. E. Hopcroft and J. D. Ullman, The design and analysis of computer algorithms, Addison
Wesley, Reading, MA, 1974 (chap. 7).
62
Chapter 3: The Network Flow Problem
3.1 Introduction
The network flow problem is an example of a beautiful theoretical subject that has many important
applications. It also has generated algorithmic questions that have been in a state of extremely rapid
development in the past 20 years. Altogether, the fastest algorithms that are now known for the problem
are much faster, and some are much simpler, than the ones that were in use a short time ago, but it is still
unclear how close to the â€˜ultimateâ€™ algorithm we are.
Definition. A network is an edge-capacitated directed graph, with two distinguished vertices called the
source and the sink.
To repeat that, this time a little more slowly, suppose first that we are given a directed graph (digraph)
G. That is, we are given a set of vertices, and a set of ordered pairs of these vertices, these pairs being
the edges of the digraph. It is perfectly OK to have both an edge from u to v and an edge from v to u, or
both, or neither, for all u 6= v. No edge (u, u) is permitted. If an edge e is directed from vertex v to vertex
w, then v is the initial vertex of e and w is the terminal vertex of e. We may then write v = Init(e) and
w = Term(e).
Next, in a network there is associated with each directed edge e of the digraph a positive real number
called its capacity, and denoted by cap(e).
Finally, two of the vertices of the digraph are distinguished. One, s, is the source, and the other, t, is
the sink of the network.
We will let X denote the resulting network. It consists of the digraph G, the given set of edge capacities,
the source, and the sink. A network is shown in Fig. 3.1.1.
Fig. 3.1.1: A network
Now roughly speaking, we can think of the edges of G as conduits for a fluid, the capacity of each edge
being the carrying-capacity of the edge for that fluid. Imagine that the fluid flows in the network from the
source to the sink, in such a way that the amount of fluid in each edge does not exceed the capacity of that
edge.
We want to know the maximum net quantity of fluid that could be flowing from source to sink.
That was a rough description of the problem; here it is more precisely.
Definition. A flow in a network X is a function f that assigns to each edge e of the network a real number
f(e), in such a way that
(1) For each edge e we have 0 â‰¤ f(e) â‰¤ cap(e) and
(2) For each vertex v other than the source and the sink, it is true that
âˆ‘
Init(e)=v
f(e) =
âˆ‘
Term(e)=v
f(e). (3.1.1)
63
Chapter 3: The Network Flow Problem
The condition (3.1.1) is a flow conservation condition. It states that the outflow from v (the left side
of (3.1.1)) is equal to the inflow to v (the right side) for all vertices v other than s and t. In the theory of
electrical networks such conservation conditions are known as Kirchhoffâ€™s laws. Flow cannot be manufactured
anywhere in the network except at s or t. At other vertices, only redistribution or rerouting takes place.
Since the source and the sink are exempt from the conservation conditions there may, and usually will,
be a nonzero net flow out of the source, and a nonzero net flow into the sink. Intuitively it must already be
clear that these two are equal, and we will prove it below, in section 3.4. If we let Q be the net outflow from
the source, then Q is also the net inflow to the sink.
The quantity Q is called the value of the flow.
In Fig. 3.1.2 there is shown a flow in the network of Fig. 3.1.1. The amounts of flow in each edge are
shown in the square boxes. The other number on each edge is its capacity. The letter inside the small circle
next to each vertex is the name of that vertex, for the purposes of the present discussion. The value of the
flow in Fig. 3.1.2 is Q = 32.
Fig. 3.1.2: A flow in a network
The network flow problem, the main subject of this chapter, is: given a network X, find the maximum
possible value of a flow in X, and find a flow of that value.
3.2 Algorithms for the network flow problem
The first algorithm for the network flow problem was given by Ford and Fulkerson. They used that
algorithm not only to solve instances of the problem, but also to prove theorems about network flow, a
particularly happy combination. In particular, they used their algorithm to prove the â€˜max-flow-min-cutâ€™
theorem, which we state below as theorem 3.4.1, and which occupies a central position in the theory.
The speed of their algorithm, it turns out, depends on the edge capacities in the network as well as on
the numbers V of vertices, and E of edges, of the network. Indeed, for certain (irrational) values of edge
capacities they found that their algorithm might not converge at all (see section 3.5).
In 1969 Edmonds and Karp gave the first algorithm for the problem whose speed is bounded by a
polynomial function of E and V only. In fact that algorithm runs in time O(E2V ). Since then there has
been a steady procession of improvements in the algorithms, culminating, at the time of this writing anyway,
with an O(EV logV ) algorithm. The chronology is shown in Table 3.2.1.
The maximum number of edges that a network of V vertices can have is Î˜(V 2). A family of networks
might be called dense if there is a K > 0 such that |E(X)| > K|V (X)|2 for all networks in the family.
The reader should check that for dense networks, all of the time complexities in Table 3.2.1, beginning with
Karzanovâ€™s algorithm, are in the neighborhood of O(V 3). On the other hand, for sparse networks (networks
with relatively few edges), the later algorithms in the table will give significantly better performances than
the earlier ones.
64
3.3 The algorithm of Ford and Fulkerson
Author(s) Y ear Complexity
Ford, Fulkerson 1956 âˆ’âˆ’ âˆ’ âˆ’âˆ’
Edmonds, Karp 1969 O(E2V )
Dinic 1970 O(EV 2)
Karzanov 1973 O(V 3)
Cherkassky 1976 O(
âˆš
EV 2)
Malhotra, et al . 1978 O(V 3)
Galil 1978 O(V 5/3E2/3)
Galil and Naamad 1979 O(EV log2 V )
Sleator and Tarjan 1980 O(EV logV )
Goldberg and Tarjan 1985 O(EV log (V 2/E))
Table 3.2.1: Progress in network flow algorithms
Exercise 3.2.1. Given K > 0. Consider the family of all possible networks X for which |E(X)| = K|V (X)|.
In this family, evaluate all of the complexity bounds in Table 3.2.1 and find the fastest algorithm for the
family.
Among the algorithms in Table 3.2.1 we will discuss just two in detail. The first will be the original
algorithm of Ford and Fulkerson, because of its importance and its simplicity, if not for its speed.
The second will be the 1978 algorithm of Malhotra, Pramodh-Kumar and Maheshwari (MPM), for
three reasons. It uses the idea, introduced by Dinic in 1970 and common to all later algorithms, of layered
networks, it is fast, and it is extremely simple and elegant in its conception, and so it represents a good
choice for those who may wish to program one of these algorithms for themselves.
3.3 The algorithm of Ford and Fulkerson
The basic idea of the Ford-Fulkerson algorithm for the network flow problem is this: start with some
flow function (initially this might consist of zero flow on every edge). Then look for a flow augmenting path
in the network. A flow augmenting path is a path from the source to the sink along which we can push some
additional flow.
In Fig. 3.3.1 below we show a flow augmenting path for the network of Fig. 3.2.1. The capacities of the
edges are shown on each edge, and the values of the flow function are shown in the boxes on the edges.
Fig. 3.3.1: A flow augmenting path
Fig. 3.3.2: The path above, after augmentation.
An edge can get elected to a flow augmenting path for two possible reasons. Either
65
Chapter 3: The Network Flow Problem
(a) the direction of the edge is coherent with the direction of the path from source to sink and the present
value of the flow function on the edge is below the capacity of that edge, or
(b) the direction of the edge is opposed to that of the path from source to sink and the present value of the
flow function on the edge is strictly positive.
Indeed, on all edges of a flow augmenting path that are coherently oriented with the path we can increase
the flow along the edge, and on all edges that are incoherently oriented with the path we can decrease the
flow on the edge, and in either case we will have increased the value of the flow (think about that one until
it makes sense).
It is, of course, necessary to maintain the conservation of flow, i.e., to respect Kirchhoffâ€™s laws. To do
this we will augment the flow on every edge of an augmenting path by the same amount. If the conservation
conditions were satisfied before the augmentation then they will still be satisfied after such an augmentation.
It may be helpful to remark that an edge is coherently or incoherently oriented only with respect to a
given path from source to sink. That is, the coherence, or lack of it, is not only a property of the directed
edge, but depends on how the edge sits inside a chosen path.
Thus, in Fig. 3.3.1 the first edge is directed towards the source, i.e., incoherently with the path. Hence
if we can decrease the flow in that edge we will have increased the value of the flow function, namely the net
flow out of the source. That particular edge can indeed have its flow decreased, by at most 8 units. The
next edge carries 10 units of flow towards the source. Therefore if we decrease the flow on that edge, by up
to 10 units, we will also have increased the value of the flow function. Finally, the edge into the sink carries
12 units of flow and is oriented towards the sink. Hence if we increase the flow in this edge, by at most 3
units since its capacity is 15, we will have increased the value of the flow in the network.
Since every edge in the path that is shown in Fig. 3.3.1 can have its flow altered in one way or the
other so as to increase the flow in the network, the path is indeed a flow augmenting path. The most that
we might accomplish with this path would be to push 3 more units of flow through it from source to sink.
We couldnâ€™t push more than 3 units through because one of the edges (the edge into the sink) will tolerate
an augmentation of only 3 flow units before reaching its capacity.
To augment the flow by 3 units we would diminish the flow by 3 units on each of the first two edges and
increase it by 3 units on the last edge. The resulting flow in this path is shown in Fig. 3.3.2. The flow in
the full network, after this augmentation, is shown in Fig. 3.3.3. Note carefully that if these augmentations
are made then flow conservation at each vertex of the network will still hold (check this!).
Fig. 3.3.3: The network, after augmentation of flow
After augmenting the flow by 3 units as we have just described, the resulting flow will be the one that
is shown in Fig. 3.3.3. The value of the flow in Fig. 3.1.2 was 32 units. After the augmentation, the flow
function in Fig. 3.3.3 has a value of 35 units.
We have just described the main idea of the Ford-Fulkerson algorithm. It first finds a flow augmenting
path. Then it augments the flow along that path as much as it can. Then it finds another flow augmenting
66
3.3 The algorithm of Ford and Fulkerson
path, etc. etc. The algorithm terminates when no flow augmenting paths exist. We will prove that when
that happens, the flow will be at the maximum possible value, i.e., we will have found the solution of the
network flow problem.
We will now describe the steps of the algorithm in more detail.
Definition. Let f be a flow function in a network X. We say that an edge e of X is usable from v to w if
either e is directed from v to w and the flow in e is less than the capacity of the edge, or e is directed from
w to v and the flow in e is > 0.
Now, given a network and a flow in that network, how do we find a flow augmenting path from the
source to the sink? This is done by a process of labelling and scanning the vertices of the network, beginning
with the source and proceeding out to the sink. Initially all vertices are in the conditions â€˜unlabeledâ€™ and
â€˜unscanned.â€™ As the algorithm proceeds, various vertices will become labeled, and if a vertex is labeled, it
may become scanned. To scan a vertex v means, roughly, that we stand at v and look around at all neighbors
w of v that havenâ€™t yet been labeled. If e is some edge that joins v with a neighbor w, and if the edge e
is usable from v to w as defined above, then we will label w, because any flow augmenting path that has
already reached from the source to v can be extended another step, to w.
The label that every vertex v gets is a triple (u,Â±, z), and here is what the three items mean.
The â€˜uâ€™ part of the label of v is the name of the vertex that was being scanned when v was labeled.
The â€˜Â±â€™ will be â€˜+â€™ if v was labeled because the edge (u, v) was usable from u to v (i.e., if the flow from
u to v was less than the capacity of (u, v)) and it will be â€˜âˆ’â€™ if v was labeled because the edge (v, u) was
usable from u to v (i.e., if the flow from v to u was > 0).
Finally, the â€˜zâ€™ component of the label represents the largest amount of flow that can be pushed from
the source to the present vertex v along any augmenting path that has so far been found. At each step the
algorithm will replace the current value of z by the amount of new flow that could be pushed through to z
along the edge that is now being examined, if that amount is smaller than z.
So much for the meanings of the various labels. As the algorithm proceeds, the labels that get attached
to the different vertices form a record of how much flow can be pushed through the network from the source
to the various vertices, and by exactly which routes.
To begin with, the algorithm labels the source with (âˆ’âˆž,+,âˆž). The source now has the label-status
labeled and the scan-status unscanned.
Next we will scan the source. Here is the procedure for scanning any vertex u.
procedure scan(u:vertex;X :network; f :flow );
for every â€˜unlabeledâ€™ vertex v that is connected
to u by an edge in either or both directions, do
if the flow in (u, v) is less than cap(u, v)
then
label v with (u,+,min{z(u), cap(u, v) âˆ’ flow(u, v)})
else if the flow in (v, u) is > 0
then
label v with (u,âˆ’,min{z(u), flow(v, u)}) and
change the label-status of v to â€˜labeledâ€™;
change the scan-status of u to â€˜scannedâ€™
end.{scan}
We can use the above procedure to describe the complete scanning and labelling of the vertices of the
network, as follows.
67
Chapter 3: The Network Flow Problem
procedure labelandscan(X :network; f :flow; whyhalt:reason);
give every vertex the scan-status â€˜unscannedâ€™
and the label-status â€˜unlabeledâ€™;
u := source;
label source with (âˆ’âˆž,+,âˆž);
label-status of source:= â€˜labeledâ€™;
while {there is a â€˜labeledâ€™ and â€˜unscannedâ€™ vertex v
and sink is â€˜unlabeledâ€™}
do scan(v,X, f);
if sink is unlabeled
then â€˜whyhaltâ€™:=â€˜flow is maximumâ€™
else â€˜whyhaltâ€™:= â€˜itâ€™s time to augmentâ€™
end.{labelandscan}
Obviously the labelling and scanning process will halt for one of two reasons: either the sink t acquires
a label, or the sink never gets labeled but no more labels can be given. In the first case we will see that a
flow augmenting path from source to sink has been found, and in the second case we will prove that the flow
is at its maximum possible value, so the network flow problem has been solved.
Suppose the sink does get a label, for instance the label (u,Â±, z). Then we claim that the value of the
flow in the network can be augmented by z units.
To prove this we will construct a flow augmenting path, using the labels on the vertices, and then we
will change the flow by z units on every edge of that path in such a way as to increase the value of the flow
function by z units. This is done as follows.
If the sign part of the label of t is â€˜+,â€™ then increase the flow function by z units on the edge (u, t), else
decrease the flow on edge (t, u) by z units.
Then move back one step away from the sink, to vertex u, and look at its label, which might be (w,Â±, z1).
If the sign is â€˜+â€™ then increase the flow on edge (w, u) by z units (not by z1 units!), while if the sign is â€˜âˆ’â€™
then decrease the flow on edge (u,w) by z units. Next replace u by w, etc., until the source s has been
reached.
A little more formally, the flow augmentation algorithm is the following.
procedure augmentflow(X :network; f :flow ; amount:real);
{assumes that labelandscan has just been done}
v:=sink;
amount:= the â€˜zâ€™ part of the label of sink;
repeat
(previous, sign, z) := label(v);
if sign=â€˜+â€™
then
increase f(previous, v) by amount
else
decrease f(v, previous) by amount;
v := previous
until v= source
end.{augmentflow}
The value of the flow in the network has now been increased by z units. The whole process of labelling
and scanning is now repeated, to search for another flow augmenting path. The algorithm halts only when
we are unable to label the sink. The complete Ford-Fulkerson algorithm is shown below.
68
3.4 The max-flow min-cut theorem
procedure fordfulkerson(X :network; f : flow; maxflowvalue:real);
{finds maximum flow in a given network X }
set f :=0 on every edge of X ;
maxflowvalue:=0;
repeat
labelandscan(X, f , whyhalt);
if whyhalt=â€˜itâ€™s time to augmentâ€™ then
augmentflow(X,f , amount);
maxflowvalue := maxflowvalue + amount
until whyhalt = â€˜flow is maximumâ€™
end.{fordfulkerson}
Letâ€™s look at what happens if we apply the labelling and scanning algorithm to the network and flow
shown in Fig. 3.1.2. First vertex s gets the label (âˆ’âˆž,+,âˆž). We then scan s. Vertex A gets the label
(s,âˆ’, 8), B cannot be labeled, and C gets labeled with (s,+, 10), which completes the scan of s.
Next we scan vertex A, during which D acquires the label (A,+, 8). Then C is scanned, which results
in E getting the label (C,âˆ’, 10). Finally, the scan of D results in the label (D,+, 3) for the sink t.
From the label of t we see that there is a flow augmenting path in the network along which we can push
3 more units of flow from s to t. We find the path as in procedure augmentflow above, following the labels
backwards from t to D, A and s. The path in question will be seen to be exactly the one shown in Fig.
3.3.1, and further augmentation proceeds as we have discussed above.
3.4 The max-flow min-cut theorem
Now we are going to look at the state of affairs that holds when the flow augmentation procedure
terminates because it has not been able to label the sink. We want to show that then the flow will have a
maximum possible value.
Let W âŠ‚ V (X), and suppose that W contains the source and W does not contain the sink. Let W
denote
all other vertices of X, i.e., W = V (X) âˆ’W .
Definition. By the cut (W,W ) we mean the set of all edges of X whose initial vertex is in W and whose
terminal vertex is in W .
For example, one cut in a network consists of all edges whose initial vertex is the source.
Now, every unit of flow that leaves the source and arrives at the sink must at some moment flow from
a vertex of W to a vertex of W , i.e., must flow along some edge of the cut (W,W ). If we define the capacity
of a cut to be the sum of the capacities of all edges in the cut, then it seems clear that the value of a flow
can never exceed the capacity of any cut, and therefore that the maximum value of a flow cannot exceed the
minimum capacity of any cut.
The main result of this section is the â€˜max-flow min-cutâ€™ theorem of Ford and Fulkerson, which we state
as
Theorem 3.4.1. The maximum possible value of any flow in a network is equal to the minimum capacity
of any cut in that network.
Proof: We will first do a little computation to show that the value of a flow can never exceed the capacity of
a cut. Second, we will show that when the Ford-Fulkerson algorithm terminates because it has been unable
to label the sink, then at that moment there is a cut in the network whose edges are saturated with flow,
i.e., such that the flow in each edge of the cut is equal to the capacity of that edge.
Let U and V be two (not necessarily disjoint) sets of vertices of the network X, and let f be a flow
function for X. By f(U, V ) we mean the sum of the values of the flow function along all edges whose initial
vertex lies in U and whose terminal vertex lies in V . Similarly, by cap(U, V ) we mean the sum of the
capacities of all of those edges. Finally, by the net flow out of U we mean f(U,U ) âˆ’ f(U,U ).
69
Chapter 3: The Network Flow Problem
Lemma 3.4.1. Let f be a flow of value Q in a network X, and let (W,W ) be a cut in X. Then
Q = f(W,W ) âˆ’ f(W,W ) â‰¤ cap(W,W ). (3.4.1)
Proof of lemma: The net flow out of s is Q. The net flow out of any other vertex w âˆˆ W is 0. Hence, if
V (X) denotes the vertex set of the network X, we obtain
Q =
âˆ‘
wâˆˆW
{f(w, V (X)) âˆ’ f(V (X), w)}
= f(W,V (X)) âˆ’ f(V (X),W )
= f(W,W âˆªW ) âˆ’ f(W âˆªW,W )
= f(W,W ) + f(W,W ) âˆ’ f(W,W ) âˆ’ f(W,W )
= f(W,W ) âˆ’ f(W,W ).
This proves the â€˜=â€™ part of (3.4.1), and the â€˜â‰¤â€™ part is obvious, completing the proof of lemma 3.4.1.
We now know that the maximum value of the flow in a network cannot exceed the minimum of the
capacities of the cuts in the network.
To complete the proof of the theorem we will show that a flow of maximum value, which surely exists,
must saturate the edges of some cut.
Hence, let f be a flow in X of maximum value, and call procedure labelandscan(X, f ,whyhalt). Let
W be the set of vertices of X that have been labeled when the algorithm terminates. Clearly s âˆˆ W .
Equally clearly, t /âˆˆ W , for suppose the contrary. Then we would have termination with â€˜whyhaltâ€™ = â€˜itâ€™s
time to augment,â€™ and if we were then to call procedure augmentflow we would find a flow of higher value,
contradicting the assumed maximality of f .
Since s âˆˆ W and t /âˆˆW , the set W defines a cut (W,W ).
We claim that every edge of the cut (W,W ) is saturated. Indeed, if (x, y) is in the cut, x âˆˆW , y /âˆˆW ,
then edge (x, y) is saturated, else y would have been labeled when we were scanning x and we would have
y âˆˆ W , a contradiction. Similarly, if (y, x) is an edge where y âˆˆ W and x âˆˆ W , then the flow f(y, x) = 0,
else again y would have been labeled when we were scanning x, another contradiction.
Therefore, every edge from W to W is carrying as much flow as its capacity permits, and every edge
from W to W is carrying no flow at all. Hence the sign of equality holds in (3.4.1), the value of the flow is
equal to the capacity of the cut (W,W ), and the proof of theorem 3.4.1 is finished.
3.5 The complexity of the Ford-Fulkerson algorithm
The algorithm of Ford and Fulkerson terminates if and when it arrives at a stage where the sink is not
labeled but no more vertices can be labeled. If at that time we let W be the set of vertices that have been
labeled, then we have seen that (W,W ) is a minimum cut of the network, and the present value of the flow
is the desired maximum for the network.
The question now is, how long does it take to arrive at that stage, and indeed, is it guaranteed that we
will ever get there? We are asking if the algorithm is finite, surely the most primitive complexity question
imaginable.
First consider the case where every edge of the given network X has integer capacity. Then during the
labelling and flow augmentation algorithms, various additions and subtractions are done, but there is no
way that any nonintegral flows can be produced.
It follows that the augmented flow is still integral. The value of the flow therefore increases by an integer
amount during each augmentation. On the other hand if, say, Câˆ— denotes the combined capacity of all edges
that are outbound from the source, then it is eminently clear that the value of the flow can never exceed Câˆ—.
Since the value of the flow increases by at least 1 unit per augmentation, we see that no more than Câˆ— flow
augmentations will be needed before a maximum flow is reached. This yields
70
3.5 Complexity of the Ford-Fulkerson algorithm
Theorem 3.5.1. In a network with integer capacities on all edges, the Ford-Fulkerson algorithm terminates
after a finite number of steps with a flow of maximum value.
This is good news and bad news. The good news is that the algorithm is finite. The bad news is that
the complexity estimate that we have proved depends not only on the numbers of edges and vertices in X,
but on the edge capacities. If the bound Câˆ— represents the true behavior of the algorithm, rather than some
weakness in our analysis of the algorithm, then even on very small networks it will be possible to assign edge
capacities so that the algorithm takes a very long time to run.
And it is possible to do that.
We will show below an example due to Ford and Fulkerson in which the situation is even worse than
the one envisaged above: not only will the algorithm take a very long time to run; it wonâ€™t converge at all!
Consider the network X that is shown in Fig. 3.5.1. It has 10 vertices s, t, x1, . . . , x4, y1, . . . , y4. There
are directed edges (xi, xj) âˆ€i 6= j, (xi, yj) âˆ€i, j, (yi, yj) âˆ€i 6= j, (yi, xj) âˆ€i, j, (s, xi) âˆ€i, and (yj , t) âˆ€j.
Fig. 3.5.1: How to give the algorithm a hard time
In this network, the four edges Ai = (xi, yi) (i = 1, 4) will be called the special edges.
Next we will give the capacities of the edges of X. Write r = (âˆ’1 +
âˆš
5)/2, and let
S = (3 +
âˆš
5)/2 =
âˆžâˆ‘
n=0
rn.
Then to every edge of X except the four special edges we assign the capacity S. The special edges
A1, A2, A3, A4 are given capacities 1, r, r2, r2, respectively (you can see that this is going to be interest-
ing).
Suppose, for our first augmentation step, we find the flow augmenting path s â†’ x1 â†’ y1 â†’ t, and that
we augment the flow by 1 unit along that path. The four special edges will then have residual capacities
(excesses of capacity over flow) of 0, r, r2, r2, respectively.
Inductively, suppose we have arrived at a stage of the algorithm where the four special edges, taken in
some rearrangement Aâ€²1, Aâ€²2, Aâ€²3, Aâ€²4, have residual capacities 0, rn, rn+1, rn+1. We will now show that the
algorithm might next do two flow augmentation steps the net result of which would be that the inductive
state of affairs would again hold, with n replaced by n+ 1.
Indeed, choose the flow augmenting path
s â†’ xâ€²2 â†’ yâ€²2 â†’ xâ€²3 â†’ yâ€²3 â†’ t.
71
Chapter 3: The Network Flow Problem
The only special edges that are on this path are Aâ€²2 and A
â€²
3. Augment the flow along this path by r
n+1 units
(the maximum possible amount).
Next, choose the flow augmenting path
s â†’ xâ€²2 â†’ yâ€²2 â†’ yâ€²1 â†’ xâ€²1 â†’ yâ€²3 â†’ xâ€²3 â†’ yâ€²4 â†’ t.
Notice that with respect to this path the special edges Aâ€²1 and Aâ€²3 are incoherently directed. Augment the
flow along this path by rn+2 units, once more the largest possible amount.
The reader may now verify that the residual capacities of the four special edges are rn+2, 0, rn+2, rn+1.
In the course of doing this verification it will be handy to use the fact that
rn+2 = rn âˆ’ rn+1 (âˆ€n â‰¥ 0).
These two augmentation steps together have increased the flow value by rn+1 + rn+2 = rn units. Hence
the flow in an edge will never exceed S units.
The algorithm converges to a flow of value S. Now comes the bad news: the maximum flow in this
network has the value 4S (find it!).
Hence, for this network
(a) the algorithm does not halt after finitely many steps even though the edge capacities are finite and
(b) the sequence of flow values converges to a number that is not the maximum flow in the network.
The irrational capacities on the edges may at first seem to make this example seem â€˜cooked up.â€™ But
the implication is that even with a network whose edge capacities are all integers, the algorithm might take
a very long time to run.
Motivated by the importance and beauty of the theory of network flows, and by the unsatisfactory time
complexity of the original algorithm, many researchers have attacked the question of finding an algorithm
whose success is guaranteed within a time bound that is independent of the edge capacities, and depends
only on the size of the network.
We turn now to the consideration of one of the main ideas on which further progress has depended, that
of layering a network with respect to a flow function. This idea has triggered a whole series of improved
algorithms. Following the discussion of layering we will give a description of one of the algorithms, the MPM
algorithm, that uses layered networks and guarantees fast operation.
3.6 Layered networks
Layering a network is a technique that has the effect of replacing a single max-flow problem by several
problems, each a good deal easier than the original. More precisely, in a network with V vertices we will find
that we can solve a max-flow problem by solving at most V slightly different problems, each on a layered
network. We will then discuss an O(V 2) method for solving each such problem on a layered network, and
the result will be an O(V 3) algorithm for the original network flow problem.
Now we will discuss how to layer a network with respect to a given flow function. The purpose of the
italics is to emphasize the fact that one does not just â€˜layer a network.â€™ Instead, there is given a network X
and a flow function f for that network, and together they induce a layered network Y = Y(X, f), as follows.
First let us say that an edge e of X is helpful from u to v if either e is directed from u to v and f(e) is
below capacity or e is directed from v to u and the flow f(e) is positive.
Next we will describe the layered network Y. Recall that in order to describe a network one must
describe the vertices of the network, the directed edges, give the capacities of those edges, and designate the
source and the sink. The network Y will be constructed one layer at a time from the vertices of X, using
the flow f as a guide. For each layer, we will say which vertices of X go into that layer, then we will say
which vertices of the previous layer are connected to each vertex of the new layer. All of these edges will be
directed from the earlier layer to the later one. Finally we will give the capacities of each of these new edges.
The 0th layer of Y consists only of the source s. The vertices that comprise layer 1 of Y will be every
vertex v of X such that in X there is a helpful edge from s to v. We then draw an edge in Y directed from
s to v for each such vertex v. We assign to that edge in Y a capacity cap(s, v) âˆ’ f(s, v) + f(v, s).
72
3.6 Layered networks
The set of all such v will be called layer 1 of Y. Next we construct layer 2 of Y. The vertex set of layer
2 consists of all vertices w that do not yet belong to any layer, and such that there is a helpful edge in X
from some vertex v of layer 1 to w.
Next we draw the edges from layer 1 to layer 2: for each vertex v in layer 1 we draw a single edge in Y
directed from v to every vertex w in layer 2 for which there is a helpful edge in X from v to w.
Note that the edge always goes from v to w regardless of the direction of the helpful edge in X. Note
also that in contrast to the Ford-Fulkerson algorithm, even after an edge has been drawn from v to w in Y,
additional edges may be drawn to the same w from other vertices vâ€², vâ€²â€² in layer 1.
Assign capacities to the edges from layer 1 to layer 2 in the same way as described above, that is, the
capacity in Y of the edge from v to w is cap(v, w)âˆ’ f(v, w) + f(w, v). This latter quantity is, of course, the
total residual (unused) flow-carrying capacity of the edges in both directions between v and w.
The layering continues until we reach a layer L such that there is a helpful edge from some vertex of
layer L to the sink t, or else until no additional layers can be created (to say that no more layers can be
created is to say that among the vertices that havenâ€™t yet been included in the layered network that we are
building, there arenâ€™t any that are adjacent to a vertex that is in the layered network, by a helpful edge).
In the former case, we then create a layer L+ 1 that consists solely of the sink t, we connect t by edges
directed from the appropriate vertices of layer L, assign capacities to those edges, and the layering process
is complete. Observe that not all vertices of X need appear in Y.
In the latter case, where no additional layers can be created but the sink hasnâ€™t been reached, the
present flow function f in f
Â¯
X is maximum, and the network flow problem in X has been solved.
Here is a formal statement of the procedure for layering a given network X with respect to a given flow
function f in X. Input are the network X and the present flow function f in that network. Output are the
layered network Y, and a logical variable maxflow that will be True, on output, if the flow is at a maximum
value, False otherwise.
procedure layer (X, f , Y, maxflow);
{forms the layered network Y with respect to the flow f in X }
{maxflow will be â€˜Trueâ€™ if the input flow f already has the
maximum possible value for the network, else it will be â€˜Falseâ€™}
L:= 0; layer(L) := {source}; maxflow := false;
repeat
layer(L + 1) := âˆ…;
for each vertex u in layer(L) do
for each vertex v such that {layer(v) = L+ 1 or v is
not in any layer} do
q := cap(u, v) âˆ’ f(u, v) + f(v, u);
if q > 0 then do
draw edge u â†’ v in Y;
assign capacity q to that edge;
assign vertex v to layer(L + 1);
L := L + 1
if layer(L) is empty then exit with maxflow := true;
until sink is in layer(L);
delete from layer(L) of Y all vertices other than sink,
and remove their incident edges from Y
end.{layer}
In Fig. 3.6.1 we show the typical appearance of a layered network. In contrast to a general network, in
a layered network every path from the source to some fixed vertex v has the same number of edges in it (the
number of the layer of v), and all edges on such a path are directed the same way, from the source towards
73
Chapter 3: The Network Flow Problem
Fig. 3.6.1: A general layered network
v. These properties of layered networks are very friendly indeed, and make them much easier to deal with
than general networks.
In Fig. 3.6.2 we show specifically the layered network that results from the network of Fig. 3.1.2 with
the flow shown therein.
Fig. 3.6.2: A layering of the network in Fig. 3.1.2
The next question is this: exactly what problem would we like to solve on the layered network Y, and
what is the relationship of that problem to the original network flow problem in the original network X?
The answer is that in the layered network Y we are looking for a blocking flow g. By a blocking flow we
mean a flow function g in Y such that every path from source to sink in Y has at least one saturated edge.
This immediately raises two questions: (a) what can we do if we find a blocking flow in Y? (b) how can
we find a blocking flow in Y? The remainder of this section will be devoted to answering (a). In the next
section we will give an elegant answer to (b).
Suppose that we have somehow found a blocking flow function, g, in Y. What we do with it is that we
use it to augment the flow function f in X, as follows.
procedure augment(f , X; g, Y);
{augment flow f in X by using a blocking flow g
in the corresponding layered network Y}
for every edge e : uâ†’ v of the layered network Y,
do
increase the flow f in the edge uâ†’ v of the
network X by the amount
min{g(e), cap(u â†’ v) âˆ’ f(u â†’ v)};
if not all of g(e) has been used
then decrease the flow in edge v â†’ u by
the unused portion of g(e)
end.{augment}
74
3.6 Layered networks
After augmenting the flow in the original network X, what then? We construct a new layered network,
from X and the newly augmented flow function f on X.
The various activities that are now being described may sound like some kind of thinly disguised repack-
aging of the Ford-Fulkerson algorithm, but they arenâ€™t just that, because here is what can be proved to
happen:
First, if we start with zero flow in X, make the layered network Y, find a blocking flow in Y, augment
the flow in X, make a new layered network Y, find a blocking flow, etc. etc., then after at most V phases
(â€˜phaseâ€™ = layer + block + augment) we will have found the maximum flow in X and the process will halt.
Second, each phase can be done very rapidly. The MPM algorithm, to be discussed in section 3.7, finds
a blocking flow in a layered network in time O(V 2).
By the height of a layered network Y we will mean the number of edges in any path from source to sink.
The network of Fig. 3.6.1 has height 3. Letâ€™s now show
Theorem 3.6.1. The heights of the layered networks that occur in the consecutive phases of the solution
of a network flow problem form a strictly increasing sequence of positive integers. Hence, for a network X
with V vertices, there can be at most V phases before a maximum flow is found.
Let Y(p) denote the layered network that is constructed at the pth phase of the computation and let
H(p) denote the height of Y(p). We will first prove
Lemma 3.6.1. If
v0 â†’ v1 â†’ v2 â†’ Â· Â· Â· â†’ vm (v0 = source)
is a path in Y(p + 1), and if every vertex vi (i = 1,m) of that path also appears in Y(p), then for every
a = 0,m it is true that if vertex va was in layer b of Y(p) then a â‰¥ b.
Proof of lemma: The result is clearly true for a = 0. Suppose it is true for v0, v1, . . . , va, and suppose
va+1 was in layer c of network Y(p). We will show that a+ 1 â‰¥ c. Indeed, if not then c > a+ 1. Since va,
by induction, was in a layer â‰¤ a, it follows that the edge
eâˆ— : va â†’ va+1
was not present in network Y(p) since its two endpoints were not in two consecutive layers. Hence the flow
in Y between va and va+1 could not have been affected by the augmentation procedure of p hase p. But edge
eâˆ— is in Y(p+1). Therefore it represented an edge of Y that was helpful from va to va+1 at the beginning of
phase p+ 1, was unaffected by phase p, but was not helpful at the beginning of phase p. This contradiction
establishes the lemma.
Now we will prove the theorem. Let
s â†’ v1 â†’ v2 â†’ Â· Â· Â· â†’ vH(p+1)âˆ’1 â†’ t
be a path from source to sink in Y(p + 1).
Consider first the case where every vertex of the path also lies in Y(p), and apply the lemma to
vm = t (m = H(p + 1)), a = m. We conclude at once that H(p + 1) â‰¥ H(p). Now we want to exclude the
â€˜=â€™ sign. If H(p+ 1) = H(p) then the entire path is in Y(p) and in Y(p + 1), and so all of the edges in Y
that the edges of the path represent were helpful both before and after the augmentation step of phase p,
contradicting the fact that the blocking flow that was used for the augmentation saturated some edge of the
chosen path. The theorem is now proved for the case where the path had all of its vertices in Y(p) also.
Now suppose that this was not the case. Let eâˆ— : va â†’ va+1 be the first edge of the path whose terminal
vertex va+1 was not in Y(p). Then the corresponding edge(s) of Y was unaffected by the augmentation in
phase p. It was helpful from va to va+1 at the beginning of phase p + 1 because eâˆ— âˆˆ Y(p + 1) and it was
unaffected by phase p, yet eâˆ— /âˆˆ Y(p). The only possibility is that vertex va+1 would have entered into Y(p)
in the layer H(p) that contains the sink, but that layer is special, and contains only t. Hence, if va was
in layer b of Y(p), then b+1 = H(p). By the lemma once more, a â‰¥ b, so a+1 â‰¥ b+1 = H(p), and therefore
H(p+ 1) > H(p), completing the proof of theorem 3.6.1.
75
Chapter 3: The Network Flow Problem
To summarize, if we want to find a maximum flow in a given network Y by the method of layered
networks, we carry out
procedure maxflow (X ,Y ,f);
set the flow function f to zero on all edges of Y;
repeat
(i) construct the layered network Y = Y(X, f)
if possible, else exit with flow at maximum
value;
(ii) find a blocking flow g in Y;
(iii) augment the flow f in Y with the blocking
flow g, by calling procedure augment above
until exit occurs in (i) above;
end.{maxflow}
According to theorem 3.6.1, the procedure will repeat steps (i), (ii), (iii) at most V times because the
height of the layered network increases each time around, and it certainly can never exceed V . The labor
involved in step (i) is certainly O(E), and so is the labor in step (iii). Hence if BFL denotes the labor involved
in some method for finding a blocking flow in a layered network, then the whole network flow problem can
be done in time O(V Â· (E + BFL)).
The idea of layering networks is due to Dinic. Since his work was done, all efforts have been directed at
the problem of reducing BFL as much as possible.
3.7 The MPM algorithm
Now we suppose that we are given a layered network Y and we want to find a blocking flow in Y. The
following ingenious suggestion is due to Malhotra, Pramodh-Kumar and Maheshwari.
Let V be some vertex of Y. The in-potential of v is the sum of the capacities of all edges directed into
v, and the outpotential of v is the total capacity of all edges directed out from v. The potential of v is the
smaller of these two.
(A) Find a vertex v of smallest potential, say P âˆ—. Now we will push P âˆ— more units of flow from source
to sink, as follows.
(B) (Pushout) Take the edges that are outbound from v in some order, and saturate each one with flow,
unless and until saturating one more would lift the total flow used over P âˆ—. Then assign all remaining flow
to the next outbound edge (not necessarily saturating it), so the total outflow from v becomes exactly P âˆ—.
(C) Follow the flow to the next higher layer of Y. That is, for each vertex vâ€² of the next layer, let h(vâ€²)
be the flow into vâ€². Now saturate all except possibly one outbound edge of vâ€², to pass through vâ€² the h(vâ€²)
units of flow. When all vertices vâ€² in that layer have been done, repeat for the next layer, etc. We never find
a vertex with insufficient capacity, in or out, to handle the flow that is thrust upon it, because we began by
choosing a vertex of minimum potential.
(D) (Pullback) When all layers â€˜aboveâ€™ v have been done, then follow the flow to the next layer â€˜belowâ€™
v. For each vertex vâ€² of that layer, let h(vâ€²) be the flow out of vâ€² to v. Then saturate all except possibly one
incoming edge of vâ€², to pass through vâ€² the h(vâ€²) units of flow. When all vâ€² in that layer have been done,
proceed to the next layer below v, etc.
(E) (Update capacities) The flow function that has just been created in the layered network must be
stored somewhere. A convenient way to keep it is to carry out the augmentation procedure back in the
network X at this time, thereby, in effect â€˜storingâ€™ the contributions to the blocking flow in Y in the flow
array for X. This can be done concurrently with the MPM algorithm as follows: Every time we increase the
flow in some edge u â†’ v of Y we do it by augmenting the flow from u to v in X, and then decreasing the
capacity of edge u â†’ v in Y by the same amount. In that way the capacities of the edges in Y will always
be the updated residual capacities, and the flow function f in X will always reflect the latest augmentation
of the flow in Y.
(F) (Prune) We have now pushed the original h(v) units of flow through the whole layered network. We
intend to repeat the operation on some other vertex v of minimum potential, but first we can prune off of
the network some vertices and edges that are guaranteed never to be needed again.
76
3.6 Layered networks
The vertex v itself has either all incoming edges or all outgoing edges, or both, at zero residual capacities.
Hence no more flow will ever be pushed throug v. Therefore we can delete v from the network Y together
with all of its incident edges, incoming or outgoing. Further, we can delete from Y all of the edges that were
saturated by the flow pushing process just completed, i.e., all edges that now have zero residual capacity.
Next, we may now find that some vertex w has had all of its incoming or all of its outgoing edges deleted.
That vertex will never be used again, so delete it and any other incident edges it may still have. Continue
the pruning process until only vertices remain that have nonzero potential. If the source and the sink are
still connected by some path, then repeat from (A) above.
Else the algorithm halts. The blocking flow function g that we have just found is the following: if e is
an edge of the input layered network Y, then g(e) is the sum of all of the flows that were pushed through
edge e at all stages of the above algorithm.
It is obviously a blocking flow: since no path between s and t remains, every path must have had at
least one of its edges saturated at some step of the algorithm. What is the complexity of this algorithm?
Certainly we delete at least one vertex from the network at every pruning stage, because the vertex v that
had minimum potential will surely have had either all of its incoming or all of its outgoing edges (or both)
saturated.
It follows that steps (A)â€“(E) can be executed at most V times before we halt with a blocking flow.
The cost of saturating all edges that get saturated , since every edge has but one saturation to give to its
network, is O(E). The number of partial edge-saturation operations is at most two per vertex visited. For
each minimal-potential vertex v we visit at most V other vertices, so we use at most V minimal-potential
vertices altogether. So the partial edge saturation operations cost O(V 2) and the total edge saturations cost
O(E).
The operation of finding a vertex of minium potential is â€˜free,â€™ in the following sense. Initially we
compute and store the in- and out- potentials of every vertex. Thereafter, each time the flow in some edge
is increased, the outpotential of its initial vertex and the inpotential of its terminal vertex are reduced by
the same amount. It follows that the cost of maintaining these arrays is linear in the number of vertices, V .
Hence it affects only the constants implied by the â€˜big ohâ€™ symbols above, but not the orders of magnitude.
The total cost is therefore O(V 2) for the complete MPM algorithm that finds a blocking flow in a layered
network. Hence a maximum flow in a netwrok can be found in O(V 3) time, since at most V layered networks
need to be looked at in order to find a maximum flow in the original network.
In contrast to the nasty example network of section 3.5, with its irrational edge capacities, that made
the Ford-Fulkerson algorithm into an infinite process that converged to the wrong answer, the time bound
O(V 3) that we have just proved for the layered-network MPM algorithm is totally independent of the edge
capacities.
3.8 Applications of network flow
We conclude this chapter by mentioning some applications of the network flow problem and algorithm.
Certainly, among these, one most often mentions first the problem of maximum matching in a bipartite
graph. Consider a set of P people and a set of J jobs, such that not all of the people are capable of doing
all of the jobs.
We construct a graph of P + J vertices to represent this situation, as follows. Take P vertices to
represent the people, J vertices to represent the jobs, and connect vertex p to vertex j by an undirected edge
if person p can do job j. Such a graph is called bipartite. In general a graph G is bipartite if its vertices can
be partitioned into two classes in such a way that no edge runs between two vertices of the same class (see
section 1.6).
In Fig. 3.8.1 below we show a graph that might result from a certain group of 8 people and 9 jobs.
The maximum matching problem is just this: assuming that each person can handle at most one of
the jobs, and that each job needs only one person, assign people to the jobs in such a way that the largest
possible number of people are employed. In terms of the bipartite graph G, we want to find a maximum
number of edges, no two incident with the same vertex.
To solve this problem by the method of network flows we construct a network Y. First we adjoin two
new vertices s, t to the bipartite graph G. If we let P, J denote the two classes of vertices in the graph G,
then we draw an edge from s to each p âˆˆ P and an edge from each j âˆˆ J to t. Each edge in the network is
77
Chapter 3: The Network Flow Problem
Fig. 3.8.1: Matching people to jobs
Fig. 3.8.2: The network for the matching problem
given capacity 1. The result for the graph of Fig. 3.8.1 is shown in Fig. 3.8.2.
Consider a maximum integer-valued flow in this network, of value Q. Since each edge has capacity 1, Q
edges of the type (s, p) each contain a unit of flow. Out of each vertex p that receives some of this flow there
will come one unit of flow (since inflow equals outflow at such vertices), which will then cross to a vertex j of
J . No such j will receive more than one unit because at most one unit can leave it for the sink t. Hence the
flow defines a matching of Q edges of the graph G. Conversely, any matching in G defines a flow, hence a
maximum flow corresponds to a maximum matching. In Fig. 3.8.3 we show a maximum flow in the network
of Fig. 3.8.2 and therefore a maximum matching in the graph of Fig. 3.8.1.
Fig. 3.8.3: A maximum flow
For a second application of network flow methods, consdier an undirected graphG. The edge-connectivity
of G is defined as the smallest number of edges whose removal would disconnect G. Certainly, for instance,
78
3.6 Layered networks
if we remove all of the edges incident to a single vertex v, we will disconnect the graph. Hence the edge
connectivity cannot exceed the minimum degree of vertices in the graph. However the edge connectivity
could be a lot smaller than the minimum degree as the graph of Fig. 3.8.4 shows, in which the minimum is
large, but the removal of just one edge will disconnect the graph.
Fig. 3.8.4: Big degree, low connectivity
Finding the edge connectivity is quite an important combinatorial problem, and it is by no means
obvious that network flow methods can be used on it, but they can, and here is how.
Given G, a graph of V vertices. We solve not just one, but V âˆ’ 1 network flow problems, one for each
vertex j = 2, . . . , V .
Fix such a vertex j. Then consider vertex 1 of G to be the source and vertex j to be the sink of a
network Xj. Replace each edge of G by two edges of Xj , one in each direction, each with capacity 1. Now
solve the network flow problem in Xj obtaining a maximum flow Q(j). Then the smallest of the numbers
Q(j), for j = 2, . . . , V is the edge connectivity of G. We will not prove this here.âˆ—
As a final application of network flow we discuss the beautiful question of determining whether or not
there is a matrix of 0â€™s and 1â€™s that has given row and column sums. For instance, is there a 6 Ã— 8 matrix
whose row sums are respectively (5, 5, 4, 3, 5, 6) and whose column sums are (3, 4, 4, 4, 3, 3, 4, 3)? Of
course the phrase â€˜row sumsâ€™ means the same thing as â€˜number of 1â€™s in each rowâ€™ since we have said that
the entries are only 0 or 1.
Hence in general, let there be given a row sum vector (r1, . . . , rm) and a column sum vector (s1, . . . , sn).
Wed ask if there exists an m Ã— n matrix A of 0â€™s and 1â€™s that has exactly ri 1â€™s in the ith row and exactly
sj 1â€™s in the jth column, for each i = 1, . . . ,m, j = 1, . . . , n. The reader will no doubt have noticed that for
such a matrix to exist it must surely be true that
r1 + Â· Â· Â·+ rm = s1 + Â· Â· Â·+ sn (3.8.1)
since each side counts the total number of 1â€™s in the matrix. Hence we will suppose that (3.8.1) is true.
Now we will construct a network Y of m+ n+ 2 vertices named s, x1, . . . , xm, y1, . . . , yn, and t. There
is an edge of capacity ri drawn from the source s to vertex xi, for each i = 1, . . . ,m, and an edge of capacity
sj drawn from vertex yj to the sink t, for each j = 1, . . . , n. Finally, there are mn edges of capacity 1 drawn
from each edge xi to each vertex yj .
Next find a maximum flow in this netwrok. Then there is a 0-1 matrix with the given row and column
sum vectors if and only if a maximum flow saturates every edge outbound from the source, that is, if and
only if a maximum flow has value equal to the right or left side of equation (3.8.1). If such a flow exists then
a matrix A of the desired kind is constructed by putting ai,j equal to the flow in the edge from xi to yj .
âˆ— S. Even and R. E. Tarjan, Network flow and testing graph connectivity, SIAM J. Computing 4 (1975),
507-518.
79
Chapter 3: The Network Flow Problem
Exercises for section 3.8
1. Apply the max-flow min-cut theorem to the network that is constructed in order to solve the bipartite
matching problem. Precisely what does a cut correspond to in this network? What does the theorem tell
you about the matching problem?
2. Same as question 1 above, but applied to the question of discovering whether or not there is a 0-1 matrix
with a certain given set of row and column sums.
Bibliography
The standard reference for the network flow problem and its variants is
L. R. Ford and D. R. Fulkerson, Flows in Networks, Princeton University Press, Princeton, NJ, 1974.
The algorithm, the example of irrational capacities and lack of convergence to maximum flow, and many
applications are discussed there. The chronology of accelerated algorithms is based on the following papers.
The first algorithms with a time bound independent of the edge capacities are in
J. Edmonds and R. M. Karp, Theoretical improvements in algorithmic efficiency for network flow prob-
lems, JACM 19, 2 (1972), 248-264.
E. A. Dinic, Algorithm for solution of a problem of maximal flow in a network with power estimation,
Soviet Math. Dokl., 11 (1970), 1277-1280.
The paper of Dinic, above, also originated the idea of a layered network. Further accelerations of the
netowrk flow algorithms are found in the following.
A. V. Karzanov, Determining the maximal flow in a network by the method of preflows, Soviet Math.
Dokl. 15 (1974), 434-437.
B. V. Cherkassky, Algorithm of construction of maximal flow in networks with complexity of O(V 2E)
operations, Akad. Nauk. USSR, Mathematical methods for the solution of economical problems 7 (1977),
117-126.
The MPM algorithm, discussed in the tex, is due to
V. M. Malhotra, M. Pramodh-Kumar and S. N. Maheshwari, An O(V 3) algorithm for finding maximum
flows in networks, Information processing Letters 7, (1978), 277-278.
Later algorithms depend on refined data structures that save fragments of partially construted aug-
menting paths. These developments were initiated in
Z. Galil, A new algorithm for the maximal flow problem, Proc. 19th IEEE Symposium on the Founda-
tions of Computer Science, Ann Arbor, October 1978, 231-245.
Andrew V. Goldberg and Robert E. Tarjan, A new approach to the maximum flow problem, 1985.
A number of examples that show that the theoretical complexity estimates for the various algorithms
cannot be improved are contained in
Z. Galil, On the theoretical efficiency of various network flow algorithms, IBM report RC7320, September
1978.
The proof given in the text, of theorem 3.6.1, leans heavily on the one in
Shimon Even, Graph Algorithms, Computer Science Press, Potomac, MD, 1979.
If edge capacities are all 0â€™s and 1â€™s, as in matching problems, then still faster algorithms can be given,
as in
S. Even and R. E. Tarjan, Network flow and testing graph connectivity, SIAM J. Computing 4, (1975),
507-518.
If every pair of vertices is to act, in turn, as source and sink, then considerable economies can be realized,
as in
R. E. Gomory and T. C. Hu, Multiterminal netwrok flows, SIAM Journal, 9 (1961), 551-570.
Matching in general graphs is much harder than in bipartite graphs. The pioneering work is due to
J. Edmonds, Path, trees, and flowers, Canadian J. Math. 17 (1965), 449-467.
80
4.1 Preliminaries
Chapter 4: Algorithms in the Theory of Numbers
Number theory is the study of the properties of the positive integers. It is one of the oldest branches of
mathematics, and one of the purest, so to speak. It has immense vitality, however, and we will see in this
chapter and the next that parts of number theory are extremely relevant to current research in algorithms.
Part of the reason for this is that number theory enters into the analysis of algorithms, but that isnâ€™t
the whole story.
Part of the reason is that many famous problems of number theory, when viewed from an algorithmic
viewpoint (like, how do you decide whether or not a positive integer n is prime?) present extremely deep
and attractive unsolved algorithmic problems. At least, they are unsolved if we regard the question as not
just how to do these problems computationally, but how to do them as rapidly as possible.
But thatâ€™s not the whole story either.
There are close connections between algorithmic problems in the theory of numbers, and problems
in other fields, seemingly far removed from number theory. There is a unity between these seemingly
diverse problems that enhances the already considerable beauty of any one of them. At least some of these
connections will be apparent by the end of study of Chapter 5.
4.1 Preliminaries
We collect in this section a number of facts about the theory of numbers, for later reference.
If n and m are positive integers then to divide n by m is to find an integer q â‰¥ 0 (the quotient) and an
integer r ( the remainder) such that 0 â‰¤ r < m and n = qm + r.
If r = 0, we say that â€˜m divides n,â€™ or â€˜m is a divisor of n,â€™ and we write m|n. In any case the remainder
r is also called â€˜n modulo m,â€™ and we write r = n mod m. Thus 4 = 11 mod 7, for instance.
If n has no divisors other than m = n and m = 1, then n is prime, else n is composite. Every positive
integer n can be factored into primes, uniquely apart from the order of the factors. Thus 120 = 23 Â· 3 Â· 5, and
in general we will write
n = pa11 p
a2
2 Â· Â· Â·p
al
l =
lâˆ
i=1
paii . (4.1.1)
We will refer to (4.1.1) as the canonical factorization of n.
Many interesting and important properties of an integer n can be calculated from its canonical factor-
ization. For instance, let d(n) be the number of divisors of the integer n. The divisors of 6 are 1, 2, 3, 6, so
d(6) = 4.
Can we find a formula for d(n)? A small example may help to clarify the method. Since 120 = 23 Â· 3 Â· 5,
a divisor of 120 must be of the form m = 2a3b5c, in which a can have the values 0,1,2,3, b can be 0 or 1, and
c can be 0 or 1. Thus there are 4 choices for a, 2 for b and 2 for c, so there are 16 divisors of 120.
In general, the integer n in (4.1.1) has exactly
d(n) = (1 + a1)(1 + a2) Â· Â· Â· (1 + al) (4.1.2)
divisors.
If m and n are nonnegative integers then their greatest common divisor, written gcd(n,m), is the integer
g that
(a) divides both m and n and
(b) is divisible by every other common divisor of m and n.
Thus gcd(12, 8) = 4, gcd(42, 33) = 3, etc. If gcd(n,m) = 1 then we say that n and m are relatively
prime. Thus 27 and 125 are relatively prime (even though neither of them is prime).
If n > 0 is given, then Ï†(n) will denote the number of positive integers m such that m â‰¤ n and
gcd(n,m) = 1. Thus Ï†(6) = 2, because there are only two positive integers â‰¤ 6 that are relatively prime to
6 (namely 1 and 5). Ï†(n) is called the Euler Ï†-function, or the Euler totient function.
Letâ€™s find a formula that expresses Ï†(n) in terms of the canonical factorization (4.1.1) of n.
81
Chapter 4: Algorithms in the Theory of Numbers
We want to count the positive integers m for which m â‰¤ n, and m is not divisible by any of the primes
pi that appear in (4.1.1). There are n possibilities for such an integer m. Of these we throw away n/p1 of
them because they are divisible by p1. Then we discard n/p2 multiples of p2, etc. This leaves us with
nâˆ’ n/p1 âˆ’ n/p2 âˆ’ Â· Â· Â· âˆ’ n/pl (4.1.3)
possible mâ€™s.
But we have thrown away too much. An integer m that is a multiple of both p1 and p2 has been
discarded at least twice. So letâ€™s correct these errors by adding
n/(p1p2) + n/(p1p3) + Â· Â· Â·+ n/(p1pl) + Â· Â· Â·+ n/(plâˆ’1pl)
to (4.1.3).
The reader will have noticed that we added back too much, because an integer that is divisible by
p1p2p3, for instance, would have been re-entered at least twice. The â€˜bottom lineâ€™ of counting too much,
then too little, then too much, etc. is the messy formula
Ï†(n) =nâˆ’ n/p1 âˆ’ n/p2 âˆ’ Â· Â· Â· âˆ’ n/pl + n/(p1p2) + Â· Â· Â·+ n/(plâˆ’1pl)
âˆ’ n/(p1p2p3) âˆ’ Â· Â· Â· âˆ’ n/(plâˆ’2plâˆ’1pl)
+ Â· Â· Â·+ (âˆ’1)ln/(p1p2 Â· Â· Â·pl).
(4.1.4)
Fortunately (4.1.4) is identical with the much simpler expression
Ï†(n) = n(1 âˆ’ 1/p1)(1 âˆ’ 1/p2) Â· Â· Â· (1 âˆ’ 1/pl) (4.1.5)
which the reader can check by beginning with (4.1.5) and expanding the product.
To calculate Ï†(120), for example, we first find the canonical factorization 120 = 23 Â·3 Â·5. Then we apply
(4.1.5) to get
Ï†(120) = 120(1 âˆ’ 1/2)(1 âˆ’ 1/3)(1 âˆ’ 1/5)
= 32.
Thus, among the integers 1, 2, . . ., 120, there are exactly 32 that are relatively prime to 120.
Exercises for section 4.1
1. Find a formula for the sum of the divisors of an integer n, expressed in terms of its prime divisors and
their multiplicities.
2. How many positive integers are â‰¤ 1010 and have an odd number of divisors? Find a simple formula for
the number of such integers that are â‰¤ n.
3. If Ï†(n) = 2 then what do you know about n?
4. For which n is Ï†(n) odd?
4.2 The greatest common divisor
Let m and n be two positive integers. Suppose we divide n by m, to obtain a quotient q and a remainder
r, with, of course, 0 â‰¤ r < m. Then we have
n = qm + r. (4.2.1)
If g is some integer that divides both n and m then obviously g divides r also. Thus every common divisor
of n and m is a common divisor of m and r. Conversely, if g is a common divisor of m and r then (4.2.1)
shows that g divides n too.
It follows that gcd(n,m) = gcd(m, r). If r = 0 then n = qm, and clearly, gcd(n,m) = m.
82
4.2 The greatest common divisor
If we use the customary abbreviation â€˜n mod mâ€™ for r, the remainder in the division of n by m, then
what we have shown is that
gcd(n,m) = gcd(m,n mod m).
This leads to the following recursive procedure for computing the g.c.d.
function gcd(n,m);
{finds gcd of given nonnegative integers n and m}
if m = 0 then gcd := n else gcd := gcd(m,n mod m)
end.
The above is the famous â€˜Euclidean algorithmâ€™ for the g.c.d. It is one of the oldest algorithms known.
The reader is invited to write the Euclidean algorithm as a recursive program, and get it working on
some computer. Use a recursive language, write the program more or less as above, and try it out with some
large, healthy integers n and m.
The gcd program exhibits all of the symptoms of recursion. It calls itself with smaller values of its
variable list. It begins with â€˜if trivialcase then do trivialthingâ€™ (m = 0), and this case is all-important
because itâ€™s the only way the procedure can stop itself.
If, for example, we want the g.c.d. of 13 and 21, we call the program with n = 13 and m = 21, and it
then recursively calls itself with the following arguments:
(21, 13), (13, 8), (8, 5), (5, 3), (3, 2), (2, 1), (1, 0) (4.2.2)
When it arrives at a call in which the â€˜mâ€™ is 0, then the â€˜n,â€™ namely 1 in this case, is the desired g.c.d.
What is the input to the problem? The two integers n, m whose g.c.d. we want are the input, and the
number of bits that are needed to input those two integers is Î˜(logn)+Î˜(logm), namely Î˜(logmn). Hence
c logmn is the length of the input bit string. Now letâ€™s see how long the algorithm might run with an input
string of that length.âˆ—
To measure the running time of the algorithm we need first to choose a unit of cost or work. Letâ€™s
agree that one unit of labor is the execution of a single â€˜a mod bâ€™ operation. In this problem, an equivalent
measure of cost would be the number of times the algorithm calls itself recursively. In the example (4.2.2)
the cost was 7 units.
Lemma 4.2.1. If 1 â‰¤ b â‰¤ a then a mod b â‰¤ (a âˆ’ 1)/2.
Proof: Clearly a mod b â‰¤ bâˆ’ 1. Further,
a mod b = aâˆ’
âŒŠa
b
âŒ‹
b
â‰¤ aâˆ’ b.
Thus a mod b â‰¤ min(aâˆ’ b, bâˆ’ 1). Now we distinguish two cases.
First suppose b â‰¤ (a+ 1)/2. Then bâˆ’ 1 â‰¤ aâˆ’ b and so
a mod b â‰¤ bâˆ’ 1
â‰¤ a + 1
2
âˆ’ 1
=
a âˆ’ 1
2
in this case.
Next, suppose b > (a + 1)/2. Then aâˆ’ b â‰¤ bâˆ’ 1 and
a mod b â‰¤ aâˆ’ b < a âˆ’ a+ 1
2
=
aâˆ’ 1
2
so the result holds in either case.
âˆ— In Historia Mathematica 21 (1994), 401-419, Jeffrey Shallit traces this analysis back to Pierre-Joseph-
EÌtienne Finck, in 1841.
83
Chapter 4: Algorithms in the Theory of Numbers
Theorem 4.2.1. (A worst-case complexity bound for the Euclidean algorithm) Given two positive integers
a, b. The Euclidean algorithm will find their greatest common divisor after a cost of at most b2 log2Mc + 1
integer divisions, where M = max(a, b).
Before we prove the theorem, letâ€™s return to the example (a, b) = (13, 21) of the display (4.2.2). In that
case M = 21 and 2 log2M + 1 = 9.78 . . .. The theorem asserts that the g.c.d. will be found after at most 9
operations. In fact it was found after 7 operations in that case.
Proof of theorem: Suppose first that a â‰¥ b. The algorithm generates a sequence a0, a1, . . . where a0 =
a, a1 = b, and
aj+1 = ajâˆ’1 mod aj (j â‰¥ 1).
By lemma 4.2.1,
aj+1 â‰¤
ajâˆ’1 âˆ’ 1
2
â‰¤ ajâˆ’1
2
.
Then, by induction on j it follows that
a2j â‰¤
a0
2j
(j â‰¥ 0)
a2j+1 â‰¤
a1
2j
(j â‰¥ 0)
and so,
ar â‰¤ 2âˆ’br/2cM (r = 0, 1, 2, . . .).
Obviously the algorithm has terminated if ar < 1, and this will have happened when r is large enough so
that 2âˆ’br/2cM < 1, i.e., if r > 2 log2M . If a < b then after 1 operation we will be in the case â€˜a â‰¥ bâ€™ that
we have just discussed, and the proof is complete.
The upper bound in the statement of theorem 4.2.1 can be visualized as follows. The number log2M
is almost exactly the number of bits in the binary representation of M (what is â€˜exactlyâ€™ that number of
bits?). Theorem 4.2.1 therefore asserts that we can find the g.c.d. of two integers in a number of operations
that is at most a linear function of the number of bits that it takes to represent the two numbers. In brief,
we might say that â€˜Time = O(bits),â€™ in the case of Euclidâ€™s algorithm.
Exercises for section 4.2
1. Write a nonrecursive program, in Basic or Fortran, for the g.c.d. Write a recursive program, in Pascal or
a recursive language of your choice, for the g.c.d.
2. Choose 1000 pairs of integers (n,m), at random between 1 and 1000. For each pair, compute the g.c.d.
using a recursive program and a nonrecursive program.
(a) Compare the execution times of the two programs.
(b) There is a theorem to the effect that the probability that two random integers have g.c.d. = 1 is
6/Ï€2. What, precisely, do you think that this theorem means by â€˜the probability that ...â€™ ? What
percentage of the 1000 pairs that you chose had g.c.d. = 1? Compare your observed percentage
with 100 Â· (6/Ï€2).
3. Find out when Euclid lived, and with exactly what words he described his algorithm.
4. Write a program that will light up a pixel in row m and column n of your CRT display if and only if
gcd(m,n) = 1. Run the program with enough values of m and n to fill your screen. If you see any interesting
visual patterns, try to explain them mathematically.
5. Show that if m and n have a total of B bits, then Euclidâ€™s algorithm will not need more than 2B + 3
operations before reaching termination.
84
4.3 The extended Euclidean algorithm
6. Suppose we have two positive integers m, n, and we have factored them completely into primes, in the
form
m =
âˆ
paii ; n =
âˆ
qbii .
How would you calculate gcd(m,n) from the above information? How would you calculate the least common
multiple (lcm) of m and n from the above information? Prove that gcd(m,n) = mn/lcm(m,n).
7. Calculate gcd(102131, 56129) in two ways: use the method of exercise 6 above, then use the Euclidean
algorithm. In each case count the total number of arithmetic operations that you had to do to get the
answer.
8. Let Fn be the nth Fibonacci number. How many operations will be needed to compute gcd(Fn, Fnâˆ’1) by
the Euclidean algorithm? What is gcd(Fn, Fnâˆ’1)?
4.3 The extended Euclidean algorithm
Again suppose n,m are two positive integers whose g.c.d. is g. Then we can always write g in the form
g = tn+ um (4.3.1)
where t and u are integers. For instance, gcd(14, 11) = 1, so we can write 1 = 14t + 11u for integers t, u.
Can you spot integers t, u that will work? One pair that does the job is (4,âˆ’5), and there are others (can
you find all of them?).
The extended Euclidean algorithm finds not only the g.c.d. of n and m, it also finds a pair of integers t,
u that satisfy (4.3.1). One â€˜applicationâ€™ of the extended algorithm is that we will obtain an inductive proof
of the existence of t, u, that is not immediately obvious from (4.3.1) (see exercise 1 below). While this hardly
rates as a â€˜practicalâ€™ application, it represents a very important feature of recursive algorithms. We might
say, rather generally, that the following items go hand-in-hand:
Recursive algorithms
Inductive proofs
Complexity analyses by recurrence formulas
If we have a recursive algorithm, then it is natural to prove the validity of the algorithm by mathematical
induction. Conversely, inductive proofs of theorems often (not always, alas!) yield recursive algorithms for
the construction of the objects that are being studied. The complexity analysis of a recursive algorithm will
use recurrence formulas, in a natural way. We saw that already in the analysis that proved theorem 4.2.1.
Now letâ€™s discuss the extended algorithm. Input to it will be two integers n and m. Output from it will
be g = gcd(n,m) and two integers t and u for which (4.3.1) is true.
A single step of the original Euclidean algorithm took us from the problem of finding gcd(n,m) to
gcd(m,n mod m). Suppose, inductively, that we not only know g = gcd(m,n mod m) but we also know the
coefficients tâ€², uâ€² for the equation
g = tâ€²m + uâ€²(n mod m). (4.3.2)
Can we get out, at the next step, the corresponding coefficients t, u for (4.3.1)? Indeed we can, by substituting
in (4.3.2) the fact that
n mod m = nâˆ’
âŒŠ n
m
âŒ‹
m (4.3.3)
we find that
g = tâ€²m + uâ€²(nâˆ’
âŒŠ n
m
âŒ‹
m)
= uâ€²n+ (tâ€² âˆ’ uâ€²
âŒŠ n
m
âŒ‹
)m.
(4.3.4)
Hence the rule by which tâ€², uâ€² for equation (4.3.2) transform into t, u for equation (4.3.1) is that
t = uâ€²
u = tâ€² âˆ’
âŒŠ n
m
âŒ‹
uâ€².
(4.3.5)
85
Chapter 4: Algorithms in the Theory of Numbers
We can now formulate recursively the extended Euclidean algorithm.
procedure gcdext(n,m, g, t, u);
{computes g.c.d. of n and m, and finds
integers t, u that satisfy (4.3.1)}
if m = 0 then
g := n; t := 1;u := 0
else
gcdext(m,n mod m, g, t, u);
s := u;
u := tâˆ’ bn/mcu;
t := s
end.{gcdext}
It is quite easy to use the algorithm above to make a proof of the main mathematical result of this
section (see exercise 1), which is
Theorem 4.3.1. Let m and n be given integers, and let g be their greatest common divisor. Then there
exist integers t, u such that g = tm + un.
An immediate consequence of the algorithm and the theorem is the fact that finding inverses modulo a
given integer is an easy computational problem. We will need to refer to that fact in the sequel, so we state
it as
Corollary 4.3.1. Let m and n be given positive integers, and let g be their g.c.d. Then m has a multi-
plicative inverse modulo n if and only if g = 1. In that case, the inverse can be computed in polynomial
time.
Proof: By the extended Euclidean algorithm we can find, in linear time, integers t and u such that g =
tm+ un. But this last equation says that tm â‰¡ g (mod n). If g = 1 then it is obvious that t is the inverse
modn of m. If g > 1 then there exists no t such that tm â‰¡ 1 (mod n) since tm = 1 + rn implies that the
g.c.d. of m and n is 1.
We will now trace the execution of gcdext if it is called with (n,m) = (14, 11). The routine first replaces
(14,11) by (11,3) and calls itself. Then it calls itself successively with (3,2), (2,1) and (1,0). When it executes
with (n,m) = (1, 0) it encounters the â€˜if m = 0â€™ statement, so it sets g := 1, t := 1, u := 0.
Now it can complete the execution of the call with (n,m) = (2, 1), which has so far been pending. To
do this it sets
u := tâˆ’ bn/mcu = 1
t := 0.
The call with (n,m) = (2, 1) is now complete. The call to the routine with (n,m) = (3, 2) has been in
limbo until just this moment. Now that the (2,1) call is finished, the (3,2) call executes and finds
u := 0 âˆ’ b3/2c 1 = 1
t := 1.
The call to the routine with (n,m) = (11, 3) has so far been languishing, but its turn has come. It
computes
u := 1 âˆ’ b11/3c (âˆ’1) = 4
t := âˆ’1.
Finally, the original call to gcdext from the user, with (n,m) = (14, 11), can be processed. We find
u := (âˆ’1) âˆ’ b14/11c 4 = âˆ’5
t := 4.
86
4.4 Primality testing
Therefore, to the user, gcdext returns the values g = 1, u = âˆ’5, t = 4, and we see that the procedure has
found the representation (4.3.1) in this case. The importance of the â€˜trivial caseâ€™ where m = 0 is apparent.
Exercises for section 4.3
1. Give a complete formal proof of theorem 4.3.1. Your proof should be by induction (on what?) and should
use the extended Euclidean algorithm.
2. Find integers t, u such that
(a) 1 = 4t+ 7u
(b) 1 = 24t+ 35u
(c) 5 = 65t+ 100u
3. Let a1, . . . , an be positive integers.
(a) How would you compute gcd(a1, . . . , an)?
(b) Prove that there exist integers t1, . . . , tn such that
gcd(a1, . . . , an) = t1a1 + t2a2 + Â· Â· Â·+ tnan.
(c) Give a recursive algorithm for the computation of t1, . . . , tn in part (b) above.
4. If r = ta+ub, where r, a, b, u, v are all integers, must r = gcd(a, b)? What, if anything, can be said about
the relationship of r to gcd(a, b)?
5. Let (t0, u0) be one pair of integers t, u for which gcd(a, b) = ta+ub. Find all such pairs of integers, a and
b being given.
6. Find all solutions to exercises 2(a)-(c) above.
7. Find the multiplicative inverse of 49 modulo 73, using the extended Euclidean algorithm.
8. If gcdext is called with (n,m) = (98, 30), draw a picture of the complete tree of calls that will occur
during the recursive execution of the program. In your picture show, for each recursive call in the tree, the
values of the input parameters to that call and the values of the output variables that were returned by that
call.
4.4 Primality testing
In Chapter 1 we discussed the important distinction between algorithms that run in polynomial time
vs. those that may require exponential time. Since then we have seen some fast algorithms and some slow
ones. In the network flow problem the complexity of the MPM algorithm was O(V 3), a low power of the
size of the input data string, and the same holds true for the various matching and connectivity problems
that are special cases of the network flow algorithm.
Likewise, the Fast Fourier Transform is really Fast. It needs only O(n logn) time to find the transform
of a sequence of length n if n is a power of two, and only O(n2) time in the worst case, where n is prime.
In both of those problems we were dealing with computational situations near the low end of the
complexity scale. It is feasible to do a Fast Fourier Transform on, say, 1000 data points. It is feasible to
calculate maximum flows in networks with 1000 vertices or so.
On the other hand, the recursive computation of the chromatic polynomial in section 2.3 of Chapter 2
was an example of an algorithm that might use exponential amounts of time.
In this chapter we will meet another computational question for which, to date, no one has ever been
able to provide a polynomial-time algorithm, nor has anyone been able to prove that such an algorithm does
not exist.
The problem is just this: Given a positive integer n. Is n prime?
87
Chapter 4: Algorithms in the Theory of Numbers
The reader should now review the discussion in Example 3 of section 0.2. In that example we showed
that the obvious methods of testing for primality are slow in the sense of complexity theory. That is, we
do an amount of work that is an exponentially growing function of the length of the input bit string if we
use one of those methods. So this problem, which seems like a â€˜pushoverâ€™ at first glance, turns out to be
extremely difficult.
Although it is not known if a polynomial-time primality testing algorithm exists, remarkable progress
on the problem has been made in recent years.
One of the most important of these advances was made independently and almost simultaneously by
Solovay and Strassen, and by Rabin, in 1976-7. These authors took the imaginative step of replacing
â€˜certainlyâ€™ by â€˜probably,â€™ and they devised what should be called a probabilistic compositeness (an integer
is composite if it is not prime) test for integers, that runs in polynomial time.
Here is how the test works. First choose a number b uniformly at random, 1 â‰¤ b â‰¤ n âˆ’ 1. Next,
subject the pair (b, n) to a certain test, called a pseudoprimality test, to be described below. The test has
two possible outcomes: either the number n is correctly declared to be composite or the test is inconclusive.
If that were the whole story it would be scarcely have been worth the telling. Indeed the test â€˜Does b
divide n?â€™ already would perform the function stated above. However, it has a low probability of success
even if n is composite, and if the answer is â€˜No,â€™ we would have learned virtually nothing.
The additional property that the test described below has, not shared by the more naive test â€˜Does b
divide n?,â€™ is that if n is composite, the chance that the test will declare that result is at least 1/2.
In practice, for a given n we would apply the test 100 times using 100 numbers bi that are independently
chosen at random in [1, nâˆ’ 1]. If n is composite, the probability that it will be declared composite at least
once is at least 1âˆ’2âˆ’100, and these are rather good odds. Each test would be done in quick polynomial time.
If n is not found to be composite after 100 trials, and if certainty is important, then it would be worthwhile
to subject n to one of the nonprobabilistic primality tests in order to dispel all doubt.
It remains to describe the test to which the pair (b, n) is subjected, and to prove that it detects com-
positeness with probability â‰¥ 1/2.
Before doing this we mention another important development. A more recent primality test, due to
Adleman, Pomerance and Rumely in 1983, is completely deterministic. That is, given n it will surely decide
whether or not n is prime. The test is more elaborate than the one that we are about to describe, and it
runs in tantalizingly close to polynomial time. In fact it was shown to run in time
O((logn)c log log logn)
for a certain constant c. Since the number of bits of n is a constant multiple of logn, this latter estimate is
of the form
O((Bits)c log log Bits).
The exponent of â€˜Bits,â€™ which would be constant in a polynomial time algorithm, in fact grows extremely
slowly as n grows. This is what was referred to as â€˜tantalizingly closeâ€™ to polynomial time, earlier.
It is important to notice that in order to prove that a number is not prime, it is certainly sufficient to
find a nontrivial divisor of that number. It is not necessary to do that, however. All we are asking for is a
â€˜yesâ€™ or â€˜noâ€™ answer to the question â€˜is n prime?.â€™ If you should find it discouraging to get only the answer
â€˜noâ€™ to the question â€˜Is 7122643698294074179 prime?,â€™ without getting any of the factors of that number,
then what you want is a fast algorithm for the factorization problem.
In the test that follows, the decision about the compositeness of n will be reached without a knowledge
of any of the factors of n. This is true of the Adleman, Pomerance, Rumely test also. The question of
finding a factor of n, or all of them, is another interesting computational problem that is under active
investigation. Of course the factorization problem is at least as hard as finding out if an integer is prime,
and so no polynomial-time algorithm is known for it either. Again, there are probabilistic algorithms for the
factorization problem just as there are for primality testing, but in the case of the factorization problem,
even they donâ€™t run in polynomial-time.
In section 4.9 we will discuss a probabilistic algorithm for factoring large integers, after some motivation
in section 4.8, where we remark on the connection between computationally intractable problems and cryp-
tography. Specifically, we will describe one of the â€˜Public Keyâ€™ data encryption systems whose usefulness
stems directly from the difficulty of factoring large integers.
88
4.5 Interlude: the ring of integers modulo n
Isnâ€™t it amazing that in this technologically enlightened age we still donâ€™t know how to find a divisor of
a whole number quickly?
4.5 Interlude: the ring of integers modulo n
In this section we will look at the arithmetic structure of the integers modulo some fixed integer n.
These results will be needed in the sequel, but they are also of interest in themselves and have numerous
applications.
Consider the ring whose elements are 0, 1, 2, . . . , n âˆ’ 1 and in which we do addition, subtraction, and
multiplication modulo n. This ring is called Zn. For example, in Table 4.5.1 we show the addition and
multiplication tables of Z6.
+ 0 1 2 3 4 5 âˆ— 0 1 2 3 4 5
0 0 1 2 3 4 5 0 0 0 0 0 0 0
1 1 2 3 4 5 0 1 0 1 2 3 4 5
2 2 3 4 5 0 1 2 0 2 4 0 2 4
3 3 4 5 0 1 2 3 0 3 0 3 0 3
4 4 5 0 1 2 3 4 0 4 2 0 4 2
5 5 0 1 2 3 4 5 0 5 4 3 2 1
Table 4.5.1: Arithmetic in the ring Z6
Notice that while Zn is a ring, it certainly need not be a field, because there will usually be some
noninvertible elements. Reference to Table 4.5.1 shows that 2, 3, 4 have no multiplicative inverses in Z6,
while 1, 5 do have such inverses. The difference, of course, stems from the fact that 1 and 5 are relatively
prime to the modulus 6 while 2, 3, 4 are not. We learned, in corollary 4.3.1, that an element m of Zn is
invertible if and only if m and n are relatively prime.
The invertible elements of Zn form a multiplicative group. We will call that group the group of units of
Zn and will denote it by Un. It has exactly Ï†(n) elements, by lemma 4.5.1, where Ï† is the Euler function of
(4.1.5).
The multiplication table of the group U18 is shown in Table 4.5.2.
âˆ— 1 5 7 11 13 17
1 1 5 7 11 13 17
5 5 7 17 1 11 13
7 7 17 13 5 1 11
11 11 1 5 13 17 7
13 13 11 1 17 7 5
17 17 13 11 7 5 1
Table 4.5.2: Multiplication modulo 18
Notice that U18 contains Ï†(18) = 6 elements, that each of them has an inverse and that each row
(column) of the multiplication table contains a permutation of all of the group elements.
Letâ€™s look at the table a little more closely, with a view to finding out if the group U18 is cyclic. In a
cyclic group there is an element a whose powers 1, a, a2, a3, . . . run through all of the elements of the group.
If we refer to the table again, we see that in U18 the powers of 5 are 1, 5, 7, 17,13,11,1, . . .. Thus the
order of the group element 5 is equal to the order of the group, and the powers of 5 exhaust all group
elements. The group U18 is indeed cyclic, and 5 is a generator of U18.
89
Chapter 4: Algorithms in the Theory of Numbers
A number (like 5 in the example) whose powers run through all elements of Un is called a primitive root
modulo n. Thus 5 is a primitive root modulo 18. The reader should now find, from Table 4.5.2, all of the
primitive roots modulo 18.
Alternatively, since the order of a group element must always divide the order of the group, every
element of Un has an order that divides Ï†(n). The primitive roots are exactly the elements, if they exist, of
maximum possible order Ï†(n).
We pause to note two corollaries of these remarks, namely
Theorem 4.5.1 (â€˜Fermatâ€™s theoremâ€™). For every integer b that is relatively prime to n we have
bÏ†(n) â‰¡ 1 (mod n). (4.5.1)
In particular, if n is a prime number then Ï†(n) = nâˆ’ 1, and we have
Theorem 4.5.2 (â€˜Fermatâ€™s little theoremâ€™). If n is prime, then for all b 6â‰¡ 0 (mod n) we have bnâˆ’1 â‰¡ 1
(mod n).
It is important to know which groups Un are cyclic, i.e., which integers n have primitive roots. The
answer is given by
Theorem 4.5.3. An integer n has a primitive root if and only if n = 2 or n = 4 or n = pa (p an odd prime)
or n = 2pa (p an odd prime). Hence, the groups Un are cyclic for precisely such values of n.
The proof of theorem 4.5.3 is a little lengthy and is omitted. It can be found, for example, in the book
of LeVeque that is cited at the end of this chapter.
According to theorem 4.5.3, for example, U18 is cyclic, which we have already seen, and U12 is not cyclic,
which the reader should check.
Further, we state as an immediate consequence of theorem 4.5.3,
Corollary 4.5.3. If n is an odd prime, then Un is cyclic, and in particular the equation x2 = 1, in Un, has
only the solutions x = Â±1.
Next we will discuss the fact that if the integer n can be factored in the form n = pa11 p
a2
2 Â· Â· Â·parr then
the full ring Zn can also be factored, in a certain sense, as a â€˜productâ€™ of Zpai
i
.
Letâ€™s take Z6 as an example. Since 6 = 2 Â· 3, we expect that somehow Z6 = Z2
âŠ—
Z3. What this means
is that we consider ordered pairs x1, x2, where x1 âˆˆ Z2 and x2 âˆˆ Z3.
Here is how we do the arithmetic with the ordered pairs.
First, (x1, x2) + (y1, y2) = (x1 + y1, x2 + y2), in which the two â€˜+â€™ signs on the right are different: the
first â€˜x1 + y1â€™ is done in Z2 while the â€˜x2 + y2â€™ is done in Z3.
Second, (x1, x2)Â·(y1, y2) = (x1 Â·y1, x2 Â·y2), in which the two multiplications on the right side are different:
the â€˜x1 Â· y1â€™ is done in Z2 and the â€˜x2 Â· y2â€™ in Z3.
Therefore the 6 elements of Z6 are
(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1,2).
A sample of the addition process is
(0, 2) + (1, 1) = (0 + 1, 2 + 1)
= (1, 0)
where the addition of the first components was done modulo 2 and of the second components was done
modulo 3.
A sample of the multiplication process is
(1, 2) Â· (1, 2) = (1 Â· 1, 2 Â· 2)
= (1, 1)
in which multiplication of the first components was done modulo 2 and of the second components was done
modulo 3.
In full generality we can state the factorization of Zn as
90
4.5 Interlude: the ring of integers modulo n
Theorem 4.5.4. Let n = pa11 p
a2
2 Â· Â· Â·parr . The mapping which associates with each x âˆˆ Zn the r-tuple
(x1, x2, . . . , xr), where xi = x mod paii (i = 1, r), is a ring isomorphism of Zn with the ring of r-tuples
(x1, x2, . . . , xr) in which
(a) xi âˆˆ Zpaii (i = 1, r) and
(b) (x1, . . . , xr) + (y1, . . . , yr) = (x1 + y1, . . . , xr + yr) and
(c) (x1, . . . , xr) Â· (y1, . . . , yr) = (x1 Â· y1, . . . , xr Â· yr)
(d) In (b), the ith â€˜+â€™ sign on the right side is the addition operation of Zpai
i
and in (c) the ith â€˜Â·â€™ sign is
the multiplication operation of Zpaii , for each i = 1, 2, . . ., r.
The proof of theorem 4.5.4 follows at once from the famous
Theorem 4.5.5 (â€˜The Chinese Remainder Theoremâ€™). Let mi (i = 1, r) be pairwise relatively prime
positive integers, and let
M = m1m2 Â· Â· Â·mr .
Then the mapping that associates with each integer x (0 â‰¤ x â‰¤ M âˆ’ 1) the r-tuple (b1, b2, . . . , br), where
bi = x mod mi (i = 1, r), is a bijection between ZM and Zm1 Ã— Â· Â· Â· Ã— Zmr .
A good theorem deserves a good proof. An outstanding theorem deserves two proofs, at least, one
existential, and one constructive. So here are one of each for the Chinese Remainder Theorem.
Proof 1: We must show that each r-tuple (b1, . . . , br) such that 0 â‰¤ bi < mi (i = 1, r) occurs exactly once.
There are obviously M such vectors, and so it will be sufficient to show that each of them occurs at most
once as the image of some x.
In the contrary case we would have x and xâ€² both corresponding to (b1, b2, . . . , br), say. But then
xâˆ’ xâ€² â‰¡ 0 modulo each of the mi. Hence xâˆ’ xâ€² is divisible by M = m1m2 Â· Â· Â·mr . But |xâˆ’ xâ€²| < M , hence
x = xâ€².
Proof 2: Hereâ€™s how to compute a number x that satisfies the simultaneous congruences x â‰¡ bi mod
mi (i = 1, r). First, by the extended Euclidean algorithm we can quickly find t1, . . . , tr, u1, . . . , ur, such that
tj(M/mj ) + ujmj = 1 for j = 1, . . . , r. Then we claim that the number x =
âˆ‘
j bjtj(M/mj) satisfies all of
the given congruences. Indeed, for each k = 1, 2, . . ., r we have
x =
râˆ‘
j=1
bjtj(M/mj)
â‰¡ bktk(M/mk) (mod mk)
â‰¡ bk (mod mk)
where the first congruence holds because each M/mj (j 6= k) is divisible by mk, and the second congruence
follows since
tk(M/mk) = 1 âˆ’ ukmk â‰¡ 1 mod mk,
completing the second proof of the Chinese Remainder Theorem.
Now the proof of theorem 4.5.4 follows easily, and is left as an exercise for the reader.
The factorization that is described in detail in theorem 4.5.4 will be written symbolically as
Zn âˆ¼=
râŠ—
i=1
Zpaii . (4.5.2)
The factorization (4.5.2) of the ring Zn induces a factorization
Un âˆ¼=
râŠ—
i=1
Upiai (4.5.3)
91
Chapter 4: Algorithms in the Theory of Numbers
of the group of units. Since Un is a group, (4.5.3) is an isomorphism of the multiplicative structure only. In
Z12, for example, we find
U12 âˆ¼= U4U3
where U4 = {1, 3}, U3 = {1, 2}. So U12 can be thought of as the set {(1, 1, ), (1, 2), (3,1), (3,2)}, together
with the componentwise multiplication operation described above.
Exercises for section 4.5
1. Give a complete proof of theorem 4.5.4.
2. Find all primitive roots modulo 18.
3. Find all primitive roots modulo 27.
4. Write out the multiplication table of the group U27.
5. Which elements of Z11 are squares?
6. Which elements of Z13 are squares?
7. Find all x âˆˆ U27 such that x2 = 1. Find all x âˆˆ U15 such that x2 = 1.
8. Prove that if there is a primitive root modulo n then the equation x2 = 1 in the group Un has only the
solutions x = Â±1.
9. Find a number x that is congruent to 1, 7 and 11 to the respective moduli 5, 11 and 17. Use the method
in the second proof of the remainder theorem 4.5.5.
10. Write out the complete proof of the â€˜immediateâ€™ corollary 4.5.3.
4.6 Pseudoprimality tests
In this section we will discuss various tests that might be used for testing the compositeness of integers
probabilistically.
By a pseudoprimality test we mean a test that is applied to a pair (b, n) of integers, and that has the
following characteristics:
(a) The possible outcomes of the test are â€˜n is compositeâ€™ or â€˜inconclusive.â€™
(b) If the test reports â€˜n is compositeâ€™ then n is composite.
(c) The test runs in a time that is polynomial in logn.
If the test result is â€˜inconclusiveâ€™ then we say that n is pseudoprime to the base b (which means that n
is so far acting like a prime number, as far as we can tell).
The outcome of the test of the primality of n depends on the base b that is chosen. In a good pseu-
doprimality test there will be many bases b that will give the correct answer. More precisely, a good
pseudoprimality test will, with high probability (i.e., for a large number of choices of the base b) declare
that a composite n is composite. In more detail, we will say that a pseudoprimality test is â€˜goodâ€™ if there
is a fixed positive number t such that every composite integer n is declared to be composite for at least tn
choices of the base b, in the interval 1 â‰¤ b â‰¤ n.
Of course, given an integer n, it is silly to say that â€˜there is a high probability that n is prime.â€™ Either
n is prime or it isnâ€™t, and we should not blame our ignorance on n itself. Nonetheless, the abuse of language
is sufficiently appealing that we will define the problem away: we will say that a given integer n is very
probably prime if we have subjected it to a good pseudoprimality test, with a large number of different bases
b, and have found that it is pseudoprime to all of those bases.
Here are four examples of pseudoprimality tests, only one of which is â€˜good.â€™
Test 1. Given b, n. Output â€˜n is compositeâ€™ if b divides n, else â€˜inconclusive.â€™
This isnâ€™t the good one. If n is composite, the probability that it will be so declared is the probability
that we happen to have found a b that divides n, where b is not 1 or n. The probability of this event, if b is
chosen uniformly at random from [1, n], is
p1 = (d(n) âˆ’ 2)/n
where d(n) is the number of divisors of n. Certainly p1 is not bounded from below by a positive constant t,
if n is composite.
92
4.6 Pseudoprimality tests
Test 2. Given b, n. Output â€˜n is compositeâ€™ if gcd(b, n) 6= 1, else output â€˜inconclusive.â€™
This one is a little better, but not yet good. If n is composite, the number of bases b â‰¤ n for which
Test 2 will produce the result â€˜compositeâ€™ is nâˆ’ Ï†(n), where Ï† is the Euler totient function, of (4.1.5). This
number of useful bases will be large if n has some small prime factors, but in that case itâ€™s easy to find
out that n is composite by other methods. If n has only a few large prime factors, say if n = p2, then the
proportion of useful bases is very small, and we have the same kind of inefficiency as in Test 1 above.
Now we can state the third pseudoprimality test.
Test 3. Given b, n. (If b and n are not relatively prime or) if bnâˆ’1 6â‰¡ 1 (mod n) then output â€˜n is
composite,â€™ else output â€˜inconclusive.â€™
Regrettably, the test is still not â€˜good,â€™ but itâ€™s a lot better than its predecessors. To cite an extreme
case of its un-goodness, there exist composite numbers n, called Carmichael numbers, with the property that
the pair (b, n) produces the output â€˜inconclusiveâ€™ for every integer b in [1, nâˆ’ 1] that is relatively prime to
n. An example of such a number is n = 1729, which is composite (1729 = 7 Â· 13 Â· 19), but for which Test
3 gives the result â€˜inconclusiveâ€™ on every integer b < 1729 that is relatively prime to 1729 (i.e., that is not
divisible by 7 or 13 or 19).
Despite such misbehavior, the test usually seems to perform quite well. When n = 169 (a difficult
integer for tests 1 and 2) it turns out that there are 158 different bâ€™s in [1,168] that produce the â€˜compositeâ€™
outcome from Test 3, namely every such b except for 19, 22, 23, 70, 80, 89, 99, 146, 147, 150, 168.
Finally, we will describe a good pseudoprimality test. The familial resemblance to Test 3 will be
apparent.
Test 4. (the strong pseudoprimality test): Given (b, n). Let n âˆ’ 1 = 2qm, where m is an odd integer. If
either
(a) bm â‰¡ 1 (mod n) or
(b) there is an integer i in [0, qâˆ’ 1] such that
bm2
i
â‰¡ âˆ’1 (mod n)
then return â€˜inconclusiveâ€™ else return â€˜n is composite.â€™
First we validate the test by proving the
Proposition. If the test returns the message â€˜n is composite,â€™ then n is composite.
Proof: Suppose not. Then n is an odd prime. We claim that
bm2
i
â‰¡ 1 (mod n)
for all i = q, q âˆ’ 1, . . . , 0. If so then the case i = 0 will contradict the outcome of the test, and thereby
complete the proof. To establish the claim, it is clearly true when i = q, by Fermatâ€™s theorem. If true for i,
then it is true for i âˆ’ 1 also, because
(bm2
iâˆ’1
)2 = bm2
i
â‰¡ 1 (mod n)
implies that the quantity being squared is +1 or âˆ’1. Since n is an odd prime, by corollary 4.5.3 Un is cyclic,
and so the equation x2 = 1 in Un has only the solutions x = Â±1. But âˆ’1 is ruled out by the outcome of the
test, and the proof of the claim is complete.
What is the computational complexity of the test? Consider first the computational problem of raising
a number to a power. We can calculate, for example, bm mod n with O(logm) integer multiplications,
by successive squaring. More precisely, we compute b, b2, b4, b8, . . . by squaring, and reducing modulo n
immediately after each squaring operation, rather than waiting until the final exponent is reached. Then we
use the binary expansion of the exponent m to tell us which of these powers of b we should multiply together
in order to compute bm. For instance,
b337 = b256 Â· b64 Â· b16 Â· b.
93
Chapter 4: Algorithms in the Theory of Numbers
The complete power algorithm is recursive and looks like this:
function power(b, m, n);
{returns bm mod n}
if m = 0
then
power := 1
else
t := sqr(power(b, bm/2c, n));
if m is odd then t := t Â· b;
power := t mod n
end.{power}
Hence part (a) of the strong pseudoprimality test can be done in O(logm) = O(logn) multiplications
of integers of at most O(logn) bits each. Similarly, in part (b) of the test there are O(logn) possible values
of i to check, and for each of them we do a single multiplication of two integers each of which has O(logn)
bits (this argument, of course, applies to Test 3 above also).
The entire test requires, therefore, some low power of logn bit operations. For instance, if we were to
use the most obvious way to multiply two B bit numbers we would do O(B2) bit operations, and then the
above test would take O((logn)3) time. This is a polynomial in the number of bits of input.
In the next section we are going to prove that Test 4 is a good pseudoprimality test in that if n is
composite then at least half of the integers b, 1 â‰¤ b â‰¤ nâˆ’ 1 will give the result â€˜n is composite.â€™
For example, if n = 169, then it turns out that for 157 of the possible 168 bases b in [1,168], Test 4 will
reply â€˜169 is composite.â€™ The only bases b that 169 can fool are 19, 22, 23, 70, 80, 89, 99, 146, 147, 150,
168. For this case of n = 169 the performances of Test 4 and of Test 3 are identical. However, there are no
analogues of the Carmichael numbers for Test 4.
Exercises for section 4.6
1. Given an odd integer n. Let T (n) be the set of all b âˆˆ [1, n] such that gcd(b, n) = 1 and bnâˆ’1 â‰¡ 1
(mod n). Show that |T (n)| divides Ï†(n).
2. Let H be a cyclic group of order n. How many elements of each order r are there in H (r divides n)?
3. If n = pa, where p is an odd prime, then the number of x âˆˆ Un such that x has exact order r, is Ï†(r), for
all divisors r of Ï†(n). In particular, the number of primitive roots modulo n is Ï†(Ï†(n)).
4. If n = pa11 Â· Â· Â·pamm , and if r divides Ï†(n), then the number of x âˆˆ Un such that xr â‰¡ 1 (modn) is
mâˆ
i=1
gcd(Ï†(paii ), r).
5. In a group G suppose fm and gm are, respectively, the number of elements of order m and the number
of solutions of the equation xm = 1, for each m = 1, 2, . . .. What is the relationship between these two
sequences? That is, how would you compute the gâ€™s from the f â€™s? the f â€™s from the gâ€™s? If you have never
seen a question of this kind, look in any book on the theory of numbers, find â€˜MoÌˆbius inversion,â€™ and apply
it to this problem.
4.7 Proof of goodness of the strong pseudoprimality test
In this section we will show that if n is composite, then at least half of the integers b in [1, nâˆ’ 1] will
yield the result â€˜n is compositeâ€™ in the strong pseudoprimality test. The basic idea of the proof is that a
subgroup of a group that is not the entire group can consist of at most half of the elements of that group.
Suppose n has the factorization
n = pa11 Â· Â· Â·pass
and let ni = piai (i = 1, s).
94
4.7 Goodness of pseudoprimality test
Lemma 4.7.1. The order of each element of Un is a divisor of eâˆ— = lcm{Ï†(ni); i = 1, s}.
Proof: From the product representation (4.5.3) of Un we find that an element x of Un can be regarded as
an s-tuple of elements from the cyclic groups Uni (i = 1, s). The order of x is equal to the lcm of the orders
of the elements of the s-tuple. But for each i = 1, . . . , s the order of the ith of those elements is a divisor of
Ï†(ni), and therefore the order of x divides the lcm shown above.
Lemma 4.7.2. Let n > 1 be odd. For each element u of Un let C(u) = {1, u, u2, . . . , ueâˆ’1} denote the cyclic
group that u generates. Let B be the set of all elements u of Un for which C(u) either contains âˆ’1 or has
odd order (e odd). If B generates the full group Un then n is a prime power.
Proof: Let eâˆ— = 2tm, where m is odd and eâˆ— is as shown in lemma 4.7.1. Then there is a j such that Ï†(nj)
is divisible by 2t.
Now if n is a prime power, we are finished. So we can suppose that n is divisible by more than one
prime number. Since Ï†(n) is an even number for all n > 2 (proof?), the number eâˆ— is even. Hence t > 0 and
we can define a mapping Ïˆ of the group Un to itself by
Ïˆ(x) = x2
tâˆ’1m (x âˆˆ Un)
(note that Ïˆ(x) is its own inverse).
This is in fact a group homomorphism:
âˆ€x, y âˆˆ Un : Ïˆ(xy) = Ïˆ(x)Ïˆ(y).
Let B be as in the statement of lemma 4.7.2. For each x âˆˆ B, Ïˆ(x) is in C(x) and
Ïˆ(x)2 = Ïˆ(x2) = 1.
Since Ïˆ(x) is an element of C(x) whose square is 1, Ïˆ(x) has order 1 or 2. Hence if Ïˆ(x) 6= 1, it is of order
2. If the cyclic group C(x) is of odd order then it contains no element of even order. Hence C(x) is of even
order and contains âˆ’1. Then it can contain no other element of order 2, so Ïˆ(x) = âˆ’1 in this case.
Hence for every x âˆˆ B, Ïˆ(x) = Â±1.
Suppose B generates the full group Un. Then not only for every x âˆˆ B but for every x âˆˆ Un it is true
that Ïˆ(x) = Â±1.
Suppose n is not a prime power. Then s > 1 in the factorization (4.5.2) of Un. Consider the element v
of Un which, when written out as an s-tuple according to that factorization, is of the form
v = (1, 1, 1, . . ., 1, y, 1, . . . , 1)
where the â€˜yâ€™ is in the jth component, y âˆˆ Unj (recall that j is as described above, in the second sentence of
this proof). We can suppose y to be an element of order exactly 2t in Unj since Unj is cyclic.
Consider Ïˆ(v). Clearly Ïˆ(v) is not 1, for otherwise the order of y, namely 2t, would divide 2tâˆ’1m, which
is impossible because m is odd.
Also, Ïˆ(v) is not âˆ’1, because the element âˆ’1 of Un is represented uniquely by the s-tuple all of whose
entries are âˆ’1. Thus Ïˆ(v) is neither 1 nor âˆ’1 in Un, which contradicts the italicized assertion above. Hence
s = 1 and n is a prime power, completing the proof.
Now we can prove the main result of Solovay, Strassen and Rabin, which asserts that Test 4 is good.
Theorem 4.7.1. Let Bâ€² be the set of integers b mod n such that (b, n) returns â€˜inconclusiveâ€™ in Test 4.
(a) If Bâ€² generates Un then n is prime.
(b) If n is composite then Bâ€² consists of at most half of the integers in [1, nâˆ’ 1].
Proof: Suppose b âˆˆ Bâ€² and let m be the odd part of n âˆ’ 1. Then either bm â‰¡ 1 or bm2i â‰¡ âˆ’1 for some
i âˆˆ [0, q âˆ’ 1]. In the former case the cyclic subgroup C(b) has odd order, since m is odd, and in the latter
case C(b) contains âˆ’1.
95
Chapter 4: Algorithms in the Theory of Numbers
Hence in either case Bâ€² âŠ† B, where B is the set defined in the statement of lemma 4.7.2 above. If Bâ€²
generates the full group Un then B does too, and by lemma 4.7.2, n is a prime power, say n = pk.
Also, in either of the above cases we have bnâˆ’1 â‰¡ 1, so the same holds for all b âˆˆ Bâ€², and so for all
x âˆˆ Un we have xnâˆ’1 â‰¡ 1, since Bâ€² generates Un.
Now Un is cyclic of order
Ï†(n) = Ï†(pk) = pkâˆ’1(p âˆ’ 1).
By theorem 4.5.3 there are primitive roots modulo n = pk. Let g be one of these. The order of g is, on the
one hand, pkâˆ’1(pâˆ’1) since the set of all of its powers is identical with Un, and on the other hand is a divisor
of nâˆ’ 1 = pk âˆ’ 1 since xnâˆ’1 â‰¡ 1 for all x, and in particular for x = g.
Hence pkâˆ’1(pâˆ’ 1) (which, if k > 1, is a multiple of p) divides pk âˆ’ 1 (which is one less than a multiple
of p), and so k = 1, which completes the proof of part (a) of the theorem.
In part (b), n is composite and so Bâ€² cannot generate all of Un, by part (a). Hence Bâ€² generates a
proper subgroup of Un, and so can contain at most half as many elements as Un contains, and the proof is
complete.
Another application of the same circle of ideas to computer science occurs in the generation of random
numbers on a computer. A good way to do this is to choose a primitive root modulo the word size of your
computer, and then, each time the user asks for a random number, output the next higher power of the
primitive root. The fact that you started with a primitive root insures that the number of â€˜random numbersâ€™
generated before repetition sets in will be as large as possible.
Now weâ€™ll summarize the way in which the primality test is used. Suppose there is given a large integer
n, and we would like to determine if it is prime.
We would do
function testn(n, outcome);
times := 0;
repeat
choose an integer b uniformly at random in [2, nâˆ’ 1];
apply the strong pseudoprimality test (Test 4) to the
pair (b, n);
times := times + 1
until {result is â€˜n is compositeâ€™ or times = 100};
if times = 100 then outcome:=â€˜n probably primeâ€™
else outcome:=â€˜n is compositeâ€™
end{testn}
If the procedure exits with â€˜n is composite,â€™ then we can be certain that n is not prime. If we want to
see the factors of n then it will be necessary to use some factorization algorithm, such as the one described
below in section 4.9.
On the other hand, if the procedure halts because it has been through 100 trials without a conclusive
result, then the integer n is very probably prime. More precisely, the chance that a composite integer n
would have behaved like that is less than 2âˆ’100. If we want certainty, however, it will be necessary to apply a
test whose outcome will prove primality, such as the algorithm of Adleman, Rumely and Pomerance, referred
to earlier.
In section 4.9 we will discuss a probabilistic factoring algorithm. Before doing so, in the next section
we will present a remarkable application of the complexity of the factoring problem, to cryptography. Such
applications remind us that primality and factorization algorithms have important applications beyond pure
mathematics, in areas of vital public concern.
Exercises for section 4.7
1. For n = 9 and for n = 15 find all of the cyclic groups C(u), of lemma 4.7.2, and find the set B.
2. For n = 9 and n = 15 find the set Bâ€², of theorem 4.7.1.
96
4.8 Factoring and cryptography
4.8 Factoring and cryptography
A computationally intractable problem can be used to create secure codes for the transmission of infor-
mation over public channels of communication. The idea is that those who send the messages to each other
will have extra pieces of information that will allow the m to solve the intractable problem rapidly, whereas
an aspiring eavesdropper would be faced with an exponential amount of computation.
Even if we donâ€™t have a provably computationally intractable problem, we can still take a chance that
those who might intercept our messages wonâ€™t know any polynomial-time algorithms if we donâ€™t know any.
Since there are precious few provably hard problems, and hordes of apparently hard problems, it is scarcely
surprising that a number of sophisticated coding schemes rest on the latter rather than the former. One
should remember, though, that an adversary might discover fast algorithms for doing these problems and
keep that fact secret while deciphering all of our messages.
A remarkable feature of a family of recently developed coding schemes, called â€˜Public Key Encryption
Systems,â€™ is that the â€˜keyâ€™ to the code lies in the public domain, so it can be easily available to sender and
receiver (and eavesdropper), and can be readily changed if need be. On the negative side, the most widely
used Public Key Systems lean on computational problems that are only presumed to be intractable, like
factoring large integers, rather than having been proved so.
We are going to discuss a Public Key System called the RSA scheme, after its inventors: Rivest, Shamir
and Adleman. This particular method depends for its success on the seeming intractability of the problem
of finding the factors of large integers. If that problem could be done in polynomial time, then the RSA
system could be â€˜cracked.â€™
In this system there are three centers of information: the sender of the message, the receiver of the
message, and the Public Domain (for instance, the â€˜Personalsâ€™ ads of the New York Times). Here is how the
system works.
(A) Who knows what and when
Here are the items of information that are involved, and who knows each item:
p, q: two large prime numbers, chosen by the receiver, and told to nobody else (not even to the sender!).
n : the product pq is n, and this is placed in the Public Domain.
E : a random integer, placed in the Public Domain by the receiver, who has first made sure that E is
relatively prime to (pâˆ’ 1)(q âˆ’ 1) by computing the g.c.d., and choosing a new E at random until the g.c.d.
is 1. This is easy for the receiver to do because p and q are known to him, and the g.c.d. calculation is fast.
P : a message that the sender would like to send, thought of as a string of bits whose value, when
regarded as a binary number, lies in the range [0, nâˆ’ 1].
In addition to the above, one more item of information is computed by the receiver, and that is the
integer D that is the multiplicative inverse mod (pâˆ’ 1)(q âˆ’ 1) of E, i.e.,
DE â‰¡ 1 (mod (pâˆ’ 1)(q âˆ’ 1)).
Again, since p and q are known, this is a fast calculation for the receiver, as we shall see.
To summarize,
The receiver knows p, q, D
The sender knows P
Everybody knows n and E
In Fig. 4.8.1 we show the interiors of the heads of the sender and receiver, as well as the contents of the
Public Domain.
97
Chapter 4: Algorithms in the Theory of Numbers
Fig. 4.8.1: Who knows what
(B) How to send a message
The sender takes the message P , looks at the public keys E and n, computes C â‰¡ PE (mod n), and
transmits C over the public airwaves.
Note that the sender has no private codebook or anything secret other than the message itself.
(C) How to decode a message
The receiver receives C, and computes CD mod n. Observe, however, that (p âˆ’ 1)(q âˆ’ 1) is Ï†(n), and
so we have
CD â‰¡ PDE
= P (1+tÏ†(n)) (t is some integer)
â‰¡ P (mod n)
where the last equality is by Fermatâ€™s theorem (4.5.1). The receiver has now recovered the original message
P .
If the receiver suspects that the code has been broken, i.e., that the adversaries have discovered the
primes p and q, then the sender can change them without having to send any secret messages to anyone else.
Only the public numbers n and E would change. The sender would not need to be informed of any other
changes.
Before proceeding, the reader is urged to contruct a little scenario. Make up a short (very short!) mes-
sage. Choose values for the other parameters that are needed to complete the picture. Send the message as
the sender would, and decode it as the receiver would. Then try to intercept the message, as an eavesdropper
would, and see what the difficulties are.
(D) How to intercept the message
An eavesdropper who receives the message C would be unable to decode it without (inventing some
entirely new decoding scheme or) knowing the inverse D of E (mod (p âˆ’ 1)(q âˆ’ 1)). The eavesdropper,
however, does not even know the modulus (p âˆ’ 1)(q âˆ’ 1) because p and q are unknown (only the receiver
knows them), and knowing the product pq = n alone is insufficient. The eavesdropper is thereby compelled
to derive a polynomial-time factoring algorithm for large integers. May success attend those efforts!
The reader might well remark here that the receiver has a substantial computational problem in creating
two large primes p and q. To a certain extent this is so, but two factors make the task a good deal easier.
First, p and q will need to have only half as many bits as n has, so the job is of smaller size. Second, there
98
4.9 Factoring large integers
are methods that will produce large prime numbers very rapidly as long as one is not too particular about
which primes they are, as long as they are large enough. We will not discuss those methods here.
The elegance of the RSA cryptosystem prompts a few more remarks that are intended to reinforce the
distinction between exponential- and polynomial-time complexities.
How hard is it to factor a large integer? At this writing, integers of up to perhaps a couple of hundred
digits can be approached with some confidence that factorization will be accomplished within a few hours of
the computing time of a very fast machine. If we think in terms of a message that is about the length of one
typewritten page, then that message would contain about 8000 bits, equivalent to about 2400 decimal digits.
This is in contrast to the largest feasible length that can be handled by contemporary factoring algorithms of
about 200 decimal digits. A one-page message is therefore well into the zone of computational intractability.
How hard is it to find the multiplicative inverse, mod (pâˆ’ 1)(q âˆ’ 1)? If p and q are known then itâ€™s easy
to find the inverse, as we saw in corollary 4.3.1. Finding an inverse modn is no harder than carrying out
the extended Euclidean algorithm, i.e., itâ€™s a linear time job.
4.9 Factoring large integers
The problem of finding divisors of large integers is in a much more primitive condition than is primality
testing. For example, we donâ€™t even know a probabilistic algorithm that will return a factor of a large
composite integer, with probability > 1/2, in polynomial time.
In this section we will discuss a probabilistic factoring algorithm that finds factors in an average time
that is only moderately exponential, and thatâ€™s about the state of the art at present.
Let n be an integer whose factorization is desired.
Definition. By a factor base B we will mean a set of distinct nonzero integers {b0, b1, . . . , bh}.
Definition. Let B be a factor base. An integer a will be called a B-number if the integer c that is defined
by the conditions
(a) c â‰¡ a2 (mod n) and
(b) âˆ’n/2 â‰¤ c < n/2
can be written as a product of factors from the factor base B.
If we let e(a, i) denote the exponent of bi in that product, then we have
a2 â‰¡
hâˆ
i=0
b
e(a,i)
i (mod n).
Hence, for each B-number we get an (h + 1)-vector of exponents e(a).
Suppose we can find enough B-numbers so that the resulting collection of exponent vectors is a linearly
dependent set, mod 2. For instance, a set of h+ 2 B-numbers would certainly have that property.
Then we could nontrivially represent the zero vector as a sum of a certain set A of exponent vectors,
say âˆ‘
aâˆˆA
e(a) â‰¡ (0, 0, . . . , 0) (mod 2).
Now define the integers
ri = (1/2)
âˆ‘
aâˆˆA
e(a, i) (i = 0, 1, . . .h)
u =
âˆ
A
a (mod n)
v =
âˆ
i
brii .
It then would follow, after an easy calculation, that u2 â‰¡ v2 (mod n). Hence either u âˆ’ v or u + v has
a factor in common with n. It may be, of course, that u â‰¡ Â±v (mod n), in which case we would have
99
Chapter 4: Algorithms in the Theory of Numbers
learned nothing. However if neither u â‰¡ v (mod n) nor u â‰¡ âˆ’v (mod n) is true then we will have found
a nontrivial factor of n, namely gcd(uâˆ’ v, n) or gcd(u+ v, n).
Example:
Take as a factor base B = {âˆ’2, 5}, and let it be required to find a factor of n = 1729. Then we claim
that 186 and 267 are B-numbers. To see that 186 is a B-number, note that 1862 = 20 Â· 1729 + (âˆ’2)4, and
similarly, since 2672 = 41 Â· 1729 + (âˆ’2)452, we see that 267 is a B-number, for this factor base B.
The exponent vectors of 186 and 167 are (4, 0) and (4, 2) respectively, and these sum to (0, 0) (mod 2),
hence we find that
u = 186 Ã— 267 â‰¡ 1250 (mod 1729)
r1 = 4; r2 = 1
v = (âˆ’2)4(5)1 = 80
gcd(uâˆ’ v, n) = gcd(1170, 1729) = 13
and we have found the factor 13 of 1729.
There might have seemed to be some legerdemain involved in plucking the B-numbers 186 and 267 out
of the air, in the example above. In fact, as the algorithm has been implemented by its author, J. D. Dixon,
one simply chooses integers uniformly at random from [1, nâˆ’ 1] until enough B-numbers have been found
so their exponent vectors are linearly dependent modulo 2. In Dixonâ€™s implementation the factor base that
is used consists of âˆ’1 together with the first h prime numbers.
It can then be proved that if n is not a prime power then with a correct choice of h relative to n, if we
repeat the random choices until a factor of n is found, the average running time will be
exp{(2 + o(1))(log log logn).5}.
This is not polynomial time, but it is moderately exponential only. Nevertheless, it is close to being about
the best that we know how to do on the elusive problem of factoring a large integer.
4.10 Proving primality
In this section we will consider a problem that sounds a lot like primality testing, but is really a little
different because the rules of the game are different. Basically the problem is to convince a skeptical audience
that a certain integer is prime, requiring them to do only a small amount of computation in order to be so
persuaded.
First, though, suppose you were writing a 100-decimal-digit integer n on the blackboard in front of a
large audience and you wanted to prove to them that n was not a prime.
If you simply wrote down two smaller integers whose product was n, the job would be done. Anyone
who wished to be certain could spend a few minutes multiplying the factors together and verifying that their
product was indeed n, and all doubts would be dispelled.
Indeed*, a spea ker at a mathematical convention in 1903 announced the result that 267 âˆ’ 1 is not a
prime number, and to be utterly convincing all he had to do was to write
267 âˆ’ 1 = 193707721Ã— 761838257287.
We note that the speaker probably had to work very hard to find those factors, but having found them
it became quite easy to convince others of the truth of the claimed result.
A pair of integers r, s for which r 6= 1, s 6= 1, and n = rs constitute a certificate attesting to the
compositeness of n. With this certificate C(n) and an auxiliary checking algorithm, viz.
(1) Verify that r 6= 1, and that s 6= 1
(2) Verify that rs = n
we can prove, in polynomial time, that n is not a prime number.
* We follow the account given in V. Pratt, Every prime has a succinct certificate, SIAM J. Computing, 4
(1975), 214-220.
100
4.10 Proving primality
Now comes the hard part. How might we convince an audience that a certain integer n is a prime
number? The rules are that we are allowed to do any immense amount of calculation beforehand, and the
results of that calculation can be written on a certificate C(n) that accompanies the integer n. The audience,
however, will need to do only a polynomial amount of further computation in order to convince themselves
that n is prime.
We will describe a primality-checking algorithm A with the following properties:
(1) Inputs to A are the integer n and a certain certificate C(n).
(2) If n is prime then the action of A on the inputs (n, C(n)) results in the output â€˜n is prime.â€™
(3) If n is not prime then for every possible certificate C(n) the action of A on the inputs (n, C(n)) results
in the output â€˜primality of n is not verified.â€™
(4) Algorithm A runs in polynomial time.
Now the question is, does such a procedure exist for primality verification? The answer is affirmative,
and we will now describe one. The fact that primality can be quickly verified, if not quickly discovered, is
of great importance for the developments of Chapter 5. In the language of section 5.1, what we are about
to do is to show that the problem â€˜Is n prime?â€™ belongs to the class NP.
The next lemma is a kind of converse to â€˜Fermatâ€™s little theoremâ€™ (theorem 4.5.2 ).
Lemma 4.10.1. Let p be a positive integer. Suppose there is an integer x such that xpâˆ’1 â‰¡ 1 (mod p)
and such that for all divisors d of pâˆ’ 1, d < pâˆ’ 1, we have xd 6â‰¡ 1 (mod p). Then p is prime.
Proof: First we claim that gcd(x, p) = 1, for let g = gcd(x, p). Then x = ggâ€², p = ggâ€²â€². Since xpâˆ’1 â‰¡ 1
(mod p) we have xpâˆ’1 = 1 + tp and xpâˆ’1 âˆ’ tp = (ggâ€²)pâˆ’1 âˆ’ tggâ€²â€² = 1. The left side is a multiple of g. The
right side is not, unless g = 1.
It follows that x âˆˆ Up, the group of units of Zp. Thus x is an element of order pâˆ’ 1 in a group of order
Ï†(p). Hence (p âˆ’ 1)|Ï†(p). But always Ï†(p) â‰¤ pâˆ’ 1. Hence Ï†(p) = pâˆ’ 1 and p is prime.
Lemma 4.10.1 is the basis for V. Prattâ€™s method of constructing certificates of primality. The construc-
tion of the certificate is actually recursive since step 30 below calls for certificates of smaller primes. We
suppose that the certificate of the prime 2 is the trivial case, and that it can be verified at no cost.
Here is a complete list of the information that is on the certificate C(p) that accompanies an integer p
whose primality is to be attested to:
10: a list of the primes pi and the exponents ai for the canonical factorization pâˆ’ 1 =
âˆr
i=1 p
ai
i
20: the certificates C(pi) of each of the primes p1, . . . , pr
30: a positive integer x.
To verify that p is prime we could execute the following algorithm B:
(B1) Check that pâˆ’ 1 =
âˆ
paii .
(B2) Check that each pi is prime, using the certificates C(pi) (i = 1, r).
(B3) For each divisor d of p âˆ’ 1, d < pâˆ’ 1, check that xd 6â‰¡ 1 (mod p).
(B4) Check that xpâˆ’1 â‰¡ 1 (mod p).
This algorithm B is correct, but it might not operate in polynomial time. In step B3 we are looking at
every divisor of pâˆ’ 1, and there may be a lot of them.
Fortunately, it isnâ€™t necessary to check every divisor of p âˆ’ 1. The reader will have no trouble proving
that there is a divisor d of pâˆ’ 1 (d < pâˆ’ 1) for which xd â‰¡ 1 (mod p) if and only if there is such a divisor
that has the special form d = (pâˆ’ 1)/pi.
The primality checking algorithm A now reads as follows.
(A1) Check that pâˆ’ 1 =
âˆ
paii .
(A2) Check that each pi is prime, using the certificates C(pi) (i = 1, r).
(A3) For each i := 1 to r, check that
x(pâˆ’1)/pi 6â‰¡ 1 (mod p).
101
Chapter 4: Algorithms in the Theory of Numbers
(A4) Check that xpâˆ’1 â‰¡ 1 (mod p).
Now letâ€™s look at the complexity of algorithm A .
We will measure its complexity by the number of times that we have to do a computation of either of
the types (a) â€˜is m =
âˆ
q
bj
j ?â€™ or (b) â€˜is y
s â‰¡ 1 (mod p)?â€™
Let f(p) be that number. Then we have (remembering that the algorithm calls itself r times)
f(p) = 1 +
râˆ‘
i=2
f(pi) + r + 1 (4.10.1)
in which the four terms, as written, correspond to the four steps in the checking algorithm. The sum begins
with â€˜i = 2â€™ because the prime 2, which is always a divisor of pâˆ’ 1, is â€˜free.â€™
Now (4.10.1) can be written as
g(p) =
râˆ‘
i=2
g(pi) + 4 (4.10.2)
where g(p) = 1 + f(p). We claim that g(p) â‰¤ 4 log2 p for all p.
This is surely true if p = 2. If true for primes less than p then from (4.10.2),
g(p) â‰¤
râˆ‘
i=2
{4 log2 pi} + 4
= 4 log2 {
râˆ
i=2
pi} + 4
â‰¤ 4 log2 {(pâˆ’ 1)/2} + 4
= 4 log2 (pâˆ’ 1)
â‰¤ 4 log2 p.
Hence f(p) â‰¤ 4 log2 pâˆ’ 1 for all p â‰¥ 2.
Since the number of bits in p is Î˜(log p), the number f(p) is a number of executions of steps that is
a polynomial in the length of the input bit string. We leave to the exercises the verification that each of
the steps that f(p) counts is also executed in polynomial time, so the entire primality-verification procedure
operates in polynomial time. This yields
Theorem 4.10.1. (V. Pratt, 1975) There exist a checking algorithm and a certificate such that primality
can be verified in polynomial time.
Exercises for section 4.10
1. Show that two positive integers of b bits each can be multiplied with at most O(b2) bit operations
(multiplications and carries).
2. Prove that step A1 of algorithm A can be executed in polynomial time, where time is now measured by
the number of bit operations that are implied by the integer multiplications.
3. Same as exercise 2 above, for steps A3 and A4.
4. Write out the complete certificate that attests to the primality of 19.
5. Find an upper bound for the total number of bits that are in the certificate of the integer p.
6. Carry out the complete checking algorithm on the certificate that you prepared in exercise 4 above.
7. Let p = 15. Show that there is no integer x as described in the hypotheses of lemma 4.10.1.
8. Let p = 17. Find all integers x that satisfy the hypotheses of lemma 4.10.1.
102
4.10 Proving primality
Bibliography
The material in this chapter has made extensive use of the excellent review article
John D. Dixon, Factorization and primality tests, The American Mathematical Monthly, 91 (1984), 333-352.
A basic reference for number theory, Fermatâ€™s theorem, etc. is
G. H. Hardy and E. M. Wright, An Introduction to the Theory of Numbers, Oxford University Press, Oxford,
1954
Another is
W. J. LeVeque, Fundamentals of Number Theory, Addison-Wesley, Re ading, MA, 1977
The probabilistic algorithm for compositeness testing was found by
M. O. Rabin, Probabilistic algorithms, in Algorithms and Complexity, New Directions and Recent Results,
J. Traub ed., Academic Press, New York, 1976
and at about the same time by
R. Solovay and V. Strassen, A fast Monte Carlo test for primality, SIAM Journal of Computing, 6 (1977),
pp. 84-85; erratum ibid., 7 (1978), 118.
Some empirical properties of that algorithm are in
C. Pomerance, J. L. Selfridge and S. Wagstaff Jr., The pseudoprimes to 25Â·109, Mathematics of Computation,
35 (1980 ), 1003-1026.
The fastest nonprobabilistic primality test appeared first in
L. M. Adleman, On distinguishing prime numbers from composite numbers, IEEE Abstracts, May 1980,
387-406.
A more complete account, together with the complexity analysis, is in
L. M. Adleman, C. Pomerance and R. S. Rumely, On distinguishing prime numbers from composite numbers,
Annals of Mathematics 117 (1983), 173-206.
A streamlined version of the above algorithm was given by
H. Cohen and H. W. Lenstra Jr., Primality testing and Jacobi sums, Report 82-18, Math. Inst. U. of
Amsterdam, Amsterdam, 1982.
The idea of public key data encryption is due to
W. Diffie and M. E. Hellman, New directions in cryptography, IEEE Transactions on Information Theory,
IT-22, 6 (1976), 644-654.
An account of the subject is contained in
M. E. Hellman, The mathematics of public key cryptography, Scientific American, 241, 2 (August 1979),
146-157.
The use of factoring as the key to the code is due to
R. L. Rivest, A. Shamir and L. M. Adleman, A method for obtaining digital signatures and public key
cryptosystems, Communications of the A.C.M., 21, 2 (February 1978), 120-126
The probabilistic factoring algorithm in the text is that of
John D. Dixon, Asymptotically fast factorization of integers, Mathematics of Computation, 36 (1981), 255-
260.
103
Chapter 5: NP -completeness
Chapter 5: NP -completeness
5.1 Introduction
In the previous chapter we met two computational problems for which fast algorithms have never been
found, but neither have such algorithms been proved to be unattainable. Those were the primality-testing
problem, for which the best-known algorithm is delicately poised on the brink of polynomial time, and the
integer-factoring problem, for which the known algorithms are in a more primitive condition.
In this chapter we will meet a large family of such problems (hundreds of them now!). This family is not
just a list of seemingly difficult computational problems. It is in fact bound together by strong structural
ties. The collection of problems, called the NP -complete problems, includes many well known and important
questions in discrete mathematics, such as the following.
The travelling salesman problem (â€˜TSPâ€™): Given n points in the plane (â€˜citiesâ€™), and a distance D. Is
there a tour that visits all n of the cities, returns to its starting point, and has total length â‰¤ D?
Graph coloring: Given a graph G and an integer K. Can the vertices of G be properly colored in K or
fewer colors?
Independent set: Given a graph G and an integer K. Does V (G) contain an independent set ofK vertices?
Bin packing: Given a finite set S of positive integers, and an integer N (the number of bins). Does there
exist a partition of S into N or fewer subsets such that the sum of the integers in each subset is â‰¤ K? In
other words, can we â€˜packâ€™ the integers of S into at most N â€˜bins,â€™ where the â€˜capacityâ€™ of each bin is K?
These are very difficult computational problems. Take the graph coloring problem, for instance. We
could try every possible way of coloring the vertices of G in K colors to see if any of them work. There are
Kn such possibilities, if G has n vertices. Hence a very large amount of computation will be done, enough
so that if G has 50 vertices and we have 10 colors at our disposal, the problem would lie far beyond the
capabilities of the fastest computers that are now available.
Hard problems can have easy instances. If the graph G happens to have no edges at all, or very few of
them, then it will be very easy to find out if a coloring is possible, or if an independent set of K vertices is
present.
The real question is this (letâ€™s use â€˜Independent Setâ€™ as an illustration). Is it possible to design an
algorithm that will come packaged with a performance guarantee of the following kind:
The seller warrants that if a graph G, of n vertices,
and a positive integerK are input to this program, then
it will correctly determine if there is an independent set
of K or more vertices in V (G), and it will do so in an
amount of time that is at most 1000n8 minutes.
Hence there is no contradiction between the facts that the problem is hard and that there are easy
cases. The hardness of the problem stems from the seeming impossibility of producing such an algorithm
accompanied by such a manufacturerâ€™s warranty card. Of course the â€˜1000n8â€™ didnâ€™t have to be exactly that.
But some quite specific polynomial in the length of the input bit string must appear in the performance
guarantee. Hence â€˜357n9â€™ might have appeared in the guarantee, and so might â€˜23n3,â€™ but â€˜nK â€™ would not
be allowed.
Letâ€™s look carefully at why nK would not be an acceptable worst-case polynomial time performance
bound. In the â€˜Independent Setâ€™ problem the input must describe the graph G and the integer K. How
many bits are needed to do that? The graph can be specified, for example, by its vertex adjacency matrix
A. This is an nÃ— n matrix in which the entry in row i and column j is 1 if (i, j) âˆˆ E(G) and is 0 else.
Evidently n2 bits of input will describe the matrix A. The integers K and n can be entered with just
O(logn) bits, so the entire input bit string for the â€˜Independent Setâ€™ problem is âˆ¼ n2 bits long. Let B denote
the number of bits in the input string. Suppose that on the warranty card the program was guaranteed to
run in a time that is < nK .
Is this a guarantee of polynomial time performance? That question means â€˜Is there a polynomial P such
that for every instance of â€˜Independent Setâ€™ the running time T will be at most P (B)?â€™ Well, is T bounded
104
What is a language?
by a polynomial in B if T = nK and B âˆ¼ n2? It would seem so; in fact obviously T = O(BK/2), and thatâ€™s
a polynomial, isnâ€™t it?
The key point resides in the order of the qualifiers. We must give the polynomial that works for
every instance of the problem first. Then that one single polynomial must work on every instance. If
the â€˜polynomialâ€™ that we give is BK/2, well thatâ€™s a different polynomial in B for different instances of
the problem, because K is different for different instances. Therefore if we say that a certain program for
â€˜Independent Setâ€™ will always get an answer before BK/2 minutes, where B is the length of the input bit
string, then we would not have provided a polynomial-time guarantee in the form of a single polynomial in
B that applies uniformly to all problem instances.
The distinction is a little thorny, but is worthy of careful study because itâ€™s of fundamental importance.
What we are discussing is usually called a worst-case time bound, meaning a bound on the running time that
applies to every instance of the problem. Worst-case time bounds arenâ€™t the only possible interesting ones.
Sometimes we might not care if an algorithm is occasionally very slow as long as it is almost always fast. In
other situations we might be satisfied with an algorithm that is fast on average. For the present, however,
we will stick to the worst-case time bounds and study some of the theory that applies to that situation. In
sections 5.6 and 5.7 we will study some average time bounds.
Now letâ€™s return to the properties of the NP-complete family of problems. Here are some of them.
10: The problems all seem to be computationally very difficult, and no polynomial time algorithms have
been found for any of them.
20: It has not been proved that polynomial time algorithms for these problems do not exist.
20: But this is not just a random list of hard problems. If a fast algorithm could be found for one
NP-complete problem then here would be fast algorithms for all of them.
20: Conversely, if it could be proved that no fast algorithm exists for one of the NP-complete problems,
then there could not be a fast algorithm for any other of those problems.
The above properties are not intended to be a definition of the concept of NP-completeness. Weâ€™ll get to
that later on in this section. They are intended as a list of some of the interesting features of these problems,
which, when coupled with their theoretical and practical importance, accounts for the intense worldwide
research effort that has gone into understanding them in recent years.
The question of the existence or nonexistence of polynomial-time algorithms for the NP-complete prob-
lems probably rates as the principal unsolved problem that faces theoretical computer science today.
Our next task will be to develop the formal machinery that will permit us to give precise definitions
of all of the concepts that are needed. In the remainder of this section we will discuss the additional ideas
informally, and then in section 5.2 weâ€™ll state them quite precisely.
What is a decision problem? First, the idea of a decision problem. A decision problem is one that asks
only for a yes-or-no answer: Can this graph be 5-colored? Is there a tour of length â‰¤ 15 miles? Is there a
set of 67 independent vertices?
Many of them problems that we are studying can be phrased as decision problems or as optimization
problems: What is the smallest number of colors with which G can be colored? What is the length of the
shortest tour of these cities? What is the size of the largest independent set of vertices in G?
Usually if we find a fast algorithm for a decision problem then with just a little more work we will
be able to solve the corresponding optimization problem. For instance, suppose we have an algorithm that
solves the decision problem for graph coloring, and what we want is the solution of the optimization problem
(the chromatic number).
Let a graph G be given, say of 100 vertices. Ask: can the graph be 50-colored? If so, then the chromatic
number lies between 1 and 50. Then ask if it can be colored in 25 colors. If not, then the chromatic
number lies between 26 and 50. Continue in this way, using bisection of the interval that is known to
contain the chromatic number. After O(logn) steps we will have found the chromatic number of a graph of
n vertices. The extra multiplicative factor of logn will not alter the polynomial vs. nonpolynomial running
time distinction. Hence if there is a fast way to do the decision problem then there is a fast way to do the
optimization problem. The converse is obvious.
Hence we will restrict our discussion to decision problems.
105
Chapter 5: NP -completeness
What is a language?
Since every decision problem can have only the two answers â€˜Y/N,â€™ we can think of a decision problem
as asking if a given word (the input string) does or does not belong to a certain language. The language is
the totality of words for which the answer is â€˜Y.â€™
The graph 3-coloring language, for instance, is the set of all symetric, square matrices of 0,1 entries,
with zeroes on the main diagonal (these are the vertex adjacency matrices of graphs) such that the graph
that the matrix represents is 3-colorable. We can image that somewhere there is a vast dictionary of all of
the words in this language. A 3-colorability computation is therefore nothing but an attempt to discover
whether a given word belongs to the dictionary.
What is the class P?
We say that a decision problem belongs to the class P if there is an algorithm A and a number c such
that for every instance I of the problem the algorithm A will produce a solution in time O(Bc), where B is
the number of bits in the input string that represents I.
To put it more briefly, P is the set of easy decision problems.
Examples of problems in P are most of the ones that we have already met in this book: Are these two
integers relatively prime? Is this integer divisible by that one? Is this graph 2-colorable? Is there a flow of
value greater than K in this network? Can this graph be disconnected by the removal of K or fewer edges?
Is there a matching of more than K edges in this bipartite graph? For each of these problems there is a fast
(polynomial time) algorithm.
What is the class NP?
The class NP is a little more subtle. A decision problem Q belongs to NP if there is an algorithm A
that does the following:
(a) Associated with each word of the language Q (i.e.,with each instance I for which the answer is â€˜Yesâ€™)
there is a certificate C(I) such that when the pair (I, C(I)) are input to algorithm A it recognizes
that I belongs to the language Q.
(b) If I is some word that does not belong to the language Q then there is no choice of certificate C(I)
that will cause A to recognize I as a member of Q.
(c) Algorithm A operates in polynomial time.
To put this one more briefly, NP is the class of decision problems for which it is easy to check the
correctness of a claimed answer, with the aid of a little extra information. So we arenâ€™t asking for a way to
find a solution, but only to verify that an alleged solution really is correct.
Here is an analogy that may help to clarify the distinction between the classes P and NP. We have all
had the experience of reading through a truly ingenious and difficult proof of some mathematical theorem,
and wondering how the person who found the proof in the first place ever did it. Our task, as a reader, was
only to verify the proof, and that is a much easier job than the mathematician who invented the proof had.
To pursue the analogy a bit farther, some proofs are extremely time consuming even to check (see the proof
of the four-color theorem!), and similarly, some computational problems are not even known to belong to
NP, let alone to P.
In P are the problems where itâ€™s easy to find a solution, and in NP are the problems where itâ€™s easy to
check a solution that may have been very tedious to find.
Hereâ€™s another example. Consider the graph coloring problem to be the decision problem Q. Certainly
this problem is not known to be in P. It is, however, in NP, and here is an algorithm, and a method of
constructing certificates that proves it.
Suppose G is some graph that is K-colorable. The certificate of G might be a list of the colors that get
assigned to each vertex in some proper K-coloring of the vertices of G. Where did we get that list, you ask?
Well, we never said it was easy to construct a certificate. If you actually want to find one then you will have
to solve a hard problem. But weâ€™re really only talking about checking the correctness of an alleged answer.
To check that a certain graph G really is K-colorable we can be convinced if you will show us the color of
each vertex in a proper K-coloring.
If you do provide that certificate, then our checking algorithm A is very simple. It checks first that every
vertex has a color and only one color. It then checks that no more than K colors have been used altogether.
106
What is NP-completeness?
It finally checks that for each edge e of G it is true that the two endpoints of e have different colors.
Hence the graph coloring problem belongs to NP.
For the travelling salesman problem we would provide a certificate that contains a tour, whose total
length is â‰¤ K, of all of the cities. The checking algorithm A would then verify that the tour really does visit
all of the cities and really does have total length â‰¤ K.
The travelling salesman probelm, therefore, also belongs to NP.
â€˜Well,â€™ you might reply, â€˜if weâ€™re allowed to look at the answers, how could a problem fail to belong to
NP?â€™
Try this decision problem: an instance I of the problem consists of a set of n cities in the plane and a
positive number K. The question is â€˜Is it true that there is not a tour of all of these cities whose total length
is less than K?â€™ Clearly this is a kind of a negation of the travelling salesman problem. Does it belong to
NP? If so, there must be an algorithm A and a way of making a certificate C(I) for each instance I such
that we can quickly verify that no such tour exists of the given cities. Any suggestions for the certificate?
The algorithm? No one else knows how to do this either.
It is not known if this negation of the travelling salesman problem belongs to NP.
Are there problems that do belong to NP but for which it isnâ€™t immediately obvious that this is so?
Yes. In fact thatâ€™s one of the main reasons that we studied the algorithm of Pratt, in section 4.10. Prattâ€™s
algorithm is exactly a method of producing a certificate with the aid of which we can quickly check that a
given integer is prime. The decision problem â€˜Given n, is it prime?â€™ is thereby revealed to belong to NP,
although that fact wasnâ€™t obvious at a glance.
It is very clear that PâŠ†NP. Indeed if Q âˆˆ P is some decision problem then we can verify membership in
the language Q with the empty certificate. That is, we donâ€™t even need a certificate in order to do a quick
calculation that checks membership in the language because the problem itself can be quickly solved.
It seems natural to suppose that NP is larger than P. That is, one might presume that there are problems
whose solutions can be quickly checked with the aid of a certificate even though they canâ€™t be quickly found
in the first place.
No example of such a problem has ever been produced (and proved), nor has it been proved that no
such problem exists. The question of whether or not P=NP is the one that we cited earlier as being perhaps
the most important open question in the subject area today.
It is fairly obvious that the class P is called â€˜the class Pâ€™ because â€˜Pâ€™ is the first letter of â€˜Polynomial
Time.â€™ But what does â€˜NPâ€™ stand for? Stay tuned. The answer will appear in section 5.2.
What is reducibility?
Suppose that we want to solve a system of 100 simultaneous linear equations in 100 unknowns, of the
form Ax = b. We run down to the local software emporium and quickly purchase a program for $49.95 that
solves such systems. When we get home and read the fine print on the label we discover, to our chagrin,
that the system works only on systems where the matrix A is symmetric, and the coefficient matrix in the
system that we want to solve is, of course, not symmetric.
One possible response to this predicament would be to look for the solution to the system ATAx = AT b,
in which the coefficient matrix ATA is now symmetric.
What we would have done would be to have reduced the problem that we really are interested in to an
instance of a problem for which we have an algorithm.
More generally, let Q and Qâ€² be two decision problems. We will say that Qâ€² is quickly reducible to Q if
whenever we are given an instance Iâ€² of the problem Qâ€² we can convert it, with only a polynomial amount
of labor, into an instance I of Q, in such a way that Iâ€² and I both have the same answer (â€˜Yesâ€™ or â€˜Noâ€™).
Thus if we buy a program to solve Q, then we can use it to solve Qâ€², with just a small amount of extra
work.
What is NP-completeness?
How would you like to buy one program, for $49.95, that can solve 500 different kinds of problems?
Thatâ€™s what NP-completeness is about.
To state it a little more carefully, a decision problem is NP-complete if it belongs to NP and every
problem in NP is quickly reducible to it.
107
Chapter 5: NP -completeness
The implications of NP-completeness are numerous. Suppose we could prove that a certain decision
problem Q is NP-complete. Then we could concentrate our efforts to find polynomial-time algorithms on
just that one problem Q. Indeed if we were to succeed in finding a polynomial time algorithm to do instances
of Q then we would automatically have found a fast algorithm for doing every problem in NP. How does
that work?
Take an instance Iâ€² of some problem Qâ€² in NP. Since Qâ€² is quickly reducible to Q we could transform
the instance Iâ€² into an instance I of Q. Then use the super algorithm that we found for problems in Q to
decide I. Altogether only a polynomial amount of time will have been used from start to finish.
Letâ€™s be more specific. Suppose that tomorow morning we prove that the graph coloring problem is
NP-complete, and that on the next morning you find a fast algorithm for solving it. Then consider some
instance of the bin packing problem. Since graph coloring is NP-complete, the instance of bin packing can
be quickly converted into an instance of graph coloring for which the â€˜Yes/Noâ€™ answer is the same. Now use
the fast graph coloring algorithm that you found (congratulations, by the way!) on the converted problem.
The answer you get is the correct answer for the original bin packing problem.
So, a fast algorithm for some NP-complete problem implies a fast algorithm for every problem in NP.
Conversely suppose we can prove that it is impossible to find a fast algorithm for some particular problem
Q in NP. Then we canâ€™t find a fast algorithm for any NP-complete problem Qâ€² either. For if we could then
we would be able to solve instances of Q by quickly reducing them to instances of Qâ€² and solving them.
If we could prove that there is no fast way to test the primality of a given integer then we would have
proved that there is no fast way to decide of graphs are K-colorable, because, as we will see, the graph coloring
problem is NP-complete and primality testing is in NP. Think about that one for a few moments, and the
extraordinary beauty and structural unity of these computational problems will begin to reveal itself.
To summarize: quick for one NP-complete problem implies quick for all of NP; provably slow for one
problem in NP implies provably slow for all NP-complete problems.
Thereâ€™s just one small detail to attend to. Weâ€™ve been discussing the economic advantages of keeping
flocks of unicorns instead of sheep. If there arenâ€™t any unicorns then the discussion is a little silly.
NP-complete problems have all sorts of marvellous properties. Itâ€™s lovely that every problem in NP can
be quickly reduced to just that one NP-complete problem. But are there any NP-complete problems? Why,
after all, should there be a single computational problem with the property that every one of the diverse
creatures that inhabit NP should be quickly reducible to it?
Well, there are NP-complete problems, hordes of them, and proving that will occupy our attention for
the next two sections. Hereâ€™s the plan.
In section 5.2 we are going to talk about a simple computer, called a Turing machine. It is an idealized
computer, and its purpose is to standardize ideas of computability and time of computation by referring all
problems to the one standard machine.
A Turing machine is an extremely simple finite-state computer, and when it performs a computation,
a unit of computational labor will be very clearly and unambiguously describable. It turns out that the
important aspects of polynomial time computability do not depend on the particular computer that is
chosen as the model. The beauty of the Turing machine is that it is at once a strong enough concept that it
can in principle perform any calculation that any other finite state machine can do, while at the same time
it is logically clean and simple enough to be useful for proving theorems about complexity.
The microcomputer on your desktop might have been chosen as the standard against which polynomial
time computability is measured. If that had been done then the class P of quickly solvable problems would
scarcely have changed at all (the polynomials would be different but they would still be polynomials), but
the proofs that we humans would have to give in order to establish the relevant theorems would have gotten
much more complicated because of the variety of different kinds of states that modern computers have.
Next, in section 5.3 we will prove that there is an NP-complete problem. It is called the satisfiability
problem. Its status as an NP-complete problem was established by S. Cook in 1971, and from that work all
later progress in the field has flowed. The proof uses the theory of Turing machines.
The first NP-complete problem was the hardest one to find. We will find, in section 5.4, a few more
NP-complete problems, so the reader will get some idea of the methods that are used in identifying them.
Since nobody knows a fast way to solve these problems, various methods have been developed that give
approximate solutions quickly, or that give exact solutions in fast average time, and so forth. The beautiful
108
5.2 Turing Machines
book of Garey and Johnson (see references at the end of the chapter) calls this â€˜coping with NP-completeness,â€™
and we will spend the rest of this chapter discussing some of these ideas.
Exercises for section 5.1
1. Prove that the following decision problem belongs to P: Given integers K and a1, . . . , an. Is the median
of the aâ€™s smaller than K?
2. Prove that the following decision problem is in NP: given an n Ã— n matrix A of integer entries. Is
detA = 0?
3. For which of the following problems can you prove membership in P?
(a) Given a graph G. Does G contain a circuit of length 4?
(b) Given a graph G. Is G bipartite?
(c) Given n integers. Is there a subset of them whose sum is an even number?
(d) Given n integers. Is there a subset of them whose sum is divisible by 3?
(e) Given a graph G. Does G contain an Euler circuit?
4. For which of the following problems can you prove membership in NP?
(a) Given a set of integers and another integer K. Is there a subset of the given integers whose sum is
K?
(b) Given a graph G and an integer K. Does G contain a path of length â‰¥ K?
(c) Given a set of K integers. Is it true that not all of them are prime?
(d) Gievn a set of K integers. Is it true that all of them are prime?
5.2 Turing Machines
A Turing machine consists of
(a) a doubly infinite tape, that is marked off into squares that are numbered as shown in Fig. 5.2.1 below.
Each square can contain a single character from the character set that the machine recognizes. For
simplicity we can assume that the character set contains just three symbols: â€˜0,â€™ â€˜1,â€™ and â€˜â€™ (blank).
(b) a tape head that is capable of either reading a single character from a square on the tape or writing a
single character on a square, or moving its position relative to the tape by an increment of one square in
either direction.
(c) a finite list of states such that at every instant the machine is in exactly one of those states. The possible
states of the machine are, first of all, the regular states q1, . . . , qs, and second, three special states
q0: the initial state
qY , the final state in a problem to which the answer is â€˜Yesâ€™
qN : the final state in a problem to which the answer is â€˜Noâ€™
(d) a program (or program module, if we think of it as a pluggable component) that directs the machine
through the steps of a particular task.
Fig. 5.2.1: A Turing machine tape
Letâ€™s describe the program module in more detail. Suppose that at a certain instant the machine is in
state q (other than qY or qN ) and that the symbol that has just been read from the tape is â€˜symbol.â€™ Then
from the pair (q, symbol) the program module will decide
(i) to what state qâ€² the machine shall next go, and
(ii) what single character the machine will now write on the tape in the square over which the head is now
positioned, and
(iii) whether the tape head will next move one square to the right or one square to the left.
109
Chapter 5: NP -completeness
One step of the program, therefore, goes from
(state, symbol) to (newstate, newsymbol , increment). (5.2.1)
If and when the state reaches qY or qN the computation is over and the machine halts.
The machine should be thought of as part hardware and part software. The programmerâ€™s job is, as
usual, to write the software. To write a program for a Turing machine, what we have to do is to tell it how
to make each and every one of the transitions (5.2.1). A Turing machine program looks like a table in which,
for every possible pair (state, symbol) that the machine might find itself in, the programmer has specified
what the newstate, the newsymbol and the increment shall be.
To begin a computation with a Turing machine we take the input string x, of length B, say, that describes
the problem that we want to solve, and we write x in squares 1, 2, . . . , B of the tape. The tape head is then
positioned over square 1, the machine is put into state q0, the program module that the programmer prepared
is plugged into its slot, and the computation begins.
The machine reads the symbol in square 1. It now is in state q0 and has read symbol, so it can consult
the program module to find out what to do. The program instructs it to write at square 1 a newsymbol, to
move the head either to square 0 or to square 2, and to enter a certain newstate, say qâ€². The whole process
is then repeated, possibly forever, but hopefully after finitely many steps the machine will enter the state
qY or state qN , at which moment the computation will halt with the decision having been made.
If we want to watch a Turing machine in operation, we donâ€™t have to build it. We can simulate one.
Here is a pidgin-Pascal simulation of a Turing machine that can easily be turned into a functioning program.
It is in two principal parts.
The procedure turmach has for input a string x of length B, and for output it sets the Boolean variable
accept to True or False, depending on whether the outcome of the computation is that the machine halted
in state qY or qN respectively. This procedure is the â€˜hardwareâ€™ part of the Turing machine. It doesnâ€™t vary
from one job to the next.
Procedure gonextto is the program module of the machine, and it will be different for each task. Its
inputs are the present state of the machine and the symbol that was just read from the tape. Its outputs
are the newstate into which the machine goes next, the newsymbol that the tape head now writes on the
current square, and the increment (Â±1) by which the tape head will now move.
procedure turmach(B:integer; x :array[1..B]; accept:Boolean);
{simulates Turing machine action on input string x of length B}
{write input string on tape in first B squares}
for square := 1 to B do
tape[square] :=x[square];
{record boundaries of written-on part of tape}
leftmost:=1; rightmost := B;
{initialize tape head and state}
state:=0; square:=1;
while state 6= â€˜Yâ€™ and state 6= â€˜Nâ€™ do
{read symbol at current tape square}
if square< leftmost or square> rightmost
then symbol:=â€˜â€™ else symbol:= tape[square]
{ask program module for state transition}
gonnextto(state,symbol,newstate,newsybol,increment);
state:=newstate;
{update boundaries and write new symbol};
if square> rightmost then leftmost:= square;
tape[square]:=newsymbol;
{move tape head}
square := square+increment
end;{while}
accept:={ state=â€˜Yâ€™}
end.{turmach}
110
5.2 Turing Machines
Now letâ€™s try to write a particular program module gonextto. Consider the following problem: given
an input string x, consisting of 0â€™s and 1â€™s, of length B. FInd out if it is true that the string contains an
odd number of 1â€™s.
We will write a program that will scan the input string from left to right, and at each moment the
machine will be in state 0 if it has so far scanned an even number of 1â€™s, in state 1 otherwise. In Fig. 5.2.2
we show a program that will get the job done.
state symbol newstate newsymbol increment
0 0 0 0 +1
0 1 1 1 +1
0 blank qN blank âˆ’1
1 0 1 0 +1
1 1 0 1 +1
1 blank qY blank âˆ’1
Fig. 5.2.2: A Turing machine program for bit parity
Exercise. Program the above as procedure gonextto, run it for some input string, and print out the state of
the machine, the contents of the tape, and the position of the tape head after each step of the computation.
In the next section we are going to use the Turing machine concept to prove Cookâ€™s theorem, which
is the assertion that a certain problem is NP-complete. Right now letâ€™s review some of the ideas that have
already been introduced from the point of view of Turing machines.
We might immediately notice that some terms that were just a little bit fuzzy before are now much more
sharply in focus. Take the notion of polynomial time, for example. To make that idea precise one needs a
careful definition of what â€˜the length of the input bit stringâ€™ means, and what one means by the number of
â€˜stepsâ€™ in a computation.
But on a Turing machine both of these ideas come through with crystal clarity. The input bit string x
is what we write on the tape to get things started, and its length is the number of tape squares it occupies.
A â€˜stepâ€™ in a Turing machine calculation is obviously a single call to the program module. A Turing machine
caluclation was done â€˜in time P (B)â€™ if the input string occupied B tape squares and the calculation took
P (B) steps.
Another word that we have been using without ever nailing down precisely is â€˜algorithm.â€™ We all
understand informally what an algorithm is. But now we understand formally too. An algorithm for a
problem is a program module for a Turing machine that will cause the machine to halt after finitely many
steps in state â€˜Yâ€™ for every instance whose answer is â€˜Yes,â€™ and after finitely many steps in state â€˜Nâ€™ for every
instance whose answer is â€˜No.â€™
A Turing machine and an algorithm define a language. The language is the set of all input strings x
that lead to termination in state â€˜Y,â€™ i.e., to an accepting calculation.
Now letâ€™s see how the idea of a Turing machine can clarify the description of the class NP. This is
the class of problems for which the decisions can be made quickly if the input strings are accompanied by
suitable certificates.
By a certificate we mean a finite strip of Turing machine tape, consisting of 0 or more squares, each
of which contains a symbol from the character set of the machine. A certificate can be loaded into a
Turing machine as follows. If the certificate contains m > 0 tape squares, then replace the segment from
square number âˆ’m to square number âˆ’1, inclusive, of the Turing machine tape with the certificate. The
information on the certificate is then available to the program module just as any other information on the
tape is available.
To use a Turing machine as a checking or verifying computer, we place the input string x that describes
the problem instance in squares 1, 2, . . ., B of the tape, and we place the certificate C(x) of x in squares
âˆ’m,âˆ’m + 1, . . . ,âˆ’1 of the tape. We then write a verifying program for the program module in which the
program verifies that the string x is indeed a word in the language of the machine, and in the course of the
verification the program is quite free to examine the certificate as well as the problem instance.
A Turing machine that is being used as a verifying computer is called a nondeterministic machine. The
hardware is the same, but the manner of input and the question that is being asked are different from the
111
Chapter 5: NP -completeness
situation with a deterministic Turing machine, in which we decide whether or not the input string is in the
language, without using any certificates.
The class NP (â€˜Nondeterministic Polynomialâ€™) consists of those decision problems for which there exists
a fast (polynomial time) algorithm that will verify, given a problem instance string x and a suitable certificate
C(x), that x belongs to the language recognized by the machine, and for which, if x does not belong to the
language, no certificate would cause an accepting computation to ensue.
5.3 Cookâ€™s Theorem
The NP-complete problems are the hardest problems in NP, in the sense that if Qâ€² is any decision
problem in NP and Q is an NP-complete problem, then every instance of Qâ€² is polynomially reducible to an
instance of Q. As we have already remarked, the surprising thing is that there is an NP-complete problem
at all, since it is not immediately clear why any single problem should hold the key to the polynomial time
solvability of every problem in the class NP. But there is one. As soon as we see why there is one, then weâ€™ll
be able to see more easily why there are hundreds of them, including many computational questions about
discrete structures such as graphs, networks and games and about optimization problems, about algebraic
structures, formal logic, and so forth.
Here is the satisfiability problem, the first problem that was proved to be NP-complete, by Stephen Cook
in 1971.
We begin with a list of (Boolean) variables x1, . . . , xn. A literal is either one of the variables xi or the
negation of one of the variables, as xÌ„i. There are 2n possible literals.
A clause is a set of literals.
The rules of the game are these. We assign the value â€˜Trueâ€™ (T) or â€˜Falseâ€™ (F), to each one of the
variables. Having done that, each one of the literals inherits a truth value, namely a literal xi has the same
truth or falsity as the corresponding variable xi, and a literal xÌ„i has the opposite truth value from that of
the variable xi.
Finally each of the clauses also inherits a truth value from this process, and it is determined as follows.
A clause has the value â€˜Tâ€™ if and only if at least one of the literals in that clause has the value â€˜T,â€™ and
otherwise it has the value â€˜F.â€™
Hence starting with an assignment of truth values to the variables, some true and some false, we end
up with a determination of the truth values of each of the clauses, some true and some false.
Definition. A set of clauses is satisfiable if there exists an assignment of truth values to the variables that
makes all of the clauses true.
Think of the word â€˜orâ€™ as being between each of the literals in a clause, and the word â€˜andâ€™ as being
between the clauses.
The satisfiability problem (SAT). Given a set of clauses. Does there exist a set of truth values (=T or
F), one for each variable, such that every clause contains at least one literal whose value is T (i.e., such that
every clause is satisfied)?
Example: Consider the set x1, x2, x3 of variables. From these we might manufacture the following list of
four clauses:
{x1, xÌ„2}, {x1, x3}, {x2, xÌ„3}, {xÌ„1, x3}.
If we choose the truth values (T, T, F ) for the variables, respectively, then the four clauses would
acquire the truth values (T, T, T, F ), and so this would not be a satisfying truth assignment for the set
of clauses. There are only eight possible ways to assign truth values to three variables, and after a little
more experimentation we might find out that these clauses would in fact be satisfied if we were to make the
assignments (T, T, T ) (how can we recognize a set of clauses that is satisfied by assigning to every variable
the value â€˜Tâ€™?).
The example already leaves one with the feeling that SAT might be a tough computational problem,
because there are 2n possible sets of truth values that we might have to explore if we were to do an exhaustive
search.
It is quite clear, however, that this problem belongs to NP. Indeed, it is a decision problem. Furthermore
we can easily assign a certificate to every set of clauses for which the answer to SAT is â€˜Yes, the clauses
112
5.3 Cookâ€™s Theorem
are satisfiable.â€™ The certificate contains a set of truth values, one for each variable, that satisfy all of the
clauses. A Turing machine that receives the set of clauses, suitably encoded, as input, along with the above
certificate, would have to verify only that if the truth values are assigned to the variables as shown on the
certificate then indeed every clause does contain at least one literal of value â€˜T.â€™ That verification is certainly
a polynomial time computation.
Now comes the hard part. We want to show
Theorem 5.3.1. (S. Cook, 1971): SAT is NP-complete.
Before we carry out the proof, it may be helpful to give a small example of the reducibility ideas that
we are going to use.
1
2
3
4
Fig. 5.3.1: A 3-coloring problem
Example. Reducing graph-coloring to SAT
Consider the graph G of four vertices that is shown in Fig. 5.3.1, and the decision problem â€˜Can the
vertices of G be properly colored in 3 colors?â€™
Letâ€™s see how that decision problem can be reduced to an instance of SAT. We will use 12 Boolean
variables: the variable xi,j corresponds to the assertion that â€˜vertex i has been colored in color jâ€™ (i =
1, 2, 3, 4; j = 1, 2, 3).
The instance of SAT that we construct has 31 clauses. The first 16 of these are
C(i) := {xi,1, xi,2, xi,3} (i = 1, 2, 3, 4)
T (i) := {xÌ„i,1, xÌ„i,2} (i = 1, 2, 3, 4)
U (i) := {xÌ„i,1, xÌ„i,3} (i = 1, 2, 3, 4)
V (i) := {xÌ„i,2, xÌ„i,3} (i = 1, 2, 3, 4).
(5.3.1)
In the above, the four clauses C(i) assert that each vertex has been colored in at least one color. The
clauses T (i) say that no vertex has both color 1 and color 2. Similarly the clauses U (i) (resp. V (i)) guarantee
that no vertex has been colored 1 and 3 (resp. 2 and 3).
All 16 of the clauses in (5.3.1) together amount to the statement that â€˜each vertex has been colored in
one and only one of the three available colors.â€™
Next we have to construct the clauses that will assure us that the two endpoints of an edge of the graph
are never the same color. For this purpose we define, for each edge e of the graph G and color j (=1,2,3),
a clause D(e, j) as follows. Let u and v be the two endpoints of e; the D(e, j) := {xÌ„u,j, xÌ„v,j}, which asserts
that not both endpoints of the edge e have the same color j.
The original instance of the graph coloring problem has now been reduced to an instance of SAT. In
more detail, there exists an assignment of values T, F to the 12 Boolean variables x1,1, . . . , x4,3 such that
each of the 31 clauses contains at least one literal whose value is T if and only if the vertices of the graph G
can be properly colored in three colors. The graph is 3-colorable if and only if the clauses are satisfiable.
It is clear that if we have an algorithm that will solve SAT, then we can also solve graph coloring
problems. A few moments of thought will convince the reader that the transformation of one problem to the
other that was carried out above involves only a polynomial amount of computation, despite the seemingly
large number of variables and clauses. Hence graph coloring is quickly reducible to SAT.
113
Chapter 5: NP -completeness
Proof of Cookâ€™s theorem
We want to prove that SAT is NP-complete, i.e., that every problem in NP is polynomially reducible
to an instance of SAT. Hence let Q be some problem in NP and let I be an instance of problem Q. Since Q
is in NP there exists a Turing machine that recognizes encoded instances of problem Q, if accompanied by
a suitable certificate, in polynomial time.
Let TMQ be such a Turing machine, and let P (n) be a polynomial in its argument n with the property
that TMQ recognizes every pair (x,C(x)), where x is a word in the language Q and C(x) is its certificate,
in time â‰¤ P (n), where n is the length of x.
We intend to construct, corresponding to each word I in the language Q, and instance f(I) of SAT for
which the answer is â€˜Yes, the clauses are all simultaneously satisfiable.â€™ Conversely, if the word I is not in
the language Q, the clauses will not be satisfiable.
The idea can be summarized like this: the instance of SAT that will be constructed will be a collection
of clauses that together express the fact that there exists a certificate that causes Turing machine TMQ to do
an accepting calculation. Therefore, in order to test whether or not the word Q belongs to the language, it
suffices to check that the collection of clauses is satisfiable.
To construct an instance of SAT means that we are going to define a number of variables, of literals,
and of clauses, in such a way that the clauses are satisfiable if and only if x is in the language Q, i.e., the
machine TMQ accepts x and its certificate.
What we must do, then, is to express the accepting computation of the Turing machine as the simul-
taneous satisfaction of a number of logical propositions. It is precisely here that the relative simplicity of a
Turing machine allows us to enumerate all of the possible paths to an accepting computation in a way that
would be quite unthinkable with a â€˜realâ€™ computer.
Now we will describe the Boolean variables that will be used in the clauses under construction.
Variable Qi,k is true if after step i of the checking calculation it is true that the Turing machine TMQ
is in state qk, false otherwise.
Variable Si,j,a = {after step i, symbol a is in tape square j}.
Variable Ti,j = {after step i, the tape head is positioned over square j}.
Letâ€™s count the variables that weâ€™ve just introduced. Since the Turing machine TMQ does its accepting
calculation in time â‰¤ P (n) it follows that the tape head will never venture more than Â±P (n) squares away
from its starting position. Therefore the subscript j, which runs through the various tape squares that are
scanned during the computation, can assume only O(P (n)) different values.
Index a runs over the letters in the alphabet that the machine can read, so it can assume at most some
fixed number A of values.
The index i runs over the steps of the accepting computation, and so it takes at most O(P (n)) different
values.
Finally, k indexes the states of the Turing machine, and there is only some fixed finite number, K, say,
of states that TMQ might be in. Hence there are altogether O(P (n)2) variables, a polynomial number of
them.
Is it true that every random assignment of true or false values to each of these variables corresponds to
an accepting computation on (x,C(x))? Certainly not. For example, if we arenâ€™t careful we might assign
true values to T9,4 and to T10,33, thereby burning out the bearings on the tape transport mechanism! (why?)
Our remaining task, then, will be to describe precisely the conditions under which a set of values assigned
to the variables listed above actually defines a possible accepting calculation for (x,C(x)). Then we will be
sure that whatever set of satisfying values of the variables might be found by solving the SAT problem, they
will determine a real accepting calculation of the machine TMQ.
This will be done by requiring that a number of clauses be all true (â€˜satisfiedâ€™) at once, where each
clause will exprss one necessary condition. In the following, the bold face type will describe, in words, the
condition that we want to express, and it will be followed by the formal set of clauses that actually expresses
the condition on input to SAT.
At each step, the machine is in at least one state.
Hence at least one of the K available state variables must be true. This leads to the first set of clauses,
114
At step P (n) the machine is in state qY .
one for each step i of the computation:
{Qi,1, Qi,2, . . . , Qi,K}
Since i assumes O(P (n)) values, these are O(P (n)) clauses.
At each step, the machine is not in more than one state
Therefore, for each step i, and each pair jâ€², jâ€²â€² of distinct states, the clause
{QÌ„i,jâ€², QÌ„i,jâ€²â€²}
must be true. These are O(P (n)) additonal clauses to add to the list, but still more are needed.
At each step, each tape square contains exactly one symbol from the alphabet of the machine.
This leads to two lists of clauses which require, first, that there is at least one symbol in each square at
each step, and second, that there are not two symbols in each square at each step. The clauses that do this
are
{Si,j,1, Si,j,2, . . . , Si,j,A}
where A is the number of letters in the machineâ€™s alphabet, and
{SÌ„i,j,kâ€², SÌ„i,j,kâ€²â€²}
for each step i, square j, and pair kâ€², kâ€²â€² of distinct symbols in the alphabet of the machine.
The reader will by now have gotten the idea of how to construct the clauses, so for the next three
categories we will simply list the functions that must be performed by the corresponding lists of clauses, and
leave the construction of the clauses as an exercise.
At each step, the tape head is positioned over a single square.
Initially the machine is in state 0, the head is over square 1, the input string x is in squares 1
to n, and C(x) (the input certificate of x) is in squares 0, -1, ..., âˆ’P (n).
At step P (n) the machine is in state qY .
The last set of restrictions is a little trickier:
At each step the machine moves to its next configuration (state, symbol, head position) in
accordance with the application of its program module to its previous (state, symbol).
To find the clauses that will do this job, consider first the following condition: the symbol in square j
of the tape cannot change during step i of the computation if the tape head isnâ€™t positioned there at that
moment. This translates into the collection
{Ti,j, SÌ„i,j,k, Si+1,j,k}
of clauses, one for each triple (i, j, k) = (state, square, symbol). These clauses express the condition in the
following way: either (at time i) the tape head is positioned over square j (Ti,j is true) or else the head is
not positioned there, in which case either symbol k is not in the jth square before the step or else symbol k
is (still) in the jth square after the step is executed.
It remains to express the fact that the transitions from one configuration of the machine to the next are
the direct results of the operation of the program module. The three sets of clauses that do this are
{TÌ„i,j, QÌ„i,k, SÌ„i,j,l,TÌ„i+1,j+INC}
{TÌ„i,j, QÌ„i,k, SÌ„i,j,l,Qi+1,kâ€²}
{TÌ„i,j, QÌ„i,k, SÌ„i,j,l,Si+1,j,lâ€²}.
115
Chapter 5: NP -completeness
In each case the format of the clause is this: â€˜either the tape head is not positioned at square j, or the
present state is not qk or the symbol just read is not l, but if they are then ...â€™ There is a clause as above for
each step i = 0, . . . , P (n) of the computation, for each square j = âˆ’P (n), P (n) of the tape, for each symbol
l in the alphabet, and for each possible state qk of the machine, a polynomial number of clauses in all. The
new configuration triple (INC, kâ€², lâ€²) is, of course, as computed by the program module.
Now we have constructed a set of clauses with the following property. If we execute a recognizing
computation on a string x and its certificate, in time at most P (n), then this computation determines a
set of (True, False) values for all of the variables listed above, in such a way that all of the clauses just
constructed are simultaneously satisfied.
Conversely if we have a set of values of the SAT variables that satisfy all of the clauses at once, then
that set of values of the variables describes a certificate that would cause TMQ to do a computation that
would recognize the string x and it also describes, in minute detail, the ensuing accepting computation that
TMQ would do if it were given x and that certificate.
Hence every language in NP can be reduced to SAT. It is not difficult to check through the above
construction and prove that the reduction is accomplishable in polynomial time. It follows that SAT is
NP-complete.
5.4 Some other NP-complete problems
Cookâ€™s theorem opened the way to the identification of a large number of NP-complete problems. The
proof that Satisfiability is NP-complete required a demonstration that every problem in NP is polynomially
reducible to SAT. To prove that some other problem X is NP-complete it will be sufficient to prove that
SAT reduces to problem X. For if that is so then every problem in NP can be reduced to problem X by
first reducing to an instance of SAT and then to an instance of X.
In other words, life after Cookâ€™s theorem is a lot easier. To prove that some problem is NP-complete
we need show only that SAT reduces to it. We donâ€™t have to go all the way back to the Turing machine
computations any more. Just prove that if you can solve your problem then you can solve SAT. By Cookâ€™s
theorem you will then know that by solving your problem you will have solved every problem in NP.
For the honor of being â€˜the second NP-complete problem,â€™ consider the following special case of SAT,
called 3-satisfiability, or 3SAT. An instance of 3SAT consists of a number of clauses, just as in SAT, except
that the clauses are permitted to contain no more than three literals each. The question, as in SAT, is â€˜Are
the clauses simultaneously satisfiable by some assignment of T, F values to the variables?â€™
Interestingly, though, the general problem SAT is reducible to the apparently more special problem
3SAT, which will show us
Theorem 5.4.1. 3-satisfiability is NP-complete.
Proof. Let an instance of SAT be given. We will show how to transform it quickly to an instance of 3SAT
that is satisfiable if and only if the original SAT problem was satisfiable.
More precisely, we are going to replace clauses that contain more than three literals with collections
of clauses that contain exactly three literals and that have the same satisfiability as the original. In fact,
suppose our instance of SAT contains a clause
{x1, x2, . . . , xk} (k â‰¥ 4). (5.4.1)
Then this clause will be replaced by kâˆ’ 2 new clauses, utilizing kâˆ’ 3 new variables zi (i = 1, . . . , kâˆ’ 3) that
are introduced just for this purpose. The k âˆ’ 2 new clauses are
{x1, x2, z1}, {x3, zÌ„1, z2}, {x4, zÌ„2, z3}, . . . , {xkâˆ’1, xk, zÌ„kâˆ’3}. (5.4.2)
We now make the following
Claim. If xâˆ—1, . . . , x
âˆ—
k is an assignment of truth values to the xâ€™s for which the clause (5.4.1) is true, then there
exist assignments zâˆ—1 , . . . , z
âˆ—
kâˆ’3 of truth values to the zâ€™s such that all of the clauses (5.4.2) are simultaneously
satisfied by (xâˆ—, zâˆ—). Conversely, if (xâˆ—, zâˆ—) is some assignment that satisfies all of (5.4.2), then xâˆ— alone
satisfies (5.4.1).
116
5.4 Some other NP-complete problems
To prove the claim, first suppose that (5.4.1) is satisfied by some assignment xâˆ—. Then one, at least, of
the k literals x1, . . . , xk, say xr, has the value â€˜T.â€™ Then we can satisfy all k âˆ’ 2 of the transformed clauses
(5.4.2) by assigning zâˆ—s := â€˜T â€² for s â‰¤ r âˆ’ 2 and zâˆ—s = â€˜F â€² for s > r âˆ’ 2. It is easy to check that each one of
the k âˆ’ 2 new clauses is satisfied.
Conversely, suppose that all of the new clauses are satisfied by some assignment of truth values to the
xâ€™s and the zâ€™s. We will show that at least one of the xâ€™s must be â€˜True,â€™ so that the original clause will be
satisfied.
Suppose, to the contrary, that all of the xâ€™s are false. Since, in the new clauses none of the xâ€™s are
negated, the fact that the new clauses are satisfied tells us that they would remain satisfied without any of
the xâ€™s. Hence the clauses
{z1}, {zÌ„1, z2}, {zÌ„2, z3}, . . . , {zÌ„kâˆ’4, zkâˆ’3}, {zÌ„kâˆ’3}
are satisfied by the values of the zâ€™s. If we scan the list from left to right we discover, in turn, that z1 is true,
z2 is true, . . . , and finally, much to our surprise, that zkâˆ’3 is true, and zkâˆ’3 is also false, a contradiction
which establishes the truth of the claim made above.
The observation that the transformations just discussed can be carried out in polynomial time completes
the proof of theorem 5.4.1.
We remark, in passing, that the problem â€˜2SATâ€™ is in P.
Our collection of NP-complete problems is growing. Now we have two, and a third is on the way. We
will show next how to reduce 3SAT to a graph coloring problem, thereby proving
Theorem 5.4.2. The graph vertex coloring problem is NP-complete.
Proof: Given an instance of 3SAT, that is to say, given a collection of k clauses, involving n variables and
having at most three literals per clause, we will construct, in polynomial time, a graph G with the property
that its vertices can be properly colored in n + 1 colors if and only if the given clauses are satisfiable. We
will assume that n > 4, the contrary case being trivial.
The graph G will have 3n+ k vertices:
{x1, . . . , xn}, {xÌ„1, . . . , xÌ„n}, {y1, . . . , yn}, {C1, . . . , Ck}
Now we will describe the set of edges of G. First each vertex xi is joined to xÌ„i(i = 1, . . . , n). Next, every
vertex yi is joined to every other vertex yj(j 6= i), to every other vertex xj(j 6= i), and to every vertex
xÌ„j(j 6= i).
Vertex xi is connected to Cj if xi is not one of the literals in clause Cj . Finally, xÌ„i is connected to Cj
if xÌ„i is not one of the literals in Cj.
May we interrupt the proceedings to say again why weâ€™re doing all of this? You have just read the
description of a certain graph G. The graph is one that can be drawn as soon as someone hands us a 3SAT
problem. We described the graph by listing its vertices and then listing its edges. What does the graph do
for us?
Well suppose that we have just bought a computer program that can decide if graphs are colorable in
a given number of colors. We paid $ 49.95 for it, and weâ€™d like to use it. But the first problem that needs
solving happens to be a 3SAT problem, not a graph coloring problem. We arenâ€™t so easily discouraged,
though. We convert the 3SAT problem into a graph that is (n+1)-colorable if and only if the original 3SAT
problem was satisfiable. Now we can get our moneyâ€™s worth by running the graph coloring program even
though what we really wanted to do was to solve a 3SAT problem.
117
Chapter 5: NP -completeness
In Fig. 5.4.1 we show the graph G of 11 vertices that correesponds to the following instance of 3SAT:
Fig. 5.4.1: The graph for a 3SAT problem
Now we claim that this graph is n+ 1 colorable if and only if the clauses are satisfiable.
Clearly G cannot be colored in fewer than n colors, because the n vertices y1, . . . , yn are all connected
to each other and therefore they alone already require n different colors for a proper coloration. Suppose
that yi is assigned color i (i = 1, . . . , n).
Do we need new colors in order to color the xi vertices? Since vertex yi is connected to every x vertex
and every xÌ„ vertex except xi, xÌ„i, if color i is going to be used on the xâ€™s or the xÌ„â€™s, it will have to be assigned
to one of xi, xÌ„i, but not to both, since they are connected to each other. Hence a new color, color n+ 1, will
have to be introduced in order to color the xâ€™s and xÌ„â€™s.
Further, if we are going to color the vertices of G in only n + 1 colors, the only way to do it will be
to assign color n + 1 to exactly one member of each pair (xi, xÌ„i), and color i to the other one, for each
i = 1, . . . , n. That one of the pair that gets color n+ 1 will be called the False vertex, the other one is the
True vertex of the pair (xi, xÌ„i), for each i = 1, . . . , n.
It remains to color the vertices C1, . . . , Ck. The graph will be n+1 colorable if and only if we can do this
without using any new colors. Since each clause contains at most three literals, and n > 4, every variable Ci
must be adjacent to both xj and xÌ„j for at least one value of j. Therefore no vertex Ci can be colored in the
color n+ 1 in a proper coloring of G, and therefore every Ci must be colored in one of the colors 1, . . . , n.
Since Ci is connected by an edge to every vertex xj or xÌ„j that is not in the clause Ci, it follows that Ci
cannot be colored in the same color as any xj or xÌ„j that is not in the clause Ci.
Hence the color that we assign to Ci must be the same as the color of some â€˜Trueâ€™ vertex Xj or xÌ„j that
corresponds to a literal that is in clause Ci. Therefore the graph is n + 1 colorable if and only if there is a
â€˜Trueâ€™ vertex for each Ci, and this means exactly that the clauses are satisfiable.
It is easy to verify that the transformation from the 3SAT problem to the graph coloring problem can
be carried out in polynomial time, and the proof is finished.
By means of many, often quite ingenious, transformations of the kind that we have just seen, the list of
NP-complete problems has grown rapidly since the first example, and the 21 additional problems found by
R. Karp. Hundreds of such problems are now known. Here are a few of the more important ones.
118
5.5 Half a loaf ...
Maximum clique: We are given a graph G and an integer K. The question is to determine whether or
not there is a set of K vertices in G, each of which is joined, by an edge of G, to all of the others.
Edge coloring: Given a graph G and an integer K. Can we color the edges of G in K colors, so that
whenever two edges meet at a vertex, they will have different colors?
Let us refer to an edge coloring of this kind as a proper coloring of the edges of G.
A beautiful theorem of Vizingâˆ— deals with this question. If âˆ† denotes the largest degree of any vertex
in the given graph, the Vizingâ€™s theorem asserts that the edges of G can be properly colored in either âˆ† or
âˆ† + 1 colors. Since it is obvious that at least âˆ† colors will be needed, this means that the edge chromatic
number is in doubt by only one unit, for every graph G! Nevertheless the decision as to whether the correct
answer is âˆ† or âˆ† + 1 is NP-complete.
Hamilton path: In a given graph G, is there a path that visits every vertex of G exactly once?
Target sum: Given a finite set of positive integers whose sum is S. Is there a subset whose sum is S/2?
The above list, together with SAT, 3SAT, Travelling Salesman and Graph Coloring, constitutes a modest
sampling of the class of these seemingly intractable problems. Of course it must not be assumed that every
problem that â€˜sounds likeâ€™ an NP-complete problem is necessarily so hard. If for example we ask for an Euler
path instead of a Hamilton path (i.e., if we want to traverse edges rather than vertices) the problem would
no longer be NP-complete, and in fact it would be in P, thanks to theorem 1.6.1.
As another example, the fact that one can find the edge connectivity of a given graph in polynomial
time (see section 3.8) is rather amazing considering the quite difficult appearance of the problem. One
of our motivations for including the network flow algorithms in this book was, indeed, to show how very
sophisticated algorithms can sometimes prove that seemingly hard problems are in fact computationally
tractable.
Exercises for section 5.4
1. Is the claim that we made and proved above (just after (5.4.2)) identical with the statement that the
clause (5.4.1) is satisfiable if and only if the clauses (5.4.2) are simultaneously satisfiable? Discuss.
2. Is the claim that we made and proved above (just after (5.4.2)) identical with the statement that the
Boolean expression (5.4.1) is equal to the product of the Boolean expressions (5.4.2) in the sense that their
truth values are identical on every set of inputs? Discuss.
3. Let it be desired to find out if a given graph G, of V vertices, can be vertex colored in K colors. If we
transform the problem into an instance of 3SAT, exactly how many clauses will there be?
5.5 Half a loaf ...
If we simply have to solve an NP-complete problem, then we are faced with a very long computation. Is
there anything that can be done to lighten the load? In a number of cases various kinds of probabilistic and
approximate algorithms have been developed, some very ingenious, and these may often be quite serviceable,
as we have already seen in the case of primality testing. Here are some of the strategies of â€˜nearâ€™ solutions
that have been developed.
Type I: â€˜Almost surely ...â€™
Suppose we have an NP-complete problem that asks if there is a certain kind of substructure embedded
inside a given structure. Then we may be able to develop an algorithm with the following properties:
(a) It always runs in polynomial time
(b) When it finds a solution then that solution is always a correct one
(c) It doesnâ€™t always find a solution, but it â€˜almost alwaysâ€™ does, in the sense that the ratio of successes to
total cases approaches unity as the size of the input string grows large.
An example of such an algorithm is one that will find a Hamilton path in almost all graphs, failing to
do so sometimes, but not often, and running always in polynomial time. We will describe such an algorithm
below.
âˆ— V. G. Vizing, On an estimate of the chromatic class of a p-graph (Russian), Diskret. Analiz. 3 (1964),
25-30.
119
Chapter 5: NP -completeness
Type II: â€˜Usually fast ...â€™
In this category of quasi-solution are algorithms in which the uncertainty lies not in whether a solution
will be found, but in how long it will take to find one. An algorithm of this kind will
(a) always find a solution and the solution will always be correct, and
(b) operate in an average of subexponential time, although occasionally it may require exponential time.
The averaging is over all input strings of a given size.
An example of this sort is an algorithm that will surely find a maximum independent set in a graph,
will on the average require â€˜onlyâ€™ O(nc log n) time to do so, but will occasionally, i.e., for some graphs, require
nearly 2n time to get an answer. We will outline such an algorithm below, in section 5.6. Note that O(nc logn)
is not a polynomial time estimate, but itâ€™s an improvement over 2n.
Type II: â€˜Usually fast ...â€™
In this kind of an algorithm we donâ€™t even get the right answer, but itâ€™s close. Since this means giving
up quite a bit, people like these algorithms to be very fast. Of course we are going to drop our insistence
that the questions be posed as decision problems, and instead they will be asked as optimization problems:
find the shortest tour through these cities, or, find the size of the maximum clique in this graph, or, find a
coloring of this graph in the fewest possible colors, etc.
In response these algorithms will
(a) run in polynomial time
(b) always produce some output
(c) provide a guarantee that the output will not deviate from the optimal solution by more than such-and-
such.
An example of this type is the approximate algorithm for the travelling salesman problem that is given
below, in section 5.8. It quickly yields a tour of the cities that is guaranteed to be at most twice as long as
the shortest possible tour.
Now letâ€™s look at examples of each of these kinds of approximation algorithms.
An example of an algorithm of Type I is due to Angluin and Valiant. It tries to find a Hamilton path
(or circuit) in a graph G. It doesnâ€™t always find such a path, but in theorem 5.5.1 below we will see that it
usually does, at least if the graph is from a class of graphs that are likely to have Hamilton paths at all.
Input to the algorithm are the graph G and two distinguished vertices s, t. It looks for a Hamilton path
between the vertices s, t (if s = t on input then we are looking for a Hamilton circuit in G).
The procedure maintains a partially constructed Hamilton path P , from s to some vertex ndp, and it
attempts to extend P by adjoining an edge to a new, previously unvisited vertex. In the process of doing
so it will delete from the graph G, from time to time, an edge, so we will also maintain a variable graph Gâ€²,
that is initially set to G, but which is acted upon by the program.
To do its job, the algorithm chooses at random an edge (ndp, v) that is incident with the current endpoint
of the partial path P , and it deletes the edge (ndp, v) from the graph Gâ€², so it will never be chosen again. If
v is a vertex that is not on the path P then the path is extended by adjoining the new edge (ndp, v).
So much is fairly clear. However if the new vertex v is already on the path P , then we short circuit the
path by deleting an edge from it and drawing in a new edge, as is shown below in the formal statement of
the algorithm, and in Fig. 5.5.1. In that case the path does not get longer, but it changes so that it now has
120
5.5 Half a loaf ...
enhanced chances of ultimate completion.
Fig. 5.5.1: The short circuit
Here is a formal statement of the algorithm of Angluin and Valiant for finding a Hamilton path or circuit
in an undirected graph G.
procedure uhc(G:graph; s, t: vertex);
{finds a Hamilton path (if s 6= t) or a Hamilton
circuit (if s = t) P in an undirected graph G
and returns â€˜successâ€™, or fails, and returns â€˜failureâ€™}
Gâ€² := G; ndp := s; P := empty path;
repeat
if ndp is an isolated point of Gâ€²
then return â€˜failureâ€™
else
choose uniformly at random an edge (ndp, v) from
among the edges of Gâ€² that are incident with ndp
and delete that edge from Gâ€²;
if v 6= t and v /âˆˆ P
then adjoin the edge (ndp, v) to P ; ndp := v
else
if v 6= t and v âˆˆ P
then
{This is the short-circuit of Fig. 5.5.1}
u := neighbor of v in P that is closer to ndp;
delete edge (u, v) from P ;
adjoin edge (ndp, v) to P ;
ndp := u
end; {then}
end {else}
until P contains every vertex of G (except T , if
s 6= t) and edge (ndp, t) is in G but not in Gâ€²;
adjoin edge (ndp, t) to P and return â€˜successâ€™
end. {uhc}
As stated above, the algorithm makes only a very modest claim: either it succeeds or it fails! Of course
what makes it valuable is the accompanying theorem, which asserts that in fact the procedure almost always
succeeds, provided the graph G has a good chance of having a Hamilton path or circuit.
121
Chapter 5: NP -completeness
What kind of graph has such a â€˜good chanceâ€™? A great deal of research has gone into the study of how
many edges a graph has to have before almost surely it must contain certain given structures. For instance,
how many edges must a graph of n vertices have before we can be almost certain that it will contain a
complete graph of 4 vertices?
To say that graphs have a property â€˜almost certainlyâ€™ is to say that the ratio of the number of graphs
on n vertices that have the property to the number of graphs on n vertices approaches 1 as n grows without
bound.
For the Hamilton path problem, an important dividing line, or threshold, turns out to be at the level
of c logn edges. That is to say, a graph of n vertices that has o(n logn) edges has relatively little chance
of being even connected, whereas a graph with > cn logn edges is almost certainly connected, and almost
certainly has a Hamilton path.
We now state the theorem of Angluin and Valiant, which asserts that the algorithm above will almost
surely succeed if the graph G has enough edges.
Theorem 5.5.1. Fix a positive real number a. There exist numbers M and c such that if we choose a graph
G at random from among those of n vertices and at least cn logn edges, and we choose arbitrary vertices s, t
in G, then the probability that algorithm UHC returns â€˜successâ€™ before making a total of Mn logn attempts
to extend partially constructed paths is 1 âˆ’O(nâˆ’a).
5.6 Backtracking (I): independent sets
In this section we are going to describe an algorithm that is capable of solving some NP-complete
problems fast, on the average, while at the same time guaranteeing that a solution will always be found, be
it quickly or slowly.
The method is called backtracking, and it has long been a standard method in computer search problems
when all else fails. It has been common to think of backtracking as a very long process, and indeed it can be.
But recently it has been shown that the method can be very fast on average, and that in the graph coloring
problem, for instance, it functions in an average of constant time, i.e.,the time is independent of the number
of vertices, although to be sure, the worst-case behavior is very exponential.
We first illustrate the backtrack method in the context of a search for the largest independent set of
vertices (a set of vertices no two of which are joined by an edge) in a given graph G, an NP-complete
problem. In this case the average time behavior of the method is not constant, or even polynomial, but is
subexponential. The method is also easy to analyze and to describe in this case.
Hence consider a graph G of n vertices, in which the vertices have been numbered 1, 2, . . . , n. We want
to find, in G, the size of the largest independent set of vertices. In Fig. 5.6.1 below, the graph G has 6
vertices.
Fig. 5.6.1: Find the largest independent set
Begin by searching for an independent set S that contains vertex 1, so let S := {1}. Now attempt to
enlarge S. We cannot enlarge S by adjoining vertex 2 to it, but we can add vertex 3. Our set S is now
{1, 3}.
Now we cannot adjoin vertex 4 (joined to 1) or vertex 5 (joined to 1) or vertex 6 (joined to 3), so we are
stuck. Therefore we backtrack, by replacing the most recently added member of S by the next choice that
we might have made for it. In this case, we delete vertex 3 from S, and the next choice would be vertex 6.
The set S is {1, 6}. Again we have a dead end.
If we backtrack again, there are no further choices with which to replace vertex 6, so we backtrack even
further, and not only delete 6 from S but also replace vertex 1 by the next possible choice for it, namely
vertex 2.
122
5.6 Backtracking (I): independent sets
To speed up the discussion, we will now show the list of all sets S that turn up from start to finish of
the algorithm:
{1}, {13}, {16},{2}, {24},{245},{25}, {3},
{34}, {345}, {35}, {4},{45}, {5},{6}
A convenient way to represent the search process is by means of the backtrack search tree T . This is
a tree whose vertices are arranged on levels L := 0, 1, 2, . . ., n for a graph of n vertices. Each vertex of T
corresponds to an independent set of vertices in G. Two vertices of T , corresponding to independent sets
Sâ€², Sâ€²â€² of vertices of G, are joined by an edge in T if Sâ€² âŠ† Sâ€²â€², and Sâ€²â€² âˆ’ Sâ€² consists of a single element: the
highest-numbered vertex in Sâ€²â€². On level L we find a vertex S of T for every independent set of exactly L
vertices of G. Level 0 consists of a single root vertex, corresponding to the empty set of vertices of G.
The complete backtrack search tree for the problem of finding a maximum independent set in the graph
G of Fig. 5.6.1 is shown in Fig. 5.6.2 below.
Fig. 5.6.2: The backtrack search tree
The backtrack algorithm amounts just to visiting every vertex of the search tree T , without actually
having to write down the tree explicitly, in advance.
Observe that the list of sets S above, or equivalently, the list of nodes of the tree T , consists of exactly
every independent set in the graph G. A reasonable measure of the complexity of the searching job, therefore,
is the number of independent sets that G has. In the example above, the graph G had 19 independent sets
of vertices, including the empty set.
The question of the complexity of backtrack search is therefore the same as the question of determining
the number of independent sets of the graph G.
Some graphs have an enormous number of independent sets. The graph Kn of n vertices and no edges
whatever has 2n independent sets of vertices. The backtrack tree will have 2n nodes, and the search will be
a long one indeed.
The complete graphKn of n vertices and every possible edge, n(nâˆ’1)/2 in all, has just n+1 independent
sets of vertices.
Any other graph G of n vertices will have a number of independent sets that lies between these two
extremes of n + 1 and 2n. Sometimes backtracking will take an exponentially long time, and sometimes it
will be fairly quick. Now the question is, on the average how fast is the backtrack method for this problem?
What we are asking for is the average number of independent sets that a graph of n vertices has. But
that is the sum, over all vertex subsets S âŠ† {1, . . . , n}, of the probability that S is an independent set. If
S has k vertices, then the probability that S is independent is the probability that, among the k(k âˆ’ 1)/2
possible edges that might join a pair of vertices in S, exactly zero of these edges actually live in the random
graph G. Since each of these
(
k
2
)
edges has a probability 1/2 of appearing in G, the probability that none of
them appear is 2âˆ’k(kâˆ’1)/2. Hence the average number of independent sets in a graph of n vertices is
In =
nâˆ‘
k=0
(
n
k
)
2âˆ’k(kâˆ’1)/2. (5.6.1)
123
Chapter 5: NP -completeness
Hence in (5.6.1) we have an exact formula for the average number of independent sets in a graph of n
vertices. A short table of values of In is shown below, in Table 5.6.1, along with values of 2n, for comparison.
Clearly the average number of independent sets in a graph is a lot smaller than the maximum number that
graphs of that size might have.
n In 2n
2 3.5 4
3 5.6 8
4 8.5 16
5 12.3 32
10 52 1024
15 149.8 32768
20 350.6 1048576
30 1342.5 1073741824
40 3862.9 1099511627776
Table 5.6.1: Independent sets and all sets
In the exercises it will be seen that the rate of growth of In as n grows large is O(nlog n). Hence the
average amount of labor in a backtrack search for the largest independent set in a graph grows subexponen-
tially, although faster than polynomially. It is some indication of how hard this problem is that even on the
average the amount of labor needed is not of polynomial growth.
Exercises for section 5.6
1. What is the average number of independent sets of size k that are in graphs of V vertices and E edges?
2. Let tk denote the kth term in the sum (5.6.1).
(a) Show that tk/tkâˆ’1 = (nâˆ’ k + 1)/(k2k+1).
(b) Show that tk/tkâˆ’1 is > 1 when k is small, then is < 1 after k passes a certain critical value k0. Hence
show that the terms in the sum (5.6.1) increase in size until k = k0 and then decrease.
3. Now we will estimate the size of k0 in the previous problem.
(a) Show that tk < 1 when k = blog2 nc and tk > 1 when k = blog2 nâˆ’ log2 log2 nc. Hence the index k0 of
the largest term in (5.6.1) satisfies
blog2 nâˆ’ log2 log2 nc â‰¤ k0 â‰¤ blog2 nc
(b) The entire sum in (5.6.1) is at most n+1 times as large as its largest single term. Use Stirlingâ€™s formula
(1.1.10) and 3(a) above to show that the k0th term is O((n+ )log n) and therefore the same is true of
the whole sum, i.e., of In.
5.7 Backtracking (II): graph coloring
In another NP-complete problem, that of graph-coloring, the average amount of labor in a backtrack
search is O(1) (bounded) as n, the number of vertices in the graph, grows without bound. More precisely,
for fixed K, if we ask â€˜Is the graph G, of V vertices, properly vertex-colorable in K colors?,â€™ then the average
labor in a backtrack search for the answer is bounded. Hence not only is the average of polynomial growth,
but the polynomial is of degree 0 (in V ).
To be even more specific, consider the case of 3 colors. It is already NP-complete to ask if the vertices of
a given graph can be colored in 3 colors. Nevertheless, the average number of nodes in the backtrack search
tree for this problem is about 197, averaged over all graphs of all sizes. This means that if we input a random
graph of 1,000,000 vertices, and ask if it is 3-colorable, then we can expect an answer (probably â€˜Noâ€™) after
only about 197 steps of computation.
To prove this we will need some preliminary lemmas.
124
5.7 Backtracking (II): graph coloring
Lemma 5.7.1. Let s1, . . . , sK be nonnegative numbers whose sum is L. Then the sum of their squares is
at least L2/K.
Proof: We have
0 â‰¤
Kâˆ‘
i=1
(si âˆ’
L
K
)2
=
Kâˆ‘
i=1
(s2i âˆ’ 2
Lsi
K
+
L2
K2
)
=
Kâˆ‘
i=1
s2i âˆ’ 2
L2
K
+
L2
K
=
Kâˆ‘
i=1
s2i âˆ’
L2
K
.
The next lemma deals with a kind of inside-out chromatic polynomial question. Instead of asking â€˜How
many proper colorings can a given graph have?,â€™ we ask â€˜How many graphs can have a given proper coloring?â€™
Lemma 5.7.2. Let C be one of the KL possible ways to color in K colors a set of L abstract vertices
1, 2, . . . , L. Then the number of graphs G whose vertex set is that set of L colored vertices and for which C
is a proper coloring of G is at most 2L
2(1âˆ’1/K)/2.
Proof: In the coloring C , suppose s1 vertices get color 1, . . . , sK get colorK, where, of course, s1+Â· Â· Â·+sK =
L. If a graph G is to admit C as a proper vertex coloring then its edges can be drawn only between vertices
of different colors. The number of edges that G might have is therefore
s1s2 + s1s3 + Â· Â· Â·+ s1sK + s2s3 + Â· Â· Â·+ s2sK + Â· Â· Â·+ sKâˆ’1sK
for which we have the following estimate:
âˆ‘
1â‰¤i<jâ‰¤K
sisj =
1
2
âˆ‘
i6=j
sisj
=
1
2
{ Kâˆ‘
i,j=1
sisj âˆ’
Kâˆ‘
i=1
s2i
}
=
1
2
(
âˆ‘
si)2 âˆ’
1
2
âˆ‘
s2i
â‰¤ L
2
2
âˆ’ 1
2
L2
K
(by lemma 5.7.1)
=
L2
2
(1 âˆ’ 1
K
).
(5.7.1)
The number of possible graphs G is therefore at most 2L
2(1âˆ’1/K)/2.
Lemma 5.7.3. The total number of proper colorings in K colors of all graphs of L vertices is at most
KL2L
2(1âˆ’1/K)/2.
Proof: We are counting the pairs (G, C), where the graph G has L vertices and C is a proper coloring of
G. If we keep C fixed and sum on G, then by lemma 5.7.2 the sum is at most 2L2(1âˆ’1/K)/2. Since there are
KL such C â€™s, the proof is finished.
Now letâ€™s think about a backtrack search for a K-coloring of a graph. Begin by using color 1 on vertex
1. Then use color 1 on vertex 2 unless (1, 2) is an edge, in which case use color 2. As the coloring progresses
through vertices 1, 2, . . . , L we color each new vertex with the lowest available color number that does not
cause a conflict with some vertex that has previously been colored.
125
Chapter 5: NP -completeness
At some stage we may reach a dead end: out of colors, but not out of vertices to color. In the graph of
Fig. 5.7.1 if we try to 2-color the vertices we can color vertex 1 in color 1, vertex 2 in color 2, vertex 3 in
color 1 and then weâ€™d be stuck because neither color would work on vertex 4.
Fig. 5.7.1: Color this graph
When a dead end is reached, back up to the most recently colored vertex for which other color choices
are available, replace its color with the next available choice, and try again to push forward to the next
vertex.
The (futile) attempt to color the graph in Fig. 5.7.1 with 2 colors by the backtrack method can be
portrayed by the backtrack search tree in Fig. 5.7.2.
The search is thought of as beginning at â€˜Root.â€™ The label at each node of the tree describes the
colors of the vertices that have so far been colored. Thus â€˜212â€™ means that vertices 1,2,3 have been colored,
respectively, in colors 2,1,2.
Fig. 5.7.2: A frustrated search tree
Fig. 5.7.3: A happy search tree
126
5.7 Backtracking (II): graph coloring
If instead we use 3 colors on the graph of Fig. 5.7.1 then we get a successful coloring; in fact we get 12
of them, as is shown in Fig. 5.7.3.
Letâ€™s concentrate on a particular level of the search tree. Level 2, for instance, consists of the nodes of
the search tree that are at a distance 2 from â€˜Root.â€™ In Fig. 5.7.3, level 2 contains 6 nodes, correspoonding
to the partial colorings 12, 13, 21, 23, 31, 32 of the graph. When the coloring reaches vertex 2 it has seen
only the portion of the graph G that is induced by vertices 1 and 2.
Generally, a node at level L of the backtrack search tree corresponds to a proper coloring in K colors
of the subgraph of G that is induced by vertices 1, 2, . . . , L.
Let HL(G) denote that subgraph. Then we see the truth of
Lemma 5.7.4. The number of nodes at level L of the backtrack search tree for coloring a graph G in K
colors is equal to the number of proper colorings of HL(G) in K colors, i.e., to P (K,HL(G)), where P is the
chromatic polynomial.
We are now ready for the main question of this section: what is the average number of nodes in a
backtrack search tree for K-coloring graphs of n vertices? This is
A(n,K) =
1
no. of graphs
âˆ‘
graphs Gn
{no. of nodes in tree for G}
= 2âˆ’(
n
2)
âˆ‘
Gn
{
nâˆ‘
L=0
{no. of nodes at level L}}
= 2âˆ’(
n
2)
âˆ‘
Gn
nâˆ‘
L=0
P (K,HL(G)) (by lemma 5.7.4)
= 2âˆ’(
n
2)
nâˆ‘
L=0
{
âˆ‘
Gn
P (K,HL(G))}.
Fix some value of L and consider the inner sum. As G runs over all graphs of N vertices, HL(G) selects
the subgraph of G that is induced by vertices 1, 2, . . ., L. Now lots of graphs G of n vertices have the same
HL(G) sitting at vertices 1, 2, . . . , L. In fact exactly 2(
n
2)âˆ’(L2) different graphs G of n vertices all have the
same graph H of L vertices in residence at vertices 1, 2, . . ., L (see exercise 15 of section 1.6). Hence (5.7.2)
gives
A(n,K) = 2âˆ’(
n
2)
nâˆ‘
L=0
2(
n
2)âˆ’(L2){âˆ‘
HL
P (K,H)
}
=
nâˆ‘
L=0
2âˆ’(
L
2){âˆ‘
HL
P (K,H)
}
.
The inner sum is exactly the number that is counted by lemma 5.7.3, and so
A(n,K) â‰¤
nâˆ‘
L=0
2âˆ’(
L
2)KL2L
2(1âˆ’1/K)/2
â‰¤
âˆžâˆ‘
L=0
KL2L/22âˆ’L
2/2K .
The infinite series actually converges! Hence A(n, k) is bounded, for all n. This proves
Theorem 5.7.1. Let A(n, k) denote the average number of nodes in the backtrack search trees for K-
coloring the vertices of all graphs of n vertices. Then there is a constant h = h(K), that depends on the
number of colors, K, but not on n, such that A(n, k) â‰¤ h(K) for all n.
127
Chapter 5: NP -completeness
5.8 Approximate algorithms for hard problems
Finally we come to Type III of the three kinds of â€˜half-a-loaf-is-better-than-noneâ€™ algorithms that were
described in section 5.5. In these algorithms we donâ€™t find the exact solution of the problem, only an
approximate one. As consolation we have an algorithm that runs in polynomial time as well as a performance
guarantee to the effect that while the answer is approximate, it can certainly deviate by no more than such-
and-such from the exact answer.
An elegant example of such a situation is in the Travelling Salesman Problem, which we will now express
as an optimization problem rather than as a decision problem.
We are given n points (â€˜citiesâ€™) in the plane, as well as the distances between every pair of them, and we
are asked to find a round-trip tour of all of these cities that has minimum length. We will assume throughout
the following discussion that the distances satisfy the triangle inequality. This restriction of the TSP is often
called the â€˜Euclideanâ€™ Travelling Salesman Problem.
The algorithm that we will discuss for this problem has the properties
(a) it runs in polynomial time and
(b) the round-trip tour that it finds will never be more than twice as long as the shortest possible tour.
The first step in carrying out the algorithm is to find a minimum spanning tree (MST) for the n given
cities. A MST is a tree whose nodes are the cities in question, and which, among all possible trees on that
vertex set, has minimum possible length.
It may seem that finding a MST is just as hard as solving the TSP, but NIN (No, Itâ€™s Not). The MST
problem is one of those all-too-rare computational situations in which it pays to be greedy.
Generally speaking, in a greedy algorithm,
(i) we are trying to construct some optimal structure by adding one piece at a time, and
(ii) at each step we make the decision about which piece will be added next by choosing, among all
available pieces, the single one that will carry us as far as possible in the desirable direction (be
greedy!).
The reason that greedy algorithms are not usually the best possible ones is that it may be better not
to take the single best piece at each step, but to take some other piece, in the hope that at a later step we
will be able to improve things even more. In other words, the global problem of finding the best structure
might not be solveable by the local procedure of being as greedy as possible at each step.
In the MST problem, though, the greedy strategy works, as we see in the following algorithm.
procedure mst(x :array of n points in the plane);
{constructs a spanning tree T of minimum length, on the
vertices {x1, . . . , xn} in the plane}
let T consist of a single vertex x1;
while T has fewer than n vertices do
for each vertex v that is not yet in T , find the
distance d(v) from v to the nearest vertex of T ;
let vâˆ— be a vertex of smallest d(v);
adjoin vâˆ— to the vertex set of T ;
adjoin to T the edge from vâˆ— to the nearest
vertex w 6= vâˆ— of T ;
end{while}
end.{mst}
Proof of correctness of mst: Let T be the tree that is produced by running mst, and let e1, . . . , enâˆ’1 be
its edges, listed in the same order in which the alfgorithm mst produced them.
Let T â€² be a minimum spanning tree for x. Let er be the first edge of T that does not appear in T â€². In
the minimum tree T â€², edges e1, . . . , erâˆ’1 all appear, and we let S be the union of their vertex sets. In T â€² let
f be the edge that joins the subtree on S to the subtree on the remaining vertices of x.
Suppose f is shorter than er. Then f was one of the edges that was available to the algorithm mst
at the instant that it chose er , and since er was the shortest edge available at that moment, we have a
contradiction.
128
5.7 Backtracking (II): graph coloring
Suppose f is longer than er . Then T â€² would not be minimal because the tree that we would obtain by
exchanging f for er in T â€² ( why is it still a tree if we do that exchange?) would be shorter, contradicting the
minimality of T â€².
Hence f and er have the same length. In T â€² exchange f for er. Then T â€² is still a tree, and is still a
minimum spanning tree.
The index of the first edge of T that does not appear in T â€² is now at least r + 1, one unit larger than
before. The process of replacing edges of T that do not appear in T â€² without affecting the minimality of T
can be repeated until every edge of T appears in T â€², i.e., until T = T â€². Hence T was a minimum spanning
tree.
That finishes one step of the process that leads to a polynomial time travelling salesman algorithm that
finds a tour of at most twice the minimum length.
The next step involves finding an Euler circuit. Way back in theorem 1.6.1 we learned that a connected
graph has an Euler circuit if and only if every vertex has even degree. Recall that the proof was recursive
in nature, and immediately implies a linear time algorithm for finding Euler circuits recursively. We also
noted that the proof remains valid even if we are dealing with a multigraph, that is, with a graph in which
several edges are permitted between single pairs of vertices. We will in fact need that extra flexibility for
the purpose at hand.
Now we have the ingredients for a quick near-optimal travelling salesman tour.
Theorem 5.8.1. There is an algorithm that operates in polynomial time and which will return a travelling
salesman tour whose length is at most twice the length of a minimum tour.
Here is the algorithm. Given the n cities in the plane:
(1) Find a minimum spanning tree T for the cities.
(2) Double each edge of the tree, thereby obtaining a â€˜multitreeâ€™ T (2) in which between each pair of
vertices there are 0 or 2 edges.
(3) Since every vertex of the doubled tree has even degree, there is an Eulerian tour W of the edges of
T (2); find one, as in the proof of theorem 1.6.1.
(4) Now we construct the output tour of the cities. Begin at some city and follow the walk W . However,
having arrived at some vertex v, go from v directly (via a straight line) to the next vertex of the walk
W that you havenâ€™t visited yet. This means that you will often short-circuit portions of the walk W
by going directly from some vertex to another one that is several edges â€˜down the road.â€™
The tour Zâ€² that results from (4) above is indeed a tour of all of the cities in which each city is visited
once and only once. We claim that its length is at most twice optimal.
Let Z be an optimum tour, and let e be some edge of Z. Then Z âˆ’ e is a path that visits all of the
cities. Since a path is a tree, Z âˆ’ e is a spanning tree of the cities, hence Z âˆ’ e is at least as long as T is,
and so Z is surely at least as long as T is.
Next consider the length of the tour Zâ€². A step of Zâ€² that walks along an edge of the walk W has length
equal to the length of that edge of W . A step of Zâ€² that short circuits several edges of W has length at most
equal to the sum of the lengths of the edges of W that were short-circuited. If we sum these inequalities
over all steps of Zâ€² we find that the length of Zâ€² is at most equal to the length of W , which is in turn twice
the length of the tree T .
If we put all of this together we find that
length(Z) > length(Z âˆ’ e) â‰¥ length(T ) = 1
2
length(W ) â‰¥ 1
2
length(Zâ€²)
as claimed (!)
More recently it has been proved (Cristofides, 1976) that in polynomial time we can find a TSP tour
whose total length is at most 3/2 as long as the minimum tour. The algorithm makes use of Edmondsâ€™s
algorithm for maximum matching in a general graph (see the reference at the end of Chapter 3). It will be
interesting to see if the factor 3/2 can be further refined.
Polynomial time algorithms are known for other NP-complete problems that guarantee that the answer
obtained will not exceed, by more than a constant factor, the optimum answer. In some cases the guarantees
apply to the difference between the answer that the algorithm gives and the best one. See the references
below for more information.
129
Chapter 5: NP -completeness
Exercises for section 5.8
1. Consider the following algorithm:
procedure mst2(x :array of n points in the plane);
{allegedly finds a tree of minimum total length that
visits every one of the given points}
if n = 1
then T := {x1}
else
T := mst2(n âˆ’ 1,xâˆ’xn);
let u be the vertex of T that is nearest to xn;
mst2:=T plus vertex xn plus edge (xn, u)
end.{mst2}
Is this algorithm a correct recursive formulation of the minimum spanning tree greedy algorithm? If so then
prove it, and if not then give an example of a set of points where mst2 gets the wrong answer.
Bibliography
Before we list some books and journal articles it should be mentioned that research in the area of
NP-completeness is moving rapidly, and the state of the art is changing all the time. Readers who would
like updates on the subject are referred to a series of articles that have appeared in issues of the Journal
of Algorithms in recent years. These are called â€˜NP-completeness: An ongoing guide.â€™ They are written
by David S. Johnson, and each of them is a thorough survey of recent progress in one particular area of
NP-completeness research. They are written as updates of the first reference below.
Journals that contain a good deal of research on the areas of this chapter include the Journal of Algo-
rithms, the Journal of the Association for Computing Machinery, the SIAM Journal of Computing, Infor-
mation Processing Letters, and SIAM Journal of Discrete Mathematics.
The most complete reference on NP-completeness is
M. Garey and D. S. Johnson, Computers and Intractability; A guide to the theory of NP-completeness, W.
H. Freeman and Co., San Francisco, 1979.
The above is highly recommended. It is readable, careful and complete.
The earliest ideas on the computational intractability of certain problems go back to
Alan Turing, On computable numbers, with an application to the Entscheidungsproblem, Proc. London
Math. Soc., Ser. 2, 42 (1936), 230-265.
Cookâ€™s theorem, which originated the subject of NP-completeness, is in
S. A. Cook, The complexity of theorem proving procedures, Proc., Third Annual ACM Symposium on the
Theory of Computing, ACM, New York, 1971, 151-158.
After Cookâ€™s work was done, a large number of NP-complete problems were found by
Richard M. Karp, Reducibility among combinatorial problems, in R. E. Miller and J. W. Thatcher, eds.,
Complexity of Computer Computations, Plenum, New York, 1972, 85-103.
The above paper is recommended both for its content and its clarity of presentation.
The approximate algorithm for the travelling salesman problem is in
D. J. Rosencrantz, R. E. Stearns and P. M. Lewis, An analysis of several heuristics for the travelling salesman
problem, SIAM J. Comp. 6, 1977, 563-581.
Another approximate algorithm for the Euclidean TSP which guarantees that the solution found is no more
than 3/2 as long as the optimum tour, was found by
N. Cristofides, Worst case analysis of a new heuristic for the travelling salesman problem, Technical Report,
Graduate School of Industrial Administration, Carnegie-Mellon University, Pittsburgh, 1976.
The minimum spanning tree algorithm is due to
R. C. Prim, Shortest connection netwroks and some generalizations, Bell System Tech. J. 36 (1957), 1389-
1401.
The probabilistic algorithm for the Hamilton path problem can be found in
130
5.7 Backtracking (II): graph coloring
D. Angluin and L. G. Valiant, Fast probabilistic algorithms for Hamilton circuits and matchings, Proc. Ninth
Annual ACM Symposium on the Theory of Computing, ACM, New York, 1977.
The result that the graph coloring problem can be done in constant average time is due to
H. Wilf, Backtrack: An O(1) average time algorithm for the graph coloring problem, Information Processing
Letters 18 (1984), 119-122.
Further refinements of the above result can be found in
E. Bender and H. S. Wilf, A theoretical analysis of backtracking in the graph coloring problem, Journal of
Algorithms 6 (1985), 275-282.
If you enjoyed the average numbers of independent sets and average complexity of backtrack, you might
enjoy the subject of random graphs. An excellent introduction to the subject is
Edgar M. Palmer, Graphical Evolution, An introduction to the theory of random graphs, Wiley-Interscience,
New York, 1985.
131
Index
Index
adjacent 40
Adleman, L. 149, 164, 165, 176
Aho, A. V. 103
Angluin, D. 208-211, 227
Appel, K. 69
average complexity 57, 211ff.
backtracking 211ff.
Bender, E. 227
Bentley, J. 54
Berger, R. 3
big oh 9
binary system 19
bin-packing 178
binomial theorem 37
bipartite graph 44, 182
binomial coefficients 35
â€”, growth of 38
blocking flow 124
Burnsideâ€™s lemma 46
cardinality 35
canonical factorization 138
capacity of a cut 115
Carmichael numbers 158
certificate 171, 182, 193
Cherkassky, B. V. 135
Chinese remainder theorem 154
chromatic number 44
chromatic polynomial 73
Cohen, H. 176
coloring graphs 43
complement of a graph 44
complexity 1
â€”, worst-case 4
connected 41
Cook, S. 187, 194-201, 226
Cookâ€™s theorem 195ff.
Cooley, J. M. 103
Coppersmith, D. 99
cryptography 165
Cristofides, N. 224, 227
cut in a network 115
â€”, capacity of 115
cycle 41
cyclic group 152
decimal system 19
decision problem 181
degree of a vertex 40
deterministic 193
Diffie, W. 176
digraph 105
Dinic, E. 108, 134
divide 137
Dixon, J. D. 170, 175, 177
domino problem 3
â€˜easyâ€™ computation 1
edge coloring 206
edge connectivity 132
132
Index
Edmonds, J. 107, 134, 224
Enslein, K. 103
Euclidean algorithm 140, 168
â€”, complexity 142
â€”, extended 144ff.
Euler totient function 138, 157
Eulerian circuit 41
Even, S. 135
exponential growth 13
factor base 169
Fermatâ€™s theorem 152, 159
FFT, complexity of 93
â€”, applications of 95 ff.
Fibonacci numbers 30, 76, 144
flow 106
â€”, value of 106
â€”, augmentation 109
â€”, blocking 124
flow augmenting path 109
Ford-Fulkerson algorithm 108ff.
Ford, L. 107ff.
four-color theorem 68
Fourier transform 83ff.
â€”, discrete 83
â€”, inverse 96
Fulkerson, D. E. 107ff.
Galil, Z. 135
Gardner, M. 2
Garey, M. 188
geometric series 23
Gomory, R. E. 136
graphs 40ff.
â€”, coloring of 43, 183, 216ff.
â€”, connected 41
â€”, complement of 44
â€”, complete 44
â€”, empty 44
â€”, bipartite 44
â€”, planar 70
greatest common divisor 138
group of units 151
Haken, W. 69
Hamiltonian circuit 41, 206, 208ff.
Hardy, G. H. 175
height of network 125
Hellman, M. E. 176
hexadecimal system 21
hierarchy of growth 11
Hoare, C. A. R. 51
Hopcroft, J. 70, 103
Hu, T. C. 136
independent set 61, 179, 211ff.
intractable 5
Johnson, D. S. 188, 225, 226
Karp, R. 107, 134, 205, 226
Karzanov, A. 134
Knuth, D. E. 102
KoÌˆnig, H. 103
133
Index
k-subset 35
language 182
Lawler, E. 99
layered network 120ff.
Lenstra, H. W., Jr. 176
LeVeque, W. J. 175
Lewis, P. A. W. 103
Lewis, P. M. 227
Lâ€™Hospitalâ€™s rule 12
little oh 8
Lomuto, N. 54
Maheshwari, S. N. 108ff. , 135
Malhotra, V. M. 108ff. , 135
matrix multiplication 77ff.
max-flow-min-cut 115
maximum matching 130
minimum spanning tree 221
moderately exponential growth 12
MPM algorithm 108, 128ff.
MST 221
multigraph 42
network 105
â€” flow 105ff.
â€”, dense 107
â€”, layered 108, 120ff.
â€”, height of 125
Nijenhuis, A. 60
nondeterministic 193
NP 182
NP-complete 61, 180
NP-completeness 178ff.
octal system 21
optimization problem 181
orders of magnitude 6ff.
P 182
Palmer, E. M. 228
Pan, V. 103
Pascalâ€™s triangle 36
path 41
periodic function 87
polynomial time 2, 179, 185
polynomials, multiplication of 96
Pomerance, C. 149, 164, 176
positional number systems 19ff.
Pramodh-Kumar, M. 108ff. , 135
Pratt, V. 171, 172
Prim, R. C. 227
primality, testing 6, 148ff. , 186
â€”, proving 170
prime number 5
primitive root 152
pseudoprimality test 149, 156ff.
â€”, strong 158
public key encryption 150, 165
Quicksort 50ff.
Rabin, M. O. 149, 162, 175
Ralston, A. 103
134
Index
recurrence relations 26ff.
recurrent inequality 31
recursive algorithms 48ff.
reducibility 185
relatively prime 138
ring Zn 151ff.
Rivest, R. 165, 176
roots of unity 86
Rosenkrantz, D. 227
RSA system 165, 168
Rumely, R. 149, 164, 176
Runge, C. 103
SAT 195
satisfiability 187, 195
scanned vertex 111
SchoÌˆnhage, A. 103
Selfridge, J. 176
Shamir, A. 165, 176
slowsort 50
Solovay, R. 149, 162, 176
splitter 52
Stearns, R. E. 227
Stirlingâ€™s formula 16, 216
Strassen, V. 78, 103, 149, 162, 176
synthetic division 86
3SAT 201
target sum 206
Tarjan, R. E. 66, 70, 103, 135
Î˜ (â€˜Theta ofâ€™) 10
tiling 2
tractable 5
travelling salesman problem 178, 184, 221
tree 45
Trojanowski, A. 66, 103
â€˜TSPâ€™ 178, 221
Tukey, J. W. 103
Turing, A. 226
Turing machine 187ff.
Ullman, J. D. 103
usable edge 111
Valiant, L. 208-11, 227
vertices 40
Vizing, V. 206
Wagstaff, S. 176
Welch, P. D. 103
Wilf, H. 60, 103, 227, 228
Winograd, S. 99
worst-case 4, 180
Wright, E. M. 175
135

