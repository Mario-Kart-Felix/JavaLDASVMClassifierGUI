 
 
 
 
 
Edinburgh Research Explorer 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Handlers of Algebraic Effects
Citation for published version:
Plotkin, G & Pretnar, M 2009, Handlers of Algebraic Effects. in G Castagna (ed.), Programming Languages
and Systems: 18th European Symposium on Programming, ESOP 2009, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2009, York, UK, March 22-29, 2009.
Proceedings. Lecture Notes in Computer Science, vol. 5502, Springer-Verlag GmbH, pp. 80-94. DOI:
10.1007/978-3-642-00590-9_7
Digital Object Identifier (DOI):
10.1007/978-3-642-00590-9_7
Link:
Link to publication record in Edinburgh Research Explorer
Document Version:
Peer reviewed version
Published In:
Programming Languages and Systems
General rights
Copyright for the publications made accessible via the Edinburgh Research Explorer is retained by the author(s)
and / or other copyright owners and it is a condition of accessing these publications that users recognise and
abide by the legal requirements associated with these rights.
Take down policy
The University of Edinburgh has made every reasonable effort to ensure that Edinburgh Research Explorer
content complies with UK legislation. If you believe that the public display of this file breaches copyright please
contact openaccess@ed.ac.uk providing details, and we will remove access to the work immediately and
investigate your claim.
Download date: 29. Jun. 2017
Handlers of Algebraic Effects
Gordon Plotkin ? and Matija Pretnar ??
Laboratory for Foundations of Computer Science,
School of Informatics, University of Edinburgh, Scotland
Abstract. We present an algebraic treatment of exception handlers and,
more generally, introduce handlers for other computational effects repre-
sentable by an algebraic theory. These include nondeterminism, interac-
tive input/output, concurrency, state, time, and their combinations; in
all cases the computation monad is the free-model monad of the theory.
Each such handler corresponds to a model of the theory for the effects
at hand. The handling construct, which applies a handler to a compu-
tation, is based on the one introduced by Benton and Kennedy, and is
interpreted using the homomorphism induced by the universal property
of the free model. This general construct can be used to describe previ-
ously unrelated concepts from both theory and practice.
1 Introduction
In seminal work, Moggi proposed a uniform representation of computational ef-
fects by monads [1â€“3]. The computations that return values from a set X are
represented by elements of TX, for a suitable monad T . Examples include excep-
tions, nondeterminism, interactive input/output, concurrency, state, time, con-
tinuations, and combinations thereof. Plotkin and Power later proposed to focus
on algebraic effects, that is effects that allow a representation by operations and
equations [4â€“6]; the operations give rise to the effects at hand. All of the effects
mentioned above are algebraic, with the notable exception of continuations [7],
which have to be treated differently (see [8] for initial ideas).
In the algebraic approach the arguments of an operation represent possible
computations after an occurrence of an effect. For example, using a binary choice
operation or :2, a nondeterministically chosen boolean is represented by the term
or(return true, return false) :Fbool, where FÏƒ stands for the type of computations
that return values of type Ïƒ. The equations of the theory, for example the ones
stating that or is a semi-lattice operation, generate the free-model functor, which
is exactly the monad proposed by Moggi to model the corresponding effect [9]
(modulo the forgetful functor) and which is used to interpret the type FÏƒ. The
operations are then interpreted by the model structure. When viewed as a fam-
ily of functions parametric in X, e.g., orX : TX2 â†’ TX, one obtains a so-called
? Supported by EPSRC grant GR/586371/01 and a Royal Society-Wolfson Award
Fellowship.
?? Supported by EPSRC grant GR/586371/01.
algebraic operation; such families are characterised by a certain naturality con-
dition [5].
Although this gives a way of constructing, combining [10], and reasoning [11]
about algebraic effects, it does not account for their handling, as exception han-
dlers, a well-known programming concept, fail to be algebraic operations [5].
Conceptually, algebraic operations and effect handlers are dual: the former could
be called effect constructors as they give rise to the effects; the latter could be
called effect deconstructors as they depend on the effects already created. Filin-
skiâ€™s reflection and reification [12] are closely related general concepts.
This paper introduces a handling construction for arbitrary algebraic effects.
The central new idea is that, semantically, handling a computation amounts
to composing it with a unique homomorphism guaranteed by universality. The
domain of this homomorphism is a free model of the algebraic theory of the
effects at hand; its range is a programmer-defined model of the algebraic theory;
and it extends a programmer-defined map on values. The principal example
is exception handling, particularly the exception-handling construct of Benton
and Kennedy [13], which our new construct generalises. It also includes many
other, previously unrelated, concepts. For example, stream redirection of shell
processes, renaming and hiding in CCS [14], timeout, and rollback can all be
seen as instances of such handlers.
In Section 2 we explain the idea of using homomorphisms for the seman-
tics of handlers via an informal discussion of exception handlers. In the follow-
ing Sections 3, 4 and 5 we develop a formal calculus in the call-by-push-value
framework [15, 11]. Section 3, describes (base) values and the algebraic theory
of effects. A natural need for two languages arises: one to describe handlers,
given in Section 4, and one where they are used to handle computations, given
in Section 5. The second parts of these sections give the relevant denotational
semantics; readers may wish to omit these and continue with Section 6, where
we give examples.
We outline a version of a logic for algebraic effects [11] with handlers in Sec-
tion 7. In Section 8 we sketch the inclusion of recursion: until then we work only
with sets and functions, but everything adapts straightforwardly to Ï‰-cpos (par-
tial orders with sups of increasing sequences) and continuous functions (mono-
tone functions preserving sups of increasing sequences). Finally, we discuss some
open questions and possible future work in Section 9.
2 Exception handlers
We start our study with exception handlers both because they are an established
concept [13, 16] and also because exceptions provide the simplest example of
algebraic effects. To focus on the exposition of ideas, we write this section in a
rather informal style, mixing syntax and semantics.
Taking a set of exceptions E, the computations that return values from a
set X are represented by elements, Î³, of TX =def X+E; the unit of the monad is
Î· = x 7â†’ inl(x). Algebraically, one may take a nullary operation, i.e., a constant,
2
raisee : 0 for each e âˆˆ E and no equations, and then FX has a carrier TX with
raisee interpreted as inr(e).
An exception handler
Î³ handle {e 7â†’ xe}eâˆˆE
takes a computation Î³ âˆˆ X+E and intercepts raised exceptions e âˆˆ E, carrying
out predefined computations xe âˆˆ E instead (if one chooses not to handle a
particular exception e one takes xe = raisee). So we have the two equations:
Î·(x) handle {e 7â†’ xe}eâˆˆE = inl(x) ,
raisee handle {e 7â†’ xe}eâˆˆE = xe .
From an algebraic point of view, the xe provide a model for the theory of
exceptions on X+E, interpreting each operation raisee by xe. If we write X+E
for the free model and X + E for the new model on the same carrier set, we see
from the above two equations that
h(Î³) =def Î³ handle {e 7â†’ xe}eâˆˆE
is the unique homomorphism h : X + E â†’ X + E extending inl : X â†’ X + E
along the unit Î·.
Benton and Kennedy [13] generalised the handling construct to one
try xâ‡ Î³ in g(x) unless {e 7â†’ ye}eâˆˆE ,
where exceptions emay be handled by computations ye of any given typeM (here
a model of the theory); returned values are â€œhandledâ€ with a map g : X â†’ M .
(This construct is actually a bit more general than in [13] as E may be infinite
and as we are in a call-by-push-value framework rather than a call-by-value one.)
We now have:
try xâ‡ Î·(x) in g(x) unless {e 7â†’ ye}eâˆˆE = g(x) ,
try xâ‡ raisee in g(x) unless {e 7â†’ ye}eâˆˆE = ye .
As they remarked, this handling construct allows a more concise programming
style, program optimisations, and a stack-free small-step operational semantics.
Algebraically we now have a model M on (the carrier of) M , interpreting
raisee by ye, and the handling construct corresponds to the homomorphism h
induced by g, that is the unique homomorphism h : X + E â†’ M extending g
along Î·. Note that all the homomorphisms from the free model are obtained in
this way, and so (this version of) Benton and Kennedyâ€™s handling construct is
the most general one possible from the algebraic point of view.
We can now see how to give handlers of other algebraic effects. To give
a model of an algebraic theory on a set X is to give a map fop : Xn â†’ X
for each operation op : n, on condition that those maps satisfy the equations
of the theory. As before, computations are interpreted in the free model and
handling constructs are interpreted by the induced homomorphisms. Intuitively,
while exceptions were simply replaced by handling computations, operations are
recursively replaced by handling functions on computations.
3
3 Values and effects
3.1 Base signature and interpretation
We start with a base signature Î£base, consisting of: a set of base types Î²; a
subset of base types, called the arity types Î±; a collection of function symbols
f : (Î²)â†’ Î²; and a collection of relation symbols R : (Î²). We use vector notation
a to abbreviate lists a1, . . . , an.
Base terms v are built from variables and function symbols, while base for-
mulas Ï• are built from equations between base terms, relation symbols applied
to base terms, logical connectives, and quantifiers over base types. In a con-
text Î“ of variables bound to base types, we type base terms as Î“ ` v : Î² and
base formulas as Î“ ` Ï• : form.
An interpretation of the base signature is given by: a set [[Î²]] for each base
type Î², countable when Î² is an arity type; a map [[f ]] : [[Î²]] â†’ [[Î²]] for each
function symbol f : (Î²)â†’ Î²; and a subset [[R]] âŠ† [[Î²]] for each relation symbol R :
(Î²), where [[Î²]] = [[Î²1]] Ã— . . . [[Î²n]]. Terms Î“ ` v :Î² and formulas Î“ ` Ï• : form are
interpreted by maps [[v]] : [[Î“ ]] â†’ [[Î²]] and subsets [[Ï•]] âŠ† [[Î“ ]] as usual [17].
3.2 Effect theory
Standard equational logic does not give a finitary notation for describing effects
given by an infinite family of operations, having an infinite number of outcomes,
or described by an infinite number of equations [5]. We present a more general
notation to do this, at least in some cases. We assume a given base signature
and interpretation.
To avoid infinite families of operation symbols, we allow operations to have
parameters of base types. For example, instead of having a family of operation
symbols updatel,d :1 for each location l and datum d, we take a single operation
symbol update : loc,dat; 1 that takes parameters l : loc and d : dat, which give
the memory location to be updated and the datum to be stored there.
To avoid operation symbols with infinite arity, we allow each argument of
an operation to be dependent on the outcome of an effect, which is a value of
an arity type. For example, the argument of an operation lookup : loc; dat is
dependent on the datum d :dat, stored in the memory location l : loc, supplied
to it as a parameter.
Thus, an effect signature Î£eff consists of operation symbols op:Î²;Î±1, . . . ,Î±n,
where Î² is a list of the parameter base types, and Î±1, . . . ,Î±n are lists of argument
arity types. We omit the semicolon when Î² is empty, and we write n instead of
Î±1, . . . ,Î±n when all the Î±i are empty. Effect terms T , which serve as templates
for computations, are given by the following grammar:
T ::= w(v) | opv(xi :Î±i.Ti)i ,
where w ranges over effect variables, and opv(xi :Î±i.Ti)i is an abbreviation for
opv(x1 :Î±1.T1, . . . ,xn :Î±n.Tn).
4
We type effect terms as Î“ ;âˆ† ` T , where âˆ† consists of effect variables w : (Î±),
according to the following rules:
Î“ ` v :Î±
(w : (Î±) âˆˆ âˆ†)
Î“ ;âˆ† ` w(v)
Î“ ` v :Î² Î“,xi :Î±i;âˆ† ` Ti (i = 1, . . . , n)
(op:Î²;Î±1, . . . ,Î±n âˆˆ Î£eff)
Î“ ;âˆ† ` opv(xi :Î±i.Ti)i
.
Next, conditional equations have the form Î“ ;âˆ† ` T1 = T2 (Ï•), assuming that
Î“ ;âˆ† ` T1, Î“ ;âˆ† ` T2, and Î“ ` Ï• : form. Finally, a conditional effect theory E is
a collection of such equations; it would be interesting to develop an equational
logic for such theories [18].
Example 1. To describe a set E of exceptions, the base signature consists of a
base type exc and a constant function symbol e : () â†’ exc for each e âˆˆ E.
We interpret exc by E and functional symbols by their corresponding elements.
The effect signature consists of an operation symbol raise : exc; 0, while the
effect theory is empty. Then, omitting empty parentheses, raisee represents the
computation that raises the exception e.
Example 2. For nondeterminism, we take the empty base signature, the empty
interpretation, the effect signature with a single nondeterministic choice opera-
tion symbol or :2, and the effect theory for a semi-lattice, which states that or is
idempotent, commutative, and associative.
Example 3. For state, the base signature contains a base type loc of memory
locations, an arity type dat of data, and appropriate function and relation sym-
bols to represent the locations and data. We interpret loc by a finite set L and
dat by a countable set D. The effect signature consists of operation symbols
lookup : loc; dat and update : loc,dat; 1, while the effect theory consists of seven
conditional equations [9, 18]. As an example term, lookupl(d :dat.updatelâ€²,d(w))
represents the computation that copies d from l to lâ€² and then proceeds as w.
Each effect theory E gives rise to a standard (possibly infinitary) equational
theory [19]. For each op:Î²;Î±1, . . . ,Î±n âˆˆ Î£eff and b âˆˆ [[Î²]], we take an operation
symbol opb of countable arity
âˆ‘
i |[[Î±i]]|. Then each term Î“ ;âˆ† ` T and each
c âˆˆ [[Î“ ]] give rise to a term âˆ†â€² ` Tc, where âˆ†â€² consists of variables wa for each
w : (Î±) âˆˆ âˆ† and a âˆˆ [[Î±]]. The equations of the theory are âˆ†â€² ` Tc = Tcâ€² for any
equation Î“ ;âˆ† ` T = T â€² (Ï•) in E and any c âˆˆ [[Ï•]].
A model of the effect theory is a set M together with a family of maps
{opM : [[Î²]] Ã—
âˆ
iM
[[Î±i]] â†’ M}op:Î²;Î±1,...,Î±nâˆˆÎ£eff , such that the corresponding
maps opM (b,âˆ’), where b âˆˆ [[Î²]], satisfy the equations of the induced infinitary
effect theory. A homomorphism between models M and N is a map f : M â†’ N
such that opN â—¦ (id[[Î²]] Ã—
âˆ
i f
[[Î±i]]) = f â—¦ opM holds.
Models and homomorphisms form a category ModE, equipped with the for-
getful functor U : ModE â†’ Set, which maps a model to its underlying set and a
5
homomorphism to its underlying map. This functor has a left adjoint F , which
constructs the free model FA on a set of generators A. The set UFA rep-
resents the set of computations that return values in A, and the monad UF
corresponds [9] to the monad proposed by Moggi to model the corresponding
effect [2]. The monad induced by the theory for exceptions in Example 1 maps
a set X to X +E, the one for non-determinism in Example 2 maps it to the set
F+(X) of finite non-empty subsets of X, while the one for state in Example 3
maps it to (SÃ—X)S , where S = DL. One can give an equivalent treatment using
countable Lawvere theories [20].
4 Handlers
Exception handlers are usually described and used within the same language:
for each exception, we give a replacement computation term, which can contain
further exception handlers. Repeating the same procedure for other algebraic
effects is difficult: in order to interpret the handling construct, the handlers have
to be correct in the sense that the redefinition of the operations they provide
yields a model of the effect theory.
Instead of equipping a single calculus with a mechanism to verify that han-
dlers are correct, we avoid this complex interdependence between well-formed-
ness and correctness by providing two calculi. One, given in this section, enables
the language designer to specify handlers; one, given in the next section, enables
the programmer to use them. In this way the selection of correct handlers is
delegated to the meta-level.
Handlers are described by handler types Ï‡ and handler terms h, given by the
following grammar:
Ï‡ ::=X | FÏƒ | 1 | Ï‡1 Ã— Ï‡2 | Ïƒ â†’ Ï‡ ,
h ::= z(v) | opv(xi :Î±i.hi)i | if Ï• thenh1 elseh2 | returnu | letx beh inhâ€² |
? | ã€ˆh1, h2ã€‰ | fsth | sndh | Î»x :Ïƒ.h | hu ,
where X ranges over type variables, Ïƒ ranges over value types, z ranges over
handler variables, u ranges over value terms, and Ï• in the conditional statement
ranges over quantifier-free formulas. For the sake of simplicity, only the most
basic programming constructs are present, and the only value types and terms
are the one stemming from the base signature.
Handler terms h are typed with handler types Ï‡ in a context Î“ of variables,
bound to value types, and a context Z of handler variables z : (Î±) â†’ Ï‡, where
we write z :Ï‡ if Î± is empty, according to the following rules:
Î“ ` v :Î±
(z : (Î±)â†’ Ï‡ âˆˆ Z)
Î“ ;Z ` z(v) :Ï‡
Î“ ` v :Î² Î“,xi :Î±i;Z ` hi :Ï‡ (i = 1, . . . , n)
(op:Î²;Î±1, . . . ,Î±n âˆˆ Î£eff)
Î“ ;Z ` opv(xi :Î±i.hi)i :Ï‡
6
Î“ ` u :Ïƒ
Î“ ;Z ` returnu :FÏƒ
Î“ ;Z ` h :FÏƒ Î“, x :Ïƒ;Z ` hâ€² :Ï‡
Î“ ;Z ` letx beh inhâ€² :Ï‡
,
and the standard rules for conditionals, products, and functions.
For greater generality, handlers are parametric in two ways: their type con-
tains type variables, and they are dependent on parameters xp and zp, supplied
through the handling construct. A handler is given by a handling term for each
operation, dependent on its parameters x and arguments z, and is typed by
xp :Ïƒ,x :Î²; zp :Ï‡, (zi : (Î±i)â†’ Ï‡)ni=1 ` hop :Ï‡ (op:Î²;Î±1, . . . ,Î±n âˆˆ Î£eff)
` (xp :Ïƒ; zp :Ï‡).{opx(z) 7â†’ hop}opâˆˆÎ£eff : (Ïƒ;Ï‡)â†’ Ï‡ handler
.
When opx(z) 7â†’ hop is omitted, we assume that hop = opx(xi :Î±i.zi(xi))i, so
that op is not handled.
4.1 Semantics
For each assignment of models [[X]] to type variables X, handler types Ï‡ are
interpreted by models [[Ï‡]], given by
[[FÏƒ]] = F [[Ïƒ]] [[1]] = 1
[[Ï‡1 Ã— Ï‡2]] = [[Ï‡1]] Ã— [[Ï‡2]] [[Ïƒ â†’ Ï‡]] = [[Ï‡]][[Ïƒ]] ,
where the model is given component-wise on M1 Ã—M2 and point-wise on MA.
Then, we interpret contexts Z = z1 : (Î±1) â†’ Ï‡1, . . . , zn : (Î±n) â†’ Ï‡n by
[[Z]] = U [[Ï‡1]][[Î±1]] Ã— Â· Â· Â· Ã— U [[Ï‡n]][[Î±n]] and handler terms Î“ ;Z ` h : Ï‡ by maps
[[h]] : [[Î“ ]] Ã— [[Z]] â†’ U [[Ï‡]], defined inductively by
[[Î“ ;Z ` zi(v) :Ï‡i]] = ev â—¦ ã€ˆprU [[Ï‡i]][[Î±i]] , [[v]]ã€‰ ,
[[Î“ ;Z ` opv(xi.hi)i :Ï‡]] = op[[Ï‡]] â—¦ ã€ˆ[[v]], [Ì‚[h1]], . . . , Ì‚[[hn]]ã€‰ ,
[[Î“ ;Z ` returnu :FÏƒ]] = Î·[[Ïƒ]] â—¦ [[u]] ,
[[Î“ ;Z ` letx beh inhâ€² :Ï‡]] = [[hâ€²]]â€  â—¦ ã€ˆidÎ“ , idZ , [[h]]ã€‰ ,
where fÌ‚ : B â†’ CA is the transpose of f : AÃ—B â†’ C and fâ€  : AÃ—UFB â†’ UM
is the lifting of f : AÃ— B â†’ UM , which is defined by U â—¦ UFf â—¦ stA,B , where
stA,B : A Ã— UFB â†’ UF (A Ã— B) is the strength of the functor UF . The inter-
pretations of conditionals, products, and functions are defined as usual [15].
A handler (xp :Ïƒ; zp :Ï‡).{opx(z) 7â†’ hop}opâˆˆÎ£eff : (Ïƒ;Ï‡)â†’ Ï‡ handler is cor-
rect (with respect to E) if for all assignments of models [[X]] to type variables X,
and for all parameters ap âˆˆ [[Ïƒ]] and mp âˆˆ [[Ï‡]], the family of maps
{[[hop]] â—¦ ã€ˆap,pr[[Î²]] ,mp,prQi U [[Ï‡]][[Î±i]] ã€‰ : [[Î²]] Ã—
âˆ
i
U [[Ï‡]][[Î±i]] â†’ U [[Ï‡]]}opâˆˆÎ£eff
defines a model of the effect theory E on U [[Ï‡]].
7
5 Computations
A handler signature Î£hand consists of handler symbols H, each with a corre-
sponding correct handler. Then, computation types Ï„ and computation terms t
are given by the following grammar:
Ï„ ::= FÏƒ | 1 | Ï„1 Ã— Ï„2 | Ïƒ â†’ Ï„ ,
t ::= opv(xi :Î±i.ti)i | if Ï• then t1 else t2 | returnu | letx be t in tâ€² |
try twithH(u; t) asx in tâ€² | ? | ã€ˆt1, t2ã€‰ | fst t | snd t | Î»x :Ïƒ.t | tu .
One can see that computation types and terms mirror their handler counter-
parts, with the omission of type and handler variables, and the addition of the
handling construct. When the extended handling construct is not necessary, we
write handle twithH(u; t) instead of try twithH(u; t) asx in returnx, and when
the handler signature consists of a single handler symbol H, we omit it and
simply write try twithu; t asx in tâ€².
We can extend both handlers and computations with other call-by-push-value
constructs [15]. A problem arises if we introduce thunks: handler terms then
contain value terms, which contain thunked computation terms, which contain
the handling construct. To resolve the issue, we would further split the handler
types and terms into value and computation ones.
Computation terms t are typed with computation types Ï„ , according to rules
similar to the ones for handling terms, while the handling construct for a handler
H : (Ïƒ;Ï‡)â†’ Ï‡ handler âˆˆ Î£hand is typed by
Î“ ` t :FÏƒ Î“ ` u :Ïƒ Î“ ` t :Ï‡[Ï„/X] Î“, x :Ïƒ ` tâ€² :Ï‡[Ï„/X]
Î“ ` try twithH(u; t) asx in tâ€² :Ï‡[Ï„/X]
,
where Ï‡[Ï„/X] is the computation type obtained by replacing all the type vari-
ables X in Ï‡ by computation types Ï„ . A handler H : (Ïƒ;Ï‡)â†’ Ï‡ handler is
uniform, if Ï‡ = X, and parametrically uniform, if Ï‡ = Ïƒ â†’ X.
5.1 Semantics
Computation types and terms are interpreted in the same way as their han-
dler counterparts, while the handling construct is interpreted as follows. Each
handler H : (Ïƒ;Ï‡)â†’ Ï‡ handler âˆˆ Î£hand is correct and so induces a model
[[Ï‡[Ï„/X] withH(u; t)]] for any assignment of computation types Ï„ to type vari-
ables X, any value terms Î“ ` u :Ïƒ, and any computation terms Î“ ` t :Ï‡[Ï„/X].
From the universality of the free model F [[Ïƒ]], we get the unique map [Ìƒ[tâ€²]], ho-
momorphic in the second argument, for which the diagram below commutes.
[[Î“ ]] Ã— UF [[Ïƒ]]
[[Î“ ]] Ã— [[Ïƒ]]
âˆª
6
[[tâ€²]]- U [[Ï‡[Ï„/X] withH(u; t)]]
............................................
[Ìƒ[t â€²]]
-
8
Then, Î“ ` try twithH(u; t) asx in tâ€² is interpreted by
[Ìƒ[tâ€²]] â—¦ ã€ˆid[[Î“ ]] , [[t]]ã€‰ : [[Î“ ]] â†’ U [[Ï‡[Ï„/X] withH(u; t)]] = U [[Ï‡[Ï„/X]]] .
6 Examples
6.1 Exceptions
The standard uniform exception handler Hexc : (excâ†’ X)â†’ X handler is
(z :excâ†’ X).{raisee() 7â†’ ze} .
Benton and Kennedyâ€™s construct try x â‡ t in tâ€² unless {e1 â‡’ t1 | Â· Â· Â· | en â‡’ tn}
can then be written as try twith texc asx in tâ€² for a suitable term texc :excâ†’ Ï„ .
Benton and Kennedy noted a few issues about the syntax of their construct
when used for programming [13]. It is not obvious that t is handled whereas tâ€²
is not, especially when tâ€² is large and the handler is obscured. An alternative
they propose is try x â‡ t unless {e1 â‡’ t1 | . . . | en â‡’ tn}i in tâ€², but then it is not
obvious that x is bound in tâ€², but not in the handler. The syntax of our con-
struct try twithH(u; t) asx in tâ€² addresses those issues and clarifies the order of
evaluation: after t is handled with H, its results are bound to x and used in tâ€².
6.2 Stream redirection
Shell processes in Unix-like operating systems communicate with the user us-
ing input and output streams, usually connected to a keyboard and a terminal
window. However, such streams can be rerouted to other processes and simple
commands can be combined into more powerful ones.
One case is the redirection proc > outfile of the output stream of a pro-
cess proc to a file outfile, usually used to store the output for a future analysis.
An alternative is the redirection proc > /dev/null to the null device, which ef-
fectively discards the standard output stream.
Another case is the pipe proc1 | proc2, where the output of proc1 is fed to
the input of proc2. For example, to get a way (not necessarily the best one) of
routinely confirming a series of actions, for example deleting a large number of
files, we write yes | proc, where the command yes outputs an infinite stream
made of a predetermined character (default one being y).
We represent interactive input/output by: a base signature, consisting of
a base type char of characters and constants a, b, . . . of type char, together
with the obvious interpretation; an effect signature, consisting of operation sym-
bols out : char; 1 and in : char, with the empty effect theory. Then, if t is a
computation, we can express yes | t > /dev/null by handle twithHred, where
Hred :X handler is given by {outc(z) 7â†’ z, in(z) 7â†’ z(y)}.
9
6.3 CCS renaming and hiding
In functional programming, processes are regarded as programs of the empty
type 0. The subset of CCS processes [21], given by action prefix and sum, can
be represented by: a base signature, consisting of a base type act of actions
and appropriate constants for actions, interpreted in the evident way; an effect
signature, consisting of operation symbols 0 : 0, do : act; 1, and + : 2, with
the obvious effect theory [11]. Then, process renaming t[b/a] can be written as
handle twithHren(a, b) using the handler Hren : (act,act)â†’ F0 handler, where,
writing a.z for doa(z):
Hren = (a :act, b :act).{aâ€².z 7â†’ if aâ€² = a then b.z else aâ€².z} .
Hiding can be implemented in a similar way, but, and most unfortunately, it
seems that parallel cannot be, as it is recursively defined on the structure of two
processes and thus apparently requires a binary variant of handlers. Presently,
we do not see a possible such generalisation, as primitive recursion is inherently
defined on a single structure.
6.4 Explicit nondeterminism
The evaluation of a nondeterministic computation usually takes only one of all
the possible paths. But in logic programming [22, 23], we do an exhaustive search
for all solutions that satisfy given constraints in the order given by the solver im-
plementation. Such nondeterminism is represented slightly differently from the
one in Example 2. We take: the empty base signature; the effect signature, con-
sisting of operation symbols fail : 0 and pick : 2, with the effect theory consisting
of the following equations stating that the operations form a monoid:
w ` pick(w, fail()) = pick(fail(), w) = w ,
w1, w2, w3 ` pick(w1, pick(w2, w3)) = pick(pick(w1, w2), w3) .
The free-model monad maps a set to the set of all finite sequences of its elements,
which is Haskellâ€™s nondeterminism monad [24].
A user is usually presented with a way of browsing through those solutions,
for example extracting all the solutions into a list. Since our calculus has no
polymorphic lists (although it can easily be extended with them), we take base
types Î± and listÎ±, function symbols nil : () â†’ listÎ±, cons : (Î±, listÎ±) â†’ listÎ±,
head : (listÎ±)â†’ Î±, tail : (listÎ±)â†’ listÎ±, and append : (listÎ±, listÎ±)â†’ listÎ±. Then,
all the results of a computation of type FÎ± can be extracted into a returned
value of type F listÎ± using the handler
{fail() 7â†’ return nil() ,
pick(z1, z2) 7â†’ letx1 be z1 in letx2 be z2 in return append(x1, x2)} .
We can similarly devise a handler that returns the first solution, or one that
prints out a solution and asks the user whether to continue the search or not.
10
6.5 Handlers with parameter passing
Sometimes, we wish to handle different instances of the same operation dif-
ferently, for example suppressing output after a certain number of characters.
Although we handle operations in a fixed way, we can use handlers on a function
type Ïƒ â†’ Ï‡ to simulate handlers on Ï‡ that pass around a parameter of type Ïƒ.
Instead of
(xp :Ïƒ; zp :Ï‡).{opx(z) 7â†’ Î»x :Ïƒ.hop}opâˆˆÎ£eff : (Ïƒ;Ï‡)â†’ (Ïƒ â†’ Ï‡) handler .
where all the occurrences of zi(v) are applied to some v :Ïƒ, the changed param-
eter, we write
(xp :Ïƒ; zp :Ï‡).{opx(z)@x 7â†’ hâ€²op}opâˆˆÎ£eff : (Ïƒ;Ï‡)â†’ Ï‡@Ïƒ handler ,
where hâ€²op results from substituting zi(v)v for zi(v)@v in hop. We also write
try twithH(u; t)@v asx@y in tâ€²
instead of
(try twithH(u; t) asx inÎ»y :Ïƒ.tâ€²)v .
We could similarly simulate mutually defined handlers by handlers on product
types, but we know no interesting examples of their use.
6.6 Timeout
When the evaluation of a computation takes too long, we may want to abort it
and provide a predefined result instead, a behaviour called timeout.
We represent time by: a base signature with a base type int of integers, ap-
propriate function symbols and a relation symbol > : (int, int), with the evident
interpretation; an effect signature consisting of delay :1, to represent the passage
of some fixed amount of time, with the empty effect theory. Then timeout can
be described by a handler which passes around a parameter T : int representing
how long we are willing to wait before we abort the evaluation and return zp.
(zp :X).{delay(z)@T 7â†’ delay(if T > 0 then z@(T âˆ’ 1) else zp)} .
Note that the handling term is wrapped in delay in order to preserve the time
spent during the evaluation of the handled computation.
6.7 Input redirection
With parameter passing, we can implement the redirection proc < infile,
which feeds the contents of infile to the standard input of proc. We take
the base signature, etc., of Section 6.2, extended by the base type listchar, etc.,
of Section 6.4. Then a handler Hin :X@listchar handler to pass a string to a
process is given by:
{in(z)@` 7â†’ if ` = nil() then in(a.z(a)@nil()) else z(head(`))@tail(`)} .
Unfortunately we do not see how to implement the pipe t1|t2: the difficulty is
very much like that with the CCS parallel combinator.
11
6.8 Rollback
When a computation raises an exception while modifying the memory, for ex-
ample, when a connection drops half-way through a database transaction, we
want to revert all the modifications made. This behaviour is termed rollback.
We take the base and the effect signatures for exceptions as in Example 1 and
state as in Example 3, and the effect theory for state, together with the equation
updatel,d(raisee) = raisee for each exception e we deem unrecoverable [10]. In this
case, the standard exception handler, extended to state, is not correct. Instead,
we use a handler Hrollback : X@(exc â†’ X) handler, which passes around a
function that reverts the modified locations. Such a handler is given by
{updatel,d(z)@f 7â†’
lookupl(d
â€².updatel,d(z@(Î»e :exc. letx be fe in updatel,dâ€²(x)))) ,
lookupl(z)@f 7â†’ lookupl(d.z(d)@f) ,
raisee()@f 7â†’ fe} ,
and is used on t :FÏƒ by handle twithHrollback@t0 for some t0 :excâ†’ FÏƒ.
We can also give a variant of rollback that passes around a list of changes to
the memory, committed only after the computation has returned a value.
7 Logic
Since the notions needed to interpret the handling construct are present in all the
interpretations of algebraic effects, it is relatively easy to adapt the logic for alge-
braic effects of [11] to account for handlers. (In fact, handlers are already present
in the logic in a way, as the free algebra principle allows an ad-hoc construction
of models and guarantees the existence of the required unique homomorphism.)
To incorporate handlers, we extend the language of the logic with handler
types and terms, and state that the handling construct acts as a homomorphism
by:
Î“ ` try returnuwithH(u; t) asx in t = t[u/x] ,
Î“ ` try opv(xi.ti)i withH(u; t) asx in tâ€² = hopâ€² [v/x] ,
where hâ€²op is the computation term, obtained by taking the handling term hop
and substituting try ti[vi/xi] withH(u; t) asx in t for zi(vi). The principle of com-
putation induction yields uniqueness.
This principle was used in [11] to derive associativity and other properties of
let binding and we can obtain analogous equations for the exception-handling
construct, instead of taking them as axioms [13, 16]. However, a general associa-
tivity of the handling construct would have the form
try (try t1 withH1 asx1 in t2) withH2 asx2 in t
= try t1 withH asx1 in(try t2 withH2 asx2 in t) ,
12
but may not be expressible, as the model needed for H, the image of the model
induced by H1 under the homomorphism induced by t2, may not be definable.
Still, the associativity of exception handlers is not only expressible, but also
derivable by induction, because, then, H1 = Hexc(f1) and H2 = Hexc(f2) for
some f1 :excâ†’ FÏƒ2 and f2 :excâ†’ Ï„ , and we can set
H =def Hexc(Î»e :exc. try f1ewithH2 asx2 in t) .
8 Recursion
We sketch how to adapt the above ideas to deal with recursion. We work with
Ï‰-cpos and continuous functions. Base signatures are as before; for their inter-
pretations we use Ï‰-cpos and continuous functions, still, however, interpreting
arity types by countable sets, equipped with the trivial order (with some ad-
ditional effort this can be generalised to countable Ï‰-cpos, in the categorical
sense). Effect syntax is as before, except that we allow conditional inequations
Î“ ;âˆ† ` T1 â‰¤ T2 (Ï•) and assume there is always a constant â„¦ and the inequation
â„¦ â‰¤ w. We again obtain a category of models, now using Ï‰-cpos (necessarily
with a least element) and continuous functions; free models exist as before.
Handler and computation syntax are also as before except that we add recur-
sion terms Âµx :Ï‡.h and Âµx :Ï„ .t (and so also computation variables) with the usual
least fixed-point interpretation. Correct handlers cannot redefine â„¦ because of
the inequation â„¦ â‰¤ w. The adaptation of the logic of effects to allow recursion
in [11] further adapts to handlers, analogously to the above; in this regard one
notes that equations are admissible and therefore one may still use computation
induction to prove associativity and so on.
9 Conclusions
Some immediate questions stem from the current work. The most important is
how to simultaneously handle two computations to describe parallel operators,
e.g., that of CCS or the UNIX pipe combinator: that would bring parallelism
within the ambit of the algebraic theory of effects. More routinely, perhaps, the
work done on combinations of effects [10] should be extended to combinations
of handlers; one would also like a general operational semantics [4] including
Benton and Kennedyâ€™s in [13].
The separation between the languages for handlers and computations is es-
sential in the development of this paper. A possible alternative is to give a single
language and a mechanism limiting well-typed handlers to correct ones. This
might be done by means of a suitable type-theory.
It is interesting to compare our approach to that taken in Haskell [24], where
a monad is given by a type with unit and binding maps. The type-checker only
checks the signature of the maps, but not the monadic laws they should satisfy.
Still, the only way to use effects in Haskell is through the use of the built-in mon-
ads, and their laws were checked by their designers. Building on this similarity,
13
one can imagine extending Haskell in two ways: one could enrich the built-in
effects with operations and handlers, and one could can give programmers a way
write their own handlers, which have no direct access to effects, but which could
be used to program in an extension of the monadic style.
Monads, or algebraic theories, are used to model particular computational
effects, and it is even possible for one monad to model distinct effects. For exam-
ple the complexity monad NÃ—âˆ’ may account for either space or time. A given
handler may or may not be computationally feasible for a given effect and there
is a question as to which are. We may expect uniform handlers to be feasible, as
they cannot use the properties of a specific data-type and so, one may imagine,
cannot be as contrived.
Lastly, one advantage of Benton and Kennedyâ€™s handling construct is the
elegant programming style it introduces. We gave various examples of our more
general construct above; some used parameter-passing, but none, unfortunately,
used mutually defined handlers. We hope our new programming construct proves
useful, and we look forward to feedback from the programming community.
Acknowledgments
The authors thank Andrej Bauer, Andrzej Filinski, Paul Levy, John Power,
Mojca Pretnar, and Alex Simpson for their insightful comments and support.
References
1. Moggi, E.: Computational lambda-calculus and monads. In: 4th Symposium on
Logic in Computer Science. (1989) 14â€“23
2. Moggi, E.: Notions of computation and monads. Information And Computation
93 (1991) 55â€“92
3. Benton, N., Hughes, J., Moggi, E.: Monads and effects. In: International Summer
School on Applied Semantics 2000. Volume 2395 of Lecture Notes in Computer
Science. (2000) 42â€“122
4. Plotkin, G.D., Power, A.J.: Adequacy for algebraic effects. In: 4th International
Conference on Foundations of Software Science and Computation Structures. Vol-
ume 2030 of Lecture Notes in Computer Science. (2001) 1â€“24
5. Plotkin, G.D., Power, A.J.: Algebraic operations and generic effects. Applied
Categorical Structures 11 (2003) 69â€“94
6. Plotkin, G.D., Power, A.J.: Computational effects and operations: An overview.
Electronic Notes in Theoretical Computer Science 73 (2004) 149â€“163
7. Flanagan, C., Sabry, A., Duba, B.F., Felleisen, M.: The essence of compiling with
continuations. In: Conference on Programming Language Design and Implemen-
tation. (1993) 237â€“247
8. Hyland, M., Levy, P.B., Plotkin, G.D., Power, A.J.: Combining algebraic effects
with continuations. Theoretical Computer Science 375 (2007) 20â€“40
9. Plotkin, G.D., Power, A.J.: Notions of computation determine monads. In: 5th
International Conference on Foundations of Software Science and Computation
Structures. Volume 2303 of Lecture Notes in Computer Science. (2002) 342â€“356
14
10. Hyland, M., Plotkin, G.D., Power, A.J.: Combining effects: Sum and tensor. The-
oretical Computer Science 357 (2006) 70â€“99
11. Plotkin, G.D., Pretnar, M.: A logic for algebraic effects. In: 23rd Symposium on
Logic in Computer Science. (2008) 118â€“129
12. Filinski, A.: Representing layered monads. In: 26th Symposium on Principles of
Programming Languages. (1999) 175â€“188
13. Benton, N., Kennedy, A.: Exceptional syntax. Journal of Functional Programming
11 (2001) 395â€“410
14. Hennessy, M., Milner, R.: Algebraic laws for nondeterminism and concurrency.
Journal of the ACM 32 (1985) 137â€“161
15. Levy, P.B.: Call-by-push-value: Decomposing call-by-value and call-by-name.
Higher-Order and Symbolic Computation 19 (2006) 377â€“414
16. Levy, P.B.: Monads and adjunctions for global exceptions. Electronic Notes in
Theoretical Computer Science 158 (2006) 261â€“287
17. Enderton, H.B.: A Mathematical Introduction to Logic. 2nd edn. Academic Press
(2000)
18. Plotkin, G.D.: Some varieties of equational logic. In: Essays Dedicated to Joseph
A. Goguen. Volume 4060 of Lecture Notes in Computer Science. (2006) 150â€“156
19. GraÌˆtzer, G.A.: Universal algebra. 2nd edn. Springer (1979)
20. Power, A.J.: Countable Lawvere theories and computational effects. Electronic
Notes in Theoretical Computer Science 161 (2006) 59â€“71
21. Milner, R.: A calculus of communicating systems. Springer (1980)
22. Clocksin, W.F., Mellish, C.: Programming in Prolog. 3rd edn. Springer (1987)
23. Pfenning, F., SchuÌˆrmann, C.: System description: Twelf â€“ a meta-logical framework
for deductive systems. In: 16th International Conference on Automated Deduction.
Volume 1632 of Lecture Notes in Computer Science. (1999) 202â€“206
24. Jones, S.L.P.: Haskell 98. Journal of Functional Programming 13 (2003) 0â€“255
15

