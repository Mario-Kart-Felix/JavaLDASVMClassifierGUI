Defining Equitable Geographic Districts in Road Networks via
Stable Matching
David Eppstein
University of California, Irvine
eppstein@uci.edu
Michael T. Goodrich
University of California, Irvine
goodrich@uci.edu
Doruk Korkmaz
University of California, Irvine
dkorkmaz@uci.edu
Nil Mamano
University of California, Irvine
nmamano@uci.edu
ABSTRACT
We introduce a novel method for defining geographic districts
in road networks using stable matching. In this approach, each
geographic district is defined in terms of a center, which identifies
a location of interest, such as a post office or polling place, and all
other network vertices must be labeled with the center to which
they are associated. We focus on defining geographic districts that
are equitable, in that every district has the same number of vertices
and the assignment is stable in terms of geographic distance. That
is, there is no unassigned vertex-center pair such that both would
prefer each other over their current assignments. We solve this
problem using a version of the classic stable matching problem,
called symmetric stable matching, in which the preferences of the
elements in both sets obey a certain symmetry. In our case, we
study a graph-based version of stable matching in which nodes are
stably matched to a subset of nodes denoted as centers, prioritized
by their shortest-path distances, so that each center is apportioned
a certain number of nodes. We show that, for a planar graph or road
network with n nodes and k centers, the problem can be solved in
O(n
√
n logn) time, which improves upon theO(nk) runtime of using
the classic Gale–Shapley stable matching algorithm when k is large.
In order to achieve this running time, we present a novel dynamic
nearest-neighbor data structure for road networks, which may be
of independent interest. This data structure maintains a subset of
nodes of the network and allows nearest-neighbor queries (for other
nodes in the graph) inO(
√
n) time and updates inO(
√
n logn) time.
Finally, we provide experimental results on road networks for these
algorithms and a heuristic algorithm that performs better than the
Gale–Shapley algorithm for any range of values of k .
KEYWORDS
road networks, stable matching, nearest neighbors, geographic
districting
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
, ,
© 2017 Copyright held by the owner/author(s).
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn
1 INTRODUCTION
Location analysis is a classical branch of optimization in geographic
information systems, concerned both with facility location, the
placement of centers to serve geographic regions such as polling
places, fire stations, or post offices, and the assignment problem,
the problem of surrounding these facilities by service regions in
an optimal way, so that all points are equitably served by nearby
facilities and each facility bears a fair portion of the total service
load. This problem includes, for instance, the special case of political
districting in which the requirements for fairness (avoiding unfair
gerrymandered districts) include both geographic compactness and
equal representivity with respect to the broader population. (E.g.,
see [36–38].)
In this work, we consider a geographic abstraction of the assign-
ment problem in which the facility locations have already been de-
termined through some other algorithm. We model the geographic
space of interest as a weighted, undirected graph representing a
road network, we model the population to be assigned to facilities
as the set of all vertices of the graph, and we model the facility
locations as a subset of k chosen center nodes of the graph. Each
center has a quota indicating how many nodes it should match. The
desired output is an assignment of every node to a center, such that
the set of assigned nodes for each center equals its quota. The use
of quotas in this way allows each of the facilities to have different
operational capacities in terms of how much of the population they
can serve.
We impose the conditions that each node has a preference for
centers ordered by shortest-path distance from the node, and each
center has a preference for nodes ordered by their distances from
the center. Our goal is to match each center to its quota number of
nodes and for the matching to be stable, meaning that no node and
center that are not assigned to each other prefer each other to their
specified matches. Rather than optimizing some computationally
challenging global quality criterion, we seek an assignment of nodes
to centers that is stable.
We are offering this combined notion of giving each center a
quota and optimizing stability in terms of distance-based prefer-
ences as a type of equitability for defining geographic districts.
Quotas provide fairness in terms of the number of nodes assigned
to each center and stability provides fairness in terms of how those
nodes are assigned.
Defining geographic districts that are equitable implies a certain
amount of “compactness” for districts, which avoids the types of
highly non-compact districts that have been the subject of recent
1
ar
X
iv
:1
70
6.
09
59
3v
1 
 [
cs
.D
S]
  2
9 
Ju
n 
20
17
, , D. Eppstein et al.
Texas (n = 2037K ,m = 2550K ) Michigan (n = 662K ,m = 833K )
Washington, DC (n = 9522,m = 14850) Illinois (n = 790K ,m = 1008K )
Figure 1: The solutions to the stable graphmatching problem for the 2010 road networks of three U.S. states and the District of
Columbia, from the DIMACS database [9]. They consists of primary and secondary roads in the biggest connected component
of the road networks. In each case, n andm denote the number of nodes and edges, respectively, and there are k = 6 random
centers with equal quota n/k .
legal cases involving gerrymandering. This is a characteristic of
our use of stable matching for assigning nodes to centers based
on symmetric distance-based preferences. This notion does not,
however, imply that equitable districts are necessarily convex or
even connected. Indeed, depending on the placement of centers
and how quotas are defined, it may be necessary for some districts
to be disconnected.
Figure 1 illustrates these properties for solutions to our stable
graph matching problem for the road networks of three U.S. states
and the District of Columbia, with k = 6 randomly-placed centers
and equal quotas.
1.1 New Results
In the standard stable matching problem, preferences are arbitrary.
Each individual may choose as his or her preferences any permu-
tation of the opposite-set individuals, independently of all other
choices. Preferences resulting from shortest-path distances in an
undirected graph are not arbitrary, however. Instead, they obey a
certain symmetry property coming from the undirected nature of
the graph and shortest paths within the graph. To capitalize on this
idea, we define an abstract problem intermediate between stable
graph matching and stable matching, which we call the symmetric
stable matching problem. Stable graph matching is a particular case
of symmetric stable matching. We observe that for a symmetric sta-
ble matching of n nodes with k centers, the classical Gale–Shapley
2
Defining Districts via Stable Matching , ,
algorithm can compute a solution in time O(nk), once all distances
between nodes and centers have been computed.
Moreover, we develop a novel nearest-neighbor chain algorithm
for any symmetric stable matching problem, using ideas borrowed
from a very different application of nearest-neighbor chains, in hi-
erarchical clustering problems [4, 29]. Our algorithm can be applied
to stable graph matching and extends our previous work on stable
grid matching [17], another case of symmetric stable matching. It
runs in O(n · T (n)) time, where T (n) is the time per operation of
a data structure for updating a dynamic subset of points from the
given metric space and answering nearest neighbors to these points.
In the graph setting, this means that we need to be able to find the
closest center of a node, and vice versa, efficiently. Motivated by
this application, we present a novel, dynamic nearest-neighbor data
structure for planar graphs and road networks with n nodes that
answers queries in O(
√
n) time and updates in O(
√
n logn) time.
We summarize our contributions as follows.
• We formulate the stable graph matching problem and its
generalization, the symmetric stable matching problem.
• We describe a general class of algorithms for solving sym-
metric stable matching, the mutual closest pair algorithms,
and we use these algorithms to prove that for symmetric
stable matching (and unlike stable matching more gener-
ally) the solution is always unique.
• We define and analyze the nearest-neighbor chain algo-
rithm for symmetric stable matchings. As we show, for
inputs that can support nearest-neighbor queries on dy-
namic subsets of the input preferences, with time T (n) per
update or nearest-neighbor query, we can find a symmetric
stable matching in time O(nT (n)).
• For planar graphs and road networks, we provide a dy-
namic nearest-neighbor data structure with timeO(
√
n) per
query and O(
√
n logn) per update. Combining this struc-
ture with our nearest-neighbor chain algorithm allows us
to solve stable graph matchings in these networks in total
timeO(n
√
n logn), significantly smaller than Gale–Shapley
when k is large.
• We provide a heuristic circle-growing improvement to the
Gale–Shapley algorithm for the case of symmetric stable
matchings. Our heuristic does not improve theO(nk)worst-
case time of the algorithm, but we expect it to provide
significant speedups in practice.
• We provide an experimental comparison of our algorithms
on real-world road networks. Our experiments confirm the
independence from k of the running time of our nearest-
neighbor based algorithm, and they also confirm the effi-
cacy of our heuristic circle-growing improvement to the
Gale–Shapley algorithm.
One of the techniques we use in our algorithms is based on graph
separators for planar graphs and road networks, which provides a
paradigm that may be of use in other dynamic data structures for
planar graphs and road networks. In particular, our O(n
√
n logn)
time algorithm generalizes to any family of graphs with separators
of size O(
√
n).
1.2 Prior Related Work
Our notion of equitability introduces an interesting new (and more
realistic) twist to Knuth’s classic post office problem [32]. In the
classic post office problem, one is given a collection of sites called
“post offices” and one is interested in assigning nodes to their nearest
post office with no consideration for quotas characterizing the
capacity of each post office to handle mail. Thus, the classic post
office problem is equivalent to our geographic districting problem
with unbounded quotas.
Knuth’s discussion of the classic post office problem has given
rise to a long line of research on structures for spatial partitioning
for answering nearest-neighbor queries, including an entire litera-
ture on the topic of Voronoi diagrams (e.g., see [2]), which, given
a collection of sites, partition a space into regions such that the
points in each region have a particular site as their nearest. Further-
more, Erwig [20] shows that Voronoi diagrams can be extended to
graphs and that such structures can be constructed using Dijstra’s
shortest-path algorithm (e.g., see [8, 24]). These Voronoi diagram
structures are efficient for instances when the set of sites is fixed,
but they tend to perform poorly for cases in which sites can be
inserted or removed. Such dynamic nearest neighbor problems have
been addressed in geometric settings. For exact two-dimensional
dynamic nearest neighbors, a data structure with O(nϵ ) update
and query time was given by Agarwal et al. [1]; this was improved
to O(log6 n) by Chan [7], and to O(log5 n) by Kaplan et al. [30].
Because of the high complexities of these methods, researchers
have also looked at the problem of finding approximate nearest
neighbors in dynamic point sets. For example, dynamic versions of
quadtrees and k-d trees are known (e.g., see [41]), and Eppstein et
al. [18] introduce a dynamic skip-quadtree data structure, which
can answer approximate nearest neighbor queries and updates in
logarithmic time.
The variant of the dynamic nearest neighbor problem that we
study, on planar graph metrics, falls into the area of dynamic graph
algorithms, which has been the subject of extensive study [15]. In
particular, there has been much research on closely related prob-
lems of maintaining shortest paths and shortest path distances in
dynamic graphs [3, 5, 6, 10–12, 21, 31, 39]. However, this work
has primarily focused on edge insertion and edge deletion updates
rather than the vertex subset updates that we study. An exception
is the work of Eppstein on maintaining a dynamic subset of vertices
in a sparse graph and keeping track of whether it is a dominating
set [14], but this is a very different problem from the nearest neigh-
bor problem that we study here. To the best of our knowledge, no
one has considered the problem of maintaining a nearest-neighbor
data structure for graphs subject to the insertion and removal of
sites.
The stable matching problem, which is also known as the stable
marriage problem, was introduced by Gale and Shapley [22]. This
problem was originally described in terms of matching n men and
n women based on each person having an ordered preference list
for the members of the opposite sex in this group. In that context,
stability means that no man–woman pair prefer each other to their
assigned choices. Stability, defined in this way, is a necessary condi-
tion (and more important than, e.g., total utility) in order to prevent
extramarital affairs. When generalized to the one-to-many case, this
3
, , D. Eppstein et al.
problem is also called the college admission problem [40], because
it models a setting where n students are stably matched to k < n
colleges, each with a certain quota of admissions. Indeed, solutions
to this one-to-many stable matching problem are currently used to
match medical students to residency programs in some countries,
such as the US.
The standard algorithm used today for computing a stable match-
ing with arbitrary preferences is the original Gale–Shapley algo-
rithm [22]. This algorithm finds a stable matching in time O(nk) in
the one-to-many (college admission) case or in O(n2) time in the
one-to-one (men and women) case. Moreover, these running times
are the best possible for arbitrary preferences, since just reading
the input in the one-to-many case requires Ω(nk) time and Ω(n2)
time in the one-to-one case. Intuitively, the one-to-one version of
their algorithm involves each man making proposals to women
according to his preference order and each woman accepting a
proposal if it is her first or if it offers her a better match based on
her preference order.
Existing research about stable matching studies variations such
as matching with added constraints [33], preferences with ties [27],
and many more, e.g., see [28, 35]. However, the assumption that
preferences are arbitrary has rarely been challenged. A first step in
this direction was taken by Hoffman et al. [26], who considered the
mathematical properties of a stable matching in a geometric setting,
where “colleges” are points in R2 and “students” are all the points
in R2, and both use distances as preferences. Eppstein et al. [17]
extended their approach to images, where “students” and “colleges”
are pixels, but their work does not extend to general graphs and
road networks.
2 SYMMETRIC STABLE MATCHING
We present the symmetric stable matching problem in the one-to-
many context of schools and students, and therefore all the results
in this section also apply to the one-to-one case of men and women.
In order to formulate the symmetric stable matching problem,
consider this alternative but equivalent definition of the stable
matching problem. Each agent (school or student) gives a unique
score to each agent from the other set, and ranks them in increasing
order of these scores. Therefore, a set of scores such as (a ← 7,b ←
2, c ← 10) corresponds to the list of preferences (b,a, c).
We call the preferences symmetric if the score of x for y equals
the score of y for x . Moreover, in this case, we call these scores
distances.
Definition 2.1. A stable matching problem is symmetric if the
preferences are symmetric.
2.1 Mutual closest pair algorithm
Before introducing our nearest-neighbor chain algorithm for sym-
metric stable matching, we describe a simplified version of it, the
mutual closest pair algorithm.
Definition 2.2. In a stable matching problem, a mutual closest
pair is a school and a student who have each other as first choice.
The algorithm is based on the following lemma:
Lemma 2.3. If preferences are symmetric, a mutual closest pair
always exists.
Proof. Let s and x be the student and school whose distance is
the global minimum, that is, no other school and student are closer
to each other than s and x . Then, s and x are a mutual closest pair:
s is the closest student to x , and x is the closest school to s . □
Although the pair realizing the global minimum distance are
always a mutual closest pair, the reverse is not true: there can be
other mutual closest pairs whose distance is not a global minimum.
Moreover, Lemma 2.3 and its proof require that the distances on
which we are basing preferences be symmetric. If they are not
symmetric, as may be the case for shortest path distances in a
directed graph, then there might not be any mutual closest pairs.
Now we describe our symmetric stable matching algorithm:
Algorithm 1. Mutual closest pair algorithm
Input: n students andm schools with symmetric preferences,
and school quotas adding up to n.
Output: a stable matching between the students and schools.
(1) Initialize the matching empty.
(2) Repeat while there is an unmatched student:
(a) Find a mutual closest pair s,x .
(b) Match s and x , remove the student from the pool of
unmatched students, reduce the quota of the school
by one and remove it from the pool of unmatched
schools if its the quota reached zero.
Due to Lemma 2.3, the algorithm will never fail to find a closest
mutual pair. Next, we prove that the resulting matching is stable,
that is, that there are no blocking pairs (a student and a school
that are not matched to each other but prefer each other to their
assigned choices).
Theorem 2.4. Algorithm 1 finds a stable solution to any symmetric
stable matching problem.
Proof. Suppose student s is matched to school x , but she prefers
school y. When s and x were matched by the algorithm, x was the
closest school to s , soy already had quota zero. Therefore,ymatched
all of its students while s was not matched yet. But y was matched
with students other than s , who must have been closer to y than s .
Hence, s and y are not a blocking pair. □
Lemma 2.5. If s and x are a mutual closest pair of a symmetric
stable matching problem, then every stable solution to the problem
must match s to x .
Proof. If s and x were each matched to someone other than
each other, they would form an unstable pair. □
Theorem 2.6. Any symmetric stable matching problem has a
unique solution, which will be found by any instance of Algorithm 1.
Proof. Let S be any solution to the problem; at least one solution
S exists by Theorem 2.4. Let s and x be a mutual closest pair, which
must exist by Lemma 2.3. By Lemma 2.5, s and x are matched to
each other in S . Because Algorithm 1 is guaranteed to find a correct
solution (Theorem 2.4 again), it necessarily matches s with x , so its
behavior on s and x agrees with solution S . These two elements s
and x cannot form any mutual closest pairs with other elements,
so if we remove both of them from the given problem, we obtain a
smaller problem such that the restriction of S to the smaller problem
4
Defining Districts via Stable Matching , ,
is still stable and such that the restriction of Algorithm 1 to the
smaller problem agrees with its behavior on the whole problem.
The result follows by induction on the size of the problem. □
Eeckhout [13] stated a sufficient condition for a unique solution
in one-to-one stable matchings. It can be shown that symmetric
preferences satisfy this condition, and hence uniqueness also fol-
lows from their result in the one-to-one case.
Algorithm 1 leaves open how to actually find a mutual closest
pair, but any strategy that finds mutual closest pairs will work
correctly. Although different strategiesmay choose thematches that
they make in different orderings, and may take different running
times, they will always produce the same overall matching. In the
next section, we present one strategy for quickly finding mutual
closest pairs by making use of of a dynamic nearest-neighbor data
structure. This data structure should be able to maintain a set of
agents of the same type (students or schools) and answer queries
asking for the closest one to a query agent of the opposite set.
Moreover, it should support deletions, that is, allow to remove
elements from the set.
2.2 Nearest-neighbor chain algorithm
The following algorithm, which we call the Nearest-neighbor chain
algorithm, is based on the theory of hierarchical clustering [4, 29],
and was first used in the context of stable matching (for grid-based
geometric data only) in [17].
Algorithm 2. Nearest-neighbor chain algorithm
Input: n students andm schools with symmetric preferences,
and school quotas adding up to n.
Output: a stable matching between the students and schools.
(1) Initialize the matching empty.
(2) Initialize a dynamic nearest-neighbor structure containing
the students, and one containing the schools.
(3) Initialize an empty stack S .
(4) Repeat while there is an unmatched student:
(a) If S is empty, add any unmatched student (or school)
to it.
(b) Let p be the agent at the top of the stack, and use
the nearest-neighbor structures to find its nearest-
neighbor q of the opposite set.
(c) If q is not already in S , add it. Otherwise, q must be
the second-from-top element in S , and p and q are
a mutual closest pair. Match p and q, remove both
from the stack, reduce the quota of the school by one,
and remove the student, and the school if its quota
reached zero, from their respective nearest-neighbor
structures. If the school was below the student in the
stack and it still has positive quota, it can remain on
the stack (since it would be added again in the next
iteration).
Note that the distance between consecutive elements in S only
decreases. That’s why, in step 4.(c), q must be the second-from-top;
if q was anywhere else, p would be closer to its predecessor in S
than to q. Here we are using the fact that the preferences of each
element are distinct. In the graph setting, we may use a tie-breaking
rule to ensure that distances are unique.
Each step that adds a new element to S can be charged against a
later pop operation and its associated match. Therefore, the num-
ber of repetitions is O(n). This algorithm gives us the following
theorem.
Theorem 2.7. The symmetric stable matching problem can be
solved in O(n) query and update operations of a dynamic nearest-
neighbor data structure.
2.3 Circle-growing algorithm
As we mentioned in the introduction, the Gale–Shapley algorithm
requires O(nk) time to find a stable matching between n nodes and
k centers. However, in the graph setting first we need to compute
the preferences, that is, the shortest-path distances between every
center and node. These preferences can be computed by applying
a single-source shortest-path algorithm starting from each center,
such as Dijkstra’s algorithm. The running time for applying Dijk-
stra’s algorithm k times on a graph withm edges and n vertices,
using a Fibonacci heap based implementation of Dijkstra’s algo-
rithm, would beO(k(m+n logn)), e.g., see [8]. In planar graphs, this
could be improved to O(kn) by replacing Dijkstra’s algorithm with
the linear-time algorithm from Henzinger et al. [25]. Therefore, the
time for this preference computation step matches or dominates
the time for performing the Gale–Shapley algorithm.
However, with the following alternative algorithm it is not nec-
essary to compute the distances between all centers and nodes, and
we can do without a separate Gale–Shapley phase of the algorithm
altogether. Instead, we perform the assignment steps of the solu-
tion as part of k instances of Dijkstra’s algorithm, allowing us to
stop each instance earlier once its quota is met. The algorithm is
analogous to the circle-growing method, a geometric algorithm for
a continuous variant of stable grid matching described by Hoffman
et al. [26]. It can be visualized as a process in which we grow circles
from each center, all at the same speed, and match each node to the
first circle that grows across it.
We start k instances of Dijkstra’s algorithm at the same time, one
from each center. We explore, at each step, the next closest node
to any of the centers, advancing one of the instances of Dijkstra’s
algorithm by a single step. We match each node to the center whose
instance of Dijkstra’s algorithm reaches it first. Note that when an
instance of Dijkstra’s algorithm, starting from center c , reaches a
node x that has not already been matched, then c and x must be
the global closest pair (omitting already matched pairs). We halt
each instance of Dijkstra’s algorithm as soon as its center reaches
its quota. This stopping condition prevents wasted work in which
an instance of Dijkstra’s algorithm explores nodes farther than
its farthest matched node. In addition, using this method to solve
symmetric stable matching problems allows us to avoid running
the Gale–Shapley algorithm afterwards.
There are several alternatives for implementing the parallel in-
stances of Dijkstra’s algorithm, all of which result in a running
time of O(k(m + n logn)) for arbitrary graphs and O(kn logn) for
planar graphs. For instance, we can use a priority queue of centers
to decide which instance of Dijkstra’s algorithm should advance in
each step, or we can merge the priority queues of all the instances
of Dijkstra’s algorithm into a single larger priority queue, which is
then implemented using a Fibonacci heap.
5
, , D. Eppstein et al.
3 DYNAMIC NEAREST-NEIGHBORS FOR
PLANAR GRAPHS
Next, we present the dynamic nearest-neighbor structure for graphs.
By combining this data structure with Theorem 2.7, we observe
that the stable graph matching problem in planar graphs can be
solved in O(n
√
n logn) time.
In the query version of the classic post-office problem, we have
a set P of points in the plane and, given a query point q, we want
to know which point in P is the closest one to q. The query version
comes from the application where q is a residence that needs to
locate its closest post office, which are located at the points in P .
However, modeling post offices and residences as points in the plane
is quite artificial because in a real setting, buildings are part of a
road network. Therefore, we present a dynamic nearest-neighbor
data structure for planar graphs and road networks. More precisely,
our data structure works for the graphs in any hereditary graph
family in which n-vertex graphs have O(
√
n)-vertex separators.
A separator in a given n-vertex graph is a subset S of nodes
such that the removal of S (and its incident edges) partitions the
remaining graph into two disjoint subgraphs (with no edges from
one to the other), each of size at most 2n/3. It is allowed for these
subgraphs to be disconnected; that is, removing S can partition the
remaining graph into more than two connected components, as
long as those components can be grouped into two subgraphs that
are each of size at most 2n/3. The planar separator theorem [34]
states that planar graphs have separators of sizeO(
√
n). While road
networks are not quite planar [16], they also have separators of
size O(
√
n) [19]. A separator hierarchy is the result of recursively
subdividing a graph by using separators.
To formally define the dynamic nearest-neighbor problem, we
are given an undirected graph G = (V ,E) with nonnegative edge
weights, from a graph family in which we can find separators of
size O(
√
n), and we are also given subset of the graph nodes P ⊆ V
which we call sites. We are required to construct a data structure
that can handle both queries and updates. A query is given as an
argument a query node q ∈ V , and should return the closest site
to q. An update does not change the underlying graph, but can add
or remove a node to or from the subset of sites. The data structure
that we will describe requiresO(n
√
n) space and can be constructed
in O(n
√
n logn) preprocessing time. It supports queries in O(
√
n)
time and updates to the set P in O(
√
n logn) time.
3.1 Preprocessing
The preprocessing stage of our data structure consists of two phases.
The first phase does not depend on the choice of the subset P of
sites, while the second phase incorporates our knowledge of P into
the data structure.
P-independent phase. We build a separator hierarchy of the
graph: a binary tree where the root is the graphG itself and
its children are the corresponding hierarchies of the two
disjoint subgraphs produced by removing some separator
S ofG . In planar graphs, this hierarchy can be constructed
in O(n) time and space [23]. For each graph in this hierar-
chy, we also compute the shortest-path distance from each
separator node to all the nodes. This computation can be
represented as a collection of single-source shortest-path
problems, one for each separator node.
Each single-source shortest path problem can be solved
in planar graphs in O(n) time when edge weights are non-
negative [25]. The same algorithm applies more generally
to graphs that have a separator hierarchy. Therefore, the
time to compute shortest-path distances at the top level
of the hierarchy is O(n
√
n). We can analyze the time to
compute these distances at all levels of the hierarchy by
the recurrence
T (n) = T (x) +T (y) +O(n
√
n),
where x and y are the sizes of two subgraphs, chosen so
that x + y ≤ n, max(x ,y) ≤ 2n/3, and (among x and y
obeying these constraints) so thatT (x)+T (y) is maximum.
The recurrence is dominated by its top-level O(n
√
n) term,
and has a solution that is also O(n
√
n).
P-dependent phase. For each subgraph H in the separator
hierarchy, and each separator node s in H , we store a pri-
ority queue Qs . The elements stored in Qs are the sites
that belong to H , and their priorities are their distances
from s . If we implement the priority queue as a binary heap,
constructing each queue Qs takes linear time. Thus, the
time at the top level of the hierarchy is linear per separator
node, and the total time analysis of this phase is O(n
√
n)
as before.
Adding the space and time for the two phases together gives
O(n
√
n) for planar graphs, or for other graphs on which we use the
linear-time separator-hierarchy based shortest path algorithm. If
we instead use the simpler Dijkstra’s algorithm to compute short-
est paths, the running time becomes the slightly slower bound of
O(n
√
n logn), plus the time to compute a separator.
3.2 Queries
Given a query node q, we find two sites: the closest site to q with
(a) paths restricted to the same side of the partition as q and (b)
paths containing at least one separator node. The paths considered
in both cases cover all possible paths, so one of the found sites will
be the overall closest site to q (or one of them, in case of a tie).
• To find the site satisfying condition (a), we can relay the
query to the subgraph of the separator hierarchy contain-
ing q. This satisfies the invariant that the query node is a
node of the graph. We only have this case when q is not a
separator node.
• To find the site satisfying condition (b), we need the short-
est path fromq to any site, but only among paths containing
separator nodes. Note that if a shortest path goes through a
separator s , it should end at the site closest to s . Therefore,
the length of the shortest path starting at q, going through
s , and ending at any site, is d(q, s) + d(s,min(Qs )), where
min(Qs ) denotes the element with the smallest key in Qs .
We can find the site satisfying condition (b) by considering
all the separator nodes and retaining the one minimizing
this sum.
6
Defining Districts via Stable Matching , ,
The time to find paths of type (b) isO(
√
n), since there areO(
√
n)
separator nodes to check and each takes constant time, as we pre-
computed all the distances we need. Therefore, the time to find all
paths of types (a) and (b) can be analyzed by the recurrence
T (n) ≤ T (2n/3) +O(
√
n),
where the T (2n/3) bound dominates the actual time for recursing
in a single subgraph of the separator hierarchy. The solution to this
recurrence is O(
√
n), and therefore the time per query is O(
√
n).
3.3 Updates
Suppose that we wish to add or remove a node p from the set of
sites P . Note that, when we perform such an update, the structures
computed during the P-independent preprocessing phase of con-
structing our data structure do not change, as they do not depend on
the choice of P . However, we will need to updateQs for every node
s in the top-level separator S, by adding or removing p (according
to whether we are adding it to or removing it from P respectively).
Moreover, ifp is not inS, it will belong to one of the two recursive
subgraphs in the separator hierarchy. In this case, we also need to
update the data structure for the subgraph containing p recursively,
since p will appear in the priority queues of the separator nodes in
that subgraph.
The time to add or remove p in all top-level priority queues is
O(logn) per priority queue, for a total time of O(
√
n logn) at the
top level. Again, if we formulate and solve a recurrence for the
running time at all levels of the separator hierarchy, this time will
be dominated by the top level time, giving a total time ofO(
√
n logn)
per update. Thus, by Theorem 2.7, we have the following.
Theorem 3.1. The symmetric stable matching problem can be
solved for planar graphs or undirected road networks inO(n
√
n logn)
time.
3.4 Improvements and extensions
We remark that our dynamic nearest neighbor data structure can be
extended to directed graphs. The only required change is to compute
distances from and to every separator node. To obtain the latter, we
can use Dijkstra’s algorithm in the reverse graph. However, we do
not know how to apply this data structure in directed versions of
stable graph matching, because we do not have an extension of the
nearest-neighbor chain algorithm to directed graphs.
As another remark, it would be possible to modify our data
structure by, for each separator vertex s , replacing the distances
from s to all other nodes by the ranks of these distances in the
sorted list of distances. That is, if the set of distances in sorted order
from s to the other nodes are
d1,d2,d3, . . .
with d1 < d2 < d3 < · · · , we could replace these numbers by the
numbers
1, 2, 3, . . .
without changing the comparison between any two distances. This
replacement would allow us to use a faster integer priority queue,
such as a van Emde Boas tree [42], in place of the binary heap
representation of each priority queueQs . However, we omit the de-
tails, as the total time to sort the distances,O(n
√
n logn) (assuming
Table 1: Runtime in seconds of the algorithms in the
Delaware road network (n = 48812,m = 60027). Each data
point is the average of 10 runs with 10 sets of random cen-
ters (the same sets for all the algorithms). A dash indicates
that the algorithm ran out of memory.
k GSN GSC CG NNC
2 0.11 0.09 0.06 19.35
4 0.15 0.15 0.06 19.14
8 0.30 0.30 0.10 18.94
16 0.64 0.60 0.16 18.85
32 1.32 1.14 0.17 18.49
64 2.82 2.24 0.29 17.60
128 6.96 4.77 0.43 19.09
256 15.18 9.87 0.59 18.59
512 — — 0.86 17.25
1024 — — 1.13 17.61
2048 — — 1.78 17.95
4096 — — 2.75 18.38
8192 — — — 21.47
16384 — — — 23.95
a comparison sort) would dominate the total running time of the
stable graph matching algorithm based on this data structure pre-
venting the faster time per priority queue operation from providing
any asymptotic speedup to the whole algorithm.
4 EXPERIMENTS
In this section we present an empirical comparison of the Gale–
Shapley algorithm, circle-growing algorithm, and nearest-neighbor
chain algorithm on real-world road network data. Figure 2 and its
associated Table 1 illustrate the main findings.
4.1 Experiment setup
We implemented the various symmetric stable matching algorithms
of our comparison in Java 8. We then executed them and timed
them as run on an Intel Core CPU i7-3537U 2.00GHz with 4GB of
RAM, under Windows 10.
In the table and figures presenting our experimental results,
we use the label CG for the circle-growing algorithm and NNC
for the nearest-neighbor chain algorithm. For Gale–Shapley, we
consider a variationGSC where the centers do the proposals (which
corresponds to the role of the men in the original algorithm), and
the alternative GSN where the nodes do the proposals.
4.2 Results
Figure 2 shows a clear picture of the respective algorithms’ strengths
and weaknesses:
• The Gale–Shapley algorithm, with a runtime ofO(kn logn),
scales linearly with k . Moreover, because of the memory re-
quirement ofΘ(nk), we could not run it with large numbers
of centers. The version of Gale–Shapley where nodes pro-
pose (GSN ) was about 50% slower than the version where
centers propose. This is explained by the fact that, when
nodes propose, each center needs to keep track of its least
7
, , D. Eppstein et al.
GSC
GSN
CG
NNC
DC State
T
im
e 
(s
)
0
1
2
3
4
5
6
7
k
2 4 8 16 32 64 12
8
25
6
51
2
10
24
20
48
40
96
GSC
GSN
CG
NNC
DE State
0
5
10
15
20
25
k
2 4 8 16 32 64 12
8
25
6
51
2
10
24
20
48
40
96
81
92
16
38
4
Figure 2: Comparison of the running time of the algorithms in the Washington, DC (left, n = 9522,m = 14850) and Delaware
(right, n = 48812,m = 60027) road networks from the DIMACS database [9] for a range of number of centers k (in a logarithmic
scale). Each data point is the average of 10 runs with 10 sets of random centers (the same sets for all the algorithms).
preferred already-matched node. This node may need to be
rejected if the center receives a preferable proposition from
another node. We maintain these least-preferred matched
nodes by using a binary heap of nodes for each center;
however, the overhead of maintaining this heap adds to
the running time of our implementation. In contrast, when
centers propose, each node needs to keep track only of a
single match, so we do not need to use an additional binary
heap for this purpose.
• Our circle-growing algorithm was the fastest of our imple-
mented algorithms in practice, over the range of values of k
for which we could run it. It is also the only algorithm that
could complete a solution for the largest road networks
that we tested. For instance, on the Texas road network,
which has over 2 million nodes, the algorithm finishes in
3 seconds when given 6 random centers; our other imple-
mentations could not solve instances this large. We did not
see significant differences in the runtime between differ-
ent ways to implement the parallel instances of Dijkstra’s
algorithm.
• Additionally, in contrast to the Gale–Shapley algorithm,
the runtime of circle-growing did not appear to be strongly
affected by the value of k . The reason for this is that, even
though the algorithm runs k instances of Dijkstra’s algo-
rithm, the expected number of nodes that each instance ex-
plores decreases as k increases. However, this phenomenon
may only be valid in expectation with randomly located
centers.
• Our nearest-neighbor chain algorithm, with a runtime of
O(n
√
n logn), is the only one with a runtime independent
of k . Hence, it has a flat curve in the plots. The Gale–
Shapley curve and the nearest-neighbor chain curve cross
in our experimental data at around k ≈ 4
√
n, showing
that the constant factors in our implementation of the
nearest-neighbor chain algorithm are reasonable. More-
over, because of its memory requirement of O(n
√
n), the
nearest-neighbor chain algorithm is the only algorithm
that was able to complete a solution for the entire range
of values of k on all inputs that were small enough for it
to run at all. For instance, in the Delaware road network,
the Gale–Shapley algorithm ran out of memory at k = 256,
and the circle-growing algorithm ran out of memory at
k = 8192, but the nearest-neighbor chain algorithm was
unaffected by the choice of k .
• One factor that could affect the runtime of the nearest-
neighbor data structure used in this algorithm is the choice
of separators. Here, rather than implementing a full planar
separator algorithm to find these separators, we choose
the smallest of two simply-determined separators: the ver-
tical and horizontal lines partitioning the nodes into two
equal subsets. Our past experiments on the transversal
complexity in road networks [19] indicate that straight-
line traversals of road networks should provide separators
with low complexity, making it unnecessary to incorporate
the extra complexity of a full planar graph separator algo-
rithm. However, it may be of interest in future experiments
to compare the benefits of a simpler but lower-quality sep-
arator construction algorithm versus a slower and more
complicated but higher-quality separator construction al-
gorithm.
5 CONCLUSIONS
We have defined the symmetric stable matching problem, a sub-
family of stable matching problems which arise naturally when
preferences are determined by distances. We studied its basic prop-
erties and provided the mutual closest pair algorithm, which has
the potential to be faster than the Gale–Shapley algorithm. Future
researchers should consider the algorithms in this paper if they
identify that a matching problem has symmetric preferences. As
8
Defining Districts via Stable Matching , ,
a special case of symmetric stable matching, we defined the sta-
ble graph matching problem. For this problem, we compared (a)
the Gale–Shapley algorithm, (b) the mutual closest pair algorithm,
which used our novel dynamic nearest-neighbor data structure
for planar graphs, and (c) the circle-growing algorithm, a heuristic
improvement over the Gale–Shapley algorithm.
This work leaves open several questions for future research:
• We know of two settings where symmetric stable matching
arises naturally: the geometric and graph-based cases. In
what other settings does it arise?
• What other applications could a dynamic nearest-neighbor
structure for graphs have?
• Our dynamic nearest-neighbor structure for planar graphs
and road networks is simple to implement, and fast enough
for our purposes. However, it seems possible that data
structures with better theoretical running times exist –
perhaps even polylogarithmic in n.
• Moreover, it would be interesting to design an equivalent
structure for dense graphs, efficient in terms of the number
of nodes as well as edges.
• The experiments show that the circle-growing algorithm
scales much better with k than the Gale–Shapley algo-
rithm when centers are placed randomly. However, in the
worst case both are θ (kn logn). For instance, the circle-
growing algorithm achieves this worst-case behavior when
the graph is just a path and the k centers are located at the
first k nodes. Can the circle-growing algorithm be shown
to have a better expected complexity when centers are
placed randomly?
• As Figure 1 illustrates, the regions given by the solution
to an instance of the stable graph matching problem are
not necessarily connected. In many applications, such as
political districting [38], it is necessary to have connected
regions. Because stable graph matching has a unique so-
lution, achieving connectivity will require a relaxation of
the stability property, or a better-optimized choice of the
center locations. We leave these for future work.
ACKNOWLEDGMENTS
This article reports on work supported by the DARPA under agree-
ment no. AFRL FA8750-15-2-0092. The views expressed are those
of the authors and do not reflect the official policy or position of
the Department of Defense or the U.S. Government. This work was
also supported in part from NSF grants 1228639, 1526631, 1217322,
1618301, and 1616248.
REFERENCES
[1] Pankaj K. Agarwal, David Eppstein, and Jiří Matoušek. 1992. Dynamic half-space
reporting, geometric optimization, and minimum spanning trees. In Proc. 33rd
Symp. Foundations of Computer Science. IEEE Computer Society, Los Alamitos,
CA, 80–89. https://doi.org/10.1109/SFCS.1992.267816
[2] Franz Aurenhammer. 1991. Voronoi diagrams—A survey of a fundamental
geometric data structure. Comput. Surveys 23, 3 (1991), 345–405. https:
//doi.org/10.1145/116873.116880
[3] Giorgio Ausiello, Giuseppe F. Italiano, Alberto Marchetti-Spaccamela, and Um-
berto Nanni. 1991. Incremental algorithms forminimal length paths. J. Algorithms
12, 4 (1991), 615–638. https://doi.org/10.1016/0196-6774(91)90036-X
[4] Jean-Paul Benzécri. 1982. Construction d’une classification ascendante hiérar-
chique par la recherche en chaîne des voisins réciproques. Les Cahiers de l’Analyse
des Données 7, 2 (1982), 209–218. http://www.numdam.org/item?id=CAD_1982_
_7_2_209_0
[5] Luciana S. Buriol, Mauricio G. C. Resende, and Mikkel Thorup. 2008. Speeding
up dynamic shortest-path algorithms. INFORMS J. Comput. 20, 2 (2008), 191–204.
https://doi.org/10.1287/ijoc.1070.0231
[6] Edward P. F. Chan and Yaya Yang. 2009. Shortest path tree computation in
dynamic graphs. IEEE Trans. Comput. 58, 4 (2009), 541–557. https://doi.org/10.
1109/TC.2008.198
[7] Timothy M. Chan. 2010. A dynamic data structure for 3-d convex hulls and 2-d
nearest neighbor queries. J. ACM 57, 3 (2010), 16:1–16:15. https://doi.org/10.
1145/1706591.1706596
[8] Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.
2001. Introduction to Algorithms (2nd ed.). McGraw-Hill, New York, NY, USA.
[9] Camil Demetrescu, AndrewV. Goldberg, andDavid S. Johnson. 2006. 9thDIMACS
Implementation Challenge: Shortest Paths. (2006). http://www.dis.uniroma1.it/
~challenge9/
[10] Camil Demetrescu and Giuseppe F. Italiano. 2004. A new approach to dynamic
all pairs shortest paths. J. ACM 51, 6 (2004), 968–992. https://doi.org/10.1145/
1039488.1039492
[11] Camil Demetrescu and Giuseppe F. Italiano. 2006. Experimental analysis of
dynamic all pairs shortest path algorithms. ACM Trans. Algorithms 2, 4 (2006),
578–601. https://doi.org/10.1145/1198513.1198519
[12] Hristo N. Djidjev, Grammati E. Pantziou, and Christos D. Zaroliagis. 1995. On-
line and dynamic algorithms for shortest path problems. In Proc. 12th Annual
Symposium on Theoretical Aspects of Computer Science (STACS 1995). Lecture
Notes in Computer Science, Vol. 900. Springer, Berlin, 193–204. https://doi.org/
10.1007/3-540-59042-0_73
[13] Jan Eeckhout. 2000. On the uniqueness of stable marriage matchings. Economics
Letters 69, 1 (2000), 1 – 8. https://doi.org/10.1016/S0165-1765(00)00263-9
[14] David Eppstein. 2009. All maximal independent sets and dynamic dominance
for sparse graphs. ACM Transactions on Algorithms 5, 4 (2009), Art. 38. https:
//doi.org/10.1145/1597036.1597042
[15] David Eppstein, Zvi Galil, and Giuseppe F. Italiano. 2010. Dynamic graph algo-
rithms. In Algorithms and Theory of Computation Handbook (2nd ed.), Mikhail J.
Atallah (Ed.). CRC Press, Boca Raton, Florida, 9.1–9.28. http://www.info.uniroma2.
it/~italiano/Papers/dyn-survey.ps.Z
[16] David Eppstein and Michael T. Goodrich. 2008. Studying (non-planar) road net-
works through an algorithmic lens. In Proc. 16th ACM SIGSPATIAL International
Conference on Advances in Geographic Information Systems (GIS ’08). ACM, New
York, NY, USA, 16:1–16:10. https://doi.org/10.1145/1463434.1463455
[17] David Eppstein, Michael T. Goodrich, and Nil Mamano. 2017. Algorithms for
stable matching and clustering in a grid. In Proc. 18th International Workshop
on Combinatorial Image Analysis (IWCIA 2017), Plovdiv, Bulgaria, 2017 (Lecture
Notes in Computer Science), Vol. 10256. Springer, Berlin, 117–131. https://doi.org/
10.1007/978-3-319-59108-7_10
[18] David Eppstein, Michael T. Goodrich, and Jonathan Z. Sun. 2008. Skip quadtrees:
Dynamic data structures for multidimensional point sets. Int. J. Comp. Geom. &
Appl. 18, 1-2 (2008), 131–160. https://doi.org/10.1142/S0218195908002568
[19] David Eppstein, Michael T. Goodrich, and Lowell Trott. 2009. Going off-road:
Transversal complexity in road networks. In Proc. 17th ACM SIGSPATIAL Interna-
tional Conference on Advances in Geographic Information Systems (GIS ’09). ACM,
New York, NY, USA, 23–32. https://doi.org/10.1145/1653771.1653778
[20] Martin Erwig. 2000. The graph Voronoi diagramwith applications. Networks 36, 3
(2000), 156–163. https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>
3.0.CO;2-L
[21] Daniele Frigioni, Alberto Marchetti-Spaccamela, and Umberto Nanni. 2000. Fully
dynamic algorithms for maintaining shortest paths trees. J. Algorithms 34, 2
(2000), 251–281. https://doi.org/10.1006/jagm.1999.1048
[22] David Gale and Lloyd S. Shapley. 1962. College admissions and the stability
of marriage. The American Mathematical Monthly 69, 1 (1962), 9–15. https:
//doi.org/10.2307/2312726
[23] Michael T. Goodrich. 1995. Planar separators and parallel polygon triangulation.
J. Comput. System Sci. 51, 3 (1995), 374–389. https://doi.org/10.1006/jcss.1995.1076
9
, , D. Eppstein et al.
[24] Michael T. Goodrich and Roberto Tamassia. 2014. Algorithm Design and Applica-
tions (1st ed.). Wiley, Hoboken, NJ.
[25] Monika R. Henzinger, Philip Klein, Satish Rao, and Sairam Subramanian. 1997.
Faster shortest-path algorithms for planar graphs. J. Comput. System Sci. 55, 1
(1997), 3–23. https://doi.org/10.1006/jcss.1997.1493
[26] Christopher Hoffman, Alexander E. Holroyd, and Yuval Peres. 2006. A stable
marriage of Poisson and Lebesgue. Annals of Probability 34, 4 (2006), 1241–1272.
https://doi.org/10.1214/009117906000000098
[27] Robert W. Irving. 1994. Stable marriage and indifference. Discrete Applied
Mathematics 48, 3 (1994), 261–272. https://doi.org/10.1016/0166-218X(92)00179-P
[28] Kazuo Iwama and Shuichi Miyazaki. 2008. A survey of the stable marriage
problem and its variants. In International Conference on Informatics Education
and Research for Knowledge-Circulating Society (ICKS 2008). IEEE Computer
Society, Los Alamitos, CA, 131–136. https://doi.org/10.1109/ICKS.2008.7
[29] J. Juan. 1982. Programme de classification hiérarchique par l’algorithme de la
recherche en chaîne des voisins réciproques. Les Cahiers de l’Analyse des Données
7, 2 (1982), 219–225. http://www.numdam.org/item?id=CAD_1982__7_2_219_0
[30] Haim Kaplan, Wolfgang Mulzer, Liam Roditty, Paul Seiferth, and Micha Sharir.
2017. Dynamic planar Voronoi diagrams for general distance functions and their
algorithmic applications. In Proc. 28th ACM-SIAM Symposium on Discrete Algo-
rithms (SODA 2017). Society for Industrial and AppliedMathematics, Philadelphia,
PA, 2495–2504. https://doi.org/10.1137/1.9781611974782.165
[31] Valerie King. 1999. Fully dynamic algorithms for maintaining all-pairs shortest
paths and transitive closure in digraphs. In Proc. 40th Annual Symp. on Foun-
dations of Computer Science (FOCS 1999). IEEE Computer Society, Los Alamitos,
CA, 81–89. https://doi.org/10.1109/SFFCS.1999.814580
[32] Donald E. Knuth. 1998. The Art of Computer Programming, Vol. 3: Sorting and
Searching (2nd ed.). Addison-Wesley, Reading, MA.
[33] Fuhito Kojima, Parag A. Pathak, and Alvin E. Roth. 2010. Matching with couples:
Stability and incentives in large markets. Working Paper 16028. National Bureau
of Economic Research. https://doi.org/10.3386/w16028
[34] Richard J. Lipton and Robert Endre Tarjan. 1979. A separator theorem for planar
graphs. SIAM J. Appl. Math. 36, 2 (1979), 177–189. https://doi.org/10.1137/0136016
[35] David F. Manlove, Robert W. Irving, Kazuo Iwama, Shuichi Miyazaki, and Ya-
sufumi Morita. 2002. Hard variants of stable marriage. Theoretical Computer
Science 276, 1 (2002), 261–279. https://doi.org/10.1016/S0304-3975(01)00206-7
[36] Richard G. Niemi and John Deegan. 1978. A Theory of Political Districting.
American Political Science Review 72, 4 (1978), 1304ÔÇô–1323. https://doi.org/10.
2307/1954541
[37] Charles S. ReVelle and H. A. Eiselt. 2005. Location analysis: A synthesis and
survey. European Journal of Operational Research 165, 1 (2005), 1–19. https:
//doi.org/10.1016/j.ejor.2003.11.032
[38] Federica Ricca, Andrea Scozzari, and Bruno Simeone. 2008. Weighted Voronoi
region algorithms for political districting. Mathematical and Computer Modelling
48, 9-10 (2008), 1468–1477. https://doi.org/10.1016/j.mcm.2008.05.041
[39] Liam Roditty and Uri Zwick. 2011. On dynamic shortest paths problems. Algo-
rithmica 61, 2 (2011), 389–401. https://doi.org/10.1007/s00453-010-9401-5
[40] Alvin E. Roth and Marilda Sotomayor. 1989. The college admissions problem
revisited. Econometrica 57, 3 (1989), 559–570.
[41] Hanan Samet. 1990. The Design and Analysis of Spatial Data Structures. Addison-
Wesley, Reading, MA.
[42] Peter van Emde Boas. 1975. Preserving order in a forest in less than logarithmic
time. In 16th IEEE Symposium on Foundations of Computer Science (FOCS). IEEE
Computer Society, Los Alamitos, CA, 75–84. https://doi.org/10.1109/SFCS.1975.26
A ADDITIONAL RESULTS ON ROAD
NETWORKS
In this appendix we visualize additional examples of stable graph
matchings in real road networks. Figure 3 shows the results for 6
additional US states. Figure 4 shows the same road network with
different numbers of centers.
10
Defining Districts via Stable Matching , ,
Maryland (n = 264K ,m = 315K ) New York (n = 709K ,m = 889K )
Colorado (n = 436K ,m = 529K ) Alaska (n = 49K ,m = 55K )
Florida (n = 1037K ,m = 1315K ) Delaware (n = 49K ,m = 60K )
Figure 3: The solutions to the stable graph matching problem for the 2010 road network of six US states, from the DIMACS
database [9]. They consists of primary and secondary roads in the biggest connected component of the road networks. In each
case, n andm denote the number of nodes and edges, respectively, and there are k = 6 random centers with equal quota n/k .
11
, , D. Eppstein et al.
k = 2 k = 4
k = 8 k = 16
k = 32 k = 64
Figure 4: The solutions to the stable graph matching problem for the 2010 road network of California from the DIMACS
database [9] and different numbers of centers. The road network consists of primary and secondary roads in the biggest
connected component, for a total of n = 1596K nodes andm = 1971K edges. The centers have been chosen randomly, and in
each case they have equal quota n/k . 12

