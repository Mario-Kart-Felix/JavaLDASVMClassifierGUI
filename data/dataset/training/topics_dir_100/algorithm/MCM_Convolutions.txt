PERGAMON Mathematical and Computer Modelling 0 (2004) 1–0
www.elsevier.com/locate/mcm
Algorithms for Computing the Distributions
of Sums of Discrete Random Variables
D. L. Evans∗
Department of Mathematics, Rose-Hulman Institute of Technology
Terre Haute, IN 47803, U.S.A.
diane.evans@rose-hulman.edu
L. M. Leemis
Department of Mathematics, The College of William and Mary
Williamsburg, VA 23187, U.S.A.
leemis@math.wm.edu
(Received March 2003; revised and accepted August 2004)
Abstract—We present algorithms for computing the probablity density function of the sum of two
independent discrete random variables, along with an implementation of the algorithm in a computer
algebra system. Some examples illustrate the utility of this algorithm. c© 2004 Elsevier Science Ltd.
All rights reserved.
Keywords—Computer algebra systems, Convolution, Probability.
1. INTRODUCTION
An important operation in probability theory is to calculate the distribution of the sum (convo-
lution) of two independent random variables X and Y . Applications of convolutions appear in
many areas of mathematics, probability theory, physics, and engineering. Most texts devote the
majority of their attention to convolutions of continuous random variables, rather than discrete
random variables. We focus here on the case in which X and Y are discrete random variables
with integer-valued supports.
There are several approaches for computing the probability density function (PDF) of Z =
X + Y in the discrete case. The event {X + Y = z}, z ∈ Z, can be written as the union of the
disjoint events {X = ζ, Y = z − ζ}, {X = ζ + 1, Y = z − (ζ + 1)}, . . . , {X = z − ζ, Y = ζ},
where ζ is the minimum of the union of the support values of X and Y . The PDF fZ(z) of the
convolution of the PDFs of the independent random variables X and Y (with integer supports)
can be computed as
* Author gratefully acknowledges support from the Clare Boothe Luce Foundation.
Both authors thank Lt. Col. A. Glen for the original code for continuous convolution, Dr. D. Nicol for his idea
of using heaps to compute the convolution, Dr. J. Drew for his help with the proof of the result that appears in
Appendix 1, and two referees for their helpful comments.
0895-7177/04/$ - see front matter c© 2004 Elsevier Science Ltd. All rights reserved. Typeset by AMS-TEX
PII:00
2 D. Evans and L. Leemis
Pr (Z = z) = Pr (X + Y = z)
=
z−ζ∑
k=ζ
Pr (X = k, Y = z − k)
=
z−ζ∑
k=ζ
Pr (X = k) Pr (Y = z − k) .
The following example illustrates the use of this discrete convolution formula.
Example 1. If X and Y are independent Poisson random variables with respective parameters
λ1 and λ2, compute the PDF of Z = X + Y [1, p. 267].
Solution. The PDF of a Poisson random variable X with parameter λ is fX(x) = e−λ λx/x!,
x = 0, 1, 2, . . . . Since ζ = min{0, 1, 2, . . . } = 0, then,
Pr (Z = z) = Pr (X + Y = z)
=
z∑
k=0
Pr (X = k, Y = z − k)
=
z∑
k=0
Pr (X = k) · Pr (Y = z − k)
=
z∑
k=0
e−λ1λk1
k!
· e
−λ2λ2
z−k
(z − k)!
= e−(λ1+λ2)
z∑
k=0
λ1
kλ2
z−k
k! (z − k)!
=
e−(λ1+λ2)
z!
z∑
k=0
z!
k! (z − k)!λ1
kλ2
z−k (binomial series)
=
e−(λ1+λ2)
z!
· (λ1 + λ2)z, z = 0, 1, 2, . . . .
Thus, Z = X + Y has a Poisson distribution with parameter λ1 + λ2.
If one wants to sum more than two iid random variables, then, the distribution function for Z
can be determined by induction [2, p. 286]. Let Zn = X1 + X2 + · · · + Xn be the sum of n
independent random variables with common PDF fX(x) defined on the integers. Then, the PDF
of Z1 is fX(x). We can write
Zi = Zi−1 +Xi,
for i = 2, 3, . . . , n. Thus, since we know the distribution of Xi is fX(x), for i = 1, 2, . . . , n, we
can find the distribution function of Zn by induction. When summing more than two iid random
variables, our procedure ConvolutionIID (see Examples 7 and 10 in Section 5) uses this inductive
process to compute the PDF of the convolution.
For example, let X1, X2, and X3 have PDFs fX(x) = 1/6 for x = 1, 2, . . . , 6. If Z2 = X1 +X2,
then the PDF fZ2(z) is
fZ2 (z) =

z − 1
36
, z = 2, 3, . . . , 7,
13− z
36
, z = 8, 9, . . . , 12.
The PDF of Z3 = X1 + X2 + X3 is the convolution of the PDFs of Z2 and X3. For example,
Pr(Z3 = 4) = Pr(Z2 = 3)·Pr(X3 = 1)+ Pr(Z2 = 2)· Pr(X3 = 2) = (2/36) ·(1/6)+(1/36) ·(1/6) =
(1/72).
Algorithms for Computing 3
Due to the mathematical intractability in implementing the discrete convolution formula,∑z−ζ
k=ζ Pr(X = k, Y = z − k), for certain nonidentically distributed random variables [e.g., X ∼
Poisson (λ), Y ∼ geometric (p)] and the inefficiency in making computations with this formula
for random variables with arbitrary supports (e.g., X with support {−216, −57, 23, 81} and Y
with support {−1002, −15, 2, 62, 211}), only certain convolutions can or should be computed
using this formula. For random variables with arbitrary supports, the discrete convolution for-
mula can be used, but it is often inefficient because one or both of the random variables have
support values ranging over a large domain of nonadjacent integer values. The following example
displays the inefficiency that can be encountered by using this formula, even for random variables
with only a small number of support values with nonzero probability.
Example 2. Suppose X and Y are independent discrete random variables with PDFs defined as
fX (x) =

0.15, x = −3,
0.25, x = −1,
0.1, x = 2,
0.3, x = 6,
0.2, x = 8,
fY (y) =

0.2, y = −2,
0.1, y = 1,
0.3, y = 5,
0.4, y = 8.
Compute the PDF of Z.
Solution. The support values for Z are z = {−5, −3, −2, 0, 2, 3, 4, 5, 6, 7, 9, 10, 11, 13,
14, 16}. We’ll use the formula
∑z−ζ
k=ζ Pr(X = k, Y = z − k), where ζ = −3, to compute
Pr(Z = 4).
Pr (Z = 4) =
7∑
k=−3
Pr (X = k, Y = 4− k)
= Pr (X = −3) · Pr (Y = 7) Pr (X = −2) · Pr (Y = 6)
+ Pr (X = −1) · Pr (Y = 5) Pr (X = 0) · Pr (Y = 4)
+ Pr (X = 1) · Pr (Y = 3) Pr (X = 2) · Pr (Y = 2)
+ Pr (X = 3) · Pr (Y = 1) Pr (X = 4) · Pr (Y = 0)
+ Pr (X = 5) · Pr (Y = −1) Pr (X = 6) · Pr (Y = −2)
+ Pr (X = 7) · Pr (Y = −3)
= 0.15 · 0 + 0 · 0 + 0.25 · 0.3 + 0 · 0 + 0 · 0 + 0.1 · 0
+ 0 · 0.1 + 0 · 0 + 0 · 0 + 0.3 · 0.2 + 0 · 0
= 0.135.
The probabilities for the other support values are computed similarly. Because of the tedious
calculations needed to compute the PDF of Z by the discrete convolution formula, we’ll compute
it fully in the next example using moment generating functions (MGFs).
Unlike the discrete convolution formula, the algorithm to be presented in this paper avoids
all of the zero term computations in the construction of the PDF of Z. Also, another way to
compute the PDF of Z, while avoiding the numerous zero terms, is to use the moment generating
function technique.
Example 3. Suppose X and Y are the discrete random variables defined in Example 2 and
Z = X + Y . Find the PDF of Z using the moment generating function technique [3].
Solution. Since X and Y are independent, the MGF of Z is
MZ (t) = E
(
et(X+Y )
)
4 D. Evans and L. Leemis
= E
(
etXetY
)
= E
(
etX
)
E
(
etY
)
= MX (t)MY (t) .
The MGFs of X and Y , respectively, are
MX (t) = E
(
etX
)
= 0.15e−3t + 0.25e−t + 0.1e2t + 0.3e6t + 0.2e8t
and
MY (t) = E
(
etY
)
= 0.2e−2t + 0.1et + 0.3e5t + 0.4e8t,
for −∞ < t <∞. Thus, the MGF of Z is,
MZ (t) = 0.03e−5t + 0.05e−3t + 0.015e−2t + 0.045 + 0.045e2t + 0.01e3t
+ 0.135e4t + 0.06e5t + 0.04e6t + 0.16e7t + 0.02e9t + 0.04e10t
+ 0.09e11t + 0.06e13t + 0.12e14t + 0.08e16t,
for −∞ < t <∞. Thus, the PDF of Z is:
Z = z −5 −3 −2 0 2 3 4 5 6 7 9 10 11 13 14 16
fZ(z) .03 .05 .015 .045 .045 .01 .135 .06 .04 .16 .02 .04 .09 .06 .12 .08
In complicated examples, especially those involving continuous random variables, using the
moment generating function technique to obtain convolution functions can be more efficient than
direct summation or integration. Along the same lines as the moment generating function tech-
nique, the probability generating function technique can be used for determining the PDF of
the convolution of discrete random variables with nonnegative integer-valued supports. Unfor-
tunately, the implementation of these techniques in a computer algebra system (Maple) has
drawbacks when the supports of the random variables X and/or Y are not integervalued. These
implementation issues are discussed in Section 4.
Besides the integration/summation and generating function methods already described, the
characteristic functions of independent random variables can be used to compute convolutions
[4, p. 395]. In order to use this method, though, one must know the inversion formula of the
PDF of a random variable in terms of its characteristic function. The complexity of the inversion
makes this method unappealing for complicated or arbitrary distributions.
The purpose of this paper is to present an algorithm for determining the distributions of con-
volutions of discrete random variables, especially those with finite arbitrary supports. Like the
algorithm presented in [5], our algorithm handles well-known distributions, such as the binomial
and Poisson. But, our algorithm was primarily written for arbitrary distributions with moder-
ate cardinality of their support. Computer algebra systems make it feasible to determine the
distributions of convolutions for these types of distributions.
Section 2 describes the algorithm for determining the PDF of the convolution of discrete random
variables. The algorithm that was constructed to compute this convolution appears in Section 3.
Implementation issues that arose when the algorithm was coded in a computer algebra system
are given in Section 4. Section 5 provides a collection of examples that can be solved with the
convolution algorithm.
2. CONCEPTUAL DEVELOPMENT
One way to compute the PDF of the convolution of the PDFs of two independent discrete
random variables is by what we call the “brute force method”. Let X have support x1, x2, . . . , xn
and Y have support y1, y2, . . . , ym. This method does just what the name implies—it computes
Algorithms for Computing 5
all possible sums between the support of X and the support of Y by brute force, e.g., x1 +
y1, x1 + y2, . . . , x1 + ym, x2 + y1, x2 + y2, . . . , xn + ym−1, xn + ym. The sums are placed in an
one-dimensional array, called s, of length n ·m. The corresponding probabilities for each of these
sums, fX(x1) · fY (y1), fX(x1) · fY (y2), . . . , fX(xn) · fY (ym), are stored in an one-dimensional
array called Probs, also of length n ·m. The probability in position Probsi corresponds to the
sum in position si, i = 1, 2, . . . , n ·m.
For example, let X and Y be the random variables introduced in Example 2. The arrays s and
Probs for the random variables X and Y are
s = [−5,−2, 2, 5,−3, 0, 4, 7, 0, 3, 7, 10, 4, 7, 11, 14, 6, 9, 13, 16] ,
Probs = [0.03, 0.015, 0.045, 0.06, 0.05, 0.025, 0.075, 0.1, 0.02, 0.01,
0.03, 0.04, 0.06, 0.03, 0.09, 0.12, 0.04, 0.02, 0.06, 0.08] .
We assume that s is unsorted and may contain repeated values, such as 0, 4, and 7 in this
particular example. The array s is sorted and appropriate updates are made to the corresponding
elements in the array Probs. After sorting, the arrays s and Probs are
s = [−5,−3,−2, 0, 0, 2, 3, 4, 4, 5, 6, 7, 7, 7, 9, 10, 11, 13, 14, 16] ,
Probs = [0.03, 0.05, 0.015, 0.025, 0.02, 0.045, 0.01, 0.075, 0.06, 0.06,
0.04, 0.1, 0.03, 0.03, 0.02, 0.04, 0.09, 0.06, 0.12, 0.08] .
Last, the redundancies in s are removed and the appropriate probabilities corresponding to those
redundancies are combined in Probs. The final arrays are
s = [−5,−3,−2, 0, 2, 3, 4, 5, 6, 7, 9, 10, 11, 13, 14, 16] ,
Probs = [0.03, 0.05, 0.015, 0.045, 0.045, 0.01, 0.135, 0.06, 0.04, 0.16,
0.02, 0.04, 0.09, 0.06, 0.12, 0.08] .
One algorithm we employ to sort the array s is insertion sort [6, p. 254–255]. When n · m
is small, the simplicity of insertion sort makes it an appropriate choice. The general strategy
of insertion sort is to partition the array s into two regions: sorted and unsorted. Initially, the
entire array s is considered unsorted, as already discussed. At each step, insertion sort takes the
first value in the unsorted region and places it in its correct position in the sorted region. The
entire array s will be sorted after the final element in the n ·m array position is inserted.
Unfortunately, for random variables X and Y with larger support sizes n and m, such as,
n = m = 10, insertion sort becomes inefficient. Since insertion sort is an O(N 2) algorithm, where
N = n ·m in our setting, it is not an appropriate method for sorting lists containing more than
a hundred or so elements. For this reason, another sorting algorithm, heapsort [6, p. 260–262], is
used to sort larger arrays. Heapsort uses a heap, which is a binary tree with special properties,
to sort the array s. Heapsort is an O(N · log(N)) algorithm [7, p. 430].
Heapsort builds the array s as a maximum heap data structure. It then swaps the maximum
element (the root) of the heap with the element in the last array position sn·m. The heap is rebuilt
with the remaining unsorted elements in array positions s1 through sn·m−1. Then, the maximum
element of the new heap is swapped with the element in the second to last position of the array
s, which is position sn·m−1. Now, the last two positions in s are sorted in ascending order.
The heap structure is again restored with the remaining unsorted elements in array positions s1
through sn·m−2. This swap and rebuild process repeats itself until all elements are removed from
the unsorted region of the heap and placed in ascending order from the front to the back of the
heap. Heapsort proved more efficient than insertion sort for large values of N . The respective
CPU times for a given example using insertion sort and heapsort are provided in Section 4 for
comparison.
6 D. Evans and L. Leemis
Shellsort , an improved insertion sort, is the algorithm employed by the mathematical software
package Maple to sort polynomials (Maple 9’s online help guide). Since shellsort’s “perfor-
mance is quite acceptable in practice, even for N [number of elements] in the tens of thousands”
[6, p. 260], we take advantage of Maple’s sorting algorithm for polynomials (when possible) by
using the moment generating function technique to compute the convolution of discrete random
variables. The MGFs for X and Y , which are MX(t) and MY (t) respectively, are first computed.
Next, the product of the MGFs, MZ(t), is computed. We manipulate the terms of the MGF
with Maple’s expand procedure so that they are written in a fashion that Maple interprets as
polynomials terms. For example, if the MGF is MZ(t) = (1/3)e3t + (1/6)e2t + (1/2)e5t, then
expand (MZ(t)) returns MZ(t) as 1/3(et)3 + 1/6(et)2 + 1/2(et)5. The terms of the resulting
expanded MGF are then sorted in descending order by the constant appearing in the exponent
of each et term. Sorting the example expression MZ(t) returns 1/2(et)5 + 1/3(et)3 + 1/6(et)2.
The probability and support values are extracted from the terms of the expression MZ(t), and
the PDF of the convolution is formed. The PDF for the example expression MZ(t) is
fZ(z) =

1
6
, z = 2,
1
3
, z = 3,
1
2
, z = 5.
Although in theory this is an ideal method, Maple recognizes that expressions, such as (1/3)e3.1t
+(1/6)e2.5t+ (1/2)e5.4t, are not truly polynomials and will incorrectly sort expressions with non-
integer valued constants in the exponents. Since the MGF MZ(t) may not always have integer
constants for exponents, the moment generating function technique for computing convolutions
is only reasonable to use for integer supports. Using probability generating functions to com-
pute the PDF of a convolution of random variables results in the same complications. Further
implementation issues faced by moment and probability generating functions are discussed in
Section 4.
As suggested by [8], the sum array s can be constructed in such a way that the next largest sum
element is placed in s as it is being built. Instead of constructing the array s first and then sorting
it, our algorithm constructs s by sequentially appending the next ordered element. We refer to
this method as the “moving heap method”, and it involves building, deleting, and inserting sums
into a minimum heap data structure. A minimum heap contains its smallest element in the root,
rather than its largest as in a maximum heap.
The idea behind this sorting algorithm is the construction of a two-dimensional “conceptual”
array A. The array A is not instantiated to save on memory, but is helpful in explaining the
nature of the algorithm. The array A has m+1 rows and n+1 columns. The array A, illustrated
in Example 4, is displayed in an unusual manner in order to resemble the axes in the Cartesian
coordinate system. Without loss of generality, we assume that the supports of X and Y are
arranged in increasing order; i.e., x1 < x2 < · · · < xn and y1 < y2 < · · · < ym. The array
cell (i, j) contains the sum Ai,j = yi + xj , for i = 1, 2, . . . ,m and j = 1, 2, . . . , n. The cells
in row m + 1 of A hold a 0 or 1, for each column j = 1, 2, . . . , n to indicate whether the cell
in column j is “active”, which means its entry is in the minimum heap. Thus, Am+1,j = 0
or 1, for j = 1, 2, . . . , n. Likewise, the cells in column n + 1 of A also hold a 0 or 1, for each
row i = 1, 2, . . . ,m to indicate whether the cell in row i is “active”; i.e., Ai,n+1 = 0 or 1, for
i = 1, 2, . . . ,m. The (m+ 1, n+ 1) cell is not used in the algorithm. Example 4 illustrates what
is meant by an “active” cell.
Since xj < xj+1, for j = 1, 2, . . . , n− 1 and yi < yi+1, for i = 1, 2, . . . ,m− 1, the entry in cell
(i, j) is always guaranteed to be less than both the entries in cells (i + 1, j) and (i, j + 1); i.e.,
Ai,j < Ai+1,j and Ai,j < Ai,j+1. This result, along with other properties of the array A proven
Algorithms for Computing 7
in Appendix 1, allow the algorithm to move the smallest number of candidate entries for the
next largest sum from the array A to the minimum heap. Thus, this algorithm moves from the
southwest cell to the northeast cell of the array A placing the next largest sum into s after first
placing the competing sums into a minimum heap.
Since this process and its intricacies are best explained by an example, we’ll reintroduce X
and Y , the random variables from Example 2.
Example 4. Let X and Y have PDFs:
fX(x) =

0.15, x = −3,
0.25, x = −1,
0.1, x = 2,
0.3, x = 6,
0.2, x = 8,
fY (y) =

0.2, y = −2,
0.1, y = 1,
0.3, y = 5,
0.4, y = 8.
Use the “moving heap method” to determine the PDF of Z = X + Y .
Solution. Construct the 5 × 6 array A. Set Ai,n+1 = Ai,6 = 0, for i = 1, 2, 3, 4 and Am+1,j =
A5,j = 0, for j = 1, 2, 3, 4, 5. The smallest value in A is positioned in cell (1, 1) and is A1,1 =
y1 + x1 = −5. The algorithm designates the cell (1, 1) as an “active” cell in A by setting
Am+1,1 = A5,1 = 1 and A1,n+1 = A1,6 = 1. The zeros in the other cells of row five and column
six remain. Figure 1 displays this initial array. The entries of A increase in value as one moves
up, to the right, or a combination of both (as in the Cartesian coordinate system).
 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
1 0 0 0 0
0
0
0
1
row 5
row 4
row 3
row 2
row 1  5
Figure 1. Array A with active cell (1, 1), which contains the entry A1,1 = −5.
As in the brute force method, let the one-dimensional array s of length n ·m hold the sums
of the supports of the random variables X and Y . The corresponding probabilities for each of
these sums will again be stored in the one-dimensional array called Probs, also of length n ·m.
Clearly, the first (smallest) sum to be placed in the first position of array s is A1,1. Accordingly,
fX(x1) · fY (y1) = 0.03 is placed in the Probs array in its first position, Probs1. After setting
s1 = A1,1 = −5 and Probs1 = Pr(Z = A1,1) = fX(x1) · fY (y1) = 0.03, the cell (1, 1) becomes
inactive. In order to reflect the absence of an element in the first row and first column, reset
Am+1,1 = A5,1 = 0 and A1,n+1 = A1,6 = 0. The next two cells to become “active” (i.e., these cells
may contain the next largest sum) in the array A are A1,2 = y1+x2 = −3 and A2,1 = y2+x1 = −2.
Since cell (1, 2) in A is now active, reset A1,6 = 1 and set A5,2 = 1. Similarly, since cell (2, 1) is
active, set A2,6 = 1 and reset A5,1 = 1. The purpose of these ones and zeros along the boundary
of the A array is to assure that there is no more than one active cell in each row and column.
Figure 2 contains the current state of array A.
The values A1,2 and A2,1 are used to construct a minimum heap H. Informally, a heap is a
complete binary tree with a special ordering property of its nodes. A complete binary tree is a
8 D. Evans and L. Leemis
    
    
    
    
    





 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
1 1 0 0 0
0
0
1
1
row 5
row 4
row 3
row 2
row 1  5  3
 2
Figure 2. Array A after A1,1 has been removed and added to the one-dimensional
sum array s. The cells (1, 2) and (2, 1) are active, as indicated by the ones in cells
(1, 6), (5, 2), (2, 6), and (5, 1).
a
c
f
b
d e g
h i
Figure 3. Six binary trees. The top three trees are complete binary trees and the
bottom three are not.
tree that is completely filled with the possible exception of the bottom level, which is filled from
left to right. Figure 3 contains illustrations of structures which are and are not complete binary
trees. Each node of the tree has one parent, except the root of the tree, which has no parent. In a
minimum heap, the smallest element of the heap is contained in its root. In the upper right tree
in Figure 3, a is the root of the tree. Nodes b and c are a’s children, where b is the left child and
c is the right child . (According to the definition of a complete binary tree, when a node above
the bottom level of the tree has only one child, it must be a left child.) Node b is the parent to
nodes d and e. The height of a tree is the number of nodes from the root to a node at the bottom
level of the tree. For example, the heights of the top trees in Figure 3 are three, three, and four,
respectively. A complete binary tree of height h has between 2h and 2h+1 − 1 nodes [7, p. 496].
Thus, a minimum heap is a complete binary tree with the special ordering property that each
parent node contains a value less than or equal to the values in its childrens’ nodes. Because of
this ordering property, the smallest value in a minimum heap will always be at the root.
The binary heap H formed with the values A1,2 and A2,1 is in Figure 4. The next sum to be
entered into s in position s2 is the root of the heap. Since A1,2 = −3 is the root, it is removed from
the heap H and placed in s2, while its corresponding probability is placed in Probs2. Because
Algorithms for Computing 9
 2
 3
Figure 4. Heap H containing entries A1,2 = −3 and A2,1 = −2.
    
    
    
    
    





   
   
   
   
   





 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
1 0 0 0 0
0
0
1
0
row 5
row 4
row 3
row 2
row 1  5  3
 2
Figure 5. Array A after A1, 2 = −3 is removed and appended to s. Cell (2, 1) is the
only active cell. Candidates to become active are cells (1, 3) and (2, 2). Cell (2, 2)
cannot become active since row two already contains an active cell.
    
    
    
    
    





   
   
   
   
   





 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
1 0 1 0 0
0
0
1
1
row 5
row 4
row 3
row 2
row 1  5  3
 2
0
Figure 6. Array A with active cells (1, 3) and (2, 1).
the entry A1,2 is removed from the array A, reset A1,6 = 0 and A5,2 = 0 to indicate that row
one and column two no longer contain an active cell. After these changes, array A is displayed
in Figure 5.
After setting cell (1, 2) to inactive, the two cells that may enter into the array A (if the
corresponding row and column do not already contain an active cell) are cells (3, 1) and (2, 2).
Since row two contains an active cell, then, entry A2,2 is not activated since its sum is greater
than A2,1. However, cell (1, 3) does become active, and its entry is A1,3 = y1 + x3 = 0. Hence,
A1,6 = 1 and A5,3 = 1. After these changes, array A is displayed in Figure 6.
The entry A1,3 is inserted into the heap H, and the heap is rebuilt to fulfill its ordering property.
After the addition of A1,3, the heap H is displayed in Figure 7. The minimum element, A2,1, is
removed from the root of the heap and placed in the sum array s in position s3. Its corresponding
probability is placed in Probs3.
10 D. Evans and L. Leemis
 2
0
Figure 7. Heap H containing entries A2,2 = −2 and A1,3 = 0.
    
    
    
    
    





   
   
   
   
   





    
    
    
    
    
    






 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
0 0 1 0 0
0
0
0
1
row 5
row 4
row 3
row 2
row 1  5  3
 2
0
Figure 8. Array A after A2,2 = −2 is removed. Cell (3, 1) is the only active cell.
Candidates to become active are cells (2, 2) and (3, 1).
The two cells that may enter the array A after the removal of the A2,1 entry are in cells (2, 2)
and (3, 1), as indicated by the arrows in Figure 8. Both cells (2, 2) and (3, 1) become active, and
their values are A2,2 = y2 + x2 = 0 and A3,1 = y3 + x1 = 2. Hence, A2,6 = 1, A5,2 = 1, A3,6 = 1,
and A5,1 = 1, as displayed in Figure 9. Entries A2,2 and A3,1 are inserted into the heap H, and
H is again rebuilt. Its structure is displayed in Figure 10.
Moving ahead to the seventeenth pass through the construction of the array A, its appearance
is displayed in Figure 11. A3,4 = 11 is placed in s17, and values A3,5 = 13 and A4,4 = 14 are
activated in the array A and inserted into the heap H. Since A3,5 is the root of the heap, it is
deleted and placed in s18. No new element is allowed to enter the heap, so the root element of
the heap is now A4,4 = 14, and it is removed and placed in s19. The last entry to be activated is
A4,5 = 16, and it is placed in position s20 of the sum array s.
Thus, after twenty iterations of this process, s and Probs arrays are
s = [−5,−3,−2, 0, 0, 2, 3, 4, 4, 5, 6, 7, 7, 7, 9, 10, 11, 13, 14, 16] ,
Probs = [0.03, 0.05, 0.015, 0.025, 0.02, 0.045, 0.01, 0.075, 0.06, 0.06,
0.04, 0.1, 0.03, 0.03, 0.02, 0.04, 0.09, 0.06, 0.12, 0.08] .
which are the same arrays encountered by using the moment generating function technique.
The redundancies are removed from s and the appropriate probabilities are combined in Probs to
complete the algorithm. (This could have been embedded into the iterative steps of the algorithm
to save memory.) Thus, the PDF of Z = X + Y is the same as determined in Example 3.
3. ALGORITHM
The algorithm for the procedure Convolution(X, Y) returns the PDF of the convolution of
the PDFs of the random variables X and Y . A brief description of the algorithm for discrete
random variables follows.
If X and Y are discrete, their supports, finite or infinite, dictate which of the methods described
in Section 2 is used to compute the convolution. The convolution of the PDFs of X and Y with
Algorithms for Computing 11
    
    
    
    
    





   
   
   
   
   





    
    
    
    
    
    






 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
1 1 1 0 0
0
1
1
1
row 5
row 4
row 3
row 2
row 1  5  3
 2
0
0
2
Figure 9. Array A with active cells (1, 3), (2, 2), and (3, 3).
20
0
Figure 10. Heap H with entries A1,3 = 0, A2,2 = 0, and A1,3 = 2.
    
    
    
    
    





   
   
   
   
   





    
    
    
    
    
    






    
    
    
    
    





    
    
    
    




   
   
   
   
   





    
    
    
    
    





   
   
   
   
   





   
   
   
   
   





    
    
    
    
    





    
    
    
    
    





    
    
    
    
    





    
    
    
    
    
    






   
   
   
   
   
   






    
    
    
    
    





   
   
   
   
   





 3
col 1
 1 2 6 8
col 2 col 3 col 4 col 5 col 6
 2
1
5
8
0 0 0 1 0
0
1
0
0
row 5
row 4
row 3
row 2
row 1  5  3
 2
0
0
5 7 10
4 7
3 7 9
64
112
Figure 11. Array A with its seventeenth active cell (3, 4).
finite support is computed either using the BruteForceMethod or MovingHeapMethod procedures,
whose algorithms appear in Appendices 2 and 3, respectively. The PDF of the convolution of Z is
stored in a list-of-sublists format. The list of elements f(z1), f(z2), . . . , f(zn·m) are the probability
values of Z, while z1, z2, . . . , zn·m are its support values. The one-dimensional array s is created
to contain the unique sums extracted from the array A. Similarly, the one-dimensional array
Probs is created to hold the probability values corresponding to the sums in s.
The zeros (if any) at the end of the Probs array do not represent probability values; they
correspond to the zeros in the Probs array that are not support values. These extra zeros
indicate that there are redundant values in the support of Z. The nonzero probability values are
removed from Probs and placed in the array FinalProbs. The support values that correspond to
the removed probability values are removed and placed in the array FinalSupport.
If the supports of the random variables X and Y are infinite, either the discrete convolution
formula is used to compute the convolution or the APPL (“A Probability Programming Lan-
guage” that is discussed in the next section) procedure MGF is used to determine the MGF of the
product of X and Y .
12 D. Evans and L. Leemis
If either X or Y has infinite support, while the other has finite support, the product of their
MGFs is returned. If both X and Y have infinite support and the discrete convolution formula
formed with their PDFs results in an intractable sum, then the product of their MGFs is returned.
Otherwise, the discrete convolution formula is used to determine the convolution of their PDFs.
Unless the MGF for Z or the PDF of the convolution for X and Y (with n = 1 and m = 1)
has already been returned, the PDF fZ(z) is returned.
Procedure Convolution: Computes the PDF of the convolution of the PDFs of two independent
random variables (indentation indicates nesting).
Input: The random variables X and Y . Assume the random variables X and Y are input in
their PDF forms. The support of X is ΩX and the support of Y is ΩY .
Output: The PDF of Z = X + Y .
If X and Y are continuous
fZ(z)←
∫∞
−∞ fX(z − y) fY (y) dy
Else if X and Y are discrete
If X and Y have finite support
n← |ΩX |
m← |ΩY |
If n ·m ≤ 100
Z ← BruteForceMethod(X, Y )
Else
Z ← MovingHeapMethod(X, Y )
If (n = 1 and m = 1) [i.e. fZ(z) = 1 for z = c ∈ R]
return(fZ(z))
Dimension s[n ·m] [Create the sums array s]
Dimension Probs[n ·m] [Create the probability array Probs]
For i← 1 to n ·m
si ← 0
Probsi ← 0
s1 ← z1
s2 ← z2
Probs1 ← f(z1)
k ← 2
j ← 2
While (k < n ·m) do
Probsj ← Probsj + f(zk)
If zk 6= zk+1 then [Eliminate redundant support values]
j ← j + 1
sj ← zk+1
k ← k + 1
Probsj ← Probsj + f(zk)
NumZeros← 0
For i← n ·m to 1 by −1 while Probsi = 0
NumZeros← NumZeros+ 1
Dimension FinalProbs[1, n ·m−NumZeros]
Dimension FinalSupport[1, n ·m−NumZeros]
For i← 1 to (n ·m−NumZeros)
FinalProbsi ← Probsi
FinalSupporti ← si
Algorithms for Computing 13
fZ(z)← [FinalSupport, F inalProbs]
Else if (X or Y has infinite support or
X and Y have infinite support with intractable discrete convolution sum)
mgfx← MGF(X)
mgfy ← MGF(Y )
mgfprod← mgfx ·mgfy
return(mgfprod)
Else [Discrete convolution formula]
fZ(z)←
∑z
k=0(fX(z)) · (fY (z − k))
Else
print(“ERROR: X and Y must both be continuous or discrete”)
return
return(fZ(z))
4. IMPLEMENTATION
The algorithm for the Convolution procedure has been implemented in Maple. This Maple
procedure is one of over 30 procedures included in a probability package developed to automate
the naming, processing, and applications of random variables. The software package is referred
to as “A Probability Programming Language” (APPL) and is described in [9]. Several
other APPL procedures, such as Mean, Variance, and PDF, will also be used in this paper.
The data structure used to represent the distribution of a random variable is a “list of three
sublists.” The first sublist contains the PDF, CDF, SF, HF, CHF, or IDF of the distribution.
For explanation purposes, we will assume it contains the PDF. The function in the first sublist
can either be written symbolically as a function,
[
x→
(3
x
)
(2/5)x(3/5)3−x
]
, or numerically as
a list of probability values, [27/125, 54/125, 36/125, 8/125]. The second sublist contains the
support values of the PDF. If the PDF of X is entered as a function in the first sublist, then,
its support Ω is entered as a range in the second sublist as [min {Ω} . . .max {Ω} , k], where k is a
positive increment with a default value of one. IfX ∼ binomial(3, 2/5), for example, then, the first
and second sublists written in symbolic function notation are
[
x→
(3
x
)
(2/5)x(3/5)3−x
]
, [0 . . . 3].
If the PDF is entered as a list of probability values in the first sublist, then, each corresponding
support value is listed in the second sublist. Again, if X ∼ binomial(3, 2/5), then, the first and
second sublists entered as numeric lists are [(27/125), (54/125), (36/125), (8/125)] , [0, 1, 2, 3].
Last, the third sublist contains two strings. The first string, which is either "Continuous" or
"Discrete", indicates whether the random variable is continuous or discrete. The second string
is "PDF", "CDF", "SF", "HF", "CHF", or "IDF", which indicates the type of function in the first
sublist.
One piece of the algorithm for the Convolution procedure involves computing every possible
sum between the support of the random variables X and Y . At the same time, the probabilities
for those sums are calculated. This is called the “brute force method”. The list of sums are
ordered and redundancies combined. The corresponding probability values are repositioned to
match their corresponding sums. One important reason for sorting the sums is that all other
APPL procedures assume that discrete distributions, written in their list-of-sublists form, have
supports listed in increasing order without repeated values. To be consistent with the APPL
language and textbooks, the sums are sorted. Also, placing the values of the support into a list
in sorted order means that tied yi + xj values can be combined dynamically as the algorithm
proceeds.
The first sorting method used to sort the list of sums was insertion sort. It was chosen because
of its straightforward code and efficiency in computing convolutions when the support sizes of
the random variables are small. Unfortunately, as the supports of random variables grow larger
(e.g., random variables with 50 random numbers chosen on the interval (−1, 1) as a support), the
14 D. Evans and L. Leemis
time used to compute the PDF of the convolution becomes unreasonably large. A faster sorting
method for larger list sizes is heapsort. Heapsort is employed in the Convolution procedure for
sorting the list of sums created by the “brute force method”.
Maple uses Shellsort to sort polynomials. In order to use the Shellsort procedure in Maple,
the MGFs of X and Y need to be computed. The product of the MGFs of X and Y is an
expression composed of exponential terms ekt, where k ∈ R, t > 0. Letting u = et, the MGF
of the product can be rewritten as a polynomial-type expression. For example, if u = et, then,
MZ(t) = (1/3)e3t + (1/6)e2t + (1/2)e5t can be rewritten MZ(t) = (1/3)u3 + (1/6)u2 + (1/2)u5.
The Shellsort procedure sorts the polynomial-like expression, and the PDF of the convolution of
X and Y is retrieved from this expression. Instead of MGFs, probability generating functions
(PGFs) can be used in the process. MGFs were chosen over PGFs since PGFs can only be formed
when the discrete distribution has nonnegative integer support.
The method of computing convolutions via their MGFs was abandoned after realizing that
Maple can only sort “true” polynomial expressions in which variables are raised to nonnegative
integer powers. Thus using MGFs would be too restrictive for a Maple implementation. Maple
is unable to sort an expression that has nonintegers in the powers of the polynomial terms. For
example, Maple cannot sort the expression 1/3 (et)3/2 + 1/6 (et)1/2 + 1/2 (et)5.5. Since the Con-
volution procedure was intended to be used on arbitrary distributions, which could indeed have
negative, non-integer supports, the MGF method was removed from the procedure Convolution.
The extra time involved in checking for appropriate values also affected the algorithm’s efficiency.
Unfortunately, for random variables with large finite support sizes, heapsort was also inefficient.
Nicol [8] suggested constructing a heap dynamically and sorting the list of sums sequentially,
instead of waiting until the list of sums is built and then sorting it. The heap will always
contain min{m, n} or fewer entries. After constructing the algorithm for this method, which
is called MovingHeapMethod, the Convolution procedure was tested on random variables with
large supports by using the BruteForceMethod with insertion sort, the BruteForceMethod with
heapsort, and the MovingHeapMethod. A brief comparison analysis of the three methods suggested
that MovingHeapMethod yielded the best times for computing convolution of random variables
with large supports. Test cases of random variables with increasing support sizes were performed
to confirm this assumption.
The test involved generating random numbers between −1 and 1 and making them the support
values for the random variables X and Y . The supports of the random numbers were sorted and
placed into the second sublist in the list-of-sublists format for the random variables to conform
to the system of the APPL language. The probabilities, which had no effect on the efficiency
of the different algorithms, were assigned to be equally-likely for all support values; i.e., if X’s
support consisted of 50 values, then each support value’s probability was 1/50. The times for
determining the PDF of the convolution of random variables of increasing support sizes using a
266 MHz Pentium II personal computer appears in Table 1.
When either one or both random variables’ supports are infinite, either the convolution of their
PDFs is computed via the discrete convolution formula or the MGF of their product is determined.
If one of the random variables has infinite support, while the other has finite support, the MGF
of their product is returned. At this time, APPL does not contain a procedure to convert the
MGF of a random variable to its PDF form. In future work, this recognition process may become
an APPL procedure.
Two random variables with infinite support does not guarantee that the PDF of their convo-
lution can be determined by the discrete convolution formula. Only tractable summations, such
as the convolution formula for two Poisson random variables as in Example 1, can be computed.
This means that instead of determining the PDF for the convolution of the PDFs of some random
variables, such as a Poisson with parameter λ = 5 and a geometric with parameter p = 0.3, the
Convolution procedure only computes the product of their MGFs.
Algorithms for Computing 15
Table 1. CPU times (in seconds) for the convolution of random variables X and Y by
the BruteForceMethod with insertion sort, the BruteForceMethod with heapsort,
and the MovingHeapMethod for arbitrary distributions with arbitrary support values
ranging in increasing value from −1 to 1.
Support size BruteForceMethod BruteForceMethod
MovingHeapMethod
of X and Y with insertion sort with heapsort
50 70.5 10.6 15.3
60 143.1 18.1 24.0
70 313.3 29.1 34.6
80 518.0 45.5 50.0
90 824.0 69.9 69.3
95 1050.5 85.3 80.6
100 1263.5 101.3 93.5
110 2037.6 153.2 123.3
120 2897.4 201.7 163.0
125 3283.5 257.5 173.9
130 – 284.8 201.6
140 – 394.8 236.4
150 – 541.1 320.1
160 – 728.8 377.3
170 – 969.0 454.6
175 – 1127.9 506.5
180 – 1319.1 578.5
190 – 1723.2 671.8
200 – 2210.3 829.0
5. EXAMPLES
The following examples use the algorithm described in Section 3 to determine the PDF of the
convolution of independent random variables. Examples for a variety of random variables are
provided to illustrate the utility of the algorithm. Returning first to Examples 1–4 introduced in
Section 1 of this paper, we can use the Convolution procedure to determine their solutions.
Example 1 Revisited. If X and Y are independent Poisson random variables with respective
parameters λ1 and λ2, compute the PDF of Z = X + Y .
Solution. In APPL, define X as a Poisson random variable with parameter lambda1 and Y
as a Poisson random variable with parameter lambda2. The Poisson random variable is also
predefined in APPL. The PDF Z = X + Y is found with the statements,
> X := PoissonRV(lambda1);
> Y := PoissonRV(lambda2);
> Z := Convolution(X, Y);
which returns the PDF of Z as:[[
z → (z + 1) e
−λ1−λ2 (λ2 + λ1)
z
(z + 1)!
]
, [0 . . .∞] , [ “Discrete”, “PDF”]
]
.
Using the Maple simplify procedure, the resulting PDF after simplification is
f(z) =
e−λ1−λ2 (λ2 + λ1)
z
Γ(z + 1)
, z = 0, 1, . . . ,
which is easy to recognize in its standard form as
f(z) =
e−λ1−λ2 (λ1 + λ2)
z
z!
, z = 0, 1, . . . .
16 D. Evans and L. Leemis
We are fortunate in this example that Maple can compute the PDF by the discrete convolution
formula by simplifying the sum
∑x
k=0(λ1
ke−λ1λ2
x−ke−λ2/k! (x − k)!). Unfortunately, Maple
can only simplify certain expressions, so, in some instances, we cannot compute the PDF by the
discrete convolution formula.
Examples 2–4 Revisited. X and Y are independent discrete random variables with PDFs
defined as:
fX(x) =

0.15, x = −3,
0.25, x = −1,
0.1, x = 2,
0.3, x = 6,
0.2, x = 8,
fY (y) =

0.2, y = −2,
0.1, y = 1,
0.3, y = 5,
0.4, y = 8.
Find the PDF of Z.
Solution. Define the random variables X and Y in APPL’s list-of-sublists format. Compute the
PDF of Z = X + Y with the following statements,
> X := [[0.15, 0.25, 0.1, 0.3, 0.2], [-3, -1, 2, 6, 8], ["Discrete", "PDF"]];
> Y := [[0.2, 0.1, 0.3, 0.4], [-2, 1, 5, 8], ["Discrete", "PDF"]];
> Z := Convolution(X, Y);
which returns the PDF of Z as
[[0.03, 0.05, 0.015, 0.045, 0.045, 0.01, 0.135, 0.06, 0.04, 0.16, 0.02, 0.04, 0.09, 0.06, 0.12, 0.08] ,
[−5,−3,−2, 0, 2, 3, 4, 5, 6, 7, 9, 10, 11, 13, 14, 16] , [“Discrete”, “PDF”]] .
Example 5. Let X and Y be independent random variables; X assumes three possible values
0, 1, 3 with probabilities 1/2, 3/8, and 1/8, and Y assumes two possible values 0 and 1 with
probabilities 1/3, 2/3. Find the PDF of the random variable Z = X + Y [10, p. 136].
Solution. By hand, we can compute the PDF of Z with probability generating functions. The
PGFs G of X and Y , respectively, are,
GX (t) =
1
8
t3 +
3
8
t+
1
2
, −∞ < t <∞,
GY (t) =
2
3
t+
1
3
, −∞ < t <∞.
Thus, the PGF of Z = X + Y is,
GZ (t) =
1
12
t4 +
1
24
t3 +
1
4
t2 +
11
24
t+
1
6
, −∞ < t <∞,
and hence, the PDF of Z is,
fZ(z) =

1
6
, z = 0,
11
24
, z = 1,
1
4
, z = 2,
1
24
, z = 3,
1
12
, z = 4.
In APPL, define X and Y as list-of-sublists and then apply the Convolution procedure to achieve
the same result.
Algorithms for Computing 17
> X := [[1 / 2, 3 / 8, 1 / 8], [0, 1, 3], ["Discrete", "PDF"]];
> Y := [[1 / 3, 2 / 3], [0, 1], ["Discrete", "PDF"]];
> Z := Convolution(X, Y);
Other measures, such as the mean and variance, of a distribution can be found with the use of
additional APPL procedures, as seen in the next example.
Example 6
Let X1 and X2 be observations of a random sample of size n = 2 from a distribution with PDF
f(x) = (x/6), x = 1, 2, 3. Find the PDF of Y = X1 +X2, and determine the mean and variance
of the sum [11, p. 297].
Solution. The PGF of X1 and X2 is
GX1 (t) = GX2 (t) =
1
6
t+
1
3
t2 +
1
2
t3, −∞ < t <∞.
Thus, GY (t) is
GY (t) =
1
4
t6 +
1
3
t5 +
5
18
t4 +
1
9
t3 +
1
36
t2, −∞ < t <∞.
and fY (y) is
fY (y) =

1
36
, y = 2,
1
9
, y = 3,
5
18
, y = 4,
1
3
, y = 5,
1
4
, y = 6.
The mean and the variance of Y , respectively, are
E [Y ] = G′Y (t)
∣∣∣∣t=1 = [32 t5 + 53 t4 + 109 t3 + 13 t2 + 118 t
]
t=1
=
14
3
and
G′Y (1) +G
′
Y (1)− [G′Y (1)]
2 =
10
9
.
In APPL, the mean and variance of Y are computed with the statements,
> X := [[x -> x / 6], [1 .. 3], ["Discrete", "PDF"]];
> Y := [[1 / 3, 2 / 3], [0, 1], ["Discrete", "PDF"]];
> Mean(Y);
> Variance(Y);
Example 7. Find the probability of obtaining a total of 14 in a single toss of four dice [3, p. 230].
Solution. Let X be the PDF fX(x) = 1/6, x = 1, 2, . . . , 6. The PGF G of X is
GX (t) =
1
6
t6 +
1
6
t5 +
1
6
t4 +
1
6
t3 +
1
6
t2 +
1
6
t, −∞ < t <∞.
The PDF of Z = X1 +X2 +X3 +X4 can be found by computing [GX(t)]4, which is
[GX (t)]
4 =
1
1296
t24 +
1
324
t23 +
5
648
t22 +
5
324
t21 +
35
1296
t20
+
7
162
t19 +
5
81
t18 +
13
162
t17 +
125
1296
t16 +
35
324
t15 +
73
648
t14
+
35
324
t13 +
125
1296
t12 +
13
162
t11 +
5
81
t10 +
7
162
t9 +
35
1296
t8
+
5
324
t7 +
5
648
t6 +
1
324
t5 +
1
1296
t4, −∞ < t <∞.
Thus, Pr(Z = 14) = 73/648. In APPL, define X as a uniform discrete random variable (predefined
18 D. Evans and L. Leemis
in APPL) with parameter 1/6. The procedure ConvolutionIID(X, n) computes the PDF of the
convolution of n iid random variables X. This procedure contains a Maple “for loop” which calls
Convolution n times.
> X := DiscreteUniformRV(1 / 6);
> Z := ConvolutionIID(X, 4);
> PDF(Z, 14);
The APPL procedure PDF computes the probability that Z is 14, which is 73/648.
Examples 8–10 are from the article “Getting Normal Probability Approximations without
Using Normal Tables” by Thompson [12]. His paper discusses an alternate approach to approx-
imating probabilities involving sums of discrete random variables using the PDF for the normal
distribution. He lets S denote the sum of n independent discrete random variables, and assumes
that S assumes consecutive integer values. Letting µ = E(S) and σ2 = Var(S), he argues that
for sufficiently large values of n, S is approximately normally distributed. Using the standard
continuity correction, he gets
Pr (S = s) = Pr
(
s− 0.5 < N
(
µ, σ2
)
< s+ 0.5
)
.
Calculating a midpoint approximation using a single subinterval, the normal PDF approximation
is obtained, which is
Pr (S = s) =
1√
2πσ
e−(s−µ)
2/2σ2 .
Instead of settling for approximations of the probabilities, we will show how APPL procedures,
including Convolution, can retrieve exact solutions, while still giving the same insight into the
problem.
Example 8. Suppose that X1, X2, . . . , X20 are independent and that Xi ∼ Bernoulli(pi = (29 +
2i)/100), i = 1, 2, . . . , 20. Let S =
∑20
i=1Xi. (Here, S denotes the total number of successes
obtained in a series of independent trials where the probability of success varies from trial to
trial.) Give an exact probability table for S, for s = 2, 3, . . . , 10 [12, p. 53].
Solution. Using Thompson’s notation, µ = 10 and σ2 = 2367/500, and so Pr(S = s) ∼=
(1/
√
2π
√
2367/500)e−(s−10)
2/(2367/250), s = 0, 1, . . . , 20. Using APPL, we obtain the exact dis-
tribution of S with the statements:
> p := (29 + 2 * 1) / 100;
> S := BernoulliRV(p);
> for i from 2 to 20 do
> p := (29 + 2 * i) / 100:
> X := BernoulliRV(p):
> S := Convolution(S, X):
> od:
> S;
Table 2 contains the exact probabilities found with APPL and the normal PDF approximations
for s = 2, 3, . . . , 10.
Example 9
There are 20 girls and 30 boys in Group 1, 25 girls and 25 boys in Group 2, and 10 girls and
10 boys in Group 3. If 10 children are randomly chosen from each group and S denotes the total
number of girls chosen, give an exact probability table for S, for s = 7, 8, . . . , 21 [12, p. 53–54].
Solution
Let X1, X2, and X3 be the three independent hypergeometric random variables, and let S =
X1 +X2 +X3. The mean and variance of S are µ = E[S] = E[X1] + E[X2] + E[X3] = 14 and σ2
Algorithms for Computing 19
Table 2. Exact probabilities and normal PDF approximations of Pr(S = s) for
s = 2, 3, . . . , 10.
s
True Pr(S = s) Approximation of Normal PDF
(APPL) true Pr(S = s) Approximation
2
204658765144989225788930713729011
1600000000000000000000000000000000000
0.0001 0.0002
3
670581044381861117271962962043967
800000000000000000000000000000000000
0.0008 0.0010
4
12306309890051216090420607156481161
3200000000000000000000000000000000000
0.0038 0.0041
5
13130118961411820609429234497062639
1000000000000000000000000000000000000
0.0131 0.0131
6
13845545992556016094922419904605161
400000000000000000000000000000000000
0.0346 0.0338
7
14429186684261724023997491367619439
200000000000000000000000000000000000
0.0721 0.0709
8
193196528593089153025093245904930293
1600000000000000000000000000000000000
0.1207 0.1202
9
65549414450257125600014354447607969
400000000000000000000000000000000000
0.1639 0.1650
10
725313008476889512417635294011302541
4000000000000000000000000000000000000
0.1813 0.1834
= Var(S) = Var(X1) + Var(X2) + Var(X3) = 101/19 (since X1, X2, and X3 are independent).
Table 3 shows the normal PDF approximation values
Pr (S = s) ∼= (1/
√
2π
√
101/19)e−(s−14)
2/(202/19),
for s = 7, 8, . . . , 20.
Using the APPL Convolution procedure, we can readily produce the PDF of S with the
statements
> X1 := HypergeometricRV(50, 20, 10);
> X2 := HypergeometricRV(50, 25, 10);
> X3 := HypergeometricRV(20, 10, 10);
> Y := Convolution(X3, Convolution(X1, X2));
The exact values for s = 7, 8, . . . , 21 are shown in Table 3.
In the next example, APPL is able to find the convolution of a large number (150) of random
variables. While not impossible, computing the actual distribution by hand is tremendously
tedious and time-consuming.
Example 10. Let S = X1+· · ·+X150, where theXs are independent, Pr(Xi = −1) = Pr(Xi = 0)
= Pr(Xi = 1) = 1/3, i = 1, 2, . . . , 150. Find a normal approximation to Pr(S = 5) [12, p. 54].
Solution. Since the mean and variance of S are µ = 0 and σ2 = 100, using the normal PDF
approximation we obtain approximately 1/20(
√
2e−1/8/
√
π) ∼= 0.03521.
The APPL code:
> X := [[1 / 3, 1 / 3, 1 / 3], [-1, 0, 1], ["Discrete", "PDF"]];
> S := ConvolutionIID(X, 150);
> PDF(S, 5);
yields the exact PDF for S. The statement PDF(S, 5) returns
Pr (S = 5) =
160709987007649212790999852367465829596098558279031212787052332840770
4567759074507740406477787437675267212178680251724974985372646979033929
,
which is approximately 0.03518.
20 D. Evans and L. Leemis
Table 3. The exact probabilities and normal PDF approximations for Pr(S = s) for
s = 7, 8, . . . , 21.
s
True Pr(S = s) Approximation of Normal PDF
(APPL) true Pr(S = s) Approximation
7
4641594894759547665
3082276280132202064912
0.0015 0.0017
8
97479371530863990
17512933409842057187
0.0056 0.0059
9
12613791756912076515
770569070033050516228
0.0164 0.0165
10
74849525260411094591
1926422675082626290570
0.0389 0.0384
11
57967137494173367365
770569070033050516228
0.0752 0.0742
12
2096975232909133615
17512933409842057187
0.1197 0.1188
13
22076335771392253895
140103467278736457496
0.1576 0.1575
14
317244095646532855
1843466674720216546
0.1721 0.1730
15
9955623438355053449
63683394217607480680
0.1563 0.1575
16
217921905682010165
1843466674720216546
0.1182 0.1188
17
1894259194489549345
25473357687042992272
0.0744 0.0742
18
71588441634588035
1843466674720216546
0.0388 0.0384
19
10756216836381565
641205799902684016
0.0168 0.0165
20
1208983087163529637
202781334219223820060
0.0060 0.0059
21
280730797358534065
162225067375379056048
0.0017 0.0017
Since the mass values of the parent populations are adjacent, Pr(S = 5) can be computed using
a combinatorics approach,
Pr (S = 5) =
∑∑∑
{(p,q,r)|p+q+r=150,
0≤p≤150
0≤q≤150
0≤r≤150
−p+r=5}
(
150
p, q, r
)(
1
3
)p(1
3
)q (1
3
)r
or equivalently,
Pr (S = 5) =
72∑
p=0
(
150
p, 145− 20, 5 + p
)(
1
3
)150
,
yielding the same result as the APPL code. The true power of APPL is not demonstrated in this
particular example because of the adjacent mass values of the parent populations. The APPL
Algorithms for Computing 21
approach allows for unequal, and more importantly, nonadjacent mass values. Also, more than
three mass values can be used in the APPL approach. Although a combinatorics method may
still be used on these types of examples, the resulting expressions will not be as easy to evaluate
as the expression obtained in the sum above.
6. FURTHER WORK
Computer algebra systems make it feasible to determine distributions of convolutions of ran-
dom variables, especially those random variables with finite arbitrary supports. The algorithm
that was constructed (with heaps) to compute the PDF of the convolution was extended to deter-
mine the PDF of the product also. Because of negative and positive support values for random
variables X and Y , the product algorithm must split the array A into four quadrants before
heaping. The quadrants are split based on X’s and Y ’s negative and nonnegative support values.
Figure 12 illustrates the evolution of the algorithm in the most general case when both X and Y
have negative and positive support values. The product algorithm works from the corners of
quadrants two and four toward the center where the quadrants meet, and then, works outward
from the center through quadrants one and three. For the product algorithm, the heap can receive
values from two competing quadrants at a time. The function Product has been implemented
and is a part of APPL. The algorithm for the continuous implementation of Product is presented
in [13].
 3  1 2 6 8
 2
1
5
8
Quadrant 1
Quadrant 4
Quadrant 2
Quadrant 3
Figure 12. Array A split into four quadrants for the product algorithm.
REFERENCES
1. S. Ross, A First Course in Probability, Sixth Edition, Prentice–Hall, Upper Saddle River, NJ, U.S.A., (2002).
2. C.M. Grinstead and J.L. Snell, Introduction to Probability, Second Revised Edition, American Mathematical
Society, (1997).
3. R.V. Hogg and A.T. Craig, Mathematical Statistics, Fifth Edition, Prentice–Hall, Englewood Cliffs, NJ,
U.S.A., (1995).
4. E. Parzen, Modern Probability Theory and Its Applications, John Wiley & Sons, Inc., New York, (1960).
5. J.A. Woodward and C.G.S. Palmer, On the exact convolution of discrete random variables, Applied Mathe-
matics and Computation 83, 69–77, (1997).
6. M.A. Weiss, Data Structures and Algorithm Analysis in C++, Addison–Wesley Publishing Company, Menlo
Park, CA, U.S.A., (1994).
7. F.M. Carrano, P. Helman and R. Veroff, Data Abstraction and Problem Solving with C++: Walls and
Mirrors, Second Edition, Addison–Wesley Longman, Inc., Reading, MA, U.S.A., (1998).
8. D. Nicol, personal communication, (2000).
9. A. Glen, D. Evans and L. Leemis, APPL: A probability programming language, The American Statistician
55, 156–166, (2001).
10. A.A. Sveshnikov, Editor, Problems in Probability Theory, Mathematical Statistics and Theory of Random
Functions, Dover Publications, Inc., New York, (1968).
11. R.V. Hogg and E.A. Tanis, Probability and Statistical Inference, Sixth Edition, Prentice–Hall, Upper Saddle
River, NJ, U.S.A., (2000).
22 D. Evans and L. Leemis
12. P. Thompson, Getting normal probability approximations without using normal tables, The College of Math-
ematics Journal 31, 51–54, (2000).
13. A. Glen, L. Leemis and J. Drew, Computing the distribution of the product of two continuous random
variables, Computational Statistics and Data Analysis 44, 451–464, (2004).
APPENDIX 1
DETERMINING CANDIDATE SUMS FOR THE HEAP
Theorem. Let x1 < x2 < · · · < xn and y1 < y2 < · · · < ym be finite real numbers. Let the
m×n array A be arranged as shown in Figure 13 and have entries Ai,j = yi + xj , i = 1, 2, . . . ,m
and j = 1, 2, . . . , n. Let the set C contain all (i, j) pairs, such that xi + yj ≤ c, where c > y1 +x1
is a real number. Let P be the path from the northwest corner of A to the southeast corner of
A that separates C from C ′. The smallest element in C ′ must occur just to the northeast of a
southward followed by an eastward change in direction of the path P .
.
.
.
.
.
.
.
.
.
x1 x2 xn
y2
y1 y1 + xny1 + x2y1 + x1
y2 + x1 y2 + x2 y2 + xn
ym ym + xnym + x2ym + x1 : : :
: : :
: : :
: : :
.
.
.
Figure 13. Array A where x1 < x2 < · · · < xn and y1 < y2 < · · · < ym.
 3  1 2 6 8
 2
1
5
8
 5  3
 2
0
0
2
3
4
4
5
Figure 14. Array A corresponds to Example 2. The path P from the northwest
corner to the southeast corner of A that delimits the set C = {(i, j) | yi + xj ≤ 3}
from C′ is thickened. The circled entries lie just to the northeast of points in the
path where there is a turn from a southward to an eastward direction. These three
entries are contained in the cells in C′ that hold the smallest entries in C′ for c = 3.
Algorithms for Computing 23
Proof. For any cell in C, every cell to the southwest of C is also in C, since x1 < x2 < · · · < xn
and y1 < y2 < · · · < ym. Thus, C must be a finite union of rectangles in A, where each rectangle
contains the (1, 1) cell. The next cell to be included in C as c increases is the smallest element
in C ′. Since C will continue to be a finite union of rectangles when the next cell is added, the
smallest element in C ′ must occur at intersections of the rectangles and the western and southern
boundaries of A that occur on P .
As an example, Figure 14 displays the array A for Example 2 with c = 3.
APPENDIX 2
ALGORITHM FOR BRUTEFORCEMETHOD
The algorithm for the APPL procedure BruteForceMethod(X, Y) computes the PDF of the
convolution of the PDFs of the two random variables X and Y by the “brute force method”
described in Section 2. The support list for the convolution is sorted by a heapsort in the APPL
procedure HeapSort, which sorts the elements of its first argument, making corresponding swaps
to the elements of its second argument. The variables ΩX and ΩY are the supports of the random
variables X and Y , respectively.
Procedure BruteForceMethod(X, Y) n← |ΩX |
m← |ΩY |
s← array[1 . . . n ·m]
Probs← array[1 . . . n ·m]
For i← 1 to n
For j ← 1 to m
sk ← yi + xj
Probsk ← fY (yi) · fX(xj)
return(HeapSort(s,Probs))
APPENDIX 3
ALGORITHM FOR MOVINGHEAPMETHOD
The algorithm for the APPL procedure MovingHeapMethod(X, Y) computes the PDF of the
convolution of two random variables X and Y by the “moving heap method” described in Sec-
tion 2. The additional APPL procedures PercolateDownHeap, RebuildHeap, and InsertHeap
are standard heap programs for inserting and restructuring a heap so that it continues to fulfill
the properties of a heap.
Procedure MovingHeapMethod(X, Y)
n← |ΩX |
m← |ΩY |
Dimension s[n ·m]
Dimension Probs[n ·m]
s1 ← y1 + x1
Probs1 ← fY (y1) · fX(x1)
Dimension r[m+ 1]
Dimension c[n+ 1]
row1col2entry ← [y1 + x2, fY (y1) · fX(x2)]
r1 ← 1
c2 ← 1
row2col1entry ← [y2 + x1, fY (y2) · fX(x1)]
r2 ← 1
c1 ← 1
rn+1 ← 1 [Keeps search for new entries inside north border of A]
24 D. Evans and L. Leemis
cm+1 ← 1 [Keeps search for new entries inside east border of A]
H ←
[
−1 · 106, row1col2entry, row2col1entry
]
Mimic← [[0, 0], [1, 2], [2, 1]] [Holds the positions of the entries]
PercolateDownHeap(2, 3) [Restructures H to fulfill the heap properties]
For q ← 2 to n ·m
RootItem← H2
RootPosition←Mimic2
sq ← RootItem1 [Root entry placed in sums array s]
Probsq ← RootItem2 [Root entry’s probability placed in probability array Probs]
a← RootPosition1
b← RootPosition2
ra ← 0 [The root’s row becomes inactive]
cb ← 0 [The root’s column becomes inactive]
size← |H|
H2 ← Hsize
Mimic2 ←Mimicsize
H ← [H1 . . . Hsize−1]
Mimic← [Mimic1dotsMimicsize−1]
RebuildHeap(2, size− 1) [Restores H as a heap]
If (ra = 0) and (cb+1 = 0) then [If the cell just east of
ra ← 1 the removed entry is inactive,
cb+1 ← 1 insert its entry into the heap]
NewPosition← [a, b+ 1]
InsertHeap(NewPosition)
If (ra+1 = 0) and (cb = 0) then [If the cell just south of
ra+1 ← 1 the removed entry is inactive,
cb ← 1 insert its entry into the heap]
NewPosition← [a+ 1, b]
InsertHeap(NewPosition)
return(s, Probs)

