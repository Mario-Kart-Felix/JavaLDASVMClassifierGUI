New Results On Routing Via Matchings On Graphs
Indranil Banerjee
ibanerje@gmu.edu
George Mason University
Dana Richards
richards@cs.gmu.edu
George Mason University
June 29, 2017
Abstract
In this paper we present some new complexity results on the routing time of a
graph under the routing via matching model. This is a parallel routing model which
was introduced by Alon et al[1]. The model can be viewed as a communication scheme
on a distributed network. The nodes in the network can communicate via matchings
(a step), where a node exchanges data (pebbles) with its matched partner. Let G be a
connected graph with vertices labeled from {1, ..., n} and the destination vertices of the
pebbles are given by a permutation π. The problem is to find a minimum step routing
scheme for the input permutation π. This is denoted as the routing time rt(G, π) of G
given π. In this paper we characterize the complexity of some known problems under
the routing via matching model and discuss their relationship to graph connectivity
and clique number. We also introduce some new problems in this domain, which may
be of independent interest.
1 Introduction
Originally introduced by Alon and others [1] the routing via matching model explores a
parallel routing problem on connected undirected graphs. Consider a undirected labeled
graph G. Each vertex of G contains a pebble with the same label as the vertex. Pebbles
move along edges through a sequence of swaps. A set of swaps (necessarily disjoint) that
occurs concurrently is called a step. This is determined by a matching. A permutation π
gives the destination of each pebble. That is, the pebble pv on vertex v is destined for the
vertex π(v). The task is to route each pebble to their destination via a sequence of matchings.
The routing time rt(G, π) is defined as the minimum number of steps necessary to route all
the pebbles for a given permutation. The routing number of G, rt(G), is defined as the
maximum routing time over all permutation. Let G = (V,E), m = |E| and |G| = n = |V |.
Determining the routing time is a special case of the minimum generator sequence prob-
lem for groups. In this problem instead of a graph we are given a permutation group G and
a set of generators S. Given a permutation π ∈ G the task is to determine if there exists
1
ar
X
iv
:1
70
6.
09
35
5v
1 
 [
cs
.D
S]
  2
8 
Ju
n 
20
17
a generator sequence of length ≤ k that generates π from the identity permutation. It was
first shown to be NP-hard by Evan and Goldreich [11]. Later Jerrum [15] showed that it is
in fact PSPACE-complete, even when the generating set is restricted to only two generators.
The serial version, where swaps takes place one at a time, is also of interest. This has
recently garnered interest after its introduction by Yamanaka and others [8]. They have
termed it the token swapping problem. This problem is also NP-complete as shown by
Miltzow and others [9] in a recent paper. Where the authors prove token swapping problem
is hard to approximate within (1 + δ) factor. They also provide a simple 4-approximation
scheme for the problem. A generalization of the token swapping problem (and also the
permutation routing problem) is the colored token swapping problem [8, 4]. In this model
the vertices and the tokens are partitioned into equivalence classes (using colors) and the
goal is to route all pebbles in such a way that each pebble ends up in some vertex with the
same class as the pebble. If each pebble (and vertex) belong to a unique class then this
problem reduces to the original token swapping problem. This problem is also proven to
be NP-complete by Yamanaka and others [8] when the number of colors is at least 3. The
problem is polynomial time solvable for the bi-color case.
1.1 Prior Results
Almost all previous literature on this problem focused on determining the routing number of
typical graphs. In the introductory paper, Alon and others [1] show that for any connected
graph G, rt(G) ≤ 3n. This was shown by considering a spanning tree of G and using only the
edges of the tree to route permutations in G. Note that, one can always route a permutation
on a tree, by iteratively moving a pebble that belongs to some leaf node and ignoring the
node afterward. The routing scheme is recursive and uses an well known property of trees: a
tree has a centroid (vertex) whose removal results in a forest of trees with size at most n/2.
Later Zhang and others [5] improve this upper bound to 3n/2 + O(log n). This was done
using a new decomposition called the caterpillar decomposition. This bound is essentially
tight as it takes b3(n− 1)/2c steps to route some permutations on a star K1,n−1. There
are also some known results for routing numbers of graphs besides trees. We know that
for the complete graph and the complete bipartite graph the routing number is 2 and 4
respectively [1]. Where the latter result is attributed to W. Goddard. Li and others [6]
extend these results to show rt(Ks,t) = b3s/2tc+O(1) (s ≥ t). For the n-cube Qn we know
that n+ 1 ≤ rt(Qn) ≤ 2n− 2. The lower bound is quite straightforward. The upper bound
was discovered by determining the routing number of the Cartesian product of two graphs
[1]. If G = G1G2 be the Cartesian product of G1 and G2 then:
rt(G) ≤ 2 min(rt(G1), rt(G2)) + max(rt(G1), rt(G2))
Since Qn = K2Qn−1 the result follow.1.
1The base case, which computes rt(Q3) was determined to be 4 via a computer search[6]
2
1.2 Our Results
In this paper we present several complexity results for the routing time problem and some
variants of it. We summarize these results below.
Complexity results on routing time:
1. If G is at least bi-connected then determining whether rt(G, π) = k for any arbitrary
permutation and k > 2 is NP-complete. 2
2. For any graph, determining rt(G, π) ≤ 2 can be done in polynomial time, for which
we give a O(n2.5) time algorithm.
3. As a consequence of our NP-completeness proof of the routing time we show that the
problem of determining a minimum sized partitioning scheme of a colored graph such
that each partition induces a connected subgraph is NP-complete.
4. We introduce a notion of approximate routing called maximum routability for a graph
and give an approximation algorithm for it.
Structural results on routing number:
5. IfG is h-connected thenG has a routing number ofO(nrG). Here rG = min rt(Gh)/|Gh|,
over all induced connected subgraphs |Gh| ≤ h.
6. A connected graph with a clique number of κ has a routing number of O(n− κ).
Routing on general graphs is a natural question and the swapping model is a natural
model in synchronous networks. Our results are some of the first to address these models
when the graph has certain topological properties. Connectivity properties are basic, espe-
cially for network algorithms. While the hope is to have matching upper and lower bounds
for, say, h-connected graphs, we give new algorithms and techniques towards that end.
2 Computational Results
2.1 An O(n2.5) time Algorithm for Determining If rt(G, π) ≤ 2
In this section we present a polynomial time deterministic algorithm to compute a two step
routing scheme if one exists. It is trivial to determine whether rt(G, π) = 1. Hence, we only
consider the case if rt(G, π) > 1. The basic idea centers around whether we can route the
individual cycles of the permutation within 2 steps. Let π = π1π2 . . . πk consists of k cycles
and πi = (πi,1 . . . πi,ai), where ai is the number of elements in πi. A cycle πi is identified with
2After publication of our results to arXiv ([16]) a similar result was independently discovered in the
context of parallel token swapping by Kawahara and others [17].
3
the vertex set Vi ⊂ V whose pebbles need to be routed around that cycle. We say a cycle πi
is self-routable if it can be routed on the induced subgraph G[Vi] in 2 steps.
If all cycles were self-routable we would be done, so suppose that there is a cycle πi that
needs to match across an edge between it and another cycle πj. Let G[Vi, Vj] be the induced
bipartite subgraph corresponding to the two sets Vi and Vj.
πi
πj
πi;s
πj;t
Figure 1: The two cycles are shown as concentric circles. The direction of rotation for the
outer circle is clockwise and the inner circle is counter-clockwise. Once, we choose (πi,s, πj,t)
as the first matched pair, the rest of the matching is forced. Solid arrows indicate matched
vertices during the first round. Note that the cycles are unequal and the crossed vertices in
the figure will not be routed.
Lemma 2.1. If πi is not self-routable and it is routed with an edge from Vi to Vj then πi
and πj are both routable in 2 steps when all of the edges used are from G[Vi, Vj] and when
|Vi| = |Vj|.
Proof. We prove this assuming G is a complete graph. Since for any other case the induced
subgraph G[Vi ∪ Vj] would have fewer edges, hence this is a stronger claim. Let the cycle
πi = (πi,1, . . . , πi,s, . . . , πi,|Vi|). If there is an edge used between the cycles then there must be
such an edge in the first step, since pebbles need to cross from one cycle to another and back.
Assume πi,s is matched with πj,t in the first step. From Figure 1 we see that the crossing
pattern is forced, and unless |Vi| = |Vj|, the pattern will fail.
A pair of cycles πi, πj is mutually-routable in the case described by Lemma 1. Naively
verifying whether a cycle πi is self-routable, or a pair (πi, πj) is mutually-routable takes
O(|Vi|2) and O((|Vi| + |Vj|)2) time respectively. However, with additional bookkeeping we
can compute this in linear time on the size of the induced graphs. This can be done by
considering the fact that no edge can belong to more than one routing scheme on G[Vi] or on
G[Vi, Vj]. Hence the set of edges are partitioned by the collection of 2 step routing schemes.
Self-routable schemes, if they exist, are forced by the choice of any edge to be in the first
step; no edge is forced by more than four initial choices, leading to a test that runs in time
proportional in |G[Vi]|. Mutually-routable schemes, if they exist, are one of |Vi| (= |Vj|)
possible schemes; each edge votes for a scheme and it is routable if a scheme gets enough
votes, leading to a test that runs in time proportional in |G[Vi, Vj]|. All the tests can be
done in O(m) time.
4
We define a graph Gcycle = (Vcycle, Ecycle) whose vertices are the cycles (Vcycle = {πi})
and two cycle are adjacent iff they are mutually-routable in 2 steps. Additionally, Gcycle has
loops corresponding to vertices which are self-routable cycles. We can modify any existing
maximum matching algorithm to check whether Gcycle has a perfect matching (assuming
self loops) with only a linear overhead. We omit the details. Then the next lemma follows
immediately:
Lemma 2.2. rt(G, π) = 2 iff there is a perfect matching in Gcycle.
The graph Gcycle can be constructed in O(m) time by determining self and mutual routability
of cycles and pair of cycles respectively. Since we have at most k cycles, Gcycle has ≤ 2k
vertices and thus O(k2) edges. Hence we can determine a maximum matching in Gcycle in
O(k2.5) time [7]. This gives a total runtime of O(n + m + k2.5) for our algorithm to find a
2-step routing scheme of a connected graph if one exists.
Corollary 2.3. rt(G) = 2 iff G is a clique.
Proof. (⇒ ) A two step routing scheme for Kn was given in [1].
(⇐) If G is not a clique then there is at least a pair of non-adjacent vertices. Let (i, j) be
a non-edge. Then by Lemma 1 the permutation (ij)(1)(2) . . . (n) cannot be routed in two
steps.
2.2 Determining rt(G, π) ≤ k Is Hard for Any k ≥ 3
Theorem 2.4. For k ≥ 3 computing rt(G, π) is NP-complete.
Proof. Proving it is in NP is trivial, we can use a set of matchings as a witness. We give
a reduction from 3-SAT. We first define three atomic gadgets (see Figure 2) which will be
use to construct the variable and clause gadgets. Vertices whose pebbles are fixed (1-cycles)
are represented as red circles. Otherwise they are represented as black dots. So in the first
three sub-figures ((a)-(c)) the input permutation is (a, b)3. In all our constructions we shall
use permutations consisting of only 1 or 2 cycles. Each cycle labeled i will be represented
as the pair (ai, bi). If the correspondence between a pair is clear from the figure then we
shall omit the subscript. It is an easy observation that rt(P3, ((a, b))) = rt(P4, ((a, b))) =
rt(H, ((a, b))) = 3. In the case of the hexagon H we see that in order to route the pebbles
within 3 steps we have to use the left or the right path, but we cannot use both paths
simultaneously (i.e., a goes along the left path but b goes along the right and vice-versa).
Figure 2(e) shows a chain of diamonds connecting u to v. Where each diamond has a 2-cycle,
top and bottom. If vertex u is used to route any pebble other than the two pebbles to its
right then the chain construction forces v to be used in routing the two pebbles to its left.
This chain is called a diamond-chain. In our construction we only use chains of constant
length to simplify the presentation of our construction.
3We do not write the 1 cycles explicitly as is common.
5
(a)
a
b b
a a
b b
a
x y :z
C = x+ y + :z
H
A diamond chain
Shown as a path
A clause gadget
(b) (c) (d) (e)
P3 P4
u
v
vu
Figure 2: Atomic Gadgets, pairs (a, b) need to swap their pebbles. The unmarked red circles
have pebbles that are fixed.
x1
:x1
x2
:x2
:x1
x1 x2
:x2 :x3
x3 xmX
:xmX
a1 a2
a1 a2 a3 amX
b1 b2
b2b1 b3 bmX
(a)
(b)
H1 H2
H2H1 H3 HmX
u1 u2 u3
u3u2u1 u4
umX
umX+1
C
C
Figure 3: Variable graph of X. (a) is a special case for mX = 2, (b) is the general case.
2.2.1 Clause Gadget:
Say we have clause C = x ∨ y ∨ ¬z. In Figure 2(d) we show how to create a clause gadget.
This is referred to as the clause graph GC for the clause C. The graph in Figure 2(d) can
route πC = (aC , bC) in three steps by using one of the three paths between aC and bC . Say,
aC is routed to bC via x. Then it must be the case that vertex x is not used to route any
other pebbles. We say the vertex x is owned by the clause. Otherwise, it would be not
possible to route aC to bC in three steps via x. We can interpret this as follows. A clause
has a satisfying assignment iff its clause graph has a owned vertex.
6
2.2.2 Variable Gadget:
Construction of the variable gadgets is done in a similar manner. The variable gadget GX
corresponding to X is shown in Figure 3(b). Figure 3(a) is essentially a smaller version of
4(b) and is easier to understand. If we choose to route a1 and b1 via the top-left path passing
through x1 and u1 then (a2, b2) must be routed via x2 and u2. This follows from the fact that
since u1 is occupied the pebbles in the diamond chain C (the dashed line connecting u1 with
u3) must use u3 to route the right most pair. By symmetry, if we choose to route (a1, b1)
using the bottom right path (via ¬x1, u2) then we also have to choose the bottom right path
for (a2, b2). These two (and only two) possible (optimal) routing scheme can be interpreted
as variable assignment. Let GX be the graph corresponding to the variable X (Figure 3(b)).
The top-left routing scheme leaves the vertices ¬x1,¬x2, . . . free to be used for other purposes
since they will not be able take part in routing pebbles in GX . Thus this can be interpreted
as setting the variable X to false. This “free” vertex can be used by a clause (if the clause
has that literal) to route its own pebble pair. That is they can become owned vertices of
some clause. Similarly, the bottom right routing scheme can be interpreted as setting X to
true. For each variable we shall have a separate graph and a corresponding permutation on
its vertices. The permutation we will route on GX is πX = (a1b1)(a2b2) . . . (amX , bmX )πfX .
The permutation πfX corresponds to the diamond chain connecting u1 with umX+1. The size
of the graph GX is determined by mX , the number of clauses the variable X appears in.
2.2.3 Reduction:
For each clause C, if the literal x ∈ C then we connect xi ∈ GX (for some i) to the vertex
labeled x ∈ GC via a diamond chain. If ¬x ∈ C then we connect it with ¬xi via a diamond
chain. This is our final graph Gφ corresponding to an instance of a 3-SAT formula. The
input permutation is π = πX . . . πC . . . πf . . ., which is the concatenation of all the individual
permutations on the variable graphs, clause graphs and the diamond chains. This completes
our construction. We need to show, rt(Gφ, π) = 3 iff φ is satisfiable. Suppose φ is satisfiable.
Then for each variable X, if the literal x is true then we use bottom-right routing on GX ,
otherwise we use top-left routing. This ensures in each clause graph there will be at least
one owned vertex. Now suppose (Gφ, π) = 3. Then each clause graph has at least one owned
vertex. If x is a free vertex in some clause graph then ¬x is not a free vertex in any of the
other clause graphs, otherwise variable graph GX will not be able route its own permutation
in 3 steps. Hence the set of free vertices will be a satisfying assignment for φ. It is an
easy observation that the number of vertices in Gφ is polynomially bounded in n,m; the
number of variables and clauses in φ respectively and that Gφ can be explicitly constructed
in polynomial time.
Corollary 2.5. Computing rt(G, π) remains hard even when G is restricted to being 2-
connected.
7
2.3 Connected Colored Partition Problem (CCPP)
Our proof technique for Theorem 1 can be used to prove that the following problem is also
NP-hard. Let G be a graph whose vertices are colored with k colors. We say a partition
S = {S1, . . . , Sr} of the the vertex set V respects the coloring C (where C : V → {1, . . . , k})
if each partition either contains all vertices of some color or none of the vertices of that
color (necessarily r ≤ k). Further, we require the induced subgraph G[Si] be connected, for
every i. Given a graph G, a coloring C (with k colors) and a integer t ≤ n the decision
version of the problem asks, whether there exists a valid partitioning whose largest block has
a size of at most t. We denote this problem by CCPP(G, k, t). If we replace the requirement
of connectedness of the induced subgraphs with other efficiently verifiable properties then
it is a strict generalization of the better known monochromatic partitioning problems on
colored graphs (see for example [2]). Note that the connectivity requirement on the induced
subgraphs is what makes this problem graphical. In fact without it the problem becomes
trivial, as one can simply partition the vertices into monochromatic sets, which is the best
possible outcome. CCPP(G, k, t) is in P if t is constant. Since one can simply enumerate all
partitions and there are O(kt) of them.
Theorem 2.6. CCPP(G, k, t) is NP-complete for arbitrary k and t.
x1
x2 y2
y1
:z1
:z2
a
b
Figure 4: A modified clause gadget (from the proof of Theorem 1) for the clause C =
x+ y + ¬z.
Proof. The proof essentially uses a similar set of gadgets as used in the proof of Theorem 1.
The idea is to interpret a route as a connected partition. We show that even when each color
class is restricted to at most two vertices the problem remain NP-complete. This done via a
reduction from the 3-SAT problem. We reuse some of the gadgets from the proof of Theorem
1, but we interpret them differently. Lets discuss the clause gadgets first. In Figure 4 we see
the graph corresponding to the clause C = x+ y + ¬z. The vertices a and b have the same
color, lets say c so that they identify with the clause C. All the other vertices (shown as red
circles) have unique colors which also differs from c. Clearly any valid partition of C must
include both pair of vertices along some line. Hence in an optimal partition of the clause
graph the largest subgraph is of size 4.
The variable gadgets are same as before (see Figure 3) except we do away with the
diamond chain and fuse the two end vertices together. So for example in Figure 3 (a),
8
u1 = u3. We also make the gadgets twice as long, so instead of having mX hexagons we now
have 2mX number of them. The vertices (ai, bi) have the same color but which is distinct
from every other vertices. As with the clause graphs the red vertices in the variable gadgets
all have unique colors.
To construct the graph Gφ corresponding to a boolean formula φ we do the following.
Since we are not using the diamond chains anymore we directly fuse vertices from clause
graphs and variable graphs. So for example if the clause C has variable x as a true literal we
fuse two vertices xi and xj (for some i, j ≤ 2mX) to the two vertices x1 and x2 in the clause
graph. That is x1, x2 ∈ {xi, xj}. In every partition the pair ai, bi must be included since they
have the same color. Since each partition must be connected this can happen if either we
take the segment (ai, xi, ui, bi) or the segment (ai, ui+1 mod 2mX ,¬xi+1 mod 2mx , bi). Lets call
them top-left and bottom-right segments. Clearly, if we take the top-left segment as part of
some partition for any pair (ai, bi) we have to use the corresponding top-left segments for all
other (a, b) pairs in the same variable graph. Otherwise, the segments will not be connected.
Same is true with the bottom-right segments. This forces variable assignments. If we choose
the top left segments then the bottom-right vertices (¬xi’s) which corresponds to the negated
literals will be free and a pair of them can be use to partition a clause graph which contains
those literal vertices. If Gφ has a partitioning scheme such that every partition is of size 4
then φ is satisfiable. We can look at the partition to determine which segments were chosen
from the variable graph which determines the variable assignment. Since every clause graph
has been partitioned into components of size at most 4, we conclude that every clause is
satisfied. The other direction can be proven in a similar manner.
2.4 Routing As Best You Can
It is often desirable to determine how many packets we can send to their destination within a
certain number of steps. Such as propagating information in social media. In the context of
permutation routing this leads to a notion of maximum routability. Given two permutation
π and σ let |π − σ| be the number of fixed points in τ such that τπ = σ. Let us define
maximum routability mr(G, π, k) as follows:
mr(G, π, k) = max
σ∈Sn, rt(G,σ)≤k
|π − σ|
We denote by MaxRoute the problem of computing maximum routability. Essentially, σ is
a permutation out of all permutations that can be routed in ≤ k steps and that has the
maximum number of elements in their correct position as given by π. The permutation σ
may not be unique. It can be easily shown (as a corollary to Theorem 1) that the decision
version of this problem is NP-hard, since we can determine rt(G, π) by asking whether
mr(G, π, k) = n. (Of course rt(G, π) = O(n) for any graph, hence O(log n) number of
different choices of k is sufficient to compute rt(G, π) exactly.)
In this section we give an approximation algorithm for computing the maximum routabil-
ity when the input graph G satisfies the following restriction. If the maximum degree of G
is ∆ such that (∆ + 1)k = O(log2 n) then mr(G, π, k) can be approximated within a factor
9
of O(n log log n/ log n) from the optimal. Unfortunately a good approximation for rt(G, π)
does not lead to a good approximation ratio when computing mr(G, π, k) for any k > 2.
The reason being that in an optimal algorithm for routing π on G it is conceivable that all
pebbles are displaced at the penultimate stage and the last matching fixes all the displaced
pebbles.
Our approximation algorithm is based on a reduction to the MaxClique problem. The
MaxClique problem has been extensively studied. In fact it is one of the defining problems
for PCP-type systems of probabilistic verifiers [3]. It has been shown that MaxClique can
not be approximated within a n1−o(n) factor of the optimal [14]. The best known upper
bound for the approximation ratio is by Feige [12] of O(n(log log n/ log3 n)) which improves
upon Boppana and Halldorsson’s [13] result of O(n/ log2 n). Note that if there is a f(n)-
approximation for MaxClique then whenever the clique number of the graph is ω(f(n)), the
approximation algorithm returns a non-trivial clique (not a singleton vertex).
Theorem 2.7. Given a graph G whose maximum degree is ∆, in polynomial time we can
construct another graph Gclique, with |Gclique| = O(n(∆ + 1)k), such that if the clique number
of Gclique is κ then mr(G, π, k) = κ.
In the above theorem the graph Gclique will be an n-partite graph. Hence κ ≤ n =
O(|Gclique|/(∆+1)k). As long as we have (∆+1)k = O(log2 n) we can use the approximation
algorithm for MaxClique to get a non-trivial approximation ratio of O(n log log n/ log n).
Proof. Here we give the reduction from MaxRoute to MaxClique. First we augment G by
adding self-loops. Let this new graph be G′. Hence we can make every matching in G′
perfect by assuming each unmatched vertex is matched to itself. Observe that any routing
scheme on G′ induces a collection of walks for each pebble. This collection of walks are
constrained as follows. Let Wi and Wj corresponds to walks of pebbles starting at vertices
i and j respectively. Let Wi[t] be the position of the pebble at time step t. They must
satisfy the following two conditions: 1) Wi[t] 6= Wj[t] for all t ≥ 0. 2) Wi[t + 1] = Wj[t] iff
Wi[t] = Wj[t+ 1]. Now consider two arbitrary walks in G
′. We call them compatible iff they
satisfy the above two conditions. We can check if two walks are compatible in linear time.
Let Wi be the collection of all possible length k walks starting from i and ending at
π(i). Note that |Wi| = O((∆ + 1)k). For each w ∈ Wi we create a vertex in Gclique. Two
vertices u, v in Gclique are adjacent if they do not come from the same collection (u ∈ Wi
then v 6∈ Wi) and u and v are compatible walks in G′. Clearly, Gclique is n-partite, where
each collection of vertices from Wi forming a block. Furthermore, if Gclique has a clique of
size κ then it must be the case that there are κ mutually compatible walks in G′. These
walk determines a routing scheme (since they are compatible) that routes κ pebbles to their
destination. Now if Gclique has a clique number < κ then the largest collection of mutually
compatible length k walks must be < κ. Hence number of pebbles that can be routed to
their destination in at most k steps will be < κ.
In order to get a non-trivial approximation ratio we require that (∆ + 1)k = O(log2 n)
which implies that the above reduction is polynomial in n. This completes the proof.
10
3 Structural Results On The Routing Number
3.1 An Upper Bound For h-connected Graphs
It was shown in [1] that if a graph G is h-connected then its routing number has a lower
bound of Ω(n/h). This is easy to see since there exists h-connected graphs which have a
balanced bipartition with respect to some cut-set of size h. For such a graph the permutation
that routes every pebble from one partition to the other and vice-versa takes at least Ω(n/h)
matchings. In this section we give an upper bound. Let Gh be a induced connected subgraph
of G having h vertices, we will show rt(G) = O(n rt(Gh)/h). Hence if G has a h-clique then
rt(G) = O(n/h). In fact the result is more general. If Gh is an induced subgraph with ≤ h
vertices such that r = rt(Gh)/|Gh| is minimized then rt(G) = O(nr).
We use the classical Lovasz-Gyori partition theorem for h-connected graphs for this pur-
pose:
Theorem 3.1 (Lovasz-Gyori). If G is a h-connected graph then for any choice of positive
numbers n1, . . . , nh with n1+. . .+nh = n and any set of vertices v1, . . . , vh there is a partition
of the vertices V1, . . . , Vh with vi ∈ Vi and |Vi| = ni such that the induced subgraph G[Vi] is
connected for all 1 ≤ i ≤ h.
We prove a combinatorial result. We have a lists Li, 1 ≤ i ≤ a, each of length b. Each
element of a list is a number c, 1 ≤ c ≤ a. Further, across all lists, each number c occurs
exactly b times.
Lemma 3.2. Given lists as described, there exists an a× b array A such that the ith row is
a permutation of Li and each column is a permutation of {1, 2, 3, . . . , a}.
Proof. By Hall’s Theorem for systems of distinct representatives [10], we know that we can
choose a representative from each Li to form the first column of A. The criterion of Hall’s
Theorem is that, for any k, any set of k lists have at least k distinct numbers; but there are
only b of each number so k−1 numbers can not fill up k lists. Now remove the representative
from each each list, and iterate on the collection of lists of length b− 1.
To prove our upper bound we need an additional lemma.
Lemma 3.3. Given a set S of k pebbles and tree T with k pebbles on its k vertices. Suppose
we are allowed an operation that replaces the pebble at the root of T by a pebble from S. We
can replace all the pebbles in T with the pebbles from S in Θ(k) steps, each a replace or a
matching step.
Proof. Briefly, as each pebble comes from S it is assigned a destination vertex in T , in reverse
level order (the root is at level 0). After a replace-root operation, there are two matching
steps; these three will repeat. The first matching step uses disjoint edges to move elements
of S down to an odd level and the second matching step moves elements of S down to an
even level. Each matching moves every pebble from S, that has not reached its destination,
towards its destination. The new pebbles move without delay down their paths in this
11
pipelined scheme. (The invariant is that each pebble from S is either at its destination, or
at an even level before the next replace-root operation.)
Theorem 3.4. If G is h-connected and Gh is an induced connected subgraph of order h then
rt(G) = O(n rt(Gh)/h).
Proof. Let Vh = {u1, . . . , uh} be the vertices in Gh. We take these vertices as the set of k
vertices in Theorem 2. We call them ports as they will be used to route pebbles between
different components. Without loss of generality we can assume p = n/h is an integer.
Let n1 = n2 = . . . = nh = p and Vi be the block of the partition such that ui ∈ Vi. Let
Hi = G[Vi]. Then for any permutation π on G:
1. Route the pebbles in Hi according to some permutation πi. Since Hi has n/h vertices
and is connected it takes O(n/h) matchings.
2. Next use Gh, n/h times, to route pebbles between different partitions. We show that
this can be done in O(n rt(Gh)/h) matchings. (The “replace-root” step of Lemma 4,
is actually the root replacements done by routing on Gh.)
3. Finally, route the pebbles in each Hi in parallel. Like step 1, this also can be accom-
plished in O(n/h) matchings.
Clearly the two most important thing to attend to in the above procedure are the permu-
tations in step 1 and the routing scheme of step 2. We can assume that each Hi is a tree
rooted at ui (since each Hi has a spanning tree). Thus the decomposition looks like the one
shown in Figure 5.
G[V1]T1
T2
T4
T3
Gh
Figure 5: G is decomposed into 4 connected blocks, which are connected to each other via
Gh.
The permutation π on G indicates for each element of Hi, which Hj it wants to be routed
to, where j could be i. So each Hi can build a list Li of indices of the ports of Gh that
it wants to route its elements to (again, possibly to its own port). The lists satisfy the
12
conditions of Lemma 3, with a = h and b = n/h, We will use the columns of the array A to
specify the permutations routed using Gh in step 2. Note that step 1 will need to preprocess
each Hi so that the algorithm of Lemma 4 will automatically deliver the elements of Hi up
to ui in the order specified by the ith row of A.
Once the pebbles are rearranged in step 1, we use the graph Gh to route them to their
destination components. Each such routing takes rt(Gh) steps. Between these routings on
Gh the incoming pebble at any of the port vertices is replaced by the next pebble to be
ported; this requires 2 matching steps as seen in Lemma 4. Hence, after rt(Gh) + 2 steps
a set of h pebbles are routed to their destination components. This immediately gives the
bound of the theorem.
3.2 Relation Between Clique Number and Routing Number
Theorem 3.5. For a connected graph G with clique number κ its routing number is bounded
by O(n− κ).
Proof. Let H be a clique in G of size κ. Let G\H be the minor of G after the contraction
of the subgraph H. Let the vertex that H has been contracted to be v. Further, let T
be a spanning tree of G\H . When routing on G\H we can treat v as any other vertex of
G\H . Taking into account the fact that v can store more than one pebble internally. When
v participates in a matching with some other vertex u in G\H we assume that exchanging
pebbles takes 3 steps. This accounts for the fact that the pebble thats need to be swapped
with the pebbles at u was not on a vertex adjacent to u in the un-contracted graph G.
The basic idea is to break the routing into two steps. In the first step we simply move all
pebbles in v whose final detination is not in v (i.e. not in un-contracted H) out. For a
tree, it is known that [18] we can route a subset of p pebbles where each pebble needs to be
moved at most l distance in ≤ p + 2l steps. Since T has a diameter at most n − κ and at
most min(κ, n − κ) pebbles need to be moved out of v the first step can be accomplished
≤ 3(n−κ) +O(1) steps. At this point we can employ any optimal tree routing algorithm on
T where we charge 3 time units whenever v is part of the matching to route all the pebbles
in G\H . If we use the algorithm presented in [5] then we see that the routing takes at most
15/2(n− κ) + o(n) steps for any permutation.
References
[1] Alon, N., Chung, F. R., & Graham, R. L. (1994). Routing permutations on graphs via
matchings. SIAM journal on discrete mathematics, 7(3), 513-530.
[2] Gyárfás, A., Ruszinkó, M., Sárközy, G., & Szemerédi, E. (2011). Partitioning 3-colored
complete graphs into three monochromatic cycles. Electronic Journal of Combinatorics,
18, 1-16.
13
[3] Feige, U., Goldwasser, S., Lovász, L., Safra, S., & Szegedy, M. (1996). Interactive proofs
and the hardness of approximating cliques. Journal of the ACM (JACM), 43(2), 268-292.
[4] Kawahara, J., Saitoh, T., & Yoshinaka, R. (2017, March). The time complexity of the to-
ken swapping problem and its parallel variants. In International Workshop on Algorithms
and Computation (pp. 448-459). Springer, Cham.
[5] Zhang, L. (1999). Optimal bounds for matching routing on trees. SIAM Journal on
Discrete Mathematics, 12(1), 64-77.
[6] Li, W. T., Lu, L., & Yang, Y. (2010). Routing numbers of cycles, complete bipartite
graphs, and hypercubes. SIAM Journal on Discrete Mathematics, 24(4), 1482-1494.
[7] Micali, S., & Vazirani, V. V. (1980, October). An O(
√
|V ||E|) algoithm for finding
maximum matching in general graphs. In Foundations of Computer Science, 1980., 21st
Annual Symposium on (pp. 17-27). IEEE.
[8] Yamanaka, K., Demaine, E. D., Ito, T., Kawahara, J., Kiyomi, M., Okamoto, Y., Toshiki,
S., Akira, S., Kei, U., & Uno, T. (2015). Swapping labeled tokens on graphs. Theoretical
Computer Science, 586, 81-94.f computer programming: sorting and searching (Vol. 3).
Pearson Education.
[9] Miltzow, T., Narins, L., Okamoto, Y., Rote, G., Thomas, A., & Uno, T. (2016). Approx-
imation and hardness for token swapping. arXiv preprint arXiv:1602.05150.
[10] Hall, M. (1998). Combinatorial theory (Vol. 71). John Wiley & Sons.
[11] Even, S., & Goldreich, O. (1981). The minimum-length generator sequence problem is
NP-hard. Journal of Algorithms, 2(3), 311-313.
[12] Feige, U. (2004). Approximating maximum clique by removing subgraphs. SIAM Journal
on Discrete Mathematics, 18(2), 219-225.
[13] Boppana, R., & Halldrsson, M. M. (1992). Approximating maximum independent sets
by excluding subgraphs. BIT Numerical Mathematics, 32(2), 180-196.
[14] Engebretsen, L., & Holmerin, J. (2000). Clique is hard to approximate within n1−o(1).
Automata, Languages and Programming, 2-12.
[15] Jerrum, M. R. (1985). The complexity of finding minimum-length generator sequences.
Theoretical Computer Science, 36, 265-289.
[16] Banerjee, I., & Richards, D. (2016). Routing and Sorting Via Matchings On Graphs.
arXiv preprint arXiv:1604.04978.
[17] Kawahara, J., Saitoh, T., & Yoshinaka, R. (2017, March). The time complexity of
the token swapping problem and its parallel variants. In International Workshop on
Algorithms and Computation (pp. 448-459). Springer, Cham.
14
[18] Benjamini, I., Shinkar, I., & Tsur, G. (2014). Acquaintance time of a graph. SIAM
Journal on Discrete Mathematics, 28(2), 767-785.
15

