Mathematical Fundamentals and 
Analysis of Algorithms
CSE 373  
Data Structures
Math. Fund. and Anal. of Alg 2
Reading
• All of Chapter 4
• It’s short!
• You should know most of it already
Math. Fund. and Anal. of Alg 3
Mathematical Background
• We will review:
› Powers and Logs 
› Series
• We will formally define the Big Oh 
notation
› Important functions for algorithm analysis
› An example of algorithm analysis
Math. Fund. and Anal. of Alg 4
Floor and Ceiling
 X
 X
Floor function: the largest integer < X
Ceiling function: the smallest integer > X
      2232.722.7 =−=−=
      2222.332.3 =−=−=
Math. Fund. and Anal. of Alg 5
Facts about Floor and Ceiling
 
 
    integer an is n ifnn/2n/23.
1XXX2.
XX1X1.
=+
+<≤
≤<−
Math. Fund. and Anal. of Alg 6
Powers of 2
• Many of the numbers we use in Computer 
Science are powers of 2
• Binary numbers (base 2) are easily 
represented in digital computers
› each "bit" is a 0 or a 1
› 20=1, 21=2, 22=4, 23=8, 24=16,…, 210 =1024 (1K)
› , an n-bit wide field can hold 2n positive integers:
• 0 ≤k ≤2n-1
Math. Fund. and Anal. of Alg 7
Unsigned binary integers
• For unsigned integers in a fixed width 
field
› the minimum value is 0
› the maximum value is 2n-1, where n is the 
number of bits in the field
› The value is
• Each bit position represents a power of 
2 with ai = 0 or ai = 1
ini
i i
a 21
0∑
−=
=
Math. Fund. and Anal. of Alg 8
Logs and exponents
• Definition: log2 x = y means x = 2y
› 8 = 23, so log28 = 3
› 65536= 216, so log265536 = 16
• Notice that log2x tells you how many bits 
are needed to hold x values
› 8 bits holds 256 numbers: 0 to 28-1 = 0 to 255
› log2256 = 8
x, 2x and log2x
x = 0:.1:4
y = 2.^x
plot(x,y,'r')
hold on
plot(y,x,'g')
plot(y,y,'b')
2x and log2x
x = 0:10
y = 2.^x
plot(x,y,'r')
hold on
plot(y,x,'g')
plot(y,y,'b')
Math. Fund. and Anal. of Alg 11
Properties of logs (of the 
mathematical kind)
• We will assume logs to base 2 unless 
specified otherwise
• log AB = log A + log B
› A=2log2A and B=2log2B
› AB = 2log2A • 2log2B = 2log2A+log2B
› so log2AB = log2A + log2B
› [note: log AB ≠ log A•log B]
Math. Fund. and Anal. of Alg 12
Other log properties
• log A/B = log A – log B
• log (AB) = B log A
• log log X < log X < X for all X > 0 
› log log X = Y means
› log X grows slower than X
• called a “sub-linear” function
› log log X grows very slowly (but it grows!)
X2
Y2 =
Math. Fund. and Anal. of Alg 13
A log is a log is a log
• Any base x log is equivalent to base 2 log 
within a constant factor:
x
a
ax
2
2
log
log
log =
Math. Fund. and Anal. of Alg 14
Arithmetic Series
•
• The sum is
› S(1) = 1
› S(2) = 1+2 = 3
› S(3) = 1+2+3 = 6
•
∑
=
=+++=
N
1i
iN21S(N) K
∑
=
+=
N
1i 2
1)N(Ni Why is this formula useful 
when you analyze algorithms?
(
Johann Carl Gauss
1777-1855
Math. Fund. and Anal. of Alg 15
Algorithm Analysis
• Consider the following program 
segment:
x:= 0;
for i = 1 to N do
for j = 1 to i do
x := x + 1;
• What is the value of x at the end? 
Math. Fund. and Anal. of Alg 16
Analyzing the Loop
• Total number of times x is incremented is the 
number of “instructions” executed =
• You’ve just analyzed the program!
› Running time of the program is proportional to 
N(N+1)/2 for all N
› O(N2) (we’ll define formally the Big-Oh notation in 
a few slides)
∑
=
+==+++
N
1i 2
1)N(Ni...321
Math. Fund. and Anal. of Alg 17
Motivation for Algorithm 
Analysis
• Suppose you are 
given two algorithms 
A and B for solving a 
problem
• The running times 
TA(N) and TB(N) of A 
and B as a function of 
input size N are given
TA
TB
R
un
 T
im
e
Input Size N
Which is better?
Math. Fund. and Anal. of Alg 18
More Motivation
• For large N, the running time of A and B 
is:
Now which 
algorithm would 
you choose?Ru
n 
Ti
m
e
Input Size N
TA(N) = 50N
TB(N) = N2
Math. Fund. and Anal. of Alg 19
Asymptotic Behavior
• The “asymptotic” performance as N → ∞, 
regardless of what happens for small input 
sizes N, is generally most important
• Performance for small input sizes may 
matter in practice, if you are sure that small
N will be common forever
• We will compare algorithms based on how 
they scale for large values of N
Math. Fund. and Anal. of Alg 20
Order Notation
• Mainly used to express upper bounds on time 
of algorithms. “n” is the size of the input.
• T(n) = O(f(n)) if there are constants c and n0
such that T(n) < c f(n) for all n > n0.
› 10000n + 10  n log2 n = O(n log n)
› .00001 n2 ≠ O(n log n)
• Order notation ignores constant factors and 
low order terms.
Math. Fund. and Anal. of Alg 21
Why Order Notation
• Program performance may vary by a 
constant factor depending on the 
compiler and the computer used.
• In asymptotic performance (n →∞) the 
low order terms are negligible.
Math. Fund. and Anal. of Alg 22
Some Basic Time Bounds
• Logarithmic time is O(log n)
• Linear time is O(n)
• O(nlogn) grows faster than linear but slower 
than quadratic 
• Quadratic time is 0(n2)
• Cubic time is O(n3)
• Polynomial time is O(nk) for some k.
• Exponential time is O(cn) for some c > 1.
Math. Fund. and Anal. of Alg 23
Kinds of Analysis
• Asymptotic – uses order notation, ignores 
constant factors and low order terms.
• Worst case – time bound valid for all inputs of 
length n.
• Average case – time bound valid on average 
– requires a distribution of inputs.
• Amortized – worst case time averaged over a 
sequence of operations.
• Others – best case, common case (80%-
20%), upper bound, lower bound etc.
Math. Fund. and Anal. of Alg 24
Example of Analysis or 
Recursion Used Badly
• Classic example: Fibonacci numbers Fn
0,1, 1, 2, 3, 5, 8, 13, 21, …
› F0 = 0 , F1 = 1 (Base Cases)
› Rest are sum of preceding two
Fn = Fn-1 + Fn-2 (n > 1)
Leonardo Pisano
Fibonacci (1170-1250)
Math. Fund. and Anal. of Alg 25
Recursive Procedure for 
Fibonacci Numbers
fib(n : integer): integer {
Case { 
n < 0 : return 0; 
n = 1 : return 1;
else : return fib(n-1) + fib(n-2);
}
}
• Easy to write: looks like the definition of Fn
• But, can you spot the big problem?
Math. Fund. and Anal. of Alg 26
Recursive Calls of Fibonacci 
Procedure
• Re-computes fib(N-i) multiple times!
Math. Fund. and Anal. of Alg 27
Fibonacci Analysis
2)-T(n1)-T(nT(n)
1T(1)T(0),
fib(n). compute to time the is T(n)
+≥
≥
It can be shown by induction that T(n) > φ n-2
where
1.62
2
51 ≈+=φ
So, is it linear, quadratic, polynomial time, 
exponential?
Math. Fund. and Anal. of Alg 28
Iterative Algorithm for 
Fibonacci Numbers
fib_iter(n : integer): integer {
fib0, fib1, fibresult, i : integer;
fib0 := 0; fib1 := 1;
case {_ 
n < 0 : fibresult := 0;
n = 1 : fibresult := 1;
else :
for i = 2 to n do {
fibresult := fib0 + fib1;
fib0 := fib1;
fib1 := fibresult;
}
} 
return fibresult;
} 
So is it linear, quadratic, 
polynomial time, 
exponential?
Math. Fund. and Anal. of Alg 29
Recursion Summary
• Recursion may simplify programming, but 
beware of generating large numbers of 
calls
› Function calls can be expensive in terms of 
time and space
• Be sure to get the base case(s) correct!
• Each step must get you closer to the base 
case
Math. Fund. and Anal. of Alg 30
Justification Techniques
• By example; By contradiction; By induction
• Using preconditions and postconditions
› Predicate is true before statement executes (precondition)
› Predicate is true after statement executes (postcondition)
• Using invariants (mostly for loops)
› Initial claim. Predicate true before the loop begins
› If predicate true before iteration i begins, it will be true after 
iteration i terminates
› The final statement (after loop has totally executed) implies 
that the invariant has held

