Contracting a Planar Graph Efficiently
Jacob Holm∗1, Giuseppe F. Italiano†2, Adam Karczmarz‡3,
Jakub Łącki§4, Eva Rotenberg1, and Piotr Sankowski‡¶3
1University of Copenhagen, Denmark
{jaho|roden}@di.ku.dk
2University of Rome Tor Vergata
giuseppe.italiano@uniroma2.it
3University of Warsaw, Poland
{a.karczmarz|sank}@mimuw.edu.pl
4Google Research, New York
jlacki@google.com
Abstract
We present a data structure that can maintain a simple planar graph under edge contractions in
linear total time. The data structure supports adjacency queries and provides access to neighbor lists
in O(1) time. Moreover, it can report all the arising self-loops and parallel edges.
By applying the data structure, we can achieve optimal running times for decremental bridge
detection, 2-edge connectivity, maximal 3-edge connected components, and the problem of finding a
unique perfect matching for a static planar graph. Furthermore, we improve the running times of
algorithms for several planar graph problems, including decremental 2-vertex and 3-edge connectivity,
and we show that using our data structure in a black-box manner, one obtains conceptually simple
optimal algorithms for computing MST and 5-coloring in planar graphs.
1 Introduction
An edge contraction is one of the fundamental graph operations. Given an undirected graph and an
edge e, contracting the edge e consists in removing it from the graph and merging its endpoints. The
notion of a contraction has been used to describe a number of prominent graph algorithms, including
Edmonds’ algorithm for computing maximum matchings [4] or Karger’s minimum cut algorithm [11].
Edge contractions are of particular interest in planar graphs, as a number of planar graph properties
are easiest described using contractions. For example, it is well-known that a graph is planar precisely
when it cannot be transformed into K5 or K3,3 by contracting edges or removing vertices or edges.
Moreover, contracting an edge preserves planarity.
While a contraction operation is conceptually very simple, its efficient implementation is challenging.
By using standard data structures (e.g. balanced binary trees), one can maintain adjacency lists of a
graph in polylogarithmic amortized time. However, in many planar graph algorithms this becomes a
∗This research is supported by the Advanced Grant DFF-0602-02499B from the Danish Council for Independent Research
under the Sapere Aude research career programme.
†Partly supported by the Italian Ministry of Education, University and Research under Project AMANDA (Algorithmics
for MAssive and Networked DAta).
‡Supported by the Polish National Science Center grant number 2014/13/B/ST6/01811.
§When working on this paper Jakub Łącki was partly supported by the EU FET project MULTIPLEX no. 317532 and
the Google Focused Award on ”Algorithms for Large-scale Data Analysis” and Polish National Science Center grant number
2014/13/B/ST6/01811. Part of this work was done while Jakub Łącki was visiting the Simons Institute for the Theory of
Computing.
¶The work of P. Sankowski is a part of the project TOTAL that has received funding from the European Research
Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 677651).
1
ar
X
iv
:1
70
6.
10
22
8v
1 
 [
cs
.D
S]
  3
0 
Ju
n 
20
17
bottleneck. As an example, consider the problem of computing a 5-coloring of a planar graph. There exists
a very simple algorithm based on contractions [17], but efficient implementations use some more involved
planar graph properties [5, 17, 18]. For example, the algorithm by Matula, Shiloach and Tarjan [17] uses
the fact that every planar graph has either a vertex of degree at most 4 or a vertex of degree 5 adjacent
to at least four vertices each having degree at most 11. Similarly, although there exists a very simple
algorithm for computing a MST of a planar graph based on edge contractions, various different methods
have been used to implement it efficiently [5, 15, 16].
Our Results. We show a data structure that can efficiently maintain a planar graph subject to edge
contractions in O(n) total time, assuming the standard word-RAM model with word size Ω(log n). It can
report groups of parallel edges and self-loops that emerge. It also supports constant-time adjacency queries
and maintains the neighbor lists and degrees explicitly. The data structure can be used as a black-box
to implement planar graph algorithms that use contractions. In particular, it can be used to give clean
and conceptually simple implementations of the algorithms for computing 5-coloring or MST that do not
manipulate the embedding. More importantly, by using our data structure we give improved algorithms
for a few problems in planar graphs. In particular, we obtain optimal algorithms for decremental 2-edge-
connectivity, finding unique perfect matching, and computing maximal 3-edge-connected subgraphs. We
also obtain improved algorithms for decremental 2-vertex and 3-edge connectivity, where the bottleneck
in the state-of-the-art algorithms [7] is detecting parallel edges under contractions. For detailed theorem
statements, see Sections 3 and 4.
Related work. The problem of detecting self-loops and parallel edges under contractions is implicitly
addressed by Giammarresi and Italiano [7] in their work on decremental (edge-, vertex-) connectivity in
planar graphs. Their data structure uses O(n log2 n) total time.
In their book, Klein and Mozes [12] show that there exists a data structure maintaining a planar
graph under edge contractions and deletions and answering adjacency queries in O(1) worst-case time.
The update time is O(log n). This result is based on the work of Brodal and Fagerberg [1], who showed
how to maintain a bounded outdegree orientation of a dynamic planar graph so that edge insertions and
deletions are supported in O(log n) amortized time.
Gustedt [9] showed an optimal solution to the union-find problem, in the case when at any time,
the actual subsets form disjoint, connected subgraphs of a given planar graph G. In other words, in
this problem the allowed unions correspond to the edges of a planar graph and the execution of a union
operation can be seen as a contraction of the respective edge.
Our Techniques. It is relatively easy to give a simple vertex merging data structure for general graphs,
that would process any sequence of contractions in O(m log2 n) total time and support the same queries
as our data structure in O(log n) time. To this end, one can store the lists N(v) of neighbors of individual
vertices as balanced binary trees. Upon a contraction of an edge uv, or a more general operation of
merging two (not necessarily adjacent) vertices u, v, N(u) and N(v) are merged by inserting the smaller
set into the larger one (and detecting loops and parallel edges by the way, at no additional cost). If we
used hash tables instead of balanced BSTs, we could achieve O(log n) expected amortized update time
and O(1) query time. In fact, such an approach was used in [7].
To obtain the speed-up we take advantage of planarity. Our general idea is to partition the graph
into small pieces and use the above simple-minded vertex merging data structures to solve our problem
separately for each of the pieces and for the subgraph induced by the vertices contained in multiple pieces
(the so-called boundary vertices). Due to the nature of edge contractions, we need to specify how the
partition evolves when our graph changes.
The data structure builds an r-division (see Section 2) R = P1, P2, . . . of G0 for r = log4 n. The
set ∂R of boundary vertices (i.e., those shared among at least two pieces) has size O(n/ log2 n). Let
(V0, E0) denote the original graph, and (V,E) denote the current graph (after performing some number
of contractions). Then we can denote by φ : V0 → V a function such that the initial vertex v0 ∈ V0 is
contracted into φ(v0). We use vertex merging data structures to detect parallel edges and self-loops in
the “top-level” subgraph G[φ(∂R)], which contains only edges between boundary vertices, and separately
for the “bottom-level” subgraphs G[φ(V (Pi))] \G[φ(R)]. At any time, each edge of G is contained in
2
exactly one of the defined subgraphs, and thus, the distribution of responsibility for handling individual
edges is based solely on the initial r-division.
However, such an assignment of responsibilities gives rise to additional difficulties. First, a contraction
of an edge in a lower-level subgraph might cause some edges “flow” from this subgraph to the top-level
subgraph (i.e., we may get new edges connecting boundary vertices). As such an operation turns out to
be costly in our implementation, we need to prove that the number of such events is only O(n/ log2 n).
Another difficulty lies in the need of keeping the individual data structures synchronized: when an
edge of the top-level subgraph is contracted, pairs of vertices in multiple lower-level subgraphs might need
to be merged. We cannot afford iterating through all the lower-level subgraphs after each contraction in
G[φ(∂R)]. This problem is solved by maintaining a system of pointers between representations of the
same vertex of V in different data structures and another clever application of the smaller-to-larger merge
strategy.
Such a two-level data structure would yield a data structure with O(n log log n) total update time.
To obtain a linear time data structure, we further partition the pieces Pi and add another layer of
maintained subgraphs on O(log4 log4 n) = O(log4 log n) vertices. These subgraphs are so small that we
can precompute in O(n) time the self-loops and parallel edges for every possible graph on t vertices and
every possible sequence of edge contractions.
We note that this overall idea of recursively reducing a problem with an r-division to a size when
microencoding can be used has been previously exploited in [9] and [14] (Gustedt [9] did not use r-divisions,
but his concept of a patching could be replaced with an r-division). Our data structure can be also seen
as a solution to a more general version of the planar union-find problem studied by Gustedt [9]. However,
maintaining the status of each edge e of the initial graph G (i.e., whether e has become a self-loop or a
parallel edge) subject to edge contractions turns out to be a serious technical challenge. For example,
in [9], the requirements posed on the bottom-level union-find data structures are in a sense relaxed and it
is not necessary for those to be synchronized with the top-level union-find data structure.
Organization of the Paper. The remaining part of this paper is organized as follows. In Section 2,
we introduce the needed notation and definitions, whereas in Section 3 we define the operations that our
data structure supports. Then, in Section 4 we present a series of applications of our data structure. In
Section 5, we provide a detailed implementation of our data structure.
2 Preliminaries
Throughout the paper we use the term graph to denote an undirected multigraph, that is we allow the
graphs to have parallel edges and self-loops. Formally, each edge e of such a graph is a pair ({u,w}, id(e))
consisting of a pair of vertices and a unique identifier used to distinguish between the parallel edges. For
simplicity, we skip this third coordinate and use just uw to denote one of the edges connecting vertices u
and w. If the graph contains no parallel edges and no self-loops, we call it simple.
For any graph G, we denote by V (G) and E(G) the sets of vertices and edges of G, respectively.
A graph G′ is called a subgraph of G if V (G′) ⊆ V (G) and E(G′) ⊆ E(G). We define G1 ∪ G2 =
(V (G1) ∪ V (G2), E(G1) ∪ E(G2)) and G1 \G2 = (V (G1), E(G1) \ E(G2)). For S ⊆ V (G), we denote by
G[S] the induced subgraph (S, {uv : uv ∈ E(G), {u, v} ⊆ S}).
For a vertex v ∈ V , we define N(v) = {u : uv ∈ E, u 6= v} to be the neighbor set of v.
A cycle of a graph G is a nonempty set C ⊆ E(G), such that for some ordering of edges C =
{u1w1, . . . , ukwk}, we have wi = ui+1 for 1 ≤ i < k and wk = u1, and the vertices u1, . . . , uk are distinct.
The length of a cycle C is simply |C|. Note that this definition allows cycles of length 1 (self-loop) or 2
(a pair of parallel edges), but does not allow non-simple cycles of length 3 or more. A cut is a minimal
(w.r.t. inclusion) set C ⊆ E(G), such that G \ C has more connected components than G.
Let G = (V,E) be a graph and xy = e ∈ E. We use G− e to denote the graph obtained from G by
removing e and G/e to denote the graph obtained by contracting an edge e (in the case of a contraction
e may not be a self-loop, i.e., x 6= y). We will often look at contraction from the following perspective:
as a result of contracting e, all edge endpoints equal to x or y are replaced with some new vertex z. In
some cases it is convenient to assume z ∈ {x, y}. This yields a 1-to-1 correspondence between the edges
of G− e and the edges of G/e. Formally, we assume that the contraction preserves the edge identifiers,
i.e., e1 ∈ E(G− e) and e2 ∈ E(G/e) are corresponding if and only if id(e1) = id(e2).
3
Note that contracting an edge may introduce parallel edges and self-loops. Namely, for each edge that
is parallel to e in G, there is a self-loop in G/e. And for each cycle of length 3 that contains e in G, there
is a pair of parallel edges in G/e.
Planar graphs. An embedding of a planar graph is a mapping of its vertices to distinct points and
edges to non-crossing curves in the plane. We say that a planar graph G is plane, if some embedding of
G is assumed. A face of a connected plane G is a maximal open connected set of points not in the image
of any vertex or edge in the embedding of G.
Figure 1: A semi-strict graph with 6
vertices and 5 faces.
Semi-strictness. We say that a connected plane graph G is
semi-strict [12] if each of its faces has a boundary of at least
3 edges (see Figure 1). We can obtain a maximal semi-strict
subgraph of a plane embedded multigraph H as follows: for each
set P of parallel edges xy of H such that they form a contiguous
fragment of the edge rings of both x and y, remove from H all
edges of P except one.
Fact 2.1. A semi-strict plane graph G with n vertices has at most 3n− 6 edges.
Proof. We note that each face of G has at least 3 edges and apply the Euler’s formula.
Duality. Let G be a plane graph. We denote by G∗ the dual graph of G. Each edge of G naturally
corresponds to an edge of G∗. We denote by e∗ the edge of G∗ that corresponds to e ∈ E(G). More
generally, if E1 ⊆ E(G) is a set of edges of G, we set E∗1 = {e∗|e ∈ E1}.
We exploit the following relations between G and G∗. Deleting an edge e of G corresponds to
contracting the edge e∗ in G∗, that is (G− e)∗ = G∗/e∗. Moreover, C ⊆ E is a cut in G iff C∗ is a cycle
in G∗. In particular, a bridge e in G corresponds to a self-loop in G∗ and a two-edge cut in G corresponds
to a pair of parallel edges in G∗.
Planar graph partitions. Let G be a simple planar graph. Let a piece be subgraph of G with no
isolated vertices. For a piece P , we denote by ∂P the set of vertices v ∈ V (P ) such that v is adjacent
to some edge of G that is not contained in P . ∂P is also called the set of boundary vertices of P . An
r-division R of G is a partition of G into O(n/r) edge-disjoint pieces such that each piece P ∈ R has O(r)
vertices and O(
√
r) boundary vertices. For an r-division R, we also denote by ∂R the set
⋃
Pi∈R ∂Pi.
Clearly, |∂R| = O(n/
√
r).
Lemma 2.2 ([8, 13, 19]). An r-division of a planar graph G can be computed in linear time.
3 The Data Structure Interface
In this section we specify the set of operations that our data structure supports so that it fits our
applications. It proves beneficial to look at the graph undergoing contractions from two perspectives.
1. The adjacency viewpoint allows us to track the neighbor sets of the individual vertices, as if G was
simple at all times.
2. The edge status viewpoint allows us to track, for all the original edges E0, whether they became
self-loops or parallel edges, and also track how E0 is partitioned into classes of pairwise-parallel
edges.
Let G0 = (V0, E0) be a planar graph used to initialize the data structure. Recall that any contraction
alters both the set of vertices and the set of edges of the graph. Throughout, we let G = (V,E) denote
the current version of the graph, unless otherwise stated.
Each edge e ∈ E(G) can be either a self-loop, an edge parallel to some other edge e′ 6= e (we call such
an edge parallel), or an edge that is not parallel to any other edge of G (we call it simple in this case).
An edge e ∈ E(G) that is simple might either get contracted or might change into a parallel edge as a
4
result of contracting other edges. Similarly, a parallel edge might either get contracted or might change
into a self-loop. Note that, during contractions, neither can a parallel edge ever become simple, nor can a
self-loop become parallel.
Observe that parallelism is an equivalence relation on the edges of G. Once two edges e1, e2 connecting
vertices u, v ∈ V become parallel, they stay parallel until some edge e3 (possibly equal to e1 or e2) parallel
to both of them gets contracted. However, groups of parallel edges might merge (Figure 2) and this might
also be a valuable piece of information.
Figure 2: Contracting the blue
dotted edge will merge two
groups of parallel edges.
To succinctly describe how the groups of parallel edges change, we
report parallelism in a directed manner, as follows. Each group Y ⊆ E
of parallel edges in G is assumed to have its representative edge α(Y ).
For e ∈ Y we define α(e) = α(Y ). When two groups of parallel edges
Y1, Y2 ⊆ E merge as a result of a contraction, the data structure chooses
α(Yi) for some i ∈ {1, 2} to be the new representative of the group
Y1 ∪ Y2 and reports an ordered pair α(Y3−i)→ α(Yi) to the user. We
call each such pair a directed parallelism. After such an event, α(Y3−i)
will not be reported as a part of a directed parallelism anymore. The
choice of i can also be made according to some fixed strategy, e.g., if the edges are assigned weights `(·)
then we may choose α(Yi) so that `(α(Yi)) ≤ `(α(Y3−i)). This is convenient in what Klein and Mozes
[12] call strict optimization problems, such as MST, where we can discard one of any two parallel edges
based only on these edges.
Note that at any point of time the set of directed parallelisms reported so far can be seen as a forest
of rooted trees T , such that each tree T of T represents a group Y of parallel edges of G. The root of T
is equal to α(Y ).
When some edge is contracted, all edges parallel to it are reported as self-loops. Clearly, each edge e
is reported as a self-loop at most once. Moreover, it is reported as a part of a directed parallelism e→ e′,
e′ 6= e, at most once.
We are now ready to define the complete interface of our data structure.
• init(G0 = (V0, E0), `): initialize the data structure. ` is an optional weight function.
• (s, P, L) := contract(e), for e ∈ E: contract the edge e. Let e = uv. The call contract(e) returns
a vertex s resulting from merging u and v, and two lists P , L of new directed parallelisms and
self-loops, respectively, reported as a result of contraction of e.
• vertices(e), for e ∈ E: return u, v ∈ V such that e = uv.
• neighbors(u), for u ∈ V : return an iterator to the list {(v, α(uv)) : v ∈ N(u)}.
• deg(u), for u ∈ V : find the number of neighbors of u in G.
• edge(u, v), for u, v ∈ V : if uv ∈ E, then return α(uv). Otherwise, return nil.
The following theorem summarizes the performance of our data structure.
Theorem 3.1. Let G = (V,E) be a planar graph with |V | = n and |E| = m. There exists a data structure
supporting edge, vertices, neighbors and deg in O(1) worst-case time, and whose initialization and
any sequence of contract operations take O(n+m) expected time, or O(n+m) worst-case time, if no
edge operations are performed. The data structure supports iterating through the neighbor list of a vertex
with O(1) overhead per element.
4 Applications
Decremental Edge- and Vertex-Connectivity. In the decremental k-edge (k-vertex) connectivity
problem, the goal is to design a data structure that supports queries about the existence of k edge-disjoint
(vertex-disjoint) paths between a pair of given vertices, subject to edge deletions. We obtain improved
algorithms for decremental 2-edge-, 2-vertex- and 3-edge-connectivity in dynamic planar graphs. For
decremental 2-edge-connectivity we obtain an optimal data structure with both updates and queries
supported in amortized O(1) time. In the case of 2-vertex- and 3-edge-connectivity, we achieve the
5
amortized update time of O(log n), whereas the query time is constant. For all these problems, we
improve upon the 20-year-old update bounds by Giammarresi and Italiano [7] by a factor of O(log n).
Theorem 4.1. Let G = (V,E) be a planar graph and let n = |V |. There exists a deterministic data
structure that maintains G subject to edge deletions and can answer 2-edge connectivity queries in O(1)
time. Its total update time is O(n).
Proof. Denote by G0 the initial graph. Suppose wlog. that G0 is connected. Let B(G) be the set of all
bridges of G. Note that two vertices u, v are in the same 2-edge-connected component of G iff they are in
the same connected component of the graph (V,E \B(G)).
Observe that if e is a bridge, then deleting e from G does not influence the 2-edge-components of G.
Hence, when a bridge e is deleted, we may ignore this deletion. We denote by G′ be the graph obtained
from G0 by the same sequence of deletions as G, but ignoring the bridge deletions. This way, G′ is
connected at all times and the 2-edge-connected components of G′ and G are the same. It is also easy to
see that E(G) \B(G) = E(G′) \B(G′) and B(G) = B(G′) ∩ E(G). Moreover, the set E(G′) shrinks in
time whereas B(G′) only grows.
First we show how the set B(G′) is maintained. Recall that e ∈ E(G′) is a bridge of G′ iff e∗ is a
self-loop of G′∗. We build the data structure of Theorem 3.1 for G′∗, which initially equals G∗0. As deleting
a non-bridge edge e of G′ translates to a contraction of a non-loop edge e∗ in G′∗, we can maintain B(G′)
in O(n) total time by detecting self-loops in G′∗.
Denote by H the graph (V,E(G′) \ B(G′)). To support 2-edge connectivity queries, we maintain
the graph H with the decremental connectivity data structure of Łącki and Sankowski [14]. This data
structure maintains a planar graph subject to edge deletions in linear total time and supports connectivity
queries in O(1) time. When an edge e is deleted from G, we first check whether it is a bridge and if
so, we do nothing. If e is not a bridge, the set E(G′) shrinks and thus we remove the edge e from H.
The deletion of e might cause the set B(G′) to grow. Any new edge of B(G′) is also removed from H
afterwards.
To conclude, note that each 2-edge connectivity query on G translates to a single connectivity query
in H. All the maintained data structures have O(n) total update time.
As an almost immediate consequence of Theorem 4.1 we improve upon [6] and obtain an optimal
algorithm for the unique perfect matching problem when restricted to planar graphs. The details can be
found in Appendix A.
Corollary 4.2. Given a planar graph G = (V,E) with n = |V |, in O(n) time we can find a unique
perfect matching of G or detect that the number of perfect matchings in G is not 1.
To obtain improved bounds for 2-vertex connectivity and 3-edge connectivity we use the data structure
of Theorem 3.1 to remove bottlenecks in the existing algorithms by Giammarresi and Italiano [7]. The
details are deferred to Appendix A.
Theorem 4.3. Let G = (V,E) be a planar graph and let n = |V |. There exists a deterministic data
structure that maintains G subject to edge deletions and can answer 2-vertex connectivity and 3-edge
connectivity queries in O(1) time. Its total update time is O(n log n).
Maximal 3-Edge-Connected Subgraphs. A k-edge-connected component of a graph G is a maximal
(w.r.t. inclusion) subset S of vertices, such that each pair of vertices in S is k-edge-connected. However,
if k ≥ 3, in the subgraph of G induced by S, some pairs of vertices may not be k-edge-connected
(see [2] for an example). Thus, for k ≥ 3, maximal k-edge-connected subgraphs can be different from
k-edge-connected components. Very recently, Chechik et al. [2] showed how to compute maximal k-
edge-connected subgraphs in O((m+ n log n)
√
n ) time for any constant k, or O(m
√
n ) time for k = 3.
Using the results of [7] one can compute maximal 3-edge-connected subgraphs of a planar multigraph in
O(m+ n log n) time. Our new approach allows us to improve this to an optimal O(m+ n) time bound.
Lemma 4.4. The maximal 3-edge-connected subgraphs of a planar graph can be computed in linear time.
6
Simple Linear-Time Algorithms. Finally, we present two examples showing that Theorem 3.1 might
be a useful black-box in designing linear time algorithms for planar graphs.
ux y
Figure 3: The degree ≤ 5 vertex and its
two independent neighbors may be colored
using the remaining two colors.
Example 4.5. Every planar graph G can be 5-colored in
expected linear time.
Proof. A textbook proof of the 5-color theorem proceeds by
induction as follows (see Figure 3). Each simple planar graph
has a vertex u of degree at most 5. The case when u has
degree less than 5 is easy: for any v ∈ N(u), we can color
G/uv inductively, uncontract the edge uv and finally recolor
u with a color not used among the vertices N(u). When,
however, u has degree exactly 5, there exist two neighbors of
x, y of u such that x and y are not adjacent, as otherwise G would contain K5. We could thus obtain a
planar graph G′ by contracting both ux and uy. After inductively coloring G′ and “uncontracting” ux
and uy, we obtain a coloring of G that is valid, except that x, y and u have the same colors assigned.
Thus, at most 4 colors are used among the neighbors of u and we recolor u to the remaining color in
order to get a valid coloring of G.
Note that this proof can be almost literally converted into a linear time 5-coloring algorithm (see
Appendix B for the pseudocode) using the data structure of Theorem 3.1 built for G. We only need to
maintain a subset Q of vertices of G with degree at most 5. The subset Q can be easily maintained in
linear total time, since all vertices that potentially change their degrees after the call contract(e) are
endpoints of the reported parallel edges.
Example 4.6. An MST of a planar graph G can be computed in linear time.
Proof. Observe that by the cut property of a minimum spanning tree, for any vertex u ∈ V (G), and an
edge e of minimum cost among the edges adjacent to u, there exists a minimum spanning tree T of G
such that e ∈ T .
This observation can be turned into an efficient algorithm as follows. Again we build the data structure
of Theorem 3.1 and maintain the subset S ⊆ V (G) containing the vertices of degree no more than 5.
We repeatedly pick any u ∈ S, find the minimum cost edge uv adjacent to u (in O(1) time), include uv
in the constructed MST and subsequently contract uv. The set S can be updated after a contraction
analogously as in Example 4.5. The pseudocode can be found in Appendix B. By Theorem 3.1, the total
running time of this algorithm is linear.
5 Maintaining a Planar Graph Under Contractions
In this section we prove Theorem 3.1. We defer the discussion on supporting arbitrary weights `(·) to
Appendix A.2. Hence, in the following, we assume all edges have equal weights.
5.1 A Vertex Merging Data Structure
We first consider a more general problem, which we call the bordered vertex merging problem. The data
structure presented below will constitute a basic building block of the multi-level data structure. Let us
now describe the data structure for the bordered vertex merging problem in detail. Suppose we have
a dynamic simple planar graph G = (V,E) and a border set B ⊆ V . Assume G is initially equal to
G0 = (V0, E0) and no edge of E0 connects two vertices of B. The data structure handles the following
update operations.
• Merge (or in other words, an identification) of two vertices u, v ∈ V (u 6= v), such that the graph is
still planar. If {u, v} 6⊆ B, then u and v have to be connected by an edge and in such a case the
merge is equivalent to a contraction of uv.
• Insertion of an edge e = uv (where uv /∈ E is not required), preserving planarity.
7
After each update operation the data structure reports the parallel edges and self-loops that emerge.
Once reported, each set of parallel edges is merged into one representative edge. Moreover, the data
structure reports and removes any edges that have both endpoints in B. Thus, the following invariants
are satisfied before the first and after each modification:
1. G is planar and simple.
2. No edge of E has both its endpoints in B.
Clearly, merging vertices alters the set V by replacing two vertices u, v with a single vertex. Thus, at
each step, each vertex of G corresponds to a set of vertices of the initial graph G0. We explicitly maintain
a mapping φ : V0 → V such that for a ∈ V0, φ(a) is a vertex of the current vertex set V “containing” a.
The reverse mapping φ−1 : V → 2V0 is also stored explicitly. We now define how the merge of u and
v influences the set B. When {u, v} ⊆ B, the resulting vertex is also in B. When u ∈ B, v /∈ B (or
v ∈ B, u /∈ B, resp.), the resulting vertex is included in B in place of u (v, resp.). Finally, for u, v /∈ B,
the resulting vertex does not belong to B either.
Let Ẽ be the set of inserted edges. At any time, the edges of E constitute a subset of E0 ∪ Ẽ in the
following sense: for each e = xy ∈ E there exists an edge e′ = uv ∈ E0 ∪ Ẽ such that id(e) = id(e′), and
vertices u and v have been merged into x and y, respectively.
Note that some modifications might break the second invariant: both an edge insertion and a merge
might introduce an edge e with both endpoints in B. We call such an edge a border edge. Each border
edge e that is not a self-loop is reported and deleted from (or not inserted to) G. Apart from reporting
and removing new edges of B ×B appearing in E, we also report the newly created parallel edges that
might arise after the modification and remove them. The reporting of parallel edges is done in the form
of directed parallelisms, as described in Section 3. Again, it is easy to see that each edge of E0 ∪ Ẽ is
reported as the first coordinate of a directed parallelism at most once.
Note that an edge e may be first reported parallel (in a directed parallelism of the form e′ → e, where
e′ 6= e) and then reported border.
The Graph Representation. The data structure for the bordered vertex merging problem internally
maintains G using the data structure of the following lemma for planar graphs.
Lemma 5.1 ([1]). There exists a deterministic, linear-space data structure, initialized in O(n) time, and
maintaining a dynamic, simple planar graph H with n vertices, so that:
• adjacency queries in H can be performed in O(1) worst-case time,
• edge insertions and deletions can be performed in O(log n) amortized time.
Fact 5.2. The data structure of Lemma 5.1 can be easily extended so that:
• Doubly-linked lists N(v) of neighbors, for v ∈ V , are maintained within the same bounds.
• For each edge xy of H, some auxiliary data associated with e can be accessed and updated in O(1)
worst-case time.
In addition to the data structure of Lemma 5.1 representing G, for each unordered pair x, y of vertices
adjacent in G, we maintain an edge α(x, y) = e, where e is the unique edge in E connecting x and y.
Recall that in fact α(x, y) corresponds to some of the original edges of E0 or one of the inserted edges Ẽ.
By Fact 5.2, we can access α(x, y) in constant time.
The mapping φ is stored in an array, whereas the sets φ−1(·) – in doubly-linked lists.
Suppose we merge two vertices u, v ∈ V . Instead of creating a new vertex w, we merge one of these
vertices into the other. Suppose we merge u into v. In terms of the operations supported by the data
structure of Lemma 5.1, we need to remove each edge ux and insert an edge vx, unless v has been adjacent
to x before.
To update our representation, we only need to perform the following steps:
• For each v0 ∈ φ−1(u), set φ(v0) = v and add v0 to φ−1(v).
8
• Compute the list Nu = {(x, α(u, x)) : x ∈ N(u)}. Remove all edges adjacent to u from G. For each
(x, α(u, x)) ∈ Nu, x 6= v, check whether x ∈ N(v) (this can be done in O(1) time, by Lemma 5.1).
If so, report the parallelism α(u, x)→ α(v, x). Otherwise, if vx is not a border edge, insert an edge
vx to G and set α(v, x) = α(u, x). If, on the other hand, v ∈ B and x ∈ B (i.e., vx is a border
edge), report α(u, x) as a border edge.
Observe that our order of updates issued to G guarantees that G remains planar at all times.
The decision whether we merge u into v or v into u heavily affects both the correctness and efficiency
of the data structure. First, if one of u, v (say v) is contained in B, whereas the other (say u) is not,
we merge u into v. If, however, we have {u, v} ⊆ B or {u, v} ⊆ V \B, we pick a vertex (say u) with a
smaller set φ−1(u) and merge u into v.
To handle an insertion of a new edge e = xy, we first check whether xy is a border edge. If so, we
discard e and report it. Otherwise, check whether x and y are adjacent in G. If so, report the parallelism
e→ α(x, y). If not, add an edge xy to G and set α(x, y) = e.
Lemma 5.3. Let G be a graph initially equal to a simple planar graph G0 = (V0, E0) such that n =
|V0|. There is a data structure for the bordered vertex merging problem that processes any sequence of
modifications of G0, along with reporting parallelisms and border edges, in O((n+ f) log
2 n+m) total
time, where m is the total number of edge insertions and f is the total number of insertions of edges
connecting non-adjacent vertices.
Proof. Clearly, by Lemma 5.1, building the initial representation takes O(n log n) time, as we insert O(n)
edges to G. The reporting of parallel edges and border edges takes O(n+m) time, since each (initial
or inserted) edge is reported as a border edge or occurs as the first coordinate of a reported directed
parallelism at most once.
Also note that, by Lemma 5.1, an insertion of a parallel edge costs O(1) time, for a total of O(m) time
over all insertions, as G is not updated in that case. Recall that, by Fact 5.2, accessing and updating
values α(x, y) for xy ∈ E(G) takes O(1) time.
The total cost of maintaining the representation of G is O(g log n), where g is the total number of
edge updates to the data structure of Lemma 5.1. We prove that g = O((n + f) log n). To this end,
we look at the merge of u into v from a different perspective: instead of removing an edge e = ux and
inserting an edge vx, imagine that we simply change an endpoint u of e to v, but the edge itself does not
lose its identity. Then, new edges in G are only created either during the initialization or by inserting
an edge connecting the vertices that have not been previously adjacent in G. Hence, there are O(n+ f)
creations of new edges.
Consider some edge e = xy of G immediately after its creation. Denote by q(e) the pair
(|φ−1(x)|, |φ−1(y)|). The value of q(e) always changes when some endpoint of e is updated. Sup-
pose a merge of u into v (u 6= v) causes the change of some endpoint u of e to v. We either we have
u /∈ B and v ∈ B or |φ−1(v)| ≥ |φ−1(u)| before the merge. The former situation can arise at most once
per each endpoint of e, since we always merge a non-border vertex into a border vertex, if such case
arises. In the latter case, on the other hand, one coordinate of q(e) grows at least by a factor of 2, and
clearly this can happen at most O(log n) times, as the size of any φ−1(x) is never more than n. Since
there are O(n+ f) “created” edges, and each such edge undergoes O(log n) endpoint updates, indeed we
have g = O((n+ f) log n).
A very similar argument can be used to show that the total time needed to maintain the mapping φ
along with the reverse mapping φ−1 is O(n log n).
A Micro Data Structure. In order to obtain an optimal data structure, we need the following
specialized version of the bordered vertex merging data structure that handles very small graphs in linear
total time. Suppose we disallow inserting new edges into G. Additionally, assume we are allowed to
perform some preprocessing in time O(n). Then, due to a monotonous nature of allowed operations
on G, when the size of G0 is very small compared to n, we can maintain G faster than by using the data
structure of Lemma 5.3.
Lemma 5.4. After preprocessing in O(n) time, we can repeatedly solve the bordered vertex merging
problem without edge insertions for planar simple graphs G0 with t = O(log
4 log4 n) vertices in O(t) time.
9
Proof. Let f(n) = c log4 log4 n for some c > 0. We use the preprocessing time to simulate every possible
sequence of modifications on every possible graph G0 = (V0, E0) with no more than f(n) vertices and
each possible B ⊆ V0. The simulation allows us to precompute for each step the list of self-loops and
directed parallelisms to be reported.
We identify the vertices V0 with the set {1, . . . , t} and assume that edges of E0 are assigned identifiers
from the set 1, . . . , |E0| such that e = uv ∈ E0 is assigned an identifier equal to the position of the pair
(u, v) in the sorted list {(u, v) : u < v ∧ uv ∈ E0}.
Any possible graph G0 can be encoded with O(f(n)2) bits, representing the adjacency matrix of G0.
For a given G0 with t vertices, each possible B ⊆ V0 can be easily encoded with additional O(t) = O(f(n))
bits. On a graph G initially equal to G0, at most t merges can be performed. Clearly, a single operation
on G can be encoded as a pair of affected vertices, i.e., O(log t) bits. Each possible sequence S of
modifications of G (not necessarily maximal) can be thus encoded with additional O(t log t) = O(f(n)2)
bits.
We conclude that each triple (G0, B, S) can be encoded with O(poly(f(n))) bits and thus there are
no more than O(2poly(f(n))) such triples.
For each triple ψ = (G0, B, S), we do the following:
• We compute its bit encoding z(ψ).
• We use the data structure D of Lemma 5.3 to simulate the sequence of updates S on a graph G
initially equal to G0 and a border set B.
• Afterwards, a record Q[z(ψ)] is filled with the following information:
– mappings φ and φ−1 computed by D,
– the lists of border edges and directed parallelisms that were reported after the last modification
of the sequence S.
– the bit encodings z(ψ′) of all the triples φ′ = (G0, B, S′), such that S′ extends S by a single
modification.
For each triple ψ = (G0, B, S), all the needed information can be clearly computed in time polynomial
in f(n). Hence, in total we need O(2poly(f(n))) time to compute all the necessary information. As
O(poly(f(n))) = o(log n) any bit encoding z(ψ) is an integer of order O(n) and fits in O(1) machine
words.
Now, to handle any sequence of modifications on a graph G0 with at most f(n) vertices and a border
set B ⊆ V0, we first compute in linear time the bit encoding z(ψ∗) of ψ∗ = (G0, B, S), where initially
S = ∅. Each modification Y is executed as follows: we use the information in Q[z(ψ∗)] to find the bit
encoding z(ψ′) of the configuration ψ′ = (G0, B, S ∪ {Y }) and we move from the configuration ψ∗ to ψ′.
Next, we read from Q[z(ψ
′
)] which edges should be reported as parallel edges or border edges. As we
only move between the configurations by updating the bit encoding of the current configuration and
possibly report edges, the whole sequence of updates takes time linear in the size of G0. Clearly, the
record Q[z(ψ∗)] can be used to access the mappings φ and φ−1 in constant time.
5.2 A Multi-Level Data Structure
Recall that our goal is to maintain G under contractions. Below we describe in detail how to take
advantage of graph partitioning and bordered vertex merging data structures to obtain a linear time
solution. To simplify the further presentation, we assume that the initial version G0 = (V0, E0) of G is
simple and of constant degree. The standard reduction assuring that is described in Appendix A.1.
We build an r-division R = {P1, P2, . . . , } of G with r = log4 n, where n = |V0| (see Lemma 2.2).
Then, for each piece Pi ∈ R, we build an r-division Ri = {Pi,1, Pi,2, . . .} of Pi with r = log4 log4 n. By
Lemma 2.2, building all the necessary pieces takes O(n) time in total. Since G0 is of constant degree, any
vertex v ∈ V0 is contained in O(1) pieces of R. Analogously, for any v ∈ Pi, v is contained in O(1) pieces
of Ri.
As G undergoes contractions, let φ : V0 → V be a mapping such that for each v ∈ V0, v “has been
merged” into φ(v). As we later describe, a vertex resulting from contracting an edge uv will be called
either u or v, which guarantees that V ⊆ V0 at all times. Of course, initially φ(v) = v for each v ∈ V = V0.
10
Let G = (V,E) denote the maximal simple subgraph of G, i.e., the graph G with self-loops discarded
and each group Y of parallel edges replaced with a single edge α(Y ). The key component of our data
structure is a 3-level set of (possibly micro-) bordered vertex merging data structures Π = {π}∪{πi : Pi ∈
R} ∪ {πi,j : Pi ∈ R, Pi,j ∈ Ri}. The data structures Π form a tree such that π is the root, {πi : Pi ∈ R}
are the children of π and {πi,j : Pi,j ∈ Ri} are the children of πi. For D ∈ Π, let par(D) be the parent of
D and let A(D) be the set of ancestors of D. We call the value h(D) = |A(D)| a level of D. The data
structures of levels 0 and 1 are stored as data structures of Lemma 5.3, whereas the data structures of
level 2 are stored as micro structures of Lemma 5.4.
Each data structure D ∈ Π has a defined set VD ⊆ V0 of interesting vertices, defined as follows:
Vπ = ∂R, Vπi = ∂Pi ∪ ∂Ri and Vπi,j = V (Pi,j). The data structure D maintains a certain subgraph GD
of G defined inductively as follows (recall that we define G1 \G2 to be a graph containing all vertices of
G1 and edges of G1 that do not belong to G2)
GD = G[φ(VD)] \
( ⋃
D′∈A(D)
GD′
)
.
Fact 5.5. For any D ∈ Π, GD is a minor of G0.
Fact 5.6. For any uv = e ∈ E, there exists D ∈ Π such that e ∈ E(GD).
Proof. Let u0, v0 be the initial endpoints of e. Initially e ∈ Pi,j for some i, j. Observe that, since
{φ(u0), φ(v0)} ⊆ V (Gπi,j ), e is contained in Gπi,j or some of its ancestors.
Each D ∈ Π is initialized with the graph GD, according to the initial mapping φ(v) = v for any v ∈ V0.
We define the set of ancestor vertices AVD = VD ∩
(⋃
D′∈A(D) VD′
)
.
Now we discuss what it means for the bordered vertex merging data structure D to maintain the graph
GD. Note that the vertex set used to initialize D is VD. We write φD, φ−1D to denote the mappings φ, φ−1
maintained by D ∈ Π, respectively. Throughout a sequence of contractions, we maintain the following
invariants for any D ∈ Π:
• There is a 1-1 mapping between the sets φ(VD) and φD(VD) such that for the corresponding vertices
x ∈ φ(VD) and y ∈ φD(VD) we have φ−1D (y) = φ−1(x) ∩ VD. We also say that x is represented in D
in this case.
• There is an edge xy ∈ E(GD) if and only if there is an edge x′y′ in the graph maintained by D,
where x′, y′ ∈ φD(VD) are the corresponding vertices of x and y, respectively.
• The border set BD of D is always equal to φD(AVD).
Thus, the graph maintained by D is isomorphic to GD but can technically use a different vertex set.
Observe that in GD there are no edges between the vertices φ(AVD) and the following fact describes how
this is reflected in D.
Fact 5.7. In the graph stored in D, no two vertices of BD are adjacent.
Note that as the sets VD and VD′ might overlap for D 6= D′, the vertices of V can be represented in
multiple data structures.
Lemma 5.8. Suppose for v ∈ V we have v ∈ V (GD1) and v ∈ V (GD2). Then, v ∈ V (GD), where D is
the lowest common ancestor of D1 and D2.
Proof. We first prove that for i 6= j, φ(V (Pi)) ∩ φ(V (Pj)) ⊆ φ(∂R). Assume the contrary. Thus, there
exists such w ∈ φ(V (Pi))∩φ(V (Pj)) that w /∈ φ(∂R). But for x ∈ V , G0[φ−1(x)] is a connected subgraph
of G0 and thus G0[φ−1(w)] is connected and contains both some vertex of Pi and some vertex for Pj . But
each path from V (Pi) to V (Pj) in G0 has to go through a vertex of ∂R, by the definition of an r-division.
Hence ∂R ∩ φ−1(w) 6= ∅ and w ∈ φ(∂R), a contradiction.
Analogously one can prove that for any i and j 6= k, φ(V (Pi,j)) ∩ φ(V (Pi,k)) ⊆ φ(∂Ri).
Suppose that v ∈ V (GD1) ∩ V (GD2). If for some i 6= j we have D1 ∈ {πi} ∪
⋃
k{πi,k} and D2 ∈
{πj} ∪
⋃
k{πj,k} then v ∈ φ(Pi) ∩ φ(Pj) and we conclude v ∈ φ(∂R) and hence v ∈ V (Gπ). Analogously
we prove that if D1 = πi,j and D2 = πi,k for some j 6= k, then v ∈ V (Gπi).
11
By Lemma 5.8, each vertex v ∈ V is represented in a unique data structure of minimal level, a lowest
common ancestor of all data structures where v is represented. We denote such a data structure by D(v).
Observe that for any D ∈ Π the vertices {v : D(v) = D} are represented in D by φD(VD) \ φD(AVD).
We now describe the way we index the vertices of V . This is required, as upon a contraction, our
data structure returns an identifier of a new vertex. We also reuse the names of the initial vertices V0, as
the bordered vertex merging data structures do. Namely, a vertex v ∈ V is labeled with φD(v)(v′) ∈ V0,
where v′ represents v in D(v).
Note that, as the bordered vertex merging data structures always merge one vertex involved into the
other, for any D ∈ Π we have φD(VD) \ φD(AVD) ⊆ VD \AVD. Hence the label sets used by distinct sets
{v : D(v) = D} are distinct, since the sets of the form VD \AVD are pairwise disjoint. Such a labeling
scheme makes it easy to find the data structure D(v) by looking only at the label.
For brevity, in the following we sometimes do not distinguish between the set V and the set of labels⋃
D∈Π (φD(VD) \ φD(AVD)).
Lemma 5.9. Let uv = e ∈ E and h(D(u)) ≥ h(D(v)). Then e ∈ E(GD(u)) and either D(u) = D(v) or
D(u) is a descendant of D(v).
Proof. If {u, v} ⊆ φ(∂R), then clearly h(D(u)) = h(D(v)) = 0, e ∈ E(Gπ) and the lemma holds. Moreover,
no GD such that D is a descendant of π can contain the edge uv.
Otherwise, u does not belong to φ(∂R). Consequently, by Fact 5.6 and Lemma 5.8, there exists exactly
one i such that φ(u) is a vertex of some graph GD, and e is an edge of some graph GD′ , where D,D′ are
data structures in the subtree of Π rooted of πi. If v /∈ φ(∂R), v cannot be a vertex of any GD′′ , where
D′′ is in the subtree of πj , j 6= i.
Again, if {u, v} ⊆ φ(∂Pi ∪ ∂Ri), then uv ∈ E(Gπi), D(u) = πi and no descendant of Gπi can contain
uv. If not, we analogously get that there might exist at most one Gπi,j containing the edge uv and the
vertex u. If v /∈ φ(∂Pi ∪ ∂Ri), then only Gπi,j can contain the vertex v.
In all cases, D(u) = D(v) or D(u) is a descendant of D(v).
Lemma 5.10. Let uv be an edge of some GD, D ∈ Π. If {u, v} ⊆ V (GD′), where D′ 6= D, then D′ is a
descendant of D and both u and v are represented as border vertices of D′.
Proof. Suppose wlog. that h(D(u)) ≥ h(D(v)). By Lemma 5.9, we have D = D(u).
Let {u, v} ⊆ V (GD′). If D′ is a descendant of D, then {u, v} ⊆ φ(AVD′) and by the invariants
maintained by our data structure, u and v are represented by the vertices of BD′ .
Suppose D′ 6= D and D′ is not a descendant of D. Then, by Lemma 5.8, the lowest common ancestor
of D′ and D contains the vertex u and is an ancestor of D = D(u), a contradiction.
Lemma 5.11. Let v ∈ φ(VD), where D ∈ Π. Then, v is represented in O(|φ−1D (v)|) data structures D′
such that par(D′) = D.
Proof. Let D′ be a child of D. If v is represented in D′, then v ∈ φ(VD) ∩ φ(VD′). It follows that as
G0[φ
−1(v)] is a connected subgraph of G0, it contains a path between some vertex x ∈ VD and some
vertex y ∈ VD′ . Assume x /∈ VD′ . If D′ = πi, then in fact we have x ∈ V (Pj), for j 6= i and any path
from x to y has to go through a vertex of z ∈ ∂Pi and as ∂Pi ⊆ VD ∩ VD′ , there exists a vertex from
VD ∩ VD′ in φ−1(v). Similarly, if D′ = πi,j , there exists a vertex of ∂Pi,j in φ−1(v) and we again obtain
φ−1(v) ∩ VD ∩ VD′ 6= ∅.
Recall that we maintain an invariant φ−1D (v) = φ
−1(v) ∩ VD. Hence, φ−1D (v) ∩ VD′ 6= ∅. However, for
each w ∈ φ−1D (v), there are only O(1) child data structures D′ such that w ∈ V ′D, by the constant degree
assumption. It follows that there are can be at most O(|φ−1D (v)|) data structures D′ such that par(D′) = D
and φ−1D (v) ∩ VD′ 6= ∅, which in turn means that there are at most O(|φ
−1
D (v)|) data structures D′ such
that v is also represented in D′.
We also use the following auxiliary components for each D ∈ Π:
• For each x ∈ φD(AVD) we maintain a pointer βD(x) into y ∈ φpar(D)(AVD), such that x and y
represent the same vertex of the maintained graph G.
• A dictionary (we use a balanced BST) γD mapping a pair (D′, x), where D′ is a child of D and
x ∈ φD(VD), to a vertex y ∈ φD′(AVD) iff x and y represent the same vertex of V .
12
Another component of our data structure is the forest T of reported parallelisms: for each reported
parallelism e→ α(e), we make e a child of α(e) in T . Note that the forest T allows us to go through all
the edges parallel to α(e) in time linear in their number.
Lemma 5.12. For v0 ∈ V0, we can compute φ(v0) and find D(φ(v0)) in O(1) time.
Proof. Let Pi,j be any piece such that v0 ∈ V (Pi,j). First, we can compute the representation x = φπi,j (v0)
of φ(v0) in πi,j in O(1) time, as the data structure πi,j stores the mapping φπi,j explicitly. Set D = πi,j .
Next, if x ∈ φD(AVD) (or, technically speaking, if x ∈ AVD), we follow the pointer βD(x) to the data
structure of lower level and repeat if needed, until we reach the data structure D(φ(v0)). As the tree of
data structures has 3 levels, we follow O(1) pointers.
Lemma 5.13. Let v ∈ V (GD). For any D′, such that par(D′) = D, we can compute the vertex v′
representing v in GD′ (or detect that such v′ does not exist) in O(log |VD|) time.
Proof. By Lemma 5.11, the number of entries in γD is O
(∑
v∈V (GD) |φ
−1
D (v)|
)
= O(VD). The cost of
any operation on a balanced binary search is logarithmic in the size of the tree.
We now describe how to implement the call (s, P, L) := contract(e), where uv = e ∈ E, u, v ∈ V .
Suppose the initial endpoints of e were u0, v0 ∈ V0. First, we iterate through the tree Te ∈ T containing
e to find α(e). By Lemma 5.12, we can find the vertices u, v along with the respective data structures
D(u),D(v), based on u0, v0 in O(1) time. Assume wlog. that h(D(u)) ≥ h(D(v)). By Lemma 5.9, α(e)
is an edge of GD(u). Although we are asked to contract e, we conceptually contract α(e), by issuing a
merge of u and v to D(u). To reflect that we were actually asked to contract e, we include all the edges
of Te \ {e} in L as self-loops. The merge might make D(u) report some parallelisms e1 → e2. In such a
case we report e1 → e2 to the user (by including it in P ) and update the forest T .
We now have to reflect the contraction of e in all the required data structures D ∈ Π, so that our
invariants are satisfied. Assume wlog. that u is merged into v in D. If before the contraction, both u and
v were the vertices of some GD′ , D′ 6= D, then by Lemma 5.10, D′ is a descendant of D. By a similar
argument as in the proof of Lemma 5.3, we can afford to iterate through φ−1D (u) without increasing the
asymptotic performance of the u-into-v merge performed by D, as long as we spend O(log |VD|) time
per element of φ−1D (u). By Lemma 5.11, there are O(|φ
−1
D (u)|) data structures D1,D2, . . . that are the
children of D and contain the representation of u. For each such Di, we first use the dictionary γD to
find the vertex x representing u in Di, and update βDi(x) to v. Then, using Lemma 5.13, we check
whether v ∈ V (GDi) in O(log |VD|) time. If not, we set γD(Di, v) to x. Otherwise, we merge u and v in
Di and handle this merge – in terms of updating the auxiliary components β and γ – analogously as
for D. This is legal, as u, v ∈ φDi(AVDi) and thus u and v are border vertices in Di, by Fact 5.7. The
merge may cause Di to report some parallelisms. We handle them as described above in the case of the
data structure D. Note however that merging border vertices cannot cause reporting of new border edges
(i.e., those with both endpoints in BDi).
The merge of u and v in D might also create some new edges e′ = xy between the vertices φD(AVD)
in GD. Note that in this case D reports xy as a border edge and also we know that h(D(x)) < h(D)
and h(D(y)) < h(D). Hence, e′ should end up in some of the ancestors of D. We insert e′ to par(D).
par(D) might also report xy as a border edge and in that case e′ is inserted to the grandparent of D. It
is also possible that e′ will be reported a parallel edge in some of the ancestors of D: in such a case an
appropriate directed parallelism is added to P .
Note that all the performed merges and edge insertions are only used to make the graphs represented
by the data structures satisfy their definitions. Fact 5.5 implies that the represented graphs remain planar
at all times.
We now describe how the other operations are implemented. To compute u, v ∈ V such that
{u, v} = vertices(e), where e ∈ E, we first use Lemma 5.12 to compute u = φ(u0) and v = φ(v0), where
u0, v0 are the initial endpoints of e. Clearly, this takes O(1) time.
To maintain the values deg(v) of each v ∈ V , we simply set deg(s) := deg(u) + deg(v) − 1 after a
call (s, P, L) := contract(e). Additionally, for each directed parallelism e1 → e2 we decrease deg(x) and
deg(y) by one, where {x, y} = vertices(e1).
For each u ∈ V we maintain a doubly-linked list E(u) = {α(uv) : uv ∈ E}. Additionally, for
each e ∈ E we store the pointers to the two occurrences of e in the lists E(·). Again after a call
13
(s, P, L) := contract(e), where e = uv, we set E(s) to be a concatenation of the lists E(u) and E(v).
Finally, we remove all the occurrences of edges {α(e)} ∪ {e1 : (e1 → e2) ∈ P} from the lists E(·). Now,
the implementation of the iterator neighbors(u) is easy, as the endpoints not equal to u of the edges in
E(u) form exactly the set N(u).
Lemma 5.14. The operations vertices, deg and neighbors run in O(1) worst-case time.
To support the operation edge(u, v) in O(1) time, we first turn all the dictionaries γD into hash tables
with O(1) expected update time and O(1) worst-case query time [3]. Our data structure thus ceases to
be deterministic, but we obtain a more efficient version of Lemma 5.13 that allows us to compute the
representation of a vertex in a child data structure D′ in O(1) time. By Lemma 5.9, the edge uv can be
contained in either D(u) or D(v), whichever has greater level. Wlog. suppose h(D(u)) ≥ h(D(v)). Again,
by Lemma 5.9, D(u) is a descendant of D(v). Thus, we can find v in D(u) by applying Lemma 5.13 at
most twice.
Lemma 5.15. If the dictionaries γD are implemented as hash tables, the operation edge runs in O(1)
worst-case time.
The following lemma summarizes the total time spent on updating all the vertex merging data
structures Π and is proved in Section 5.3.
Lemma 5.16. The cost of all operations on the data structures D ∈ Π is O(n).
Proof of Theorem 3.1. To initialize our data structure, we initialize all the data structures D ∈ Π and
the auxiliary components. This takes O(n) time. The time needed to perform any sequence of operations
contract is proportional to the total time used by the data structures Π, as the cost of maintaining the
auxiliary components can be charged to the operations performed by the individual structures of Π. By
Lemma 5.16, this time is O(n). If the dictionaries γD are implemented as hash tables, this bound is valid
only in expectation.
By combining the above with Lemmas 5.14 and 5.15, the theorem follows.
5.3 Running Time Analysis
To bound the operating time of our data structure, we need to analyze, for any D ∈ Π and any sequence
of edge contractions, the number of changes to E(GD) that result in a costly operation of inserting an
edge connecting non-adjacent vertices into the underlying bordered vertex merging data structure D.
Lemma 5.17. Let D ∈ Π. After the initialization of D, only the edges initially contained in the graphs
represented by the descendants of D might be inserted into D, each at most once.
Proof. Note that whenever we report a border edge in D, we insert it to par(D).
Consider some sequence S of k edge contractions on G. Let Gi = (Vi, Ei) (for i = 0, 1, . . . , k) be the
graph G after i contractions. Denote by ui, vi ∈ Vi−1 the vertices involved in the i-th contraction, and by
si ∈ Vi the vertex of Gi obtained as a result of the i-th contraction. We have Vi = Vi−1 \ {ui, vi} ∪ {si}.
Moreover, let φi : V0 → Vi be the mapping φ after i contractions of S. Denote by Gi the graph G after i
contractions.
Let W ⊆ V0. For i > 0, we define the set ∆Wi ⊆ E(Gi) of “new” edges appearing in the induced
subgraph G[φ(W )] as a result of the i-th contraction, in the following sense. An edge siyi ∈ E(Gi) is
included in ∆Wi iff {si, yi} ⊆ φi(W ) and:
• either ui /∈ φi−1(W ) or uiyi /∈ E(Gi−1),
• either vi /∈ φi−1(W ) or viyi /∈ E(Gi−1).
Note that this definition implies yi ∈ φi−1(W ) and |{ui, vi}∩φi−1(W )| = 1. Define ΨW = |∆W1 |+ |∆W2 |+
. . .+ |∆Wk |.
Corollary 5.18. We have ΨW =
∑k
i=1 d
W
i , where d
W
i is the number of edges that should be added to
Gi−1[φi−1(W )], after possibly performing a contraction of an edge uivi in Gi−1 (if {ui, vi}∩φi−1(W ) 6= ∅),
in order to obtain Gi[φi(W )].
14
Lemma 5.19. For any W ⊆ V0, ΨW = O(|W |).
Proof. Fix some plane embedding of G0. We define semi-strict versions GW0 , G
W
1 , . . . , G
W
k of graphs
G0[φ(W )], G1[φ(W )], . . . , Gk[φ(W )], respectively, so that:
• GW0 = G0[φ(W )]. Recall that G0 is simple, and thus its subgraph G0[φ(W )] is also simple and in
particular semi-strict.
• If {ui, vi} ∩ φi−1(W ) = ∅, then GWi = GWi−1.
• If {ui, vi} ⊆ φi−1(W ), then we obtain GWi from GWi−1 by first contracting uivi. For any triangular
face f = uivixi of GWi−1 (there can be between 0 and 2 such faces), the contraction introduces a face
f ′ = sixi of length 2. We remove one of these edges sixi from GWi so that the face f
′ is merged
with any neighboring face and GWi is semi-strict.
• If |{ui, vi}∩φi−1(W )| = 1, suppose wlog. that ui ∈ φi−1(W ) (the case vi ∈ φi−1(W ) is symmetrical).
Pick a maximal pairwise non-parallel subset Fi of such edges vibi of Gi−1, that bi ∈ φi−1(W ) and
uibi /∈ E(GWi−1). Let GWi be obtained from the following subgraph of Gi−1:
Xi = (φi−1(W ) ∪ {vi}, E(GWi−1) ∪ {uivi} ∪ Fi)
by contraction of uivi (which merges vertices ui, vi into si). Observe that, by definition of Xi the
contraction of uivi in Xi does not introduce parallel edges and as a result GWi is semi-strict.
The graphs GWi are defined in such a way that for any x, y ∈ φi(W ), xy ∈ E(Gi) if and only if xy ∈ E(GWi ).
As a result, we have ∆Wi ⊆ E(GWi ) \ E(GWi−1). It is thus sufficient to prove
ΨW ≤ |E(GW1 ) \ E(GW0 )|+ |E(GW2 ) \ E(GW1 )|+ . . .+ |E(GWk ) \ E(GWk−1)| = O(|W |).
As each GWi is semi-strict, |E(GWi )| ≤ 3|V (GWi )| = 3|φi(W )| ≤ 3|W |. Moreover, as any contraction
in a semi-strict graph decreases the number of edges by at most 3, |E(GWi−1) \ E(GWi )| ≤ 3. In fact,
by the definition of GWi , we have E(G
W
i−1) 6⊆ E(GWi ) if and only if {ui, vi} ⊆ φi−1(W ), i.e., when
|V (GWi )| < |V (GWi−1)|. This may happen for at most |W | values of i, as |V (GW0 )| = W . Denote the set
of these values i as I.
We have
ΨW ≤
k∑
i=1
|E(GWi ) \ E(GWi−1)|
=
k∑
i=1
|E(GWi ) \ (E(GWi ) ∩ E(GWi−1))| =
k∑
i=1
|E(GWi )| − |E(GWi ) ∩ E(GWi−1)|
≤
k∑
i=1
|E(GWi )| −
∑
i∈{1,...,k}\I
|E(GWi−1)| −
∑
i∈I
(|E(GWi−1)| − 3)
= |E(GWk )| − |E(GW0 )|+ 3|I| ≤ 6|W | = O(|W |).
Proof of Lemma 5.16. Recall that by Lemma 5.3, the cost of any sequence of operations on D ∈ {π}∪{πi :
Pi ∈ R} is O((|VD|+fD) log2 |VD|+mD), where mD is the total number of times an edge is inserted into D
and fD is the number of insertions connecting non-adjacent vertices. By Lemma 5.17, mπ = O(|E0|) and
mπi = O(|E(Pi)|). By Corollary 5.18 and Lemma 5.19, fD = ΨVD = O(|VD|). We have |Vπ| = O(n/ log
2 n)
and thus the cost of operating π is O(n). Similarly, we have |Vπi | = O(log
4 n/ log2 log4 n) and the total
cost of operating O(n/ log4 n) data structures πi is O(n/ log
2 log4 n+
∑
i |E(Pi)|) = O(n).
By Lemma 5.4, after O(n) preprocessing, the total cost of operating each πi,j is O(|V (Pi,j)|) and thus,
summed over all i, j, we again obtain O(n) time.
15
References
[1] Gerth Stølting Brodal and Rolf Fagerberg. Dynamic representation of sparse graphs. In Algorithms
and Data Structures, 6th International Workshop, WADS ’99, Vancouver, British Columbia, Canada,
August 11-14, 1999, Proceedings, pages 342–351, 1999. doi:10.1007/3-540-48447-7_34.
[2] Shiri Chechik, Thomas Dueholm Hansen, Giuseppe F. Italiano, Veronika Loitzenbauer, and Nikos
Parotsidis. Faster algorithms for computing maximal 2-connected subgraphs in sparse directed
graphs. In Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms,
SODA 2017, Barcelona, Spain, Hotel Porta Fira, January 16-19, pages 1900–1918, 2017. doi:
10.1137/1.9781611974782.124.
[3] Martin Dietzfelbinger, Anna R. Karlin, Kurt Mehlhorn, Friedhelm Meyer auf der Heide, Hans
Rohnert, and Robert Endre Tarjan. Dynamic perfect hashing: Upper and lower bounds. SIAM J.
Comput., 23(4):738–761, 1994. doi:10.1137/S0097539791194094.
[4] Jack Edmonds. Paths, trees and flowers. Canadian Journal of Mathematics, pages 449–467, 1965.
[5] Greg N. Frederickson. On linear-time algorithms for five-coloring planar graphs. Inf. Process. Lett.,
19(5):219–224, 1984. doi:10.1016/0020-0190(84)90056-5.
[6] Harold N. Gabow, Haim Kaplan, and Robert Endre Tarjan. Unique maximum matching algorithms.
J. Algorithms, 40(2):159–183, 2001. Announced at STOC ’99. doi:10.1006/jagm.2001.1167.
[7] Dora Giammarresi and Giuseppe F. Italiano. Decremental 2- and 3-connectivity on planar graphs.
Algorithmica, 16(3):263–287, 1996. doi:10.1007/BF01955676.
[8] Michael T. Goodrich. Planar separators and parallel polygon triangulation. J. Comput. Syst. Sci.,
51(3):374–389, 1995. doi:10.1006/jcss.1995.1076.
[9] Jens Gustedt. Efficient union-find for planar graphs and other sparse graph classes. Theor. Comput.
Sci., 203(1):123–141, 1998. doi:10.1016/S0304-3975(97)00291-0.
[10] John E. Hopcroft and Robert Endre Tarjan. Efficient planarity testing. J. ACM, 21(4):549–568,
1974. doi:10.1145/321850.321852.
[11] David R. Karger. Global min-cuts in rnc, and other ramifications of a simple min-out algorithm. In
Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’93, pages
21–30, Philadelphia, PA, USA, 1993. Society for Industrial and Applied Mathematics.
[12] Philip N. Klein and Shay Mozes. Optimization algorithms for planar graphs, 2017. URL: http:
//planarity.org.
[13] Philip N. Klein, Shay Mozes, and Christian Sommer. Structured recursive separator decompositions
for planar graphs in linear time. In Symposium on Theory of Computing Conference, STOC’13, Palo
Alto, CA, USA, June 1-4, 2013, pages 505–514, 2013. doi:10.1145/2488608.2488672.
[14] Jakub Łącki and Piotr Sankowski. Optimal decremental connectivity in planar graphs. In 32nd
International Symposium on Theoretical Aspects of Computer Science, STACS 2015, March 4-7,
2015, Garching, Germany, pages 608–621, 2015. doi:10.4230/LIPIcs.STACS.2015.608.
[15] Martin Mareš. Two linear time algorithms for mst on minor closed graph classes. Archivum
mathematicum, 40(3):315–320, 2002.
[16] Tomomi Matsui. The minimum spanning tree problem on a planar graph. Discrete Applied
Mathematics, 58(1):91–94, 1995. doi:10.1016/0166-218X(94)00095-U.
[17] David W. Matula, Yossi Shiloach, and Robert E. Tarjan. Two linear-time algorithms for five-coloring
a planar graph. Technical report, Stanford University, Stanford, CA, USA, 1980.
[18] Neil Robertson, Daniel P. Sanders, Paul Seymour, and Robin Thomas. Efficiently four-coloring planar
graphs. In Proceedings of the Twenty-eighth Annual ACM Symposium on Theory of Computing,
STOC ’96, pages 571–575, New York, NY, USA, 1996. ACM. doi:10.1145/237814.238005.
16
[19] Freek van Walderveen, Norbert Zeh, and Lars Arge. Multiway simple cycle separators and I/O-
efficient algorithms for planar graphs. In Proceedings of the Twenty-Fourth Annual ACM-SIAM
Symposium on Discrete Algorithms, SODA 2013, New Orleans, Louisiana, USA, January 6-8, 2013,
pages 901–918, 2013. doi:10.1137/1.9781611973105.65.
17
A Omitted Proofs
Corollary 4.2. Given a planar graph G = (V,E) with n = |V |, in O(n) time we can find a unique
perfect matching of G or detect that the number of perfect matchings in G is not 1.
Proof. The algorithm by Gabow et al. [6] for this problem runs in O(n log n) time. The algorithm has
two bottlenecks and otherwise runs in O(n) time.
1. Maintaining the set of bridges of G under edge deletions.
2. Maintaining the sizes of connected components of G under edge deletions. Specifically, one has to
be able to query the size of a component containing given v ∈ V in O(1) time.
Clearly, the data structure of Theorem 4.1 can be used to remove the former bottleneck. The latter
bottleneck can be dealt with by extending the data structure for decremental connectivity in planar
graphs due to Łącki and Sankowski [14]. This data structure computes a r-division R of the input graph,
and based on it defines a skeleton graph. Roughly speaking, the skeleton graph is defined as follows. We
say that a connected component is interesting if it contains a boundary vertex. Thus, each connected
component is either interesting or fully contained within one piece of the r-division (in which case it is
handled with a recursive call).
The skeleton graph represents all interesting connected components of the graph. It has vertices of two
types, namely it contains all boundary vertices of the r-division and, for each interesting component C
and each piece containing vertices of C, one auxiliary vertex representing the intersection of C and the
piece. Such an auxiliary vertex may correspond to multiple vertices in the entire graph.
The skeleton graph has O(n/
√
r) vertices, and for each vertex the data structure explicitly maintains
the identifier of its connected component. In order to extend the data structure to maintain the sizes of
the components, it suffices to maintain, for each auxiliary vertex, the number of vertices in the entire
graph, that it corresponds to. From the algorithm, it follows that this information can be updated without
impacting the overall running time.
Theorem A.1. Let G = (V,E) be a planar graph and let n = |V |. There exists a deterministic data
structure that maintains G subject to edge deletions and can answer 2-vertex connectivity queries in O(1)
time. Its total update time is O(n log n).
Proof. The only bottleneck of the data structure of [7] is the following subproblem (otherwise the total
cost of the data structure is O(n log n)). Suppose we delete an edge e separating the faces fl, fr, fl 6= fr.
Denote by C(f) the cycle bounding the face f . We want to find the vertices of C(fl) ∩ C(fr) in order
they appear on this cycles (the order is the same for both faces up to reversal). In the data structure of
[7], the cycles C(fl) are represented as doubly linked lists and thus they can be maintained in amortized
constant time under edge deletions (which correspond to face merges). The set C(fl)∩C(fr) is computed
by iterating through the shorter bounding cycle (say C(fl)) and checking for each v ∈ C(fl) whether v is
adjacent with fr. This, in turn, is accomplished by storing for each vertex v ∈ V the set of neighboring
faces in a balanced binary search tree. Consequently C(fl) ∩ C(fr) is computed in O(|C(fl)| log n) time.
As we always iterate through the smaller of the cycles which are subsequently joined, this gives us
O(n log2 n) total time for any sequence of edge deletions.
We now show how the step of computing C(fl) ∩ C(fr) in order can be sped up to O(|C(fl)|). This
will make the whole data structure handle any sequence of updates in O(n log n) total time.
To proceed, we need the notion of a face-vertex graph of G, denoted by G. This is a plane embedded
graph, which is constructed as follows. First, embed a single vertex inside every face of G, thus obtaining
a set of vertices F . The vertex set of G is V (G) ∪ F . We call each element of V (G) a v-vertex and each
element of F an f-vertex. Now, consider each face of G one by one. For a face f let v1, . . . , vk be the
sequence of vertices on the boundary of f (note that we may have vi = vj for i 6= j). Then for each
1 ≤ i ≤ k, G has a single edge connecting vertex vi with the vertex embedded inside the face f . No
other edges are added to G. In particular, every edge of G connects an f-vertex and a v-vertex, so G
is bipartite. Also, we may have multiple edges between two vertices of G, if the boundary of some face
of G goes through a vertex multiple times.
We build the data structure D(H) of Theorem 3.1 for the graph H = G ∪G∗. Clearly, this graph is
planar. The deletions of edge of G are reflected in H by contractions of edges connecting the faces. Note
18
that for each v ∈ C(fl) ∩ C(fr) there exist edges vfl and vfr in H. Thus, after merging fl and fr into
a face f , we will have at least two edges vf in H that have not been previously parallel. Hence, some
parallelism e→ e′, where e = vf will be reported. As a result, we obtain the set C(fl) ∩ C(fr) from the
set of parallel edges reported by D(H) after the last contraction. Note that D(H) might also report some
parallel edges connecting two face-vertices of H; such edges are ignored.
The total time for obtaining all the sets C(fl) ∩ C(fr) is linear, by Theorem 3.1. However, recall that
the data structure of [7] requires the elements C(fl) ∩ C(fr) in order of their occurrences on the cycle
bounding fl and unfortunately D(H) does not give us this order. That is why we also need to traverse
C(fl) to obtain the order of C(fl) ∩ C(fr). Hence, O(|C(fl)|) additional time is needed.
Theorem A.2. Let G = (V,E) be a planar graph and let n = |V |. There exists a deterministic data
structure that maintains G subject to edge deletions and can answer 3-edge connectivity queries in O(1)
time. Its total update time is O(n log n).
Proof. The data structure of [7] maintains explicitly the so-called cactus tree which succinctly describes
the structure of 2-edge-cuts in G. The vertices of a cactus trees T are the 3-edge-components of G and
the edge set of T consist of edge-disjoint simple cycles.
The core problem of the update procedure is deleting an edge contained in a 3-edge-connected
component C. When such edge e of G is deleted, a vertex of the cactus tree representing C is possibly
split and some cycles of T are updated; certain pairs of cycles of the cactus tree are merged, whereas
some cycles get extended by a single edge.
Although not stated explicitly, the total cost of maintaining the cactus tree T in [7], once we know
which pairs of cycles should be merged and which cycles should be extended after a deletion, is O(n log n),
as the total number of updates to T is in fact linear for any sequence of edge deletions (in each such case,
the number of vertices of T grows by at least 1).
The most computationally demanding part of the procedure updating T in [7] is deciding which pairs
of cycles of T should be merged and which cycles should be extended: it might take as much as Θ(n log2 n)
time for the entire sequence of edge updates to G. This problem is reduced in [7] to the following. Let
the deleted edge e separate two faces fl and fr of G (fl 6= fr). We need to find the set of faces f of G
such that f /∈ {fl, fr} and f is neighboring with both fl and fr before the edge deletion, or, in other
words, {flf, frf} ⊆ E(G∗).
Note that after contraction e∗ in G∗ (which identifies the faces fl and fr), all such pairs of edges
constitute pairs of parallel edges of G∗ that have not been previously parallel. Recall that if G∗ was
maintained using the data structure of Theorem 3.1, a directed parallelism e1 → e2 or e2 → e1, where
e1 = flf ∧ e2 = frf would have been reported immediately after contracting e∗.
Consequently, we can solve this subproblem in O(n) total time by maintaining the graph G∗ under
contractions using the data structure of Theorem 3.1. As all other subproblems of the update procedure
of [7] are solved in O(n log n) total time, the theorem follows.
Lemma A.3. Let k ≥ 2. Suppose there exists a data structure Dk maintaining a planar graph H under
edge contractions and reporting edges of H participating in some cycle of length i, i ≤ k, in an online
manner. Denote by O(fk(m)) the total time needed by Dk to execute any sequence of contractions on
a graph on m edges. Then, there exists an algorithm computing the maximal (k + 1)-edge-connected
subgraphs of a planar graph G in O(fk(m)) time.
Proof. We build a data structure Dk for G∗. Recall that each simple cycle of length i ≤ k in G∗
corresponds to a simple edge-cut of size i in G.
Clearly, if G does not have edge-cuts of size no more than k, it is (k + 1)-edge connected. Suppose
some edge e participates in some edge-cut of size i in G. Then e participates in some edge-cut of size
no more than i in every subgraph of G containing e. As a result, any subgraph of G containing e is not
(k + 1)-edge-connected. We may thus safely discard e: the maximal (k + 1)-edge-connected subgraphs of
G and G− e are the same.
The above observation leads to a simple algorithm for computing maximal (k + 1)-edge-connected
subgraphs. We maintain a queue Q of edges e that participate in some edge-cut of G of size no more than
k. As long as Q 6= ∅, we extract some e of Q and remove it from G. Recall that removal of an edge e in
G corresponds to a contraction of e∗ in G∗. We thus issue a contraction to Dk, after which new edges
can be marked as participating in small cycles of G∗. These newly marked edges in G∗ are added to Q.
19
The connected components of the subgraph of G induced by the edges that were not removed constitute
the maximal (k + 1)-edge-connected subgraphs of G.
Lemma 4.4. The maximal 3-edge-connected subgraphs of a planar graph can be computed in linear time.
Proof. Recall that, by Theorem 3.1, we can maintain any planar graph H under edge contractions in
linear total time, so that the edges participating in 2-cycles, i.e., parallel edges, are reported in an online
fashion. To finish the proof, we apply Lemma A.3.
A.1 Simple and Bounded-Degree
If G is not initially simple, we first report and discard the self-loops. For each group of pairwise parallel
edges {e1, . . . , eq} we report directed parallelisms ei → e1 for each i = 2, . . . , q and remove all edges
e2, . . . , eq from G.
Suppose now that G is simple. We first compute the embedding of G in linear time [10]. We build a
graph H obtained from G by replacing each vertex v of G of degree at least 4 with an undirected cycle Cv
of length deg(v) in a standard way (but consistently with the embedding of G). After this step, all the
vertices of H have degree no more than 3. Moreover, H is planar and has a linear number of edges and
vertices. If we now build a data structure for maintaining H under contractions, we may first contract all
the edges constituting the cycles Cv first, but without reporting the self-loops and parallelisms involving
these edges. Note that after these contractions the graph H in fact becomes equal to G. Clearly, the size
of H is linear in the size of G.
A.2 Supporting Edge Weights
In this section we show how to modify the data structure of Section 5 so that, given a weight function
` : E0 → R, for each reported directed parallelism α(Y3−i)→ α(Yi) (see Section 3) we have `(α(Yi)) ≤
`(α(Y3−i)).
We maintain an array δ defined as follows. Let Y be a group of parallel edges represented by a tree
T ∈ T . Then, δ[α(Y )] is equal to an edge e ∈ T such that `(e) is minimum. Initially, for each e ∈ E0, we
have δ(e) = e. To maintain the invariant posed on δ throughout any sequence of contractions, we do the
following.
Suppose the data structure of Section 5 reports a parallelism α(Y1) → α(Y2). Then, if δ[α(Y1)] ≤
δ[α(Y2)], the weight supporting layer reports δ[α(Y2)] → δ[α(Y1)] instead and sets δ[α(Y2)] = δ[α(Y1)].
On the other hand, when δ[α(Y1)] > δ[α(Y2)], we only report δ[α(Y1)]→ δ[α(Y2)] instead.
20
B Pseudocode of Linear Time Algorithms for 5-coloring and
MST
Function contract-and-update(e)
(s, P, L)← contract(e)
for w ∈ {s} ∪
⋃
{vertices(e1) : (e1 → e2) ∈ P} do
if w /∈ Q and deg(w) ≤ 5 then
Q← Q ∪ {w}
return s
Algorithm 1: MST of a planar graph
input :A simple connected planar graph G = (V,E) and a function ` : E → R.
output :A minimum spanning tree of G.
init(G). Use ` to report directed parallelism, so that each time e′ → e is reported, we have
`(e′) ≥ `(e).
Q← {v ∈ V : deg(v) ≤ 5}
T ← ∅
while Q 6= ∅ do
u← any element of Q
Q← Q \ {u}
if deg(u) ≥ 1 then
e← an edge such that (v, e) ∈ neighbors(u) and `(e) is minimal
T ← T ∪ {e}
contract-and-update(e)
return T
Procedure color
if Q = ∅ then
return
u← any element of Q
Q← Q \ {u}
Z ← neighbors(u)
if deg(u) ≥ 1 and deg(u) ≤ 4 then
v ← any vertex of Z
s← contract-and-update(edge(u, v))
color()
C[v]← C[s]
else if deg(u) = 5 then
x, y ← any two vertices of Z such that edge(x, y) = nil
s′ ← contract-and-update(edge(u, x))
s← contract-and-update(edge(s1, y))
color()
C[x]← C[s]
C[y]← C[s]
C[u]← any color of ({1, 2, 3, 4, 5} \ {C[w] : w ∈ Z})
Algorithm 2: 5-coloring of a planar graph
input :A simple connected planar graph G = (V,E).
output :A 5-coloring C of G.
init(G)
Q← {v ∈ V : deg(v) ≤ 5}
C ← an array indexed with vertices with values from {1, 2, 3, 4, 5}
color()
return C
21

