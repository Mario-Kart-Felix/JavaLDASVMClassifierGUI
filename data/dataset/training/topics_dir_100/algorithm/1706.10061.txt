ar
X
iv
:1
70
6.
10
06
1v
1 
 [
cs
.D
S]
  3
0 
Ju
n 
20
17
Compaction of Church Numerals for
Higher-Order Compression
Isamu Furuya1 Takuya Kida1
1Graduate School of IST, Hokkaido University, Japan
{furuya,kida}@ist.hokudai.ac.jp
Abstract
We addressed the problem of compacting the Church numerals, which
is useful for higher-order compression. We proposed a novel decomposition
scheme for a natural number using tetration, which leads to the compact
representation of λ-terms equivalent to the Church numerals. For natural
number n, we proved that the size of the lambda term obtained by our
method is O(slog2n
log n/ log log n). We also quantitatively confirmed via
experiments that in many cases, our method can produce shorter λ-terms
more than existing methods.
1 Introduction
Our aim is to obtain a compact lambda term (λ-term) equivalent to the Church
numeral for a given natural number. Church numerals are unary representations
of natural numbers using lambda notation; for an integer n, the length of the
Church numeral linearly increases with n. Let C(n) be the Church numeral for
a natural number n; then the lambda expression C(n) is as follows:
C(n) = (λfx.
n
︷ ︸︸ ︷
f(f(· · · f(f x) · · · )).
For a large number n, decomposing it and representing its expression may
reduce the length of the λ-term for n. For example, let n = 50; we can
decompose it as 2 × 5 × 5. The λ-term corresponding to the expression is
(λpqfx.p(q f)x)C(2)((λpfx.p(p f)x)C(5)), which is much shorter than C(50).
Length shortening of Church numerals is applied to data compression. Kobayashi
et al. [1] proposed a compression method, called higher-order compression, which
uses a λ-term as the data model. The method translates an input into a λ-term
inducing the input itself, and then encodes the obtained λ-term. The input
data is first represented as a simple λ-term, which consists of nested functional
applications of lambda notation. The λ-term is converted into a shorter term
by repeatedly extracting common contexts. Since repeating patterns in the ini-
tial λ-term appear as Church numerals, quickly shortening them is important
for compression of data. We call the task of shortening Church numerals a
compaction of C(n).
In this paper, we introduce a new scheme, named Recursive tetrational par-
titioning (RTP) to decompose a natural number using tetration. We present
an algorithm to perform RTP for a given natural number and show that the
1
expression obtained by RTP is translated into a compact λ-term. Moreover, we
prove that the length of the obtained λ-term is O(slog2nlogn/ log logn) in the
worst case.
Kobayashi et al. [1] also showed the binary representation of λ-terms equiv-
alent to Church numerals, whose length is O(log n). Although the result of our
O(slog2nlogn/ log log n) is larger than O(log n), we confirmed via an experiment
that the obtained λ-terms become much shorter than binary representation in
many cases.
Yaguchi et al. [4] recently proposed an efficient algorithm for higher-order
compression. They utilized a simply typed λ-term for efficient modeling and
encoding. Their idea was to extract the most frequent context up to a certain
size, unlike the approach of Kobayashi et al., which extracts every context oc-
curring more than once. In [4], they state that the performance of their method
is often better than the performance of grammar compression, with regard to
compression ratio. We also confirmed that our method tends to produce more
compact λ-terms for highly repeating patterns compared with the method of
Yaguchi et al.. Our method can be easily incorporated into their algorithm.
Contributions: Three contributions are made in this paper:
1. For large natural numbers, we propose a novel decomposition scheme us-
ing tetration, RTP, which leads to the compact representation of λ-terms
equivalent to the Church numerals of the numbers. RTP is different from
the n-ary notation.
2. By incorporating RTP, we present an algorithm performing the compaction
of C(n). Moreover, we proved that the length of λ-terms, constructed by
the algorithm, is O(slog2nlogn/ log logn) in the worst case.
3. We quantitatively confirmed via experiments that in many cases, our
method can produce shorter λ-terms more than the existing methods;
the size reduction is approximately 21% and 23% for n ≤ 10, 000 on an
average, compared with the binary representation stated in [1] and with
the method of Yaguchi et al. stated in [4], respectively.
The rest of this paper is organized as follows. In the next section, we review
the lambda notation, Church numerals, and tetration. In Sec. 3, we define RTP
and present the translation algorithm using RTP. Moreover, in Sec. 3, we prove
the upper bound of the length of the λ-term produced by the algorithm. In
Sec. 4, we discuss how to apply our algorithm to higher-order compression and
illustrate an experimental result. Finally, we conclude the paper in Sec. 5.
2 Preliminary
2.1 Lambda terms
Definition 1 (Lambda terms). Let S = {λ, ., (, )} be the set of special symbols.
Let A be the set of characters in the input data, where we assume A ∩ S = ∅.
We call A and a ∈ A terminal alphabet and terminal symbol, respectively. Let
Σ be an alphabet such that Σ∩ (A ∪ S) = ∅. We call x ∈ Σ variable. For a ∈ A
and x ∈ Σ, lambda terms (λ-terms) are recursively defined as follows:
(i) x (ii) (λx.M) (iii) (M N) (iv) a
2
where M and N are λ-terms. 
We call (ii) in Def. 1 λ-abstraction and (iii) functional application. Although
condition (iv) is added to for higher-order compression, Def. 1 is inherently the
same as that of the lambda calculus. Thus, hereafter, we borrow well-known
omission rules of lambda calculus, such as the omission of parentheses and short
notation of nested λ-abstractions. We also follow the usual rules of lambda
terms. We define the size of a λ-term according to [1] as follows.
Definition 2 (The size of a lambda term). We denote the size of the λ-term
M by #M , and define it as follows:
#x = #a = 1, #(λx.M) = #M + 1, #(M N) = #M +#N + 1,
where a ∈ A, x ∈ Σ, and M,N are λ-terms. 
2.2 Church numerals
Natural numbers are known to be represented by λ-terms as Church numerals.
Definition 3 (Church numerals). Let n be a natural number. Church numerals
for n, denoted by C(n), are defined as follows:
C(n) := (λfx.
n
︷ ︸︸ ︷
f (f · · · (f x) · · · )).

For example, C(5) is (λfx.f(f(f(f(f x))))). From the following definition,
it is also known that some arithmetic operations on numbers can be represented
by functions of λ-terms on Church numerals.
Definition 4 (Arithmetic operations on Church numerals). Let n1 and n2 be
natural numbers. From Def. 3, each function of addition, multiplication, and
exponentiation on C(n1) and C(n2) are, respectively, defined as follows:
addition add(n1, n2) = n1 + n2 := (λpqfx.p f (q f x)) C(n1) C(n2),
multiplication mul(n1, n2) = n1 · n2 := (λpqfx.p (q f) x) C(n1) C(n2),
exponentiation exp(n1, n2) = n1
n2 := (λpqfx.q p f x) C(n1) C(n2).

As can be seen, λ-abstractions at the above λ-terms appear first and are
followed by Church numerals. We call the former function parts and the latter
argument parts.
2.3 Tetration and super-logarithm
Tetration is known as the next hyper-operation after exponentiation. In mathe-
matics, it is defined as iterated exponentiation. For any natural numbers ϕ and
i, the ith tetration of ϕ is denoted by iϕ and recursively defined as follows:
iϕ :=
{
1, for i = 0,
ϕ
i−1ϕ, for i > 0.
For example, 12 = 2, 22 = 4, 32 = 16, and 42 = 65536.
The following lemma is easily induced from the definition.
3
Lemma 1. For natural numbers ϕ and i, it holds that logϕ
iϕ = i−1ϕ.
The super-logarithm, denoted by slog, is known as one of the inverse opera-
tions of tetration. For natural numbers ϕ and i, it holds that slogϕ
iϕ = i. On
the other hand, the iterated logarithm of n, denoted by log∗ n, is also known as
the number of times the logarithm function must be applied to n before it be-
comes less than or equal to 1. For the positive numbers, the super-logarithm is
essentially equivalent to the iterated logarithm; it holds that log∗ n = ⌈slogen⌉
for any n > 0.
3 Proposed Method
3.1 Our approach
We conduct the compaction of C(n) in the following two steps:
Step 1: Decompose n with a natural number ϕ (1 < ϕ < n) into a numerical
expression, which includes as much tetration and multiplication of ϕ as
possible.
Step 2: Translate the expression into a corresponding λ-term so that the trans-
lated λ-term includes a single functional part followed by C(ϕ).
For Step 1, we introduce RTP in Sec. 3.2. For Step 2, we present a translation
algorithm in Sec. 3.3.
As stated in Sec. 1, we may reduce #C(n) for a large number n. For the run-
ning example, it becomes #C(50) = 103, while #(λpqfx.p(q f)x)C(2)(λpfx.p(p f)x)C(5) =
44 corresponding to 2 × 5× 5. Moreover, we can compress the λ-term by com-
bining two function parts into one, such as (λpqfx.p(q(qf))x) C(2) C(5) with a
size of 35.
For a natural number n, there are many ways of decomposition, and the size
of the λ-term changes depending on the approach followed. For the running
example, expressions 7 × 7 + 1 and 5 × (5 + 5) are also equal to 50. The
corresponding λ-terms are
7× 7 + 1 : (λpfx.p(pf)(fx)) C(7),
5× (5 + 5) : (λpfx.p(pf(pf))x) C(5),
and the sizes are 29 and 28, respectively. Obtaining the optimal decomposition
is difficult, therefore, in RTP, we employ a heuristic approach.
3.2 Recursive tetrational partitioning
We only consider numerical expressions such as
F ::= x | F + F | F · F | FF
in BNF, where x is an arbitrary natural number. If the calculation of F results
in n, we denote it by F [n].
We construct a compact F [n] such that the size of the λ-term is reduced. It
is effective in reducing Church numerals appearing in the λ-term. It is equal to
reduce the kind of natural numbers included in F [n].
4
Let ϕ be a natural number smaller than or equal to n. Then, we consider
numerical expressions only using ϕ, denoted by Fϕ, as follows:
Fϕ ::= ϕ | Fϕ + Fϕ | Fϕ · Fϕ | FϕFϕ .
Fϕ derives only a multiple of ϕ. Let r = n mod ϕ and n̄ = n − r. Then, if
Fϕ derives n̄, we denote it by Fϕ[n̄]. Here, Fϕ[n̄] + r is a numerical expression
which derives n and includes at most 2 natural numbers, ϕ and r.
In order to reduce the size of the λ-term, it is also effective in reducing arith-
metic operations appearing in Fϕ[n̄], because the size of the λ-term increases
with the number of arithmetic operations. Next we show how our method
achieves this reduction.
We partition n̄ into an addition of tetrations with integer coefficients. It is
denoted as follows:
n̄→ kϕ · pk + k−1ϕ · pk−1 + · · ·+ 1ϕ · p1
where k is the maximum natural number such that kϕ ≤ n̄ and pi (0 ≤ i ≤ k)
is the integer such that 0 ≤ pi < i+1ϕ. The term including 0ϕ does not appear
in it because n̄ is divisible by ϕ. Then, we convert each term as follows:
iϕ · pi → iϕ · (pi − ri) + (
ri
︷ ︸︸ ︷
iϕ+ · · ·+ iϕ)
where ri = pi mod ϕ. Moreover, let p̄i = pi − ri and we partition p̄i recursively
in the same way. In this way, we can convert n̄ into Fϕ[n̄]. The procedure above
can be defined as Def. 5.
Definition 5 (Recursive tetrational partitioning (RTP)). Let n and ϕ be natu-
ral numbers such that 0 < ϕ < n, and let r = n mod ϕ and n̄ = n− r. Then, we
define RTP as follows, with the result derived by RTP being denoted by Tϕ[n̄]:
Tϕ[n̄] =



n̄ (if n̄ ≤ ϕ)
kϕ · (Tϕ[pk − (pk mod ϕ)]) + (
pk mod ϕ
︷ ︸︸ ︷
kϕ+ · · ·+ kϕ)
+ · · ·+ 1ϕ · (Tϕ[p1 − (p1 mod ϕ)]) + (
p1 mod ϕ
︷ ︸︸ ︷
1ϕ+ · · ·+ 1ϕ) (otherwise)
where k is the maximum natural number such that kϕ ≤ n̄ and pi (0 ≤ i ≤ k)
is the integer such that 0 < pi <
i+1ϕ. Here, if pi = 0 or 1, we omit the display
of the term or coefficient, respectively. 
For example, Tϕ[n̄] = T2[65578] =
42 + 32 × 2 + 22 × 2 + 2 with n = 65579
and ϕ = 2. In Def. 5, each coefficient (pi − (pi mod ϕ)) is a multiple of ϕ.
Thus, the remainder of each recursion step will always be 0. Hence, there is no
term including 0ϕ in Tϕ[n̄]. With regard to given n and ϕ, Tn̄[ϕ] is uniquely
determined.
3.3 Translation algorithm
When a numeral expression F is represented by Polish notation, we denote it
by PN(F ). Then, the following holds:
PN(Tϕ[n̄]) := +(term(k), (+(term(k − 1), (· · · , (+(term(2), term(1))) · · · ),
5
Algorithm 1 Algorithm translating Tϕ[n̄] + r into a λ-term
Input: Tϕ[n̄], r
Output: Λ(Tϕ[n̄], r)
1: function Translate(F )
2: function TermCase(F )
3: if F = ”×(M,N)” then return Translate(F )
4: else return (Translate(F ) f)
5: end if
6: end function
7: if F = ”+(M,N)” then return ((TermCase(M))(TermCase(N)))
8: else if F = ”×(M,N)” then return
((Translate(M))((Translate(N)) f))
9: else if F = ”∧(M,N)” then return
((Translate(N))(Translate(M)))
10: else return p
11: end if
12: end function
13: main
14: PN(Tϕ[n̄])← Tϕ[n̄] denoted by Polish notation
15: output (λpfx.(Translate(PN(Tϕ[n̄])))(
r
︷ ︸︸ ︷
f (f · · · (f x) · · · ))) C(ϕ)
16: end main
where
term(i) := +(×(iϕ, (PN(Tϕ[pi − (pi mod ϕ)]))), rem(pi))),
iϕ := ∧(
i
︷ ︸︸ ︷
ϕ,∧(ϕ, · · · ∧ (ϕ, ϕ) · · · ), and rem(pi) := +(
pi mod ϕ
︷ ︸︸ ︷
iϕ,+(iϕ, · · ·+ (iϕ, iϕ) · · · ).
For example,
PN(T2[65578]) = PN(
42 + 32× 2 + 22× 2 + 2)
= +(∧(2,∧(2,∧(2, 2))),+(×(∧(2,∧(2, 2)), 2),+(×(∧(2, 2), 2), 2)).
In Sec. 3.1, we mentioned that any numerical expression can be represented on λ-
terms by using Polish notation and naive substitution via Def. 4. However, the λ-
term generated in this way tends to be large. Therefore, we design an algorithm,
which enables the generation of a compact λ-term with regard to Tϕ[n̄]. This
algorithm is presented in Algorithm 1. For example, by this algorithm, 65579 =
T2[65578] + 1 is translated to Λ(T2[65578], 1) such that
Λ(T2[65578], 1) = (λpfx.p p p f (p p p (p f))(p p f (p f))(p f)(f x)) C(2).
Here, #Λ(T2[65578], 1) = 46 is much smaller than #C(65579) = 131161.
The λ-term generated by Algorithm 1 comprises only a λ-abstraction and
C(ϕ). Here, the λ-abstraction is regarded as a folded function of arithmetic
operations included in Tϕ[n̄]. We denote the λ-term by Λ(Tϕ[n̄], r) with Tϕ[n̄]+r,
the numerical expression of n.
6
Lemma 2. Let n and ϕ be natural numbers such that ϕ < n, and let r =
n mod ϕ and n̄ = n− r. Let us denote the number of additions, multiplications,
and expressions appearing in Tϕ[n̄] by Na, Nm, and Ne, respectively. Then, the
following equation holds:
#Λ(Tϕ[n̄], r) = 2((2Na +Nm +Ne) + ϕ+ r + 6).
Proof. The form of Λ(Tϕ[n̄], r) is (λnfx.M) C(ϕ). By Def. 2 and Def. 3,
#C(ϕ) = 2ϕ+ 3. Then, the size of that λ-term is as follows:
#Λ(Tϕ[n̄], r) = #(λnfx.M) C(ϕ) = 3 +#M +#C(ϕ) + 1 = #M + 2ϕ+ 7.
(1)
Initially, the λ-term M has the form such as (p f X) with X = (
r
︷ ︸︸ ︷
f (f · · · (f x) · · · )).
Here, #M = 2r + 5. If an addition is added in the λ-term, the form of M
changes into (p f (p f X)), and #M increases by 4. Note that while counting
the size of the λ-term, the parentheses are ignored. Similarly, in the case of
multiplications and exponentiations, the form of M changes into (p (p f) X)
and (p p f X), respectively. Both of their sizes increase by 2. Therefore,
#M = 4Na + 2Nm + 2Ne + 2r + 5. Then, by equation (1), the following holds:
#Λ(Tϕ[n̄], r) = #M + 2ϕ+ 7 = 4Na + 2Nm + 2Ne + 2r + 5 + 2ϕ+ 7
= 2((2Na +Nm +Ne) + ϕ+ r + 6).

Lemma 3. Let n and ϕ be natural numbers such that ϕ < n, and let r =
n mod ϕ and n̄ = n− r. Then, if n ≤ 8, then #C(n) ≤ #Λ(Tϕ[n̄], r).
Proof. By Lemma 2, the following inequality holds:
#Λ(Tϕ[n̄], r) = 2((2Np +Nm +Ne) + ϕ+ (n mod ϕ) + 6)
> 2(1 + ϕ+ 6)
≥ 2(1 + 2 + 6) = 18
If n ≤ 7, then #C(n) = 2n + 3 < 18. Even if n = 8, then #Λ(Tϕ[n̄], r) >
#C(8) = 19 because #Λ(T2[8], 0) = 20, #Λ(T3[8], 2) = 26, and #Λ(T4[8], 0) =
24. 
3.4 Further compaction
We denote ϕ in minimum #Λ(Tϕ[n̄], r) by ϕ
∗, and denote Tϕ∗ [n̄] by T
∗[n̄].
Lemma 4. With any natural number n, ϕ∗ is in [2, 2
√
n].
Proof. Let Na(Tϕ[n̄]), Nm(Tϕ[n̄]), and Ne(Tϕ[n̄]) be the numbers of additions,
multiplications, and exponentiations in Tϕ[n̄], respectively. Note that we can
generate Tϕ[n̄] with some arithmetic operations only if ϕ ≤ n/2. Let ϕt be an
integer such that
√
n < ϕt ≤ n/2, and let rϕt = n mod ϕt and n̄ϕt = n − rϕt .
Here, Tϕt [n̄ϕt ] includes some additions, no multiplication and no exponentiation.
Thus, Na(Tϕt [n̄ϕt ]) ≥ 1, Nm(Tϕt [n̄ϕt ]) = Ne(Tϕt [n̄ϕt ]) = 0. Then, by Lemma 2,
the following holds:
#Λ(Tϕt [n̄ϕt ], rϕt) = 4Na(Tϕt [n̄ϕt ]) + 2ϕt + 2rϕt + 12. (2)
7
n #C(n) #Λ(T ∗[n̄], r) n #C(n) #Λ(T ∗[n̄], r) n #C(n) #Λ(T ∗[n̄], r)
9 21 20 14 31 20 19 41 20
10 23 22 15 33 22 20 43 22
11 25 24 16 35 24 21 45 24
12 27 24 17 37 24 22 47 24
13 29 26 18 39 26 23 49 26
24 51 10
Table 1: C(n) = 2n+ 3 and #Λ(T ∗[n̄], r) in 8 < n ≤ 24
Next, let ϕu be the maximum integer such that ϕu ≤
√
n, and let rϕu = n mod
ϕu and n̄ϕu = n−rϕu . Here, Nm(Tϕu [n̄]) = 1, Na(Tϕu [n̄ϕu ]) = Ne(Tϕu [n̄ϕu ]) =
0. Similar to the above, by Lemma 2,
#Λ(Tϕu [n̄ϕu ], rϕu) = 2Nm(Tϕu [n̄ϕu ]) + 2ϕu + 12 + 2rϕu = 2ϕu + 14 + 2rϕu
≤ 2ϕu + 14 + 2(ϕu − 1) = 4ϕu + 12. (3)
Therefore, we obtain the following inequality:
(2)− (3) ≥ 2(ϕt + rϕt − 2ϕu). (4)
The right-hand side of inequality (4) is larger than 0 if ϕt ≥ 2ϕu. Since ϕt >
√
n,
#Λ(Tϕ[n̄], r) is not minimized when ϕ > 2
√
n. 
Lemma 5. Let n and ϕ be natural numbers such that ϕ < n, and let r =
n mod ϕ and n̄ = n− r. Then, the inverse of Lemma 3 holds, that is, Tϕ[n̄] + r
such that #C(n) > #Λ(Tϕ[n̄], r) exists when n > 8.
Proof. We show that T ∗[n̄] such that #C(n) > #Λ(T ∗[n̄], r) exists for any n >
8. Let ϕu be the maximum integer such that ϕu ≤
√
n, and let rϕu = n mod ϕu
and n̄ϕu = n− rϕu . By Lemma 2 and Lemma 4,
#Λ(Tϕ[n̄], r) ≤ #Λ(Tϕu [n̄ϕu ], rϕu) ≤ 4ϕu + 12 ≤ 8
√
n+ 12 (5)
If n > 24, #Λ(T ∗[n̄], r) < #C(n) follows #C(n) = 2n + 3 > 8√n + 14 and
inequality (5). By Table 1, it also holds in the case of 8 < n ≤ 24. 
Lemma 5 implies that if ϕ∗ > 8, we can make Λ(T ∗[n̄], r) into a more
compact λ-term by applying RTP to ϕ∗ and by translating its result into a
λ-term via Algorithm 1. This operation can be applied recursively while ϕ∗,
at each recursion step, is larger than 8. By Λ∗(n) we denote the final λ-term
obtained as a result. That is,
(λpfx.Mi)C(ϕ∗i+1) := Λ(T ∗[ϕ̄∗i ], rϕ∗i )
Λ∗(n) := (λpfx.M0)((λpfx.M1) · · · ((λpfx.MN )C(ϕ∗N )) · · · ),
where 0 ≤ i ≤ N, ϕ∗0 = n, rϕ∗i = ϕ∗i mod ϕ∗i+1, and ϕ̄∗i = ϕ∗i − rϕ∗i . We show
an algorithm generating Λ∗(n) for given C(n) in Algorithm 2.
8
Algorithm 2 Algorithm generating Λ∗(n) for C(n)
Input: C(n)
Output: Λ∗(n)
1: function Compaction(C(n))
2: n← the natural number corresponding C(n)
3: for ϕ = 2 to 2
√
n do
4: rϕ ← n mod ϕ
5: n̄← n− rϕ
6: Tϕ[n̄]← RTP of n̄ by ϕ
7: Λ(Tϕ[n̄], rϕ)← λ-term translated from Tϕ[n̄] + rϕ via Algorithm 1
8: end for
9: T ∗[n̄]← Tϕ[n̄] in minimum #Λ(Tϕ[n̄], rϕ)
10: r∗ ← rϕ in minimum #Λ(Tϕ[n̄], rϕ)
11: if r∗ ≤ 8 then return Λ(T ∗[n̄], r∗)
12: else return (The function part of (Λ(T ∗[n̄], r∗))(Compaction(C(r∗))))
13: end if
14: end function
15: main
16: output Compaction(C(n))
17: end main
3.5 The upper bound of the size
Lemma 6. Let n and ϕ be natural numbers such that ϕ < n, and let r =
n mod ϕ and n̄ = n − r. Then, the size of the function part of Λ(T ∗[n̄], r) is
less than or equal to that of Λ(T2[n̄], r).
Proof. We show it by reduction to contradiction. We assume that the size of
the function part of Λ(T ∗[n̄], r) is larger than that of Λ(T2[n̄], r). With regard to
the size of Church numerals appearing in the argument parts, #C(2) ≤ #C(ϕ∗)
holds. #Λ(Tϕ[n̄], r) is the sum of the sizes of the function and argument part.
Therefore, #Λ(T ∗[n̄], r) > #Λ(T2[n̄], r) follows the assumption. However, this
contradicts Λ(T ∗[n̄], r) being the minimum λ-term of Λ(Tϕ[n̄], r). Hence, the
assumption is wrong and the proposition has been proven. 
Theorem 1. O(#Λ∗(n)) is O((slog2n)logn/ log logn) with a natural number n.
Proof. Let ϕ be a natural number such that ϕ < n, and let r = n mod ϕ
and n̄ = n − r. Then, O(#Λ(T ∗[n̄], r)) is sum of O(the size of the function
part) and O(the size of the argument part). First, we consider O(the size of the
function part). By Lemma 6, it is bounded by O(the size of the function part of
#Λ(T2[n̄], r)). Here, T2[n̄] is as follows:
T2[n̄] =
k2T2[p̄k] + (
pk mod 2
︷︸︸︷
k2 ) + k−12T2[p̄k−1] + (
pk−1 mod 2
︷︸︸︷
k−12 ) + · · ·+ 12T2[p̄1] + (
p1 mod 2
︷︸︸︷
12 )
where p̄i is pi − (pi mod 2), which is a coefficient of iϕ for 1 ≤ i ≤ k. At that
time, pi mod 2 is 1, at most. Then, the following inequality holds with regard to
k:
(slog2n)− 1 < k ≤ slog2n (6)
9
This says that k is the maximum integer such that k ≤ slog2n. By Lemma
2, in the function part, the size increments by addition, multiplication, and
exponentiation are 4, 2, and 2, respectively. Therefore, the maximum size of
each term (i2 · p̄i + i2) is 2i+2+ (the size of p̄i) + 4+ 2i where i ≤ k and these
terms appear k times at most. RTP partitions each p̄i recursively. Let us denote
the number of recursion times by ρ. With regard to the upper bound of the size
of the function part in Λ(T2[n̄], r), the following holds:
O((2k + 2 + (the size of p̄k) + 4 + 2k) · k) = O(k2 + k + k(the size of p̄k)) = O(kρ).
Note that i can be k in each recursion step. Therefore, by Lemma 1,
(k2)ρ ≤ n ⇐⇒ ρ log k2 ≤ logn
ρ ≤ log n
log k2
<
logn
log (slog2n)−12
=
logn
log log (slog2n)2
=
logn
log logn
. (7)
Hence, the conclusion below follows inequality (6) and (7):
O(kρ) = O((slog2n)logn/ log logn).
Secondly, we consider O(the size of the argument part). If ϕ∗ ≤ 8, it is con-
stant because O(#C(ϕ∗)) = O(#C(8)). If ϕ∗ > 8, C(ϕ∗) is recursively com-
pacted. By the proof above, the upper bound of the size of the λ-term result is
O((slog2ϕ∗)logϕ
∗/ log logϕ∗+#C(ϕ∗1)) where ϕ∗1 is ϕ1 in minimum Λ(Tϕ1[ϕ∗], (ϕ∗−
(ϕ∗ mod ϕ1))). Here, ϕ
∗ is clearly less than n. This is followed by
O((slog2ϕ∗)logϕ
∗/ log logϕ∗) ≤ O((slog2n)log n/ log log n).
If C(ϕ∗1) > 8, it is also converted recursively. However, a similar inequality holds
in each recursion step and the final ϕ∗ρ results in a constant such that ϕ
∗
ρ ≤ 8.
Therefore, O(#Λ∗(n)) is O((slog2n)logn/ log logn). 
4 Application to Higher-Order Compression
4.1 Abstract of higher-order compression
In higher-order compression, first, the source text data is regarded as the λ-term
such that terminal alphabets are repeatedly combined form tail by functional
applications. For example, the source text ababc$ is regarded as the λ-term
(a (b (a (b (c $))))). Then, we convert it to another λ-term whose size is less
than the size of the original, with the remaining equivalency between them.
Here, we say that there is an equivalency between M and N if both M and N
result in the same λ-term by calculation.
4.2 Relationship between Church numerals and repetition
patterns
In the λ-terms of higher-order compression, repetition patterns appeare as ((a
Church numeral corresponding to the repetition number of the pattern) (pat-
tern)). For example, the λ-term corresponding to the string ”abcabcabcabc$” is
expressed as follows:
((a b c)((a b c)((a b c)((a b c) $))))→ (λfx.f(f(f(f x))))(a b c) $ = C(4) (a b c) $
10
Figure 1: Experimental result
If the repetition number is large, i.e., the Church numeral appearing in the
λ-term is large, we can then compress the λ-term by compacting the Church
numeral via our algorithm.
4.3 A method using binary expression
As related work, we introduce a method that can compress Church numerals
using a binary expression. This method is reported by Kobayashi et al. [1]. Let
b0 = (λfpq.f p (f p q)) and b1 = (λfpq.p (f p (f p q))). Then, the term
(b1(b0(b0(b1(b1(b1(C(0))))))) a $) generates the λ-term, which expresses a57$,
that is, (
57
︷ ︸︸ ︷
a (a · · · (a $) · · · )). Here, the binary expression of 57 is 111001, and
the part b1(b0(b0(b1(b1(b1(C(0))))))) corresponds to its reverse.
Ahead of Kobayashi et al., Mogensen [2] proposed a binary expression of
Church numerals and generalized to higher number-bases. The above method
is essentially the same as the method of Mogensen.
4.4 Experiment
To confirm the efficiency of our Algorithm, we conduct an experiment with
regard to the compression ratio. Figure 1 depicts the result of the experiment.
We used the artificial data an$ as input. In Fig. 1, the horizontal axis shows
the repetition n and the vertical axis shows the size of each λ-term. ”string” de-
notes #(
n
︷ ︸︸ ︷
a (a · · · (a $) · · · )). ”binary” denotes the size of the λ-term compacted
by the method using the binary expression. ”YKS” denotes the compaction
manner of higher-order compression, proposed by Yaguchi et al. [4], and, ”pro-
posed” denotes our proposed method that uses Algorithm 2.
The inequality (proposed ≤ binary) holds in 9625 cases out of 10000 cases.
The ratio (proposed / binary) is approximately 0.7887. This means that the size
of the compressed λ-term decreased by approximately 21%, on an average, by
our algorithm. Similarly, the inequality (proposed ≤ YKS) holds in 9584 cases
and the ratio (proposed / YKS) is approximately 0.7667. This means that the
size decreased by approximately 23%, on an average, by the proposed method.
11
5 Conclusion
In this paper, we addressed the problem of compacting Church numerals, which
is useful for higher-order compression. We proposed RTP for decomposing large
numerals and presented a λ-term conversion algorithm using RTP. The λ-terms
produced by the algorithm tend to become shorter in practice, while its theo-
retical size, O(slog2nlogn/ log logn), may grow larger than O(log n) in the worst
case. For n = k2, of course, C(n) is converted to the λ-term whose size is
O(slog2n) = O(k). We have not proved the lower bound of the size in the worst
case; it is one of our future works.
Very recently, Takeda et al. [3] proposed an efficient method to encode λ-
terms. Efficiently finding repeating regions in an input and counting the number
of repetitions are the problems remaining in higher-order compression.
Acknowledgements. The authors would like to thank Ayumi Shinohara
and his colleagues for providing the source codes for higher-order compression.
This work was supported by JSPS KAKENHI Grant Number JP15K00002 and
JST CREST Grant Number JPMJCR1402, Japan. Finally, the authors would
like to thank Enago (www.enago.jp) for the English language review.
References
[1] Naoki Kobayashi, Kazutaka Matsuda, Ayumi Shinohara, and Kazuya
Yaguchi. Functional programs as compressed data. Higher-Order and Sym-
bolic Computation, 25(1):39–84, 2012.
[2] Torben Æ. Mogensen. An investigation of compact and efficient number
representations in the pure lambda calculus. In Revised Papers from the
4th International Andrei Ershov Memorial Conference on Perspectives of
System Informatics: Akademgorodok, Novosibirsk, Russia, PSI ’02, pages
205–213, London, UK, 2001. Springer-Verlag.
[3] Kotaro Takeda, Naoki Kobayashi, Kazuya Yaguchi, and Ayumi Shinohara.
Compact bit encoding schemes for simply-typed lambda-terms. SIGPLAN
Not.(Proceedings of the 21st ACM SIGPLAN International Conference on
Functional Programming), 51(9):146–157, September 2016.
[4] Kazuya Yaguchi, Naoki Kobayashi, and Ayumi Shinohara. Efficient algo-
rithm and coding for higher-order compression. In In proceedings of 2014
Data Compression Conference (DCC2014), pages 434–434, March 2014.
12
This figure "figure_1.png" is available in "png"
 format from:
http://arxiv.org/ps/1706.10061v1

