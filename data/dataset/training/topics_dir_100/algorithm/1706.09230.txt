Accelerations for Graph Isomorphism
Caishi Fang∗
Centre for Quantum Software and Information,
University of Technology Sydney, Australia
Abstract
In this paper, we present two main results. First, by only one conjec-
ture (Conjecture 2.9) for recognizing a vertex symmetric graph, which is
the hardest task for our problem, we construct an algorithm for finding
an isomorphism between two graphs in polynomial time O(n3). Second,
without that conjecture, we prove the algorithm to be of quasi-polynomial
time O(n1.5 logn). The conjectures in this paper are correct for all graphs
of size no larger than 5 and all graphs we have encountered. At least
the conjecture for determining if a graph is vertex symmetric is quite true
intuitively. We are not able to prove them by hand, so we have planned to
find possible counterexamples by a computer. We also introduce new con-
cepts like collapse pattern and collapse tomography, which play important
roles in our algorithms.
1 Introduction
Currently, the best general algorithm for graph isomorphism problem is due to
Babai [1], who shows that the graph isomorphism is of quasi-polynomial time
exp((log n)O(1)). We give a constructive proof of this result in the current paper.
And by only one conjecture, which is quite true intuitively, we give a polynomial
time algorithm for the problem. This also means that we have reduced the graph
isomorphism problem in polynomial time to the problem of determining whether
a graph is vertex symmetric or not.
A detailed review is needed on the applications and related problems such
as group isomorphism. The author has not seen Babai’s [1] work in very de-
tail. There may be some common techniques between this paper and previous
papers not pointed out, which is another reason for the need of a review paper.
Currently, if you want to know more about the origin and research history of
the graph isomorphism problem, please refer to [8, 3, 1, 6].
In this paper, G = (V,E) means an undirected graph G with a vertex set
V and an edge set E and without self-loop or multiple edges connecting two
vertexes. The case that graphs containing self-loop and multi-edges is discussed
after we have presented the main results. Let V = {v1, v2, · · · , vn}. If there is a
direct connecting between vi and vj for vi, vj ∈ V and vj 6= vi, we denote it by
(vi, vj). Let T be the set of all (i, j) pairs with (vi, vj). E = {(vi, vj) : (i, j) ∈ T}.
∗thinliber@gmail.com
1
ar
X
iv
:1
70
6.
09
23
0v
1 
 [
cs
.D
S]
  2
7 
Ju
n 
20
17
We denote the size of V as |V |. Let Vj = {vk ∈ V : (vj , vk) ∈ E}. The degree
of a vertex vj ∈ V is |Vj |.
Given two graphs G1 = (V1, E1) and G2 = (V2, E2), if there is a one-to-one
correspondence π between V1 and V2, s.t., for all vi, vj ∈ V1, (vi, vj) ∈ E1
iff (π(vi), π(vj)) ∈ E2, then we say G1 is isomorphic to G2 and π is a graph
isomorphism between G1 and G2. Any isomorphism from a graph G to itself
is called the automorphism of G. Note that, as the identity permutation is
always an automorphism for any graph, we are not interested in this trivial
automorphism. For the graph isomorphism and automorphism, we have an
intuitive understanding, i.e., all directly connected vertexes must be also directly
connected after an isomorphic or automorphic mapping, which is a permutation
of vertex names.
Now we define several problems.
The graph isomorphism problem, denoted as GI(G1, G2): determine whether
G1 and G2 are isomorphic.
The graph automorphism problem, denoted as GA(G): determine if there
exists a non-trivial automorphism of the undirected graph G.
The graph automorphism counting problem, denoted as #GA(G): find the
total number of automorphisms of the undirected graph G.
If we can solve a problem P by using polynomially many times of the proce-
dure for solving another problem Q, we say P is polynomially reducible to Q. If
P and Q are polynomially reducible to each other, we say they are polynomially
equivalent.
It is shown GI(G1, G2) is polynomially equivalent with #GA(G) [7, 5], and
GA(G) is polynomially reducible to GI(G1, G2) [5].
It seems #GA(G) is much harder than GA(G). Just take the complete graph
as an example, the total number of automorphisms is n!−1, which is hard to
find one by one. With an oracle for GI(G1, G2), it will be easy to do #GA(G).
In this paper, we introduce two more problems. One is the graph automor-
phism with constraint problem, denoted as GA(G,C): determine if there exists
a non-trivial automorphism of the undirected graph G, with the constraint C.
For v1, v2 ∈ G, (v1, v2) ∈ C if v1 and v2 cannot replace each other under any
permutation or 〈v1, v2〉 ∈ C if v1 and v2 can only correspond to each other in
any automorphic mapping.
The other is the graph isomorphism with constraint problem, denoted as
GI(G1, G2, C): determine whether G1 and G2 are isomorphic, with the con-
straint C. For v1 ∈ G1, v2 ∈ G2, (v1, v2) ∈ C if v1 and v2 cannot replace each
other under any mapping or 〈v1, v2〉 ∈ C if v1 and v2 can only correspond to
each other in any isomorphic mapping.
It is easy to see that (1) GI(G1, G2) is a special case of GI(G1, G2, C); (2)
GA(G) is a special case of GA(G,C); (3) GI(G1, G2) is equivalent to GA(G1 ∪
G2, C), with C = {〈v1, v2〉 : v1, v2 ∈ G1 or v1, v2 ∈ G2}; (4) GA(G,C) seems
easier than GA(G), as some permutations are ruled out by the constraint C. In
our polynomial algorithm for GI(G1, G2), we make use of GI(G1, G2, C) as a
subroutine.
In [7], it is said that the checking and counting of graph isomorphism are
polynomially equivalent, which is an evidence to the conjecture that the graph
isomorphism is not NP-complete.
In [2, 5], they define a complexity class GI of all problems polynomially
reducible to the graph isomorphism problem, and claim that GI = P if the
2
graph isomorphism is in class P.
We introduce concepts and theoretic work, including our conjectures, in
Section 2. The algorithm for graph isomorphism is described in Section 3. The
final section is the conclusion. The reader may skip Section 2.1 if not interested
in too much theoretical work.
2 Preparations
Given two graphs G = (V,E) and G′ = (V ′, E′), with |V |= |V ′|, our target is
to find a one-to-one correspondence π : V → V ′, s.t.,
for all vi, vj ∈ V, (vi, vj) ∈ E iff (π(vi), π(vj)) ∈ E′.
In this section, V = {v1, v2, · · · , vn}, V ′ = {v′1, v′2, · · · , v′n}; Vi = {vj ∈ V :
(vi, vj) ∈ E}, V ′i = {v′j ∈ V ′ : (v′i, v′j) ∈ E′}, for i = 1, 2, · · · , n.
The first information we can use is that |Vi|= |V ′j | if π is an isomorphism
and π(vi) = v
′
j , i.e., in any isomorphism between V and V
′, a vertex of V can
only be mapped to a vertex of V ′ with the same degree. For this reason, we
introduce a concept called base subgraph G(w) for those vertexes of the same
degree w in a graph G:
G(w) = (V (w), E(w)), V (w) = {vi ∈ V : |Vi|= w},
E(w) = {(vi, vj) ∈ E : vi, vj ∈ V (w)}.
Note that it is only possible to map a vi ∈ V (w) to some v′j ∈ V ′
(w)
.
Given G(w) and vi ∈ V (w), we define the extension based on vi,
Gex(vi, w) = (V
ex(vi, w), E
ex(vi, w)),
as follows:
1. vi ∈ V ex(vi, w);
2. Vi − V (w) ⊆ V ex(vi, w);
3. For any vj ∈ V ex(vi, w)− V (w), Vj ⊆ V ex(vi, w);
4. Eex(vi, w) = {(vj , vk) ∈ E : vj ∈ V ex(vi, w)− V (w), vk ∈ V ex(vi, w)}.
We call vi the base point of the extension G
ex(vi, w).
The base subgraph G(w) is a separation of the the graph G, which means
vertexes inside the base subgraph are different from those outside. As such
separation is not limited to the degree argument, we can generalize the concepts,
base subgraph and extension, to a given set of vertexes β ( V . The base
subgraph of β is Gβ = (V β , Eβ), where V β = β. The extension of Gβ based
on vi is G
ex(vi, β). We just replace V
(w) by β in the definition of G(w) and
Gex(vi, w).
As the definitions are not so intuitive, we explain them by an example. Let’s
consider the graph in Figure 1a. The base subgraph of degree 3 is depicted in
Figure 1b. All extensions with respect to this base subgraph are depicted in
Figure 1d, 1e. Note we have colored all base points in black.
3
v1
v2
v3
v4 v5
v6
(a)
v2 v4
(b)
v2;l11 v4;l12
(c)
v1
v2
v3
v4
(d)
v2
v3
v4 v5
v6
(e)
Figure 1: (a) Ga; (b) G
(3)
a ; (c) G
(3)
a with labels; (d) Gexa (v2, 3); (e) G
ex
a (v4, 3)
Now we introduce some sets of labels Lk = {lk1, lk2, lk3, · · ·}, for k = 1, 2, · · ·.
The total number of labels used in an algorithm will be finite. We use labels
to replace extensions with respect to a base subgraph. The labels serve as
carrying on the information of whether two extensions are isomorphic or not. If
two extensions are isomorphic, we replace them with the same label, otherwise
different labels. After pair-wise comparing Figure 1d, 1e, we find that they are
not isomorphic with the constraint that a base point (black point) can only be
mapped to a base point, so we label them differently. In Figure 1c, we focus on
the base subgraph of degree 3, the base point v2 now has a label l11 and the
base point v4 has a label l12. It is better to write labels of a base point in a
predefined order and combine identical labels, e.g., write l23l11l12l12 as l11l
2
12l23.
We will learn more about the labeling procedure in the algorithm for graph
isomorphism.
We say a graph is vertex regular of w if every vertex in the graph is of the
same degree w.
Given a graph G = (V,E), with vi and Vi for i = 1, 2, · · · , n, we define the
collapse of G with the trigger vk, G
col(vk), as follows:
1. Layer 0: Gcol(vk, 0), V
col(vk, 0) = {vk}, Ecol(vk, 0) = ∅;
2. Layer 1: Gcol(vk, 1), V
col(vk, 1) = Vk, E
col(vk, 1) = {(vi, vj) ∈ E : vi, vj ∈
Vk};
3. Layer i + 2: Given Layer i + 1 (Gcol(vk, i + 1)) and Layer i (G
col(vk, i)),
Layer i+ 2 is Gcol(vk, i+ 2), with V
col(vk, i+ 2) =
⋃
vx∈V col(vk,i+1){vy ∈
V : vy ∈ Vx − V col(vk, i + 1) − V col(vk, i)}, Ecol(vk, i + 2) = {(vx, vy) ∈
E : vx, vy ∈ V col(vk, i+ 2)}.
See Figure 2b for example. It is a collapse trigged by vertex v1 for the vertex
regular graph Gb, which is Figure 2a. There are n collapses in a graph of n
vertexes.
Let deg(vi, vj) = |Vi|+|Vj |−|Vi ∩ Vj | be the degree (edge degree) of an edge
(vi, vj). Intuitively, the degree of an edge is the total number of collapses in
which the edge is located before Layer 2. Likewise, we say a graph is edge
regular of w if every edge in the graph is of the same degree w. Figure 3a
4
v1
v2
v3
v4 v5
v6
v7
v8
(a)
v1 v2
v3
v4
v5
v6
v7
v8
(b)
Figure 2: (a) vertex regular graph Gb; (b) G
col
b (v1)
and Figure 3b are both edge regular and vertex regular, and they are actually
isomorphic. Figure 2a is vertex regular but not edge regular.
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
(a)
v1
v2
v3
v4
v5
v6
v7
v8
v9
v10
v11
v12
(b)
Figure 3: (a) graph Gc; (b) graph Gd
Let’s define here an important class of graphs, the vertex symmetric graph.
For a graph G = (V,E), by designating a nailed vertex (imagine that you nail
the graph to the wall with the nail on the designated vertex), we distinguish
|V | possible nailed graphs of G, G(vi), i = 1, 2, · · · , |V |. Those independent
parts of the graph will fall down to the floor. Thus, G(vi) is equal to G
col(vi)
with the edges between its layers added back. Any nailed graph is connected.
G is vertex symmetric if and only if all of its nailed graphs are isomorphic to
each other. More precisely, if for every i from 1 to |V |, we have for every j
from i to |V |, GI(G(vi), G(vj), {〈vi, vj〉}) = True, then we say the graph G is
vertex symmetric. Here, {〈vi, vj〉} means vi can only correspond to vj in any
isomorphic mapping and vice versa. Complete graph is vertex symmetric. A
graph consisting of one circle or multiple identical circles is also vertex symmet-
ric. Figure 3a and Figure 3b are further examples of vertex symmetric graphs.
Later we will see that the only obstacle of the graph isomorphism problem is
how to recognize a vertex symmetric graph.
Lemma 2.1 Given G = (V,E), if G is vertex symmetric, then it is vertex
regular.
5
We can generalize the concepts, collapse and nailed graph, to multi-collapse
and multi-nailed graph, i.e., using multiple triggers or nailed vertexes at the
same time. Given a graph G, a multi-collapse (sometimes just called collapse if
it is clear from the content) with a set of triggers T is Gcol(T ), in which layer 0
contains vertexes in the set T , and layer k + 1 contains all vertexes connecting
those vertexes in layer k. A multi-nailed graph with a set of nailed vertexes T is
G(T ), which looks the same as Gcol(T ) with those edges between layers added
back. The normal (not nailed) graph and the nailed graph are special cases of
the multi-nailed graph.
A graph G is edge symmetric if and only if all of its multi-nailed graphs
G((vi, vj)), with (vi, vj) ∈ E, are isomorphic to each other under the constraint
{〈(vi, vj), (vi′ , vj′)〉}, which means that the edge (vi, vj) can only be mapped to
(vi′ , vj′) in any isomorphism between G((vi, vj)) and G((vi′ , vj′)).
Lemma 2.2 Given G = (V,E), if G is edge symmetric, then it is edge regular.
Actually, there exist graphs that is both vertex regular and edge regular but
not vertex symmetric, see Figure 4a. There exist graphs that is edge symmetric
but not vertex symmetric, e.g., Figure 4a, the complete bipartite graph in Figure
4b and Figure 3.2 in [4]. There exist graphs that is vertex symmetric but not
edge symmetric, see Figure 4c. There exist graphs edge symmetric but not
vertex regular, see Figure 4b. There exists graphs that is both vertex regular
and edge regular but not vertex symmetric or edge symmetric, e.g., a graph
consisting of two independent circles of different sizes.
v1
v2
v3 v4
v5
v6
v7 v8
v9
v10 v11
v12
v13 v14
v15
v16
v17
v18
v19 v20
(a)
v1
v2
v3
v4
v5
v6
v7
(b)
v1
v2
v3
v4
v5
v6
v7
v8
(c)
Figure 4: (a) graph Ge; (b) graph Gf ; (c) graph Gg
An arc is an edge treated as directed. A graph G is arc symmetric if and
only if all of its arc nailed graphs G(vi; vj), with (vi, vj) ∈ E, are isomorphic
to each other under the constraint {〈vi, vi′〉, 〈vj , vj′〉}, which means that the
vertex vi of the edge (vi, vj) can only be mapped to vi′ of the edge (vi′ , vj′)
and vj can only be mapped to vj′ in any isomorphism between G(vi; vj) and
G(vi′ ; vj′). The difference between arc symmetry and edge symmetry is that we
treat the trigger edge as directed in the arc symmetry. There exists graphs that
is both vertex symmetric and edge symmetric but not arc symmetric, e.g., the
Doyle-Holt graph, see Figure 3.3 in [4].
6
Lemma 2.3 Given G = (V,E), if G is arc symmetric, then it is both vertex
symmetric and edge symmetric.
In the literature, vertex symmetric is equivalent to vertex transitive and 0-arc
transitive, edge symmetric is equivalent to edge transitive, and arc symmetric is
equivalent to arc transitive and 1-arc transitive. We prefer the word ‘symmetric’
more than ‘transitive’, as the former is shorter and more intuitive.
Let’s point out the levels of symmetry of a graph: No pair of isomorphic ver-
tex nailed subgraphs and no pair of isomorphic edge nailed subgraphs =⇒ Some
pairs of isomorphic vertex nailed subgraphs or some pairs of isomorphic edge
nailed subgraphs =⇒ Vertex symmetric or edge symmetric =⇒ Arc symmetric.
Given two multi-sets A = {a1, a2, · · · , as} and B = {b1, b2, · · · , bt}, we say A
matches B if the sort of a1, a2, · · · , as is equal to the sort of b1, b2, · · · , bt. For
instance, {3, 7, 3, 2, 1} matches {1, 2, 3, 3, 7} but does not match {3, 7, 2, 1, 4}.
More generally, {{5, 3, 3}, {5, 2, 2, 8}, {1, 4, 2}, {1, 3, 3}} matches {{1, 2, 4}, {1, 3,
3}, {2, 2, 5, 8}, {3, 3, 5}} but does not match {{5, 3, 3}, {1, 3, 4}, {5, 2, 2, 2}, {1, 4,
2}}.
The vertex property of a graph G = (V,E) is the multi-set PV (G) = {|Vi|:
i = 1, 2, · · · , n}, where n = |V |. We say two graphs G and G′ are of the same
vertex property if their vertex properties match. Similarly, the edge property of
a graph G = (V,E) is the multi-set PE(G) = {deg(vi, vj) : (vi, vj) ∈ E}. We
say two graphs G and G′ are of the same edge property if their edge properties
match.
Given one collapse of G, say Gcol(vk), which has l + 1 layers, G
col(vk, i) for
i = 0, 1, · · · , l, the collapse tomography of Gcol(vk) is an ordered list of l ordered
pairs of the vertex property and the edge property, i.e.,
Ctom(G, vk) = [[PV (G
col(vk, i));PE(G
col(vk, i))] : i = 1, 2, · · · , l].
Two collapse tomographies match if all properties in the ordered list match at
the corresponding position. For instance,
[[{5, 3, 3}; {5, 2, 2, 8}], [{1, 4, 2}; {1, 3, 3}], [{7, 5}; {3, 3}]]
matches
[[{3, 3, 5}; {2, 2, 5, 8}], [{1, 2, 4}; {1, 3, 3}], [{5, 7}; {3, 3}]]
but not
[[{3, 3, 5}; {2, 2, 5, 8}], [{1, 3, 3}; {1, 2, 4}], [{5, 7}; {3, 3}]].
The collapse tomography of Figure 2b is
[[{0, 2, 2, 2}; {3, 3, 3}], [{2, 2, 2}; {3, 3, 3}]].
Given a graph G, the collapse pattern of G is a multi-set of collapse tomo-
graphies of G, i.e.,
Cpat(G) = {Ctom(G, vi) : i = 1, 2, · · · , |V |}.
Given a nailed graph G(va), let G
col(va, j), j = 0, 1, 2, · · · , l, be l + 1 layers
of its collapse. The collapse pattern of G(va) is an ordered list of multi-sets of
collapse tomographies of G, i.e.,
Cpat(G(va)) = [{Ctom(G, vi) : vi ∈ V col(va, j)} : j = 0, 1, 2, · · · l].
7
Given a multi-nailed graph G(T ) and its collapse Gcol(T ), which has l + 1
layers, the corresponding collapse pattern is
Cpat(G(T )) = [{Ctom(G, vi) : vi ∈ V col(T, j)} : j = 0, 1, 2, · · · l].
If each vertex v of the graph G is labeled by L(v), then the collapse tomog-
raphy under labeling L is
Ctom(G,L, vi) = [[L(vi);PV (G
col(vk, i));PE(G
col(vk, i))] : i = 1, 2, · · · , l],
and the collapse pattern under labeling L for a nailed graph G(va) is
Cpat(G(va), L) = [{Ctom(G,L, vi) : vi ∈ V col(va, j)} : j = 0, 1, 2, · · · l].
We leave the study of properties of the collapse pattern of normal graph,
nailed graph and multi-nailed graphs as a future work.
Lemma 2.4 Given G = (V,E) and G′ = (V ′, E′), if G is isomorphic to G′,
then the collapse pattern of G matches that of G′.
Conjecture 2.5 Given G = (V,E) and G′ = (V ′, E′), G is isomorphic to G′
if the collapse pattern of G matches that of G′.
Lemma 2.6 Given G, G′, and their nailed graphs, G(va) and G
′(vb), if G(va)
is isomorphic to G′(vb) with the constraint {〈va, vb〉}, then the collapse pattern
of G(va) matches that of G
′(vb).
Conjecture 2.7 Given G, G′, and their nailed graphs, G(va) and G
′(vb), G(va)
is isomorphic to G′(vb) with the constraint {〈va, vb〉} if the collapse pattern of
G(va) matches that of G
′(vb).
Lemma 2.8 Given G = (V,E), if G is vertex symmetric, then all |V | collapse
tomographies of G match each other, i.e., the collapse pattern of a vertex sym-
metric graph consists of |V | equal collapse tomographies.
Conjecture 2.9 Given G = (V,E), G is vertex symmetric if all |V | collapse
tomographies of G match each other, i.e., the collapse pattern of a vertex sym-
metric graph consists of |V | equal collapse tomographies.
Conjecture 2.9 is a corollary of Conjecture 2.7. In the algorithm for graph
isomorphism, we only use Conjecture 2.9, as it is quite true intuitively.
Let’s call a graph G vertex indistinguishable if all of its |V | collapse patterns
Cpat(G(vi)), with vi ∈ V , are equivalent. The question corresponding to Con-
jecture 2.9 is “Is there any graph that is vertex indistinguishable but not vertex
symmetric?”.
Lemma 2.10 Given G = (V,E), if G is edge symmetric, then all |E| collapse
patterns of edge nailed graphs G(vi, vj), with (vi, vj) ∈ E, match each other.
Conjecture 2.11 Given G = (V,E), G is edge symmetric if all |E| collapse
patterns of edge nailed graphs G(vi, vj), with (vi, vj) ∈ E, match each other.
8
In order to have a similar conjecture for arc symmetry, we redefine the
collapse pattern for the arc nailed graph G(va; vb) as an ordered list of collapse
patterns:
Cpat(G(va; vb)) = [C
pat(G(va, vb)), C
pat(G[va, vb](va)), C
pat(G[va, vb](vb))],
where Cpat(G(va, vb)) is the collapse pattern of the edge nailed graph G(va, vb),
Cpat(G[va, vb](va)) is the collapse pattern of the nailed graph at va obtained
by removing the edge (va, vb) in G and nail the vertex va, and similarly for
Cpat(G[va, vb](vb)).
Lemma 2.12 Given G = (V,E), if G is arc symmetric, then all 2|E| col-
lapse patterns of arc (an edge treated as directed) nailed graphs G(vi; vj), with
(vi, vj) ∈ E and the direction is from vi to vj, match each other.
Conjecture 2.13 Given G = (V,E), G is arc symmetric if all 2|E| collapse
patterns of arc nailed graphs G(vi; vj) match each other.
The quantity, collapse pattern, contains a lot of information of a graph, so
it may be a good argument to distinguish graphs. Up to now, our conjectures
have never failed. Although we have tried our best to prove them, we cannot.
Thus, we hope of finding a counterexample by a computer.
Now let’s introduce the dual graph. Given a graph G = (V,E), its dual
graph is G = (V,E), where (vi, vj) ∈ E if and only if (vi, vj) /∈ E.
Lemma 2.14 G is isomorphic to G′ if and only if G is isomorphic to G′.
Proof. For any isomorphism π between G and G′, (vi, vj) in G if and only
if (π(vi), π(vj)) in G
′. So it is also true that (vi, vj) not in G if and only if
(π(vi), π(vj)) not in G
′. 
When a graph of size n is vertex regular of a large degree w > n2 , it seems
easier to consider its dual graph, which is vertex regular of a smaller degree
n− 1− w < n2 .
Lemma 2.15 Given two complete graphs G and G′, if G has n vertexes with
vertex vi labeled by L(vi) and G
′ has n vertexes with vertex v′j labeled by L(v
′
j),
then G is isomorphic to G′ if and only if {L(vi) : i = 1, 2, · · · , n} matches
{L(v′j) : j = 1, 2, · · · , n}.
Proof. The dual graph of a complete graph of size n is n independent vertexes.
2.1 Variations of Collapse Pattern
In the remaining part of Section 2, we provide more discussions on our conjec-
tures, which is not important for the next section. The reader may skip it if not
interested.
In case that the above conjectures fail, we can vary the definitions of our
collapse pattern to add more details of the graph.
Given a nailed graph G(va), let G
col(va, j), j = 0, 1, 2, · · · , l, be l + 1 layers
of its collapse, and let Gex(vi; va, j) be the extension with a base point vi ∈
9
V col(va, j) and the base subgraph G
col(va, j). The varied collapse pattern of
G(va) is an ordered list of multi-sets of ordered collapse tomographies, i.e.,
Cpat(G(va)) = [{[Ctom(G, vi);Ctom(Gcol(va, j), vi);
Ctom(Gex(vi; va, j), vi)] : vi ∈ V col(va, j)} : j = 0, 1, · · · l].
This varied definition encodes more information of the nailed graph.
For an ordinary graph, we also change the definition as
Cpat(G) = {Cpat(G(vi)) : vi ∈ V }.
Let G(T ) be a multi-nailed graph with nailed vertexes T and its collapse
Gcol(T ), which has l + 1 layers. The corresponding varied collapse pattern of
G(T ) is
Cpat(G(T )) = [{[Ctom(G, vi);Ctom(Gcol(T, j), vi);
Ctom(Gex(vi;T, j), vi)] : vi ∈ V col(T, j)} : j = 0, 1, · · · l].
Lemma 2.16 All of our definitions of collapse tomography and collapse pattern
are well-defined and computable in polynomial time.
If G of size n is a graph constructed by linking n− 1 vertexes to one vertex
v, we call it a diverging graph and v is called the source of the graph..
Lemma 2.17 If G is a diverging graph with the source v and n − 1 vertexes
labeled by L(vi), and G
′ is another diverging graph with source v′ and m − 1
vertexes labeled by L(v′j), then G(v) is isomorphic to G
′(v′) if and only if {L(vi) :
vi ∈ V } matches {L(v′j) : v′j ∈ V ′}.
Suppose we want to define for a nailed graph G(va) a quantity that is useful
to distinguish graphs and easy to be proved by induction, let such quantity be
Cq(G(va)). We hope that two graphs are isomorphic if and only if their values
of the quantity are equivalent.
Theorem 2.18 Given G(va) and G
′(vb), G(va) is isomorphic to G
′(vb) with
the constraint {〈va, vb〉} if and only if Cq(G(va)) matches Cq(G′(vb)), if we
define the quantity as
Cq(G(va)) = {Cq(Gex(vi, va)) : vi ∈ Va},
where Gex(vi, va) is the extension based on vi linking to va and the base subgraph
consisting only of the edge (vi, va).
Proof. Let L(vi) = C
q(Gex(vi, va)), then by induction and Lemma 2.17, we can
prove this theorem. 
Corollary 2.19 If Cq(G(va)) is a quantity for nailed graphs, then C
q(G) =
{Cq(G(vi)) : vi ∈ V } is a quantity for normal graphs.
Lemma 2.20 If Cq(G) = {Cq(G(vi)) : vi ∈ V } is a quantity for normal graphs,
then Cq(G,L) = {[Cq(G(vi)), L(vi)] : vi ∈ V } is a quantity for the case that
each vertex is labeled by L(vi).
10
Lemma 2.21 If G(va) and G
′(vb) are two nailed graphs with their collapses
Gcol(va) and G
′col(vb) having only Layer 0 and Layer 1, then G(va) is isomor-
phic to G′(vb) if and only if G
col(va, 1) is isomorphic to G
′col(vb, 1).
Theorem 2.22 Given G(va) a nailed graph, if we define the quantity as
Cq(G(va)) = {[Cq(G(vi, Va)), Cq(Gex(vi, Va ∪ {va}))] : vi ∈ V col(va, 1)},
where G(vi, Va) is the graph G
col(va, 1) nailed at vi, and G
ex(vi, Va ∪ {va}) is
the extension based on vi with the base subgraph consisting of vertexes Va and
va, then this quantity can distinguish graphs according to isomorphism.
Proof. Let L(vi) = C
q(Gex(vi, Va ∪ {va})), then by induction and Lemma 2.20
and Lemma 2.21, we can prove this theorem. 
As the lack of details of a graph, we cannot accelerate the graph isomorphism
problem in the abstract approach. In the next section, we apply a bunch of
methods for the acceleration of our algorithm.
3 Algorithms
Now, we are ready to present the algorithm for determining whether two graphs
are isomorphic.
Note that our algorithm is only based on Conjecture 2.9 and no other as-
sumption not proved. If we remove this conjecture, we can show its quasi-
polynomial time efficiency.
Our algorithm for graph isomorphism is GI(G,G′) = GI(G,G′, L0), where
L0 = ∅.
Algorithm: Graph Isomorphism GI(G,G′, Lk) with Labels
Input: Two graphs G = (V,E) and G′ = (V ′, E′), without self-loop or
multi-edge. V = {v1, v2, · · · , vn}, V ′ = {v′1, v′2, · · · , v′n}. Every
vertex v ∈ V ∪ V ′ is labeled by Lk(v).
Output: If G and G′ are isomorphic under the labeling function Lk, output
‘Yes’, otherwise ‘No’.
Runtime: O(n3) with Conjecture 2.9; O(n1.5 logn) without Conjecture 2.9.
The worst case is when the input is two vertex indistinguishable
but not vertex symmetric graphs.
Procedure:
1. Compute Ctom(G,Lk, vi) for all vi ∈ V , and Ctom(G′, Lk, v′j) for all
v′j ∈ V ′. If they all match each other, then by Conjecture 2.9, G and G′
are vertex symmetric. Then if G and G′ are regular of degree w ≤ n2 , we
call the sub-algorithm GI(G,G′, C, Lk), with C = {〈v1, v′1〉}. If G and G′
are regular of degree w > n2 , we call the sub-algorithm GI(G,G
′, C, Lk),
with C = {〈v1, v′1〉}. Output ‘Yes’ iff the sub-algorithm returns ‘Yes’.
Here, our target is to find an isomorphism. Note that, if we do not appeal
11
to Conjecture 2.9, then we have to check the isomorphism for all 2n nailed
graphs of G and G′ in the worst case, instead of only one pair. We may
use the method ‘try-and-error’ to further accelerate the algorithm, as
we believe that there is a non-negligible probability for finding a pair of
isomorphic nailed graphs if two graphs are vertex indistinguishable but
not vertex symmetric. Because of the use of dual graph, the size of the
next occurrence of vertex indistinguishable graph is no larger than n2 .
2. Compute C(G) = {Cpat(G(vi), Lk) : vi ∈ V }, and C(G′) = {Cpat(G′(v′j),
Lk) : v
′
j ∈ V ′}. Sort these two multi-sets of collapse patterns. If they
do not match, output ‘No’. Otherwise, suppose the rarest collapse pat-
tern in C(G) is Cpat(G(vx), Lk) and the corresponding one in C(G
′) is
Cpat(G′(v′y), Lk), let β = {vi : Cpat(G(vi), Lk) = Cpat(G(vx), Lk)} and
β′ = {v′j : Cpat(G′(v′j), Lk) = Cpat(G′(v′y), Lk)}. The base subgraph
of G is Gβ and that of G′ is G′
β′
. The extensions of Gβ are Ex(β) =
{Gex(vi, β) : vi ∈ V β} and those of G′β
′
are Ex(β′) = {G′ex(v′j , β′) : v′j ∈
V ′
β′}. Call the sub-algorithm GI(Gex1 (v1, β1), Gex2 (v2, β2), C, Lk) for all
pairs of extensions (Gex1 (v1, β1), G
ex
2 (v2, β2)) in the union set Ex(β) ∪
Ex(β′) with C = {〈v1, v2〉}. Next we assign two extensions with the
same label iff they are isomorphic. The labeling function Lk+1 assigns
two base points with the same label iff Lk assigns them with the same
label and the labels for their extensions are of the same. Then we call
the sub-algorithm GI(Gβ , G′
β′
, Lk+1), with vertex v ∈ β ∪ β′ labeled by
Lk+1(v). Output ‘Yes’ iff this sub-algorithm returns ‘Yes’.
Algorithm: Graph Isomorphism GI(G,G′, C, Lk) with Constraint and
Labels
Input: Two graphs G = (V,E) and G′ = (V ′, E′), without self-loop or
multi-edge. V = {v1, v2, · · · , vn}, V ′ = {v′1, v′2, · · · , v′n}. The con-
straint is C = {〈va, v′b〉}, where va is the nailed vertex of G(va)
and v′b is the nailed vertex of G
′(v′b). Every vertex v ∈ V ∪ V ′ is
labeled by Lk(v).
Output: If G(va) and G
′(v′b) are isomorphic under the constraint C and
the labeling function Lk, then output ‘Yes’; otherwise ‘No’.
Procedure:
1. Compute Cpat(G(va), Lk) and C
pat(G′(v′b), Lk). If they do not match,
then output ‘No’. Otherwise, let the collapse Gcol(va) have l + 1 layers.
2. If l = 1, call the sub-algorithm GI(Gcol(va, 1), G
′col(v′b, 1), Lk). Output
‘Yes’ iff this sub-algorithm returns ‘Yes’. Here, the input graphs may be
again vertex indistinguishable but not vertex symmetric.
3. For l ≥ 1, from x = l−1 to x = 0, we update the labels of vertexes in layer
x with the layer x+ 1 by the following procedure. Let β(x) be the set of
vertexes in layers from 0 to x of Gcol(va) and β
′(x) be the set of vertexes
in layers from 0 to x of G′
col
(v′b). Let Ex(β(x)) = {Gex(vi, β(x)) :
vi ∈ V col(va, x)} and Ex(β′(x)) = {G′ex(v′j , β′(x)) : v′j ∈ V ′
col
(v′b, x)}.
12
Suppose the labeling function for layer x is Lk,x with Lk,l = Lk. Call the
sub-algorithm GI(Gex1 (v1, β1(x)), G
ex
2 (v2, β2(x)), C, Lk,x+1) for all pairs
of extensions (Gex1 (v1, β1(x)), G
ex
2 (v2, β2(x))) in the union set Ex(β(x))∪
Ex(β′(x)) with C = {〈v1, v2〉}. Usually, we omit the labels of base points
when we are determining isomorphism of their extensions. Next we assign
two extensions with the same label iff they are isomorphic. The labeling
function Lk,x assigns two base points with the same label iff Lk assigns
them with the same label and the labels for their extensions are of the
same. On the whole, we distinguish two nailed graphs, according to
isomorphism, layer-by-layer.
Theorem 3.1 The algorithm GI(G,G′, Lk) can correctly distinguish graphs ac-
cording to isomorphism and is of polynomial time if Conjecture 2.9 is true.
Theorem 3.2 If Conjecture 2.9 is not true, then the algorithm GI(G,G′, Lk)
is of quasi-polynomial time O(n1.5 logn).
Proof. The recursion is T (n) = nn2T (n2 ) for the worst case, which has the most
chance of encounter of graphs that is vertex indistinguishable but not vertex
symmetric. 
Suppose now we allow graphs with self-loop and multi-edge. First, we remove
all self-loop and multi-edge, and by the algorithm GI(G,G′), we can find an
isomorphism. Then we can check this isomorphism for graphs with self-loop
and multi-edge. Another method is to use the labeling procedure to remove
self-loop and multi-edge before the algorithm for graphs without those.
With the algorithm for isomorphism, we can construct an algorithm for
automorphism without too much effort.
4 Conclusion
In this paper, we provide an algorithm for the graph isomorphism problem.
We have shown that the graph isomorphism problem is based on the recogni-
tion problem of a vertex symmetric graph. Conjecture 2.9 can solve the latter
problem very efficiently. Without this conjecture, our algorithm is of quasi-
polynomial time. It is possible to further improve our algorithm.
Although some techniques in this article might have been already known
before, we apologize for the possibility of not pointing out, for our limited
knowledge. We plan to write a detailed and also interesting review paper to
make it clear and talk all aspects of the graph isomorphism problem, including
the research history and its applications.
Left works: What is the algorithm for directed graphs? Experimental bench-
mark of algorithms for graph isomorphism. Problems relating to the graph iso-
morphism. Properties of collapse tomography and collapse pattern. A more
refined analysis of our algorithm. Find a counter-example to Conjecture 2.9
and other conjectures.
13
References
[1] László Babai. Graph isomorphism in quasipolynomial time [extended ab-
stract]. In Proceedings of the 48th Annual ACM SIGACT Symposium on
Theory of Computing, pages 684–697. ACM, 2016.
[2] Kellog S Booth and Charles J Colbourn. Problems polynomially equivalent
to graph isomorphism. Computer Science Department, Univ., 1979.
[3] Horst Bunke. Graph matching: Theoretical foundations, algorithms, and
applications. In Proc. Vision Interface, volume 2000, pages 82–88, 2000.
[4] Chris Godsil and Gordon Royle. Algebraic graph theory. Springer-Verlag,
2001.
[5] J Köbler, U Schöning, and J Torán. The Graph Isomorphism Problem: Its
Structural Complexity. Birkhaeuser, Boston, MA, 1993.
[6] Johannes Köbler, Uwe Schöning, and Jacobo Torán. The graph isomorphism
problem: its structural complexity. Springer Science & Business Media, 2012.
[7] Rudolf Mathon. A note on the graph isomorphism counting problem. In-
formation Processing Letters, 8(3):131–136, 1979.
[8] Gary L Miller. Graph isomorphism, general remarks. Journal of Computer
and System Sciences, 18(2):128–142, 1979.
14

