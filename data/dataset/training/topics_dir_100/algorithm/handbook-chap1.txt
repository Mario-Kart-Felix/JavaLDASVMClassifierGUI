Handbook of
Computer Vision Algorithms
in Image Algebra
Gerhard X. Ritter
Joseph N. Wilson
Center for Computer Vision and Visualization
University of Florida
Preface
The aim of this book is to acquaint engineers, scientists, and students with the
basic concepts of image algebra and its use in the concise representation of computer
vision algorithms. In order to achieve this goal we provide a brief survey of commonly
used computer vision algorithms that we believe represents a core of knowledge that all
computer vision practitioners should have. This survey is not meant to be an encyclopedic
summary of computer vision techniques as it is impossible to do justice to the scope and
depth of the rapidly expanding field of computer vision.
The arrangement of the book is such that it can serve as a reference for computer
vision algorithm developers in general as well as for algorithm developers using the image
algebra C++ object library, iac++.1 The techniques and algorithms presented in a given
chapter follow a progression of increasing abstractness. Each technique is introduced
by way of a brief discussion of its purpose and methodology. Since the intent of this
text is to train the practitioner in formulating his algorithms and ideas in the succinct
mathematical language provided by image algebra, an effort has been made to provide the
precise mathematical formulation of each methodology. Thus, we suspect that practicing
engineers and scientists will find this presentation somewhat more practical and perhaps a
bit less esoteric than those found in research publications or various textbooks paraphrasing
these publications.
Chapter 1 provides a short introduction to field of image algebra. Chapters
2–11 are devoted to particular techniques commonly used in computer vision algorithm
development, ranging from early processing techniques to such higher level topics as image
descriptors and artificial neural networks. Although the chapters on techniques are most
naturally studied in succession, they are not tightly interdependent and can be studied
according to the reader’s particular interest. In the Appendix we present iac++ computer
programs of some of the techniques surveyed in this book. These programs reflect the
image algebra pseudocode presented in the chapters and serve as examples of how image
algebra pseudocode can be converted into efficient computer programs.
1 The iac++ library supports the use of image algebra in the C++ programming language and is available
for anonymous ftp from ftp://ftp.cis.ufl.edu/pub/src/ia/.
iii
Acknowledgments
We wish to take this opportunity to express our thanks to our current and former
students who have, in various ways, assisted in the preparation of this text. In particular,
we wish to extend our appreciation to Dr. Paul Gader, Dr. Jennifer Davidson, Dr. Hongchi
Shi, Ms. Brigitte Pracht, Mr. Mark Schmalz, Mr. Venugopal Subramaniam, Mr. Mike
Rowlee, Dr. Dong Li, Dr. Huixia Zhu, Ms. Chuanxue Wang, Mr. Jaime Zapata, and
Mr. Liang-Ming Chen. We are most deeply indebted to Dr. David Patching who assisted
in the preparation of the text and contributed to the material by developing examples that
enhanced the algorithmic exposition. Special thanks are due to Mr. Ralph Jackson, who
skillfully implemented many of the algorithms herein, and to Mr. Robert Forsman, the
primary implementor of the iac++ library.
We also want to express our gratitude to the Air Force Wright Laboratory for their
encouragement and continuous support of image algebra research and development. This
book would not have been written without the vision and support provided by numerous
scientists of the Wright Laboratory at Eglin Air Force Base in Florida. These supporters
include Dr. Lawrence Ankeney who started it all, Dr. Sam Lambert who championed the
image algebra project since its inception, Mr. Neil Urquhart our first program manager,
Ms. Karen Norris, and most especially Dr. Patrick Coffield who persuaded us to turn a
technical report on computer vision algorithms in image algebra into this book.
Last but not least we would like to thank Dr. Robert Lyjack of ERIM for his
friendship and enthusiastic support during the formative stages of image algebra.
iv
Notation
The tables presented here provide a brief explantation of the notation used
throughout this document. The reader is referred to Ritter [1] for a comprehensive treatise
covering the mathematics of image algebra.
Logic
Symbol Explanation
" implies ." If is true, then is true.
" if and only if ," which means that and are logically
equivalent.
iff "if and only if"
"not"
"there exists"
"there does not exist"
"for each"
s.t. "such that"
Sets Theoretic Notation and Operations
Symbol Explanation
Uppercase characters represent arbitrary sets.
Lowercase characters represent elements of an arbitrary set.
Bold, uppercase characters are used to represent point sets.
Bold, lowercase characters are used to represent points, i.e.,
elements of point sets.
The set .
The set of integers, positive integers, and negative integers.
The set .
The set .
The set .
The set of real numbers, positive real numbers, negative real
numbers, and positive real numbers including 0.
v
Symbol Explanation
The set of complex numbers.
An arbitrary set of values.
The set unioned with .
The set unioned with .
The set unioned with .
The empty set (the set that has no elements).
The power set of (the set of all subsets of ).
"is an element of"
"is not an element of"
"is a subset of"
Union
Let be a family of sets indexed by an indexing set
.
Intersection
Let be a family of sets indexed by an indexing set
.
Cartesian product
The Cartesian product of copies of , i.e., .
vi
Symbol Explanation
Set difference
Let and be subsets of some universal set ,
.
Complement
, where is the universal set that contains .
The cardinality of the set .
A function that randomly selects an element from the set .
Point and Point Set Operations
Symbol Explanation
If , then
If , then
If , then
If , then
If , then
If , then
In general, if , and
If and and , then
If , then
If , then
If and then
If , then
If , then If , then
If , then
If , then
If , then
If , then
vii
Symbol Explanation
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then
If , then the supremum of . If
then
For a point set with total order ,
If , then the infimum of . If
, then
For a point set with total order ,
If , then
If , then
viii
Morphology
In following table and denote subsets of .
Symbol Explanation
The reflection of across the origin .
The complement of ; i.e., .
Minkowski addition is defined as
. (Section 7.2)
Minkowski subtraction is defined as .
(Section 7.2)
The opening of by is denoted and is defined by
. (Section 7.3)
The closing of by is denoted and is defined by
. (Section 7.3)
Let be an ordered pair of structuring elements.
The hit-and-miss transform of the set is given by
. (Section 7.5)
Functions and Scalar Operations
Symbol Explanation
is a function from into .
The domain of the function is the set .
The range of the function is the set
.
The inverse of the function .
The set of all functions from into , i.e., if , then
.
Given a function and a subset , the
restriction of to , , is defined by
for .
Given and , the extension of to is
defined by
ix
Symbol Explanation
Given two functions and , the
composition is defined by
, for every .
Let and be real or complex-valued functions, then
.
Let and be real or complex-valued functions, then
.
Let be a real or complex-valued function, and be a real
or complex number, then , .
, where is a real (or complex)-valued
function, and denotes the absolute value (or
magnitude) of .
The identity function is given by .
The projection function onto the th coordinate is defined
by .
The cardinality of the set .
A function which randomly selects an element from the set
.
For , is the maximum of and .
For , is the minimun of and .
For the ceiling function returns the smallest
integer that is greater than or equal to .
For the floor function returns the largest integer
that is less than or equal to .
For the round function returns the nearest integer to .
If there are two such integers it yields the integer with
greater magnitude.
For , if there exists with
such that .
The characteristic function is defined by
x
Images and Image Operations
Symbol Explanation
Bold, lowercase characters are used to represent images.
Image variables will usually be chosen from the beginning of
the alphabet.
The image is an -valued image on . The set is called
the value set of and the spatial domain of .
Let be a set with unit . Then denotes an image, all of
whose pixel values are .
Let be a set with zero . Then denotes an image, all of
whose pixel values are .
The domain restriction of to a subset of is
defined by .
The range restriction of to the subset is
defined by . The double-bar notation is
used to focus attention on the fact that the restriction is
applied to the second coordinate of .
If , , and , then the restriction of to
and is defined as .
Let and be subsets of the same topological space. The
extension of to is defined by
Row concatenation of images and , respectively the row
concatenation of images .
Column concatenation of images and .
If and , then the image is
given by , i.e.,
.
If and , the induced image is
defined by .
If is a binary operation on , then an induced operation on
can be defined. Let ; the induced operation is
given by .
xi
Symbol Explanation
Let , , and be a binary operation on . An
induced scalar operation on images is defined by
.
Let ; .
Let
.
Pointwise complex conjugate of image , .
denotes reduction by a generic reduce operation
.
The following four items are specific examples of the global reduce operation. Each
assumes and .
Dot product, .
Complementation of a set-valued image .
Complementation of a Boolean image .
Transpose of image .
xii
Templates and Template Operations
Symbol Explanation
Bold, lowercase characters are used to represent templates.
Usually characters from the middle of the alphabet are used
as template variables.
A template is an image whose pixel values are images. In
particular, an -valued template from to is a function
. Thus, and is an -valued
image on .
Let . For each , . The image
is given by .
If and , then the support of is
denoted by and is defined by
.
If , then .
If , then .
If , then .
A parameterized -valued template from to with
parameters in is a function of the form .
Let . The transpose is defined as
.
Image-Template Operations
In the table below, is a finite subset of .
Symbol Explanation
Let be a semiring and , , then
the generic right product of with is defined as
With the conditions above, except that now , the
generic left product of with is defined as
xiii
Symbol Explanation
Let , , and , where .
The right linear product (or convolution) is defined as
With the conditions above, except that , the left
linear product (or convolution) is defined as
For and , the right additive maximum
is defined by
For and , the left additive maximum is
defined by
For and , the right additive minimum
is defined by
For and , the left additive minimum is
defined by
For and , the right
multiplicative maximum is defined by
For and , the left multiplicative
maximum is defined by
xiv
Symbol Explanation
For and , the right
multiplicative minimum is defined by
For and , the left multiplicative
minimum is defined by
Neighborhoods and Neighborhood Operations
Symbol Explanation
Italic uppercase characters are used to denote neighborhoods.
A neighborhood is an image whose pixel values are sets of
points. In particular, a neighborhood from to is a
function .
A parameterized neighborhood from to with parameters
in is a function of the form .
Let , the transpose is defined as
, that is,
.
The dilation of by is defined by
.
Image-Neighborhood Operations
In the table below, is a finite subset of .
Symbol Explanation
Given and , and reduce operation
, the generic right reduction of with is
defined as .
With the conditions above, except that now , the
generic left reduction of with is defined as
.
xv
Symbol Explanation
Given , and the image average function ,
yielding the average of its image argument,
.
Given , and the image median function ,
yielding the average of its image argument,
.
Matrix and Vector Operations
In the table below, and represent matrices.
Symbol Explanation
The conjugate of matrix .
The transpose of matrix .
, The matrix product of matrices and .
The tensor product of matrices and .
The p-product of matrices and .
The dual p-product of matrices and , defined by
.
References
[1] G. Ritter, “Image algebra with applications.” Unpublished manuscript, available via
anonymous ftp from ftp://ftp.cis.ufl.edu/pub/src/ia/documents,
1994.
xvi
To our brothers,
Friedrich Karl and
Scott Winfield
xvii
xviii
Contents
1 IMAGE ALGEBRA . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2. Point Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
3. Value Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
4. Images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5. Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
6. Recursive Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
7. Neighborhoods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
8. The p-Product . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
9. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2 IMAGE ENHANCEMENT TECHNIQUES . . . . . . . . . . . . 51
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2. Averaging of Multiple Images . . . . . . . . . . . . . . . . . . . . . . . . 51
3. Local Averaging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
4. Variable Local Averaging . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
5. Iterative Conditional Local Averaging . . . . . . . . . . . . . . . . . . . . 54
6. Max-Min Sharpening Transform . . . . . . . . . . . . . . . . . . . . . . . 55
7. Smoothing Binary Images by Association . . . . . . . . . . . . . . . . . . 56
8. Median Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
9. Unsharp Masking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
10. Local Area Contrast Enhancement . . . . . . . . . . . . . . . . . . . . . . 65
11. Histogram Equalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
12. Histogram Modification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
13. Lowpass Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
14. Highpass Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
15. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
3 EDGE DETECTION AND BOUNDARY FINDING
TECHNIQUES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
2. Binary Image Boundaries . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
3. Edge Enhancement by Discrete Differencing . . . . . . . . . . . . . . . . 81
4. Roberts Edge Detector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
5. Prewitt Edge Detector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
6. Sobel Edge Detector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
7. Wallis Logarithmic Edge Detection . . . . . . . . . . . . . . . . . . . . . 89
8. Frei-Chen Edge and Line Detection . . . . . . . . . . . . . . . . . . . . . 90
9. Kirsch Edge Detector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
10. Directional Edge Detection . . . . . . . . . . . . . . . . . . . . . . . . . . 95
11. Product of the Difference of Averages . . . . . . . . . . . . . . . . . . . . 98
xix
12. Crack Edge Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
13. Local Edge Detection in Three-Dimensional Images . . . . . . . . . . 102
14. Hierarchical Edge Detection . . . . . . . . . . . . . . . . . . . . . . . . 104
15. Edge Detection Using K-Forms . . . . . . . . . . . . . . . . . . . . . . 106
16. Hueckel Edge Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
17. Divide-and-Conquer Boundary Detection . . . . . . . . . . . . . . . . . 116
18. Edge Following as Dynamic Programming . . . . . . . . . . . . . . . . 119
19. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
4 THRESHOLDING TECHNIQUES . . . . . . . . . . . . . . . . 125
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
2. Global Thresholding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
3. Semithresholding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
4. Multilevel Thresholding . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
5. Variable Thresholding . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6. Threshold Selection Using Mean and Standard Deviation . . . . . . . . 129
7. Threshold Selection by Maximizing Between-Class Variance . . . . . 131
8. Threshold Selection Using a Simple Image Statistic . . . . . . . . . . . 137
9. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
5 THINNING AND SKELETONIZING . . . . . . . . . . . . . . . 143
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
2. Pavlidis Thinning Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 143
3. Medial Axis Transform (MAT) . . . . . . . . . . . . . . . . . . . . . . . 145
4. Distance Transforms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
5. Zhang-Suen Skeletonizing . . . . . . . . . . . . . . . . . . . . . . . . . . 151
6. Zhang-Suen Transform — Modified to Preserve Homotopy . . . . . . 154
7. Thinning Edge Magnitude Images . . . . . . . . . . . . . . . . . . . . . 156
8. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
6 CONNECTED COMPONENT ALGORITHMS . . . . . . . . . 161
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
2. Component Labeling for Binary Images . . . . . . . . . . . . . . . . . . 161
3. Labeling Components with Sequential Labels . . . . . . . . . . . . . . 164
4. Counting Connected Components by Shrinking . . . . . . . . . . . . . 166
5. Pruning of Connected Components . . . . . . . . . . . . . . . . . . . . 169
6. Hole Filling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
7. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
7 MORPHOLOGICAL TRANSFORMS AND TECHNIQUES . . 173
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
2. Basic Morphological Operations: Boolean Dilations and Erosions . . . 173
3. Opening and Closing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
xx
4. Salt and Pepper Noise Removal . . . . . . . . . . . . . . . . . . . . . . 179
5. The Hit-and-Miss Transform . . . . . . . . . . . . . . . . . . . . . . . . 181
6. Gray Value Dilations, Erosions, Openings, and Closings . . . . . . . . 183
7. The Rolling Ball Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . 185
8. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8 LINEAR IMAGE TRANSFORMS . . . . . . . . . . . . . . . . . 189
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
2. Fourier Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
3. Centering the Fourier Transform . . . . . . . . . . . . . . . . . . . . . . 192
4. Fast Fourier Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
5. Discrete Cosine Transform . . . . . . . . . . . . . . . . . . . . . . . . . 201
6. Walsh Transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
7. The Haar Wavelet Transform . . . . . . . . . . . . . . . . . . . . . . . . 209
8. Daubechies Wavelet Transforms . . . . . . . . . . . . . . . . . . . . . . 217
9. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
9 PATTERN MATCHING AND SHAPE DETECTION . . . . . . 225
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
2. Pattern Matching Using Correlation . . . . . . . . . . . . . . . . . . . . 225
3. Pattern Matching in the Frequency Domain . . . . . . . . . . . . . . . . 229
4. Rotation Invariant Pattern Matching . . . . . . . . . . . . . . . . . . . . 234
5. Rotation and Scale Invariant Pattern Matching . . . . . . . . . . . . . . 237
6. Line Detection Using the Hough Transform . . . . . . . . . . . . . . . 239
7. Detecting Ellipses Using the Hough Transform . . . . . . . . . . . . . 246
8. Generalized Hough Algorithm for Shape Detection . . . . . . . . . . . 251
9. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
10 IMAGE FEATURES AND DESCRIPTORS . . . . . . . . . . . 257
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
2. Area and Perimeter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
3. Euler Number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
4. Chain Code Extraction and Correlation . . . . . . . . . . . . . . . . . . 260
5. Region Adjacency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
6. Inclusion Relation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
7. Quadtree Extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
8. Position, Orientation, and Symmetry . . . . . . . . . . . . . . . . . . . . 274
9. Region Description Using Moments . . . . . . . . . . . . . . . . . . . . 276
10. Histogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
11. Cumulative Histogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
12. Texture Descriptors: Gray Level Spatial Dependence Statistics . . . . 281
13. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
xxi
11 NEURAL NETWORKS AND CELLULAR AUTOMATA . . . 289
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
2. Hopfield Neural Network . . . . . . . . . . . . . . . . . . . . . . . . . . 290
3. Bidirectional Associative Memory (BAM) . . . . . . . . . . . . . . . . 296
4. Hamming Net . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
5. Single-Layer Perceptron (SLP) . . . . . . . . . . . . . . . . . . . . . . . 305
6. Multilayer Perceptron (MLP) . . . . . . . . . . . . . . . . . . . . . . . . 308
7. Cellular Automata and Life . . . . . . . . . . . . . . . . . . . . . . . . . 315
8. Solving Mazes Using Cellular Automata . . . . . . . . . . . . . . . . . 316
9. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
APPENDIX THE IMAGE ALGEBRA C++ LIBRARY . . . . . . . . 321
INDEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356
xxii
CHAPTER 1
IMAGE ALGEBRA
1.1. Introduction
Since the field of image algebra is a recent development it will be instructive to
provide some background information. In the broad sense, image algebra is a mathematical
theory concerned with the transformation and analysis of images. Although much emphasis
is focused on the analysis and transformation of digital images, the main goal is the
establishment of a comprehensive and unifying theory of image transformations, image
analysis, and image understanding in the discrete as well as the continuous domain [1].
The idea of establishing a unifying theory for the various concepts and opera-
tions encountered in image and signal processing is not new. Over thirty years ago, Unger
proposed that many algorithms for image processing and image analysis could be imple-
mented in parallel using cellular array computers [2]. These cellular array computers were
inspired by the work of von Neumann in the 1950s [3, 4]. Realization of von Neumann’s
cellular array machines was made possible with the advent of VLSI technology. NASA’s
massively parallel processor or MPP and the CLIP series of computers developed by Duff
and his colleagues represent the classic embodiment of von Neumann’s original automaton
[5, 6, 7, 8, 9]. A more general class of cellular array computers are pyramids and Thinking
Machines Corporation’s Connection Machines [10, 11, 12]. In an abstract sense, the vari-
ous versions of Connection Machines are universal cellular automatons with an additional
mechanism added for non-local communication.
Many operations performed by these cellular array machines can be expressed in
terms of simple elementary operations. These elementary operations create a mathematical
basis for the theoretical formalism capable of expressing a large number of algorithms
for image processing and analysis. In fact, a common thread among designers of parallel
image processing architectures is the belief that large classes of image transformations can
be described by a small set of standard rules that induce these architectures. This belief
led to the creation of mathematical formalisms that were used to aid in the design of
special-purpose parallel architectures. Matheron and Serra’s Texture Analyzer [13] ERIM’s
(Environmental Research Institute of Michigan) Cytocomputer [14, 15, 16], and Martin
Marietta’s GAPP [17, 18, 19] are examples of this approach.
The formalism associated with these cellular architectures is that of pixel neigh-
borhood arithmetic and mathematical morphology. Mathematical morphology is the part of
image processing concerned with image filtering and analysis by structuring elements. It
grew out of the early work of Minkowski and Hadwiger [20, 21, 22], and entered the mod-
ern era through the work of Matheron and Serra of the Ecole des Mines in Fontainebleau,
France [23, 24, 25, 26]. Matheron and Serra not only formulated the modern concepts
of morphological image transformations, but also designed and built the Texture Analyzer
System. Since those early days, morphological operations have been applied from low-
level, to intermediate, to high-level vision problems. Among some recent research papers
on morphological image processing are Crimmins and Brown [27], Haralick et al. [28, 29],
Maragos and Schafer [30, 31, 32], Davidson [33, 34], Dougherty [35], Goutsias [36, 37],
and Koskinen and Astola [38].
Serra and Sternberg were the first to unify morphological concepts and methods
into a coherent algebraic theory specifically designed for image processing and image
1
2 CHAPTER 1. IMAGE ALGEBRA
analysis. Sternberg was also the first to use the term “image algebra” [39, 40]. In the
mid 1980s, Maragos introduced a new theory unifying a large class of linear and nonlinear
systems under the theory of mathematical morphology [41]. More recently, Davidson
completed the mathematical foundation of mathematical morphology by formulating its
embedding into the lattice algebra known as Mini-Max algebra [42, 43]. However,
despite these profound accomplishments, morphological methods have some well-known
limitations. For example, such fairly common image processing techniques as feature
extraction based on convolution, Fourier-like transformations, chain coding, histogram
equalization transforms, image rotation, and image registration and rectification are — with
the exception of a few simple cases — either extremely difficult or impossible to express in
terms of morphological operations. The failure of a morphologically based image algebra to
express a fairly straightforward U.S. government-furnished FLIR (forward-looking infrared)
algorithm was demonstrated by Miller of Perkin-Elmer [44].
The failure of an image algebra based solely on morphological operations to
provide a universal image processing algebra is due to its set-theoretic formulation, which
rests on the Minkowski addition and subtraction of sets [22]. These operations ignore
the linear domain, transformations between different domains (spaces of different sizes and
dimensionality), and transformations between different value sets (algebraic structures), e.g.,
sets consisting of real, complex, or vector valued numbers. The image algebra discussed
in this text includes these concepts and extends the morphological operations [1].
The development of image algebra grew out of a need, by the U.S. Air Force
Systems Command, for a common image-processing language. Defense contractors do
not use a standardized, mathematically rigorous and efficient structure that is specifically
designed for image manipulation. Documentation by contractors of algorithms for image
processing and rationale underlying algorithm design is often accomplished via word de-
scription or analogies that are extremely cumbersome and often ambiguous. The result of
these ad hoc approaches has been a proliferation of nonstandard notation and increased
research and development cost. In response to this chaotic situation, the Air Force Arma-
ment Laboratory (AFATL — now known as Wright Laboratory MNGA) of the Air Force
Systems Command, in conjunction with the Defense Advanced Research Project Agency
(DARPA — now known as the Advanced Research Project Agency or ARPA), supported
the early development of image algebra with the intent that the fully developed structure
would subsequently form the basis of a common image-processing language. The goal of
AFATL was the development of a complete, unified algebraic structure that provides a com-
mon mathematical environment for image-processing algorithm development, optimization,
comparison, coding, and performance evaluation. The development of this structure proved
highly successful, capable of fulfilling the tasks set forth by the government, and is now
commonly known as image algebra.
Because of the goals set by the government, the theory of image algebra provides
for a language which, if properly implemented as a standard image processing environment,
can greatly reduce research and development costs. Since the foundation of this language is
purely mathematical and independent of any future computer architecture or language, the
longevity of an image algebra standard is assured. Furthermore, savings due to commonality
of language and increased productivity could dwarf any reasonable initial investment for
adapting image algebra as a standard environment for image processing.
Although commonality of language and cost savings are two major reasons
for considering image algebra as a standard language for image processing, there exists
a multitude of other reasons for desiring the broad acceptance of image algebra as a
component of all image processing development systems. Premier among these is the
predictable influence of an image algebra standard on future image processing technology.
1. 1 Introduction 3
In this, it can be compared to the influence on scientific reasoning and the advancement
of science due to the replacement of the myriad of different number systems (e.g., Roman,
Syrian, Hebrew, Egyptian, Chinese, etc.) by the now common Indo-Arabic notation.
Additional benefits provided by the use of image algebra are
• The elemental image algebra operations are small in number, translucent,
simple, and provide a method of transforming images that is easily learned and
used;
• Image algebra operations and operands provide the capability of expressing
all image-to-image transformations;
• Theorems governing image algebra make computer programs based on image
algebra notation amenable to both machine dependent and machine independent
optimization techniques;
• The algebraic notation provides a deeper understanding of image manipula-
tion operations due to conciseness and brevity of code and is capable of suggesting
new techniques;
• The notational adaptability to programming languages allows the substitution
of extremely short and concise image algebra expressions for equivalent blocks
of code, and therefore increases programmer productivity;
• Image algebra provides a rich mathematical structure that can be exploited
to relate image processing problems to other mathematical areas;
• Without image algebra, a programmer will never benefit from the bridge
that exists between an image algebra programming language and the multitude of
mathematical structures, theorems, and identities that are related to image algebra;
• There is no competing notation that adequately provides all these benefits.
The role of image algebra in computer vision and image processing tasks and
theory should not be confused with the government’s Ada programming language effort.
The goal of the development of the Ada programming language was to provide a single high-
order language in which to implement embedded systems. The special architectures being
developed nowadays for image processing applications are not often capable of directly
executing Ada language programs, often due to support of parallel processing models not
accommodated by Ada’s tasking mechanism. Hence, most applications designed for such
processors are still written in special assembly or microcode languages. Image algebra,
on the other hand, provides a level of specification, directly derived from the underlying
mathematics on which image processing is based and that is compatible with both sequential
and parallel architectures.
Enthusiasm for image algebra must be tempered by the knowledge that image
algebra, like any other field of mathematics, will never be a finished product but remain
a continuously evolving mathematical theory concerned with the unification of image
processing and computer vision tasks. Much of the mathematics associated with image
algebra and its implication to computer vision remains largely unchartered territory which
awaits discovery. For example, very little work has been done in relating image algebra
to computer vision techniques which employ tools from such diverse areas as knowledge
representation, graph theory, and surface representation.
4 CHAPTER 1. IMAGE ALGEBRA
Several image algebra programming languages have been developed. These
include image algebra Fortran (IAF) [45], an image algebra Ada (IAA) translator [46],
image algebra Connection Machine *Lisp [47, 48], an image algebra language (IAL)
implementation on transputers [49, 50], and an image algebra C++ class library (iac++)
[51, 52]. Unfortunately, there is often a tendency among engineers to confuse or equate
these languages with image algebra. An image algebra programming language is not
image algebra, which is a mathematical theory. An image algebra-based programming
language typically implements a particular subalgebra of the full image algebra. In addition,
simplistic implementations can result in poor computational performance. Restrictions and
limitations in implementation are usually due to a combination of factors, the most pertinent
being development costs and hardware and software environment constraints. They are not
limitations of image algebra, and they should not be confused with the capability of image
algebra as a mathematical tool for image manipulation.
Image algebra is a heterogeneous or many-valued algebra in the sense of Birkhoff
and Lipson [53, 1], with multiple sets of operands and operators. Manipulation of images
for purposes of image enhancement, analysis, and understanding involves operations not
only on images, but also on different types of values and quantities associated with these
images. Thus, the basic operands of image algebra are images and the values and quantities
associated with these images. Roughly speaking, an image consists of two things, a
collection of points and a set of values associated with these points. Images are therefore
endowed with two types of information, namely the spatial relationship of the points, and
also some type of numeric or other descriptive information associated with these points.
Consequently, the field of image algebra bridges two broad mathematical areas, the theory
of point sets and the algebra of value sets, and investigates their interrelationship. In the
sections that follow we discuss point and value sets as well as images, templates, and
neighborhoods that characterize some of their interrelationships.
1.2. Point Sets
A point set is simply a topological space. Thus, a point set consists of two
things, a collection of objects called points and a topology which provides for such notions
as nearness of two points, the connectivity of a subset of the point set, the neighborhood of
a point, boundary points, and curves and arcs. Point sets will be denoted by capital bold
letters from the end of the alphabet, i.e., W, X, Y, and Z.
Points (elements of point sets) will be denoted by lower case bold letters from
the end of the alphabet, namely . Note also that if , then x is of form
, where for each , denotes a real number called
the ith coordinate of x.
The most common point sets occurring in image processing are discrete subsets of
n–dimensional Euclidean space with or 3 together with the discrete topology.
However, other topologies such as the von Neumann topology and the product topology are
also commonly used topologies in computer vision [1].
There is no restriction on the shape of the discrete subsets of used
in applications of image algebra to solve vision problems. Point sets can assume
arbitrary shapes. In particular, shapes can be rectangular, circular, or snake-like.
Some of the more pertinent point sets are the set of integer points (here we view
), the n–dimensional lattice (i.e.,
) with or , and
rectangular subsets of . Two of the most often encountered rectangular point sets are
1. 2 Point Sets 5
of form
or
We follow standard practice and represent these rectangular point sets by listing the points in
matrix form. Figure 1.2.1 provides a graphical representation of the point set .
... ...
... ...
... ...
...
...
...
...
...
...
x 
y
1
2
m
1 2 n
Figure 1.2.1. The rectangular point set
Point Operations
As mentioned, some of the more pertinent point sets are discrete subsets of the
vector space . These point sets inherit the usual elementary vector space operations.
Thus, for example, if (or ) and
, then the sum of the points x and y is defined as
while the multiplication and addition of a scalar (or ) and a point x is given by
and
respectively. Point subtraction is also defined in the usual way.
In addition to these standard vector space operations, image algebra also incorpo-
rates three basic types of point multiplication. These are the Hadamard product, the cross
product (or vector product) for points in (or ), and the dot product which are defined by
and
respectively.
6 CHAPTER 1. IMAGE ALGEBRA
Note that the sum of two points, the Hadamard product, and the cross product are
binary operations that take as input two points and produce another point. Therefore these
operations can be viewed as mappings whenever X is closed under these
operations. In contrast, the binary operation of dot product is a scalar and not another vector.
This provides an example of a mapping , where denotes the appropriate field
of scalars. Another such mapping, associated with metric spaces, is the distance function
which assigns to each pair of points x and y the distance from x to y. The
most common distance functions occurring in image processing are the Euclidean distance,
the city block or diamond distance, and the chessboard distance which are defined by
and
respectively.
Distances can be conveniently computed in terms of the norm of a point. The
three norms of interest here are derived from the standard norms
The norm is given by
where . Specifically, the Euclidean norm is given by
. Thus, . Similarly, the city block distance
can be computed using the formulation and the chessboard distance
by using
Note that the p-norm of a point x is a unary operation, namely a function
. Another assemblage of functions which play a major role in
various applications are the projection functions. Given , then the ith projection on
X, where , is denoted by and defined by , where denotes
the ith coordinate of x.
Characteristic functions and neighborhood functions are two of the most fre-
quently occurring unary operations in image processing. In order to define these opera-
tions, we need to recall the notion of a power set of a set. The power set of a set S is
defined as the set of all subsets of S and is denoted by . Thus, if Z is a point set, then
.
Given (i.e., ), then the characteristic function associated with
X is the function
1. 2 Point Sets 7
defined by
For a pair of point sets X and Z, a neighborhood system for X in Z, or equivalently,
a neighborhood function from X to Z, is a function
It follows that for each point , . The set is called a neighborhood
for x.
There are two neighborhood functions on subsets of which are of particular
importance in image processing. These are the von Neumann neighborhood and the Moore
neighborhood. The von Neumann neighborhood  is defined by
where , while the Moore neighborhood  is defined by
Figure 1.2.2 provides a pictorial representation of these two neighborhood functions; the
hashed center area represents the point x and the adjacent cells represent the adjacent points.
The von Neumann and Moore neighborhoods are also called the four neighborhood and
eight neighborhood, respectively. They are local neighborhoods since they only include
the directly adjacent points of a given point.
N

(x)  = M(x)  =
Figure 1.2.2. The von Neumann neighborhood
and the Moore neighborhood of a point x.
There are many other point operations that are useful in expressing computer
vision algorithms in succinct algebraic form. For instance, in certain interpolation schemes
it becomes necessary to switch from points with real-valued coordinates (floating point
coordinates) to corresponding integer-valued coordinate points. One such method uses the
induced floor operation defined by , where
and denotes the largest integer less than or equal to
(i.e., and if with , then ).
Summary of Point Operations
We summarize some of the more pertinent point operations. Some image algebra
implementations such as iac++ provide many additional point operations [54].
8 CHAPTER 1. IMAGE ALGEBRA
Binary operations. Let , and
.
addition
subtraction
multiplication
division
supremum
infimum
dot product
cross product
concatenation
scalar operations
where
Unary operations. In the following let .
negation
ceiling
floor
rounding
projection
sum
product
maximum
minimum
Euclidean norm
norm
norm
dimension
neighborhood
characteristic function
It is important to note that several of the above unary operations are special
instances of spatial transformations . Spatial transforms play a vital role in many
image processing and computer vision tasks.
In the above summary we only considered points with real- or integer-valued
coordinates. Points of other spaces have their own induced operations. For example,
typical operations on points of (i.e., Boolean-valued points) are the usual
logical operations of , , , and complementation.
Point Set Operations
Point arithmetic leads in a natural way to the notion of set arithmetic. Given a
vector space Z, then for (i.e., ) and an arbitrary point we
define the following arithmetic operations:
addition
subtraction
point addition
point subtraction
1. 2 Point Sets 9
Another set of operations on are the usual set operations of union, intersection,
set difference (or relative complement), symmetric difference, and Cartesian product as
defined below.
union
intersection
set difference
symmetric difference
Cartesian product
Note that with the exception of the Cartesian product, the set obtained for each of the
above operations is again an element of .
Another common set theoretic operation is set complementation. For ,
the complement of X is denoted by , and defined as .
In contrast to the binary set operations defined above, set complementation is a unary
operation. However, complementation can be computed in terms of the binary operation
of set difference by observing that .
In addition to complementation there are various other common unary operations
which play a major role in algorithm development using image algebra. Among these is the
cardinality of a set which, when applied to a finite point set, yields the number of elements
in the set, and the choice function which, when applied to a set, selects a randomly chosen
point from the set. The cardinality of a set X will be denoted by card(X). Note that
while
That is, and , where x is some randomly chosen element of X.
As was the case for operations on points, algebraic operations on point sets are
too numerous to discuss at length in a short treatise as this. Therefore, we again only
summarize some of the more frequently occurring unary operations.
Summary of Unary Point Set Operations
In the following .
negation
complementation
supremum
infimum
choice function
cardinality
The interpretation of is as follows. Suppose X is finite, say
. Then ,
where denotes the binary operation of the supremum of two points de-
fined earlier. Equivalently, if for , then
. More generally, is defined to be the
least upper bound of X (if it exists). The infimum of X is interpreted in a similar fashion.
If X is finite and has a total order, then we also define the maximum and minimum
of X, denoted by and , respectively, as follows. Suppose
and , where the symbol denotes the particular total order on X.
10 CHAPTER 1. IMAGE ALGEBRA
Then and . The most commonly used order for a subset X of
is the row scanning order. Note also that in contrast to the supremum or infimum, the
maximum and minimum of a (finite totally ordered) set is always a member of the set.
1.3. Value Sets
A heterogeneous algebra is a collection of nonempty sets of possibly different
types of elements together with a set of finitary operations which provide the rules of
combining various elements in order to form a new element. For a precise definition of a
heterogeneous algebra we refer the reader to Ritter [1]. Note that the collection of point
sets, points, and scalars together with the operations described in the previous section form
a heterogeneous algebra.
A homogeneous algebra is a heterogeneous algebra with only one set of operands.
In other words, a homogeneous algebra is simply a set together with a finite number of
operations. Homogeneous algebras will be referred to as value sets and will be denoted
by capital blackboard font letters, e.g., , and . There are several value sets that
occur more often than others in digital image processing. These are the set of integers, real
numbers (floating point numbers), the complex numbers, binary numbers of fixed length k,
the extended real numbers (which include the symbols and/or ), and the extended
non–negative real numbers. We denote these sets by , ,
, , and , respectively,
where the symbol denotes the set of positive real numbers.
Operations on Value Sets
The operations on and between elements of a given value set are the usual
elementary operations associated with . Thus, if , then the binary
operations are the usual arithmetic and logic operations of addition, multiplication, and
maximum, and the complementary operations of subtraction, division, and minimum. If
, then the binary operations are addition, subtraction, multiplication, and division.
Similarly, we allow the usual elementary unary operations associated with these sets such
as the absolute value, conjugation, as well as trigonometric, logarithmic and exponential
functions as these are available in all higher-level scientific programming languages.
For the set we need to extend the arithmetic and logic operations of as
follows:
Note that the element acts as a null element in the system if we
view the operation + as multiplication and the operation as addition. The same cannot be
said about the element in the system since .
In order to remedy this situation we define the dual structure of
as follows:
1. 3 Value Sets 11
Now the element acts as a null element in the system Observe, however,
that the dual additions and introduce an asymmetry between and The
resultant structure is known as a bounded lattice ordered group [1].
Dual structures provide for the notion of dual elements. For each we
define its dual or conjugate by , where . The following duality
laws are a direct consequence of this definition: 
  
and
  
.
Closely related to the additive bounded lattice ordered group described above is
the multiplicative bounded lattice ordered group . Here the dual of
ordinary multiplication is defined as
with both multiplicative operations extended as follows:
Hence, the element 0 acts as a null element in the system and the element
acts as a null element in the system . The conjugate of an element
of this value set is defined by
if
if
if
Another algebraic structure with duality which is of interest in image algebra is the
value set , where .
The logical operations and are the usual binary operations of max (or) and min (and),
respectively, while the dual additive operations and are defined by the tables shown
in Figure 1.3.1.
0 1 0 1
0 1 0 0 1 0
1 0 1 1 0 1
Figure 1.3.1. The dual additive operations and .
Note that the addition (as well as ) restricted to is the exclusive
or operation xor and computes the values for the truth table of the biconditional statement
(i.e., p if and only if q).
12 CHAPTER 1. IMAGE ALGEBRA
The operations on the value set can be easily generalized to its k-fold Cartesian
product . Specifically, if
and , where for , then
.
The addition should not be confused with the usual addition on .
In fact, for , where
Many point sets are also value sets. For example, the point set is a
metric space as well as a vector space with the usual operation of vector addition. Thus,
, where the symbol “ ” denotes vector addition, will at various times be used both
as a point set and as a value set. Confusion as to usage will not arise as usage should be
clear from the discussion.
Summary of Pertinent Numeric Value Sets
In order to focus attention on the value sets most often used in this treatise we
provide a listing of their algebraic structures:
(a)
(b)
(c)
(d)
(e)
(f)
(g)
In contrast to structure c, the addition and multiplication in structure d is addition
and multiplication .
These listed structures represent the pertinent global structures. In various ap-
plications only certain subalgebras of these algebras are used. For example, the subalge-
bras and of play special roles in mor-
phological processing. Similarly, the subalgebra of , where
, is the only pertinent applicable algebra in certain cases.
The complementary binary operations, whenever they exist, are assumed to be
part of the structures. Thus, for example, subtraction and division which can be defined in
terms of addition and multiplication, respectively, are assumed to be part of .
Value Set Operators
As for point sets, given a value set , the operations on 	 are again the usual
operations of union, intersection, set difference, etc. If, in addition, is a lattice, then
the operations of infimum and supremum are also included. A brief summary of value set
operators is given below.
1. 4 Images 13
For the following operations assume that 
 for some value set .
union
intersection
set difference
symmetric difference
Cartesian product
choice function
cardinality
supremum
infimum
1.4. Images
The primary operands in image algebra are images, templates, and neighborhoods.
Of these three classes of operands, images are the most fundamental since templates and
neighborhoods can be viewed as special cases of the general concept of an image. In order to
provide a mathematically rigorous definition of an image that covers the plethora of objects
called an “image” in signal processing and image understanding, we define an image in
general terms, with a minimum of specification. In the following we use the notation to
denote the set of all functions (i.e., ).
Definition: Let be a value set and X a point set. An -valued image
on X is any element of  . Given an –valued image  (i.e.,
), then is called the set of possible range values of a and
X the spatial domain of a.
It is often convenient to let the graph of an image represent a. The graph
of an image is also referred to as the data structure representation of the image. Given
the data structure representation , then an element of
the data structure is called a picture element or pixel. The first coordinate x of a pixel is
called the pixel location or image point, and the second coordinate a(x) is called the pixel
value of a at location x.
The above definition of an image covers all mathematical images on topological
spaces with range in an algebraic system. Requiring X to be a topological space provides
us with the notion of nearness of pixels. Since X is not directly specified we may substitute
any space required for the analysis of an image or imposed by a particular sensor and scene.
For example, X could be a subset of with of form , where
the first coordinates denote spatial location and t a time variable.
Similarly, replacing the unspecified value set with or
provides us with digital integer-valued and digital vector-valued images, respectively. An
implication of these observations is that our image definition also characterizes any type
of discrete or continuous physical image.
Induced Operations on Images
Operations on and between -valued images are the natural induced operations
of the algebraic system . For example, if is a binary operation on , then induces a
binary operation — again denoted by — on defined as follows:
14 CHAPTER 1. IMAGE ALGEBRA
Let . Then
For example, suppose and our value set is the algebraic structure of the real
numbers . Replacing by the binary operations , and we obtain
the basic binary operations
and
on real-valued images. Obviously, all four operations are commutative and associative.
In addition to the binary operation between images, the binary operation on
also induces the following scalar operations on images:
For ,
and
Thus, for , we obtain the following scalar multiplication and addition of real-valued
images:
and
It follows from the commutativity of real numbers that,
Although much of image processing is accomplished using real-, integer-, binary-,
or complex-valued images, many higher-level vision tasks require manipulation of vector
and set-valued images. A set-valued image is of form  . Here the underlying
value set is  , where the tilde symbol denotes complementation. Hence, the
operations on set-valued images are those induced by the Boolean algebra of the value set.
For example, if  , then
and
where .
1. 4 Images 15
The operation of complementation is, of course, a unary operation. A particularly
useful unary operation on images which is induced by a binary operation on a value set
is known as the global reduce operation. More precisely, if is an associative and
commutative binary operation on and X is finite, say , then
induces a unary operation
called the global reduce operation induced by , which is defined as
Thus, for example, if and is the operation of addition ( ), then and
In all, the value set provides for four basic global reduce operations, namely
, and .
Induced Unary Operations and Functional Composition
In the previous section we discussed unary operations on elements of induced
by a binary operation on . Typically, however, unary image operations are induced
directly by unary operations on . Given a unary operation , then the induced
unary operation is again denoted by f and is defined by
Note that in this definition we view the composition as a unary operation on
with operand a. This subtle distinction has the important consequence that f is viewed as
a unary operation — namely a function from to — and a as an argument of f.
For example, substituting for and the sine function for f, we obtain the
induced operation , where
As another example, consider the characteristic function
Then for any , is the Boolean (two-valued) image on X with value 1 at
location x if and value 0 if . An obvious application of this operation
is the thresholding of an image. Given a floating point image a and using the characteristic
function
then the image b in the image algebra expression
16 CHAPTER 1. IMAGE ALGEBRA
is given by
The unary operations on an image discussed thus far have resulted either
in a scalar (an element of ) by use of the global reduction operation, or another -valued
image by use of the composition . More generally, given a function ,
then the composition provides for a unary operation which changes an -valued image
into a -valued image . Taking the same viewpoint, but using a function f between
spatial domains instead, provides a scheme for realizing naturally induced operations for
spatial manipulation of image data. In particular, if and , then we
define the induced image by
Thus, the operation defined by the above equation transforms an -valued image defined
over the space X into an -valued image defined over the space Y.
Examples of spatial based image transformations are affine and perspective trans-
forms. For instance, suppose , where is a rectangular array. If
and is defined as
then is a one sided reflection of a across the line . Further examples are provided
by several of the algorithms presented in this text.
Simple shifts of an image can be achieved by using either a spatial transformation
or point addition. In particular, given , , and , we define a shift
of a by y as
Note that is an image on since , which provides
for the equivalent formulation
Of course, one could just as well define a spatial transformation by
in order to obtain the identical shifted image .
Another simple unary image operation that can be defined in terms of a spatial
map is image transposition. Given an image   , then the transpose of a, denoted
by , is defined as where is given by .
Binary Operations Induced by Unary Operations
Various unary operations image operations induced by functions
can be generalized to binary operations on . As a simple illustration, consider the
exponentiation function defined by , where k denotes some non-
negative real number. Then f induces the exponentiation operation
1. 4 Images 17
where a is a non-negative real-valued image on X. We may extend this operation to a binary
image operation as follows: if , then
The notion of exponentiation can be extended to negative valued images as long
as we follow the rules of arithmetic and restrict this binary operation to those pairs of
real-valued images for which . This avoids creation of complex,
undefined, and indeterminate pixel values such as , respectively.
However, there is one exception to these rules of standard arithmetic. The algebra of
images provides for the existence of pseudo inverses. For , the pseudo inverse of
a, which for reason of simplicity is denoted by is defined as
Note that if some pixel values of a are zero, then , where 1 denotes unit image
all of whose pixel values are 1. However, the equality always holds. Hence
the name “pseudo inverse.”
The inverse of exponentiation is defined in the usual way by taking logarithms.
Specifically,
As for real numbers, is defined only for positive images; i.e., .
Another set of examples of binary operations induced by unary operations are the
characteristic functions for comparing two images. For we define
Functional Specification of Image Operations
The basic concepts of elementary function theory provide the underlying founda-
tion of a functional specification of image processing techniques. This is a direct conse-
quence of viewing images as functions. The most elementary concepts of function theory
are the notions of domain, range, restriction, and extension of a function.
Image restrictions and extensions are used to restrict images to regions of par-
ticular interest and to embed images into larger images, respectively. Employing standard
mathematical notation, the restriction of to a subset Z of X is denoted by ,
and defined by
Thus, . In practice, the user may specify Z explicitly by providing bounds for
the coordinates of the points of Z.
18 CHAPTER 1. IMAGE ALGEBRA
There is nothing magical about restricting a to a subset Z of its domain X. We
can just as well define restrictions of images to subsets of the range values. Specifically, if
and , then the restriction of a to S is denoted by and defined as
In terms of the pixel representation of we have . The
double-bar notation is used to focus attention on the fact that the restriction is applied to
the second coordinate of .
Image restrictions in terms of subsets of the value set is an extremely useful
concept in computer vision as many image processing tasks are restricted to image domains
over which the image values satisfy certain properties. Of course, one can always
write this type of restriction in terms of a first coordinate restriction by setting
so that . However, writing a program statement such
as is of little value since Z is implicitly specified in terms of S; i.e., Z
must be determined in terms of the property “ .” Thus, Z would have to be
precomputed, adding to the computational overhead as well as increased code. In contrast,
direct restriction of the second coordinate values to an explicitly specified set S avoids these
problems and provides for easier implementation.
As mentioned, restrictions to the range set provide a useful tool for expressing
various algorithmic procedures. For instance, if and S is the interval ,
where k denotes some given threshold value, then denotes the image a restricted
to all those points of X where a(x) exceeds the value k. In order to reduce notation, we
define . Similarly,
As in the case of characteristic functions, a more general form of range restriction
is given when S corresponds to a set-valued image  ; i.e., .
In this case we define
For example, for we define
Combining the concepts of first and second coordinate (domain and range)
restrictions provides the general definition of an image restriction. If , , and
, then the restriction of a to Z and S is defined as
It follows that , , and
 .
The extension of to on Y, where X and Y are subsets of the
same topological space, is denoted by and defined by
In actual practice, the user will have to specify the function b.
1. 4 Images 19
Two of the most important concepts associated with a function are its domain
and range. In the field of image understanding, it is convenient to view these concepts as
functions that map images to sets associated with certain image properties. Specifically,
we view the concept of range as a function

defined by .
Similarly, the concept of domain is viewed as the function

where  
and domain is defined by
These mapping can be used to extract point sets and value sets from regions of
images of particular interest. For example, the statement
yields the set of all points (pixel locations) where a(x) exceeds k, namely
. The statement
on the other hand, results in a subset of instead of X.
Closely related to spatial transformations and functional composition is the notion
of image concatenation. Concatenation serves as a tool for simplifying algorithm code,
adding translucency to code, and to provide a link to the usual block notion used in matrix
algebra. Given   and   , then the row-order concatenation of a with
b is denoted by and is defined as
Note that   .
Assuming the correct dimensionality in the first coordinate, concatenation of any
number of images is defined inductively using the formula so that
in general we have
Column-order concatenation can be defined in a similar manner or by simple transposition;
i.e.,
...
20 CHAPTER 1. IMAGE ALGEBRA
Multi-Valued Image Operations
Although general image operations described in the previous sections apply to
both single and multi-valued images as long as there is no specific value type associated
with the generic value set , there exist a large number of multi-valued image operations
that are quite distinct from single-valued image operations. As the general theory of multi-
valued image operations is beyond the scope of this treatise, we shall restrict our attention
to some specific operations on vector-valued images while referring the reader interested
in more intricate details to Ritter [1]. However, it is important to realize that vector-valued
images are a special cases of multi-valued images.
If and , then a(x) is a vector of form
where for each , . Thus, an image is of form
and with each vector value a(x) there are associated n real values .
Real-valued image operations generalize to the usual vector operations on .
In particular, if , then
If , then we also have
etc. In the special case where , we simply use the scalar and define
, and so on.
As before, binary operations on multi-valued images are induced by the corre-
sponding binary operation on the value set . It turns out to be useful
to generalize this concept by replacing the binary operation by a sequence of binary
operations , where , and defining
For example, if is defined by
then for and , the components of have
values
for .
As another example, suppose and are two binary operations
defined by
and
1. 4 Images 21
respectively. Now if represent two complex-valued images, then the
product represents pointwise complex multiplication, namely
Basic operations on single and multi-valued images can be combined to form
image processing operations of arbitrary complexity. Two such operations that have proven
to be extremely useful in processing real vector-valued images are the winner take all jth-
coordinate maximum and minimum of two images. Specifically, if , then the
jth-coordinate maximum of a and b is defined as
while the jth-coordinate minimum is defined as
Unary operations on vector-valued images are defined in a similar componentwise
fashion. Given a function , then f induces a function , again denoted
by f, which is defined by
These functions provide for one type of unary operations on vector-valued images. In
particular, if , then
Thus, if , then
Similarly, if , then
Any function gives rise to a sequence of functions
, where . Conversely, given a sequence of functions ,
where , then we can define a function by
where . Such functions provide for a more complex type of unary
image operations since by definition
which means that the construction of each new coordinate depends on all the original
coordinates. To provide a specific example, define by
and by . Then the induced function
22 CHAPTER 1. IMAGE ALGEBRA
given by . Applying f to an image results
in the image
Thus, if we represent complex numbers as points in and a denotes a complex-valued
image, then is a pointwise application of the complex sine function.
Global reduce operations are also applied componentwise. For example, if
, and , then
In contrast, the summation since each . Note that the
projection function is a unary operation .
Similarly,
and
Summary of Image Operations
The lists below summarize some of the more significant image operations.
Binary image operations.
It is assumed that only appropriately valued images are employed for the opera-
tions listed below. Thus, for the operations of maximum and minimum apply to real- or
integer-valued images but not complex-valued images. Similarly, union and intersection
apply only to set-valued images.
generic
addition
multiplication
maximum
minimum
scalar addition
scalar multiplication
point addition
union
intersection
exponentiation
logarithm
1. 5 Templates 23
concatenation    
concatenation
characteristics
Whenever b is a constant image, say (i.e., ), then we
simply write for and for . Similarly, we have , , , etc.
Unary image operations.
As in the case of binary operations, we again assume that only appropriately
valued images are employed for the operations listed below.
value transform
spatial transform
domain restriction
range restriction
extension
domain
range
generic reduction
image sum
image product
image maximum
image minimum
image complement
pseudo inverse
image transpose
1.5. Templates
Templates are images whose values are images. The notion of a template, as used
in image algebra, unifies and generalizes the usual concepts of templates, masks, windows,
and neighborhood functions into one general mathematical entity. In addition, templates
generalize the notion of structuring elements as used in mathematical morphology [26, 55].
24 CHAPTER 1. IMAGE ALGEBRA
Definition. A template is an image whose pixel values are images
(functions). In particular, an -valued template from Y to X is a function
. Thus,
 
and t is an

-valued image on Y.
For notational convenience we define  . The image 
has representation
 
The pixel values  of this image are called the weights of the template
at point y.
If t is a real- or complex-valued template from Y to X, then the support of
is denoted by and is defined as
More generally, if and is an algebraic structure with a zero element 0, then
the support of will be defined as .
For extended real-valued templates we also define the following supports at
infinity:
and
If X is a space with an operation such that is a group, then a template
is said to be translation invariant (with respect to the operation ) if and only
if for each triple we have that . Templates that are not
translation invariant are called translation variant or, simply, variant templates. A large
class of translation invariant templates with finite support have the nice property that they
can be defined pictorially. For example, let and y = (x,y) be an arbitrary point of
X. Set . Define by
defining the weights
whenever x is not an element of . Note that it follows from the definition
of t that . Thus, at any arbitrary point y, the configuration of the
support and weights of is as shown in Figure 1.5.1. The shaded cell in the pictorial
representation of indicates the location of the point y.
y
x
y
x
x +1
y -1
 3  1
 2 4
Figure 1.5.1. Pictorial representation of a translation invariant template.
1. 5 Templates 25
There are certain collections of templates that can be defined explicitly in terms
of parameters. These parameterized templates are of great practical importance.
Definition. A parameterized -valued template from Y to X with param-
eters in P is a function of form 

The set P is called the
set of parameters and each is called a parameter of t.
Thus, a parameterized -valued template from Y to X gives rise to a family of
regular -valued templates from Y to X, namely .
Image-Template Products
The definition of an image-template product provides the rules for combining
images with templates and templates with templates. The definition of this product includes
the usual correlation and convolution products used in digital image processing. Suppose
is a value set with two binary operations and , where distributes over , and
is associative and commutative. If , then for each , . Thus, if
, where X is finite, then and . It follows that the
binary operations and induce a binary operation
where
is defined by
Therefore, if , then
The expression is called the right product of a with t. Note that while
a is an image on X, the product is an image on Y. Thus, templates allow for the
transformation of an image from one type of domain to an entirely different domain type.
Replacing by changes into
the linear image-template product, where
, and .
Every template has a transpose which is defined
. Obviously, and reverses the mapping order from
26 CHAPTER 1. IMAGE ALGEBRA
to . By definition, and , whenever and
. Hence the binary operations and induce another product operation
where
is defined by
The expression is called the left product of a with s.
When computing , it is not necessary to use the transpose since
This allows us to redefine the transformation as
For the remainder of this section we assume that is a monoid and let 0
denote the zero of under the operation . Suppose and , where
X and Z are subsets of the same space. Since is a monoid, the operator can be
extended to a mapping
where is defined by is defined by
The left product is defined in a similar fashion. Subsequent examples will demonstrate
that the ability of replacing X with Z greatly simplifies the issue of template implementation
and the use of templates in algorithm development.
Significant reduction in the number of computations involved the image-template
product can be achieved if is a commutative semiring. Recall that if ,
then the support of t at a point with respect to the operation is defined as
. Since whenever , we have that
whenever and, therefore,
It follows that the computation of the new pixel value b(y) does not depend on the size of
X, but on the size of . Therefore, if , then the computation of
b(y) requires a total of operations of type and .
As pointed out earlier, substitution of different value sets and specific binary op-
erations for and results in a wide variety of different image transforms. Our prime ex-
amples are the ring and the value sets and
The structure provides for two lattice products:
1. 5 Templates 27
where
and
where
In order to distinguish between these two types of lattice transforms, we call the operator
the additive maximum and the additive minimum. It follows from our earlier discussion
that if , then the value of b(y) is , the zero of under the
operation of . Similarly, if , then .
The left additive max and min operations are defined by
and
respectively. The relationship between the additive max and min is given in terms of
lattice duality by
where the image is defined by , and the conjugate (or dual) of
is the template defined by . It follows
that .
The value set also provides for two lattice products. Specif-
ically, we have
where
and
where
Here 0 is the zero of under the operation of , so that whenever
. Similarly, whenever .
28 CHAPTER 1. IMAGE ALGEBRA
The lattice products and are called the multiplicative maximum and
multiplicative minimum, respectively. The left multiplicative max and left multiplicative
min are defined as
and
respectively. The duality relation between the multiplicative max and min is given by
where and . Here denotes the conjugate of r in .
Summary of Image-Template Products
In the following list of pertinent image-template products and
. Again, for each operation we assume the appropriate value set .
right generic product
right linear product
right additive max
right additive min
right multiplicative max
right multiplicative min
right xor max
right xor min
1. 5 Templates 29
In the next set of operations, .
left generic product
left linear product
left additive max
left additive min
left multiplicative max
left multiplicative min
Binary and Unary Template Operations
Since templates are images, all unary and binary image operations discussed
earlier apply to templates as well. Any binary on induces a binary operation
(again denoted by ) on as follows: for each pair the induced
operation is defined in terms of the induced binary image operation on , namely
. Thus, if , , and , then
, where denotes the pointwise sum of the two images
and .
The unary template operations of prime importance are the global reduce opera-
tions. Suppose Y is a finite point set, say , and . Any
binary semigroup operation on induces a global reduce operation
which is defined by
30 CHAPTER 1. IMAGE ALGEBRA
Thus, for example, if and is the operation of addition ( ), then and
Therefore, is an image, namely the sum of a finite number of images.
In all, the value set provides for four basic global reduce oper-
ations, namely , and .
If the value set has two binary operations and so that is a ring (or
semiring), then under the induced operations is also a ring (or semiring).
Analogous to the image-template product, the binary operations and induce a template
convolution product
defined as follows. Suppose , , and X a finite point set. Then the
template product , where , is defined as
Thus, if and , then is given by the formula
The lattice product is defined in a similar manner. For
and , the product template r is given by
The following example provides a specific instance of the above product formu-
lation.
Example: Suppose are the following translation invariant
templates:
1 12

1
3
-1
s    =y t    =y
1. 5 Templates 31
Then the template product is the template defined by
r   =y
1 2

1
36

3
-1 -2 -1
If  "! are defined as above with values outside the
support, then the template product is the template defined by
r   # =y$
2 3 2
4
%
5
&
4
%
0
'
1 0
'
The template t is not an (*)+ -valued template. To provide an example of
the template product , we redefine t as
t   
,
=y-
1
3
1
Then is given by
r   . =y-
1 2 1
3 6
/
3
1 2 1
The utility of template products stems from the fact that in semirings the equation
holds [1]. This equation can be utilized in order to reduce the computational burden
associated with typical convolution problems. For example, if 0 0 is defined by
32 CHAPTER 1. IMAGE ALGEBRA
, then
r   =y
4
1
6

4
1
6

9
2
-6
-4 -6
-4
where
t   
3
=y$s   4 =y$ 2 3 -2
2
5
3
-2
The construction of the new image requires nine multiplications and
eight additions per pixel (if we ignore boundary pixels). In contrast, the computation of the
image requires only six multiplications and four additions per pixel. For
large images (e.g., size ) this amounts to significant savings in computation.
Summary of Unary and Binary Template Operations
In the following and denotes the appropriate value set.
generic binary operation
template sum
max of two templates
min of two templates
generic reduce operation
sum reduce
product reduce
max reduce
min reduce
1. 6 Recursive Templates 33
In the next list, , , X is a finite point set, and denotes
the appropriate value set.
generic template product
linear template product
additive max product
additive min product
multiplicative max product
multiplicative min product
1.6. Recursive Templates
In this section we introduce the notions of recursive templates and recursive
template operations, which are direct extensions of the notions of templates and the
corresponding template operations discussed in the preceding section.
A recursive template is defined in terms of a regular template from some point
set X to another point set Y with some partial order imposed on Y.
Definition. A partially ordered set (or poset) is a set P together
with a binary relation , satisfying the following three axioms for arbitrary
:
(i)
(ii)
(iii)
Now suppose that X is a point set, Y is a partially ordered point set with partial
order , and a monoid. An -valued recursive template t from Y to X is a function6 , where 6 and , such that
Thus, for each , 6 is an -valued image on X and is an -valued image
on Y.
In most applications, the relation or usually holds. Also,
for consistency of notation and for notational convenience, we define 6 6 and
so that 6 . The support of t at a point y is defined as6 . The set of all -valued recursive templates from Y to X will
be denoted by .
In analogy to our previous definition of translation invariant templates, if X is
closed under the operation , then a recursive template is called
34 CHAPTER 1. IMAGE ALGEBRA
translation invariant if for each triple , we have , or
equivalently, 7 7 and . An example of an
invariant recursive template is shown in Figure 1.6.1.
1
1
1-1
=tt =
Figure 1.6.1. An example of an integer-valued invariant recursive template from to .
If t is an invariant recursive template and has only one pixel defined on the target
point of its nonrecursive support 8 , then t is called a simplified recursive template.
Pictorially, a simplified recursive template can be drawn the same way as a nonrecursive
template since the recursive part and the nonrecursive part do not overlap. In particular,
the recursive template shown in Figure 1.6.1 can be redrawn as illustrated in Figure 1.6.2
11
1-1
t =
Figure 1.6.2. An example of an integer-valued simplified recursive template.
The notions of transpose and dual of a recursive template are defined in terms of
those for nonrecursive templates. In particular, the transpose of a recursive template t is
defined as 9 . Similarly, if , then the additive dual of
t is defined by 9 . The multiplicative dual for recursive -valued templates
is defined in a likewise fashion.
Operations between Images and Recursive Templates
In order to facilitate the discussion on recursive templates operations, we begin
by extending the notions of the linear product , the additive maximum , and the
multiplicative maximum to the corresponding recursive operations , and
, respectively.
Let X and Y be finite subsets of with Y partially ordered by . If and
, then the recursive linear image-template product is defined by
: 9
The recursive template operation computes a new pixel value based
on both the pixel values of the source image and some previously calculated new
1. 6 Recursive Templates 35
pixel values which are determined by the partial order and the region of support
of the participating template. By definition of a recursive template, for every
and . Therefore, is always recursively computable. Some
partial orders that are commonly used in two-dimensional recursive transforms are forward
and backward raster scanning and serpentine scanning.
It follows from the definition of that the computation of a new pixel can
be done only after all its predecessors (ordered by ) have been computed. Thus, in contrast
to nonrecursive template operations, recursive template operations are not computed in a
globally parallel fashion.
Note that if the recursive template t is defined such that for all
, then one obtains the usual nonrecursive template operation
;
<
Hence, recursive template operations are natural extensions of nonrecursive template op-
erations.
Recursive additive maximum and multiplicative minimum are defined in a similar
fashion. Specifically, if and , then
is defined by
;
<
For and ,
is defined by
;
<
The operations of the recursive additive minimum and multiplicative minimum
are defined in the same straightforward fashion.
Recursive additive maximum, minimum as well as recursive multiplicative maxi-
mum and minimum are nonlinear operations. However, the recursive linear product remains
a linear operation.
The basic recursive template operations described above can be easily generalized
to the generic recursive image-template product by simple substitution of the specific
operations, such as multiplication and addition, by the generic operations and . More
precisely, given a semiring with identity, then one can define the generic
recursive product
36 CHAPTER 1. IMAGE ALGEBRA
by defining by
= >
Again, in addition to the basic recursive template operations discussed earlier, a wide variety
of recursive template operations can be derived from the generalized recursive rule by
substituting different binary operations for and . Additionally, parameterized recursive
templates are defined in the same manner as parametrized nonrecursive templates; namely
as functions
where P denotes the set of parameters, and > with >
and .
Summary of Recursive Template Operations
In the following list of pertinent recursive image-template products and
. As before, for each operation we assume the appropriate value set .
recursive generic product
= >
recursive linear product
= >
recursive additive max
= >
recursive additive min
= >
recursive multiplicative max
= >
1. 7 Neighborhoods 37
right multiplicative min
?
@
The definition of the left recursive product is also straightforward. How-
ever, for sake of brevity and since the different left products are not required for the
remainder of this text, we dispense with their formulation. Additional facts about recursive
products, their properties and applications can be found in [1, 56, 57].
1.7. Neighborhoods
There are several types of template operations that are more easily implemented
in terms of neighborhood operations. Typically, neighborhood operations replace template
operations whenever the values in the support of a template consist only of the unit elements
of the value set associated with the template. A template with the property
that for each , the values in the support of consist only of the unit of is called
a unit template.
For example, the invariant template A A shown in Figure 1.7.1 is a unit
template with respect to the value set since the value 1 is the unit with respect
to multiplication.
t
B
=
1
1
11
1
1
1
1
1
Figure 1.7.1. The unit Moore template for the value set .
Similarly, the template C C shown in Figure 1.7.2 is a unit template
with respect to the value set since the value 0 is the unit with respect to
the operation .
 0
 0
 0
 0rD =  0
Figure 1.7.2. The unit von Neumann template for the value set .
38 CHAPTER 1. IMAGE ALGEBRA
If is an array of points, , and E E is the
unit Moore template, then the values of the image b obtained from the statement
are computed by using the equation
We need to point out that the difference between the mathematical equality and
the pseudocode statement is that in the latter the new image is computed only
for those points y for which . Observe that since and
, where denotes the Moore neighborhood of y (see Figure 1.2.2),
it follows that
This observation leads to the notion of neighborhood reduction. In implementation,
neighborhood reduction avoids unnecessary multiplication by the unit element and, as we
shall shortly demonstrate, neighborhood reduction also avoids some standard boundary
problems associated with image-template products.
To precisely define the notion of neighborhood reduction we need a more general
notion of the reduce operation , which was defined in terms of a binary
operation on . The more general form of is a function
where .
For example, if , where is an array of points, then one
such function could be defined as
where . Another example would be to define
as , then implements the averaging function, which we
shall denote by average. Similarly, for integer-valued images, the median reduction
is defined as , where
.
Now suppose , is a unit template with respect to the
operation of the semiring , is a neighborhood system defined by
, and . It then follows that is given by
This observation leads to the following definition of an image-neighborhood
product. Given , , a reduction function , and a neighborhood
1. 7 Neighborhoods 39
system (i.e., ), then the image-neighborhood product
is defined by
for each . Note that the product is similar to the image template product
in that is a function
In particular, if , F is the Moore neighborhood, and
F F is the unit Moore template defined earlier, then .
Likewise, , where F F denotes the von Neumann unit template
(Figure 1.7.2) and N denotes the von Neumann neighborhood (1.2.2). The latter equality
stems from the fact that if and , then since for all
and for all points , we have that
Unit templates act like characteristic functions in that they do not weigh a pixel,
but simply note which pixels are in their support and which are not. When employed in
the image-template operations of their semiring, they only serve to collect a number of
values that need to be reduced by the gamma operation. For this reason, unit templates
are also referred to as characteristic templates. Now suppose that we wish to describe a
translation invariant unit template with a specific support such as the support of the
Moore template t shown in Figure 1.7.1. Suppose further that we would like this template
to be used with a variety of reduction operations, for instance, summation and maximum.
In fact, we cannot describe such an operand without regard of the image-template operation
by which it will be used. For us to derive the expected results, the template must map
all points in its support to the unitary value with respect to the combining operation .
Thus, for the reduce operation of summation , the unit values in the support must be
1, while for the maximum reduce operation , the values in the support must all be 0.
Therefore, we cannot define a single template operand to characterize a neighborhood for
reduction without regard to the image-template operation to be used to reduce the values
within the neighborhood. However, we can capture exactly the information of interest in
unit templates with the simple notion of neighborhood function. Thus, for example, the
Moore neighborhood M can be used to add the values in every neighborhood as well as
to find the maximum or minimum in such a neighborhood by using the statements ,
, and , respectively. This is one advantage for replacing unit templates with
neighborhoods.
Another advantage of using neighborhoods instead of templates can be seen by
considering the simple example of image smoothing by local averaging. Suppose ,
where is an array of points, and F F is the unit Moore template
with unit values 1. The image b obtained from the statement represents the
image obtained from a by local averaging since the new pixel value is given by
40 CHAPTER 1. IMAGE ALGEBRA
Of course, there will be a boundary effect. In particular, if
, then
which is not the average of four points. One may either ignore this boundary effect (the
most common choice), or one may one of several schemes to prevent it [1]. However,
each of these schemes adds to the computational burden. A simpler and more elegant
way is to use the Moore neighborhood function M combined with the averaging reduction
. The simple statement provides for the desired locally averaged
image without boundary effect.
Neighborhood composition plays an important role in algorithm optimization and
simplification of algebraic expressions. Given two neighborhood functionsG
, then the dilation of by , denoted by , is a neighborhood functionG
which is defined as
where . Just as for template composition, algorithm
optimization can be achieved by use of the equation for
appropriate neighborhood functions and neighborhood reduction functions . For ,
the kth iterate of a neighborhood
G
is defined inductively as ,
where .
Most neighborhood functions used in image processing are translation invariant
subsets of (in particular, subsets of ). A neighborhood function
G
is said to be translation invariant if for every point .
Given a translation invariant neighborhood N, we define its reflection or conjugate by
, where and
denotes the origin. Conjugate neighborhoods play an important role in morphological
image processing.
Note also that for a translation invariant neighborhood N, the kth iterate of N can
be expressed in terms of the sum of sets
Furthermore, since and
, we have the symmetric relation
.
Summary of Image-Neighborhood Products
In the following list of pertinent image-neigborhood products , ,
and . Again, for each operation we assume the appropriate value set .
generic neighborhood reduction
1. 8 The p-Product 41
neigborhood sum
neighborhood maximum
neighborhood minimum
Note that
and, therefore, . Similarly, .
Although we did not address the issues of parameterized neighborhoods and
recursive neighborhood operations, it should be clear that these are defined in the usual
way by simple substitution of the appropriate neighborhood function for the corresponding
Boolean template. For example, a parameterized neighborhood with parameters in the set
P is a function . Thus, for each parameter , is a neighborhood
system for X in Z since . Similarly, a recursive neighborhood system for
a partially ordered set is a function H satisfying the
conditions that for each , , and for each , .
1.8. The p-Product
It is well known that in the linear domain template convolution products and
image-template products are equivalent to matrix products and vector-matrix products,
respectively [58, 1]. The notion of a generalized matrix product was developed in order
to provide a general matrix theory approach to image-template products and template
convolution products in both the linear and non-linear domains. This generalized matrix or
p-product was first defined in Ritter [59]. This new matrix operation includes the matrix
and vector products of linear algebra, the matrix product of minimax algebra [60], as
well as generalized convolutions as special cases [59]. It provides for a transformation
that combines the same or different types of values (or objects) into values of a possibly
different type from those initially used in the combining operation. It has been shown that
the p-product can be applied to express various image processing transforms in computing
form [61, 62, 63]. In this document, however, we consider only products between matrices
having the same type of values. In the subsequent discussion, and the set of
all matrices with entries from will be denoted by . We will follow the usual
convention of setting and view as the set of all n-dimensional row vectors
with entries from . Similarly, the set of all m-dimensional column vectors with entries
from is given by
42 CHAPTER 1. IMAGE ALGEBRA
Let and p be positive integers with p dividing both m and n. Define the
following correspondences:
I
and
I
Since , linearizes the array
using the row scanning order as shown:
...
...
...
...
...
...
...
...
It follows that the row-scanning order on is given by
or, equivalently, by
We define the one-to-one correspondence
The one-to-one correspondence allows us to re-index the entries of a matrix
in terms of a triple index by using the convention
1. 8 The p-Product 43
Example: Suppose . Then
. Hence for JLK M NPORQ , we have
SLS S N SUT SWV SLX S Q
N S NLN N T N V N X NUQ
S KZY S K S\[ S K Y S K N [ S K Y]N\K S^[ S K_Y`NLK N [ S K_Y T K SL[ S K Y T K N [
NLK_Y S K S^[ N\K Y S K N [ N\K Y]N\K S^[ NLK_Y`NLK N [ NLK_Y T K SL[ N\K Y Tba N [
The factor of the Cartesian product is decomposed in a similar
fashion. Here the row-scanning map is given by
This allows us to re-index the entries of a matrix in terms of a
triple index by using the convention
Example: Suppose . Then
. Hence for J\K M cdORe , we have
SLS S N SUT
N S NLN N TTfS T N TLTVbS V N VgT
Y S K SL[ K S Y S K S^[ K N Y S K S^[ K T
Y S K N [ K S Y S K N [ K N Y S K N [ K T
Y]N\K SL[ K S Y]N\K S^[ K N Y`N\K S^[ K T
Y]N\K N [ K S Y]N\K N [ K N Y`N\K N [ K T
Now let and . Using the maps and
, A and B can be rewritten as
h i j k l m
j n o p q m
The p-product or generalized matrix product of A and B is denoted by , and is
the matrix
defined by
44 CHAPTER 1. IMAGE ALGEBRA
where denotes the th row and th column entry of C. Here we use the
lexicographical order Thus, the matrix C
has the following form:
rWs]tUu twvxsytUu tzv {W{U{|rWs]t}u tzvysytUu ~zv rWs]t}u twvysLu tzv{}{}{rWsyt}u tzvysLu ~v {W{W{rWs]t}u tvxsx]u v {}{W{r sxtUu tzv  u ~
r syt}u }vysytUu tzv {W{U{|r s]t}u }vysytUu ~zv r s]t}u vysLu tzv {}{}{r syt}u }vysLu ~v {W{W{r s]t}u Wvxsxyu v {}{W{r sxtUu }v  u ~
...
...
...
...
...r tUuy s]t}u tv {W{U{r t}u] sytUu ~v r tUuy s^u tv {}{}{r t}u` s^u ~v {W{W{r t}u] s]u xv {}{W{r t}u`   u ~rWs^u tzvysytUu tzv{W{U{|rWs^u tzvysytUu ~zv rWs^u twvysLu tzv{}{}{rWs^u tzvysLu ~v {W{W{rWs^u tvxsxyu v {}{W{r sLu tzv  u ~
...
...
...
...
...
...r Luy s]t}u tv {W{U{r ^u] sytUu ~v r Luy s^u tv {}{}{r ^u` s^u ~v {W{W{r ^u] s]u xv {}{W{r ^u`  u ~
...
...
...
...
...
...r sUu vysxt}u tzv {W{U{r sUu vxsytUu ~v r sUu Wvxs^u twv {}{}{r sUu vxsLu ~v {W{W{r sUu Wvxs]u xv {}{W{r sxUu v  u ~
...
...
...
...
...
...rWsyu tvxs]t}u tv {W{U{rWsu tzvxs]t}u ~v rWsxu tvxs^u tv {}{}{rWsu tzvxs^u ~v {W{W{rWsxu tvxs]u xv {}{W{r su tzv  u ~
...
...
...
...
...
...r u` s]t}u twv {W{U{r u` sytUu ~v r u` s^u tv {}{}{r u] sLu ~v {W{W{r u` s]u xv {}{W{r uy  u ~
The entry in the (s,j)-row and (i,t)-column is underlined for emphasis.
To provide an example, suppose that . Then
for p = 2, one obtains . Now let
and
Then the (2,1)-row and (2,3)-column element of the matrix
is given by
Thus, in order to compute , the two underlined elements of A are combined with
the two underlined elements of B as illustrated:
1. 8 The p-Product 45
In particular,
If
then
This shows that the transpose property, which holds for the regular matrix product, is
generally false for the p-product. The reason is that the p-product is not a dual operation
in the transpose domain. In order to make the transpose property hold we define the dual
operation of by
It follows that
and the p-product is the dual operation of . In particular, we now have the transpose
property .
46 CHAPTER 1. IMAGE ALGEBRA
Since the operation is defined in terms of matrix transposition, labeling of
matrix indices are reversed. Specifically, if is an matrix, then A gets
reindexed as , using the convention
Similarly, if is an matrix, then the entries of B are relabeled as ,
using the convention
The product is then defined by the equation
Note that the dimension of C is .
To provide a specific example of the dual operation , suppose that
In this case we have . Thus, for p = 2 and using the
scheme described above, the reindexed matrices have form
According to the dual product definition, the matrix is a matrix given by
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
1.9 References 47
The underlined element is obtained by using the formula:
Thus, in order to compute , the two underlined elements of A are combined with the
two underlined elements of B as illustrated:
As a final observation, note that the matrices A, B, and C in this example have the form of
the transposes of the matrices B, A, and C, respectively, of the previous example.
1.9. References
[1] G. Ritter, “Image algebra with applications.” Unpublished manuscript, available via
anonymous ftp from ftp://ftp.cis.ufl.edu/pub/src/ia/documents,
1994.
[2] S. Unger, “A computer oriented toward spatial problems,” Proceedings of the IRE,
vol. 46, pp. 1144–1750, 1958.
[3] J. von Neumann, “The general logical theory of automata,” in Cerebral Mechanism in
Behavior: The Hixon Symposium, New York, NY: John Wiley & Sons, 1951.
[4] J. von Neumann, Theory of Self-Reproducing Automata. Urbana, IL: University of
Illinois Press, 1966.
[5] K. Batcher, “Design of a massively parallel processor,” IEEE Transactions on
Computers, vol. 29, no. 9, pp. 836–840, 1980.
[6] M. Duff, D. Watson, T. Fountain, and G. Shaw, “A cellular logic array for image
processing,” Pattern Recognition, vol. 5, pp. 229–247, Sept. 1973.
[7] M. J. B. Duff, “Review of CLIP image processing system,” in Proceedings of the
National Computing Conference, pp. 1055–1060, AFIPS, 1978.
[8] M. Duff, “Clip4,” in Special Computer Architectures for Pattern Processing (K. Fu
and T. Ichikawa, eds.), ch. 4, pp. 65–86, Boca Raton, FL: CRC Press, 1982.
[9] T. Fountain, K. Matthews, and M. Duff, “The CLIP7A image processor,” IEEE Pattern
Analysis and Machine Intelligence, vol. 10, no. 3, pp. 310–319, 1988.
[10] L. Uhr, “Pyramid multi-computer structures, and augmented pyramids,” in Computing
Structures for Image Processing (M. Duff, ed.), pp. 95–112, London: Academic Press,
1983.
[11] L. Uhr, Algorithm-Structured Computer Arrays and Networks. New York, NY:
Academic Press, 1984.
[12] W. Hillis, The Connection Machine. Cambridge, MA: The MIT Press, 1985.
[13] J. Klein and J. Serra, “The texture analyzer,” Journal of Microscopy, vol. 95, 1972.
[14] R. Lougheed and D. McCubbrey, “The cytocomputer: A practical pipelined image
processor,” in Proceedings of the Seventh International Symposium on Computer
Architecture, pp. 411–418, 1980.
48 CHAPTER 1. IMAGE ALGEBRA
[15] S. Sternberg, “Biomedical image processing,” Computer, vol. 16, Jan. 1983.
[16] R. Lougheed, “A high speed recirculating neighborhood processing architecture,” in
Architectures and Algorithms for Digital Image Processing II, vol. 534 of Proceedings
of SPIE, pp. 22–33, 1985.
[17] E. Cloud and W. Holsztynski, “Higher efficiency for parallel processors,” in Proceed-
ings IEEE Southcon 84, (Orlando, FL), pp. 416–422, Mar. 1984.
[18] E. Cloud, “The geometric arithmetic parallel processor,” in Proceedings Frontiers of
Massively Parallel Processing, George Mason University, Oct. 1988.
[19] E. Cloud, “Geometric arithmetic parallel processor: Architecture and implementation,”
in Parallel Architectures and Algorithms for Image Understanding (V. Prasanna, ed.),
(Boston, MA.), Academic Press, Inc., 1991.
[20] H. Minkowski, “Volumen und oberflache,” Mathematische Annalen, vol. 57, pp. 447–
495, 1903.
[21] H. Minkowski, Gesammelte Abhandlungen. Leipzig-Berlin: Teubner Verlag, 1911.
[22] H. Hadwiger, Vorlesungen Über Inhalt, Oberflæche und Isoperimetrie. Berlin: Springer-
Verlag, 1957.
[23] G. Matheron, Random Sets and Integral Geometry. New York: Wiley, 1975.
[24] J. Serra, “Introduction a la morphologie mathematique,” booklet no. 3, Cahiers du
Centre de Morphologie Mathematique, Fontainebleau, France, 1969.
[25] J. Serra, “Morphologie pour les fonctions “a peu pres en tout ou rien”,” technical report,
Cahiers du Centre de Morphologie Mathematique, Fontainebleau, France, 1975.
[26] J. Serra, Image Analysis and Mathematical Morphology. London: Academic Press,
1982.
[27] T. Crimmins and W. Brown, “Image algebra and automatic shape recognition,” IEEE
Transactions on Aerospace and Electronic Systems, vol. AES-21, pp. 60–69, Jan. 1985.
[28] R. Haralick, S. Sternberg, and X. Zhuang, “Image analysis using mathematical
morphology: Part I,” IEEE Transactions on Pattern Analysis and Machine Intelligence,
vol. 9, pp. 532–550, July 1987.
[29] R. Haralick, L. Shapiro, and J. Lee, “Morphological edge detection,” IEEE Journal of
Robotics and Automation, vol. RA-3, pp. 142–157, Apr. 1987.
[30] P. Maragos and R. Schafer, “Morphological skeleton representation and coding of
binary images,” IEEE Transactions on Acoustics, Speech, and Signal Processing,
vol. ASSP-34, pp. 1228–1244, Oct. 1986.
[31] P. Maragos and R. Schafer, “Morphological filters Part II : Their relations to median,
order-statistic, and stack filters,” IEEE Transactions on Acoustics, Speech, and Signal
Processing, vol. ASSP-35, pp. 1170–1184, Aug. 1987.
[32] P. Maragos and R. Schafer, “Morphological filters Part I: Their set-theoretic analysis
and relations to linear shift-invariant filters,” IEEE Transactions on Acoustics, Speech,
and Signal Processing, vol. ASSP-35, pp. 1153–1169, Aug. 1987.
[33] J. Davidson and A. Talukder, “Template identification using simulated annealing
in morphology neural networks,” in Second Annual Midwest Electro-Technology
Conference, (Ames, IA), pp. 64–67, IEEE Central Iowa Section, Apr. 1993.
[34] J. Davidson and F. Hummer, “Morphology neural networks: An introduction with
applications,” IEEE Systems Signal Processing, vol. 12, no. 2, pp. 177–210, 1993.
[35] E. Dougherty, “Unification of nonlinear filtering in the context of binary logical
calculus, part ii: Gray-scale filters,” Journal of Mathematical Imaging and Vision,
vol. 2, pp. 185–192, Nov. 1992.
1.9 References 49
[36] D. Schonfeld and J. Goutsias, “Optimal morphological pattern restoration from noisy
binary images,” IEEE Transactions on Pattern Analysis and Machine Intelligence,
vol. 13, pp. 14–29, Jan. 1991.
[37] J. Goutsias, “On the morphological analysis of discrete random shapes,” Journal of
Mathematical Imaging and Vision, vol. 2, pp. 193–216, Nov. 1992.
[38] L. Koskinen and J. Astola, “Asymptotic behaviour of morphological filters,” Journal
of Mathematical Imaging and Vision, vol. 2, pp. 117–136, Nov. 1992.
[39] S. R. Sternberg, “Language and architecture for parallel image processing,” in
Proceedings of the Conference on Pattern Recognition in Practice, (Amsterdam), May
1980.
[40] S. Sternberg, “Overview of image algebra and related issues,” in Integrated Technology
for Parallel Image Processing (S. Levialdi, ed.), London: Academic Press, 1985.
[41] P. Maragos, A Unified Theory of Translation-Invariant Systems with Applications to
Morphological Analysis and Coding of Images. Ph.D. dissertation, Georgia Institute of
Technology, Atlanta, 1985.
[42] J. Davidson, Lattice Structures in the Image Algebra and Applications to Image
Processing. PhD thesis, University of Florida, Gainesville, FL, 1989.
[43] J. Davidson, “Classification of lattice transformations in image processing,” Computer
Vision, Graphics, and Image Processing: Image Understanding, vol. 57, pp. 283–306,
May 1993.
[44] P. Miller, “Development of a mathematical structure for image processing,” optical
division tech. report, Perkin-Elmer, 1983.
[45] J. Wilson, D. Wilson, G. Ritter, and D. Langhorne, “Image algebra FORTRAN
language, version 3.0,” Tech. Rep. TR-89–03, University of Florida CIS Department,
Gainesville, 1989.
[46] J. Wilson, “An introduction to image algebra Ada,” in Image Algebra and Morpho-
logical Image Processing II, vol. 1568 of Proceedings of SPIE, (San Diego, CA),
pp. 101–112, July 1991.
[47] J. Wilson, G. Fischer, and G. Ritter, “Implementation and use of an image processing
algebra for programming massively parallel computers,” in Frontiers ’88: The Second
Symposium on the Frontiers of Massively Parallel Computation, (Fairfax, VA), pp. 587–
594, 1988.
[48] G. Fischer and M. Rowlee, “Computation of disparity in stereo images on the
Connection Machine,” in Image Algebra and Morphological Image Processing,
vol. 1350 of Proceedings of SPIE, pp. 328–334, 1990.
[49] D. Crookes, P. Morrow, and P. McParland, “An algebra-based language for image
processing on transputers,” IEE Third Annual Conference on Image Processing and its
Applications, vol. 307, pp. 457–461, July 1989.
[50] D. Crookes, P. Morrow, and P. McParland, “An implementation of image algebra
on transputers,” tech. rep., Department of Computer Science, Queen’s University of
Belfast, Northern Ireland, 1990.
[51] J. Wilson, “Supporting image algebra in the C++ language,” in Image Algebra and
Morphological Image Processing IV, vol. 2030 of Proceedings of SPIE, (San Diego,
CA), pp. 315–326, July 1993.
[52] University of Florida Center for Computer Vision and Visualization, Software User
Manual for the iac++ Class Library, version 1.0 ed., 1994. Avialable via anonymous
ftp from ftp.cis.ufl.edu in /pub/ia/documents.
50 CHAPTER 1. IMAGE ALGEBRA
[53] G. Birkhoff and J. Lipson, “Heterogeneous algebras,” Journal of Combinatorial Theory,
vol. 8, pp. 115–133, 1970.
[54] University of Florida Center for Computer Vision and Visualization, Software User
Manual for the iac++ Class Library, version 2.0 ed., 1995. Avialable via anonymous
ftp from ftp.cis.ufl.edu in /pub/ia/documents.
[55] G. Ritter, J. Davidson, and J. Wilson, “Beyond mathematical morphology,” in Visual
Communication and Image Processing II, vol. 845 of Proceedings of SPIE, (Cambridge,
MA), pp. 260–269, Oct. 1987.
[56] D. Li, Recursive Operations in Image Algebra and Their Applications to Image
Processing. PhD thesis, University of Florida, Gainesville, FL, 1990.
[57] D. Li and G. Ritter, “Recursive operations in image algebra,” in Image Algebra and
Morphological Image Processing, vol. 1350 of Proceedings of SPIE, (San Diego, CA),
July 1990.
[58] R. Gonzalez and P. Wintz, Digital Image Processing. Reading, MA: Addison-Wesley,
second ed., 1987.
[59] G. Ritter, “Heterogeneous matrix products,” in Image Algebra and Morphological
Image Processing II, vol. 1568 of Proceedings of SPIE, (San Diego, CA), pp. 92–100,
July 1991.
[60] R. Cuninghame-Green, Minimax Algebra: Lecture Notes in Economics and Mathemat-
ical Systems 166. New York: Springer-Verlag, 1979.
[61] G. Ritter and H. Zhu, “The generalized matrix product and its applications,” Journal
of Mathematical Imaging and Vision, vol. 1(3), pp. 201–213, 1992.
[62] H. Zhu and G. X. Ritter, “The generalized matrix product and the wavelet transform,”
Journal of Mathematical Imaging and Vision, vol. 3, no. 1, pp. 95–104, 1993.
[63] H. Zhu and G. X. Ritter, “The p-product and its applications in signal processing,”
SIAM Journal of Matrix Analysis and Applications, vol. 16, no. 2, pp. 579–601, 1995.

