Session No. 11 Theoretical Foundations 481 
AN ALGEBRAIC DEFINITION OF SIMULATION 
BETWEEN PROGRAMS* 
Robin Milner 
Computer Science Department 
Stanford University 
Stanford, California 
A simulation relat ion between programs is 
defined which is a quasi-ordering. Mutual simula­
t ion is then an equivalence re lat ion, and by d iv id ­
ing out by it we abstract from a program such 
details as how the sequencing is controlled and 
how data is represented. The equivalence classes 
are approximations to the algorithms which are 
real ized, or expressed, by their member programs. 
A technique is given and i l lus t ra ted for 
proving simulation and equivalence of programs; 
there is an analogy with Floyd's technique for 
proving correctness oi programs. Final ly, necess­
ary and suff ic ient conditions for simulation are 
given. 
DESCRIPTIVE TERMS: Simulation, weak 
homomorphism, algorithm, program correctness, 
program equivalence. 
1. INTRODUCTION 
One aim of this paper is to make precise a 
sense in which two programs may be said to be 
realizations of the same algorithm. We can say 
loosely that for this to he true it is suff ic ient 
though perhaps not necessary that the programs do 
the same 'important' computations in the same 
sequence, even though they d i f fer in other ways: 
for example 1) we may disregard other computations 
perhaps dif ferent in the two programs, which arc 
'unimportant' in the sense that they are only con­
cerned with control l ing the 'important' ones, (2) 
the data may ilow d i i terent ly through the variables 
or registers, (3) the data may be d i f ferent ly 
represented in the two programs. The program pairs 
in Figures 1 and 2, studied in detail in Section 
4, i l l us t ra te points (1) and (5) respectively; a 
t r i v i a l i l l us t ra t i on of (2) is the following pair 
of programs: 
Although the above prescription is vague, we give 
a re lat ion of simulation between programs which may 
fa i r l y be said to match i t . The relat ion turns out 
to be t ransi t ive and reflexive but not always 
symmetric; however mutual simulation is an equiva­
lence re la t ion , and it is the equivalence classes 
under this relat ion which may be regarded as 
algorithms - at least this is an approximation to 
a def in i t ion of algorithm. 
We show also that there is a practical 
technique for proving simulation in interesting 
cases - though unfortunately simulation between 
programs handling the integers, for example, is 
not a decidable (or even par t ia l ly decidable) 
re la t ion. Under a simple rest r ic t ion simulation 
ensures the equivalence (as par t ia l functions) of 
the programs, so this is also a technique for 
proving equivalence; however in general equivalent 
programs w i l l not satisfy the simulation re la t ion. 
I also claim that in order to prove by 
Floyd's [1] method the correctness of a program 
A, in a case where data is represented unnaturally, 
perhaps for eff ic iency's sake, the easiest and 
most lucid approach is rather close to f i r s t 
designing a program B which is simulated by 
program A and which represents the data 
natural ly, and then proving B correct. This 
was in fact the or iginal motivation for studying 
simulation, and is discussed in more deta i l in 
Milner [ 2 ] , which contains a f i r s t attempt at the 
def in i t ion of simulation. The sequel [3] gener­
alizes the def in i t ion and the current paper is a 
synthesis of the two, and may be read independently 
2. NOTATION 
*This research was supported mainly by the Science 
Research Council, Great Br i ta in and In part by 
the Advanced Research Projects Agency of the 
Department of Defense (SD-183) U.S.A. 
482 Session No. 11 Theoretical Foundations 
we get either an i n f i n i t e sequence in D , or 
comp 
a f i n i t e sequence in D followed by a single 
comp 
repeated member of D . We have ( i i ) merely 
to keep F t o t a l , which the theory requires. 
Why must the domains be disjoint? What about 
a program which inputs an integer and outputs an 
integer? Here one might argue that Din = D out = 
[ integers}; but we get into no trouble having two 
formally d is jo int domains with for example an 
in ject ion or a b i ject ion between them. In fact , 
in practice we can distinguish between an input 
object and an output object of a program; for 
example they occur on di f ferent media, or at 
di f ferent spatial locations. We are concerned 
with a level of abstraction ( i . e . abstraction from 
real computers operating on physical data symbols) 
lower than that in which a program is considered 
as for example a function from integers to 
integers. 
E is the set of possible state-vector values, 
and for non-recursive (flowchart) programs N is 
the f i n i t e set of nodes of the flowchart while for 
recursive programs N is the i n f i n i t e set of 
possible states of a pushdown store. 
Before dealing with simulation, we state 
without proof some theorems concerning correct­
ness and termination of programs. Theorem 3.1 
embodies Floyd's [1J method of proving par t ia l 
correctness of programs. There is also a 
correspondence with Manna's work - for example in 
[4] ; our Theorems 3 .1 ard 3.2 correspond to 
Theorems 1 and ? of that paper. However, Manna 
is concerned with the representabil i ty of v e r i f i ­
cations (as defined below) in f i r s t order predi­
cate calculus; we perhaps gain in succinctness by 
stating results algebraically and ignoring the 
question of representabi l i ty. 
Henceforward we assume that the suff ix ' i n ' 
to a symbol denoting a set implies inclusion in 
Din . Similarly for 'comp' and ' ou t ' . i 
Session No. 11 Theoretical Foundations 483 
simulation of a by a' we say a' strongly sim­
ulates a, and it is easy to show that this is a 
transi t ive reflexive relat ion, i . e . , a quasi-
ordering. Mutual strong simulation is therefore 
an equivalence re la t ion, and equivalence classes 
may be thought of as algorithms, each of which 
is realized by i t s member programs. Moreover, 
if we divide out by this equivalence relation we 
obtain from the quasi-ordering of programs a 
par t ia l ordering of algorithms. 
It is worth noticing that there is always a 
weak simulation between any pair of programs -
just take R = 0 - so a similar def in i t ion of 
"a' weakly simulates a " is vacuous. 
We f in ish this section with two simple 
results which exhibit the close relationship 
between ver i f icat ions and simulations. 
Theorem 3.5 
Thus in a precise sense a proof of part ia l 
correctness of may be factored into a proof 
of par t ia l correctness of together with a 
proof of simulation of 
4 . APPLICATION TO FLOWCHART PROGRAMS 
In this section, we show how we may demonstrate 
(Note that in the above we did not use the to ta l i t y 
of R-1 , nor the single valuednesB of R, ). 
out 
Let us return to the discussion of algorithm 
in the introduction. If there is a strong 
484 Session No. 11 Theoretical Foundations 
485 
486 Session No. 11 Theoretical Foundations 
D , it is a simple out 
a simulation between two programs in a manner which 
bears a close relat ion to Floyd's method for proving 
correctness of a single program. Of the two examples, 
the f i r s t has the same data representation but d i f ­
ferent control in the two programs; the second has 
di f ferent data representations in the two programs. 
Given a flowchart program with input domain D. 
i n , 
state-vector domain E, output domain D and node-out 
set N, and given also an input function f :D, E 
in in 
and output function f :E out 
matter to formalize it as a program according to 
our de f in i t i on , with D = N x E and F:D D 
comp 
defined in terms of fin ,fout and the tests and in out 
assignments in the boxes. Al ternat ively, we may 
formalize it by selecting a subset M N so that 
every cycle in the flowchart contains a member of 
M (we ca l l such an M a cycle-breaking set) and 
define D instead as M x E. The cycle 
comp 
breaking property ensures that F : D D is 
again t o t a l . 
Now suppose i n a n d we have D = comp 
M x E , D ' a n d m a y have 
comp J 
been obtained by the above formalization from flow 
chart programs, for example. If H is a simu­
lat ion o f b y i , we have R J comp 
[M/ y E') , and to exhibit R it is suf f ic ient comp to exhibit R / for each m f M, m'ε M' where mm 
In the following two examples we exhibit the R mm 
and also indicate how the proof of RF' FR would 
go. 
Example 1. See F i g u r e A s s u m e that inputs to 
each program are pairs , state vectors are 
t r i p l e s , and only x is output. The 
n o d e - s e t h a s been chosen to formalize 
and {l ," to f o r m a l i z e . So if 
denote integers and reals we have 
For example, we may think of R12 as containing 
a l l state-vector pairs attained at the node-pair 
when are obeyed synchronously 
start ing from an input pair in Rin . However, it 
contains also many other state-vector pairs (since 
there is no constraint on x in the def in i t ion 
of R / ) , and simulation w i l l normally have this 
generous property. R-13 is here taken as the 
empty set, because the node p a i r i s 
never reached. 
To prove RF' FR we must show for a l l 
d ,d ' 
and this may be done by cases 
which is a f a i r l y routine matter using the def in­
i t ions of F,F', and we leave it to the reader. 
Now since R is a strong simulation, and 
indeed are ident i t ies , Theorem 
ent i t les us to conclude 
Example _. :See Figure " ). This example 
i l lus t ra tes simulation between two programs with 
di f ferent data representation. We describe this 
example in less de ta i l , to save space. Each 
program is supposed to input a str ing c, a 
character F and a str ing T, and to output the 
result of substituting T for P everywhere in 
Thus if S is the alphabet of characters, 
I ) J ( w h e r e S * i s the set in 
of strings over S) and 
Program handles strings and characters directly 
using the functions h d , t l , (concatenation) 
and the nul l str ing The three inputs are to 
the program variables respectively, 
and output is from the variable . On the other 
hand, program represents each str ing as a 
segment of an integer-indexed character array; 
on input the two input strings are stored in 
arrays s,t (indexed from 1), their lengths + 1 
in integer variables h l . k l and the character in 
Session No. 11 Theoretical Foundations 487 
and output is the str ing ss(l) ,ss(2) ss (hh-
The flowcharts are formalized as programs 
( in our sense) with node-sets 
and we have D ■ t h e set o f possible 
comp 
values for the program variable vector of and 
simi lar ly for D' . F and F' the t ransi t ion comp 
functions, are easy but tedious to define. We 
now exhibit a simulation by giving R, , R and 
in out 
the using 
an auxi l iary function seq; arrays x integers x 
integers → strings defined by 
Now as in Lxaraple 1 the proof of RF' FR 
must proceed by cases; it w i l l use certain propert­
ies (or axioms) concerning the str ing handling 
functions, the array and integer handling functions 
and the function seq. We leave it to the reader 
again. Again, since R, , R are ident i t ies we 
in out 
have proved that 
There are some interesting points about this 
example. (1) It seems that program is more 
natural than , though this asymmetry was not 
present in Example 1. In fact, program is 
only a sl ight modification of part of a real 
program wri t ten for use rather than as an example. 
In the process of proving correct (See 
using Floyd's technique, I found that the assert­
ions associated with parts of the program were 
most naturally expressed using the function seq. 
Also (this is discussed in more deta i l in the 
task of p r o v i n g c o r r e c t factored simply into 
two tasks - that of proving correct (an easier 
task since is more natural and closer to 
programmer's in tu i t ion) and that of proving the 
simulation. This ' factor ing' was made precise by 
Theorem 
(2) Unlike in Example 1, the flowcharts here have 
identical shape, and it is meaningful iand even 
true!) to say that under identical inputs the 
programs follow the same path. In Example 1 such 
a statement would not be meaningful,but in Section 
5 we show that a similar statement has meaning in 
cases more general then Example :, and provides us 
with necessary and suff icient conditions for the 
existence of a simulation between two programs. 
5. PARTITIONED SIMULATION 
We now obtain necessary and suff icient 
conditions for the existence of simulation between 
two programs and 
Def in i t ion. If J is any indexing set ana 
are part i t ions of D , 
comp 
D' respectively, then is a par t i t ion comp 
pair for D , D' (Of course any two domains 
comp comp 
can have a part i t ion pair, but we are only concerned 
with computation domains). 
Def in i t ion. Computation sequences 
agree for 
Def in i t ion. A simulation R respects 
i f R 
comp 
Theorem 5.1 
488 Session No 11 Theoretical Foundations 
if and only if computation s e q u e n c e s i n 
i n s u c h t h a t R T always 
in 
have length either both undefined or equal (the length o f i s defined a s m i n D out 
There is a corresponding corollary to Theorem 
5._ , which we omit. 
Finally, we give a corollary for flowchart 
programs of the same shape. 
'". CONCLUSIONS AND POSSIBLE DEVELOPMENTS 
The idea of simulation, which is really an 
application of the notion of weak homomorphism, 
is interesting in two ways: theoretically, 
because it allows one to abstract some irrelevant 
detail from programs to come closer to a definition 
of algorithm, and practically because there is a 
manageable technique for proving simulation 
between programs, which in some cases may make 
easier the task of proving a program correct. 
There are two possible directions for 
development. First, we have restricted to a 
single-valued, total transition function r. The 
situation looks rather different when we relax 
these conditions - for example we should consider 
computation trees rather than sequences. Second, 
we should consider simulation of parallel programs, 
and treat programs which perform the same compu-
tations but not necessarily in the same sequence 
as serializations of the same parallel program -
or of mutually simulating parallel programs. These 
extensions may bear the same relation to the work 
of Manna [5] and Ashcroft and Manna on the 
correctness of nondeterministic and parallel 
programs as the present paper bears to Manna's 
work on serial programs [4] . 
Session No. 11 Theoretical Foundations 489 
ACKNOWLEDGEMENTS 
This work owes much to Peter Landin who 
largely pioneered the algebraic approach to 
programs. This paper is in the sp i r i t of [ 8 ] , 
although that paper is concerned with the structure 
of a single program (as a product algebra) rather 
than relations between programs. I also had 
prof i table discussions with Peter Landin, Rod 
Burs ta l l and John Laski. 
REFERENCES 
1. Floyd, R.W., "Assigning Meanings to Programs", 
Proceedings of Symposia in Applied Mathematics. 
American Mathematical Society, Vol. 19, 19-32 
1967). 
Milner, R., "A Formal Notion of Simulation 
Between Programs", Memo 14, Computers and 
Logic Research Croup, University College of 
Swansea, U.K. (17/0). 
Milner, R., "Program Simulation: An Extended 
Formal Notion", Memo 17, Computers and Logic 
Research Group, University College of Swansea, 
U.K. (1961). 
4 . Manna, Z., "The Correctness of Programs", J. 
of Computer and Systems Sciences, Vol. 3, No. 
2. 119-127 (1969). 
S. Manna, Z., "The Correctness of Non-deterministic 
Programs", Stanford A r t i f i c i a l Intell igence 
Project, Memo AI-95, Stanford University 
(1969). 
6. Ashcrof t, E.A., and Manna, Z., "Formalization 
of Properties of Parallel Programs", Stanford 
A r t i f i c i a l Intell igence Project, Memo AI-110, 
Stanford University, (1970). 
7. Ginzburg, A. , Algebraic Theory of Automata. 
Academic Press (1968). 
8. Landin, P., "A Program-Machine Symmetric 
Automata Theory", Machine Intelligence 5, 
ed. , D. Michie, Edinburgh University Press, 
99-120 (1999). 

