Near-Optimal Hashing Algorithms for 
Approximate Nearest Neighbor in High Dimensions
by Alexandr Andoni and Piotr Indyk
The goal of this article is twofold. In the first part, we survey a family
of nearest neighbor algorithms that are based on the concept of locality-
sensitive hashing. Many of these algorithm have already been successfully
applied in a variety of practical scenarios. In the second part of this arti-
cle, we describe a recently discovered hashing-based algorithm, for the
case where the objects are points in the d-dimensional Euclidean space.
As it turns out, the performance of this algorithm is provably near-opti-
mal in the class of the locality-sensitive hashing algorithms.
1 Introduction
The nearest neighbor problem is defined as follows: given a collection
of n points, build a data structure which, given any query point, reports
the data point that is closest to the query. A particularly interesting and
well-studied instance is where the data points live in a d-dimensional
space under some (e.g., Euclidean) distance function. This problem is
of major importance in several areas; some examples are data com-
pression, databases and data mining, information retrieval, image and
video databases, machine learning, pattern recognition, statistics and
data analysis. Typically, the features of each object of interest (docu-
ment, image, etc.) are represented as a point in !d and the distance
metric is used to measure the similarity of objects. The basic problem
then is to perform indexing or similarity searching for query objects.
The number of features (i.e., the dimensionality) ranges anywhere from
tens to millions. For example, one can represent a 1000 × 1000 image
as a vector in a 1,000,000-dimensional space, one dimension per pixel.
There are several efficient algorithms known for the case when the
dimension d is low (e.g., up to 10 or 20). The first such data structure,
called kd-trees was introduced in 1975 by Jon Bentley [6], and remains
one of the most popular data structures used for searching in multidi-
mensional spaces. Many other multidimensional data structures are
known, see [35] for an overview. However, despite decades of inten-
sive effort, the current solutions suffer from either space or query time
that is exponential in d. In fact, for large enough d, in theory or in prac-
tice, they often provide little improvement over a linear time algorithm
that compares a query to each point from the database. This phenom-
enon is often called “the curse of dimensionality.”
In recent years, several researchers have proposed methods for over-
coming the running time bottleneck by using approximation (e.g., [5,
27, 25, 29, 22, 28, 17, 13, 32, 1], see also [36, 24]). In this formulation,
the algorithm is allowed to return a point whose distance from the query
is at most c times the distance from the query to its nearest points; c >
1 is called the approximation factor. The appeal of this approach is that,
in many cases, an approximate nearest neighbor is almost as good as the
exact one. In particular, if the distance measure accurately captures the
notion of user quality, then small differences in the distance should not
matter. Moreover, an efficient approximation algorithm can be used to
solve the exact nearest neighbor problem by enumerating all approxi-
mate nearest neighbors and choosing the closest point1.
In this article, we focus on one of the most popular algorithms for
performing approximate search in high dimensions based on the con-
cept of locality-sensitive hashing (LSH) [25]. The key idea is to hash
the points using several hash functions to ensure that for each func-
tion the probability of collision is much higher for objects that are
close to each other than for those that are far apart. Then, one can
determine near neighbors by hashing the query point and retrieving
elements stored in buckets containing that point.
The LSH algorithm and its variants has been successfully applied
to computational problems in a variety of areas, including web clus-
tering [23], computational biology [10.11], computer vision (see
selected articles in [23]), computational drug design [18] and compu-
tational linguistics [34]. A code implementing a variant of this method
is available from the authors [2]. For a more theoretically-oriented
overview of this and related algorithms, see [24].
The purpose of this article is twofold. In Sec tion 2, we describe the
basic ideas behind the LSH algorithm and its analysis; we also give an
overview of the current library of LSH functions for various distance
measures in Sec tion 3. Then, in Sec tion 4, we describe a recently
developed LSH family for the Euclidean distance, which achievies a
near-optimal separation between the collision probabilities of close
and far points. An interesting feature of this family is that it effectively
enables the reduction of the approximate nearest neighbor problem for
worst-case data to the exact nearest neighbor problem over random (or
pseudorandom) point configuration in low-dimensional spaces.
1See section 2.4 for more information about exact algorithms.
Abstract
In this article, we give an overview of efficient algorithms for the approximate and exact nearestneighbor problem. The goal is to preprocess a dataset of objects (e.g., images) so that later, givena new query object, one can quickly return the dataset object that is most similar to the query. The
problem is of significant interest in a wide variety of areas.
Biographies
Alexandr Andoni (andoni@mit.edu) is a Ph.D. Candidate in computer
science at Massachusetts Institute of Technology, Cambridge, MA.
Piotr Indyk (indyk@theory.lcs.mit.edu) is an associate professor in the
Theory of Computation Group, Computer Science and Artificial Intel-
ligence Lab, at Massachusetts Institute of Technology, Cambridge, MA.
COMMUNICATIONS OF THE ACM January  2008/Vol. 51, No. 1 117
Currently, the new family is mostly of theoretical interest. This is
because the asymptotic improvement in the running time achieved via
a better separation of collision probabilities makes a difference only for
a relatively large number of input points. Nevertheless, it is quite likely
that one can design better pseudorandom point configurations which do
not suffer from this problem. Some evidence for this conjecture is pre-
sented in [3], where it is shown that point configurations induced by so-
called Leech lattice compare favorably with truly random configurations.
Preliminaries
2.1 Geometric Normed Spaces
We start by introducing the basic notation used in this article. First,
we use P to denote the set of data points and assume that P has car-
dinality n. The points p from P belong to a d-dimensional space !d. We
use pi to the denote the ith coordinate of p, for i = 1…d.
For any two points p and q, the distance between them is defined as
for a parameter s > 0; this distance function is often called the ls norm.
The typical cases include s = 2 (the Euclidean distance) or s = 1 (the
Manhattan distance)2. To simplify notation, we often skip the subscript
2 when we refer to the Euclidean norm, that is, !p – q! = !p – q!2.
Occasionally, we also use the Hamming distance, which is defined
as the number of positions on which the points p and q differ.
2.2 Problem Definition
The nearest neighbor problem is an example of an optimization problem:
the goal is to find a point which minimizes a certain objective function
(in this case, the distance to the query point). In contrast, the algorithms
that are presented in this article solve the decision version of the prob-
lem. To simplify the notation, we say that a point p is an R-near neighbor
of a point q if the distance between p and q is at most R (see Figure 1).
In this language, our algorithm either returns one of the R-near neigh-
bors or concludes that no such point exists for some parameter R.
Fig. 1. An illustration of an R-near neighbor query. The nearest
neighbor of the query point q is the point p1. However, both p1
and p2 are R-near neighbors of q.
Naturally, the nearest and near neighbor problems are related. It is
easy to see that the nearest neighbor problem also solves the R-near 
2The name is motivated by the fact that !p – q!1 = "
d
i = 1 #pi – qi # is the length of the
shortest path between p and q if one is allowed to move along only one coordinate
at a time.
neighbor problem–one can simply check if the returned point is an
R-near neighbor of the query point. The reduction in the other direc-
tion is somewhat more complicated and involves creating several
instances of the near neighbor problem for different values of R. During
the query time, the data structures are queried in the increasing order
of R. The process is stopped when a data structure reports an answer.
See [22] for a reduction of this type with theoretical guarantees.
In the rest of this article, we focus on the approximate near neigh-
bor problem. The formal definition of the approximate version of the
near neighbor problem is as follows.
Definition 2.1 (Randomized c-approximate R-near neighbor, or
(c, R) – NN). Given a set P of points in a d-dimensional space !d, and
parameters R > 0, ! > 0, construct a data structure such that, given
any query point q, if there exists an R-near neighbor of q in P, it reports
some cR-near neighbor of q in P with probability 1 – !.
For simplicity, we often skip the word randomized in the discus-
sion. In these situations, we will assume that ! is an absolute constant
bounded away from 1 (e.g., 1/2). Note that the probability of success
can be amplified by building and querying several instances of the data
structure. For example, constructing two independent data structures,
each with ! = 1/2, yields a data structure with a probability of failure
! = 1/2·1/2 = 1/4.
In addition, observe that we can typically assume that R = 1.
Otherwise we can simply divide all coordinates by R. Therefore, we
will often skip the parameter R as well and refer to the c-approximate
near neighbor problem or c-NN.
We also define a related reporting problem.
Definition 2.2 (Randomized R-near neighbor reporting). Given a set
P of points in a d-dimensional space !d, and parameters R > 0, ! > 0,
construct a data structure that, given any query point q, reports each
R-near neighbor of q in P with probability 1 – !.
Note that the latter definition does not involve an approximation
factor. Also, unlike the case of the approximate near neighbor, here the
data structure can return many (or even all) points if a large fraction of
the data points are located close to the query point. As a result, one
cannot give an a priori bound on the running time of the algorithm.
However, as we point out later, the two problems are intimately
related. In particular, the algorithms in this article can be easily modi-
fied to solve both c-NN and the reporting problems.
2.3 Locality-Sensitive Hashing
The LSH algorithm relies on the existence of locality-sensitive hash
functions. Let H be a family of hash functions mapping !d to some
universe U. For any two points p and q, consider a process in which
we choose a function h from H uniformly at random, and analyze the
probability that h(p) = h(q). The family H is called locality sensitive
(with proper parameters) if it satisfies the following condition.
Definition 2.3 (Locality-sensitive hashing). A family H is called (R,
cR, P1, P2)-sensitive if for any two points p, q ! !
d.
• if !p – q! ≤ R then PrH [h(q) = h(p)] ≥ P1,
• if !p – q! ≥ cR then PrH [h(q) = h(p)] ≤ P2.
In order for a locality-sensitive hash (LSH) family to be useful, it has
to satisfy P1 > P2.
118 January  2008/Vol. 51, No. 1 COMMUNICATIONS OF THE ACM
Near-Optimal Hashing Algorithms for Approximate Nearest Neighbor in High Dimensions
To illustrate the concept, consider the following example. Assume
that the data points are binary, that is, each coordinate is either 0 or 1.
In addition, assume that the distance between points p and q is com-
puted according to the Hamming distance. In this case, we can use a
particularly simple family of functions H which contains all projec-
tions of the input point on one of the coordinates, that is, H contains
all functions hi from {0, 1}
d to {0, 1} such that hi(p) = pi. Choosing
one hash function h uniformly at random from H means that h(p)
returns a random coordinate of p (note, however, that different appli-
cations of h return the same coordinate of the argument).
To see that the family H is locality-sensitive with nontrivial param-
eters, observe that the probability PrH [h(q) = h(p)] is equal to the frac-
tion of coordinates on which p and q agree. Therefore, P1 = 1 – R/d,
while P2 = 1 – cR/d. As long as the approximation factor c is greater
than 1, we have P1 > P2.
2.4 The Algorithm
An LSH family H can be used to design an efficient algorithm for
approximate near neighbor search. However, one typically cannot use
H as is since the gap between the probabilities P1 and P2 could be
quite small. Instead, an amplification process is needed in order to
achieve the desired probabilities of collision. We describe this step
next, and present the complete algorithm in the Figure 2.
Given a family H of hash functions with parameters (R, cR, P1, P2)
as in Definition 2.3, we amplify the gap between the high probability
P1 and low probability P2 by concatenating several functions. In par-
ticular, for parameters k and L (specified later), we choose L functions
gj(q) = (h1, j(q),…,hk, j(q)), where ht, j (1 ≤ t ≤ k, 1 ≤ j ≤ L) are chosen
independently and uniformly at random from H. These are the actual
functions that we use to hash the data points.
The data structure is constructed by placing each point p from the
input set into a bucket gj(p), for j = 1,…,L. Since the total number of
buckets may be large, we retain only the nonempty buckets by resort-
ing to (standard) hashing3 of the values gj(p). In this way, the data
structure uses only O(nL) memory cells; note that it suffices that the
buckets store the pointers to data points, not the points themselves.
To process a query q, we scan through the buckets g1(q),…, gL(q), and
retrieve the points stored in them. After retrieving the points, we com-
3See [16] for more details on hashing.
pute their distances to the query point, and report any point that is a valid
answer to the query. Two concrete scanning strategies are possible.
1. Interrupt the search after finding the first L! points (including
duplicates) for some parameter L!.
2. Continue the search until all points from all buckets are
retrieved; no additional parameter is required.
The two strategies lead to different behaviors of the algorithms. In
particular, Strategy 1 solves the (c, R)-near neighbor problem, while
Strategy 2 solves the R-near neighbor reporting problem.
Strategy 1. It is shown in [25, 19] that the first strategy, with
L! = 3L, yields a solution to the randomized c-approximate R-near
neighbor problem, with parameters R and ! for some constant failure
probability ! < 1. To obtain this guarantee, it suffices to set L to "(n#),
where # = [19]. Note that this implies that the algorithm runs in
time proportional to n# which is sublinear in n if P1 > P2. For example,
if we use the hash functions for the binary vectors mentioned earlier,
we obtain # = 1/c [25, 19]. The exponents for other LSH families are
given in Sec tion 3.
Strategy 2. The second strategy enables us to solve the randomized
R-near neighbor reporting problem. The value of the failure probability
! depends on the choice of the parameters k and L. Conversely, for
each !, one can provide parameters k and L so that the error probabil-
ity is smaller than !. The query time is also dependent on k and L. It
could be as high as "(n) in the worst case, but, for many natural data -
sets, a proper choice of parameters results in a sublinear query time.
The details of the analysis are as follows. Let p be any R-neighbor
of q, and consider any parameter k. For any function gi, the probabil-
ity that g i(p) = g i(q) is at least P1
k. There fore, the probability that
gi(p) = gi(q) for some i = 1…L is at least 1 – (1 – P1
k)L. If we set L =
log1 – P1k ! so that (1 – P1
k)L ≤ !, then any R-neighbor of q is returned by
the algorithm with probability at least 1 – !.
How should the parameter k be chosen? Intuitively, larger values of
k lead to a larger gap between the probabilities of collision for close
points and far points; the probabilities are P1
k and P2
k, respectively (see
Figure 3 for an illustration). The benefit of this amplification is that the
hash functions are more selective. At the same time, if k is large then
P1
k is small, which means that L must be sufficiently large to ensure
that an R-near neighbor collides with the query point at least once.
ln 1/P1
ln 1/P2
Preprocessing:
1. Choose L functions gj, j = 1,…L, by setting gj = (h1, j, h2, j,…hk, j), where h1, j,…hk, j are chosen at random from the LSH family H.
2. Construct L hash tables, where, for each j = 1,…L, the j th hash table contains the dataset points hashed using the  function gj.
Query algorithm for a query point q:
1. For each j = 1, 2,…L
i) Retrieve the points from the bucket gj(q) in the  j th hash table.
ii) For each of the retrieved point, compute the distance from q to it, and report the point if it is a correct answer (cR-near
neighbor for Strategy 1, and R-near  neighbor for Strategy 2).
iii) (optional) Stop as soon as the number of reported points is more than L!.
Fig. 2. Preprocessing and query algorithms of the basic LSH algorithm.
COMMUNICATIONS OF THE ACM January  2008/Vol. 51, No. 1 119
A practical approach to choosing k was introduced in the E2LSH
package [2]. There the data structure optimized the parameter k as a
function of the dataset and a set of sample queries. Specifically, given
the dataset, a query point, and a fixed k, one can estimate precisely the
expected number of collisions and thus the time for distance compu-
tations as well as the time to hash the query into all L hash tables. The
sum of the estimates of these two terms is the estimate of the total
query time for this particular query. E2LSH chooses k that minimizes
this sum over a small set of sample queries.
3 LSH Library
To date, several LSH families have been discovered. We briefly survey
them in this section. For each family, we present the procedure of
chosing a random function from the respective LSH family as well as
its locality-sensitive properties.
Hamming distance. For binary vectors from {0, 1}d, Indyk and
Motwani [25] propose LSH function hi(p) = pi, where i ! {1,…d} is a
randomly chosen index (the sample LSH family from Sec tion 2.3).
They prove that the exponent ! is 1/c in this case.
It can be seen that this family applies directly to M-ary vectors (i.e.,
with coordinates in {1…M}) under the Hamming distance. Moreover,
a simple reduction enables the extension of this family of functions to
M-ary vectors under the l1 distance [30]. Consider any point p from
{1…M}d. The reduction proceeds by computing a binary string
Unary(p) obtained by replacing each coordinate pi by a sequence of pi
ones followed by M – pi zeros. It is easy to see that for any two M-ary
vectors p and q, the Hamming distance between Unary(p) and
Unary(p) equals the ll1 distance between p and q. Unfor tun ately, this
reduction is efficient only if M is relatively small.
l1 distance. A more direct LSH family for !d under the l1 distance
is described in [4]. Fix a real w ! R, and impose a randomly shifted
grid with cells of width w; each cell defines a bucket. More specif -
ically, pick random reals s1, s2,…sd ! [0, w) and define hs1,…sd =
(
⌊
(x1 – s1)/w
⌋
,…,
⌊
(xd – sd)/w
⌋
). The resulting exponent is equal to
! = 1/c + O(R/w).
ls distance. For the Euclidean space, [17] propose the following LSH
family. Pick a random projection of !d onto a 1-dimensional line and
chop the line into segments of length w, shifted by a random value
b ! [0, w). Formally, hr, b = (
⌊
(r·x + b)/w⌋, where the projection vector
r ! !d is constructed by picking each coordinate of r from the Gaussian
distribution. The exponent ! drops strictly below 1/c for some (carefully
chosen) finite value of w. This is the family used in the [2] package.
A generalization of this approach to ls norms for any s ! [0, 2) is
possible as well; this is done by picking the vector r from so-called
s-stable distribution. Details can be found in [17].
Jaccard. To measure the similarity between two sets A, B " U (con-
taining, e.g., words from two documents), the authors of [9, 8] utilize the
Jaccard coefficient. The Jaccard coefficient is defined as s(A, B) = .
Unlike the Hamming distance, Jaccard coefficient is a similarity meas-
ure: higher values of Jaccard coefficient indicate higher similarity of the
sets. One can obtain the corresponding distance measure by taking
d(A, B) = 1 – s(A, B). For this measure, [9, 8] propose the following
LSH family, called min-hash. Pick a random permutation on the ground
universe U. Then, define hπ(A) = min{π(a) ! a ! A}. It is not hard to
prove that the probability of collision Prπ[hπ(A) = hπ(B)] = s(A, B). See
[7] for further theoretical developments related to such hash functions.
Arccos. For vectors p, q ! !d, consider the distance measure that is
the angle between the two vectors, " (p, q) = arccos . For this
distance measure, Charikar et al. (inspired by [20]) defines the fol-
lowing LSH family [14]. Pick a random unit-length vector u ! !d and
define hu(p) = sign(u·p). The hash function can also be viewed as par-
titioning the space into two half-spaces by a randomly chosen hyperplane.
Here, the probability of collision is Pru[hu(p) = hu(q)] = 1 – "(p, q)/π.
(a) The probability that gj (p) = gj ( q) for a fixed j. Graphs are
shown for several values of k. In particular, the blue function
(k = 1) is the probability of collision of points p and q under a sin-
gle random hash function h from the LSH family.
(b) The probability that gj(p) = gj(q) for some j = 1…L. The prob-
abilities are shown for two values of k and several values of L.
Note that the slopes are sharper when k is higher.
Fig. 3. The graphs of the probability of collision of points p and q as a function of the distance between p and q for different  values
of k and L. The points p and q are d = 100  dimensional binary vectors under the Hamming distance. The LSH family H is the one
described in Section 2.3.
!A # B!
!A $ B!
p·q"#p #·#q #$
120 January  2008/Vol. 51, No. 1 COMMUNICATIONS OF THE ACM
Near-Optimal Hashing Algorithms for Approximate Nearest Neighbor in High Dimensions
l2 distance on a sphere. Terasawa and Tanaka [37] propose an LSH
algorithm specifically designed for points that are on a unit hyper-
sphere in the Euclidean space. The idea is to consider a regular poly-
tope, orthoplex for example, inscribed into the hypersphere and
rotated at random. The hash function then maps a point on the hyper-
sphere into the closest polytope vertex lying on the hypersphere. Thus,
the buckets of the hash function are the Voronoi cells of the polytope
vertices lying on the hypersphere. [37] obtain exponent ! that is an
improvement over [17] and the Leech lattice approach of [3].
4 Near-Optimal LSH Functions for
Euclidean Distance
In this section we present a new LSH family, yielding an algorithm
with query time exponent !(c) = 1/c2 + O(log log n / log1/3 n). For
large enough n, the value of !(c) tends to 1/c2. This significantly
improves upon the earlier running time of [17]. In particular, for c = 2,
our exponent tends to 0.25, while the exponent in [17] was around
0.45. More over, a recent paper [31] shows that hashing-based algo -
rithms (as described in Sec tion 2.3) cannot achieve ! < 0.462/c2.
Thus, the running time exponent of our algorithm is essentially opti-
mal, up to a constant factor.
We obtain our result by carefully designing a family of locality-sen-
sitive hash functions in l2. The starting point of our construction is the
line partitioning method of [17]. There, a point p was mapped into !1
using a random projection. Then, the line !1 was partitioned into
intervals of length w, where w is a parameter. The hash function for p
returned the index of the interval containing the projection of p.
An analysis in [17] showed that the query time exponent has an
interesting dependence on the parameter w. If w tends to infinity, the
exponent tends to 1/c, which yields no improvement over [25, 19].
How ever, for small values of w, the exponent lies slightly below 1/c. In
fact, the unique minimum exists for each c.
In this article, we utilize a “multi-dimensional version” of the afore-
mentioned approach. Specifically, we first perform random projection
into ! t, where t is super-constant, but relatively small (i.e., t = o(log n)).
Then we partition the space ! t into cells. The hash function function
returns the index of the cell which contains projected point p.
The partitioning of the space ! t is somewhat more involved than
its one-dimensional counterpart. First, observe that the natural idea of
partitioning using a grid does not work. This is because this process
roughly corresponds to hashing using concatenation of several one-
dimensional functions (as in [17]). Since the LSH algorithms perform
such concatenation anyway, grid partitioning does not result in any
improvement. Instead, we use the method of “ball partitioning”, intro-
duced in [15], in the context of embeddings into tree metrics. The par-
titioning is obtained as follows. We create a sequence of balls B1, B2…,
each of radius w, with centers chosen independently at random. Each
ball Bi then defines a cell, containing points Bi\!j< iBj.
In order to apply this method in our context, we need to take care
of a few issues. First, locating a cell containing a given point could
require enumeration of all balls, which would take an unbounded
amount of time. Instead, we show that one can simulate this proce-
dure by replacing each ball by a grid of balls. It is not difficult then to
observe that a finite (albeit exponential in t) number U of such grids
suffices to cover all points in ! t. An example of such partitioning (for
t = 2 and U = 5) is given in Figure 4.
Fig. 4. An illustration of the the ball partitioning of 
the 2-dimensional space. 
The second and the main issue is the choice of w. Again, it turns
out that for large w, the method yields only the exponent of 1/c.
Specifically, it was shown in [15] that for any two points p, q " ! t, the
probability that the partitioning separates p and q is at most
O !"#t ·$p – q$/w%. This formula can be showed to be tight for the range
of w where it makes sense as a lower bound, that is, for w =
" !"#t ·$p – q$%. However, as long as the separation probability depends
linearly on the distance between p and q, the exponent ! is still equal
to 1/c. Fortunately, a more careful analysis4 shows that, as in the one-
dimensional case, the minimum is achieved for finite w. For that value
of w, the exponent tends to 1/c2 as t tends to infinity.
5 Related Work
In this section, we give a brief overview of prior work in the spirit of
the algorithms considered in this article. We give only high-level sim-
plified descriptions of the algorithms to avoid area-specific terminol-
ogy. Some of the papers considered a closely related problem of finding
all close pairs of points in a dataset. For simplicity, we translate them
into the near neighbor framework since they can be solved by per-
forming essentialy n separate near neighbor queries.
Hamming distance. Several papers investigated multi-index hashing-
based algorithms for retrieving similar pairs of vectors with respect to
the Hamming distance. Typically, the hash functions were projecting
the vectors on some subset of the coordinates {1…d} as in the exam-
ple from an earlier section. In some papers [33, 21], the authors con-
sidered the probabilistic model where the data points are chosen
uniformly at random, and the query point is a random point close to one
of the points in the dataset. A different approach [26] is to assume that
the dataset is arbitrary, but almost all points are far from the query
point. Finally, the paper [12] proposed an algorithm which did not make
any assumption on the input. The analysis of the algorithm was akin to
the analysis sketched at the end of section 2.4: the parameters k and L
were chosen to achieve desired level of sensitivity and accuracy.
Set intersection measure. To measure the similarity between two sets
A and B, the authors of [9, 8] considered the Jaccard coefficient s(A, B),
proposing a family of hash functions h(A) such that Pr[h(A) = h(B)] =
s(A, B) (presented in detail in Sec tion 3). Their main motivation was to 
4Refer to [3] for more details.
COMMUNICATIONS OF THE ACM January  2008/Vol. 51, No. 1 121
construct short similarity-preserving “sketches” of sets, obtained by
mapping each set A to a sequence !h1(A), ..., hk(A)". In section 5.3 of
their paper, they briefly mention an algorithm similar to Strategy 2
described at the end of the Sec tion 2.4. One of the differences is that,
in their approach, the functions hi are sampled without replacement,
which made it more difficult to handle small sets.
Acknowledgement
This work was supported in part by NSF CAREER grant CCR-0133849
and David and Lucille Packard Fellowship.
References
1. Ailon, N. and Chazelle, B. 2006. Approximate nearest neighbors
and the Fast Johnson-Lindenstrauss Transform. In Proceedings of
the Symposium on Theory of Computing.
2. Andoni, A. and Indyk, P. 2004. E2lsh: Exact Euclidean locality-
sensitive hashing. http://web.mit.edu/andoni/www/LSH/.
3. Andoni, A. and Indyk, P. 2006. Near-optimal hashing algorithms
for approximate nearest neighbor in high dimensions. In Proceed-
ings of the Symposium on Foundations of Computer Science.
4. Andoni, A. and Indyk, P. 2006. Efficient algorithms for substring
near neighbor problem. In Proceedings of the ACM-SIAM Sympo-
sium on Discrete Algorithms. 1203–1212.
5. Arya, S., Mount, D. M., Netanyahu, N. S., Silverman, R., and Wu,
A. 1994. An optimal algorithm for approximate nearest neighbor
searching. In Proceedings of the ACM-SIAM Symposium on Dis-
crete Algorithms. 573–582.
6. Bentley, J. L. 1975. Multidimensional binary search trees used for
associative searching. Comm. ACM 18, 509–517.
7. Broder, A., Charikar, M., Frieze, A., and Mitzenmacher, M. 1998.
Min-wise independent permutations. J. Comput. Sys. Sci.
8. Broder, A., Glassman, S., Manasse, M., and Zweig, G. 1997. Syntac-
tic clustering of the web. In Proceedings of the 6th International
World Wide Web Conference. 391–404.
9. Broder, A. 1997. On the resemblance and containment of docu-
ments. In Proceedings of Compression and Complexity of Se-
quences. 21–29.
10. Buhler, J. 2001. Efficient large-scale sequence comparison by lo-
cality-sensitive hashing. Bioinform. 17, 419–428.
11. Buhler, J. and Tompa, M. 2001. Finding motifs using random
projections. In Proceedings of the Annual International Conference
on Computational Molecular Biology (RECOMB1).
12. Califano, A. and Rigoutsos, I. 1993. Flash: A fast look-up algo-
rithm for string homology. In Proceedings of the IEE Conference
on Computer Vision and Pattern Recognition (CVPR).
13. Chakrabarti, A. and Regev, O. 2004. An optimal randomised cell
probe lower bounds for approximate nearest neighbor searching. In
Proceedings of the Symposium on Foundations of Computer Science.
14. Charikar, M. 2002. Similarity estimation techniques from round-
ing. In Proceedings of the Symposium on Theory of Computing.
15. Charikar, M., Chekuri, C., Goel, A., Guha, S., and Plotkin, S. 1998.
Approximating a finite metric by a small number of tree metrics.
In Proceedings of the Symposium on Foundations of Computer Science.
16. Cormen, T. H., Leiserson, C. E., Rivest, R. L., and Stein, C. 2001.
Introduct. Algorithms. 2nd Ed. MIT Press.
17. Datar, M., Immorlica, N., Indyk, P., and Mirrokni, V. 2004. Locality-
sensitive hashing scheme based on p-stable distributions.In Proceed-
ings of the ACM Symposium on Computational Geometry.
18. Dutta, D., Guha, R., Jurs, C., and Chen, T. 2006. Scalable parti -
tioning and exploration of chemical spaces using geometric hashing.
J. Chem. Inf. Model. 46.
19. Gionis, A., Indyk, P., and Motwani, R. 1999. Similarity search in
high dimensions via hashing. In Proceedings of the International
Conference on Very Large Databases.
20. Goemans, M. and Williamson, D. 1995. Improved approximation
algorithms for maximum cut and satisfiability problems using
semidefinite programming. J. ACM 42. 1115–1145.
21. Greene, D., Parnas, M., and Yao, F. 1994. Multi-index hashing for in-
formation retrieval. In Proceedings of the Symposium on Founda-
tions of Computer Science. 722–731.
22. Har-Peled, S. 2001. A replacement for voronoi diagrams of near
linear size. In Proceedings of the Symposium on Foundations of
Computer Science.
23. Haveliwala, T., Gionis, A., and Indyk, P. 2000. Scalable techniques
for clustering the web. WebDB Workshop.
24. Indyk, P. 2003. Nearest neighbors in high-dimensional spaces. In
Handbook of Discrete and Computational Geometry. CRC Press.
25. Indyk, P. and Motwani, R. 1998. Approximate nearest neighbor:
 Towards removing the curse of dimensionality. In Proceedings of
the Symposium on Theory of Computing.
26. Karp, R. M., Waarts, O., and Zweig, G. 1995. The bit vector inter-
section problem. In Proceedings of the Symposium on Foundations
of Computer Science. pages 621–630.
27. Kleinberg, J. 1997. Two algorithms for nearest-neighbor search in
high dimensions. In Proceedings of the Symposium on Theory of
Computing.
28. Krauthgamer, R. and Lee, J. R. 2004. Navigating nets: Simple
 algorithms for proximity search. In Proceedings of the ACM-SIAM
Symposium on Discrete Algorithms.
29. Kushilevitz, E., Ostrovsky, R., and Rabani, Y. 1998. Efficient search
for approximate nearest neighbor in high dimensional spaces. In
Proceedings of the Symposium on Theory of Computing. 614–623.
30. Linial, N., London, E., and Rabinovich, Y. 1994. The geometry of
graphs and some of its algorithmic applications. In Proceedings of
the Symposium on Foundations of Computer Science. 577–591.
31. Motwani, R., Naor, A., and Panigrahy, R. 2006. Lower bounds on
locality sensitive hashing. In Proceedings of the ACM Symposium
on Computational Geometry.
32. Panigrahy, R. 2006. Entropy-based nearest neighbor algorithm in
high dimensions. In Proceedings of the ACM-SIAM Symposium on
Discrete Algorithms.
33. Paturi, R., Rajasekaran, S., and Reif, J.The light bulb problem.
Inform. Comput. 117, 2, 187–192.
34. Ravichandran, D., Pantel, P., and Hovy, E. 2005. Randomized al-
gorithms and nlp: Using locality sensitive hash functions for high
speed noun clustering. In Proceedings of the Annual Meeting of
the Association of Computational Linguistics.
35. Samet, H. 2006. Foundations of Multidimensional and Metric
Data Structures. Elsevier, 2006.
36. Shakhnarovich, G., Darrell, T., and Indyk, P. Eds. Nearest Neigh-
bor Methods in Learning and Vision. Neural Processing Informa-
tion Series, MIT Press.
37. Terasawa, T.  and Tanaka, Y. 2007. Spherical lsh for approximate
nearest neighbor search on unit hypersphere. In Proceedings of
the Workshop on Algorithms and Data Structures.
122 January  2008/Vol. 51, No. 1 COMMUNICATIONS OF THE ACM

