Journal of Machine Learning Research 11 (2010) 19-60 Submitted 7/09; Revised 11/09; Published 1/10
Online Learning for Matrix Factorization and Sparse Coding
Julien Mairal JULIEN.MAIRAL@INRIA.FR
Francis Bach FRANCIS.BACH@INRIA.FR
INRIA - WILLOW Project-Team
Laboratoire d’Informatique de l’Ecole Normale Supérieure (INRIA/ENS/CNRS UMR 8548)
23, avenue d’Italie 75214 Paris CEDEX 13, France
Jean Ponce JEAN.PONCE@ENS.FR
Ecole Normale Supérieure - WILLOW Project-Team
Laboratoire d’Informatique de l’Ecole Normale Supérieure (INRIA/ENS/CNRS UMR 8548)
45, rue d’Ulm 75230 Paris CEDEX 05, France
Guillermo Sapiro GUILLE@UMN.EDU
Department of Electrical and Computer Engineering
University of Minnesota
200 Union Street SE, Minneapolis, MN 55455, USA
Editor: Hui Zou
Abstract
Sparse coding—that is, modelling data vectors as sparse linear combinations of basis elements—is
widely used in machine learning, neuroscience, signal processing, and statistics. This paper fo-
cuses on the large-scale matrix factorization problem that consists of learning the basis set in order
to adapt it to specific data. Variations of this problem include dictionary learning in signal pro-
cessing, non-negative matrix factorization and sparse principal component analysis. In this paper,
we propose to address these tasks with a new online optimization algorithm, based on stochastic
approximations, which scales up gracefully to large data sets with millions of training samples, and
extends naturally to various matrix factorization formulations, making it suitable for a wide range
of learning problems. A proof of convergence is presented, along with experiments with natural
images and genomic data demonstrating that it leads to state-of-the-art performance in terms of
speed and optimization for both small and large data sets.
Keywords: basis pursuit, dictionary learning, matrix factorization, online learning, sparse cod-
ing, sparse principal component analysis, stochastic approximations, stochastic optimization, non-
negative matrix factorization
1. Introduction
The linear decomposition of a signal using a few atoms of a learned dictionary instead of a pre-
defined one—based on wavelets (Mallat, 1999) for example—has recently led to state-of-the-art
results in numerous low-level signal processing tasks such as image denoising (Elad and Aharon,
2006; Mairal et al., 2008b), texture synthesis (Peyré, 2009) and audio processing (Grosse et al.,
2007; Févotte et al., 2009; Zibulevsky and Pearlmutter, 2001), as well as higher-level tasks such as
image classification (Raina et al., 2007; Mairal et al., 2008a, 2009b; Bradley and Bagnell, 2009;
Yang et al., 2009), showing that sparse learned models are well adapted to natural signals. Unlike
decompositions based on principal component analysis and its variants, these models do not im-
c©2010 Julien Mairal, Francis Bach, Jean Ponce and Guillermo Sapiro.
MAIRAL, BACH, PONCE AND SAPIRO
pose that the basis vectors be orthogonal, allowing more flexibility to adapt the representation to
the data.1 In machine learning and statistics, slightly different matrix factorization problems are
formulated in order to obtain a few interpretable basis elements from a set of data vectors. This in-
cludes non-negative matrix factorization and its variants (Lee and Seung, 2001; Hoyer, 2002, 2004;
Lin, 2007), and sparse principal component analysis (Zou et al., 2006; d’Aspremont et al., 2007,
2008; Witten et al., 2009; Zass and Shashua, 2007). As shown in this paper, these problems have
strong similarities; even though we first focus on the problem of dictionary learning, the algorithm
we propose is able to address all of them. While learning the dictionary has proven to be critical to
achieve (or improve upon) state-of-the-art results in signal and image processing, effectively solv-
ing the corresponding optimization problem is a significant computational challenge, particularly in
the context of large-scale data sets that may include millions of training samples. Addressing this
challenge and designing a generic algorithm which is capable of efficiently handling various matrix
factorization problems, is the topic of this paper.
Concretely, consider a signal x in Rm. We say that it admits a sparse approximation over a
dictionary D in Rm×k, with k columns referred to as atoms, when one can find a linear combination
of a “few” atoms from D that is “close” to the signal x. Experiments have shown that modelling a
signal with such a sparse decomposition (sparse coding) is very effective in many signal processing
applications (Chen et al., 1999). For natural images, predefined dictionaries based on various types
of wavelets (Mallat, 1999) have also been used for this task. However, learning the dictionary
instead of using off-the-shelf bases has been shown to dramatically improve signal reconstruction
(Elad and Aharon, 2006). Although some of the learned dictionary elements may sometimes “look
like” wavelets (or Gabor filters), they are tuned to the input images or signals, leading to much better
results in practice.
Most recent algorithms for dictionary learning (Olshausen and Field, 1997; Engan et al., 1999;
Lewicki and Sejnowski, 2000; Aharon et al., 2006; Lee et al., 2007) are iterative batch procedures,
accessing the whole training set at each iteration in order to minimize a cost function under some
constraints, and cannot efficiently deal with very large training sets (Bottou and Bousquet, 2008),
or dynamic training data changing over time, such as video sequences. To address these issues, we
propose an online approach that processes the signals, one at a time, or in mini-batches. This is
particularly important in the context of image and video processing (Protter and Elad, 2009; Mairal
et al., 2008c), where it is common to learn dictionaries adapted to small patches, with training
data that may include several millions of these patches (roughly one per pixel and per frame). In
this setting, online techniques based on stochastic approximations are an attractive alternative to
batch methods (see, e.g., Bottou, 1998; Kushner and Yin, 2003; Shalev-Shwartz et al., 2009). For
example, first-order stochastic gradient descent with projections on the constraint set (Kushner and
Yin, 2003) is sometimes used for dictionary learning (see Aharon and Elad, 2008; Kavukcuoglu
et al., 2008 for instance). We show in this paper that it is possible to go further and exploit the
specific structure of sparse coding in the design of an optimization procedure tuned to this problem,
with low memory consumption and lower computational cost than classical batch algorithms. As
demonstrated by our experiments, it scales up gracefully to large data sets with millions of training
samples, is easy to use, and is faster than competitive methods.
The paper is structured as follows: Section 2 presents the dictionary learning problem. The
proposed method is introduced in Section 3, with a proof of convergence in Section 4. Section 5
1. Note that the terminology “basis” is slightly abusive here since the elements of the dictionary are not necessarily
linearly independent and the set can be overcomplete—that is, have more elements than the signal dimension.
20
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
extends our algorithm to various matrix factorization problems that generalize dictionary learning,
and Section 6 is devoted to experimental results, demonstrating that our algorithm is suited to a wide
class of learning problems.
1.1 Contributions
This paper makes four main contributions:
• We cast in Section 2 the dictionary learning problem as the optimization of a smooth non-
convex objective function over a convex set, minimizing the (desired) expected cost when the
training set size goes to infinity, and propose in Section 3 an iterative online algorithm that
solves this problem by efficiently minimizing at each step a quadratic surrogate function of
the empirical cost over the set of constraints. This method is shown in Section 4 to converge
almost surely to a stationary point of the objective function.
• As shown experimentally in Section 6, our algorithm is significantly faster than previous ap-
proaches to dictionary learning on both small and large data sets of natural images. To demon-
strate that it is adapted to difficult, large-scale image-processing tasks, we learn a dictionary
on a 12-Megapixel photograph and use it for inpainting—that is, filling some holes in the
image.
• We show in Sections 5 and 6 that our approach is suitable to large-scale matrix factorization
problems such as non-negative matrix factorization and sparse principal component analysis,
while being still effective on small data sets.
• To extend our algorithm to several matrix factorization problems, we propose in Appendix
B efficient procedures for projecting onto two convex sets, which can be useful for other
applications that are beyond the scope of this paper.
1.2 Notation
We define for p≥ 1 the ℓp norm of a vector x in Rm as ||x||p △= (∑mi=1 |x[i]|p)1/p, where x[i] denotes
the i-th coordinate of x and ||x||∞ △= maxi=1,...,m |x[i]|= limp→∞ ||x||p. We also define the ℓ0 pseudo-
norm as the sparsity measure which counts the number of nonzero elements in a vector:2 ||x||0 △=
#{i s.t. x[i] 6= 0}= limp→0+(∑mi=1 |x[i]|p). We denote the Frobenius norm of a matrix X in Rm×n by
||X||F △= (∑mi=1 ∑nj=1 X[i, j]2)1/2. For a sequence of vectors (or matrices) xt and scalars ut , we write
xt = O(ut) when there exists a constant K > 0 so that for all t, ||xt ||2 ≤ Kut . Note that for finite-
dimensional vector spaces, the choice of norm is essentially irrelevant (all norms are equivalent).
Given two matrices A in Rm1×n1 and B in Rm2×n2 , A⊗B denotes the Kronecker product between A
and B, defined as the matrix in Rm1m2×n1n2 , defined by blocks of sizes m2×n2 equal to A[i, j]B. For
more details and properties of the Kronecker product, see Golub and Van Loan (1996), and Magnus
and Neudecker (1999).
2. Note that it would be more proper to write ||x||00 instead of ||x||0 to be consistent with the traditional notation ||x||p.
However, for the sake of simplicity, we will keep this notation unchanged.
21
MAIRAL, BACH, PONCE AND SAPIRO
2. Problem Statement
Classical dictionary learning techniques for sparse representation (Olshausen and Field, 1997; En-
gan et al., 1999; Lewicki and Sejnowski, 2000; Aharon et al., 2006; Lee et al., 2007) consider a
finite training set of signals X = [x1, . . . ,xn] in Rm×n and optimize the empirical cost function
fn(D)
△
=
1
n
n
∑
i=1
ℓ(xi,D), (1)
where D in Rm×k is the dictionary, each column representing a basis vector, and ℓ is a loss function
such that ℓ(x,D) should be small if D is “good” at representing the signal x in a sparse fashion.
The number of samples n is usually large, whereas the signal dimension m is relatively small, for
example, m = 100 for 10×10 image patches, and n≥ 100,000 for typical image processing appli-
cations. In general, we also have k≪ n (e.g., k = 200 for n = 100,000), but each signal only uses a
few elements of D in its representation, say 10 for instance. Note that, in this setting, overcomplete
dictionaries with k > m are allowed. As others (see for example Lee et al., 2007), we define ℓ(x,D)
as the optimal value of the ℓ1 sparse coding problem:
ℓ(x,D) △= min
α∈Rk
1
2
||x−Dα||22 +λ||α||1, (2)
where λ is a regularization parameter. This problem is also known as basis pursuit (Chen et al.,
1999), or the Lasso (Tibshirani, 1996).3 It is well known that ℓ1 regularization yields a sparse
solution for α, but there is no direct analytic link between the value of λ and the corresponding
effective sparsity ||α||0. To prevent D from having arbitrarily large values (which would lead to
arbitrarily small values of α), it is common to constrain its columns d1, . . . ,dk to have an ℓ2-norm
less than or equal to one. We will call C the convex set of matrices verifying this constraint:
C
△
= {D ∈ Rm×k s.t. ∀ j = 1, . . . ,k, dTj d j ≤ 1}.
Note that the problem of minimizing the empirical cost fn(D) is not convex with respect to D. It
can be rewritten as a joint optimization problem with respect to the dictionary D and the coefficients
α = [α1, . . . ,αn] in Rk×n of the sparse decompositions, which is not jointly convex, but convex with
respect to each of the two variables D and α when the other one is fixed:
min
D∈C ,α∈Rk×n
n
∑
i=1
(1
2
||xi−Dαi||22 +λ||αi||1
)
. (4)
This can be rewritten as a matrix factorization problem with a sparsity penalty:
min
D∈C ,α∈Rk×n
1
2
||X−Dα||2F +λ||α||1,1,
3. To be more precise, the original formulation of the Lasso is a constrained version of Eq. (2), with a constraint on the
ℓ1-norm of α:
min
α∈Rk
1
2
||x−Dα||22 s.t. ||α||1 ≤ T. (3)
Both formulations are equivalent in the sense that for every λ > 0 (respectively every T > 0), there exists a scalar T
(respectively λ) so that Equations (2) and (3) admit the same solutions.
22
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
where, as before, X = [x1, . . . ,xn] is the matrix of data vectors, and ||α||1,1 denotes the ℓ1 norm of
the matrix α—that is, the sum of the magnitude of its coefficients. A natural approach to solving
this problem is to alternate between the two variables, minimizing over one while keeping the other
one fixed, as proposed by Lee et al. (2007) (see also Engan et al. 1999 and Aharon et al. 2006, who
use ℓ0 rather than ℓ1 penalties, or Zou et al. 2006 for the problem of sparse principal component
analysis).4 Since the computation of the coefficients vectors αi dominates the cost of each iteration
in this block-coordinate descent approach, a second-order optimization technique can be used to
accurately estimate D at each step when α is fixed.
As pointed out by Bottou and Bousquet (2008), however, one is usually not interested in the
minimization of the empirical cost fn(D) with high precision, but instead in the minimization of the
expected cost
f (D) △= Ex[ℓ(x,D)] = lim
n→∞
fn(D) a.s.,
where the expectation (which is supposed finite) is taken relative to the (unknown) probability dis-
tribution p(x) of the data.5 In particular, given a finite training set, one should not spend too much
effort on accurately minimizing the empirical cost, since it is only an approximation of the ex-
pected cost. An “inaccurate” solution may indeed have the same or better expected cost than a
“well-optimized” one. Bottou and Bousquet (2008) further show that stochastic gradient algorithms,
whose rate of convergence is very poor in conventional optimization terms, may in fact in certain
settings be shown both theoretically and empirically to be faster in reaching a solution with low
expected cost than second-order batch methods. With large training sets, the risk of overfitting is
lower, but classical optimization techniques may become impractical in terms of speed or memory
requirements.
In the case of dictionary learning, the classical projected first-order projected stochastic gradient
descent algorithm (as used by Aharon and Elad 2008; Kavukcuoglu et al. 2008 for instance) consists
of a sequence of updates of D:
Dt = ΠC
[
Dt−1−δt∇Dℓ(xt ,Dt−1)
]
,
where Dt is the estimate of the optimal dictionary at iteration t, δt is the gradient step, ΠC is the
orthogonal projector onto C , and the vectors xt are i.i.d. samples of the (unknown) distribution p(x).
Even though it is often difficult to obtain such i.i.d. samples, the vectors xt are in practice obtained
by cycling on a randomly permuted training set. As shown in Section 6, we have observed that
this method can be competitive in terms of speed compared to batch methods when the training set
is large and when δt is carefully chosen. In particular, good results are obtained using a learning
rate of the form δt
△
= a/(t + b), where a and b have to be well chosen in a data set-dependent way.
Note that first-order stochastic gradient descent has also been used for other matrix factorization
problems (see Koren et al., 2009 and references therein).
The optimization method we present in the next section falls into the class of online algorithms
based on stochastic approximations, processing one sample at a time (or a mini-batch), but further
exploits the specific structure of the problem to efficiently solve it by sequentially minimizing a
quadratic local surrogate of the expected cost. As shown in Section 3.5, it uses second-order infor-
mation of the cost function, allowing the optimization without any explicit learning rate tuning.
4. In our setting, as in Lee et al. (2007), we have preferred to use the convex ℓ1 norm, that has empirically proven to be
better behaved in general than the ℓ0 pseudo-norm for dictionary learning.
5. We use “a.s.” to denote almost sure convergence.
23
MAIRAL, BACH, PONCE AND SAPIRO
3. Online Dictionary Learning
We present in this section the basic components of our online algorithm for dictionary learning
(Sections 3.1–3.3), as well as a few minor variants which speed up our implementation in practice
(Section 3.4) and an interpretation in terms of a Kalman algorithm (Section 3.5).
3.1 Algorithm Outline
Our procedure is summarized in Algorithm 1. Assuming that the training set is composed of
i.i.d. samples of a distribution p(x), its inner loop draws one element xt at a time, as in stochastic
gradient descent, and alternates classical sparse coding steps for computing the decomposition αt
of xt over the dictionary Dt−1 obtained at the previous iteration, with dictionary update steps where
the new dictionary Dt is computed by minimizing over C the function
f̂t(D)
△
=
1
t
t
∑
i=1
(1
2
||xi−Dαi||22 +λ||αi||1
)
, (5)
and the vectors αi for i < t have been computed during the previous steps of the algorithm. The
motivation behind this approach is twofold:
• The function f̂t , which is quadratic in D, aggregates the past information with a few sufficient
statistics obtained during the previous steps of the algorithm, namely the vectors αi, and it is
easy to show that it upperbounds the empirical cost ft(Dt) from Eq. (1). One key aspect of
our convergence analysis will be to show that f̂t(Dt) and ft(Dt) converge almost surely to the
same limit, and thus that f̂t acts as a surrogate for ft .
• Since f̂t is close to f̂t−1 for large values of t, so are Dt and Dt−1, under suitable assumptions,
which makes it efficient to use Dt−1 as warm restart for computing Dt .
3.2 Sparse Coding
The sparse coding problem of Eq. (2) with fixed dictionary is an ℓ1-regularized linear least-squares
problem. A number of recent methods for solving this type of problems are based on coordinate
descent with soft thresholding (Fu, 1998; Friedman et al., 2007; Wu and Lange, 2008). When the
columns of the dictionary have low correlation, we have observed that these simple methods are
very efficient. However, the columns of learned dictionaries are in general highly correlated, and
we have empirically observed that these algorithms become much slower in this setting. This has
led us to use instead the LARS-Lasso algorithm, a homotopy method (Osborne et al., 2000; Efron
et al., 2004) that provides the whole regularization path—that is, the solutions for all possible values
of λ. With an efficient Cholesky-based implementation (see Efron et al., 2004; Zou and Hastie,
2005) for brief descriptions of such implementations), it has proven experimentally at least as fast
as approaches based on soft thresholding, while providing the solution with a higher accuracy and
being more robust as well since it does not require an arbitrary stopping criterion.
3.3 Dictionary Update
Our algorithm for updating the dictionary uses block-coordinate descent with warm restarts (see
Bertsekas, 1999). One of its main advantages is that it is parameter free and does not require any
24
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Algorithm 1 Online dictionary learning.
Require: x ∈ Rm ∼ p(x) (random variable and an algorithm to draw i.i.d samples of p), λ ∈ R
(regularization parameter), D0 ∈ Rm×k (initial dictionary), T (number of iterations).
1: A0 ∈ Rk×k← 0, B0 ∈ Rm×k← 0 (reset the “past” information).
2: for t = 1 to T do
3: Draw xt from p(x).
4: Sparse coding: compute using LARS
αt
△
= argmin
α∈Rk
1
2
||xt−Dt−1α||22 +λ||α||1.
5: At ← At−1 +αtαTt .
6: Bt ← Bt−1 +xtαTt .
7: Compute Dt using Algorithm 2, with Dt−1 as warm restart, so that
Dt
△
= argmin
D∈C
1
t
t
∑
i=1
(1
2
||xi−Dαi||22 +λ||αi||1
)
,
= argmin
D∈C
1
t
(1
2
Tr(DT DAt)−Tr(DT Bt)
)
. (6)
8: end for
9: Return DT (learned dictionary).
Algorithm 2 Dictionary Update.
Require: D = [d1, . . . ,dk] ∈ Rm×k (input dictionary),
A = [a1, . . . ,ak] ∈ Rk×k
B = [b1, . . . ,bk] ∈ Rm×k
1: repeat
2: for j = 1 to k do
3: Update the j-th column to optimize for (6):
u j←
1
A[ j, j]
(b j−Da j)+d j,
d j←
1
max(||u j||2,1)
u j.
(7)
4: end for
5: until convergence
6: Return D (updated dictionary).
learning rate tuning. Moreover, the procedure does not require to store all the vectors xi and αi, but
only the matrices At = ∑ti=1 αiαTi in Rk×k and Bt = ∑
t
i=1 xiαTi in Rm×k. Concretely, Algorithm 2
sequentially updates each column of D. A simple calculation shows that solving (6) with respect
to the j-th column d j, while keeping the other ones fixed under the constraint dTj d j ≤ 1, amounts
to an orthogonal projection of the vector u j defined in Eq. (7), onto the constraint set, namely
25
MAIRAL, BACH, PONCE AND SAPIRO
the ℓ2-ball here, which is solved by Eq. (7). Since the convex optimization problem (6) admits
separable constraints in the updated blocks (columns), convergence to a global optimum is guaran-
teed (Bertsekas, 1999). In practice, the vectors αi are sparse and the coefficients of the matrix At
are often concentrated on the diagonal, which makes the block-coordinate descent more efficient.6
After a few iterations of our algorithm, using the value of Dt−1 as a warm restart for computing Dt
becomes effective, and a single iteration of Algorithm 2 has empirically found to be sufficient to
achieve convergence of the dictionary update step. Other approaches have been proposed to up-
date D: For instance, Lee et al. (2007) suggest using a Newton method on the dual of Eq. (6), but
this requires inverting a k× k matrix at each Newton iteration, which is impractical for an online
algorithm.
3.4 Optimizing the Algorithm
We have presented so far the basic building blocks of our algorithm. This section discusses a few
simple improvements that significantly enhance its performance.
3.4.1 HANDLING FIXED-SIZE DATA SETS
In practice, although it may be very large, the size of the training set often has a predefined finite
size (of course this may not be the case when the data must be treated on the fly like a video stream
for example). In this situation, the same data points may be examined several times, and it is very
common in online algorithms to simulate an i.i.d. sampling of p(x) by cycling over a randomly
permuted training set (see Bottou and Bousquet, 2008 and references therein). This method works
experimentally well in our setting but, when the training set is small enough, it is possible to further
speed up convergence: In Algorithm 1, the matrices At and Bt carry all the information from the past
coefficients α1, . . . ,αt . Suppose that at time t0, a signal x is drawn and the vector αt0 is computed. If
the same signal x is drawn again at time t > t0, then it is natural to replace the “old” information αt0
by the new vector αt in the matrices At and Bt—that is, At ← At−1 + αtαTt −αt0αTt0 and Bt ←
Bt−1 +xtαTt −xtαTt0 . In this setting, which requires storing all the past coefficients αt0 , this method
amounts to a block-coordinate descent for the problem of minimizing Eq. (4). When dealing with
large but finite sized training sets, storing all coefficients αi is impractical, but it is still possible to
partially exploit the same idea, by removing the information from At and Bt that is older than two
epochs (cycles through the data), through the use of two auxiliary matrices A′t and B
′
t of size k× k
and m×k respectively. These two matrices should be built with the same rules as At and Bt , except
that at the end of an epoch, At and Bt are respectively replaced by A′t and B
′
t , while A
′
t and B
′
t are
set to 0. Thanks to this strategy, At and Bt do not carry any coefficients αi older than two epochs.
3.4.2 SCALING THE “PAST” DATA
At each iteration, the “new” information αt that is added to the matrices At and Bt has the same
weight as the “old” one. A simple and natural modification to the algorithm is to rescale the “old”
information so that newer coefficients αt have more weight, which is classical in online learning.
For instance, Neal and Hinton (1998) present an online algorithm for EM, where sufficient statistics
are aggregated over time, and an exponential decay is used to forget out-of-date statistics. In this
6. We have observed that this is true when the columns of D are not too correlated. When a group of columns in D are
highly correlated, the coefficients of the matrix At concentrate instead on the corresponding principal submatrices
of At .
26
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
paper, we propose to replace lines 5 and 6 of Algorithm 1 by
At ← βtAt−1 +αtαTt ,
Bt ← βtBt−1 +xtαTt ,
where βt
△
=
(
1− 1t
)ρ
, and ρ is a new parameter. In practice, one can apply this strategy after a few
iterations, once At is well-conditioned. Tuning ρ improves the convergence rate, when the training
sets are large, even though, as shown in Section 6, it is not critical. To understand better the effect
of this modification, note that Eq. (6) becomes
Dt
△
= argmin
D∈C
1
∑tj=1( j/t)ρ
t
∑
i=1
( i
t
)ρ(1
2
||xi−Dαi||22 +λ||αi||1
)
,
= argmin
D∈C
1
∑tj=1( j/t)ρ
(1
2
Tr(DT DAt)−Tr(DT Bt)
)
.
When ρ = 0, we obtain the original version of the algorithm. Of course, different strategies and
heuristics could also be investigated. In practice, this parameter ρ is useful for large data sets only
(n ≥ 100000). For smaller data sets, we have not observed a better performance when using this
extension.
3.4.3 MINI-BATCH EXTENSION
In practice, we can also improve the convergence speed of our algorithm by drawing η > 1 signals
at each iteration instead of a single one, which is a classical heuristic in stochastic gradient descent
algorithms. In our case, this is further motivated by the fact that the complexity of computing η
vectors αi is not linear in η. A Cholesky-based implementation of LARS-Lasso for decomposing a
single signal has a complexity of O(kms+ks2), where s is the number of nonzero coefficients. When
decomposing η signals, it is possible to pre-compute the Gram matrix DTt Dt and the total complexity
becomes O(k2m+η(km+ks2)), which is much cheaper than η times the previous complexity when
η is large enough and s is small. Let us denote by xt,1, . . . ,xt,η the signals drawn at iteration t. We
can now replace lines 5 and 6 of Algorithm 1 by
At ← At−1 +
1
η
η
∑
i=1
αt,iαTt,i,
Bt ← Bt−1 +
1
η
η
∑
i=1
xt,iαTt,i.
3.4.4 SLOWING DOWN THE FIRST ITERATIONS
As in the case of stochastic gradient descent, the first iterations of our algorithm may update the
parameters with large steps, immediately leading to large deviations from the initial dictionary.
To prevent this phenomenon, classical implementations of stochastic gradient descent use gradient
steps of the form a/(t + b), where b “reduces” the step size. An initialization of the form A0 = t0I
and B0 = t0D0 with t0 ≥ 0 also slows down the first steps of our algorithm by forcing the solution of
the dictionary update to stay close to D0. As shown in Section 6, we have observed that our method
does not require this extension to achieve good results in general.
27
MAIRAL, BACH, PONCE AND SAPIRO
3.4.5 PURGING THE DICTIONARY FROM UNUSED ATOMS
Every dictionary learning technique sometimes encounters situations where some of the dictionary
atoms are never (or very seldom) used, which typically happens with a very bad initialization. A
common practice is to replace these during the optimization by randomly chosen elements of the
training set, which solves in practice the problem in most cases. For more difficult and highly
regularized cases, it is also possible to choose a continuation strategy consisting of starting from an
easier, less regularized problem, and gradually increasing λ. This continuation method has not been
used in this paper.
3.5 Link with Second-order Stochastic Gradient Descent
For unconstrained learning problems with twice differentiable expected cost, the second-order stochas-
tic gradient descent algorithm (see Bottou and Bousquet, 2008 and references therein) improves
upon its first-order version, by replacing the learning rate by the inverse of the Hessian. When this
matrix can be computed or approximated efficiently, this method usually yields a faster convergence
speed and removes the problem of tuning the learning rate. However, it cannot be applied easily
to constrained optimization problems and requires at every iteration an inverse of the Hessian. For
these two reasons, it cannot be used for the dictionary learning problem, but nevertheless it shares
some similarities with our algorithm, which we illustrate with the example of a different problem.
Suppose that two major modifications are brought to our original formulation: (i) the vectors αt
are independent of the dictionary D—that is, they are drawn at the same time as xt ; (ii) the op-
timization is unconstrained—that is, C = Rm×k. This setting leads to the least-square estimation
problem
min
D∈Rm×k
E(x,α)
[
||x−Dα||22
]
, (8)
which is of course different from the original dictionary learning formulation. Nonetheless, it is
possible to address Eq. (8) with our method and show that it amounts to using the recursive formula
Dt ← Dt−1 +(xt −Dt−1αt)αTt
( t
∑
i=1
αiαTi
)−1
,
which is equivalent to a second-order stochastic gradient descent algorithm: The gradient obtained
at (xt ,αt) is the term−(xt−Dt−1αt)αTt , and the sequence (1/t)∑ti=1 αiαTi converges to the Hessian
of the objective function. Such sequence of updates admit a fast implementation called Kalman
algorithm (see Kushner and Yin, 2003 and references therein).
4. Convergence Analysis
The main tools used in our proofs are the convergence of empirical processes (Van der Vaart, 1998)
and, following Bottou (1998), the convergence of quasi-martingales (Fisk, 1965). Our analysis is
limited to the basic version of the algorithm, although it can in principle be carried over to the
optimized versions discussed in Section 3.4. Before proving our main result, let us first discuss the
(reasonable) assumptions under which our analysis holds.
28
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
4.1 Assumptions
(A) The data admits a distribution with compact support K. Assuming a compact support for
the data is natural in audio, image, and video processing applications, where it is imposed by the
data acquisition process.
(B) The quadratic surrogate functions f̂t are strictly convex with lower-bounded Hessians. We
assume that the smallest eigenvalue of the positive semi-definite matrix 1t At defined in Algorithm 1
is greater than or equal to some constant κ1. As a consequence, At is invertible and f̂t is strictly
convex with Hessian I⊗ 2t At . This hypothesis is in practice verified experimentally after a few it-
erations of the algorithm when the initial dictionary is reasonable, consisting for example of a few
elements from the training set, or any common dictionary, such as DCT (bases of cosines products)
or wavelets (Mallat, 1999). Note that it is easy to enforce this assumption by adding a term κ12 ||D||2F
to the objective function, which is equivalent to replacing the positive semi-definite matrix 1t At by
1
t At +κ1I. We have omitted for simplicity this penalization in our analysis.
(C) A particular sufficient condition for the uniqueness of the sparse coding solution is satis-
fied. Before presenting this assumption, let us briefly recall classical optimality conditions for the
ℓ1 decomposition problem in Eq. (2) (Fuchs, 2005). For x in K and D in C , α in Rk is a solution of
Eq. (2) if and only if
dTj (x−Dα) = λsign(α[ j]) if α[ j] 6= 0,
|dTj (x−Dα)| ≤ λ otherwise.
(9)
Let α⋆ be such a solution. Denoting by Λ the set of indices j such that |dTj (x−Dα⋆)|= λ, and DΛ
the matrix composed of the columns from D restricted to the set Λ, it is easy to see from Eq. (9) that
the solution α⋆ is necessary unique if (DTΛDΛ) is invertible and that
α⋆Λ = (D
T
ΛDΛ)
−1(DTΛx−λεΛ), (10)
where α⋆Λ is the vector containing the values of α
⋆ corresponding to the set Λ and εΛ[ j] is equal to the
sign of α⋆Λ[ j] for all j. With this preliminary uniqueness condition in hand, we can now formulate
our assumption: We assume that there exists κ2 > 0 such that, for all x in K and all dictionaries D
in the subset of C considered by our algorithm, the smallest eigenvalue of DTΛDΛ is greater than
or equal to κ2. This guarantees the invertibility of (DTΛDΛ) and therefore the uniqueness of the
solution of Eq. (2). It is of course easy to build a dictionary D for which this assumption fails.
However, having DTΛDΛ invertible is a common assumption in linear regression and in methods
such as the LARS algorithm aimed at solving Eq. (2) (Efron et al., 2004). It is also possible to
enforce this condition using an elastic net penalization (Zou and Hastie, 2005), replacing ||α||1 by
||α||1 + κ22 ||α||22 and thus improving the numerical stability of homotopy algorithms, which is the
choice made by Zou et al. (2006). Again, we have omitted this penalization in our analysis.
4.2 Main Results
Given assumptions (A)–(C), let us now show that our algorithm converges to a stationary point
of the objective function. Since this paper is dealing with non-convex optimization, neither our
algorithm nor any one in the literature is guaranteed to find the global optimum of the optimization
problem. However, such stationary points have often been found to be empirically good enough
29
MAIRAL, BACH, PONCE AND SAPIRO
for practical applications, for example, for image restoration (Elad and Aharon, 2006; Mairal et al.,
2008b).
Our first result (Proposition 2 below) states that given (A)–(C), f (Dt) converges almost surely
and f (Dt)− f̂t(Dt) converges almost surely to 0, meaning that f̂t acts as a converging surrogate
of f . First, we prove a lemma to show that Dt −Dt−1 = O(1/t). It does not ensure the convergence
of Dt , but guarantees the convergence of the positive sum ∑∞t=1 ||Dt −Dt−1||2F , a classical condition
in gradient descent convergence proofs (Bertsekas, 1999).
Lemma 1 [Asymptotic variations of Dt].
Assume (A)–(C). Then,
Dt+1−Dt = O
(1
t
)
a.s.
Proof This proof is inspired by Prop 4.32 of Bonnans and Shapiro (2000) on the Lipschitz regularity
of solutions of optimization problems. Using assumption (B), for all t, the surrogate f̂t is strictly
convex with a Hessian lower-bounded by κ1. Then, a short calculation shows that it verifies the
second-order growth condition
f̂t(Dt+1)− f̂t(Dt)≥ κ1||Dt+1−Dt ||2F . (11)
Moreover,
f̂t(Dt+1)− f̂t(Dt) = f̂t(Dt+1)− f̂t+1(Dt+1)+ f̂t+1(Dt+1)− f̂t+1(Dt)+ f̂t+1(Dt)− f̂t(Dt)
≤ f̂t(Dt+1)− f̂t+1(Dt+1)+ f̂t+1(Dt)− f̂t(Dt),
where we have used that f̂t+1(Dt+1)− f̂t+1(Dt) ≤ 0 because Dt+1 minimizes f̂t+1 on C . Since
f̂t(D) = 1t (
1
2 Tr(D
T DAt)−Tr(DT Bt)), and ||D||F ≤
√
k, it is possible to show that f̂t − f̂t+1 is Lip-
schitz with constant ct = (1/t)(||Bt+1−Bt ||F +
√
k||At+1−At ||F), which gives
f̂t(Dt+1)− f̂t(Dt)≤ ct ||Dt+1−Dt ||F . (12)
From Eq. (11) and (12), we obtain
||Dt+1−Dt ||F ≤
ct
κ1
.
Assumptions (A), (C) and Eq. (10) ensure that the vectors αi and xi are bounded with probability
one and therefore ct = O(1/t) a.s.
We can now state and prove our first proposition, which shows that we are indeed minimizing a
smooth function.
Proposition 2 [Regularity of f ].
Assume (A) to (C). For x in the support K of the probability distribution p, and D in the feasible
set C , let us define
α⋆(x,D) = argmin
α∈Rk
1
2
||x−Dα||22 +λ||α||1. (13)
Then,
30
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
1. the function ℓ defined in Eq. (2) is continuously differentiable and
∇Dℓ(x,D) =−(x−Dα⋆(x,D))α⋆(x,D)T .
2. f is continuously differentiable and ∇ f (D) = Ex
[
∇Dℓ(x,D)
]
;
3. ∇ f (D) is Lipschitz on C .
Proof Assumption (A) ensures that the vectors α⋆ are bounded for x in K and D in C . Therefore,
one can restrict the optimization problem (13) to a compact subset of Rk. Under assumption (C),
the solution of Eq. (13) is unique and α⋆ is well-defined. Theorem 5 in Appendix A from Bonnans
and Shapiro (1998) can be applied and gives us directly the first statement. Since K is compact, and
ℓ is continuously differentiable, the second statement follows immediately.
To prove the third claim, we will show that for all x in K, α⋆(x, .) is Lipschitz with a constant in-
dependent of x,7 which is a sufficient condition for ∇ f to be Lipschitz. First, the function optimized
in Eq. (13) is continuous in α, D, x and has a unique minimum, implying that α⋆ is continuous in x
and D.
Consider a matrix D in C and x in K and denote by α⋆ the vector α⋆(x,D), and again by Λ the set
of indices j such that |dTj (x−Dα⋆)|= λ. Since dTj (x−Dα⋆) is continuous in D and x, there exists
an open neighborhood V around (x,D) such that for all (x′,D′) in V , and j /∈Λ, |dTj
′
(x′−D′α⋆′)|< λ
and α⋆′[ j] = 0, where α⋆′ = α⋆(x′,D′).
Denoting by UΛ the matrix composed of the columns of a matrix U corresponding to the index
set Λ and similarly by uΛ the vector composed of the values of a vector u corresponding to Λ, we
consider the function ℓ̃
ℓ̃(x,DΛ,αΛ)
△
=
1
2
||x−DΛαΛ||22 +λ||αΛ||1,
Assumption (C) tells us that ℓ̃(x,DΛ, .) is strictly convex with a Hessian lower-bounded by κ2. Let
us consider (x′,D′) in V . A simple calculation shows that
ℓ̃(x,DΛ,α⋆Λ
′)− ℓ̃(x,DΛ,α⋆Λ)≥ κ2||α⋆Λ′−α⋆Λ||22.
Moreover, it is easy to show that ℓ̃(x,DΛ, .)− ℓ̃(x′,D′Λ, .) is Lipschitz with constant e1||DΛ−D′Λ||F +
e2||x−x′||2, where e1,e2 are constants independent of D,D′,x,x′ and then, one can show that
||α⋆′−α⋆||2 = ||α⋆Λ′−α⋆Λ||2 ≤
1
κ2
(
e1||D−D′||F + e2||x−x′||2
)
.
Therefore, α⋆ is locally Lipschitz. Since K×C is compact, α⋆ is uniformly Lipschitz on K×C ,
which concludes the proof.
Now that we have shown that f is a smooth function, we can state our first result showing that
the sequence of functions f̂t acts asymptotically as a surrogate of f and that f (Dt) converges almost
surely in the following proposition.
7. From now on, for a vector x in Rm, α⋆(x, .) denotes the function that associates to a matrix D verifying Assump-
tion (C), the optimal solution α⋆(x,D). For simplicity, we will use these slightly abusive notation in the rest of the
paper.
31
MAIRAL, BACH, PONCE AND SAPIRO
Proposition 3 [Convergence of f (Dt) and of the surrogate function]. Let f̂t denote the surrogate
function defined in Eq. (5). Assume (A) to (C). Then,
1. f̂t(Dt) converges almost surely;
2. f (Dt)− f̂t(Dt) converges almost surely to 0;
3. f (Dt) converges almost surely.
Proof Part of this proof is inspired by Bottou (1998). We prove the convergence of the se-
quence f̂t(Dt) by showing that the stochastic positive process
ut
△
= f̂t(Dt)≥ 0,
is a quasi-martingale and use Theorem 6 from Fisk (1965) (see Appendix A), which states that if
the sum of the “positive” variations of ut are bounded, ut is a quasi-martingale, which converges
with probability one (see Theorem 6 for details). Computing the variations of ut , we obtain
ut+1−ut = f̂t+1(Dt+1)− f̂t(Dt)
= f̂t+1(Dt+1)− f̂t+1(Dt)+ f̂t+1(Dt)− f̂t(Dt)
= f̂t+1(Dt+1)− f̂t+1(Dt)+
ℓ(xt+1,Dt)− ft(Dt)
t +1
+
ft(Dt)− f̂t(Dt)
t +1
,
(14)
using the fact that f̂t+1(Dt) = 1t+1ℓ(xt+1,Dt)+
t
t+1 f̂t(Dt). Since Dt+1 minimizes f̂t+1 on C and Dt is
in C , f̂t+1(Dt+1)− f̂t+1(Dt)≤ 0. Since the surrogate f̂t upperbounds the empirical cost ft , we also
have ft(Dt)− f̂t(Dt) ≤ 0. To use Theorem 6, we consider the filtration of the past information Ft
and take the expectation of Eq. (14) conditioned on Ft , obtaining the following bound
E[ut+1−ut |Ft ]≤
E[ℓ(xt+1,Dt)|Ft ]− ft(Dt)
t +1
≤ f (Dt)− ft(Dt)
t +1
≤ || f − ft ||∞
t +1
,
For a specific matrix D, the central-limit theorem states that E[
√
t( f (Dt)− ft(Dt))] is bounded.
However, we need here a stronger result on empirical processes to show that E[
√
t|| f − ft ||∞] is
bounded. To do so, we use the Lemma 7 in Appendix A, which is a corollary of Donsker theorem
(see Van der Vaart, 1998, chap. 19.2). It is easy to show that in our case, all the hypotheses are
verified, namely, ℓ(x, .) is uniformly Lipschitz and bounded since it is continuously differentiable
on a compact set, the set C ⊂ Rm×k is bounded, and Ex[ℓ(x,D)2] exists and is uniformly bounded.
Therefore, Lemma 7 applies and there exists a constant κ > 0 such that
E[E[ut+1−ut |Ft ]+]≤
κ
t
3
2
.
Therefore, defining δt as in Theorem 6, we have
∞
∑
t=1
E[δt(ut+1−ut)] =
∞
∑
t=1
E[E[ut+1−ut |Ft ]+] < +∞.
32
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Thus, we can apply Theorem 6, which proves that ut converges almost surely and that
∞
∑
t=1
|E[ut+1−ut |Ft ]|< +∞ a.s.
Using Eq. (14) we can show that it implies the almost sure convergence of the positive sum
∞
∑
t=1
f̂t(Dt)− ft(Dt)
t +1
.
Using Lemma 1 and the fact that the functions ft and f̂t are bounded and Lipschitz, with a constant
independent of t, it is easy to show that the hypotheses of Lemma 8 in Appendix A are satisfied.
Therefore
ft(Dt)− f̂t(Dt) −→
t→+∞
0 a.s.
Since f̂t(Dt) converges almost surely, this shows that ft(Dt) converges in probability to the same
limit. Note that we have in addition || ft − f ||∞ →t→+∞ 0 a.s. (see Van der Vaart, 1998, Theorem
19.4 (Glivenko-Cantelli)). Therefore,
f (Dt)− f̂t(Dt) −→
t→+∞
0 a.s.
and f (Dt) converges almost surely, which proves the second and third points.
With Proposition 3 in hand, we can now prove our final and strongest result, namely that first-
order necessary optimality conditions are verified asymptotically with probability one.
Proposition 4 [Convergence to a stationary point]. Under assumptions (A) to (C), the distance
between Dt and the set of stationary points of the dictionary learning problem converges almost
surely to 0 when t tends to infinity.
Proof Since the sequences of matrices At ,Bt are in a compact set, it is possible to extract converg-
ing subsequences. Let us assume for a moment that these sequences converge respectively to two
matrices A∞ and B∞. In that case, Dt converges to a matrix D∞ in C . Let U be a matrix in Rm×k.
Since f̂t upperbounds ft on Rm×k, for all t,
f̂t(Dt +U)≥ ft(Dt +U).
Taking the limit when t tends to infinity,
f̂∞(D∞ +U)≥ f (D∞ +U).
Let ht > 0 be a sequence that converges to 0. Using a first order Taylor expansion, and using the
fact that ∇ f is Lipschitz and f̂∞(D∞) = f (D∞) a.s., we have
f (D∞)+Tr(htUT ∇ f̂∞(D∞))+o(htU)≥ f (D∞)+Tr(htUT ∇ f (D∞))+o(htU),
and it follows that
Tr
( 1
||U||F
UT ∇ f̂∞(D∞)
)
≥ Tr
( 1
||Ut ||F
UT ∇ f (D∞)
)
,
33
MAIRAL, BACH, PONCE AND SAPIRO
Since this inequality is true for all U, ∇ f̂∞(D∞) = ∇ f (D∞). A first-order necessary optimality condi-
tion for D∞ being an optimum of f̂∞ is that −∇ f̂∞ is in the normal cone of the set C at D∞ (Borwein
and Lewis, 2006). Therefore, this first-order necessary conditions is verified for f at D∞ as well.
Since At ,Bt are asymptotically close to their accumulation points, −∇ f (Dt) is asymptotically close
the normal cone at Dt and these first-order optimality conditions are verified asymptotically with
probability one.
5. Extensions to Matrix Factorization
In this section, we present variations of the basic online algorithm to address different optimization
problems. We first present different possible regularization terms for α and D, which can be used
with our algorithm, and then detail some specific cases such as non-negative matrix factorization,
sparse principal component analysis, constrained sparse coding, and simultaneous sparse coding.
5.1 Using Different Regularizers for α
In various applications, different priors for the coefficients α may lead to different regularizers ψ(α).
As long as the assumptions of Section 4.1 are verified, our algorithm can be used with:
• Positivity constraints on α that are added to the ℓ1-regularization. The homotopy method
presented in Efron et al. (2004) is able to handle such constraints.
• The Tikhonov regularization, ψ(α) = λ12 ||α||22, which does not lead to sparse solutions.
• The elastic net (Zou and Hastie, 2005), ψ(α) = λ1||α||1 + λ22 ||α||22, leading to a formulation
relatively close to Zou et al. (2006).
• The group Lasso (Yuan and Lin, 2006; Turlach et al., 2005; Bach, 2008), ψ(α) = ∑si=1 ||αi||2,
where αi is a vector corresponding to a group of variables.
Non-convex regularizers such as the ℓ0 pseudo-norm, ℓp pseudo-norm with p < 1 can be used as
well. However, as with any classical dictionary learning techniques exploiting non-convex regular-
izers (e.g., Olshausen and Field, 1997; Engan et al., 1999; Aharon et al., 2006), there is no theoretical
convergence results in these cases. Note also that convex smooth approximation of sparse regulariz-
ers (Bradley and Bagnell, 2009), or structured sparsity-inducing regularizers (Jenatton et al., 2009a;
Jacob et al., 2009) could be used as well even though we have not tested them.
5.2 Using Different Constraint Sets for D
In the previous subsection, we have claimed that our algorithm could be used with different regu-
larization terms on α. For the dictionary learning problem, we have considered an ℓ2-regularization
on D by forcing its columns to have less than unit ℓ2-norm. We have shown that with this constraint
set, the dictionary update step can be solved efficiently using a block-coordinate descent approach.
Updating the j-th column of D, when keeping the other ones fixed is solved by orthogonally pro-
jecting the vector u j = d j + (1/A[ j, j])(b j−Da j) on the constraint set C , which in the classical
dictionary learning case amounts to a projection of u j on the ℓ2-ball.
34
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
It is easy to show that this procedure can be extended to different convex constraint sets C ′
as long as the constraints are a union of independent constraints on each column of D and the
orthogonal projections of the vectors u j onto the set C ′ can be done efficiently. Examples of different
sets C ′ that we propose as an alternative to C are
• The “non-negative” constraints:
C ′ = {D ∈ Rm×k s.t. ∀ j = 1, . . . ,k, ||d j||2 ≤ 1 and d j ≥ 0}.
• The “elastic-net” constraints:
C ′
△
= {D ∈ Rm×k s.t. ∀ j = 1, . . . ,k, ||d j||22 + γ||d j||1 ≤ 1}.
These constraints induce sparsity in the dictionary D (in addition to the sparsity-inducing reg-
ularizer on the vectors αi). By analogy with the regularization proposed by Zou and Hastie
(2005), we call these constraints “elastic-net constraints.” Here, γ is a new parameter, con-
trolling the sparsity of the dictionary D. Adding a non-negativity constraint is also possible in
this case. Note that the presence of the ℓ2 regularization is important here. It has been shown
by Bach et al. (2008) that using the ℓ1-norm only in such problems lead to trivial solutions
when k is large enough. The combination of ℓ1 and ℓ2 constraints has also been proposed re-
cently for the problem of matrix factorization by Witten et al. (2009), but in a slightly different
setting.
• The “fused lasso” (Tibshirani et al., 2005) constraints. When one is looking for a dictionary
whose columns are sparse and piecewise-constant, a fused lasso regularization can be used.
For a vector u in Rm, we consider the ℓ1-norm of the consecutive differences of u denoted by
FL(u) △=
m
∑
i=2
|u[i]−u[i−1]|,
and define the “fused lasso” constraint set
C ′
△
= {D ∈ Rm×k s.t. ∀ j = 1, . . . ,k, ||d j||22 + γ1||d j||1 + γ2 FL(d j)≤ 1}.
This kind of regularization has proven to be useful for exploiting genomic data such as CGH
arrays (Tibshirani and Wang, 2008).
In all these settings, replacing the projections of the vectors u j onto the ℓ2-ball by the projections
onto the new constraints, our algorithm is still guaranteed to converge and find a stationary point
of the optimization problem. The orthogonal projection onto the “non negative” ball is simple
(additional thresholding) but the projection onto the two other sets is slightly more involved. In
Appendix B, we propose two algorithms for efficiently solving these problems. The first one is
presented in Section B.1 and computes the projection of a vector onto the elastic-net constraint
in linear time, by extending the efficient projection onto the ℓ1-ball from Maculan and de Paula
(1989) and Duchi et al. (2008). The second one is a homotopy method, which solves the projection
on the fused lasso constraint set in O(ks), where s is the number of piecewise-constant parts in the
solution. This method also solves efficiently the fused lasso signal approximation problem presented
in Friedman et al. (2007):
min
u∈Rn
1
2
||b−u||22 + γ1||u||1 + γ2 FL(u)+ γ3||u||22.
35
MAIRAL, BACH, PONCE AND SAPIRO
Being able to solve this problem efficiently has also numerous applications, which are beyond the
scope of this paper. For instance, it allows us to use the fast algorithm of Nesterov (2007) for solving
the more general fused lasso problem (Tibshirani et al., 2005). Note that the proposed method could
be used as well with more complex constraints for the columns of D, which we have not tested in
this paper, addressing for instance the problem of structured sparse PCA (Jenatton et al., 2009b).
Now that we have presented a few possible regularizers for α and D, that can be used within
our algorithm, we focus on a few classical problems which can be formulated as dictionary learning
problems with specific combinations of such regularizers.
5.3 Non Negative Matrix Factorization
Given a matrix X = [x1, . . . ,xn] in Rm×n, Lee and Seung (2001) have proposed the non negative
matrix factorization problem (NMF), which consists of minimizing the following cost
min
D∈C ,α∈Rk×n
n
∑
i=1
1
2
||xi−Dαi||22 s.t. D≥ 0, ∀ i, αi ≥ 0.
With this formulation, the matrix D and the vectors αi are forced to have non negative components,
which leads to sparse solutions. When applied to images, such as faces, Lee and Seung (2001) have
shown that the learned features are more localized than the ones learned with a classical singular
value decomposition. As for dictionary learning, classical approaches for addressing this problem
are batch algorithms, such as the multiplicative update rules of Lee and Seung (2001), or the pro-
jected gradient descent algorithm of Lin (2007).
Following this line of research, Hoyer (2002, 2004) has proposed non negative sparse coding
(NNSC), which extends non-negative matrix factorization by adding a sparsity-inducing penalty to
the objective function to further control the sparsity of the vectors αi:
min
D∈C ,α∈Rk×n
n
∑
i=1
(1
2
||xi−Dαi||22 +λ
k
∑
j=1
αi[ j]
)
s.t. D≥ 0, ∀ i, αi ≥ 0.
When λ = 0, this formulation is equivalent to NMF. The only difference with the dictionary learning
problem is that non-negativity constraints are imposed on D and the vectors αi. A simple modifica-
tion of our algorithm, presented above, allows us to handle these constraints, while guaranteeing to
find a stationary point of the optimization problem. Moreover, our approach can work in the setting
when n is large.
5.4 Sparse Principal Component Analysis
Principal component analysis (PCA) is a classical tool for data analysis, which can be interpreted
as a method for finding orthogonal directions maximizing the variance of the data, or as a low-
rank matrix approximation method. Jolliffe et al. (2003), Zou et al. (2006), d’Aspremont et al.
(2007), d’Aspremont et al. (2008), Witten et al. (2009) and Zass and Shashua (2007) have proposed
different formulations for sparse principal component analysis (SPCA), which extends PCA by
estimating sparse vectors maximizing the variance of the data, some of these formulations enforcing
orthogonality between the sparse components, whereas some do not. In this paper, we formulate
SPCA as a sparse matrix factorization which is equivalent to the dictionary learning problem with
36
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
eventually sparsity constraints on the dictionary—that is, we use the ℓ1-regularization term for α
and the “elastic-net” constraint for D (as used in a penalty term by Zou et al. 2006):
min
α∈Rk×n
n
∑
i=1
(1
2
||xi−Dαi||22 +λ||αi||1
)
s.t. ∀ j = 1, . . . ,k, ||d j||22 + γ||d j||1 ≤ 1.
As detailed above, our dictionary update procedure amounts to successive orthogonal projection of
the vectors u j on the constraint set. More precisely, the update of d j becomes
u j←
1
A[ j, j]
(b j−Da j)+d j,
d j← argmin
d∈Rm
||u j−d||22 s.t. ||d||22 + γ||d||1 ≤ 1,
which can be solved in linear time using Algorithm 3 presented in Appendix B. In addition to that,
our SPCA method can be used with fused Lasso constraints as well.
5.5 Constrained Sparse Coding
Constrained sparse coding problems are often encountered in the literature, and lead to different
loss functions such as
ℓ′(x,D) = min
α∈Rk
||x−Dα||22 s.t. ||α||1 ≤ T, (15)
or
ℓ′′(x,D) = min
α∈Rk
||α||1 s.t. ||x−Dα||22 ≤ ε, (16)
where T and ε are pre-defined thresholds. Even though these loss functions lead to equivalent
optimization problems in the sense that for given x,D and λ, there exist ε and T such that ℓ(x,D),
ℓ′(x,D) and ℓ′′(x,D) admit the same solution α⋆, the problems of learning D using ℓ, ℓ′ of ℓ′′ are
not equivalent. For instance, using ℓ′′ has proven experimentally to be particularly well adapted to
image denoising (Elad and Aharon, 2006; Mairal et al., 2008b).
For all T , the same analysis as for ℓ can be carried for ℓ′, and the simple modification which
consists of computing αt using Eq. (15) in the sparse coding step leads to the minimization of the
expected cost minD∈C Ex[ℓ′(x,D)].
Handling the case ℓ′′ is a bit different. We propose to use the same strategy as for ℓ′—that is,
using our algorithm but computing αt solving Eq. (16). Even though our analysis does not apply
since we do not have a quadratic surrogate of the expected cost, experimental evidence shows that
this approach is efficient in practice.
5.6 Simultaneous Sparse Coding
In some situations, the signals xi are not i.i.d samples of an unknown probability distribution, but
are structured in groups (which are however independent from each other), and one may want to ad-
dress the problem of simultaneous sparse coding, which appears also in the literature under various
names such as group sparsity or grouped variable selection (Cotter et al., 2005; Turlach et al., 2005;
Yuan and Lin, 2006; Obozinski et al., 2009, 2008; Zhang et al., 2008; Tropp et al., 2006; Tropp,
2006). Let X = [x1, . . . ,xq] ∈ Rm×q be a set of signals. Suppose one wants to obtain sparse decom-
positions of the signals on the dictionary D that share the same active set (non-zero coefficients).
37
MAIRAL, BACH, PONCE AND SAPIRO
Let α = [α1, . . . ,αq] in Rk×q be the matrix composed of the coefficients. One way of imposing this
joint sparsity is to penalize the number of non-zero rows of α. A classical convex relaxation of this
joint sparsity measure is to consider the ℓ1,2-norm on the matrix α
||α||1,2 △=
k
∑
j=1
||α j||2,
where α j is the j-th row of α. In that setting, the ℓ1,2-norm of α is the ℓ1-norm of the ℓ2-norm of
the rows of α.
The problem of jointly decomposing the signals xi can be written as a ℓ1,2-sparse decomposition
problem, which is a subcase of the group Lasso (Turlach et al., 2005; Yuan and Lin, 2006; Bach,
2008), by defining the cost function
ℓ′′′(X,D) = min
α∈Rk×q
1
2
||X−Dα||2F +λ||α||1,2,
which can be computed using a block-coordinate descent approach (Friedman et al., 2007) or an
active set method (Roth and Fischer, 2008).
Suppose now that we are able to draw groups of signals Xi, i = 1, . . . ,n which have bounded size
and are independent from each other and identically distributed, one can learn an adapted dictionary
by solving the optimization problem
min
D∈C
lim
n→∞
1
n
n
∑
i=1
ℓ′′′(Xi,D).
Being able to solve this optimization problem is important for many applications. For instance, in
Mairal et al. (2009c), state-of-the-art results in image denoising and demosaicking are achieved with
this formulation. The extension of our algorithm to this case is relatively easy, computing at each
sparse coding step a matrix of coefficients α, and keeping the updates of At and Bt unchanged.
All of the variants of this section have been implemented. Next section evaluates some of
them experimentally. An efficient C++ implementation with a Matlab interface of these variants is
available on the Willow project-team web page http://www.di.ens.fr/willow/SPAMS/.
6. Experimental Validation
In this section, we present experiments on natural images and genomic data to demonstrate the effi-
ciency of our method for dictionary learning, non-negative matrix factorization, and sparse principal
component analysis.
6.1 Performance Evaluation for Dictionary Learning
For our experiments, we have randomly selected 1.25× 106 patches from images in the Pascal
VOC’06 image database (Everingham et al., 2006), which is composed of varied natural images;
106 of these are kept for training, and the rest for testing. We used these patches to create three data
sets A, B, and C with increasing patch and dictionary sizes representing various settings which are
typical in image processing applications: We have centered and normalized the patches to have unit
ℓ2-norm and used the regularization parameter λ = 1.2/
√
m in all of our experiments. The 1/
√
m
38
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Data set Signal size m Nb k of atoms Type
A 8×8 = 64 256 b&w
B 12×12×3 = 432 512 color
C 16×16 = 256 1024 b&w
term is a classical normalization factor (Bickel et al., 2009), and the constant 1.2 has shown to yield
about 10 nonzero coefficients for data set A and 40 for data sets B and C in these experiments.
We have implemented the proposed algorithm in C++ with a Matlab interface. All the results
presented in this section use the refinements from Section 3.4 since this has lead empirically to
speed improvements. Although our implementation is multithreaded, our experiments have been
run for simplicity on a single-CPU, single-core 2.66Ghz machine.
The first parameter to tune is η, the number of signals drawn at each iteration. Trying different
powers of 2 for this variable has shown that η = 512 was a good choice (lowest objective function
values on the training set—empirically, this setting also yields the lowest values on the test set).
Even though this parameter is fairly easy to tune since values of 64, 128, 256 and 1024 have given
very similar performances, the difference with the choice η = 1 is significant.
Our implementation can be used in both the online setting it is intended for, and in a regular
batch mode where it uses the entire data set at each iteration. We have also implemented a first-
order stochastic gradient descent algorithm that shares most of its code with our algorithm, except
for the dictionary update step. This setting allows us to draw meaningful comparisons between our
algorithm and its batch and stochastic gradient alternatives, which would have been difficult other-
wise. For example, comparing our algorithm to the Matlab implementation of the batch approach
from Lee et al. (2007) developed by its authors would have been unfair since our C++ program has
a built-in speed advantage.8 To measure and compare the performances of the three tested meth-
ods, we have plotted the value of the objective function on the test set, acting as a surrogate of the
expected cost, as a function of the corresponding training time.
6.1.1 ONLINE VS. BATCH
The left column of Figure 1 compares the online and batch settings of our implementation. The full
training set consists of 106 samples. The online version of our algorithm draws samples from the
entire set, and we have run its batch version on the full data set as well as subsets of size 104 and
105 (see Figure 1). The online setting systematically outperforms its batch counterpart for every
training set size and desired precision. We use a logarithmic scale for the computation time, which
shows that in many situations, the difference in performance can be dramatic. Similar experiments
have given similar results on smaller data sets. Our algorithm uses all the speed-ups from Section
3.4. The parameter ρ was chosen by trying the values 0,5,10,15,20,25, and t0 by trying different
powers of 10. We have selected (t0 = 0.001,ρ = 15), which has given the best performance in
terms of objective function evaluated on the training set for the three data sets. We have plotted
three curves for our method: OL1 corresponds to the optimal setting (t0 = 0.001,ρ = 15). Even
though tuning two parameters might seem cumbersome, we have plotted two other curves showing
that, on the contrary, our method is very easy to use. The curve OL2, corresponding to the setting
8. Both LARS and the feature-sign algorithm (Lee et al., 2007) require a large number of low-level operations which
are not well optimized in Matlab. We have indeed observed that our C++ implementation of LARS is up to 50 times
faster than the Matlab implementation of the feature-sign algorithm of Lee et al. (2007) for our experiments.
39
MAIRAL, BACH, PONCE AND SAPIRO
(t0 = 0.001,ρ = 10), is very difficult to distinguish from the first curve and we have observed a
similar behavior with the setting (t0 = 0.001,ρ = 20). showing that our method is robust to the
choice of the parameter ρ. We have also observed that the parameter ρ is useful for large data sets
only. When using smaller ones (n≤ 100,000), it did not bring any benefit.
Moreover, the curve OL3 is obtained without using a tuned parameter t0—that is, ρ = 15 and
t0 = 0, and shows that its influence is very limited since very good results are obtained without using
it. On the other hand, we have observed that using a parameter t0 too big, could slightly slow down
our algorithm during the first epoch (cycle on the training set).
6.1.2 COMPARISON WITH STOCHASTIC GRADIENT DESCENT
Our experiments have shown that obtaining good performance with stochastic gradient descent
requires using both the mini-batch heuristic and carefully choosing a learning rate of the form
a/(ηt + b). To give the fairest comparison possible, we have thus optimized these parameters. As
for our algorithm, sampling η values among powers of 2 (as before) has shown that η = 512 was a
good value and gives a significant better performance than η = 1.
In an earlier version of this work (Mairal et al., 2009a), we have proposed a strategy for our
method which does not require any parameter tuning except the mini-batch η and compared it with
the stochastic gradient descent algorithm (SGD) with a learning rate of the form a/(ηt). While our
method has improved in performance using the new parameter ρ, SGD has also proven to provide
much better results when using a learning rate of the form a/(ηt +b) instead of a/(ηt), at the cost
of an extra parameter b to tune. Using the learning rate a/(ηt) with a high value for a results indeed
in too large initial steps of the algorithm increasing dramatically the value of the objective function,
and a small value of a leads to bad asymptotic results, while a learning rate of the form a/(ηt + b)
is a good compromise.
We have tried different powers of 10 for a and b. First selected the couple (a = 100,000,b =
100,000) and then refined it, trying the values 100,000× 2i for i = −3, . . . ,3. Finally, we have
selected (a = 200,000,b = 400,000). As shown on the right column of Figure 1, this setting repre-
sented by the curve SG1 leads to similar results as our method. The curve SG2 corresponds to the
parameters (a = 400,000,b = 400,000) and shows that increasing slightly the parameter a makes
the curves worse than the others during the first iterations (see for instance the curve between 1 and
102 seconds for data set A), but still lead to good asymptotic results. The curve SG3 corresponds
to a situation where a and b are slightly too small (a = 50,000,b = 100,000). It is as good as SG1
for data sets A and B, but asymptotically slightly below the others for data set C. All the curves
are obtained as the average of three experiments with different initializations. Interestingly, even
though the problem is not convex, the different initializations have led to very similar values of the
objective function and the variance of the experiments was always insignificant after 10 seconds of
computations.
6.2 Non Negative Matrix Factorization and Non Negative Sparse Coding
In this section, we compare our method with the classical algorithm of Lee and Seung (2001) for
NMF and the non-negative sparse coding algorithm of Hoyer (2002) for NNSC. The experiments
have been carried out on three data sets with different sizes:
• Data set D is composed of n = 2,429 face images of size m = 19× 19 pixels from the the
MIT-CBCL Face Database #1 (Sung, 1996).
40
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
10
−1
10
0
10
1
10
2
10
3
10
4
0.275
0.28
0.285
0.29
0.295
0.3
0.305
Evaluation set A
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Batch n=104
Batch n=105
Batch n=106
OL1
OL2
OL3
10
−1
10
0
10
1
10
2
10
3
10
4
0.275
0.28
0.285
0.29
0.295
0.3
0.305
Evaluation set A
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
SG1
SG2
SG3
OL1
10
−1
10
0
10
1
10
2
10
3
10
4
0.195
0.2
0.205
0.21
0.215
0.22
0.225
0.23
0.235
Evaluation set B
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Batch n=104
Batch n=105
Batch n=106
OL1
OL2
OL3
10
−1
10
0
10
1
10
2
10
3
10
4
0.195
0.2
0.205
0.21
0.215
0.22
0.225
0.23
0.235
Evaluation set B
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
SG1
SG2
SG3
OL1
10
−1
10
0
10
1
10
2
10
3
10
4
0.215
0.22
0.225
0.23
0.235
0.24
0.245
Evaluation set C
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Batch n=104
Batch n=105
Batch n=106
OL1
OL2
OL3
10
−1
10
0
10
1
10
2
10
3
10
4
0.215
0.22
0.225
0.23
0.235
0.24
0.245
Evaluation set C
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
SG1
SG2
SG3
OL1
Figure 1: Left: Comparison between our method and the batch approach for dictionary learning.
Right: Comparison between our method and stochastic gradient descent. The results are
reported for three data sets as a function of computation time on a logarithmic scale. Note
that the times of computation that are less than 0.1s are not reported. See text for details.
41
MAIRAL, BACH, PONCE AND SAPIRO
• Data set E is composed of n = 2,414 face images of size m = 192× 168 pixels from the
Extended Yale B Database (Georghiades et al., 2001; Lee et al., 2005).
• Data set F is composed of n = 100,000 natural image patches of size m = 16×16 pixels from
the Pascal VOC’06 image database (Everingham et al., 2006).
We have used the Matlab implementations of NMF and NNSC of P. Hoyer, which are freely avail-
able at http://www.cs.helsinki.fi/u/phoyer/software.html. Even though our C++ imple-
mentation has a built-in advantage in terms of speed over these Matlab implementations, most of
the computational time of NMF and NNSC is spent on large matrix multiplications, which are typ-
ically well optimized in Matlab. All the experiments have been run for simplicity on a single-CPU,
single-core 2.4GHz machine, without using the parameters ρ and t0 presented in Section 3.4—that
is, ρ = 0 and t0 = 0. As in Section 6.1, a minibatch of size η = 512 is chosen. Following the original
experiment of Lee and Seung (2001) on data set D, we have chosen to learn k = 49 basis vectors for
the face images data sets D and E, and we have chosen k = 64 for data set F. Each input vector is
normalized to have unit ℓ2-norm.
The experiments we present in this section compare the value of the objective function on the
data sets obtained with the different algorithms as a function of the computation time. Since our
algorithm learns the matrix D but does not provide the matrix α, the computation times reported for
our approach include two steps: First, we run our algorithm to obtain D. Second, we run one sparse
coding step over all the input vectors to obtain α. Figure 2 presents the results for NMF and NNSC.
The gradient step for the algorithm of Hoyer (2002) was optimized for the best performance and λ
was set to 1√m . Both D and α were initialized randomly. The values reported are those obtained for
more than 0.1s of computation. Since the random initialization provides an objective value which
is by far greater than the value obtained at convergence, the curves are all truncated to present
significant objective values. All the results are obtained using the average of 3 experiments with
different initializations. As shown on Figure 2, our algorithm provides a significant improvement in
terms of speed compared to the other tested methods, even though the results for NMF and NNSC
could be improved a bit using a C++ implementation.
6.3 Sparse Principal Component Analysis
We present here the application of our method addressing SPCA with various types of data: faces,
natural image patches, and genomic data.
6.3.1 FACES AND NATURAL PATCHES
In this section, we compare qualitatively the results obtained by PCA, NMF, our dictionary learning
and our sparse principal component analysis algorithm on the data sets used in Section 6.2. For
dictionary learning, PCA and SPCA, the input vectors are first centered and normalized to have a
unit norm. Visual results are presented on figures 3, 4 and 5, respectively for the data sets D, E and F.
The parameter λ for dictionary learning and SPCA was set so that the decomposition of each input
signal has approximately 10 nonzero coefficients. The results for SPCA are presented for various
values of the parameter γ, yielding different levels of sparsity. The scalar τ indicates the percentage
of nonzero values of the dictionary.
Each image is composed of k small images each representing one learned feature vector. Nega-
tive values are blue, positive values are red and the zero values are represented in white. Confirming
42
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
10
−1
10
0
10
1
10
2
10
3
10
4
0.02
0.04
0.06
0.08
0.1
0.12
0.14
Evaluation set D
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Lee & Seung
10
−1
10
0
10
1
10
2
10
3
10
4
0.065
0.07
0.075
0.08
0.085
0.09
0.095
Evaluation set D
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Hoyer
10
−1
10
0
10
1
10
2
10
3
10
4
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
Evaluation set E
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Lee & Seung
10
−1
10
0
10
1
10
2
10
3
10
4
0.04
0.06
0.08
0.1
0.12
0.14
0.16
0.18
Evaluation set E
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Hoyer
10
−1
10
0
10
1
10
2
10
3
10
4
1
2
3
4
5
6
7
x 10
−3 Evaluation set F
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Lee & Seung
10
−1
10
0
10
1
10
2
10
3
10
4
0.0614
0.0616
0.0618
0.062
0.0622
0.0624
Evaluation set F
time (in seconds)
O
bj
ec
tiv
e 
fu
nc
tio
n
 
 
Our method
Hoyer
Figure 2: Left: Comparison between our method and the approach of Lee and Seung (2001) for
NMF. Right: Comparison between our method and the approach of Hoyer (2002) for
NNSC. The value of the objective function is reported for three data sets as a function of
computation time on a logarithmic scale.
43
MAIRAL, BACH, PONCE AND SAPIRO
earlier observations from Lee and Seung (2001), PCA systematically produces features spread out
over the images, whereas NMF produces more localized features on the face databases D and E.
However, neither PCA, nor NMF are able to learn localized features on the set of natural patches F.
On the other hand, the dictionary learning technique is able to learn localized features on data set F,
and SPCA is the only tested method that allows controlling the level of sparsity among the learned
matrices.
6.3.2 GENOMIC DATA
This experiment follows Witten et al. (2009) and demonstrates that our matrix decomposition tech-
nique can be used for analyzing genomic data. Gene expression measurements and DNA copy
number changes (comparative genomic hybridization CGH) are two popular types of data in ge-
nomic research, which can be used to characterize a set of abnormal tissue samples for instance.
When these two types of data are available, a recent line of research tries to analyze the correla-
tion between them—that is, to determine sets of expression genes which are correlated with sets
of chromosomal gains or losses (see Witten et al., 2009 and references therein). Let us suppose
that for n tissue samples, we have a matrix X in Rn×p of gene expression measurements and a ma-
trix Y in Rn×q of CGH measurements. In order to analyze the correlation between these two sets of
data, recent works have suggested the use of canonical correlation analysis (Hotelling, 1936), which
solves9
min
u∈Rp,v∈Rq
cov(Xu,Yv) s.t. ||Xu||2 ≤ 1 and ||Yv||2 ≤ 1.
When X and Y are centered and normalized, it has been further shown that with this type of data,
good results can be obtained by treating the covariance matrices XT X and YT Y as diagonal, leading
to a rank-one matrix decomposition problem
min
u∈Rp,v∈Rq
||XT Y−uvT ||2F s.t. ||u||2 ≤ 1, and ||v||2 ≤ 1.
Furthermore, as shown by Witten et al. (2009), this method can benefit from sparse regularizers
such as the ℓ1 norm for the gene expression measurements and a fused lasso for the CGH arrays,
which are classical choices used for these data. The formulation we have chosen is slightly different
from the one used by Witten et al. (2009) and can be addressed using our algorithm:
min
u∈Rp,v∈Rq
||YT X−vuT ||2F +λ||u||2 s.t. ||v||22 + γ1||v||1 + γ2 FL(v)≤ 1. (17)
In order to assess the effectivity of our method, we have conducted the same experiment as Witten
et al. (2009) using the breast cancer data set described by Chin et al. (2006), consisting of q = 2,148
gene expression measurements and p = 16,962 CGH measurements for n = 89 tissue samples. The
matrix decomposition problem of Eq. (17) was addressed once for each of the 23 chromosomes, us-
ing each time the CGH data available for the corresponding chromosome, and the gene expression
of all genes. Following the original choice of Witten et al. (2009), we have selected a regulariza-
tion parameter λ resulting in about 25 non-zero coefficients in u, and selected γ1 = γ2 = 1, which
results in sparse and piecewise-constant vectors v. The original matrices (X,Y) are divided into a
training set (Xtr,Ytr) formed with 3/4 of the n samples, keeping the rest (Xte,Yte) for testing. This
9. Note that when more than one couple of factors are needed, two sequences u1,u2, . . . and v1,v2, . . . of factors can be
obtained recursively subject to orthogonality constraints of the sequences Xu1,Xu2, . . . and Yv1,Yv2, . . ..
44
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
(a) PCA (b) SPCA, τ = 70%
(c) NMF (d) SPCA, τ = 30%
(e) Dictionary Learning (f) SPCA, τ = 10%
Figure 3: Results obtained by PCA, NMF, dictionary learning, SPCA for data set D.
45
MAIRAL, BACH, PONCE AND SAPIRO
(a) PCA (b) SPCA, τ = 70%
(c) NMF (d) SPCA, τ = 30%
(e) Dictionary Learning (f) SPCA, τ = 10%
Figure 4: Results obtained by PCA, NMF, dictionary learning, SPCA for data set E.
46
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
(a) PCA (b) SPCA, τ = 70%
(c) NMF (d) SPCA, τ = 30%
(e) Dictionary Learning (f) SPCA, τ = 10%
Figure 5: Results obtained by PCA, NMF, dictionary learning, SPCA for data set F.
47
MAIRAL, BACH, PONCE AND SAPIRO
experiment is repeated for 10 random splits, for each chromosome a couple of factors (u,v) are
computed, and the correlations corr(Xtru,Ytrv) and corr(Xteu,Ytev) are reported on Figure 6. The
average standard deviation of the experiments results was 0.0339 for the training set and 0.1391 for
the test set.
Comparing with the original curves reported by Witten et al. (2009) for their penalized matrix
decomposition (PMD) algorithm, our method exhibits in general a performance similar as PMD.10
Nevertheless, the purpose of this section is more to demonstrate that our method can be used with
genomic data than comparing it carefully with PMD. To draw substantial conclusions about the
performance of both methods, more experiments would of course be needed.
5 10 15 20
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Genomic Experiment: Correlation Analysis
Chromosome
C
or
re
la
tio
n
 
 
Train PMD
Test PMD
Train OL
Test OL
Figure 6: SPCA was applied to the covariance matrix obtained from the breast cancer data (Chin
et al., 2006). A fused lasso regularization is used for the CGH data. 3/4 of the n samples
are used as a training set, keeping the rest for testing. Average correlations from 10
random splits are reported for each of the 23 chromosomes, for PMD (Witten et al., 2009)
and our method denoted by OL.
10. The curves for PMD were generated with the R software package available at http://cran.r-project.org/web/
packages/PMA/index.html and a script provided by Witten et al. (2009).
48
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Figure 7: Inpainting example on a 12-Megapixel image. Top: Damaged and restored images. Bot-
tom: Zooming on the damaged and restored images. Note that the pictures presented here
have been scaled down for display. (Best seen in color).
6.4 Application to Large-Scale Image Processing
We demonstrate in this section that our algorithm can be used for a difficult large-scale image
processing task, namely, removing the text (inpainting) from the damaged 12-Megapixel image
of Figure 7. Using a multi-threaded version of our implementation, we have learned a dictionary
with 256 elements from the roughly 7× 106 undamaged 12× 12 color patches in the image with
two epochs in about 8 minutes on a 2.4GHz machine with eight cores. Once the dictionary has been
learned, the text is removed using the sparse coding technique for inpainting of Mairal et al. (2008b).
Our intent here is of course not to evaluate our learning procedure in inpainting tasks, which would
require a thorough comparison with state-the-art techniques on standard data sets. Instead, we just
wish to demonstrate that it can indeed be applied to a realistic, non-trivial image processing task on
a large image. Indeed, to the best of our knowledge, this is the first time that dictionary learning
is used for image restoration on such large-scale data. For comparison, the dictionaries used for
inpainting in Mairal et al. (2008b) are learned (in batch mode) on 200,000 patches only.
49
MAIRAL, BACH, PONCE AND SAPIRO
7. Conclusion
We have introduced in this paper a new stochastic online algorithm for learning dictionaries adapted
to sparse coding tasks, and proven its convergence. Experiments demonstrate that it is significantly
faster than batch alternatives such as Engan et al. (1999), Aharon et al. (2006) and Lee et al. (2007)
on large data sets that may contain millions of training examples, yet it does not require a careful
learning rate tuning like regular stochastic gradient descent methods. Moreover, we have extended
it to other matrix factorization problems such as non negative matrix factorization, and we have pro-
posed a formulation for sparse principal component analysis which can be solved efficiently using
our method. Our approach has already shown to be useful for image restoration tasks such as de-
noising (Mairal et al., 2009c); more experiments are of course needed to better assess its promise in
bioinformatics and signal processing. Beyond this, we plan to use the proposed learning framework
for sparse coding in computationally demanding video restoration tasks (Protter and Elad, 2009),
with dynamic data sets whose size is not fixed, and extending this framework to different loss func-
tions (Mairal et al., 2009b) to address discriminative tasks such as image classification, which are
more sensitive to overfitting than reconstructive ones.
Acknowledgments
This paper was supported in part by ANR under grant MGA ANR-07-BLAN-0311. The work of
Guillermo Sapiro is partially supported by ONR, NGA, NSF, ARO, and DARPA. The authors would
like to like to thank Sylvain Arlot, Léon Bottou, Jean-Philippe Vert, and the members of the Willow
project-team for helpful discussions, and Daniela Witten for providing us with her code to generate
the curves of Figure 6.
Appendix A. Theorems and Useful Lemmas
We provide in this section a few theorems and lemmas from the optimization and probability litera-
ture, which are used in this paper.
Theorem 5 [Corollary of Theorem 4.1 from Bonnans and Shapiro (1998), due to Danskin
(1967)].
Let f : Rp×Rq→R. Suppose that for all x∈Rp the function f (x, .) is differentiable, and that f and
∇u f (x,u) the derivative of f (x, .) are continuous on Rp×Rq. Let v(u) be the optimal value function
v(u) = minx∈C f (x,u), where C is a compact subset of Rp. Then v(u) is directionally differentiable.
Furthermore, if for u0 ∈Rq, f (.,u0) has a unique minimizer x0 then v(u) is differentiable in u0 and
∇uv(u0) = ∇u f (x0,u0).
Theorem 6 [Sufficient condition of convergence for a stochastic process, see Bottou (1998) and
references therein (Métivier, 1983; Fisk, 1965)].
Let (Ω,F ,P) be a measurable probability space, ut , for t ≥ 0, be the realization of a stochastic
process and Ft be the filtration determined by the past information at time t. Let
δt =
{
1 if E[ut+1−ut |Ft ] > 0,
0 otherwise.
50
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
If for all t, ut ≥ 0 and ∑∞t=1 E[δt(ut+1−ut)] < ∞, then ut is a quasi-martingale and converges almost
surely. Moreover,
∞
∑
t=1
|E[ut+1−ut |Ft ]|< +∞ a.s.
Lemma 7 [A corollary of Donsker theorem see Van der Vaart, 1998, chap. 19.2, lemma 19.36
and example 19.7].
Let F = { fθ : χ→R,θ ∈Θ} be a set of measurable functions indexed by a bounded subset Θ of Rd .
Suppose that there exists a constant K such that
| fθ1(x)− fθ2(x)| ≤ K||θ1−θ2||2,
for every θ1 and θ2 in Θ and x in χ. Then, F is P-Donsker (see Van der Vaart, 1998, chap. 19.2).
For any f in F, Let us define Pn f , P f and Gn f as
Pn f =
1
n
n
∑
i=1
f (Xi), P f = EX [ f (X)], Gn f =
√
n(Pn f −P f ).
Let us also suppose that for all f , P f 2 < δ2 and || f ||∞ < M and that the random elements X1,X2, . . .
are Borel-measurable. Then, we have
EP||Gn||F = O(1),
where ||Gn||F = sup f∈F |Gn f |. For a more general variant of this lemma and additional explana-
tions and examples, see Van der Vaart (1998).
Lemma 8 [A simple lemma on positive converging sums].
Let an, bn be two real sequences such that for all n, an ≥ 0,bn ≥ 0, ∑∞n=1 an = ∞, ∑∞n=1 anbn < ∞,
∃K > 0 s.t. |bn+1−bn|< Kan. Then, limn→+∞ bn = 0.
Proof The proof is similar to Bertsekas (1999, prop 1.2.4).
Appendix B. Efficient Projections Algorithms
In this section, we address the problem of efficiently projecting a vector onto two sets of constraints,
which allows us to extend our algorithm to various other formulations.
B.1 A Linear-time Projection on the Elastic-Net Constraint
Let b be a vector of Rm. We consider the problem of projecting this vector onto the elastic-net
constraint set:
min
u∈Rm
1
2
||b−u||22 s.t. ||u||1 +
γ
2
||u||22 ≤ τ. (18)
To solve efficiently the case γ > 0, we propose Algorithm 3, which extends Maculan and de Paula
(1989) and Duchi et al. (2008), and the following lemma which shows that it solves our problem.
Lemma 9 [Projection onto the elastic-net constraint set].
For b in Rm, γ≥ 0 and τ > 0, Algorithm 3 solves Eq. (18).
51
MAIRAL, BACH, PONCE AND SAPIRO
Proof First, if b is a feasible point of (18), then b is a solution. We suppose therefore that it is not
the case—that is,||b||1 + γ2 ||b||22 > τ. Let us define the Lagrangian of (18)
L(u,λ) =
1
2
||b−u||22 +λ
(
||u||1 +
γ
2
||u||22− τ
)
.
For a fixed λ, minimizing the Lagrangian with respect to u admits a closed-form solution u⋆(λ), and
a simple calculation shows that, for all j,
u⋆(λ)[ j] =
sign(b[ j])(|b[ j]|−λ)+
1+λγ
.
Eq. (18) is a convex optimization problem. Since Slater’s conditions are verified and strong duality
holds, it is equivalent to the dual problem
max
λ≥0
L(u⋆(λ),λ).
Since λ = 0 is not a solution, denoting by λ⋆ the solution, the complementary slackness condition
implies that
||u⋆(λ⋆)||1 +
γ
2
||u⋆(λ⋆)||22 = τ. (19)
Using the closed form of u⋆(λ) is possible to show that the function λ→ ||u⋆(λ)||1 + γ2 ||u⋆(λ)||22,
is strictly decreasing with λ and thus Eq. (19) is a necessary and sufficient condition of optimality
for λ. After a short calculation, one can show that this optimality condition is equivalent to
1
(1+λγ)2 ∑j∈S(λ)
(
|b[ j]|+ γ
2
|b[ j]|2−λ
(
1+
γλ
2
)
)
= τ,
where S(λ) = { j s.t. |b[ j]| ≥ λ}. Suppose that S(λ⋆) is known, then λ⋆ can be computed in closed-
form. To find S(λ⋆), it is then sufficient to find the index k such that S(λ⋆) = S(|b[k]|), which is the
solution of
max
k∈{1,...,m}
|b[k]| s.t. 1
(1+ |b[k]|γ)2 ∑j∈S(|b[k]|)
(
|b[ j]|+ γ
2
|b[ j]|2−|b[k]|
(
1+
γ|b[k]|
2
)
)
< τ.
Lines 4 to 14 of Algorithm 3 are a modification of Duchi et al. (2008) to address this problem.
A similar proof as Duchi et al. (2008) shows the convergence to the solution of this optimization
problem in O(m) in the average case, and lines 15 to 18 of Algorithm 3) compute λ⋆ after that S(λ⋆)
has been identified. Note that setting γ to 0 leads exactly to the algorithm of Duchi et al. (2008).
As for the dictionary learning problem, a simple modification to Algorithm 3 allows us to handle
the non-negative case, replacing the scalars |b[ j]| by max(b[ j],0) in the algorithm.
B.2 A Homotopy Method for Solving the Fused Lasso Signal Approximation
Let b be a vector of Rm. We define, following Friedman et al. (2007), the fused lasso signal approx-
imation problem P (γ1,γ2,γ3):
min
u∈Rm
1
2
||b−u||22 + γ1||u||1 + γ2 FL(u)+
γ3
2
||u||22, (20)
52
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Algorithm 3 Efficient projection on the elastic-net constraint.
Require: τ ∈ R; γ ∈ R; b ∈ Rm;
1: if ||b||1 + γ2 ||b||22 ≤ τ then
2: Return u← b.
3: else
4: U ←{1, . . . ,m}; s← 0; ρ← 0.
5: while U 6= /0 do
6: Pick k ∈U at random.
7: Partition U :
G = { j ∈U s.t. |b[ j]| ≥ |b[k]|},
L = { j ∈U s.t. |b[ j]|< |b[k]|}.
8: ∆ρ← |G|; ∆s← ∑ j∈G |b[ j]|+ γ2 |b[ j]|2.
9: if s+∆s− (ρ+∆ρ)(1+ γ2 |b[k]|)|b[k]|< τ(1+ γ|b[k]|)2 then
10: s← s+∆s;ρ← ∆ρ;U ← L.
11: else
12: U ← G\{k}.
13: end if
14: end while
15: a← γ2τ+ γ2 ρ,
16: b← 2γτ+ρ,
17: c← τ− s,
18: λ← −b+
√
b2−4ac
2a
19:
∀ j = 1, . . . ,n,u[ j]← sign(b[ j])(|b[ j]|−λ)
+
1+λγ
20: Return u.
21: end if
the only difference with Friedman et al. (2007) being the addition of the last quadratic term. The
method we propose to this problem is a homotopy, which solves P (τγ1,τγ2,τγ3) for all possible
values of τ. In particular, for all ε, it provides the solution of the constrained problem
min
u∈Rm
1
2
||b−u||22 s.t. γ1||u||1 + γ2 FL(u)+
γ3
2
||u||22 ≤ ε. (21)
The algorithm relies on the following lemma
Lemma 10 Let u⋆(γ1,γ2,γ3) be the solution of Eq. (20), for specific values of γ1,γ2,γ3. Then
• u⋆(γ1,γ2,γ3) = 11+γ3 u
⋆(γ1,γ2,0).
• For all i, u⋆(γ1,γ2,0)[i] = sign(u⋆(0,γ2,0)[i])max(|u⋆(0,γ2,0)[i]|−λ1,0)—that is, u⋆(γ1,γ2,0)
can be obtained by soft thresholding of u⋆(0,γ2,0).
53
MAIRAL, BACH, PONCE AND SAPIRO
The first point can be shown by short calculation. The second one is proven in Friedman et al.
(2007) by considering subgradient optimality conditions. This lemma shows that if one knows the
solution of P (0,γ2,0), then P (γ1,γ2,γ3) can be obtained in linear time.
It is therefore natural to consider the simplified problem
min
u∈Rm
1
2
||b−u||22 + γ2 FL(u). (22)
With the change of variable v[1] = u[1] and v[i] = u[i]−u[i−1] for i > 1, this problem can be recast
as a weighted Lasso
min
v∈Rm
1
2
||b−Dv||22 +
m
∑
i=1
wi|v[i]|, (23)
where w1 = 0 and wi = γ2 for i > 1, and D[i, j] = 1 if i ≥ j and 0 otherwise. We propose to use
LARS (Efron et al., 2004) and exploit the specific structure of the matrix D to make this approach
efficient, by noticing that:
• For a vector w in Rm, computing e = Dw requires O(m) operations instead of O(m2), by using
the recursive formula e[1] = w[1], e[i+1] = w[i]+ e[i].
• For a vector w in Rn, computing e = DT w requires O(m) operations instead of O(m2), by
using the recursive formula e[n] = w[n], e[i−1] = w[i−1]+ e[i].
• Let Γ = {a1, . . . ,ap} be an active set and suppose a1 < .. . < ap. Then (DTΓDΓ)−1 admits the
closed form value
(DTΓDΓ)
−1 =









c1 −c1 0 . . . 0 0
−c1 c1 + c2 −c2 . . . 0 0
0 −c2 c2 + c3 . . . 0 0
...
...
...
. . .
...
...
0 0 0 . . . cp−2 + cp−1 −cp−1
0 0 0 . . . −cp−1 cp−1 + cp









,
where cp = 1n+1−ap and ci =
1
ai+1−ai for i < p.
This allows the implementation of this homotopy method without using matrix inversion or Cholesky
factorization, solving Eq. (23) in O(ms) operations, where s is the number of non-zero values of the
optimal solution v.11
Adapting this method for solving Eq. (21) requires following the regularization path of the
problems P (0,τγ2,0) for all values of τ, which provides as well the regularization path of the prob-
lem P (τλ1,τλ2,τλ3) and stops whenever the constraint becomes unsatisfied. This procedure still
requires O(ms) operations.
Note that in the case γ1 = 0 and γ3 = 0, when only the fused-lasso term is present in Eq (20),
the same approach has been proposed in a previous work by Harchaoui and Lévy-Leduc (2008),
and Harchaoui (2008) to solve Eq. (22), with the same tricks for improving the efficiency of the
procedure.
11. To be more precise, s is the number of kinks of the regularization path. In practice, s is roughly the same as the
number of non-zero values of the optimal solution v.
54
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
References
M. Aharon and M. Elad. Sparse and redundant modeling of image content using an image-signature-
dictionary. SIAM Journal on Imaging Sciences, 1(3):228–247, July 2008.
M. Aharon, M. Elad, and A. M. Bruckstein. The K-SVD: An algorithm for designing of overcom-
plete dictionaries for sparse representations. IEEE Transactions on Signal Processing, 54(11):
4311–4322, November 2006.
F. Bach. Consistency of the group Lasso and multiple kernel learning. Journal of Machine Learning
Research, 9:1179–1224, 2008.
F. Bach, J. Mairal, and J. Ponce. Convex sparse matrix factorizations. Technical report, 2008.
Preprint arXiv:0812.1869.
D. P. Bertsekas. Nonlinear Programming. Athena Scientific Belmont, 1999.
P. Bickel, Y. Ritov, and A. Tsybakov. Simultaneous analysis of Lasso and Dantzig selector. Annals
of statistics, 37(4):1705–1732, 2009.
J. F. Bonnans and A. Shapiro. Optimization problems with perturbations: A guided tour. SIAM
Review, 40(2):202–227, 1998.
J. F. Bonnans and A. Shapiro. Perturbation Analysis of Optimization Problems. Springer, 2000.
J. M. Borwein and A. S. Lewis. Convex Analysis and Nonlinear Optimization: Theory and Exam-
ples. Springer, 2006.
L. Bottou. Online algorithms and stochastic approximations. In David Saad, editor, Online Learning
and Neural Networks. 1998.
L. Bottou and O. Bousquet. The trade-offs of large scale learning. In J.C. Platt, D. Koller, Y. Singer,
and S. Roweis, editors, Advances in Neural Information Processing Systems, volume 20, pages
161–168. MIT Press, 2008.
D. M. Bradley and J. A. Bagnell. Differentiable sparse coding. In D. Koller, D. Schuurmans, Y. Ben-
gio, and L. Bottou, editors, Advances in Neural Information Processing Systems, volume 21,
pages 113–120. 2009.
S. S. Chen, D. L. Donoho, and M. A. Saunders. Atomic decomposition by basis pursuit. SIAM
Journal on Scientific Computing, 20:33–61, 1999.
K. Chin, S. DeVries, J. Fridlyand, P.T. Spellman, R. Roydasgupta, W. L. Kuo, A. Lapuk, R. M.
Neve, Z. Qian, T. Ryder, et al. Genomic and transcriptional aberrations linked to breast cancer
pathophysiologies. Cancer Cell, 10(6):529–541, 2006.
S. F. Cotter, B. D. Rao, K. Engan, and K. Kreutz-Delgado. Sparse solutions to linear inverse prob-
lems with multiple measurement vectors. IEEE Transactions on Signal Processing, 53(7):2477–
2488, 2005.
55
MAIRAL, BACH, PONCE AND SAPIRO
J. M. Danskin. The theory of max-min, and its application to weapons allocation problems.
Ökonometrie und Unternehmensforschung, 1967.
A. d’Aspremont, L. El Ghaoui, M. I. Jordan, and G. R. G. Lanckriet. A direct formulation for sparse
PCA using semidefinite programming. SIAM Review, 49(3):434–448, 2007.
A. d’Aspremont, F. Bach, and L. El Ghaoui. Optimal solutions for sparse principal component
analysis. Journal of Machine Learning Research, 9:1269–1294, 2008.
J. Duchi, S. Shalev-Shwartz, Y. Singer, and T. Chandra. Efficient projections onto the ℓ1-ball for
learning in high dimensions. In Proceedings of the International Conference on Machine Learn-
ing (ICML), 2008.
B. Efron, T. Hastie, I. Johnstone, and R. Tibshirani. Least angle regression. Annals of Statistics, 32
(2):407–499, 2004.
M. Elad and M. Aharon. Image denoising via sparse and redundant representations over learned
dictionaries. IEEE Transactions on Image Processing, 54(12):3736–3745, December 2006.
K. Engan, S. O. Aase, and J. H. Husoy. Frame based signal compression using method of opti-
mal directions (MOD). In Proceedings of the 1999 IEEE International Symposium on Circuits
Systems, volume 4, 1999.
M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman. The PASCAL Visual
Object Classes Challenge 2006 (VOC2006) Results, 2006.
C. Févotte, N. Bertin, and J. L. Durrieu. Nonnegative matrix factorization with the itakura-saito
divergence: With application to music analysis. Neural Computation, 21(3):793–830, 2009.
D. L. Fisk. Quasi-martingales. Transactions of the American Mathematical Society, 120(3):359–
388, 1965.
J. Friedman, T. Hastie, H. Hölfling, and R. Tibshirani. Pathwise coordinate optimization. Annals of
Applied Statistics, 1(2):302–332, 2007.
W. J. Fu. Penalized regressions: The bridge versus the Lasso. Journal of Computational and
Graphical Statistics, 7:397–416, 1998.
J. J. Fuchs. Recovery of exact sparse representations in the presence of bounded noise. IEEE
Transactions on Information Theory, 51(10):3601–3608, 2005.
A. S. Georghiades, P. N. Belhumeur, and D. J. Kriegman. From few to many: Illumination cone
models for face recognition under variable lighting and pose. IEEE Transactions on Pattern
Analysis and Machine Intelligence, 23(6):643–660, 2001.
G. H. Golub and C. F. Van Loan. Matrix computations. John Hopkins University Press, 1996.
R. Grosse, R. Raina, H. Kwong, and A. Y. Ng. Shift-invariant sparse coding for audio classification.
In Proceedings of the Twenty-third Conference on Uncertainty in Artificial Intelligence (UAI),
2007.
56
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
Z. Harchaoui. Méthodes à Noyaux pour la Détection. PhD thesis, Télécom ParisTech, 2008.
Z. Harchaoui and C. Lévy-Leduc. Catching change-points with Lasso. In J.C. Platt, D. Koller,
Y. Singer, and S. Roweis, editors, Advances in Neural Information Processing Systems, vol-
ume 20, pages 161–168. MIT Press, 2008.
H. Hotelling. Relations between two sets of variates. Biometrika, 28:321–377, 1936.
P. O. Hoyer. Non-negative sparse coding. In Proc. IEEE Workshop on Neural Networks for Signal
Processing, 2002.
P. O. Hoyer. Non-negative matrix factorization with sparseness constraints. Journal of Machine
Learning Research, 5:1457–1469, 2004.
L. Jacob, G. Obozinski, and J.-P. Vert. Group Lasso with overlap and graph Lasso. In Proceedings
of the International Conference on Machine Learning (ICML), 2009.
R. Jenatton, J-Y. Audibert, and F. Bach. Structured variable selection with sparsity-inducing norms.
Technical report, 2009a. Preprint arXiv:0904.3523v1.
R. Jenatton, G. Obozinski, and F. Bach. Structured sparse principal component analysis. Technical
report, 2009b. Preprint arXiv:0909.1440v1.
I. T. Jolliffe, N. T. Trendafilov, and M. Uddin. A modified principal component technique based on
the Lasso. Journal of Computational and Graphical Statistics, 12(3):531–547, 2003.
K. Kavukcuoglu, M. Ranzato, and Y. LeCun. Fast inference in sparse coding algorithms with
applications to object recognition. Technical report, Computational and Biological Learning Lab,
Courant Institute, NYU, 2008.
Y. Koren, R. Bell, and C. Volinsky. Matrix factorization techniques for recommender systems. IEEE
Computer, 42(8):30–37, 2009.
H. J. Kushner and G. Yin. Stochastic Approximation and Recursive Algorithms and Applications.
Springer, 2003.
D. D. Lee and H. S. Seung. Algorithms for non-negative matrix factorization. In Advances in Neural
Information Processing Systems, pages 556–562, 2001.
H. Lee, A. Battle, R. Raina, and A. Y. Ng. Efficient sparse coding algorithms. In B. Schölkopf,
J. Platt, and T. Hoffman, editors, Advances in Neural Information Processing Systems, volume 19,
pages 801–808. MIT Press, 2007.
K. C. Lee, J. Ho, and D. Kriegman. Acquiring linear subspaces for face recognition under variable
lighting. IEEE Transactions on Pattern Analysis and Machine Intelligence, 27(5):684–698, 2005.
M. S. Lewicki and T. J. Sejnowski. Learning overcomplete representations. Neural Computation,
12(2):337–365, 2000.
C.J. Lin. Projected gradient methods for nonnegative matrix factorization. Neural Computation, 19
(10):2756–2779, 2007.
57
MAIRAL, BACH, PONCE AND SAPIRO
N. Maculan and J. R. G. Galdino de Paula. A linear-time median-finding algorithm for projecting a
vector on the simplex of Rn. Operations Research Letters, 8(4):219–222, 1989.
J. R. Magnus and H. Neudecker. Matrix Differential Calculus with Applications in Statistics and
Econometrics, revised edition. John Wiley, Chichester, 1999.
J. Mairal, F. Bach, J. Ponce, G. Sapiro, and A. Zisserman. Discriminative learned dictionaries for
local image analysis. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2008a.
J. Mairal, M. Elad, and G. Sapiro. Sparse representation for color image restoration. IEEE Trans-
actions on Image Processing, 17(1):53–69, January 2008b.
J. Mairal, G. Sapiro, and M. Elad. Learning multiscale sparse representations for image and video
restoration. SIAM Multiscale Modelling and Simulation, 7(1):214–241, April 2008c.
J. Mairal, F. Bach, J. Ponce, and G. Sapiro. Online dictionary learning for sparse coding. In
Proceedings of the International Conference on Machine Learning (ICML), 2009a.
J. Mairal, F. Bach, J. Ponce, G. Sapiro, and A. Zisserman. Supervised dictionary learning. In
D. Koller, D. Schuurmans, Y. Bengio, and L. Bottou, editors, Advances in Neural Information
Processing Systems, volume 21, pages 1033–1040. MIT Press, 2009b.
J. Mairal, F. Bach, J. Ponce, G. Sapiro, and A. Zisserman. Non-local sparse models for image
restoration. In Proceedings of the IEEE International Conference on Computer Vision (ICCV),
2009c.
S. Mallat. A Wavelet Tour of Signal Processing, Second Edition. Academic Press, New York,
September 1999.
M. Métivier. Semi-martingales. Walter de Gruyter, 1983.
R. M. Neal and G. E. Hinton. A view of the EM algorithm that justifies incremental, sparse, and
other variants. Learning in Graphical Models, 89:355–368, 1998.
Y. Nesterov. Gradient methods for minimizing composite objective function. Technical report, Cen-
ter for Operations Research and Econometrics (CORE), Catholic University of Louvain, 2007.
G. Obozinski, M. J. Wainwright, and M. I. Jordan. Union support recovery in high-dimensional
multivariate regression. UC Berkeley Technical Report 761, August 2008.
G. Obozinski, B. Taskar, and M. I. Jordan. Joint covariate selection and joint subspace selection for
multiple classification problems. Statistics and Computing, 2009. Published online.
B. A. Olshausen and D. J. Field. Sparse coding with an overcomplete basis set: A strategy employed
by V1? Vision Research, 37:3311–3325, 1997.
M. R. Osborne, B. Presnell, and B. A. Turlach. A new approach to variable selection in least squares
problems. IMA Journal of Numerical Analysis, 20(3):389–403, 2000.
58
ONLINE LEARNING FOR MATRIX FACTORIZATION AND SPARSE CODING
G. Peyré. Sparse modeling of textures. Journal of Mathematical Imaging and Vision, 34(1):17–31,
May 2009.
M. Protter and M. Elad. Image sequence denoising via sparse and redundant representations. IEEE
Transactions on Image Processing, 18(1):27–36, 2009.
R. Raina, A. Battle, H. Lee, B. Packer, and A. Y. Ng. Self-taught learning: transfer learning from
unlabeled data. In Proceedings of the International Conference on Machine Learning (ICML),
2007.
V. Roth and B. Fischer. The Group-Lasso for generalized linear models: uniqueness of solutions
and efficient algorithms. In Proceedings of the International Conference on Machine Learning
(ICML), 2008.
S. Shalev-Shwartz, O. Shamir, N. Srebro, and K. Sridharan. Stochastic convex optimization. In
22nd Annual Conference on Learning Theory (COLT), 2009.
K.-K. Sung. Learning and Example Selection for Object and Pattern Recognition. PhD thesis, MIT,
Artificial Intelligence Laboratory and Center for Biological and Computational Learning, 1996.
R. Tibshirani. Regression shrinkage and selection via the Lasso. Journal of the Royal Statistical
Society. Series B, 58(1):267–288, 1996.
R. Tibshirani and P. Wang. Spatial smoothing and hot spot detection for CGH data using the fused
Lasso. Biostatistics, 9(1):18–29, 2008.
R. Tibshirani, M. Saunders, S. Rosset, J. Zhu, and K. Knight. Sparsity and smoothness via the fused
lasso. Journal of the Royal Statistical Society Series B, 67(1):91–108, 2005.
J. A. Tropp. Algorithms for simultaneous sparse approximation. part ii: Convex relaxation. Signal
Processing, Special Issue ”Sparse Approximations in Signal and Image Processing”, 86:589–
602, April 2006.
J. A. Tropp, A. C. Gilbert, and M. J. Strauss. Algorithms for simultaneous sparse approximation.
part i: Greedy pursuit. Signal Processing, Special Issue ”Sparse Approximations in Signal and
Image Processing”, 86:572–588, April 2006.
B. A. Turlach, W. N. Venables, and S. J. Wright. Simultaneous variable selection. Technometrics,
47(3):349–363, 2005.
A. W. Van der Vaart. Asymptotic Statistics. Cambridge University Press, 1998.
D. M. Witten, R. Tibshirani, and T. Hastie. A penalized matrix decomposition, with applications
to sparse principal components and canonical correlation analysis. Biostatistics, 10(3):515–534,
2009.
T. T. Wu and K. Lange. Coordinate descent algorithms for Lasso penalized regression. Annals of
Applied Statistics, 2(1):224–244, 2008.
59
MAIRAL, BACH, PONCE AND SAPIRO
J. Yang, K. Yu, Y. Gong, and T. Huang. Linear spatial pyramid matching using sparse coding for
image classification. In Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2009.
M. Yuan and Y. Lin. Model selection and estimation in regression with grouped variables. Journal
of the Royal Statistical Society Series B, 68:49–67, 2006.
R. Zass and A. Shashua. Nonnegative sparse PCA. In B. Schölkopf, J. Platt, and T. Hoffman,
editors, Advances in Neural Information Processing Systems, volume 19, pages 1561–1568. MIT
Press, 2007.
H. H. Zhang, Y. Liu, Y. Wu, and J. Zhu. Selection for the multicategory svm via adaptive sup-norm
regularization. Electronic Journal of Statistics, 2:149–167, 2008.
M. Zibulevsky and B. A. Pearlmutter. Blind source separation by sparse decomposition in a signal
dictionary. Neural Computation, 13(4):863–882, 2001.
H. Zou and T. Hastie. Regularization and variable selection via the elastic net. Journal of the Royal
Statistical Society Series B, 67(2):301–320, 2005.
H. Zou, T. Hastie, and R. Tibshirani. Sparse principal component analysis. Journal of Computa-
tional and Graphical Statistics, 15(2):265–286, 2006.
60

