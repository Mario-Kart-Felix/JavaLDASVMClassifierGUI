IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002 415
A Comparison of Methods for Multiclass
Support Vector Machines
Chih-Wei Hsu and Chih-Jen Lin
Abstract—Support vector machines (SVMs) were originally
designed for binary classification. How to effectively extend it for
multiclass classification is still an ongoing research issue. Several
methods have been proposed where typically we construct a
multiclass classifier by combining several binary classifiers. Some
authors also proposed methods that consider all classes at once. As
it is computationally more expensive to solve multiclass problems,
comparisons of these methods using large-scale problems have
not been seriously conducted. Especially for methods solving
multiclass SVM in one step, a much larger optimization problem
is required so up to now experiments are limited to small data sets.
In this paper we give decomposition implementations for two such
“all-together” methods. We then compare their performance with
three methods based on binary classifications: “one-against-all,”
“one-against-one,” and directed acyclic graph SVM (DAGSVM).
Our experiments indicate that the “one-against-one” and DAG
methods are more suitable for practical use than the other
methods. Results also show that for large problems methods by
considering all data at once in general need fewer support vectors.
Index Terms—Decomposition methods, multiclass classification,
support vector machines (SVMs).
I. INTRODUCTION
SUPPORT vector machines (SVMs) [6] were originally de-signed for binary classification. How to effectively extend
it for multiclass classification is still an ongoing research issue.
Currently there are two types of approaches for multiclass SVM.
One is by constructing and combining several binary classifiers
while the other is by directly considering all data in one opti-
mization formulation. Up to now there are still no comparisons
which cover most of these methods.
The formulation to solve multiclass SVM problems in one
step has variables proportional to the number of classes. There-
fore, for multiclass SVM methods, either several binary clas-
sifiers have to be constructed or a larger optimization problem
is needed. Hence in general it is computationally more expen-
sive to solve a multiclass problem than a binary problem with
the same number of data. Up to now experiments are limited
to small data sets. In this paper we will give a decomposition
implementation for two such “all-together” methods: [25], [27]
and [7]. We then compare their performance with three methods
based on binary classification: “one-against-all,” “one-against-
one,” and DAGSVM [23].
Manuscript received April 9, 2001; revised August 22, 2001. This work was
supported in part by the National Science Council of Taiwan under Grant NSC
89-2213-E-002-106.
The authors are with the Department of Computer Science and Informa-
tion Engineering, National Taiwan University, Taipei 106, Taiwan (e-mail:
cjlin@csie.ntu.edu.tw).
Publisher Item Identifier S 1045-9227(02)01805-2.
Note that it was pointed out in [11] that the primal forms
proposed in [25], [27] are also equivalent to those in [3], [11].
Besides methods mentioned above, there are other implemen-
tations for multiclass SVM. For example, [14], [19]. However,
due to the limit of space here we do not conduct experiments
on them. An earlier comparison between one-against-one and
one-against-all methods is in [5].
In Section II, we review one-against-all, one-against-one, and
directed acyclic graph SVM (DAGSVM) methods which are
based on solving several binary classifications. In Section III,
we give a brief introduction to the method in [25], [27] which
considers all classes at once and show that the decomposition
method proposed in [12] can be applied. Another method which
also considers all variables together is by Crammer and Singer
[7], which will be discussed in Section IV. Numerical experi-
ments are in Section V where we show that “one-against-one”
and DAG methods are more suitable for practical use than the
other methods. Results also show that for large problems the
method proposed in [25], [27] by considering all variables at
once generally needs fewer support vectors. Finally, we have
some discussions and conclusions in Section VI.
II. ONE-AGAINST-ALL, ONE-AGAINST-ONE,
AND DAGSVM METHODS
The earliest used implementation for SVM multiclass clas-
sification is probably the one-against-all method (for example,
[2]). It constructs SVM models where is the number of
classes. The th SVM is trained with all of the examples in
the th class with positive labels, and all other examples with
negative labels. Thus given training data ,
where and is the class of
, the th SVM solves the following problem:
if
if
(1)
where the training data are mapped to a higher dimensional
space by the function and is the penalty parameter.
Minimizing means that we would like to max-
imize , the margin between two groups of data. When
data are not linear separable, there is a penalty term
which can reduce the number of training errors. The basic con-
cept behind SVM is to search for a balance between the regu-
larization term and the training errors.
1045-9227/02$17.00 © 2002 IEEE
416 IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002
After solving (1), there are decision functions
...
We say is in the class which has the largest value of the deci-
sion function
class of (2)
Practically, we solve the dual problem of (1) whose number
of variables is the same as the number of data in (1). Hence
-variable quadratic programming problems are solved.
Another major method is called the one-against-one method.
It was introduced in [15], and the first use of this strategy on
SVM was in [9], [16]. This method constructs clas-
sifiers where each one is trained on data from two classes. For
training data from the th and the th classes, we solve the fol-
lowing binary classification problem:
if
if
(3)
There are different methods for doing the future testing after
all classifiers are constructed. After some tests, we
decide to use the following voting strategy suggested in [9]: if
says is in the th class, then the vote for
the th class is added by one. Otherwise, the th is increased by
one. Then we predict is in the class with the largest vote. The
voting approach described above is also called the “Max Wins”
strategy. In case that two classes have identical votes, thought it
may not be a good strategy, now we simply select the one with
the smaller index.
Practically we solve the dual of (3) whose number of variables
is the same as the number of data in two classes. Hence if in
average each class has data points, we have to solve
quadratic programming problems where each of them has
about variables.
The third algorithm discussed here is the directed acyclic
graph SVM (DAGSVM) proposed in [23]. Its training phase is
the same as the one-against-one method by solving
binary SVMs. However, in the testing phase, it uses a rooted bi-
nary directed acyclic graph which has internal nodes
and leaves. Each node is a binary SVM of th and th classes.
Given a test sample , starting at the root node, the binary deci-
sion function is evaluated. Then it moves to either left or right
depending on the output value. Therefore, we go through a path
before reaching a leaf node which indicates the predicted class.
An advantage of using a DAG is that [23] some analysis of
generalization can be established. There are still no similar the-
oretical results for one-against-all and one-against-one methods
yet. In addition, its testing time is less than the one-against-one
method.
We have implemented all three methods by modifying our
SVM software LIBSVM [4].
III. A METHOD BY CONSIDERING ALL DATA AT ONCE
AND A DECOMPOSITION IMPLEMENTATION
In [25], [27], an approach for multiclass problems by solving
one single optimization problem was proposed. The idea is sim-
ilar to the one-against-all approach. It constructs two-class
rules where the th function separates training
vectors of the class from the other vectors. Hence there are
decision functions but all are obtained by solving one problem.
The formulation is as follows:
(4)
Then the decision function is
which is the same as (2) of the one-against-all method. Like bi-
nary SVM, it is easier to solve the dual problem here. Following
[27], the dual formulation of (4) is
(5a)
(5b)
if
if
(5c)
where . Then
(6)
and the decision function is
Next we explain that (4) is equivalent to two formulations
where one is from [11]
(7a)
(7b)
HSU AND LIN: A COMPARISON OF METHODS FOR MULTICLASS SUPPORT VECTOR MACHINES 417
and the other is from [3]
(8)
with the same constraints of (4).
For the optimal solution of (4), from (6) and (5c), we have
Hence, adding (7b) to (4) does not affect the optimal solution
set. Then (7b) implies
so (4) and (7) have the same optimal solution set. Similar argu-
ments can prove the relation between (4) and (8) as well. The
equivalence of these formulations was first discussed in [11].
Note that (5) has variables where of them are always
zero. Hence we can also say it has variables. Unfor-
tunately (5) was considered as an impractical formula due to
this huge amount of variables. Hence in [27] only small prob-
lems are tested. In the rest of this section we discuss a possible
implementation for solving larger problems.
Remember that when solving binary SVM, a main difficulty
is on the density of the kernel matrix as in general is not
zero. Thus currently the decomposition method is the major
method to solve binary support vector machines [21], [13], [22],
[24]. It is an iterative process where in each iteration the index
set of variables are separated to two sets and , where is
the working set. Then in that iteration variables corresponding
to are fixed while a subproblem on variables corresponding to
is minimized. The size of and the selection of its contents
are both important issues on designing a decomposition method.
For example, the sequential minimal optimization (SMO) by
Platt [22] considers only two variables in each iteration. Then
in each iteration of the decomposition method the sub-problem
on two variables can be analytically solved. Hence no optimiza-
tion software is needed.
However, such working set selections in the binary case may
not work here for the dual problem (5). Instead of only one linear
constraint in the dual of (1), now in (5a) we have linear con-
straints. Thus we can think (5a) as a system of linear equations
with variables. Note that the size of the working set is the
number of variables we would like to change in one iteration.
If it is less than , then (5a) may be an over-determined linear
system with more equations than variables so the solution of the
decomposition algorithm cannot be moved. Therefore, in gen-
eral we have to select more than variables in the working set of
each iteration. However, this is still not an easy task as bounded
constraints (5b) have to be considered as well and we would like
to have a systematic way which ensures that the selection leads
to the decrease of the objective function. Unfortunately, so far
we have not found out effective ways of doing it.
Therefore, instead of working on (4), we consider the fol-
lowing problem by adding to the objective function:
(9)
Then in the dual problem linear constraints are removed
if
if
(10)
The decision function becomes
The idea of using bounded formulations for binary classifica-
tion was first proposed in [10], [18]. For two-class problems, a
detailed numerical study showing that the bounded formulation
can achieve similar accuracy as the standard SVM is in [12],
where the software BSVM was proposed. Without linear con-
straints, we hope that the problem of selecting the working set
in the decomposition method becomes easier. Of course it is not
clear yet if the accuracy will be affected as now terms are
added to the objective function. We will see the results in the
experiment section.
For (10), the same decomposition method as in [12] can be
applied. We rewrite (10) as the following general form:
(11)
where is a by one vector and is a by matrix. Then
in each iteration, the subproblem is as follows:
(12)
where is a permutation of the matrix and
is the size of the working set. Note that as are fixed
variables, we do not select them into the working set.
418 IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002
Assume that is the solution of the current iteration and is
the size of the working set. We use the following working set
selection of BSVM:
1) Let be the number of free variables at and calculate
if
if
if
2) Select indexes of the largest elements in ,
where is free (i.e., ) into .
Select the smallest elements in into .
The main idea of this working set selection is from
Zoutendijk’s feasible-direction method [28]
if if (13)
If is an optimal solution of (13), then must be or .
The vector defined above actually has .
Thus selecting the smallest elements in is like selecting
components with the best steepest descent direction. This has
been used in some early implementations of the decomposition
methods (e.g., [13]). However, it was pointed out in [12] that
such a selection of the working set may lead to very slow
convergence on some difficult problems. With some theoretical
and experimental analyzes, in [12] the authors proposed to
include some of the largest elements of whose corresponding
are free (i.e., ). Therefore, if is the size
of the working set, we pick indexes from the smallest
elements of and the other from the largest of whose
corresponding are free.
The major difficulty for the implementation lies in calculating
elements of which are mainly accessed as and in
(12). As in (5) has a very complicated form, it is essential to
avoid some possible computational overheads.
More importantly, the form in (10) is not symmetric to in-
dexes and . That is
This increases the difficulty of writing down the explicit form of
. As any quadratic formulation can be written as a symmetric
form, we must reformulate (10). This will be explained in (15).
Note that as
(14a)
(14b)
for any nonzero vector
Hence, is positive semidefinite and (10) is a convex optimiza-
tion problem. Here (14a) to (14b) is by direct calculation. It is
easy to see how the first and third terms of in (14a) are ob-
tained from (14b). For the second term, we have
Next we discuss the explicit form of . In particular, we will
show what a column of is. We consider the vector as the
following form . In addition, for
, we assume that if is in a position
before .
In (10), the quadratic terms compose of three groups. First we
have
if
if
Clearly this part forms a symmetric matrix as follows:
. . .
. . .
...
. . .
where includes all elements with
. This implies that for the th column, row
indexes corresponding to will have
contributed by this part. We use to represent
and for .
HSU AND LIN: A COMPARISON OF METHODS FOR MULTICLASS SUPPORT VECTOR MACHINES 419
For the third term, , clearly it
forms the following symmetric matrix:
. . .
Similarly we say that at the th column, row indexes
corresponding to will include .
The most complicated one is the second part
as it is not a symmetric form. To make
it symmetric we use the property that any quadratic term
(15)
Hence for the th column, elements corresponding
to and will have
and , respectively.
In summary, the th column of can be obtained
as follows:
1) Obtain the column vector . Initialize the
th column as the a by one zero vector.
2) For elements corresponding to , add
(from the third part)
3) For elements corresponding to , minus
(from the second part)
4) For elements corresponding to each of ,
add (from the first part)
5) For elements corresponding to each of ,
minus (from the second part)
Thus in (12) is a dense but not a fully dense matrix. Its
number of nonzero elements is about . For practical im-
plementations, we compute and cache instead of elements
in . The reduction of the cached matrix from to further
improve the training time of this algorithm.
There are different implementations of the above procedure.
As the situation may vary for different computational environ-
ment, here we do not get into further details.
We have implemented this method as an extension of
BSVM and LIBSVM which will be used for the experi-
ments in Section V. In addition, the software is available at
http://www.csie.ntu.edu.tw/~cjlin/bsvm.
IV. METHOD BY CRAMMER AND SINGER
In [7], Crammer and Singer proposed an approach for mul-
ticlass problems by solving a single optimization problem. We
will also give a decomposition implementation here. Basically
[7] solves the following primal problem:
(16)
where and
if
if
Then the decision function is
The main difference from (4) is that (16) uses only slack
variables . That is, instead of using as the gap
between each two decision planes, here the maximum of such
numbers is considered
where . In addition, (16) does not contain
coefficients . Note that here we do not have to
explicitly write down constraints as when
so (16) becomes
which is exactly .
The dual problem of (16) is
(17a)
if
if
(17b)
where
and
Then
If we write and
, then the dual objective
function can be written as
where is an by identity matrix and is the Kronecker
product. Since is positive semidefinite, , the Hessian
of the dual objective function is also positive semidefinite. This
is another way to explain that (17) is a convex optimization
problem.
420 IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002
The decision function is
The main difference between linear constraints (5a) and (17a) is
that (5a) has equations while (17a) has . It is interesting that
they come from the Karush–Kuhn–Tucker (KKT) condition on
different primal variables. (5a) is due to the unconstrained vari-
ables in (4) while (17a) is from the unconstrained
variables . In addition, (17a) is much simpler than (5a)
as each of its equations involves exactly variables. In a sense
we can say that (17a) contains independent equations. Be-
cause of this advantage, unlike (5a) where we have to remove
linear constraints and use (9), here it is easier to directly conduct
working set selections for the decomposition method.
In [7] the authors proposed to choose variables associated
with the same in the working set. That is, are
elements of the working set where the selection of the index
will be discussed in (20). Then the subproblem is
(18)
where
and
In addition, is a by one vector with all
elements zero except that the th component is .
The main reason of this setting is that (18) is a very simple
problem. In [7], an algorithm was proposed for (18)
while in [8], a simple iterative approach was used. Here we use
the first method. In addition, it is easier to systematically calcu-
late and so many complicated derivations in the previous
section are avoided.
Note that the gradient of the dual objective function is
...
...
...
Then , a by one vector, can be calculated as follows by the
information of the gradient
Therefore, during iterations it is essential to always keep the
gradient updated. This is done after new are obtained
by (18) and operations are needed.
Next we discuss the selection of the working set and the stop-
ping condition of the decomposition method. The KKT condi-
tion requires that there are and
such that for all
and
They are equivalent to that for all
if
if
We can rewrite this as
(19)
Then during iterations, we select the next working set
with from
(20)
In other words, among the -component groups of variables,
we select the one with the largest violation of the KKT condi-
tion. For binary SVM, choosing indexes which most violate the
KKT condition has been a common strategy (e.g., [4]) though
here instead we choose a whole group at once. Then for vari-
ables which are selected, they do not satisfy the
KKT condition of the subproblem (18) so solving (18) will guar-
antee the strict decrease on the objective function of the dual
problem.
Following (19) the stopping criterion can be
(21)
where is the stopping tolerance.
The convergence of the above decomposition method has
been proved in [17]. In addition, [17] shows that the limit of
HSU AND LIN: A COMPARISON OF METHODS FOR MULTICLASS SUPPORT VECTOR MACHINES 421
TABLE I
PROBLEM STATISTICS
goes to zero as the number of iterations goes to infinity. Hence
in a finite number of iterations, the decomposition method stops
as (21) is satisfied. The implementation is now part of BSVM
2.0 which is also publicly available to users.
V. NUMERICAL EXPERIMENTS
A. Data and Implementation
In this section we present experimental results on several
problems from the Statlog collection [20] and the UCI Repos-
itory of machine learning databases [1]. From UCI Repository
we choose the following datasets: iris, wine, glass, and vowel.
Those problems had already been tested in [27]. From Statlog
collection we choose all multiclass datasets: vehicle, segment,
dna, satimage, letter, and shuttle. Note that except problem
dna we scale all training data to be in [ 1, 1]. Then test data are
adjusted to [ 1,1] accordingly. For the problem dna, we do not
scale its binary attributes. We give problem statistics in Table I.
For some of these problems test sets are available. Note that
for problems glass and satimage, there is one missing class.
That is, in the original application there is one more class but in
the data set no examples are with this class. In the last column
we also give the best test rate listed in statlog homepage. Note
that these best rates were obtained by four different learning
methods.
The most important criterion for evaluating the performance
of these methods is their accuracy rate. However, it is unfair
to use only one parameter set and then compare these five
methods. Practically for any method people find the best pa-
rameters by performing the model selection. This is conducted
on the training data where the test data are assumed unknown.
Then the best parameter set is used for constructing the model
for future testing. Note that details of how we conduct the model
selection will be discussed later in this section. To reduce the
search space of parameter sets, here we train all datasets only
with the RBF kernel . In addition,
for methods solving several binary SVMs (one-against-one,
one-against-all, and DAG), for each model we consider that
and of all binary problems are the same. Note that this
issue does not arise for two all-together methods as each model
corresponds to only one optimization problem.
We use similar stopping criteria for all methods. For each
problem we stop the optimization algorithm if the KKT viola-
tion is less than . To be more precise, each dual problem
of the one-against-one and one-against-all approaches has the
following general form:
where . Using a similar derivation of the stopping cri-
terion (21) of the method by Crammer and Singer, we have
(22)
For (10) of the all-together approach, (22) becomes even simpler
as there are no vector . Unfortunately though these stopping
criteria are nearly the same, they are not fully comparable due
to different size of dual problems in these approaches. We will
elaborate more on this issue in Section VI. Note that for prob-
lems letter and shuttle, a relaxed tolerance 0.1 is used for the
method by Crammer and Singer as otherwise it takes too much
training time. More information on the stopping criteria of the
decomposition method can be found in [17].
The computational experiments for this section were done
on a Pentium III-500 with 384 MB RAM using the gcc com-
piler. For each optimization problem (either binary SVMs or the
all-together approaches), we allocate 256 MB memory as the
cache for storing recently used kernel elements. Each element
of stored in the cache is in double precision. For the same
size of the cache, if the single precision is used, the number of
elements which can be stored in the cache is doubled. We have
both implementations but here only the double-precision one is
used.
While implementing these approaches using the decompo-
sition method, we can use a shrinking technique for reducing
422 IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002
TABLE II
A COMPARISON USING THE RBF KERNEL (BEST RATES BOLD-FACED)
the training time. To be more precise, if most variables are fi-
nally at bounds, the shrinking technique reduces the size of
the working problem by considering only free variables. We
have implemented the shrinking technique on all five methods.
For the three methods based on binary classifiers, details are in
([4], Section 4). For two all-together methods, the implementa-
tion is more sophisticated. This is a disadvantage of all-together
methods. Though they consider only one optimization problem,
this problem is more complicated for practical implementations.
B. Results and Discussions
For each problem, we estimate the generalized accuracy
using different kernel parameters and cost parameters
and .
Therefore, for each problem we try combina-
tions. We use two criteria to estimate the generalized accuracy.
For datasets dna, satimage, letter, and shuttle where both
training and testing sets are available, for each pair of ,
the validation performance is measured by training 70% of
the training set and testing the other 30% of the training set.
Then we train the whole training set using the pair of
that achieves the best validation rate and predict the test set.
The resulting accuracy is presented in the “rate” column of
Table II. Note that if several have the same accuracy in
the validation stage, we apply all of them to the test data and
report the highest rate. For the other six smaller datasets where
test data may not be available, we simply conduct a ten-fold
cross-validation on the whole training data and report the best
cross-validation rate.
Table II presents the result of comparing five methods. We
present the optimal parameters and the corresponding ac-
curacy rates. Note that the “C&S” column means the method
by Crammer and Singer. It can be seen that optimal parameters
are in various ranges for different problems so it is essen-
tial to test so many parameter sets. We also observe that their ac-
curacy is very similar. That is, no one is statistically better than
the others. Comparing to earlier results listed in Statlog (see the
last column of Table I), the accuracy obtained by SVM is com-
petitive or even better. For example, among the four problems
dna to shuttle, the one-against-one approach obtains better ac-
curacy on satimage and letter. For the other two problems, the
accuracy is also close to that in Table I.
We also report the training time, testing time, and the number
of unique support vectors in Table III. Note that they are re-
sults when solving the optimal model. For small problems there
are no testing time as we conduct cross validation. Here we
say “unique” support vectors because a training data may corre-
spond to different nonzero dual variables. For example, for the
one-against-one and one-against-all approaches, one training
data may be a support vector in different binary classifiers. For
the all-together methods, there are variables so one data may
associate with different nonzero dual variables. Here we report
only the number of training data which corresponds to at least
one nonzero dual variable. We will explain later that this is the
main factor which affects the testing time. Note that the number
of support vectors of the first six problems are not integers. This
is because they are the average of the ten-fold cross-validation.
For the training time, one-against-one and DAG methods are
the best. In fact the two methods have the same training proce-
dure. Though we have to train as many as classifiers,
as each problem is smaller (only data from two classes), the total
training time is still less. Note that in Table III the training time
of one-against-one and DAG methods may be quite different for
the same problem (e.g., vehicle). This is due to the difference
on the optimal parameter sets.
Although we improve the method from [25], [27] with ef-
forts in Section III, its training speed remains slow. The conver-
gence speed of the method by Crammer and Singer is also not
good. Especially for some problems (iris, vehicle, and shuttle)
its training time is huge. For these problems we note that the
optimal parameter of is quite large. The experience in [12]
shows that if the working set selection is not good, the conver-
gence of the decomposition method may be slow when using a
large . Thus the difficulty might be on the working set selec-
tion. As in each iteration only one of the equalities is involved,
HSU AND LIN: A COMPARISON OF METHODS FOR MULTICLASS SUPPORT VECTOR MACHINES 423
TABLE III
TRAINING TIME, TESTING TIME, AND NUMBER OF SUPPORT VECTORS (TIME IN SECONDS;
BEST TRAINING AND TEST TIME BOLD-FACED; LEAST NUMBER OF SVS ITALICIZED)
TABLE IV
A COMPARISON USING THE LINEAR KERNEL (BEST RATES BOLD-FACED)
there may not be enough interactions among these groups of
variables.
Regarding the testing time, though the decision function is
more complicated than the binary case, our experimental results
indicate that in general the testing time is still dominated by the
kernel evaluations. Note that to save testing time, we always
calculate and store all first, where is any “unique”
support vector and is the test data. Then this may be
used in several places of the decision function. We observe that
if is small , kernel evaluations take more than 90% of
the testing time. Therefore, we can say that in general the testing
time is proportional to the number of “unique” support vectors.
We also observe that between the one-against-one and DAG
methods, DAG is really a little faster on the testing time.
We then discuss the number of support vectors. We can see
that for larger problems, the method from [25], [27] returns
fewer support vectors than all three binary-based approaches.
Note that we generally observe that for the same parameter set,
it needs fewer support vectors. This is consistent with the results
in [27]. Here we do not really have such a comparison as the op-
timal parameters vary for all approaches. Especially for small
problems their optimal parameters are very different. However,
for large problems their optimal parameters are similar so in
Table II the “#SVs” column of the method from [25], [27] re-
ally shows smaller numbers. Therefore, if the testing time is very
important, this method can be an option. On the other hand, we
cannot draw any conclusions about the method by Crammer and
Singer. Sometimes it needs very few support vectors but some-
times the number is huge.
We would like to note that for the problem dna, several pa-
rameters get the best result during the validation stage. Then
when applying them to the test data, some of them have the same
accuracy again. In Table II we present only the result which has
the smallest number of support vectors.
424 IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 13, NO. 2, MARCH 2002
Overall, except the training time, other factors are very sim-
ilar for these approaches. Thus we suggest that one-against-one
and DAG approaches are more suitable for practical use.
To have more complete analysis, we test these methods
by using the linear kernel . Results are in
Table IV. Due to the limit of computational time, we report
only small problems. Now the only parameter is so we
test 15 different ’s and report the best rate. Comparing to
Table II, the difference on the best rates is apparent. The
one-against-all method returns the worst accuracy for some
problems. Overall one-against-one and DAG still perform well.
The comparison on linear and nonlinear kernels also reveals
the necessity of using nonlinear kernels in some situations.
The observation that overall the RBF kernel produces better
accuracy is important as otherwise we do not even need to
study the decomposition methods which is specially designed
for the nonlinear case. There are already effective methods to
solve very large problems with the linear kernel.
Finally we would like to draw some remarks about the im-
plementation of these methods. The training time of the one-
against-all method can be further improved as now for each pa-
rameter set, binary problems are treated independently. That
is, kernel elements used when solving one binary problem are
not stored and passed to other binary problems though they have
the same kernel matrix. Hence the same kernel element may
be calculated several times. However, we expect that even with
such improvements it still cannot compete with one-against-one
and DAG on the training time. For all other approaches, caches
have been implemented so that all problems involved in one
model can share them. On the other hand, for all approaches,
now different models (i.e., different parameter sets) are fully
independent. There are no caches for passing kernel elements
from one model to another.
VI. DISCUSSION AND CONCLUSION
We note that a difference between all-together methods is
that the method by Crammer and Singer does not include bias
terms . We are wondering whether this may affect the
training time. Here we give a brief discussion on this issue. If
are added, (16) becomes
(23)
Then from the KKT condition the dual has some additional
equalities
TABLE V
NUMBER OF ITERATIONS: A COMPARISON ON SOLVING (17) AND (24)
Then again the same difficulty on the working set selection for
(5) happens again so we may have to add to
the objective function of (23). The dual problem hence is
if if
(24)
which can be solved by the same decomposition method de-
scribed in Section IV. Then
so the decision function is
We modify the code for (24) and by using the optimal pa-
rameters listed in the last column of Table III, a comparison
on the number of iterations between solving (17) and (24) is
in Table V. We provide only results of the four large problems.
It can be clearly seen that after adding the bias term, the per-
formance is not better. It is not clear yet why the number of
iterations is nearly doubled but this is not surprising as in [12]
we have demonstrated that for binary SVM, with or without
in the objective function, the performance of the same decom-
position method can be quite different. Overall we realize that
the working set selection (20) may not be very good to have fast
convergence for (16).
The second issue which will be discussed here is about the
stopping criteria. Though we use stopping criteria from the same
derivation, they are affected by the problem size. That is, the
smaller the dual problem is, fewer variables are involved in the
calculation of of (22). Therefore, in some sense ap-
proaches like one-against-one which use smaller dual problems
take advantages (or say they stop earlier). A possible remedy
is to divide the left-hand-side of (22) by the size of the dual
problem. More investigation are needed for this issue. How-
ever, even with such differences, our conclusion that all-together
methods take more training time should remain as from Table III
we can see for both approaches on some problems their training
time is much longer. For example, the method by Crammer and
HSU AND LIN: A COMPARISON OF METHODS FOR MULTICLASS SUPPORT VECTOR MACHINES 425
Singer solve a -variable problem and for problems letter and
shuttle, we relax the stopping tolerance to 0.1. This is like that
we divide the left-hand-side of (21) by 100 which is grater then
, the number of classes. However, its training time still cannot
compete with that of the one-against-all approach which solves
dual problems with variables.
In conclusion, we have discussed decomposition im-
plementations for two alltogether methods and compared
them with three methods based on several binary classifiers:
one-against-one, one-against-all and DAG. Experiments on
large problems show that one-against-one method and DAG
may be more suitable for practical use. A future work is to test
data with a very large number of classes. Especially people
have suspected that there may have more differences among
these methods if the data set has few points in many classes
[26].
ACKNOWLEDGMENT
Part of the implementations benefited from the work of
C.-C. Chang. The authors also thank J. Weston, A. Elisseeff,
S. Keerthi, Y. Guermeur, and Y. Singer for many helpful
comments.
REFERENCES
[1] C. L. Blake and C. J. Merz. (1998) UCI Repository of Machine
Learning Databases. Univ. California, Dept. Inform. Comput. Sci.,
Irvine, CA. [Online]. Available: http://www.ics.uci.edu/~mlearn/ML-
Repository.html
[2] L. Bottou, C. Cortes, J. Denker, H. Drucker, I. Guyon, L. Jackel, Y.
LeCun, U. Muller, E. Sackinger, P. Simard, and V. Vapnik, “Comparison
of classifier methods: A case study in handwriting digit recognition,” in
Proc. Int. Conf. Pattern Recognition. , 1994, pp. 77–87.
[3] E. J. Bredensteiner and K. P. Bennett, “Multicategory classification by
support vector machines,” Comput. Optimiz. Applicat., pp. 53–79, 1999.
[4] LIBSVM: A Library for Support Vector Machines, C.-C. Chang and
C.-J. Lin. (2001). [Online]. Available: http://www.csie.ntu.edu.tw/
~cjlin/libsvm
[5] K. K. Chin, “Support Vector Machines Applied to Speech Pattern Clas-
sification,” Master’s Thesis, Univ. Cambridge, Cambridge, U.K., 1998.
[6] C. Cortes and V. Vapnik, “Support-vector network,” Machine Learning,
vol. 20, pp. 273–297, 1995.
[7] K. Crammer and Y. Singer, “On the learnability and design of output
codes for multiclass problems,” Comput. Learing Theory, pp. 35–46,
2000.
[8] , “Ultraconservative Online Algorithms for Multiclass Problems,”
School Comput. Sci. Eng., Hebrew Univ., Tech. Rep., 2001.
[9] J. Friedman. (1996) Another Approach to Polychotomous Classifica-
tion. Dept. Statist., Stanford Univ., Stanford, CA. [Online]. Available:
http://www-stat.stanford.edu/reports/friedman/poly.ps.Z
[10] T.-T. Friess, N. Cristianini, and C. Campbell, “The kernel adatron al-
gorithm: A fast and simple learning procedure for support vector ma-
chines,” presented at the Proc. 15th Int. Conf. Machine Learning, 1998.
[11] Y. Guermeur, “Combining Discriminant Models with New Multiclass
SVMS,” LORIA Campus Scientifique, Neuro COLT Tech. Rep.
NC-TR-00-086, 2000.
[12] C.-W. Hsu and C.-J. Lin, “A simple decomposition method for support
vector machines,” Machine Learning, vol. 46, pp. 291–314, 2002.
[13] T. Joachims, “Making large-scale SVM learning practical,” in Advances
in Kernel Methods—Support Vector Learning, B. Schölkopf, C. J. C.
Burges, and A. J. Smola, Eds. Cambridge, MA: MIT Press, 1998.
[14] J. Kindermann, E. Leopold, and G. Paass, “Multi-Class Classification
with Error Correcting Codes,” in Treffen der GI-Fachgruppe 1.1.3,
Maschinelles Lernen, E. Leopold and M. Kirsten, Eds., 2000, GMD
Rep. 114. .
[15] S. Knerr, L. Personnaz, and G. Dreyfus, “Single-layer learning revis-
ited: A stepwise procedure for building and training a neural network,”
in Neurocomputing: Algorithms, Architectures and Applications, J. Fo-
gelman, Ed. New York: Springer-Verlag, 1990.
[16] U. Kreßel, “Pairwise classification and support vector machines,” in Ad-
vances in Kernel Methods—Support Vector Learning, B. Schölkopf, C.
J. C. Burges, and A. J. Smola, Eds. Cambridge, MA: MIT Press, 1999,
pp. 255–268.
[17] C.-J. Lin, “A formal analysis of stopping criteria of decomposition
methods for support vector machines,” IEEE Trans. Neural Networks,
2002, to be published.
[18] O. L. Mangasarian and D. R. Musicant, “Successive overrelaxation for
support vector machines,” IEEE Trans. Neural Networks, vol. 10, pp.
1032–1037, 1999.
[19] E. Mayoraz and E. Alpaydin, “Support vector machines for multi-class
classification,” in IWANN, vol. 2, 1999, pp. 833–842.
[20] D. Michie, D. J. Spiegelhalter, and C. C. Taylor. (1994) Machine
Learning, Neural and Statistical Classification [Online]. Available:
ftp.ncc.up.pt/pub/statlog/
[21] E. Osuna, R. Freund, and F. Girosi, “Training support vector machines:
An application to face detection,” in Proc. CVPR’97, 1997.
[22] J. C. Platt, “Fast training of support vector machines using sequential
minimal optimization,” in Advances in Kernel Methods—Support
Vector Learning, B. Schölkopf, C. J. C. Burges, and A. J. Smola,
Eds. Cambridge, MA: MIT Press, 1998.
[23] J. C. Platt, N. Cristianini, and J. Shawe-Taylor, “Large margin DAG’s
for multiclass classification,” in Advances in Neural Information
Processing Systems. Cambridge, MA: MIT Press, 2000, vol. 12, pp.
547–553.
[24] C. Saunders, M. O. Stitson, J. Weston, L. Bottou, B. Schölkopf, and
A. Smola, “Support Vector Machine Reference Manual,” Univ. London,
London, U.K., Tech. Rep. CSD-TR-98-03, 1998.
[25] V. Vapnik, Statistical Learning Theory. New York: Wiley, 1998.
[26] J. Weston, private communication, 2001.
[27] J. Weston and C. Watkins, “Multi-class support vector machines,” pre-
sented at the Proc. ESANN99, M. Verleysen, Ed., Brussels, Belgium,
1999.
[28] G. Zoutendijk, Methods of Feasible Directions. Amsterdam, The
Netherlands: Elsevier, 1960.
Chih-Wei Hsu received the B.S. and M.S. degrees in
computer science and information engineering from
National Taiwan University, Taipei, Taiwan, R.O.C.,
in 1999 and 2001, respectively.
His research interests include machine learning
and data mining applications.
Chih-Jen Lin (S’91–M’98) received the B.S. degree
in mathematics from National Taiwan University,
Taipei, Taiwan, R.O.C., in 1993. He received the
M.S. and Ph.D. degrees from the Department of
Industrial and Operations Engineering, University
of Michigan, Ann Arbor.
Since September 1998, he has been an Assistant
Professor in the Department of Computer Science
and Information Engineering at National Taiwan
University. His research interests include machine
learning, numerical optimization, and various
applications of operations research.

