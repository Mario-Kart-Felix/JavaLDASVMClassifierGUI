22 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
Static Security Optimization for Real-Time Systems
Man Lin, Member, IEEE, Li Xu, Member, IEEE, Laurence T. Yang, Member, IEEE, Xiao Qin, Member, IEEE,
Nenggan Zheng, Zhaohui Wu, Senior Member, IEEE, and Meikang Qiu, Senior Member, IEEE
Abstract—An increasing number of real-time applications like
railway signaling control systems and medical electronics systems
require high quality of security to assure confidentiality and
integrity of information. Therefore, it is desirable and essential to
fulfill security requirements in security-critical real-time systems.
This paper addresses the issue of optimizing quality of security
in real-time systems. To meet the needs of a wide variety of secu-
rity requirements imposed by real-time systems, a group-based
security service model is used in which the security services are
partitioned into several groups depending on security types. While
services within the same security group provide the identical
type of security service, the services in the group can achieve
different quality of security. Security services from a number
of groups can be combined to deliver better quality of security.
In this study, we seamlessly integrate the group-based security
model with a traditional real-time scheduling algorithm, namely
earliest deadline first (EDF). Moreover, we design and develop a
security-aware EDF schedulability test. Given a set of real-time
tasks with chosen security services, our scheduling scheme aims
at optimizing the combined security value of the selected services
while guaranteeing the schedulability of the real-time tasks. We
study two approaches to solve the security-aware optimization
problem. Experimental results show that the combined security
values are substantially higher than those achieved by alternatives
for real-time tasks without violating real-time constraints.
Index Terms—Embedded real-time systems, optimization, secu-
rity.
I. INTRODUCTION
R ECENTLY there have been some efforts devoted to thedevelopment of real-time applications with security re-
quirements. Security requirements in many real-time applica-
tions (see, for example, [25] and [27]) must be met in addition
Manuscript received April 30, 2008; revised September 02, 2008, De-
cember 06, 2008, and January 14, 2009. Current version published March
06, 2009. The work of M. Lin and L. T. Yang was supported by National
Sciences and Engineering Research Council, Canada (NSERC) and the work
of Z. Wu and N. Zheng was supported by NSFC for Distinguished Young
Scholars (No. 60525202) PCSIRT Program (IRT0652). The work of X. Qin
was supported in part by the U.S. National Science Foundation under Grants
CCF-0742187, CNS-0757778, CNS-0831502, OCI-0753305, DUE-0621307,
and DUE-0830831 and in part by Auburn University under a startup grant. A
shorter version [14] of this paper, “Schedulability Driven Security Optimization
in Real-Time Systems” was published in the proceedings of ARES 2006. Paper
no. TII-08-04-0054.R2.
M. Lin, L. Xu, and L. T. Yang are with Department of Mathematics, Statis-
tics, and Computer Science, St. Francis Xavier University, Antigonish, NS B2G
2W5, Canada.
X. Qin is with Department of Computer Science and Software Engineering,
Samuel Ginn College of Engineering, Auburn University, Auburn, AL 36849-
5347 USA.
N. Zheng and Z. Wu are with the College of Computer Science, Zhejiang
University, Hangzhou 310027, China.
M. Qiu is with Department of Electrical and Computer Engineering, Univer-
sity of New Orleans, New Orleans, LA 70148 USA.
Digital Object Identifier 10.1109/TII.2009.2014055
to satisfying timing constraints of the real-time applications. Ex-
amples of security sensitive real-time applications include on-
line transaction processing systems [18], medical electronics
[30], radar for tracking missiles [17], and aircraft control [9].
Sensitive data and processing in a variety of real-time systems
must be protected against unauthorized accesses. For example,
a radar tracking and processing system needs to read the images
from the tracking subsystem periodically and send the tracking
commands and directions to the tracking subsystem. In a railway
signaling system, a train needs to communicate with the con-
trol center about its position, speed and the control center sends
commands to the train of which track to follow and sets the
train’s speed if necessary. Such real-time applications require
high quality of security to guarantee the messages between the
subsystems not being read or altered by malicious users, and to
guarantee the user really be whom he or she claims to be.
A. Security Requirements and Services in Real-Time Systems
To address these security requirements, security services like
message encryption and decryption, secure connection estab-
lishment, etc., can be used.
According to Kaufman et al. [13], security services com-
monly serve confidentiality, authentication and integrity.
• Confidentiality protection service is against unauthorized
disclosure of information. Loss of confidentiality means
disclosure of asset to unauthorized recipients.
• Authentication service is the process of reliably deter-
mining the identity of a communicating party. Loss of
authentication means that the one claiming to be the sender
of the message is not the true sender.
• Integrity protection service is against the unauthorized
modification of data. Loss of integrity means damage to
the asset through unauthorized modification.
The security risks that we need to consider for the railroad
signaling system include the following.
• The information of the train status (speed and position) sent
from the trains to the control center must not be altered by
malicious users. Otherwise, the control center might make
a wrong decision based on the wrong messages received.
• The information of the commands from the control center
to the trains should not be altered either. Disaster can
happen if a wrong command is received and followed by
the trains.
• The trains and the control center must authenticate the mes-
sages that they receive to make sure the messages were re-
ally sent by whom claims to send them.
• The messages should not be able to be read by a third party
to protect the message from being altered or to avoid ter-
rorists changing the track to cause disaster.
1551-3203/$25.00 © 2009 IEEE
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 23
Thus, the three types security services: confidentiality, au-
thentication and integrity are therefore needed in the railway
signalling system to protect the trains from following the wrong
track and resulting in accidents. An increasing number of real-
time applications like the railway signaling control system re-
quire high quality of security to assure confidentiality and in-
tegrity of information. Therefore, it is desirable and essential
to fulfill security requirements in security-critical real-time sys-
tems.
A security service for a particular security requirement can
be achieved by various security mechanisms. For example, dif-
ferent cryptographic algorithms can be used to guarantee the
confidentiality. The notion of security variant was first brought
forward by Irvine et al. [11]. The idea is that the degree of secu-
rity is different for different security variants. Examples of [11]
are as follows.
• Different cryptographic algorithms, e.g., RSA, RC4, RC5
or DES lead to security variants. The strength of each
variant can be measured in terms of the work factor asso-
ciated with a brute force attack or other metrics [35].
• Different length of cryptographic keys lead to security vari-
ants. The longer the key, the more robust the variant.
• Different authentication mechanisms lead to different vari-
ants. Example variants are weak password, strong pass-
word, biometric, and smart cards with onboard display and
input interfaces.
A system may provide many security services which can be
partitioned into groups. For example, a group of services can
be targeting at authentication specifically and another group of
services can be targeting at data integrity, etc.
To meet the needs of a wide variety of security requirements
imposed by real-time systems, the group-based security model
is used in this paper. The services in the same group provide
the same type of service but of different quality due to the dif-
ferent mechanism used. The group-based security model is also
used by Xie et al. [31] for developing an allocation scheme for
parallel applications with deadline and security constraints on
clusters. The services in the same group can be considered as
security variants [11]. Security services from different groups
can be combined to achieve better quality.
Applying security services to a system incurs overhead to
the system including more CPU and memory usage. Therefore,
each security service in a group can be modeled with a quality
value and parameters to compute its overhead.
B. Schedulability
There are many challenges for real-time system security, such
as challenges related to efficient implementations, software en-
gineering and programming models, and schedulability. In this
paper, we focus on the schedulability.
Real-time systems require not only logical correctness, but
also timing correctness. A vehicle with the ability to brake is
not enough, it must also be able to brake in time. The timing
constraints of a real-time system are often specified as dead-
lines. It is desirable (required in many cases) for the system
to respond within the specified deadline. If such a condition
is violated, then it might cause economic losses or even phys-
ical damage. Therefore, predictability is a major concern in a
real-time system [10], [28]. Static schedulability analysis can
be used to predict whether the timing constraints of a real-time
system can be met [4], [15]. One of the most commonly used
schedulability tests for real-time systems is schedulability test
for earliest deadline first (EDF) scheduling [15]. The test is to
check whether the utilization or density of the task set in the un-
derlying real-time system is less than 1.
To enhance security over real-time systems, the security ser-
vice overhead needs to be taken into account to guarantee the
schedulability of the system since applying security services in-
curs extra CPU computation. In this paper, the EDF schedula-
bility test is adapted to security aware real-time systems.
C. Security Optimization With Schedulability Constraints
In the group-based security model, services from different
groups can be combined to achieve better security. The problem
of finding the best combination of services is a combinatorial
optimization problem [19]. A naive method would be to exhaus-
tively check all the possible service combinations. This method
is obviously too expensive. Two approaches are proposed to
select the best combination of security services for real-time
systems while guaranteeing their schedulability. One is integer
linear programming technique and the other is a search tech-
nique. The search technique is efficient since heuristics are de-
veloped to prune the branches and back jumping is used to re-
duce the search space.
The rest of the paper is organized as follows. Section II
presents related works. Section III describes system model
including task model and security model. Section IV presents
the security aware schedulability test. Section V describes
the security optimization problem and the two approaches to
solve the problem. Section VI shows experiments. Section VII
describes the conclusions and future works.
II. RELATED WORKS
Schedulability is the most important requirement in real-time
systems. Recently, different factors are brought into real-time
scheduling to guarantee the quality and efficiency of systems.
Examples are energy aware scheduling [3], [5], [22] and fault-
tolerance aware scheduling [36]. Techniques have been devel-
oped to optimize energy saving or reliability of real-time sys-
tems while at the same time guaranteeing the schedulability of
the systems.
Quality-of-service (QoS) has received widespread attention
during the last decade, especially in networking and multimedia
systems. Intuitively, a system can achieve better quality if more
resources are available. For example, a real-time multimedia ap-
plication can obtain higher video quality when a higher frame
frequency is used. Imprecise computation [16] is a technique
for real-time systems where precise outputs are traded off for
timely responses to system events and thus a graceful degra-
dation is achieved. The QoS-based Resource Allocation Model
(Q-RAM) developed at Carnegie Mellon University allows mul-
tiple QoS requirements such as timeliness, cryptography and re-
liable data delivery to be addressed and traded off against each
other [23]. QoS resource tradeoff technique has been incorpo-
rated into a resource management system for an aircraft flight
control application for QoS negotiation [2]. The QoS resource
24 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
tradeoff technique has also been used in energy efficient com-
puting systems to maximize the system value while satisfying
time and energy constraints [24]. Although cryptographic length
is listed as a QoS dimension example in [23], security optimiza-
tion in real-time systems has not been well studied.
Security of a system ensures confidentiality of information,
authenticity of entity and integrity of message and data. Earlier
works that considered security requirement in real-time systems
addressed the quality of security in such systems. Irvine and
Levin [12] introduced the notion of security variant. Similar to
the security variant model, the group-based security model that
we adopt also assumes that a system can have different services
of different quality. The difference is that in the group-based
security model, the services are partitioned into groups and the
effect of combining different types of services to enhance the
security of a real-time system is addressed. This group-based
security model was also used in [31], [32] as level-based security
model when addressing a real-time task allocation scheme on
clusters.
One challenge of addressing security requirement in variant-
based or group (or level)-based security aware system is how to
define the quality value for security services and how to com-
pute the overhead of applying the security services. The solu-
tion relies on the security specialists to define the quality value
and cost for some certain security service. Irvine and Levin [12]
proposed a security taxonomy and overhead framework. Xie et
al. [31] have also studied and performed experiments to derive
security quality and security overhead for certain security mech-
anism of three types security services: confidentiality, authenti-
cation techniques and data integrity.
In the group-based security model, yet another challenge
is how the weight of different groups should be assigned.
The weight assignment to the groups of services can be done
through security risk analysis methodologies [7] which include
asset identification, vulnerability analysis, likelihood analysis
and countermeasure evaluation.
There have also been other works addressing the security
issue [25], [26] in real-time systems. Xie et al. [34] have pre-
sented challenges and open issues in security-aware real-time
scheduling for distributed systems. The focus of [34] is to design
a dynamic scheduling algorithm to schedule real-time tasks to
achieve high security of the system while maintaining low miss
rate of the tasks.
However, the problem of predictability in a real-time system
with security requirement was not addressed in these works.
Our work addresses static schedulability driven security opti-
mization. To the best of our knowledge, this is the first work on
static security aware schedulability analysis and static security
optimization in real-time systems.
III. SYSTEM MODEL
A. Task Model
We consider a task set with independent, preemptable
periodic tasks to be scheduled on a single processor. A periodic
task is identified by the four tuple where
• is the (worst case) execution time of the task;
• is the period of the task;
• is the relative deadline of the task;
• is the number of data items in the message that need
security service.
Note that is a common model for representing
a real-time task [15]. The worst execution time can be derived
using high level program analysis [20], [21] and low level pro-
gram analysis that considers platform features [8]. What we add
here is the communication factor of a task that need security ser-
vices.
B. Security Model
Real-time systems are developed to execute a wide range of
unverified user-implemented applications. Therefore, real-time
applications as well as systems are very likely to be targets of
security threats. Even worse, legitimate users might by accident
tamper with shared data or excessively consume real-time com-
puting resources to disrupt real-time services available to other
applications. Many existing real-time computing environments
do not incorporate security mechanisms to counter various se-
curity threats. Consequently, it becomes critical and important
to employ security services to protect security-critical real-time
systems. The basic idea of our security model is that real-time
system users can flexibly select security services to form an in-
tegrated security protection against a wide spectrum of threats
in real-time systems.
Next, we present a general model to specify the security ser-
vices of the systems.
1) Security Services: A system may provide many security
services which can be partitioned into groups where the services
in the same group provide the same type of service but of dif-
ferent quality due to the different mechanism used. For example,
a group of services can be targeting authentication specifically
and another group of services can be targeting for protecting
data integrity etc. We can use RC4, RC5, or DES for message
encryption. Their quality is different. Security services from dif-
ferent groups can be combined to achieve better quality.
Assume there are groups of security services. Each group
contains different security services that provide the same type
of security, but has different quality. is used to indicate the
number of services in group and indicates the th ser-
vice in the th group. Each security service has a quality value.
It is assumed that the highest quality of the services in each
group is normalized to 1 and the other services have quality
value between 0 and 1. The quality value of each service can
be thought of as a value compared to the group’s best security
service. The services are ordered in a decreasing order of their
quality. Each service incurs computation overhead to the sys-
tems. In this paper, two main factors that introduce overhead
to the system are considered. The first one is the overhead to
establish (initialize) the service and the second one is the unit
overhead to apply the security service to the messages. A three
tuple is used to represent a security service :
where
• indicates the quality value for service ;
• indicates the overhead for initialization of the service
;
• indicates the unit overhead for applying the service
to one data item.
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 25
Fig. 1. Combining security services.
2) Security Overhead: To reduce management overhead, all
tasks in a system use the same set of security services. The CPU
overhead of applying service to a real-time system with a
task set can be computed as follows:
where is the message (the number of data items) in task
that the security service performs on.
3) Combining Security Services: Multiple security mech-
anisms may be used to form an integrated security solution,
which in turn can fulfill high security requirements. For in-
stance, message encryption can be used in combination with
message integrity (see, for example, [17]). A set of security
services can perform as building blocks for real-time applica-
tion developers to implement integrated security mechanisms
for real-time systems.
The challenging issue is to compute the quality of the multiple
security services that fall into different types of security service
groups. The security value of multiple security services depends
on the weight of each group. Weights to each group (type of
service) are assigned with the sum of the weights for all the
groups as 1. By simply computing the weighted sum of quality
values of the selected services, we can derive the quality value
for the combined services. Let us use to denote the weight
of the th group.
Fig. 1 shows three groups of services. The quality of each ser-
vice is represented inside the corresponding node. The weight
of each group is shown in the vector on the right hand side. If
services and are selected, then the combined se-
curity value can be computed as follows:
The intention of security service combination is to provide
separate basic security services which offer users an array of
fundamental security services. The user can then select mul-
tiple security services to form an integrated security protection
to meet their needs. It is the users’ responsibility to make a
meaningful combination of basic security services. This is done
through a thorough study on the relationship and interaction be-
tween a security mechanism and the system and between dif-
ferent security mechanisms themselves. One should note that
not all the security mechanisms can be simply combined. For ex-
ample, if a shared key encryption (one security mechanism im-
plementation) is chosen for achieving both confidentiality and
authentication, then we need to put confidentiality and authen-
tication in the same group. In general, if the implementation of
the two types of service mechanisms is not independent, then
we cannot separate the services into two groups.
There exist some other cases where a service combination
does not make sense. For example, a system that is vulnerable
to unauthorized access does not benefit from any integrity or
confidentiality services. Our model can still accommodate these
cases by properly assigning the weights of the groups. In the
above example, the weight of authorization service should be set
to 1, whereas the weights of integrity and confidentiality services
are 0. In essence, the system is reduced to a single-group and the
problem becomes picking the best security service in this group
which also guarantees schedulability. Yet one is still encouraged
to further analyze the system to identify some fundamental
smaller security service building blocks that can be combined to
achieve the security requirement of this single group.
C. Security Requirements
There are two types of security requirements.
• First of all, we can specify the minimal security value
for each type (or group) of service. Let denote
the minimal security required for the th service group. It
means that the quality value of the selected service in group
must not be less than . The minimal group secu-
rities can be represented as a vector
• Second, we can specify the minimal combined security
value. Remember that the combined security value is the
weighted sum of the quality value of the individual ser-
vices. We use MinCQ to denote this required minimal com-
bined security value.
IV. SECURITY AWARE EDF SCHEDULABILITY TEST
An EDF [29] scheduler schedules tasks based on their dead-
line. EDF scheduling policy is the optimal scheduling policy
for independent preemptable tasks scheduling on single pro-
cessor meaning that if a set of independent preemptable tasks
are schedulable onto a single processor by any scheduler, then
they are schedulable by an EDF scheduler. A good property of
EDF scheduling is that we can decide the schedulability of a set
of tasks statically.
Next, the EDF schedulability analysis is described. Let us
define the density of a task as where
and are the execution time, deadline and the period for
task . To verify whether a set of tasks are schedulable under
EDF scheduling policy, we can use a very simple and robust
schedulability test by checking
This test follows directly from the following theorem [15].
Theorem: system of independent, preemptable tasks can be
feasibly scheduled on one processor if the density of the system
is equal to or less than 1.
26 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
We use to represent the
original density of the system. Now we show how to compute
the new density of the system when considering security service
overhead.
Recall that the CPU overhead of applying service to a
real-time system with a task set can be computed as follows
(see Section III-B2):
We define as the extra density of applying service to
the system. We have
Let
and
can be computed as
We define as the total extra density of applying all the
services in this combination.
The security aware schedulability test then becomes
V. SECURITY OPTIMIZATION FOR EDF-BASED
REAL-TIME SYSTEMS
The process to perform security optimization in a real-time
system includes the following steps.
1) Identify the groups of security requirements and determine
the weight for each group. The process starts with secu-
rity requirement analysis to identify the type of require-
ment needed. To do this, we need to analyze the tasks and
the data involved in the application, perform risk analysis
and decide what kind of security services are needed and
determine the weight of each type (group) of requirement
services.
2) Identify the number of data items in each task that need
security services from each group.
3) Identify security variants for each security service group.
For each security service in the groups, we need to identify
the security variants with its security value, the two over-
head parameters: initialization time, and time for servicing
a unit data.
4) Formulate the optimization problem. The formulation
needs to consider the constraints of minimal security value
of each group and minimal security value of the combined
security problem.
5) Solve the problem.
A. Problem Formulation
To achieve high quality of a real-time system, we can combine
services from two or more groups. The services in the same
group provide the same type of service. Therefore, only one
service can be selected from one group. It is possible that we do
not need all types of services for a system. To allow zero service
be selected from a certain group, one just needs to add an idle
service to this group. The idle service’s and values are
set to 0. Not selecting any service from a group means selecting
an idle service from the group.
A combination of services is represented as a vector
where is the group number and is the
service selected from group . The quality value and overhead
parameters for are . Our goal is to maximize the
weighted sum of quality values , subject
to the following constraints.
1) Only one service is selected from each group.
2) Minimal group-security quality constraint: the security
value of the selected service in each group has to be bigger
than or equal to the minimal required security value for
that group. That is,
for any
3) Minimal combined-security quality constraint: the com-
bined security has to be not less than the minimal required
combined security. That is,
where
4) Schedulability constraint: the overhead will not make
the system utilization larger than 1. Recall that
is the original den-
sity of the system. Also , the extra density of applying
service to the system is
, the total extra density of applying all the services in
this combination can be computed as
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 27
where
The schedulability test requires that: .
B. Using the Integer Linear Programming Technique
The first method to solve the problem is the integer linear
programming (ILP) technique. What needs to be done is to for-
mulate the problem as an ILP problem.
First, the variables of the system under consideration need to
be defined. Then the goal and the constraints over the defined
variables are described.
For each service of a group, a variable is defined where
represents the group number and represents
the service number . being either 1 or 0
indicates that the th service of the th group is selected or not
selected to apply to the system.
Our aim is to find an assignment for each to maximize the
combined security of the system subject to the minimal security
requirement constraint and the schedulability constraint.
The goal function can be expressed as
There are four types of constraints.
1) First, only one service is selected from each group. There-
fore, for each group , we have one constraint
2) Minimal group-security quality constraint: the quality of
the selected service from any group has to be not less than
the minimal required quality value for that group. There-
fore, for each group where , we have one
constraint
3) Minimal combined-security quality constraint: the com-
bined quality of the selected service cannot be less than
the minimal required value. That is,
TABLE I
SECURITY SERVICE GROUPS
TABLE II
TASK SET
4) Schedulability constraint: the system should still be able to
pass the EDF schedulability test with the overhead incurred
with the selected services
where
1) Simple Example: In this simple example, there are two
groups of security services and three real-time tasks, tabulated
in Tables I and II, respectively.
Now we can formulate our problem.
1) The goal function we try to maximize is
(1)
In this example, it is
(2)
2) The problem constraints are as follows.
• Only one service is selected from each group:
(3)
• Minimal group-security quality constraint:
(4)
28 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
In this example, it will be
(5)
and
(6)
• Minimal combined-security quality constraint:
(7)
In this example, it is
(8)
• Schedulability constraint:
(9)
where
(10)
In this example, it is
(11)
where
(12)
(13)
(14)
3) are integers.
After we formulate the whole problem, we can write all of
them into a x.lp file and solve it using lp solve function [1].
The running results are
• Value of objective function: 0.95.
• Actual values of the variables:
1)
2)
3)
4)
5)
6) .
C. Using a Search Technique
The second method is a search-based method. First the
problem is formulated as a search problem in a graph and then a
search technique is used to solve the problem. The algorithm is
efficient since some heuristics are applied to reduce the search
space.
First a graph which contains layers is constructed. Each
layer contains several nodes. A node is a pair where in-
dicates the group number and indicates the service number.
Node resides at the th position of the th layer.
A path in the graph is a sequence
of nodes chosen from each layer in order, where is the length
of the path. A path can be complete or incomplete. A complete
path contains one node from each layer while an incomplete
path contains fewer nodes than .
A path passes a node iff .
The quality value of a path , denoted by ,
is defined as
where is the quality value of the th service in the th group.
We define as the extra density incurred by the services
selected in the path. Both and can be computed
incrementally meaning that if we add a new node into a path ,
we can add the new quality value and the of the node to derive
the new and . A path is infeasible if and only
if violates one of the four types of constraints. Otherwise,
is said to be feasible.
A complete path corresponds to a
service combination in the original
problem. The aim for the search problem is to find a feasible
complete path with maximal combined quality value.
To solve the problem, depth-first search [6] with backtracking
is used. Three kinds of heuristics are developed to guide the
search procedure and cut branches. The three types of pruning
factors are the following.
1) The first type of pruning eliminates the nodes in each layer
whose quality value is smaller than the minimal required
group-security. This is called group quality pruning. This
type of pruning greatly reduces the search space. Fig. 2
shows the quality value of each service of the four groups
and the required minimal group security value in the
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 29
MinGQ vector. Obviously, service and
can be eliminated before the search starts.
2) Some branches can be pruned because the incomplete path
tested already fails the schedulability test. The search is
realized by expanding nodes and backtracking. It wastes
time in continuing expansion when a path is found to be
infeasible. This is because any path with an infeasible path
as prefix is still an infeasible path. Therefore, the paths
expanded from an infeasible path can be pruned. We call
this schedulability pruning.
Let us consider an example with four groups (Fig. 3)
where group 1 has two services and the other two
groups have three services. Suppose the current path is
[see Fig. 3(b)] and vi-
olates the schedulability test. Therefore, path is not a
feasible path. We should not extend this path any further.
That is, the paths shown in Fig. 3(d)–(f) will be pruned.
The immediately subsequent path considered during
search is shown in Fig. 3(c).
3) The impossibility to exceed the current combined quality
bound: some branches can be pruned since the path’s com-
bined quality cannot exceed that of the feasible path found
before. We called such pruning quality bound pruning.
When a complete feasible path is found, the search proce-
dure cannot stop since the path found does not necessarily
have the largest combined quality value. However not all
its subsequent paths are of interest since some of them ob-
viously have a smaller combined quality than that of the
current path. It is easy to prove (remember that the services
of each group are ordered by decreasing quality) that path
has a smaller combined quality value
than if
has the following property w.r.t. : at any level, the
node selected for is on the right-hand side of that se-
lected for . Look-ahead and back-jumping mechanisms
can be used to prune subsequent paths with such a prop-
erty. With back jumping, the search may jump a few levels
up. The level to jump to is derived based on the following
two observations.
• Rule 1) an increment at the final level of a path will not
lead to a larger combined quality than the original path,
for the reason that the security quality values of services
in a group are in the decreasing order. Therefore, the
level is at most . For example, if the search reaches
the state in Fig. 4(a), then the next search step will jump
back to Fig. 4(a ) without entering into calculating the
path passing the third node at level 4.
• Rule 2) if the node of a path at every level from to
is in the leftmost position, then increasing at any
level between and will not produce a larger
combined quality value than the original path . There-
fore, the backtracking level can be set to . For the
path illustrated in Fig. 4(b), the nodes from level 3 to
level 4 are in the leftmost positions. Here . Intu-
itively, the search can jump back to the third node at level
Fig. 2. Group quality pruning.
Fig. 3. Schedulability pruning.
Fig. 4. Quality bound pruning.
2 and starts from there. This path can also be pruned
because its security value is definitely less than that of
Fig. 4(b ). Therefore, the next search actually reaches
the path shown in Fig. 4(b) with the
. Fig. 4(c) is another example applicable using
rule 2. Here . Using rule 2, the search can start
from a node in level . Note that there is no
subsequent path for the path shown in Fig. 4(c ) meaning
that the search can terminate.
Let be the complete path found that has the maximal com-
bined quality CQ. If , then it is not possible to
find a feasible combination of services satisfying both the secu-
rity requirement and schedulability requirement.
30 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
Given : the number of tasks; : the number of service
groups; : the number of services in group ; a
set of tasks: ; the services:
; and the se-
curity constraints: for each group , and MinCQ, the
pruning search Algorithm 1 returns the optimal feasible service
combination with the maximal security combined value.
Pruning Search for Security Optimization
1) if the path found by Minimum policy is not schedulable
then
2) return
3) end if
4) *Group Quality Pruning*
5) delete services not satisfying from each group;
6) *Initialize the flags and variables*
7) ;
8) ;
9)
10)
11) for to to do
12) compute
13) end for
14)
15)
16) while hasMorePath && !foundMaxCQ do
17) while do
18) and
;
19) if then
20) ;
21) ;
22) else
23) *Schedulability Pruning*
24) if then
25) break;
26) else
27) ;
28) ;
29) end if
30) end if
31) end while
32) if then
33) calculate CQ of the current complete path;
34) if then
35) replace OptimalPath with the current path;
;
36) end if
37) *Search a new path with Quality Bound Pruning*
38) ;
39) while do
40) ;
41) end while
42) if then
43) ;
44) ;
Fig. 5. Pruning search versus nonpruning search.
45) else
46) ;
47) end if
48) end if
49) end while
50) if then
51) return OptimalPath;
52) else
53) return ;
54) end if
To show the effectiveness of the proposed heuristics, we com-
pared the time cost of the pruning search algorithm with that of
the simple search algorithm without any pruning heuristic (non-
pruning search). The hardware platform is a dual Intel E4600
2.40 GHz processors with 3 GB of memory. The operating
system is Linux Redhat with kernel 2.6.18–92.1.10.el5xen. We
randomly generated 684 test cases where the number of group
is within the range [4, 10], the number of security services
(NS) in each group is within the range [5,12] and the number
of tasks is within [3,15] which we believe are the reasonable
ranges for the parameters. In the 684 test cases, 483 cases are
feasible. The time costs for both algorithms of 355 test cases
out of the 483 cases are less than 1 second and the comparison
of time cost of the rest of 128 test case is shown in Fig. 5. Note
that when the time cost is less than 1 s, it is shown as 0 s in
the figure. The results show that the pruning search has great
advantages over simple search as the time cost of the pruning
search is much less than that of simple search, and the time cost
of pruning search increases slower than the simple search does
when the parameters (i.e., , NS, ) increase.
We also compare the lp solve and the pruning search algo-
rithm using the same set of test cases. Among the 483 feasible
cases, there are 459 cases where the time costs of lp solve and
pruning search are both less than 1 s. This suggests that both
algorithms are efficient. The performance of lp solve and the
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 31
Fig. 6. Comparison of lp solve and pruning search.
pruning search for the rest 24 test cases (all with ) is
compared in Fig. 6. lp solve is faster for these cases. But the
time cost of the pruning search is also reasonably short (from a
few seconds to 14 s).
D. Special Case: Service Selection From a Single Group
When there is only one group of security services in the
system, the index for the group number is always 1. Remember
that our goal is to select the best security service and guarantee
the schedulability of the system. If the th service is the optimal
service, it must satisfy the security aware EDF schedulability
test which includes the service overhead.
First, the maximal allowed density overhead is computed as
. Then the density overhead for all the services in the
group is calculated and stored in a vector. A binary search on the
vector is used to find the service that has the maximal density
overhead which does not exceed . We then check if the
quality value constraints are met for the service found. If yes,
then the optimal security service is found. Otherwise, the system
is not feasible.
VI. EXPERIMENTS
Using the ILP or the heuristic search technique, a security-
aware EDF schedule problem can be solved efficiently to ob-
tain an optimal service combination. This section shows that our
method can improve the security value of a system while guar-
anteeing schedulability comparing with other methods.
Extensive test suites were performed to compare two metrics:
the combined security value and the schedulability value (also
called the overall density value which is equal to the original
task density plus the overhead density), using the following four
policies (Minimum, Maximum, Random, and Optimal). If there
is no feasible schedule, the policy outputs 0 as the combined
security value.
• Minimum policy: the service with the lowest security level
in each group is picked for its corresponding lowest com-
putation overhead.
• Maximum policy: the service with the highest security
quality in each group is selected.
• Random policy: for each group, the security service is
picked randomly.
• Optimal policy: the services achieves the optimal security
value while meeting all the constraints are picked.
A. Random Test Suites for the Comparison
There are five random test suites in total. For each test suite,
we evaluate the combined security value and schedulability
value for different policies. In each test suite, a variable is se-
lected and scaled to observe the properties of the four policies.
To limit the exploration states, we predetermine one or two
variables, such as the number of tasks or the maximum number
of security services in each group. Without loss of generality, all
the other variables in our model are generated randomly. These
five suites with randomly generated test data for representing
the general situations are as follows.
• Test suite 1: The maximum number of services is fixed, so
as the number of tasks. We set the number of services to 5
and the number of tasks to 10. Let the number of groups
grow from 4 to 14 and the increment is 1. All the other
data: security quality, initialization overhead, unit data pro-
cessing overhead, weighted factors, minimal combined se-
curity value, task execution time, task period, task dead-
line, and the number of data items, are randomly generated.
The combined security values and schedulability values of
the four policies are illustrated in Fig. 7. When the number
of security groups is 8, 10, or 13, the Maximum policy
fails to fulfill the schedulability of the task set. It reveals
that the security quality greedy approach (i.e., the Max-
imum policy) has its weakness in scalability. The Min-
imum policy can produce a feasible schedule, but the com-
bined security value is much lower than that achieved by
our optimal method. The average difference of the normal-
ized combined security is 0.7003.
• Test suite 2: The number of security service groups and
the number of real-time tasks are predetermined as 10. Let
the maximal number of services in each group increase
from 4 to 16 and the increment is 2. Fig. 8 shows the
combined security and schedulability values. Our Optimal
policy achieves the maximum combined security value
while satisfying the schedulability constraints. More im-
provement in combined security value of Optimal policy
vs. the minimum policy is shown in Fig. 8 than the curves
in Fig. 7. The fact that more security services exist in a
group allows more combination choices of the security
services. The optimal policy utilizes this to provide more
flexible security service combinations for the tasks and
thus achieves higher improvement in the combined secu-
rity values. It is shown that the combined security values
of the Optimal policy are close to those of Maximum
policy. Note that the schedules of Maximum policy are not
32 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
Fig. 7. Combined security and schedulability value for test suite 1: the number of groups as the variable.
Fig. 8. Combined security and schedulability value for test suite 2: changing the number of security services in a group.
feasible for all seven cases, making its highest combined
security values useless.
Furthermore, another three test suites with random test data
are conducted to observe the advantage of our Optimal policy
over the others in different scheduling overhead situations. Sim-
ilar results can be concluded as test suite 1 and 2.
• Test suite 3: For ten groups and at most five services in each
group, the number of tasks increases from 4 to 12. Fig. 9
illustrates the combined security and schedulability values
for this test suite.
• Test suite 4: The number of groups, the number of services
and the number of tasks are all fixed. The number of groups
is 10. And the number of services in each group is 5 and
the number of tasks is 10. The unit overhead increases
from 0.1 to 0.8, and the increment is 0.1. Fig. 10 shows the
combined security and schedulability values.
• Test suite 5: In this test case, The number of groups, the
number of services and the number of tasks are all fixed.
We set the number of groups to 10, the number of services
in each group to 5 and the number of tasks to 10. Let the
initialization overhead increase from 0.1 to 0.6, and the
increment is 0.1. The results are shown in Fig. 11.
With the increase in the number of tasks (test suite 3), unit
overhead (test suite 4) and initialization overhead (test suite 5),
the feasible security service combination space is smaller. The
Optimal policy ensures the schedulability of the real-time tasks
and achieves the optimal combined security values, closest to
those achieved by the Maximum policy.
Consequently, from the curves of all these five test suites,
we can conclude that the Optimal policy is able to optimize
the security services for a system without the loss of schedu-
lability. Although at some points some policies like Maximum
or Random policy can get a higher combined security values,
the schedulability of the tasks at these points are all unschedu-
lable which makes these higher security values useless.
B. Effect of Overhead Parameter and
A series of experiments were conducted to evaluate the im-
pact of the parameters and for each security service ,
where is the group index and is the service index in the group.
The parameters predetermined are generated by the programs
used in Subsection VI-A, listed in Tables III and IV. We perform
fifteen security optimization problems where the scale factor
of steps up from 1 to 15. The results are shown in Fig. 12.
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 33
Fig. 9. Combined security and schedulability value for test suite 3.
Fig. 10. Combined security and schedulability value for test suite 4.
The Maximum and Minimum policies have constant combined
security value because they have fixed combination of security
services. And the combined value of the Random policy is less
than or equal to that of the Maximum policy and larger than or
equal to that of the Minimum policy. When the scale factor of
increases, the overhead of the security services also increases.
The schedulability constraint is more stringent. The Optimal
policy achieves the highest combined security value the same
as achieved by the Maximal policy when the scale factor of
is less than 5. When the scale factor of is 5, the overall den-
sity of the Maximum policy is 1.06, meaning that the system
is not schedulable. When the scale factor of is greater than
5, the combined value achieved by the Optimal policy is lower
than that achieved by the Maximum policy. This is because the
Optimal policy chooses the services with lower overhead to tol-
erate the increase of in order to produce a feasible schedule.
When the factor is larger than 10, even the Minimum policy
cannot find a feasible combination of services (the overall den-
sity of any combinations of services is larger than 1). Obviously,
the Optimal policy cannot produce a feasible solution either as
there exists no feasible solution. This suggests that the feasible
upper bound of the scale factor of is 10 for this specific secu-
rity optimization problem when we only consider schedulability
constraint. The feasible upper bound of the scale factor of is
reduced to 7 when the constraint of minimum combined secu-
rity value (here, it is 0.74) is also taken into account. Note that
in the figure the combined security value and the schedulablity
value of Optimal policy are set to 0 when the case is not fea-
sible (not schedulable or does not fulfill the minimum security
requirement).
Similar situations are shown in Fig. 13 for initialization over-
head, . The scale factor of increases from 1 to 4 with a step
of 0.1. Constant combined security values are achieved by the
Maximum policy and Minimum policy for their fixed selection
of security services. The Optimal policy schedules the tasks
with best feasible combined security values, larger than those
achieved by the Random policy.
Based on the results shown in Figs. 12 and 13, we can con-
clude that the increase of overhead (by increasing either or
) compresses the feasible security service combination space
and thus lowers down the combined security level. The Optimal
policy considers all the constraints and schedules the tasks with
34 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
Fig. 11. Combined security and schedulability value for test suite 5.
Fig. 12. Combined security and schedulability value for U scaled and other parameters predetermined.
TABLE III
PARAMETERS PREDETERMINED FOR EVALUATING THE IMPACT OF INITIALIZATION OVERHEAD   AND THE OVERHEAD OF PROCESSING UNIT DATA, 
TABLE IV
TASK SET
highest combined security value, while the other three policies
ignore the constraints of schedulability, minimal group security
qualities and minimal combined security value.
C. Real Application
Next, we show the security optimization of a flight control
system which was utilized to fly a simulated model of an F-16
fighter aircraft [2], [32]. The tasks in the system control the
aircraft during flight. The set of task include Guidance which
sets the reference trajectory of the aircraft in term of altitude
and heading; Controller which executes the close loop control
function that deals with actuator commands; the two Navigation
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 35
Fig. 13. Combined security and schedulability value for I scaled and other parameters predetermined.
TABLE V
AIRCRAFT CONTROLLER: THE TASK SET
tasks: Fast Navigation and Slow Navigation; and Missile Con-
trol which reads radar and fires missiles. The detailed descrip-
tion of the flight control system can be found in [2] and [32].
There are several versions of the original tasks which are dis-
tinguished by the task periods. We randomly chose one version
of each task. The system has high security requirement to guar-
antee the messages between the subsystems not being read or
altered by malicious users, and to guarantee the message sender
really be the ones claiming to be. The size of the messages that
need security service is randomly generated. The parameters of
the tasks are shown in Table V.
As in [32], we focus on three groups of services: confiden-
tiality, integrity and authentication. The services in each group
are shown in Tables VI–VIII, respectively. We use the overhead
provided in [32] where the overhead of the confidential services
and integrity services is measured by served data per time unit
(kb/ms) and the overhead of the authentication services is mea-
sured by service time (ms). The assumption is that no initial-
ization overhead is involved in the encryption mechanisms and
the integrity algorithms while the authentication algorithms take
constant time. To transfer this to our overhead model, the ini-
tialization overhead is zero for all the confidential services
and integrity services and the corresponding value is the in-
verse of served data per time unit. For example
. The unit data processing overhead is zero for all
the authentication services and the corresponding I value equals
to the service time (ms). For example . The
security level is normalized by the timing performance [32]. The
security level can also be derived using some other metrics like
the likeness of the mechanism being attacked and the ability to
protect the system when a brute force method is used. We as-
sume that the weights for the three groups are 0.5, 0.3 and 0.2
TABLE VI
AIRCRAFT CONTROLLER: CONFIDENTIALITY SERVICES
TABLE VII
AIRCRAFT CONTROLLER: INTEGRITY SERVICES
TABLE VIII
AIRCRAFT CONTROLLER: AUTHENTICATION SERVICES
and the minimal group security value (MinGQ) for each group
is 0.1.
Table IX shows that the optimal solution can produce the best
solution (the combined quality value ) which is fea-
sible. Maximum policy cannot find a schedulable solution. Min-
imum policy finds a feasible solution but the combined quality
value is very low. If the MinGQ of each group is raised to 0.3,
the solution found by the Minimum policy becomes infeasible
due to the MinGQ constraint. Random policy sometimes can
find a feasible and good solution (such as Rnd2) and sometimes
cannot find a feasible solution (Rnd1, for example).
To cope with the security scheme, we need to implement
the security mechanisms as program modules and add code to
the tasks to invoke the pre-selected security mechanisms in the
flight control system. Properly designing the APIs for the se-
curity mechanism is therefore important as the APIs serve as
36 IEEE TRANSACTIONS ON INDUSTRIAL INFORMATICS, VOL. 5, NO. 1, FEBRUARY 2009
TABLE IX
FOUR SECURITY SELECTION POLICY
the bridge between the tasks in the application and the security
mechanism implementation in the underlying systems. For com-
plicated distributed systems, it is worth while investigating the
security middleware system to cope with the complexities and
specialties of diverse security mechanisms as shown in [33] as
the developer might find that the low level security service APIs
are complicated to use. With the security middleware which de-
fines high level API for accessing security service and trans-
lates the high level service calls to low level security mecha-
nism calls, the users (or the tasks) only need to access high level
APIs for managing and configuring multiple security services.
As the schedulability test and the optimization of security selec-
tion are performed offline, no support is needed for the under-
lying system for dynamically selecting the security services.
VII. CONCLUSION AND FUTURE WORKS
This paper presents EDF schedulability driven security op-
timization in real-time systems. A group-based security model
is used where the services are partitioned into groups. Services
in the same security group provide the same type of security
service but of different quality due to the different mechanism
used. Services from different groups can be combined to achieve
better security. Applying security services to a system incurs
overhead to the system. The overhead model of a security ser-
vice has also been described. A security aware EDF schedula-
bility test has been developed which takes the density of secu-
rity service into account. Two approaches have been proposed
to select the best combination of security services for real-time
systems while guaranteeing their schedulability. One is integer
linear programming technique and the other is heuristic search
technique. The search technique is efficient since pruning and
back jumping are used to reduce the search space. Evaluation
has been conducted to show the effectiveness of the security op-
timization techniques. To the best of our knowledge, this is the
first work on static security aware schedulability analysis and
static security optimization in real-time systems.
Extensive test suites have been performed to compare the
two metrics: the combined security value and the schedulability
value, using our method and the following three policies (Min-
imum, Maximum, and Random) to select the security levels
for tasks. Experimental results show that the combined secu-
rity values obtained by our method are substantially higher than
those achieved by alternatives for real-time tasks without vio-
lating real-time constraints.
Currently, the weight for security group is the same for all
the tasks. In fact, different tasks may require different degree of
the various types of security services. A task may require more
authentication services than confidentiality service and the other
task may require more on data integrity than authentication. Fur-
ther improvement can be made for computing the overhead of
each security variant applying to a task. For example, instead of
using two parameters ( and ), functions can be defined for
each security overhead computation.
The work will also be extended to consider other scheduling
policies such as fixed priority scheduling policy in real-time sys-
tems.
ACKNOWLEDGMENT
The authors would like to thank the anonymous referees for
their insightful suggestions and comments for improving the
quality of this paper.
REFERENCES
[1] lp_Solve. [Online]. Available: http://lpsolve.sourceforge.net/.
[2] T. F. Abdelzaher, E. M. Atkins, and K. G. Shin, “QoS negotiation in
realtime systems and its application to automated flight control,” in
Proc. IEEE Real-Time Technology and Applications Symp., 1997, pp.
228–238.
[3] H. Aydin, R. Melhem, D. Moose, and P. Mejia-Alvarez, “Power-aware
scheduling for periodic real-time tasks,” IEEE Trans. Comput., vol. 53,
no. 5, pp. 584–600, May 2004.
[4] A. Burns, “Scheduling hard real-time systems: A review,” Softw. Eng.
J., vol. 6, pp. 116–128, 1991.
[5] J. J. Chen, H. R. Hsu, and T. W. Kwo, “Leakage-aware energy-efficient
scheduling of real-time tasks in multiprocessor systems,” in Proc. IEEE
Real Time Technology and Applications Symp., Washington, DC, 2006,
pp. 408–417.
[6] T. Dean, J. Allen, and Y. Aloimonos, Artificial Intelligence. Reading,
MA: Addison-Wesley, 1995.
[7] D. P. Eames and J. Moffett, “The integration of safety and security
requirements,” in Proc. 18th Int. Conf. Computer Safety, Reliability and
Security, London, U.K., 1999, pp. 468–480.
[8] J. Engblom, A. Ermedahl, M. Sjödin, J. Gustavsson, and H. Hansson,
“Towards industry strength worst-case execution time analysis,” in
Proc. SNART’99, Linköping, Sweden, 1999, Linköping Univ..
[9] W. E. Faller and S. J. Schreck, “Real-time prediction of unsteady
aerodynamics: Application for aircraft control and manoeuvrability
enhancement,” IEEE Trans. Neural Netw., vol. 6, no. 6, pp. 1461–1468,
Nov. 1995.
[10] W. A. Halang and A. D. Stoyenko, Constructing Predictable Real Time
Systems. Norwell, MA: Kluwer, 1991.
[11] C. Irvine and T. Levin, “Quality of security service,” in Proc. 2000
Workshop New Security Paradigms, Cork, Ireland, 2001, pp. 91–99.
[12] C. Irvine and T. Levin, “Towards a taxonomy and costing method for
security services,” in Proc. 15th Annu. Computer Security Applications,
2007.
[13] C. Kaufman, R. Perlman, and M. Speciner, Network Security: Private
Communication in a Public World. Upper Saddle River, NJ: Prentice-
Hall, 2002.
[14] M. Lin and L. T. Yang, “Schedulability driven security optimization in
real-time systems,” in Proc. 1st Int. Conf. Availability, Reliability and
Security (ARES 2006), Vienna, Austria, Apr. 2006, pp. 314–320.
[15] J. W. S. Liu, Real-Time Systems. Englewood Cliffs, NJ: Prentice-
Hall, 2000.
[16] J. W.-S. Liu, K.-J. Lin, W.-K. Shih, A. C.-S. Yu, C. Chung, J. Yao, and
W. Zhao, “Algorithms for scheduling imprecise computations,” IEEE
Comput., vol. 24, no. 5, pp. 58–68, May 1991.
[17] B. Mahafza, S. Welstead, D. Champagne, R. Manadhar, T. Wor-
thington, and S. Campbell, “Real-time radar signal simulation for the
ground based radar for national missile defense,” in Proc. 1998 IEEE
Radar Conf., Dallas, TX, May 1998, pp. 62–67.
[18] J. Nilsson and F. Dahlgren, “Improving performance of load-store se-
quences for transaction processing workloads on multiprocessors,” in
Proc. Int. Conf. Parallel Processing, Washington, DC, Sep. 1999, pp.
246–255.
[19] C. D. Papadimitriou and K. Steiglitz, Combinatorial Optimization:
Algorithms and Complexity. Englewood Cliffs, NJ: Prentice-Hall,
1982.
[20] C. Park, “Predicting program execution time by analyzing static and
dynamic program paths,” J. Real-Time Syst., vol. 5, pp. 31–62, 1993.
[21] P. Puschner and C. Koza, “Calculating the maximum execution time of
real-time programs,” J. Real-Time Syst., vol. 1, pp. 159–176, 1989.
[22] Q. Quan and X. S. Hu, “Energy efficient DVS schedule for fixed-pri-
ority real-time systems,” ACM Trans. Embed. Comput. Syst., vol. 6, no.
4, 2007, Article no. 29.
LIN et al.: STATIC SECURITY OPTIMIZATION FOR REAL-TIME SYSTEMS 37
[23] R. Rajkumar, C. Lee, J. Lehoczky, and D. Siewiorek, “A resource allo-
cation model for QoS management,” in Proc. IEEE Real-Time Systems
Symp., San Francisco, CA, Dec. 1997, pp. 298–307.
[24] C. A. Rusu, R. Melhem, and D. Mosse, “Maximizing the system value
while satisfying time and energy constraints,” IBM J. Res. Develop.,
vol. 47, no. 5–6, pp. 689–702, 2003.
[25] S. H. Son, R. Mukkamala, and R. David, “Integrating security and real-
time requirements using covert channel capacity,” IEEE Trans. Knowl.
Data Eng., vol. 12, no. 6, pp. 865–879, Dec. 2000.
[26] S. H. Son, R. Zimmerman, and J. Hansson, “An adaptable security
manager for real-time transactions,” in Proc. 12th Euromicro Conf.
Real-Time Systems, Stockholm, Sweden, Aug. 2000, pp. 63–70.
[27] S. Son and B. Thuraisingham, “Towards a multilevel secure database
management system for real-time applications,” in Proc. IEEE Work-
shop Real-Time Applications, New York, May 1993, pp. 131–135.
[28] J. A. Stankovic, “Misconceptions about real-time computing,” IEEE
Computer, vol. 21, no. 10, pp. 10–19, Oct. 1988.
[29] J. A. Stankovic, M. Spuri, K. Ramamritham, and G. Buttazzo, Dead-
line Scheduling for Real-Time Systems: EDF and Related Algorithms,
ser. The Springer International Series in Engineering and Computer
Science. Norwell, MA: Kluwer, 1998.
[30] S. Suzuki, T. Katane, H. Saotome, and O. Saito, “Electric power-gen-
erating system using magnetic coupling for deeply implanted med-
ical electronic devices,” IEEE Trans. Magn., vol. 38, no. 5, pt. 1, pp.
3006–3008, Sep. 2002.
[31] T. Xie and X. Qin, “A new allocation scheme for parallel applications
with deadline and security constraints on clusters,” in Proc. 7th IEEE
Int. Conf. Cluster Computing (Cluster 2005), Boston, MA, 2005, pp.
1–10.
[32] T. Xie and X. Qin, “Scheduling security-critical real-time applications
on clusters,” IEEE Trans. Comput., vol. 55, no. 7, pp. 864–879, Jul.
2006.
[33] T. Xie and X. Qin, “Security middleware model for real-time ap-
plications on grids,” IEICE Tran. Inf. Syst. Archive, vol. E89-D, pp.
631–638, 2006.
[34] T. Xie, X. Qin, and M. Lin, “Open issues and challenges in security-
aware real-time scheduling for distributed systems,” Inf. J., vol. 9, no.
2, pp. 215–230, 2006.
[35] T. Xie, X. Qin, and A. Sung, “SAREC: A security-aware scheduling
strategy for real-time applications on clusters,” in Proc. 34th Int. Conf.
Parallel Processing, Oslo, Norway, 2005, pp. 5–12.
[36] D. Zhu and H. Aydin, “Reliability-aware energy management for pe-
riodic real-time tasks,” in Proc. IEEE Real-Time and Embedded Tech-
nology and Applications Symp. (RTAS’07), Bellevue, WA, 2007, pp.
225–235.
Man Lin (M’08) received the B.E. degree in
computer science and technology from Tsinghua
University, Beijing, China, in 1994. She received
the Lic. and Ph.D. degrees from the Department of
Computer Science and Information at Linköping
University, Linköping, Sweden, in 1997 and 2000,
respectively.
She is currently an Associate Professor of com-
puter science at St. Francis Xavier University,
Antigonish, NS, Canada. Her research interests
include real-time and embedded system design and
analysis, scheduling, power aware computing, and optimization algorithms.
Her research is supported by National Sciences and Engineering Research
Council, Canada (NSERC) and Canada Foundation for Innovation (CFI).
Li Xu (M’07) received the B.Sc. degree in computer
science with first class honors and the M.Sc. degree in
computer science from St. Francis Xavier University,
Antigonish, NS, Canada, in 2005 and 2008, respec-
tively.
He is currently a system administrator at Atlantic
Computational Excellence Network (ACEnet).
Laurence T. Yang (M’97) is with the Depart-
ment of Math and Computer Science, St. Francis
Xavier University, Antigonish, NS, Canada. His
research includes high-performance computing and
networking, embedded systems, and ubiquitous/per-
vasive computing and intelligence. His research is
supported by National Sciences and Engineering
Research Council, Canada (NSERC) and Canada
Foundation for Innovation (CFI).
Xiao Qin (S’99–M’04) received the B.S. and M.S.
degrees in computer science from Huazhong Univer-
sity of Science and Technology, Wuhan, China, in
1996 and 1999, respectively, and the Ph.D. degree in
computer science from the University of Nebraska-
Lincoln in 2004.
Currently, he is an Assistant Professor of computer
science at Auburn University, Auburn, AL. Prior to
joining Auburn University in 2007, he had been with
New Mexico Institute of Mining and Technology for
three years. His research interests include parallel and
distributed systems, real-time computing, storage systems, and fault tolerance.
Dr. Qin received an NSF Computing Processes & Artifacts (CPA) Award and
an NSF Computer Systems Research (CSR) Award in 2007. He has been on
the program committees of various international conferences, including IEEE
Cluster, IEEE IPCCC, and ICPP. He had served as a subject area editor of IEEE
Distributed System Online (2000–2001).
Nenggan Zheng received the B.Sc. degree in
biomedical engineering from Zhejiang University,
Hangzhou, China, in 2002. Currently, he is pursuing
the Ph.D. degree at the College of Computer Science
and Technology, Zhejiang University.
His research interests include real-time systems
and wearable computing.
Zhaohui Wu (SM’05) received the Ph.D. degree
in computer science from Zhejiang University,
Hangzhou, China, in 1993.
From 1991 to 1993, he was a joint Ph.D. student
in the area of knowledge representation and expert
system with the German Research Center for Artifi-
cial Intelligence (DFKI). He is currently a Professor
of computer science with Zhejiang University and the
Director of the Institute of Computer System and Ar-
chitecture. His major research interests include intel-
ligent transport systems, distributed artificial intelli-
gence, semantic grid, and ubiquitous embedded systems. He has authored four
books and more than 100 refereed papers.
Dr. Wu is a standing council member of China Computer Federation (CCF).
Since June 2005, he has been the vice chair of the CCF Pervasive Computing
Committee. He is on the editorial boards of several journals and has served as a
PC member for various international conferences.
Meikang Qiu (SM’07) received the B.E. and
M.E. degrees from Shanghai Jiao Tong University,
Shanghai, China, and the M.S. and Ph.D. degrees in
computer science from University of Texas at Dallas.
He is an Assistant Professor of electrical and com-
puter engineering at the University of New Orleans,
New Orleans, LA. His research interests include em-
bedded systems, computer and network security, and
wireless sensor networks.
Dr. Qiu has been an editor for several journals, a
chair, and a TPC member for many international con-
ferences, such as IEEE CSE 2008, IEEE SEC 2008, 2009, IEEE ESO 2008, and
IEEE GlobeCom 2008.

