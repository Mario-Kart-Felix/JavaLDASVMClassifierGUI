Efficient Manifold and Subspace Approximations with
Spherelets
Didong Li and David B Dunson
Data lying in a high-dimensional ambient space are commonly thought to have a much
lower intrinsic dimension. In particular, the data may be concentrated near a lower-dimensional
subspace or manifold. There is an immense literature focused on approximating the unknown
subspace, and in exploiting such approximations in clustering, data compression, and build-
ing of predictive models. Most of the literature relies on approximating subspaces using a
locally linear, and potentially multiscale, dictionary. In this article, we propose a simple and
general alternative, which instead uses pieces of spheres, or spherelets, to locally approxi-
mate the unknown subspace. Building on this idea, we develop a simple and computationally
efficient algorithm for subspace learning and clustering. Results relative to state-of-the-art
competitors show dramatic gains in ability to accurately approximate the subspace with
orders of magnitude fewer components. This leads to substantial gains in data compress-
ibility, few clusters and hence better interpretability, and much lower MSE based on small
to moderate sample sizes. Basic theory on approximation accuracy is presented, and the
methods are applied to multiple examples.
Key Words: Curvature; Dimensionality reduction; Geometric multiresolution analysis;
Manifold learning; Subspace learning.
1 Introduction
Given data set X = {xi}ni=1, we assume xiâ€™s are sampled i.i.d from some probability measure
Ï in Rp. In many applications, Ï is supported on or near a lower dimensional subspace or
manifold M with dimension d p. In the majority of the literature, the lower-dimensional
subspace structure is assumed to be linear; for example, typical principal components anal-
ysis (PCA) and latent factor models assume a linear subspace. To more realistically charac-
terize a broad class of datasets and enable greater dimensionality reduction, a more flexible
assumption is to suppose the subspace is a potentially nonlinear d-dimensional manifold
embedded in the dimension p ambient space. â€œManifold learningâ€ is the problem of estimat-
ing a mapping from the p-dimensional ambient space of the observed data to the intrinsic
d-dimensional space.
A rich variety of algorithms are available for manifold learning and nonlinear PCA . The
most popular method is to approximate the manifold or subspace by a set of hyperplanes.
These approaches build on the rich literature on approximating manifolds by a set of tangent
planes; for example multiscale PCA uses such a representation to approximate the support
1
ar
X
iv
:1
70
6.
08
26
3v
1 
 [
st
at
.M
L
] 
 2
6 
Ju
n 
20
17
of the data by piecewise hyperplanes ([4-15]). A key disadvantage of such approaches is
the lack of statistical efficiency and parsimony of the representation, particularly when the
true manifold has large curvature. For example, if the manifold is a circle with very small
radius (very large curvature), a huge number of tangent lines will be needed to fit the circle
well. Such disadvantages also hold when M is not a single manifold but is a more complex
collection of manifolds.
Taking curvature into consideration, a reasonable local approximation for a manifold is
provided by a sphere. With such a locally curved basis, a pseudo distance between any two
sets of points is defined based on how well they can be fit by a space form. By using a
collection of spheres to build up a local approximation to a manifold, or to a collection of
disconnected manifolds, one obtains a generalization of common local linear approximations.
In particular, each sphere converges to a hyperplane in the limit as the radiusâ†’âˆž. However,
when the subspace is not approximately flat, our new sphere-based basis will perform much
better. The improvement will increase with the curvature of the unknown subspace being
approximated.
Our simulation results show significant gains in reduction in the number of components
needed to provide an approximation within a given error tolerance. We compare our results
with Geometric MultiResolution Analysis (GMRA) (Liao and Maggioni), which performs
better than most algorithms, according to [1][2][3]. Our spherelets approach has much lower
mean square error using dramatically fewer components. Substantial practical gains are
shown in multiple examples, including in cases in which the true subspace does not have
a manifold structure, but is more appropriately characterized by multiple separated mani-
folds. The proposed approach automatically accounts for such structure. Classification from
features having a lower-dimensional subspace structure is also addressed as a byproduct of
our algorithm.
The paper is organized as follows. The selection of local basis is discussed in section 2.
In section 3, the optimization problem of one single sphere is solved. In section 4, some
important concepts including spherelet and spherical distance are defined. We present our
manifold approximation algorithm in section 5 and then show numerical experiments in
Section 6. An improved version of the algorithm is shown in 7, followed by some other
numerical experiments.
2 Selection of local basis
Most existing algorithms approximate manifolds or subspaces by fitting data with hyper-
planes locally. A primary motivation for relying on hyperplanes instead of alternatives is
simplicity. However, as we have motivated in Section 1, hyperplanes have disadvantages
in terms of parsimony in approximating manifolds that have moderate to high curvature.
There is hence motivation to consider alternative local approximations to manifolds that are
not much more complex than hyperplanes but have non-zero curvature.
2
One can view local hyperplane approximations to the manifold as arising from a first
order Taylor series approximation. It is hence natural to consider second order Taylor series
expansions, which have a quadratic form. In particular, instead of a hyperplane embedded
in Rp, we have
M = {x âˆˆ Rp : x>Hx+ f>x+ c = 0},
where H âˆˆ Sym(p), f âˆˆ Rp and c âˆˆ R. These quadratic surfaces provide a generalization
of hyperplanes, which arise in the special case in which H = 0. However, the extra flex-
ibility of the quadratic form comes at the expense of a dramatic increase in the number
of parameters, which is p(p+1)2 + p + 1 = O(p
2) for each local piece relative to O(p) for
hyperplane dictionary functions. This makes the extension from local linear to quadratic
approximations impractical; a primary goal is reducing the number of parameters needed
in accurately approximating the overall manifold and using too many parameters per local
piece runs counter to this goal.
To reduce the complexity, we need to simplify the dictionary functions. With this goal
in mind, we start by taking a geometric perspective and viewing hyperplanes as complete,
simply connected manifolds with zero (sectional) curvature. One can then consider the
generalization to space forms defined as follows:
Definition 1. A complete, simply connected Riemannian manifold of constant sectional
curvature is called a space form. A p dimensional space form with curvature c is denoted by
Mp(c).
There is a famous classification theorem up to isometry.
Theorem 1. Let Mp(c) be a space form, then
Mp(c) âˆ¼=
ï£±ï£´ï£²ï£´ï£³
Sp( 1âˆš
c
) c > 0
Rp c = 0
Hp(c) c < 0
, (1)
where Sp( 1âˆš
c
) is p dimensional sphere with radius 1âˆš
c
and Hp(c) is a p dimensional hyperbolic
space with curvature c.
Hence, hyperplanes are one of three types of space forms, and it is natural to consider
the other two types as alternative choices of dictionary functions. In particular, instead of
just hyperplanes, we could include spheres and/or hyperbolic functions. A p dimensional
sphere centered at x0 with radius r, denoted by S
p(x0, r), can be expressed as
â€–xâˆ’ x0â€–2 = ã€ˆxâˆ’ x0, xâˆ’ x0ã€‰ = r2,
where ã€ˆÂ·, Â·ã€‰ is the usual Euclidean inner product in Rp+1 and the curvature is 1
r2
. We can
rewrite this equation in form (1) as:
x>Ix+ (âˆ’2x0)>x+ (x>0 x0 âˆ’ r2) = 0.
3
Hyperbolic spaces have more diversity, with p+ 1 symmetric axes:
â€–xâˆ’ x0â€–2i = ã€ˆxâˆ’ x0, xâˆ’ x0ã€‰i = âˆ’r2, xi â‰¥ 0, i = 1, Â· Â· Â· , p+ 1,
where ã€ˆÂ·, Â·ã€‰i is the Lorentz inner product defined as
ã€ˆx, yã€‰i = x1y1 + Â· Â· Â·+ xiâˆ’1yiâˆ’1 âˆ’ xiyi + xi+1yi+1 + Â· Â· Â·+ xn+1yn+1.
Again, we rewrite the above equation in the same form as equation (1):
x>Lix+ (âˆ’2Lix0)>x+ (x>0 Lix0 + r2) = 0,
where Li = {(Li)kl = Î´kl(1âˆ’2Î´ki)} is the diagonal matrix with all 1s on the diagonal except
the ith, which is âˆ’1.
Although we could potentially include spheres, hyperplanes and hyperbolic spaces simul-
taneously in our dictionary, we only include spheres for the following reasons:
1. Assume the computational complexity of fitting data X âˆˆ RnÃ—(p+1) by a sphere is
Î²(n, p), then the complexity of fitting a hyperbolic space with known symmetric axes is also
Î²(n, p). Since there are p+ 1 symmetric axes of p dimensional hyperbolic spaces, the total
complexity is (p+ 1)Î²(n, p).
2. The sphere is compact, while hyperbolic spaces and hyperplanes are noncompact.
Compactness is appealing from a computational stability perspective and in terms of guar-
anteeing locality of each dictionary element.
3. The cell complex structure of the sphere is ideal in this situation. Letting ei be the i
dimensional open ball, the classical cell complex structure of Sp is
Sp = Spâˆ’1 âˆª ep1 âˆª e
p
2.
In other words, a lower dimensional sphere can be viewed as an â€œequatorâ€ of a higher
dimensional sphere. We will make use of this property in our algorithm later.
4. Hyperplanes can be approximated by spheres with large radius.
As a result, we choose spheres as our local basis. Since the manifold is approximated
with multiple local spheres, the basis is called spherelets.
3 Optimization
In this section, we focus on the problem of fitting data using a single sphere; this will
serve as a key building block in developing general spherelet fitting algorithms. Given data
X âˆˆ RnÃ—p, where each row xi âˆˆ Rp, our goal is to estimate a sphere centered at x with
radius r that fits the data as well as possible.
Let xÌ‚i be the projection of xi onto the sphere centered at x with radius r. That is,
xÌ‚i = x+
r
â€–xi âˆ’ xâ€–
(xi âˆ’ x).
4
As a typical choice of loss function, we consider the mean square error (MSE):
min
x,r
1
n
nâˆ‘
i=1
â€–xÌ‚i âˆ’ xiâ€–2.
The MSE can be re-expressed as follows:
1
n
nâˆ‘
i=1
âˆ¥âˆ¥âˆ¥âˆ¥xÌ‚i âˆ’ xiâˆ¥âˆ¥âˆ¥âˆ¥2 = 1n
nâˆ‘
i=1
â€–x+ r
â€–xi âˆ’ xâ€–
(xi âˆ’ x)âˆ’ xi
âˆ¥âˆ¥âˆ¥âˆ¥2
=
1
n
nâˆ‘
i=1
âˆ¥âˆ¥âˆ¥âˆ¥(xi âˆ’ x)( r||xi âˆ’ x|| âˆ’ 1
)âˆ¥âˆ¥âˆ¥âˆ¥2
=
1
n
nâˆ‘
i=1
(â€–xi âˆ’ xâ€– âˆ’ r)2
=
1
n
nâˆ‘
i=1
(di âˆ’ r)2
where di = â€–xiâˆ’xâ€–. Note that di is determined by x only, and the loss function is minimized
by r = dÌ„ =
1
n
nâˆ‘
i=1
di when all diâ€™s are known. As a result, we only need to find the optimal
x, and r will be obtained automatically. Then observe that
min
x,r
1
n
nâˆ‘
i=1
â€–xÌ‚i âˆ’ xiâ€–2 = min
x,r
1
n
nâˆ‘
i=1
(di âˆ’ r)2
= min
x
1
n
nâˆ‘
i=1
(di âˆ’ dÌ„)2
= min
x
var(di) =: f(x)
That is, to minimize the mean square error is equivalent to minimize the variance of {di}.
This is not surprising since if all xi lie on some d dimensional sphere S
d âŠ‚ Rp, where d is the
intrinsic dimension of these data, then â€–xiâˆ’xâ€– should be all close to r, that is, the variance
of di = â€–xi âˆ’ xâ€– should be small. However, it is difficult to solve this problem, since x can
not be factored out of di = ã€ˆxâˆ’ xi, xâˆ’ xiã€‰
1
2 . As a result, we choose another loss function g
which is easier than f to handle:
g(x) : = var(d2i )
=
1
n
nâˆ‘
i=1
(d2i âˆ’ dÌ„2)2
=
1
n
nâˆ‘
i=1
(â€–xi âˆ’ xâ€–2 âˆ’
1
n
nâˆ‘
j=1
â€–xj âˆ’ xâ€–2)2.
5
Lemma 1. The optimization problem of
min
x
g(x) = min
x
1
n
nâˆ‘
i=1
(
â€–xi âˆ’ xâ€–2 âˆ’
1
n
nâˆ‘
j=1
â€–xj âˆ’ xâ€–2
)2
is equivalent to the following quadratic optimization problem:
min
x
x>Hx+ f>x,
where H =
nâˆ‘
i=1
(xÌ„âˆ’ xi)(xÌ„âˆ’ xi)>, xÌ„ =
1
n
nâˆ‘
i=1
xi, f =
nâˆ‘
i=1
(li âˆ’ lÌ„)(xÌ„âˆ’ xi), li = â€–xiâ€–2,
lÌ„ =
1
n
nâˆ‘
i=1
li.
Proof. We begin with the building block of g,
||xâˆ’ xi||2 = (xâˆ’ xi)>(xâˆ’ xi)
= x>xâˆ’ 2x>xi + x>i xi,
and
nâˆ‘
i=1
||xâˆ’ xi||2 =
nâˆ‘
i=1
(x>xâˆ’ 2x>xi + x>i xi)
= nx>xâˆ’ 2nx>xÌ„+
nâˆ‘
i=1
li.
Then,
||xâˆ’ xi||2 âˆ’
âˆ‘n
i=1 ||xâˆ’ xi||2
n
= x>xâˆ’ 2x>xi + x>i xi âˆ’
1
n
(nx>xâˆ’ 2nx>xÌ„+
nâˆ‘
i=1
li)
= âˆ’2x>xi + li + 2x>xÌ„âˆ’ lÌ„.
Then
(||xâˆ’ xi||2 âˆ’
âˆ‘n
i=1 ||xâˆ’ xi||2
n
)2 = (âˆ’2x>xi + li + 2x>xÌ„âˆ’ lÌ„)2
= (2x>(xÌ„âˆ’ xi) + (li âˆ’ lÌ„))2
= 4x>(xÌ„âˆ’ xi)x>(xÌ„âˆ’ xi) + 4(li âˆ’ lÌ„)x>(xÌ„âˆ’ xi) + (li âˆ’ lÌ„)2
= 4x>(xÌ„âˆ’ xi)(xÌ„âˆ’ xi)>x+ 4(li âˆ’ lÌ„)(xÌ„âˆ’ xi)>x+ (li âˆ’ lÌ„)2
6
Since li and l do not depend on x, itâ€™s equivalent to minimize
x>
( nâˆ‘
i=1
(xÌ„âˆ’ xi)(xÌ„âˆ’ xi)>
)
x+
( nâˆ‘
i=1
(li âˆ’ lÌ„)(xÌ„âˆ’ xi)>
)
x
= x>Hx+ f>x,
where H =
nâˆ‘
i=1
(xÌ„âˆ’ xi)(xÌ„âˆ’ xi)> and f =
nâˆ‘
i=1
(li âˆ’ lÌ„)(xÌ„âˆ’ xi).
Note 1. In fact H is nothing but the sample covariance of X. It is not surprising that H
comes in since we want to minimize the variance of d2i .
This quadratic optimization problem is easy to solve:
Proposition 1. arg min
x
g(x) = âˆ’1
2
Hâˆ’1f when H is invertible.
Proof. Trivial.
Note 2. The solution is unique if and only if H is invertible. When n < p and H is singular,
we can still solve the problem by applying pseudo-inverse of H, also denoted by Hâˆ’1.
4 Spherelet and divergence
In this section, we define several core terms in our algorithm. First, we define the spherelet
s(X) corresponding to a set of points X âˆˆ RnÃ—p:
Definition 2. Let X âˆˆ RnÃ—p with rows xi âˆˆ Rp, then the sphere centered at c with radius r
is called the spherelet of X, denoted by s(X):
s(X) := S(c, r),
where c = âˆ’12H
âˆ’1f , r =
1
n
nâˆ‘
i=1
â€–xi âˆ’ câ€–.
In some sense, the spherelet s(X) is the sphere providing the best fit to data set X.
Definition 3. Let X âˆˆ RnÃ—p with rows xi âˆˆ Rp and assume s(X) = S(c, r) is the spherelet
of X, then
(X) =
1
n
nâˆ‘
i=1
(â€–xi âˆ’ câ€– âˆ’ r)2,
is called the spherical error of X.
7
Note 3. The smaller the spherical error (X), the more spherical X is. The following
proposition explains the intuition of the spherical error:
Proposition 2. All points xi lie on a sphere if and only if (X) = 0.
Proof. =â‡’ Assume all xi lie on the sphere centered at câ€² with radius râ€². then â€–xiâˆ’ câ€²â€– = râ€²,
âˆ€i = 1, Â· Â· Â· , n, so 1
n
nâˆ‘
i=1
(â€–xi âˆ’ câ€²â€– âˆ’ râ€²)2 = 0. Assume s(X) is centered at r with radius r,
then by the definition of spherelet,
(X) =
1
n
nâˆ‘
i=1
(â€–xi âˆ’ câ€– âˆ’ r)2 â‰¤
1
n
nâˆ‘
i=1
(â€–xi âˆ’ câ€²â€– âˆ’ râ€²)2 = 0.
â‡= Assume 0 = (X) = 1
n
nâˆ‘
i=1
(â€–xi âˆ’ câ€– âˆ’ r)2, then â€–xiâˆ’ câ€–âˆ’ r = 0, âˆ€i = 1, Â· Â· Â· , n, so all xi
lie on the sphere centered at c with radius r.
Then we define a divergence measuring the dissimilarity of two data sets X âˆˆ RnÃ—p and
Y âˆˆ RmÃ—p in terms of the distance between their corresponding spheres. If the datasets lie
on the same sphere, their divergence is zero.
Definition 4. Let Fpd be the collection of all sets of samples drawn by some probability
measure whose support is some d dimensional manifold embedded in Rp. Then each element
in Fpd can be written as an n Ã— p matrix, each row represents a sample. The Riemannian
divergence dR : Fpd Ã—F
p
d â†’ Râ‰¥0 is a divergence defined on F
p
d :
dR(X,Y ) = (Z)
where X,Y âˆˆ Fpd , Z = X âˆª Y âˆˆ R
(nX+nY )Ã—p = [x1, Â· Â· Â· , xnX , y1, Â· Â· Â· , ynY ]>.
By proposition 2, X,Y lie on the same sphere if and only if (X,Y ) = 0. This Riemannian
divergence is semi-positive definite since dR(X,Y ) = (X âˆª Y ) â‰¥ 0 for any X,Y . However,
dR is not positive definite. Actually, when dR(X,Y ) = 0, we only know X,Y lie on the same
sphere, but X,Y are not necessarily the same. The spherelet divergence is also symmetric.
In order to measure the similarity between two sets of points, we also need to take the
Euclidean distance into consideration: if two set of points could be fitted by one single
sphere, and their Euclidean distance is also small, it is reasonable to regard them as one
group.
Definition 5. Let dE be the Euclidean distance between two sets of points, that is,
dE(X,Y ) = inf
i,j
â€–xi âˆ’ yjâ€–,
8
then the following divergence is called spherelet divergence.
dS : Fpd Ã—F
p
d â†’ Râ‰¥ : (X,Y ) 7â†’ dR(X,Y ) +âˆž1dE(X,Y )>Î»,
where Î» > 0 is a tuning parameter, and can be optimized by cross validation. Details on
the choice of Î» are in the next section.
Note 4. dR is called Riemannian divergence since it captures the similarity between X and
Y in the sense that dR(X,Y ) is small if X,Y almost belong to one single space form with
constant sectional curvature. dE is called Euclidean distance since it is the Euclidean distance
of two closest points in X and Y respectively. In fact, dE captures the (path) connectivity of
two data sets: if the supporting manifolds belong to one connected component, either their
Euclidean distance is small, or they could be connected by some other data set. We will see
the importance of this property later in our algorithm. As dR reflects geometric properties
and dE reflects topological properties, dS can pick up both types of properties.
5 Manifold approximation algorithm
Assume the data set X âˆˆ RnÃ—p âŠ‚ Fpd is sampled by some probability measure Ï supported
on a d dimensional manifold or subspace M . Our goal is to find the best piecewise spherical
manifold or subspace MÌ‚ and the projection map p : Rp â†’ MÌ‚ such that the mean square
error
nâˆ‘
i=1
â€–xi âˆ’ p(xi)â€–2 is minimized.
Our algorithm has the following key steps:
Step 1: Preprocess
To make computation and default tuning parameter choice easier, we normalize the data so
that xi âˆˆ [âˆ’1, 1]p.
Step 2: split
We split the data into clusters, with the data in each cluster fit well by a cluster-specific
sphere. Algorithm 1 provides the pseudo code for our initial clustering algorithm.
Step 3: merge
Step 2 can result in many clusters, and performance can be improved by adding a merge
step based on spherelet distance; refer to Algorithm 2.
Step 4: calculating spherelets
Based on Steps 1-3 we have a cluster label for each data point. Step 4 applies Algorithm 3
to calculate the explicit formula of the spherelet for each cluster.
9
Algorithm 1: Assign data to clusters having cluster-specific spherelets.
input : X, , Î»
output: label
1 initialize label= 0n;
2 cluster=0 ;
3 while labeling not done do
4 cluster++;
5 flag= 1;
6 find all unlabeled data;
7 while flag==1 and labeling not done do
8 choose the nearest unlabeled point x of current cluster Xcls;
9 if dÎ»(x,Xcls) > Î» then
10 flag=0;
11 end
12 else
13 find the spherelet s(Xcls âˆª x);
14 if spherical error (Xcls âˆª x) <  then
15 assign x to current cluster, label of x = cluster ;
16 end
17 else
18 flag=0;
19 end
20 end
21 end
22 end
10
Algorithm 2: merge clusters
input : X, label, , Î»
output: label
1 ncls = current number of clusters;
2 flag= 1;
3 while flag== 1 and ncls> 1 do
4 Dij = dÎ»(Xi, Xj) is the spherelet distance between cluster i and j;
5 Find the closest two clusters ;
6 if min(D) <  then
7 merge the two corresponding clusters;
8 end
9 else
10 flag = 0;
11 end
12 end
Algorithm 3: calculate spherelets
input : X, label
output: centers, radii
1 ncls = number of clusters;
2 for i = 1:ncls do
3 currX= all points in cluster i;
4 s(currX) = S(c, r)= spherelet of currX;
5 centers[i, :] = c;
6 radii[i] = r;
7 end
11
Step 5: construct p
An estimate MÌ‚ of the supportM is obtained by essentially pasting all the spherelets together.
Given any point x âˆˆ Rp, we want to find the projection of x onto MÌ‚ . To find which cluster
an arbitrary x belongs to, we calculate
arg min
k
d(x, Sd(ck, rk)) = arg min
k
(â€–xâˆ’ ckâ€– âˆ’ rk)2.
Then the projection map is
xÌ‚ = p(x) = ck +
rk
â€–xâˆ’ ckâ€–
(xâˆ’ ck).
Step 6: calculating MSE on test data
Given Xtest = [x
t
1, Â· Â· Â· , xtm]> âˆˆ RmÃ—p, then the mean square error is
MSE =
1
m
mâˆ‘
i=1
â€–xti âˆ’ p(xti)â€–2.
In order to choose the two tuning parameters,  and Î», we recommend using cross
validation (CV). In particular, the data are split into a training and test subsample. For
each possible choice of (, Î») on a grid, the spherelets algorithm in Steps 1-6 is applied, with
the spherelets estimated using the training data, and MSE calculated using the test data.
The (, Î») minimizing test MSE is chosen.
The code for the algorithm can be found here: https://github.com/david-dunson/spherelets
6 Examples
There is a rich literature on toy examples for manifold and subspace learning. We consider
some such examples here.
Olympic rings
We generate 2, 000 data uniformly from the subspace M : Olympic rings. We applied our
spherelets algorithm to these data obtaining tuning parameters of  = 10âˆ’5 and Î» = 0.1
via cross validation, using 1, 000 samples for training and 1, 000 samples for test. Figure 1
shows the result. The top panel is the test data, the middle panel is the projection of the
test data onto MÌ‚ , and the third panel color codes the clusters. It is easy to see that the
model fit is excellent in that the first two panels are very close. Indeed, the test MSE was
only 1.706 Ã— 10âˆ’7. In addition, clustering does an excellent job in perfectly labelling the
different circles in the olympic rings. Of course, this is essentially an ideal case for spherelets
in that the different rings are exact circles and data lie exactly on M . We will first make
the problem more difficult by adding noise.
12
Figure 1: Olympic rings
13
Noised Olympic rings
We add Gaussian noise  âˆ¼ N(0,Î£) where Î£ =
[
0.01 0
0 0.01
]
to the Olympic ring data as
shown in the previous example, and re-run our spherelet algorithm exactly as before. In
this case, the optimal tuning parameter values from CV were  = 10âˆ’3 and Î» = 0.1, and
the MSE in the test set was 9.49Ã— 10âˆ’4. Figure 2 shows the results in the same format as
for Figure 1; the top panel shows that there is a moderate level of noise, but the rings are
still visibly evident. The algorithm is able to accurately pick this up and cluster the data
into five color-coded rings; there is some error in estimating the radius, which is as expected
given the level of measurement error.
Noised spiral
The first two examples consist of circles, which are constant curvature. Now we consider a
more complicated manifold: the noised spiral. The curvature is decreasing as the point is
going outward. We generate 1, 000 data uniformly from the subspace M : noised spiral. We
applied our spherelets algorithm to these data obtaining tuning parameters of  = 10âˆ’4 and
Î» = 0.1 via cross validation, using 500 samples for training and 500 samples for test. Figure
3 shows the result. The first panel is the test data, the middle panel is the projection of the
test data onto MÌ‚ , and the third panel color codes the clusters. We can see that the first
two panels are similar to each other and the test MSE was only 1.4Ã— 10âˆ’4. From the third
panel, we can see five clusters with five different colors. The radius of the circle is decreasing
as the point is going outward, which coincides with the change of curvature.
7 Improvement
When p > n, or when p is very large, H tends to be singular and there will be an overfitting
problem. A simple example is when there are only two points, we can find infinitely many
circles so that the error is 0. To avoid this problem, we add another step in our algorithm
but we need more information about the intrinsic dimension. Assume an upper bound of
intrinsic dimension is known, that is, d â‰¤ K where K âˆˆ N is known. In the splitting
step (step 2), if the size of some cluster is less than or equal to K, this cluster is not that
informative, so we label all data in this cluster by âˆ’1. After merging step (step 3), we assign
each point with label âˆ’1 to the nearest cluster under the spherelet distance. In addition,
another merging step follows. The remaining steps are the same - refer to Algorithm 4.
14
Figure 2: Noised Olympic rings
15
Figure 3: Noised spiral
Algorithm 4: split (new version)
input : X, , Î»
output: label
1 initialize label= 0n;
2 cluster=0 ;
3 while labeling not done do
4 cluster++;
5 flag= 1;
6 find all unlabeled data;
7 while flag==1 and labeling not done do
8 choose the nearest unlabeled point x of current cluster Xcls;
9 if dÎ»(x,Xcls) > Î» then
10 flag=0;
11 end
12 else
13 find the spherelet s(Xcls âˆª x);
14 if spherical error (Xcls âˆª x) <  then
15 assign x to current cluster, label of x = cluster ;
16 end
17 else
18 flag=0;
19 end
20 end
21 end
22 if number of rows of Xcls < K then
23 label(Xcls) = âˆ’1;
24 end
25 end
16
Another change is in the function locquad:
Algorithm 5: locquad
input : X, , Î»
output: label, centers, radii, MSE, ncls
1 normalize X;
2 label=split(Xtrain,, Î»);
3 label=merge(Xtrain,label,,Î»);
4 assign each point with label -1 to the nearest cluster based on dÎ»;
5 label=merge(Xtrain,label,,Î»);
6 find centers and radii;
7 calculate MSE;
All other functions are the same as in section 5.
8 More Examples
In this section, we test the improved algorithm on some more complicated data sets.
Swiss roll
We generate 1, 000 data uniformly from the subspace M : Swiss roll. We applied our
spherelets algorithm to these data for different combinations of tuning parameters Î» âˆˆ
{0.05, 0.1, 0.15} and  âˆˆ {0.01, 0.001, 0.0001, 0.0000} using 500 samples for training and 500
samples for test. For each combination, we store the number of clusters and the correspond-
ing MSE. Figure 4 shows the result. The top panel shows the test set in clusters when the
MSE is the smallest among all MSEs. The second panel shows the relation between MSEs
and the number of clusters. The x-axis is log10(ncls) and the y-axis is log10(MSE). We
compare the curve obtained by our spherelet algorithm and the results obtained by adaptive
GMRA [1]. The code is provided by Mauro Maggioni.
The red line, obtained from the spherelet algorithm, has not only smaller y-intercept,
but also smaller slope, which means our algorithm works better at using the data to obtain
a low error approximation using relatively few components.
Dragon
Now we consider a more complicated dataset: the surface of a dragon with sample size
2,000. As in the previous example, we compare our result with the adaptive GMRA. Figure
5 shows the result, where the red line is still below the other two and has smaller slope.
The above figure shows that the MSE of our spherelet algorithm is much smaller than
that of GMRA.
17
Figure 4: Swiss roll
Figure 5: Dragon
18
Figure 6: Atmosphere boundary
Atmosphere boundary
Above the earth surface, where are two layers in the Troposphere: planetary boundary layer
(L0) and free atmosphere (L1). The boundary between L0 and L1 is changing with time and
location. The concentration of certain pollutants drop off suddenly around this boundary,
which provides an approach to estimate the altitude of this boundary. Given a data set with
the coordinates of the boundary surface[16], we run our algorithm. The sample size is 3648
and the tuning parameters are Î» âˆˆ {0.05, 0.1, 0.15} and  âˆˆ {0.01, 0.001, 0.0001, 0.0000}.
Figure 6 shows the results. The first panel is the test data, the second one is the projected
data and the last one is the log10(ncls) vs log10(MSE) curve, as before. The MSE could be
as low as 104.5, which implies our algorithm works well for this real dataset.
References
[1] W. Liao and M. Mauro , Adaptive Geometric Multiscale Approximations for Intrinsically
Low-dimensional Data, arXiv:1611.011, 2016.
[2] G. Chen and M. Maggioni. Multiscale geometric and spectral analysis of plane arrange-
ments. In Conference on Computer Vision and Pattern Recognition, 2011.
19
[3] W. Liao, M. Maggioni, S. Vigogna, Learning Adaptive Multiscale Approximations to
Data and Functions near Low-Dimensional Sets, IEEE 2016.
[4] J.Wang, P. Neskovic and L. Cooper, A minimum sphere covering approach to pattern
classification,18th International Conference on Pattern Recognition, 2006.
[5] M. Scholz, F. Kaplan, C. Guy, J. Kopka, J. Selbig, Non-linear PCA: a missing data
approach, In Bioinformatics, Vol. 21, Number 20, pp. 3887â€“3895, Oxford University Press,
2005.
[6] N. Lawrence, Probabilistic Non-linear Principal Component Analysis with Gaussian Pro-
cess Latent Variable Models, Journal of Machine Learning Research 6(Nov): 1783â€“1816,
2005.
[7] P. Demartines and J. HeÌrault, Curvilinear Component Analysis: A Self-Organizing Neu-
ral Network for Nonlinear Mapping of Data Sets, IEEE Transactions on Neural Networks,
Vol. 8(1), 1997, pp. 148â€“154.
[8] C. Walder and B. SchoÌˆlkopf, Diffeomorphic Dimensionality Reduction, Advances in Neu-
ral Information Processing Systems 22, 2009, pp. 1713â€“1720, MIT Press.
[9] B. SchoÌˆlkopf, A. Smola, K.-R. MuÌˆller, Nonlinear Component Analysis as a Kernel Eigen-
value Problem. Neural Computation 10(5):1299-1319, 1998, MIT Press Cambridge, MA,
USA, doi:10.1162/089976698300017467.
[10] J. B. Tenenbaum, V. de Silva, J. C. Langford, A Global Geometric Framework for
Nonlinear Dimensionality Reduction, Science 290, (2000), 2319â€“2323.
[11] S. T. Roweis and L. K. Saul, Nonlinear Dimensionality Reduction by Locally Linear
Embedding, Science Vol 290, 22 December 2000, 2323â€“2326.
[12] M. Belkin and P. Niyogi, Laplacian Eigenmaps and Spectral Techniques for Embedding
and Clustering, Advances in Neural Information Processing Systems 14, 2001, p. 586â€“691,
MIT Press.
[13] S.Lafon, Diffusion Maps and Geometric Harmonics, PhD Thesis, Yale University, May
2004.
[14] D. Donoho and C. Grimes, â€Hessian eigenmaps: Locally linear embedding techniques
for high-dimensional dataâ€ Proc Natl Acad Sci U S A. 2003 May 13; 100(10): 5591â€“5596.
[15] Z. Zhang and J. Wang, â€MLLE: Modified Locally Linear Embedding Using Multiple
Weightsâ€ http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.382.
[16] â€Shale Oil and Natural Gas Nexusâ€ (SONGNEX) Campaign, https://esrl.noaa.gov/,
2015.
20

