University of Pennsylvania
ScholarlyCommons
Departmental Papers (CIS) Department of Computer & Information Science
6-28-2001
Conditional Random Fields: Probabilistic Models
for Segmenting and Labeling Sequence Data
John Lafferty
Carnegie Mellon University, lafferty@cs.cmu.edu
Andrew McCallum
WhizBang! Labs, mccallum@cs.umass.edu
Fernando C.N. Pereira
University of Pennsylvania, pereira@cis.upenn.edu
Follow this and additional works at: http://repository.upenn.edu/cis_papers
Part of the Numerical Analysis and Scientific Computing Commons
Postprint version. Copyright ACM, 2001. This is the author's version of the work. It is posted here by permission of ACM for your personal use. Not for
redistribution. The definitive version was published in Proceedings of the 18th International Conference on Machine Learning 2001 (ICML 2001), pages
282-289.
Publisher URL: http://portal.acm.org/citation.cfm?id=655813
This paper is posted at ScholarlyCommons. http://repository.upenn.edu/cis_papers/159
For more information, please contact libraryrepository@pobox.upenn.edu.
Recommended Citation
John Lafferty, Andrew McCallum, and Fernando C.N. Pereira, "Conditional Random Fields: Probabilistic Models for Segmenting and
Labeling Sequence Data", . June 2001.
Conditional Random Fields: Probabilistic Models for Segmenting and
Labeling Sequence Data
Abstract
We present conditional random fields, a framework for building probabilistic models to segment and label
sequence data. Conditional random fields offer several advantages over hidden Markov models and stochastic
grammars for such tasks, including the ability to relax strong independence assumptions made in those
models. Conditional random fields also avoid a fundamental limitation of maximum entropy Markov models
(MEMMs) and other discriminative Markov models based on directed graphical models, which can be biased
towards states with few successor states. We present iterative parameter estimation algorithms for conditional
random fields and compare the performance of the resulting models to HMMs and MEMMs on synthetic and
natural-language data.
Disciplines
Numerical Analysis and Scientific Computing
Comments
Postprint version. Copyright ACM, 2001. This is the author's version of the work. It is posted here by
permission of ACM for your personal use. Not for redistribution. The definitive version was published in
Proceedings of the 18th International Conference on Machine Learning 2001 (ICML 2001), pages 282-289.
Publisher URL: http://portal.acm.org/citation.cfm?id=655813
This conference paper is available at ScholarlyCommons: http://repository.upenn.edu/cis_papers/159
Conditional Random Fields: Probabilistic Models
for Segmenting and Labeling Sequence Data
John Lafferty†∗ LAFFERTY@CS.CMU.EDU
Andrew McCallum∗† MCCALLUM@WHIZBANG.COM
Fernando Pereira∗‡ FPEREIRA@WHIZBANG.COM
∗WhizBang! Labs–Research, 4616 Henry Street, Pittsburgh, PA 15213 USA
†School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213 USA
‡Department of Computer and Information Science, University of Pennsylvania, Philadelphia, PA 19104 USA
Abstract
We present conditional random fields , a frame-
work for building probabilistic models to seg-
ment and label sequence data. Conditional ran-
dom fields offer several advantages over hid-
den Markov models and stochastic grammars
for such tasks, including the ability to relax
strong independence assumptions made in those
models. Conditional random fields also avoid
a fundamental limitation of maximum entropy
Markov models (MEMMs) and other discrimi-
native Markov models based on directed graph-
ical models, which can be biased towards states
with few successor states. We present iterative
parameter estimation algorithms for conditional
random fields and compare the performance of
the resulting models to HMMs and MEMMs on
synthetic and natural-language data.
1. Introduction
The need to segment and label sequences arises in many
different problems in several scientific fields. Hidden
Markov models (HMMs) and stochastic grammars are well
understood and widely used probabilistic models for such
problems. In computational biology, HMMs and stochas-
tic grammars have been successfully used to align bio-
logical sequences, find sequences homologous to a known
evolutionary family, and analyze RNA secondary structure
(Durbin et al., 1998). In computational linguistics and
computer science, HMMs and stochastic grammars have
been applied to a wide variety of problems in text and
speech processing, including topic segmentation, part-of-
speech (POS) tagging, information extraction, and syntac-
tic disambiguation (Manning & Schütze, 1999).
HMMs and stochastic grammars are generative models, as-
signing a joint probability to paired observation and label
sequences; the parameters are typically trained to maxi-
mize the joint likelihood of training examples. To define
a joint probability over observation and label sequences,
a generative model needs to enumerate all possible ob-
servation sequences, typically requiring a representation
in which observations are task-appropriate atomic entities,
such as words or nucleotides. In particular, it is not practi-
cal to represent multiple interacting features or long-range
dependencies of the observations, since the inference prob-
lem for such models is intractable.
This difficulty is one of the main motivations for looking at
conditional models as an alternative. A conditional model
specifies the probabilities of possible label sequences given
an observation sequence. Therefore, it does not expend
modeling effort on the observations, which at test time
are fixed anyway. Furthermore, the conditional probabil-
ity of the label sequence can depend on arbitrary, non-
independent features of the observation sequence without
forcing the model to account for the distribution of those
dependencies. The chosen features may represent attributes
at different levels of granularity of the same observations
(for example, words and characters in English text), or
aggregate properties of the observation sequence (for in-
stance, text layout). The probability of a transition between
labels may depend not only on the current observation,
but also on past and future observations, if available. In
contrast, generative models must make very strict indepen-
dence assumptions on the observations, for instance condi-
tional independence given the labels, to achieve tractability.
Maximum entropy Markov models (MEMMs) are condi-
tional probabilistic sequence models that attain all of the
above advantages (McCallum et al., 2000). In MEMMs,
each source state1 has a exponential model that takes the
observation features as input, and outputs a distribution
over possible next states. These exponential models are
trained by an appropriate iterative scaling method in the
1Output labels are associated with states; it is possible for sev-
eral states to have the same label, but for simplicity in the rest of
this paper we assume a one-to-one correspondence.
maximum entropy framework. Previously published exper-
imental results show MEMMs increasing recall and dou-
bling precision relative to HMMs in a FAQ segmentation
task.
MEMMs and other non-generative finite-state models
based on next-state classifiers, such as discriminative
Markov models (Bottou, 1991), share a weakness we call
here the label bias problem: the transitions leaving a given
state compete only against each other, rather than against
all other transitions in the model. In probabilistic terms,
transition scores are the conditional probabilities of pos-
sible next states given the current state and the observa-
tion sequence. This per-state normalization of transition
scores implies a “conservation of score mass” (Bottou,
1991) whereby all the mass that arrives at a state must be
distributed among the possible successor states. An obser-
vation can affect which destination states get the mass, but
not how much total mass to pass on. This causes a bias to-
ward states with fewer outgoing transitions. In the extreme
case, a state with a single outgoing transition effectively
ignores the observation. In those cases, unlike in HMMs,
Viterbi decoding cannot downgrade a branch based on ob-
servations after the branch point, and models with state-
transition structures that have sparsely connected chains of
states are not properly handled. The Markovian assump-
tions in MEMMs and similar state-conditional models in-
sulate decisions at one state from future decisions in a way
that does not match the actual dependencies between con-
secutive states.
This paper introduces conditional random fields (CRFs), a
sequence modeling framework that has all the advantages
of MEMMs but also solves the label bias problem in a
principled way. The critical difference between CRFs and
MEMMs is that a MEMM uses per-state exponential mod-
els for the conditional probabilities of next states given the
current state, while a CRF has a single exponential model
for the joint probability of the entire sequence of labels
given the observation sequence. Therefore, the weights of
different features at different states can be traded off against
each other.
We can also think of a CRF as a finite state model with un-
normalized transition probabilities. However, unlike some
other weighted finite-state approaches (LeCun et al., 1998),
CRFs assign a well-defined probability distribution over
possible labelings, trained by maximum likelihood or MAP
estimation. Furthermore, the loss function is convex,2 guar-
anteeing convergence to the global optimum. CRFs also
generalize easily to analogues of stochastic context-free
grammars that would be useful in such problems as RNA
secondary structure prediction and natural language pro-
cessing.
2In the case of fully observable states, as we are discussing
here; if several states have the same label, the usual local maxima
of Baum-Welch arise.
0
1r:_
4
r:_
2
i:_
3
b:rib
5
o:_
b:rob
Figure 1. Label bias example, after (Bottou, 1991). For concise-
ness, we place observation-label pairs o : l on transitions rather
than states; the symbol ‘ ’ represents the null output label.
We present the model, describe two training procedures and
sketch a proof of convergence. We also give experimental
results on synthetic data showing that CRFs solve the clas-
sical version of the label bias problem, and, more signifi-
cantly, that CRFs perform better than HMMs and MEMMs
when the true data distribution has higher-order dependen-
cies than the model, as is often the case in practice. Finally,
we confirm these results as well as the claimed advantages
of conditional models by evaluating HMMs, MEMMs and
CRFs with identical state structure on a part-of-speech tag-
ging task.
2. The Label Bias Problem
Classical probabilistic automata (Paz, 1971), discrimina-
tive Markov models (Bottou, 1991), maximum entropy
taggers (Ratnaparkhi, 1996), and MEMMs, as well as
non-probabilistic sequence tagging and segmentation mod-
els with independently trained next-state classifiers (Pun-
yakanok & Roth, 2001) are all potential victims of the label
bias problem.
For example, Figure 1 represents a simple finite-state
model designed to distinguish between the two words rib
and rob. Suppose that the observation sequence is r i b.
In the first time step, r matches both transitions from the
start state, so the probability mass gets distributed roughly
equally among those two transitions. Next we observe i.
Both states 1 and 4 have only one outgoing transition. State
1 has seen this observation often in training, state 4 has al-
most never seen this observation; but like state 1, state 4
has no choice but to pass all its mass to its single outgoing
transition, since it is not generating the observation, only
conditioning on it. Thus, states with a single outgoing tran-
sition effectively ignore their observations. More generally,
states with low-entropy next state distributions will take lit-
tle notice of observations. Returning to the example, the
top path and the bottom path will be about equally likely,
independently of the observation sequence. If one of the
two words is slightly more common in the training set, the
transitions out of the start state will slightly prefer its cor-
responding transition, and that word’s state sequence will
always win. This behavior is demonstrated experimentally
in Section 5.
Léon Bottou (1991) discussed two solutions for the label
bias problem. One is to change the state-transition struc-
ture of the model. In the above example we could collapse
states 1 and 4, and delay the branching until we get a dis-
criminating observation. This operation is a special case
of determinization (Mohri, 1997), but determinization of
weighted finite-state machines is not always possible, and
even when possible, it may lead to combinatorial explo-
sion. The other solution mentioned is to start with a fully-
connected model and let the training procedure figure out
a good structure. But that would preclude the use of prior
structural knowledge that has proven so valuable in infor-
mation extraction tasks (Freitag & McCallum, 2000).
Proper solutions require models that account for whole
state sequences at once by letting some transitions “vote”
more strongly than others depending on the corresponding
observations. This implies that score mass will not be con-
served, but instead individual transitions can “amplify” or
“dampen” the mass they receive. In the above example, the
transitions from the start state would have a very weak ef-
fect on path score, while the transitions from states 1 and 4
would have much stronger effects, amplifying or damping
depending on the actual observation, and a proportionally
higher contribution to the selection of the Viterbi path.3
In the related work section we discuss other heuristic model
classes that account for state sequences globally rather than
locally. To the best of our knowledge, CRFs are the only
model class that does this in a purely probabilistic setting,
with guaranteed global maximum likelihood convergence.
3. Conditional Random Fields
In what follows, X is a random variable over data se-
quences to be labeled, and Y is a random variable over
corresponding label sequences. All components Yi of Y
are assumed to range over a finite label alphabet Y . For ex-
ample, X might range over natural language sentences and
Y range over part-of-speech taggings of those sentences,
with Y the set of possible part-of-speech tags. The ran-
dom variables X and Y are jointly distributed, but in a dis-
criminative framework we construct a conditional model
p(Y |X) from paired observation and label sequences, and
do not explicitly model the marginal p(X).
Definition. Let G = (V,E) be a graph such that
Y = (Yv)v∈V , so that Y is indexed by the vertices
of G. Then (X,Y) is a conditional random field in
case, when conditioned on X, the random variables Yv
obey the Markov property with respect to the graph:
p(Yv |X,Yw, w 6= v) = p(Yv |X,Yw, w ∼ v), where
w ∼ v means that w and v are neighbors in G.
Thus, a CRF is a random field globally conditioned on the
observation X. Throughout the paper we tacitly assume
that the graph G is fixed. In the simplest and most impor-
3Weighted determinization and minimization techniques shift
transition weights while preserving overall path weight (Mohri,
2000); their connection to this discussion deserves further study.
tant example for modeling sequences, G is a simple chain
or line: G = (V = {1, 2, . . . m}, E = {(i, i + 1)}).
X may also have a natural graph structure; yet in gen-
eral it is not necessary to assume that X and Y have the
same graphical structure, or even that X has any graph-
ical structure at all. However, in this paper we will be
most concerned with sequences X = (X1,X2, . . . ,Xn)
and Y = (Y1,Y2, . . . ,Yn).
If the graph G = (V,E) of Y is a tree (of which a chain
is the simplest example), its cliques are the edges and ver-
tices. Therefore, by the fundamental theorem of random
fields (Hammersley & Clifford, 1971), the joint distribu-
tion over the label sequence Y given X has the form
pθ(y |x) ∝ (1)
exp
 ∑
e∈E,k
λk fk(e,y|e,x) +
∑
v∈V,k
µk gk(v,y|v,x)
 ,
where x is a data sequence, y a label sequence, and y|S is
the set of components of y associated with the vertices in
subgraph S.
We assume that the features fk and gk are given and fixed.
For example, a Boolean vertex feature gk might be true if
the word Xi is upper case and the tag Yi is “proper noun.”
The parameter estimation problem is to determine the pa-
rameters θ = (λ1, λ2, . . . ;µ1, µ2, . . .) from training data
D = {(x(i),y(i))}Ni=1 with empirical distribution p̃(x,y).
In Section 4 we describe an iterative scaling algorithm that
maximizes the log-likelihood objective function O(θ):
O(θ) =
N∑
i=1
log pθ(y(i) |x(i))
∝
∑
x,y
p̃(x,y) log pθ(y |x) .
As a particular case, we can construct an HMM-like CRF
by defining one feature for each state pair (y′, y), and one
feature for each state-observation pair (y, x):
fy′,y (<u, v>,y|<u,v>,x) = δ(yu, y′) δ(yv, y)
gy,x (v,y|v,x) = δ(yv, y) δ(xv, x) .
The corresponding parameters λy′,y and µy,x play a simi-
lar role to the (logarithms of the) usual HMM parameters
p(y′ | y) and p(x|y). Boltzmann chain models (Saul & Jor-
dan, 1996; MacKay, 1996) have a similar form but use a
single normalization constant to yield a joint distribution,
whereas CRFs use the observation-dependent normaliza-
tion Z(x) for conditional distributions.
Although it encompasses HMM-like models, the class of
conditional random fields is much more expressive, be-
cause it allows arbitrary dependencies on the observation
Yi−1 Yi Yi+1
?s
s -
?s
s -
?s
s
Xi−1 Xi Xi+1
Yi−1 Yi Yi+1
c
6
s -
c
6
s -
c
6
s
Xi−1 Xi Xi+1
Yi−1 Yi Yi+1
c
s
c
s
c
s
Xi−1 Xi Xi+1
Figure 2. Graphical structures of simple HMMs (left), MEMMs (center), and the chain-structured case of CRFs (right) for sequences.
An open circle indicates that the variable is not generated by the model.
sequence. In addition, the features do not need to specify
completely a state or observation, so one might expect that
the model can be estimated from less training data. Another
attractive property is the convexity of the loss function; in-
deed, CRFs share all of the convexity properties of general
maximum entropy models.
For the remainder of the paper we assume that the depen-
dencies of Y, conditioned on X, form a chain. To sim-
plify some expressions, we add special start and stop states
Y0 = start and Yn+1 = stop. Thus, we will be using the
graphical structure shown in Figure 2. For a chain struc-
ture, the conditional probability of a label sequence can be
expressed concisely in matrix form, which will be useful
in describing the parameter estimation and inference al-
gorithms in Section 4. Suppose that pθ(Y |X) is a CRF
given by (1). For each position i in the observation se-
quence x, we define the |Y| × |Y| matrix random variable
Mi(x) = [Mi(y′, y |x)] by
Mi(y′, y |x) = exp (Λi(y′, y |x))
Λi(y′, y |x) =
∑
k λk fk(ei,Y|ei = (y′, y),x) +∑
k µk gk(vi,Y|vi = y,x) ,
where ei is the edge with labels (Yi−1,Yi) and vi is the
vertex with label Yi. In contrast to generative models, con-
ditional models like CRFs do not need to enumerate over
all possible observation sequences x, and therefore these
matrices can be computed directly as needed from a given
training or test observation sequence x and the parameter
vector θ. Then the normalization (partition function) Zθ(x)
is the (start, stop) entry of the product of these matrices:
Zθ(x) = (M1(x) M2(x) · · ·Mn+1(x))start,stop .
Using this notation, the conditional probability of a label
sequence y is written as
pθ(y |x) =
∏n+1
i=1 Mi(yi−1,yi |x)(∏n+1
i=1 Mi(x)
)
start,stop
,
where y0 = start and yn+1 = stop.
4. Parameter Estimation for CRFs
We now describe two iterative scaling algorithms to find
the parameter vector θ that maximizes the log-likelihood
of the training data. Both algorithms are based on the im-
proved iterative scaling (IIS) algorithm of Della Pietra et al.
(1997); the proof technique based on auxiliary functions
can be extended to show convergence of the algorithms for
CRFs.
Iterative scaling algorithms update the weights as λk ←
λk + δλk and µk ← µk + δµk for appropriately chosen
δλk and δµk. In particular, the IIS update δλk for an edge
feature fk is the solution of
Ẽ[fk]
def=
∑
x,y
p̃(x,y)
n+1∑
i=1
fk(ei,y|ei ,x)
=
∑
x,y
p̃(x) p(y |x)
n+1∑
i=1
fk(ei,y|ei ,x) e δλkT (x,y) .
where T (x,y) is the total feature count
T (x,y) def=
∑
i,k
fk(ei,y|ei ,x) +
∑
i,k
gk(vi,y|vi ,x) .
The equations for vertex feature updates δµk have similar
form.
However, efficiently computing the exponential sums on
the right-hand sides of these equations is problematic, be-
cause T (x,y) is a global property of (x,y), and dynamic
programming will sum over sequences with potentially
varying T . To deal with this, the first algorithm, Algorithm
S, uses a “slack feature.” The second, Algorithm T, keeps
track of partial T totals.
For Algorithm S, we define the slack feature by
s(x,y) def=
S −
∑
i
∑
k
fk(ei,y|ei ,x)−
∑
i
∑
k
gk(vi,y|vi ,x) ,
where S is a constant chosen so that s(x(i),y) ≥ 0 for all
y and all observation vectors x(i) in the training set, thus
making T (x,y) = S. Feature s is “global,” that is, it does
not correspond to any particular edge or vertex.
For each index i = 0, . . . , n+1 we now define the forward
vectors αi(x) with base case
α0(y |x) =
{
1 if y = start
0 otherwise
and recurrence
αi(x) = αi−1(x) Mi(x) .
Similarly, the backward vectors βi(x) are defined by
βn+1(y |x) =
{
1 if y = stop
0 otherwise
and
βi(x)> = Mi+1(x) βi+1(x) .
With these definitions, the update equations are
δλk =
1
S
log
Ẽfk
Efk
, δµk =
1
S
log
Ẽgk
Egk
,
where
Efk =
∑
x
p̃(x)
n+1∑
i=1
∑
y′,y
fk(ei,y|ei = (y′, y),x) ×
αi−1(y′ |x) Mi(y′, y |x) βi(y |x)
Zθ(x)
Egk =
∑
x
p̃(x)
n∑
i=1
∑
y
gk(vi,y|vi = y,x) ×
αi(y |x) βi(y |x)
Zθ(x)
.
The factors involving the forward and backward vectors in
the above equations have the same meaning as for standard
hidden Markov models. For example,
pθ(Yi = y |x) =
αi(y |x) βi(y |x)
Zθ(x)
is the marginal probability of label Yi = y given that the
observation sequence is x. This algorithm is closely related
to the algorithm of Darroch and Ratcliff (1972), and MART
algorithms used in image reconstruction.
The constant S in Algorithm S can be quite large, since in
practice it is proportional to the length of the longest train-
ing observation sequence. As a result, the algorithm may
converge slowly, taking very small steps toward the maxi-
mum in each iteration. If the length of the observations x(i)
and the number of active features varies greatly, a faster-
converging algorithm can be obtained by keeping track of
feature totals for each observation sequence separately.
Let T (x) def= maxy T (x,y). Algorithm T accumulates
feature expectations into counters indexed by T (x). More
specifically, we use the forward-backward recurrences just
introduced to compute the expectations ak,t of feature fk
and bk,t of feature gk given that T (x) = t. Then our param-
eter updates are δλk = log βk and δµk = log γk, where
βk and γk are the unique positive roots to the following
polynomial equations
Tmax∑
i=0
ak,t β
t
k = Ẽfk ,
Tmax∑
i=0
bk,t γ
t
k = Ẽgk , (2)
which can be easily computed by Newton’s method.
A single iteration of Algorithm S and Algorithm T has
roughly the same time and space complexity as the well
known Baum-Welch algorithm for HMMs. To prove con-
vergence of our algorithms, we can derive an auxiliary
function to bound the change in likelihood from below; this
method is developed in detail by Della Pietra et al. (1997).
The full proof is somewhat detailed; however, here we give
an idea of how to derive the auxiliary function. To simplify
notation, we assume only edge features fk with parameters
λk.
Given two parameter settings θ = (λ1, λ2, . . .) and θ′ =
(λ1+δλ1, λ2+δλ2, . . .), we bound from below the change
in the objective function with an auxiliary functionA(θ′, θ)
as follows
O(θ′)−O(θ) =
∑
x,y
p̃(x,y) log
pθ′(y |x)
pθ(y |x)
= (θ′ − θ) · Ẽf −
∑
x
p̃(x) log
Zθ′(x)
Zθ(x)
≥ (θ′ − θ) · Ẽf −
∑
x
p̃(x)
Zθ′(x)
Zθ(x)
= δλ · Ẽf −
∑
x
p̃(x)
∑
y
pθ(y |x) eδλ·f(x,y)
≥ δλ · Ẽf −
∑
x,y,k
p̃(x) pθ(y |x)
fk(x,y)
T (x)
eδλkT (x)
def= A(θ′, θ)
where the inequalities follow from the convexity of − log
and exp. Differentiating A with respect to δλk and setting
the result to zero yields equation (2).
5. Experiments
We first discuss two sets of experiments with synthetic data
that highlight the differences between CRFs and MEMMs.
The first experiments are a direct verification of the label
bias problem discussed in Section 2. In the second set of
experiments, we generate synthetic data using randomly
chosen hidden Markov models, each of which is a mix-
ture of a first-order and second-order model. Competing
first-order models are then trained and compared on test
data. As the data becomes more second-order, the test er-
ror rates of the trained models increase. This experiment
corresponds to the common modeling practice of approxi-
mating complex local and long-range dependencies, as oc-
cur in natural data, by small-order Markov models. Our
0
10
20
30
40
50
60
0 10 20 30 40 50 60
M
E
M
M
 E
rr
or
CRF Error
0
10
20
30
40
50
60
0 10 20 30 40 50 60
M
E
M
M
 E
rr
or
HMM Error
0
10
20
30
40
50
60
0 10 20 30 40 50 60
C
R
F
 E
rr
or
HMM Error
Figure 3. Plots of 2×2 error rates for HMMs, CRFs, and MEMMs on randomly generated synthetic data sets, as described in Section 5.2.
As the data becomes “more second order,” the error rates of the test models increase. As shown in the left plot, the CRF typically
significantly outperforms the MEMM. The center plot shows that the HMM outperforms the MEMM. In the right plot, each open square
represents a data set with α < 1
2
, and a solid circle indicates a data set with α ≥ 1
2
. The plot shows that when the data is mostly second
order (α ≥ 1
2
), the discriminatively trained CRF typically outperforms the HMM. These experiments are not designed to demonstrate
the advantages of the additional representational power of CRFs and MEMMs relative to HMMs.
results clearly indicate that even when the models are pa-
rameterized in exactly the same way, CRFs are more ro-
bust to inaccurate modeling assumptions than MEMMs or
HMMs, and resolve the label bias problem, which affects
the performance of MEMMs. To avoid confusion of dif-
ferent effects, the MEMMs and CRFs in these experiments
do not use overlapping features of the observations. Fi-
nally, in a set of POS tagging experiments, we confirm the
advantage of CRFs over MEMMs. We also show that the
addition of overlapping features to CRFs and MEMMs al-
lows them to perform much better than HMMs, as already
shown for MEMMs by McCallum et al. (2000).
5.1 Modeling label bias
We generate data from a simple HMM which encodes a
noisy version of the finite-state network in Figure 1. Each
state emits its designated symbol with probability 29/32
and any of the other symbols with probability 1/32. We
train both an MEMM and a CRF with the same topologies
on the data generated by the HMM. The observation fea-
tures are simply the identity of the observation symbols.
In a typical run using 2, 000 training and 500 test samples,
trained to convergence of the iterative scaling algorithm,
the CRF error is 4.6% while the MEMM error is 42%,
showing that the MEMM fails to discriminate between the
two branches.
5.2 Modeling mixed-order sources
For these results, we use five labels, a-e (|Y| = 5), and 26
observation values, A-Z (|X | = 26); however, the results
were qualitatively the same over a range of sizes for Y and
X . We generate data from a mixed-order HMM with state
transition probabilities given by pα(yi |yi−1,yi−2) =
α p2(yi |yi−1,yi−2) + (1 − α) p1(yi |yi−1) and, simi-
larly, emission probabilities given by pα(xi |yi,xi−1) =
α p2(xi |yi,xi−1)+(1−α) p1(xi |yi). Thus, for α = 0 we
have a standard first-order HMM. In order to limit the size
of the Bayes error rate for the resulting models, the con-
ditional probability tables pα are constrained to be sparse.
In particular, pα(· | y, y′) can have at most two nonzero en-
tries, for each y, y′, and pα(· | y, x′) can have at most three
nonzero entries for each y, x′. For each randomly gener-
ated model, a sample of 1,000 sequences of length 25 is
generated for training and testing.
On each randomly generated training set, a CRF is trained
using Algorithm S. (Note that since the length of the se-
quences and number of active features is constant, Algo-
rithms S and T are identical.) The algorithm is fairly slow
to converge, typically taking approximately 500 iterations
for the model to stabilize. On the 500 MHz Pentium PC
used in our experiments, each iteration takes approximately
0.2 seconds. On the same data an MEMM is trained using
iterative scaling, which does not require forward-backward
calculations, and is thus more efficient. The MEMM train-
ing converges more quickly, stabilizing after approximately
100 iterations. For each model, the Viterbi algorithm is
used to label a test set; the experimental results do not sig-
nificantly change when using forward-backward decoding
to minimize the per-symbol error rate.
The results of several runs are presented in Figure 3. Each
plot compares two classes of models, with each point indi-
cating the error rate for a single test set. As α increases, the
error rates generally increase, as the first-order models fail
to fit the second-order data. The figure compares models
parameterized as µy , λy′,y , and λy′,y,x; results for models
parameterized as µy , λy′,y , and µy,x are qualitatively the
same. As shown in the first graph, the CRF generally out-
performs the MEMM, often by a wide margin of 10%–20%
relative error. (The points for very small error rate, with
α < 0.01, where the MEMM does better than the CRF,
are suspected to be the result of an insufficient number of
training iterations for the CRF.)
model error oov error
HMM 5.69% 45.99%
MEMM 6.37% 54.61%
CRF 5.55% 48.05%
MEMM+ 4.81% 26.99%
CRF+ 4.27% 23.76%
+Using spelling features
Figure 4. Per-word error rates for POS tagging on the Penn tree-
bank, using first-order models trained on 50% of the 1.1 million
word corpus. The oov rate is 5.45%.
5.3 POS tagging experiments
To confirm our synthetic data results, we also compared
HMMs, MEMMs and CRFs on Penn treebank POS tag-
ging, where each word in a given input sentence must be
labeled with one of 45 syntactic tags.
We carried out two sets of experiments with this natural
language data. First, we trained first-order HMM, MEMM,
and CRF models as in the synthetic data experiments, in-
troducing parameters µy,x for each tag-word pair and λy′,y
for each tag-tag pair in the training set. The results are con-
sistent with what is observed on synthetic data: the HMM
outperforms the MEMM, as a consequence of the label bias
problem, while the CRF outperforms the HMM. The er-
ror rates for training runs using a 50%-50% train-test split
are shown in Figure 5.3; the results are qualitatively sim-
ilar for other splits of the data. The error rates on out-
of-vocabulary (oov) words, which are not observed in the
training set, are reported separately.
In the second set of experiments, we take advantage of the
power of conditional models by adding a small set of or-
thographic features: whether a spelling begins with a num-
ber or upper case letter, whether it contains a hyphen, and
whether it ends in one of the following suffixes: -ing, -
ogy, -ed, -s, -ly, -ion, -tion, -ity, -ies. Here we find, as
expected, that both the MEMM and the CRF benefit signif-
icantly from the use of these features, with the overall error
rate reduced by around 25%, and the out-of-vocabulary er-
ror rate reduced by around 50%.
One usually starts training from the all zero parameter vec-
tor, corresponding to the uniform distribution. However,
for these datasets, CRF training with that initialization is
much slower than MEMM training. Fortunately, we can
use the optimal MEMM parameter vector as a starting
point for training the corresponding CRF. In Figure 5.3,
MEMM+ was trained to convergence in around 100 iter-
ations. Its parameters were then used to initialize the train-
ing of CRF+, which converged in 1,000 iterations. In con-
trast, training of the same CRF from the uniform distribu-
tion had not converged even after 2,000 iterations.
6. Further Aspects of CRFs
Many further aspects of CRFs are attractive for applica-
tions and deserve further study. In this section we briefly
mention just two.
Conditional random fields can be trained using the expo-
nential loss objective function used by the AdaBoost algo-
rithm (Freund & Schapire, 1997). Typically, boosting is
applied to classification problems with a small, fixed num-
ber of classes; applications of boosting to sequence labeling
have treated each label as a separate classification problem
(Abney et al., 1999). However, it is possible to apply the
parallel update algorithm of Collins et al. (2000) to op-
timize the per-sequence exponential loss. This requires a
forward-backward algorithm to compute efficiently certain
feature expectations, along the lines of Algorithm T, ex-
cept that each feature requires a separate set of forward and
backward accumulators.
Another attractive aspect of CRFs is that one can imple-
ment efficient feature selection and feature induction al-
gorithms for them. That is, rather than specifying in ad-
vance which features of (X,Y) to use, we could start from
feature-generating rules and evaluate the benefit of gener-
ated features automatically on data. In particular, the fea-
ture induction algorithms presented in Della Pietra et al.
(1997) can be adapted to fit the dynamic programming
techniques of conditional random fields.
7. Related Work and Conclusions
As far as we know, the present work is the first to combine
the benefits of conditional models with the global normal-
ization of random field models. Other applications of expo-
nential models in sequence modeling have either attempted
to build generative models (Rosenfeld, 1997), which in-
volve a hard normalization problem, or adopted local con-
ditional models (Berger et al., 1996; Ratnaparkhi, 1996;
McCallum et al., 2000) that may suffer from label bias.
Non-probabilistic local decision models have also been
widely used in segmentation and tagging (Brill, 1995;
Roth, 1998; Abney et al., 1999). Because of the computa-
tional complexity of global training, these models are only
trained to minimize the error of individual label decisions
assuming that neighboring labels are correctly chosen. La-
bel bias would be expected to be a problem here too.
An alternative approach to discriminative modeling of se-
quence labeling is to use a permissive generative model,
which can only model local dependencies, to produce a
list of candidates, and then use a more global discrimina-
tive model to rerank those candidates. This approach is
standard in large-vocabulary speech recognition (Schwartz
& Austin, 1993), and has also been proposed for parsing
(Collins, 2000). However, these methods fail when the cor-
rect output is pruned away in the first pass.
Closest to our proposal are gradient-descent methods that
adjust the parameters of all of the local classifiers to mini-
mize a smooth loss function (e.g., quadratic loss) combin-
ing loss terms for each label. If state dependencies are lo-
cal, this can be done efficiently with dynamic programming
(LeCun et al., 1998). Such methods should alleviate label
bias. However, their loss function is not convex, so they
may get stuck in local minima.
Conditional random fields offer a unique combination of
properties: discriminatively trained models for sequence
segmentation and labeling; combination of arbitrary, over-
lapping and agglomerative observation features from both
the past and future; efficient training and decoding based
on dynamic programming; and parameter estimation guar-
anteed to find the global optimum. Their main current lim-
itation is the slow convergence of the training algorithm
relative to MEMMs, let alone to HMMs, for which training
on fully observed data is very efficient. In future work, we
plan to investigate alternative training methods such as the
update methods of Collins et al. (2000) and refinements on
using a MEMM as starting point as we did in some of our
experiments. More general tree-structured random fields,
feature induction methods, and further natural data evalua-
tions will also be investigated.
Acknowledgments
We thank Yoshua Bengio, Léon Bottou, Michael Collins
and Yann LeCun for alerting us to what we call here the la-
bel bias problem. We also thank Andrew Ng and Sebastian
Thrun for discussions related to this work.
References
Abney, S., Schapire, R. E., & Singer, Y. (1999). Boosting
applied to tagging and PP attachment. Proc. EMNLP-
VLC. New Brunswick, New Jersey: Association for
Computational Linguistics.
Berger, A. L., Della Pietra, S. A., & Della Pietra, V. J.
(1996). A maximum entropy approach to natural lan-
guage processing. Computational Linguistics, 22.
Bottou, L. (1991). Une approche théorique de
l’apprentissage connexionniste: Applications à la recon-
naissance de la parole. Doctoral dissertation, Université
de Paris XI.
Brill, E. (1995). Transformation-based error-driven learn-
ing and natural language processing: a case study in part
of speech tagging. Computational Linguistics, 21, 543–
565.
Collins, M. (2000). Discriminative reranking for natural
language parsing. Proc. ICML 2000. Stanford, Califor-
nia.
Collins, M., Schapire, R., & Singer, Y. (2000). Logistic re-
gression, AdaBoost, and Bregman distances. Proc. 13th
COLT.
Darroch, J. N., & Ratcliff, D. (1972). Generalized iterative
scaling for log-linear models. The Annals of Mathemat-
ical Statistics, 43, 1470–1480.
Della Pietra, S., Della Pietra, V., & Lafferty, J. (1997). In-
ducing features of random fields. IEEE Transactions on
Pattern Analysis and Machine Intelligence, 19, 380–393.
Durbin, R., Eddy, S., Krogh, A., & Mitchison, G. (1998).
Biological sequence analysis: Probabilistic models of
proteins and nucleic acids. Cambridge University Press.
Freitag, D., & McCallum, A. (2000). Information extrac-
tion with HMM structures learned by stochastic opti-
mization. Proc. AAAI 2000.
Freund, Y., & Schapire, R. (1997). A decision-theoretic
generalization of on-line learning and an application to
boosting. Journal of Computer and System Sciences, 55,
119–139.
Hammersley, J., & Clifford, P. (1971). Markov fields on
finite graphs and lattices. Unpublished manuscript.
LeCun, Y., Bottou, L., Bengio, Y., & Haffner, P. (1998).
Gradient-based learning applied to document recogni-
tion. Proceedings of the IEEE, 86, 2278–2324.
MacKay, D. J. (1996). Equivalence of linear Boltzmann
chains and hidden Markov models. Neural Computation,
8, 178–181.
Manning, C. D., & Schütze, H. (1999). Foundations of sta-
tistical natural language processing. Cambridge Mas-
sachusetts: MIT Press.
McCallum, A., Freitag, D., & Pereira, F. (2000). Maximum
entropy Markov models for information extraction and
segmentation. Proc. ICML 2000 (pp. 591–598). Stan-
ford, California.
Mohri, M. (1997). Finite-state transducers in language and
speech processing. Computational Linguistics, 23.
Mohri, M. (2000). Minimization algorithms for sequential
transducers. Theoretical Computer Science, 234, 177–
201.
Paz, A. (1971). Introduction to probabilistic automata.
Academic Press.
Punyakanok, V., & Roth, D. (2001). The use of classifiers
in sequential inference. NIPS 13. Forthcoming.
Ratnaparkhi, A. (1996). A maximum entropy model for
part-of-speech tagging. Proc. EMNLP. New Brunswick,
New Jersey: Association for Computational Linguistics.
Rosenfeld, R. (1997). A whole sentence maximum entropy
language model. Proceedings of the IEEE Workshop on
Speech Recognition and Understanding. Santa Barbara,
California.
Roth, D. (1998). Learning to resolve natural language am-
biguities: A unified approach. Proc. 15th AAAI (pp. 806–
813). Menlo Park, California: AAAI Press.
Saul, L., & Jordan, M. (1996). Boltzmann chains and hid-
den Markov models. Advances in Neural Information
Processing Systems 7. MIT Press.
Schwartz, R., & Austin, S. (1993). A comparison of several
approximate algorithms for finding multiple (N-BEST)
sentence hypotheses. Proc. ICASSP. Minneapolis, MN.

