Optimization Methods for Supervised Machine Learning:
From Linear Models to Deep Learning
Frank E. Curtis∗ Katya Scheinberg†
July 3, 2017
Abstract
The goal of this tutorial is to introduce key models, algorithms, and open questions related
to the use of optimization methods for solving problems arising in machine learning. It is
written with an INFORMS audience in mind, specifically those readers who are familiar with
the basics of optimization algorithms, but less familiar with machine learning. We begin by
deriving a formulation of a supervised learning problem and show how it leads to various op-
timization problems, depending on the context and underlying assumptions. We then discuss
some of the distinctive features of these optimization problems, focusing on the examples of
logistic regression and the training of deep neural networks. The latter half of the tutorial
focuses on optimization algorithms, first for convex logistic regression, for which we discuss
the use of first-order methods, the stochastic gradient method, variance reducing stochastic
methods, and second-order methods. Finally, we discuss how these approaches can be em-
ployed to the training of deep neural networks, emphasizing the difficulties that arise from the
complex, nonconvex structure of these models.
1 Introduction
The past two decades have witnessed the almost unprecedented rise of an intriguing algorith-
mic field: machine learning (ML). With roots in statistics and computer science, ML has a
mathematical optimization engine at its core. In fact, these days, ML and other data-driven
disciplines have influenced much of the latest theoretical and practical advances in the opti-
mization research community. Still, despite these connections, many barriers remain between
the statistics, computer science, and optimization communities working on ML and related
topics. These barriers—of differing terminology, goals, and avenues for collaboration—have
led to duplications of efforts and continue to inhibit effective exchanges of ideas.
The aim of this tutorial is to present an overview of some of the key issues and research
questions that relate to optimization within the field of ML. With the Operations Research
(OR) community in mind, we assume that the reader is familiar with basic optimization
methodologies, but will introduce terminology and concepts used in the broader ML community
in a manner that we hope will facilitate communication between OR experts and those from
other contributing fields. To aid in this pursuit, we provide in Table 1 a small glossary of the
most important terms that will be introduced and used throughout this tutorial.
∗Lehigh University, Department of ISE, frank.e.curtis@lehigh.edu
†Lehigh University, Department of ISE, katyas@lehigh.edu
1
ar
X
iv
:1
70
6.
10
20
7v
1 
 [
st
at
.M
L
] 
 3
0 
Ju
n 
20
17
Table 1: Glossary of terms in supervised machine learning where one aims to understand a rela-
tionship between each input x from a space X and its corresponding output y in a space Y .
Term Notation Definition a.k.a.
input x element from input space X feature (vector)
output y element from output space Y label (vector)
sample set {(xi, yi)}ni=1 pairs from input × output space
testing set other set of pairs from input × output space
prediction function p function such that p(x) predicts y predictor,
classifier
parameter vector w parameterization vector for prediction function, weights
i.e., p ≡ p(w, ·) with w in a space W
loss function ` function for assigning penalty when p(x)
does not predict the correct label for x
training/testing loss average loss evaluated over sample/testing set
training/testing error percentage of mislabeled elements
in the sample/testing set
stepsize sequence {αk} multipliers for steps in optimization algorithm learning rate
1.1 Motivating illustration
The idea of machine learning arises with the fundamental question of whether machines (i.e.,
computers) can “think” like humans. At a more tangible level, this leads to questions such
as whether, given a particular input, a machine can produce a reasonable/rational output
response, e.g., for the purpose of making a prediction or decision. Let us begin with a simple
illustration of how this might be done before introducing the idea of a learning problem more
formally in the next subsection.
Suppose that a company aims to predict whether Product A is going to be profitable (yes
or no) in an upcoming quarter. A human expert might attempt to make such a prediction by
considering various factors that can be found in historical data, say about Product A, related
products, and/or other factors. For simplicity of illustration, suppose that one considers two
factors, also known as features: the demand for Product A and another factor, call it Factor X,
both projected for the upcoming quarter. Certainly, one might expect that projected high
demand might suggest high potential profitability in the upcoming quarter, but compounded
with the influence of Factor X the outcome might be less obvious. For example, Factor X may
reflect the cost of production or delivery of Product A, which might depend on the costs of raw
materials or the set-up (take-down) costs of ramping up (reducing) production levels compared
to previous quarters. Overall, the influence of Factor X could be complex and nonlinear.
Looking at historical data over multiple consecutive quarters, suppose that the data points
in Figure 1 show the pairs of demand for Product A and value of Factor X that have been
observed. The points in green indicate pairs corresponding to quarters in which Product A was
profitable while those in red indicate unprofitable quarters. Using this data, one might aim to
learn how to take the inputs of projected demand and Factor X and predict whether or not
the product will be profitable. For example, this could be achieved by learning a dividing line
or a dividing curve between green and red dots, as illustrated in the center and rightmost plots
in Figure 1, respectively. The idea is that, if a good prediction tool (i.e., dividing line/curve) is
determined, then one could take a new pair of inputs and accurately predict whether Product A
will be profitable in the upcoming quarter (in this example, by determining which side of the
dividing line lies the new pair of inputs).
Of course, our illustration in Figure 1 presents an idealized case in which dividing lines
exist between data points corresponding to differing labels. The situation is not always so
clean. We address this and other issues next in our more general discussion of learning.
2
demand for Product A
F
ac
to
r
X
demand for Product A
F
ac
to
r
X
demand for Product A
F
ac
to
r
X
Figure 1: On the left, pairs of historical data of predicted demand of Product A and Factor X,
where green indicates a resulting profitable quarter and red indicates an unprofitable one. In the
center and right, the data points separated by a linear or nonlinear classifier, respectively.
1.2 Learning problems and (surrogate) optimization problems
Let us now define a generic learning problem more formally. In particular, let us consider the
problem of trying to determine an effective procedure for taking an input (i.e., feature vector) x
from an input space X ⊆ Rdx and predicting what is its correct output (i.e., label vector) y
in an output space Y ⊆ Rdy . This can be cast as trying to learn a prediction function, call
it p : X → Y, that takes an input x and produces p(x) that one hopes can identify y. Not
knowing what might be future inputs of interest, one tries to determine p such that, over the
distribution P : X × Y → R of pairs in the input × output space (X ,Y), one maximizes the
probability of a correct prediction; i.e., the goal is to choose p to maximize∫
X×Y
1[p(x) ≈ y]dP (x, y). (1)
Here, 1 is the indicator function that takes the value 1 if its argument is true and 0 otherwise.
As for the notation “≈”, it could literally mean that the two vectors are equal (or close in
some sense), that one is less than or equal to the other by some measure, or some other related
meaning. We discuss various such possibilities later on.
Clearly, for any given application, there is not necessarily one correct manner in which
the specifics of the function p in (1) should be chosen. In addition, in its present form, it is
far from tractable to maximize (1) directly. In the remainder of this section, we discuss how,
with various approximations and manipulations, one can go from the generic learning goal of
maximizing (1) to a practical optimization problem that one can reasonably solve.
The first issue that one must address when aiming to maximize (1) is what class of pre-
diction functions to consider. If the class is too large and/or involves a diverse collection of
complex functions, then finding that which maximizes (1) can be extremely difficult. On the
other hand, if the class is too small or only involves simple functions, then even the optimal
p within the class might yield poor predictions for various inputs. (Recall the choice between
trying to separate points based on a line or a more general type of curve in §1.1.) Overall, there
is a critical balance that one should attempt to find when determining the class of prediction
functions; see §1.3 and [11] for further discussion.
For our purposes, let us assume that some family of prediction functions is chosen that is
parameterized by a real vector w ∈ W = Rdw , i.e., p ≡ p(w, ·). For example, in a simple, yet
very common setting, one considers the class of linear predictors where p(w, x) = w0 + w
T
1 x
with w0 ∈ R and w1 ∈ Rdx , making the entire space of parameters W = Rdx+1. Another
example is the class of quadratic functions in x, where p(w, x) = w0 + w
T
1 x + w
T
2 svec(xx
T )
with w0 ∈ R, w1 ∈ Rdx , and w2 ∈ Rdx(dx+1)/2 while svec(xxT ) denotes the dx(dx + 1)/2-
3
dimensional symmetric vectorization of the matrix xxT ,1 thus making W = R(dx+1)(dx+2)/2.
While this function is nonlinear in x—and hence can fit complex relationships between x and
y—it is linear in the parameters w = (w0, w1, w2). Hence, this class can actually be viewed as
a class of linear predictors for the modified feature space X ′, where for each x ∈ X one has
x′ = (x, svec(xxT )) in X ′. It turns out that many, but not all, classes of prediction functions
can be viewed as linear predictors in some modified space. A notable exception of interest
arises in the use of deep neural networks; see §3.
Our learning problem can now be cast as trying to determine the parameters solving
max
w∈W
∫
X×Y
1[p(w, x) ≈ y]dP (x, y). (2)
As a next step toward tractability, let us now discuss possible meanings for the expression
p(w, x) ≈ y. Typically, the meaning depends on the type of labels involved. For example:
• In binary classification (“yes/no” labeling) with y ∈ {+1,−1}, the expression p(w, x) ≈ y
can represent yp(w, x) > 0. In this manner, we say that the predicted value p(w, x)
identifies the correct output y as long as the two values have the same sign.
• In regression with y ∈ Y ⊆ Rdy , the expression p(w, x) ≈ y might represent the fact that
‖y − p(w, x)‖ ≤ δ, where δ > 0 is some prescribed accuracy threshold.
• In multi-class classification with y ∈ {0, 1}dy such that
∑dy
i=1 yi = 1, the expression
p(w, x) ≈ y might represent that j(w, x) := arg maxj∈{1,...,dy} pj(w, x) is the index such
that yj(w,x) = 1. In this manner, one can view the jth element of p(w, x)/‖p(w, x)‖1
as some predicted probability that the true label of x is yj , and the label that will be
predicted is the one with the largest predicted probability.
Let us continue our development toward a tractable problem by taking binary classification
as a particular example. If we use yp(w, x) > 0 to represent p(w, x) ≈ y, then (2) becomes
max
w∈W
∫
X×Y
1[yp(w, x) > 0]dP (x, y). (3)
This objective is very easy to interpret; it is the probability that the value p(w, x) correctly
predicts the sign of y. The problem can be rewritten as
min
w∈W
f(w), where f(w) :=
∫
X×Y
1[yp(w, x) ≤ 0]dP (x, y). (4)
The indicator 1[yp(w, x) ≤ 0] is known as the 01-loss function. It counts a unit loss if p(w, x)
incorrectly predicts the sign of y, and no loss otherwise. This makes sense to do, but there are
some drawbacks to using this loss function. For one thing, it is discontinuous, making the goal
of optimizing over w potentially difficult. In addition, and perhaps more importantly, this loss
function does not quantify the magnitude of the error; e.g., for a given w, small perturbations
in the data can cause large perturbations in f(w), even though other (large) perturbations
might not affect f(w) at all. This can lead to instability. To overcome these issues, one can
replace the 01-loss by a similar, yet continuous (and perhaps smooth) surrogate loss function.
One way in which this can be done is through the idea of logistic regression, which can be
described as follows. First, imagine that the label is not deterministic. Instead, given an input
x, let Y represent the random variable corresponding to the correct label for x. The goal is to
choose a parameter vector w such that
yp(w, x) > 0 ⇐⇒ P(Y = y|x) > 12
while yp(w, x) < 0 ⇐⇒ P(Y = y|x) < 12 .
(5)
1The symmetric vectorization of xxT produces a vector whose elements correspond to the upper triangle of the
outer product xxT , namely terms of the form [xa]
2 and [xa][xb].
4
Since yp(w, x) ∈ R while P(Y = y|x) ∈ [0, 1], in order to make such a connection, we can
create a relationship between these quantities by equating
ln
(
P(Y = y|x)
1− P(Y = y|x)
)
= yp(w, x).
(The left-hand side of this equation is known as the logit of P(Y = y|x).) This implies, after
some simple algebraic manipulations, that
P(Y = y|x) = e
yp(w,x)
1 + eyp(w,x)
=
1
1 + e−yp(w,x)
, (6)
from which one can verify that the relationships in (5) hold. Following this idea, one finds
that a reasonable surrogate for problem (4) is
min
w∈W
f(w), where f(w) :=
∫
X×Y
`(p(w, x), y)dP (x, y) = E[`(p(w, x), y)], (7)
where (by taking the negative logarithm of (6)) we use the logistic loss function
`(p(w, x), y) = log(1 + e−yp(w,x)).
When p(w, x) = w0 + w
T
1 x, this loss function is convex, and is, in fact, one of the most
common loss functions used in learning to train linear predictors. Other convex loss functions
that are commonly used are the hinge loss for classification, namely, `(p(w, x), y) = max{0, 1−
yp(w, x)}, and the least square loss for regression, namely, `(p(w, x), y) = ‖p(w, x) − y‖2. In
the case of linear predictors, these two loss functions typically give rise to convex quadratic
optimization problems that may be very large-scale for which specific optimization algorithms
have been designed. (In this tutorial, we do not discuss such methods in detail since they are
too specialized for our general setting.)
Problem (7) can be approached using stochastic optimization methods, such as stochastic
approximation [78, 59] and sample average approximation [72, 64]. For guarantees in terms of
solving (7), the theory for such methods necessarily assumes that one can sample from (X ,Y)
indefinitely according to the distribution P . However, in many settings in machine learning,
this is not possible, so the last issue that we must confront is the fact that the objective of (7)
and its derivatives cannot be computed since P is unknown. Instead, a surrogate problem
can be considered. For example, in supervised learning, one assumes that there exists a set of
input × output pairs (known as samples or examples) {(xi, yi)}ni=1 ⊂ (X ,Y) that is available
a priori. With this set, one can approximately solve (7) by solving a related deterministic
optimization problem defined over this set of samples, i.e.,
min
w∈W
f̂(w), where f̂(w) :=
1
n
n∑
i=1
`(p(w, xi), yi). (8)
Going forward, we will be interested in both problems (7) and (8). We consider the latter
to be the problem that one can attempt to solve in practice, though we will also be interested
in how solutions obtained from solving (8) relate to optimal solutions of (7). We refer to f as
the expected risk (loss) function and refer to f̂ as the empirical risk (loss) function.
1.3 Learning bounds, overfitting, and regularization
Let us now discuss relationships between problems (7) and (8) and their optimal solutions. To
start, suppose that these problems are convex, as is the case when ` is the logistic loss. Let
5
w∗ and ŵ, respectively, denote the expected and empirical risk minimizers. Given that one
aims for ŵ minimizing f̂ in hopes of approximating w∗ minimizing f , a variety of important
questions arise about the potential differences between ŵ and w∗, or between the optimal
values of (7) and (8). For example, one might be interested in a bound for
|f̂(ŵ)− f(w∗)| ≤ |f̂(ŵ)− f(ŵ)|+ |f(ŵ)− f(w∗)|. (9)
Bounding the first term on the right-hand side relates to asking: While ŵ is designed to
behave well on the sample set, can we be sure that it behaves well in expectation? Bounding
the second term relates to asking whether we can be sure that the expected loss corresponding
to ŵ is not far from the expected loss of the optimal vector with respect to f .
Different bounds can be derived for these quantities in various problem-specific cases. Here,
let us state a generic bound, which says that, with probability at least 1− δ, (see for example,
[85])
|f̂(w)− f(w)| ≤ O
√C + log(1δ )
n
 for w ∈ W, (10)
where C is a scalar representing the complexity of the class of the prediction functions, i.e.,
p(w, ·) with w ∈ W. A similar bound can be derived on the second term in (9). From (10),
a few intuitive notions are confirmed. First, the discrepancy appears inversely proportional
to n, meaning that more data leads the empirical risk to better approximate expected risk.
Second, the discrepancy depends on the complexity of the prediction functions.
It is beyond the scope of this tutorial to show how one might derive C in general. Instead,
for the sake of intuition, let us briefly introduce one such measure for binary classification: the
Vapnik-Chervonenkis (VC) dimension. Briefly, the VC-dimension C of a class of predictors
p(w, ·) with w ∈ W is the largest number for which there exists a set of points {x1, x2, . . . , xC}
such that for any label set {y1, y2, . . . , yC}, there exists a predictor p(w, x) that predicts all
labels without error, i.e., yip(w, xi) > 0 for all i ∈ {1, . . . , C}. For example, for the class of
linear predictors of the form p(w, x) = w0 + w
T
1 x with (w0, w1) ∈ Rm+1, the VC-dimension is
m+ 1. To see this, in Figure 2 we illustrate a set of 3 points in R2 and a linear predictor for
each labeling of these points, where in each case one finds a predictor that predicts all labels
without error. On the other hand, it is easy to show that for some set of 4 distinct points
in R2, there exists at least one labeling of the points which cannot be perfectly classified by a
linear function. Hence, the VC-dimension of linear predictors in R2 is 3.
For linear predictors, the VC-dimension is equal to the number of parameters that define
the prediction function. However, this is not true for all predictor classes. In such cases,
instead of using a precise measure of complexity in (10), a bound can be used. For example,
if the input space X is bounded by an `2-norm ball of radius Rx and the class of predictors
p(w, x) is such that w is constrained in a ball of radius Rw, then, with smoothness of a loss
function `(·, ·), a bound on C can be derived in terms of O(R2xR2w). For more information on
complexity measures of classes of predictors, we refer the reader to [4, 31, 85].
For our purposes going forward, it is important to observe that as C gets larger, a larger
sample set is required to keep the right-hand side in (10) small. This means that in order for
the optimal value of problem (8) to represent the actual expected risk corresponding to ŵ,
there needs to be a balance between the complexity of the predictor class and the number of
sample points. If optimization is performed over a complex class of predictors using a sample
set that is not sufficiently large, then the optimal solution ŵ may achieve small f̂(ŵ), but have
a large expected loss f(ŵ). Such a solution will have poor predictive properties because it
overfits the training data. On the other hand, to learn “effectively”, one needs to balance the
complexity of the predictors and the size of the data set.
6
+ −
(a) 1st predictor
− +
(b) 2nd predictor
+ −
(c) 3rd predictor
− +
(d) 4th predictor
−
+
(e) 5th predictor
+
−
(f) 6th predictor
− +
(g) 7th predictor
+ −
(h) 8th predictor
Figure 2: Correct classifications of all 8 possible labelings of 3 points by linear predictors in R2
One way to control the complexity of a class is simply to control the `2-norm of w, since
smaller ‖w‖2 results in smaller Rw and a smaller bound on an appropriate complexity measure
C [4]. Alternatively, particularly for linear predictors, one can control complexity by bounding
the number of nonzeros in w, thereby constraining the class to sparse predictors. This idea is
of particular interest when each data vector x has a lot of features, yet the prediction function
w0 +w
T
1 x is believed to depend only on a small (unknown) subset of these features. Once the
subset of features is selected, the VC-dimension of the class reduces to the number of nonzeros
in w. Hence, if a sparse predictor achieves small empirical error, then it is likely to achieve
small expected error.
Instead of explicitly constraining the number of nonzeros in w, which would make the op-
timization problem harder, a regularization term such as λ‖w‖1 can be added to the objective
function. The addition of this term encourages feature selection. It does not always guarantee
that a sparse solution will be reached, but it has been shown to work well in practice. Gener-
ically, to attempt to restrict the complexity of the prediction function class in some manner,
one often considers a regularized optimization problem of the form
min
w∈Rd
F (w), where F (w) =
1
n
n∑
i=1
`(p(w, xi), yi) + λr(w), (11)
λ ≥ 0 is a weighting parameter, and r is either ‖w‖1 or some other convex (potentially
nonsmooth) regularization function. How the parameter λ should be chosen is a subject of
work in structural risk minimization. However, the details of this are beyond the scope of
this tutorial. For our purposes, suffice it to say that for any given value of λ, one has an
optimization problem to solve (at least approximately), so now let us turn to optimization
algorithms that may serve well in the context of problem (11).
2 Methods for Solving the Logistic Regression Prob-
lem
The methods that we discuss in this section for solving problem (11) could be employed when `
and r are any convex functions with respect to w. There is a large variety of machine learning
7
models that fall in this category, including support vector machines, Lasso, sparse inverse
covariance selection and others. For further details on these models see [86] and references
therein. Here, in order to be more concrete at various times, we will refer specifically to the
case of regularized logistic regression for binary classification. To simplify our notation in this
case, let us assume without loss of generality that p(w, x) = wTx. (That is, we omit the bias
term w0, which can be done by augmenting the input vector by an extra feature which is
always equal to 1.) Denoting the dimension of both w and x as d, this leads to the specific
convex problem
min
w∈Rd
F (w), where F (w) =
1
n
n∑
i=1
log
(
1 + e−yi(w
T xi)
)
+ λr(w). (12)
It is worthwhile to note that the regularization term is necessary for this problem. To see why
this is the case, consider a parameter vector w such that yi(w
Txi) > 0 for all i ∈ {1, . . . , n}.
Then, consider the unbounded ray {θw : θ > 0}. It is easy to see that, in this case,
1
n
∑n
i=1 log(1 + e
−yi(θwT xi)) → 0 as θ → ∞, meaning that the minimum of this function can-
not be achieved. On the other hand, by adding a (coercive) regularization function r, it is
guaranteed that problem (12) will have an optimal solution.
For the regularization function r, we will refer to the common choices of r(w) = ‖w‖22
and r(w) = ‖w‖1. For simplicity, we will refer mostly to the former choice, which makes the
objective of (12) a continuously differentiable function. By contrast, r(w) = ‖w‖1 results in a
nonsmooth problem, for which minimization requires more sophisticated algorithms.
2.1 First-order methods
We begin by discussing first-order methods for solving (12). Here, “first-order” refers to the
fact that these techniques only require first-order derivatives of the terms in F .
2.1.1 Gradient descent
Conceptually, the most straightforward method for minimizing a smooth convex objective is
gradient descent ; e.g., see [62]. In this approach, one starts with an initial solution estimate
w0 and iteratively updates the estimate via the formula
wk+1 ← wk − αk∇F (wk), (13)
where αk > 0 is a stepsize parameter. The performance of the algorithm is inherently tied to
the choice of stepsize sequence {αk}. In the optimization research community, it is well known
that employing a line search in each iteration to determine {αk} can lead to a well-performing
algorithm for a variety of types of problems. However, for ML applications, such operations are
expensive due to the fact that each computation of F requires a pass over the entire dataset,
which can be prohibitively expensive if n is large.
Fortunately, theoretical convergence guarantees for the algorithm can still be proved when
each αk is set to a positive constant α for all k, as long as this fixed value is sufficiently small.
(When the stepsize is fixed, it is known in the ML community as the learning rate for the
algorithm. Some also use this term to refer to each αk or the entire sequence {αk}, even
when it is not constant.) The convergence rate depends on whether F is strongly convex or
merely convex. If F is µ-strongly convex, the gradient function∇F is Lipschitz continuous with
Lipschitz constant L ≥ µ, and α ∈ (0, 1/L), then it can be shown that the number of iterations
required until F (wk) − F (w∗) ≤  is at most O(κ log(1/)), where w∗ := arg minw F (w) and
κ := L/µ. This is a linear rate of convergence. (If λ > 0, then these conditions hold for
8
problem (12); in particular, µ ≥ λ and L ≤ maxi∈{1,...,n} ‖xi‖22.) On the other hand, if F is
merely convex (as would be the case in (12) when λ = 0), then such an -optimal solution is
obtained within at most O(1/) iterations, which is a sublinear rate. One can actually improve
these rates by employing an acceleration technique by Nesterov [60]. Using such an approach
allows one to attain -optimality within O (
√
κ log (1/)) iterations when F is strongly convex
and within O(1/
√
) iterations when it is convex.
Extensions of gradient descent and accelerated gradient descent for solving `1-norm reg-
ularized logistic regression problems (i.e., (12) when r(w) = ‖x‖1) are known as ISTA and
FISTA, respectively, [5]. Observe that, in this setting, the objective function may not be
strongly convex even if λ > 0. ISTA and FISTA have the same sublinear convergence rates as
their smooth counterparts when the objective function is convex [5].
The important aspect of gradient descent in the context of ML is to recognize the compu-
tational cost of computing the gradient of F in each iteration. In particular, in the context of
ML, the cost of a single gradient computation is typically O(nd); this can be seen, e.g., in the
case of problem (12) with r(w) = ‖w‖22, where the gradient of F for a given w is
∇F (w) = − 1
n
n∑
i=1
(
1
1 + eyi(wT xi)
)
yixi + 2λw. (14)
(Here, one funds a sum of n terms, where for each term one needs to compute the inner product
wTxi of d-dimensional vectors, hence the O(nd) cost.) The dependence of this computation on
n (which can be of order 106 ∼ 109 in various ML applications) is computationally prohibitive,
and can be viewed as potentially wasteful when many of the elements of the sample set are
the same or at least very similar. In the next subsection, we discuss a stochastic optimization
method whose per-iteration computational cost is drastically smaller, and yet can still offer
convergence guarantees.
2.1.2 Stochastic gradient method
The stochastic gradient method, well known in the OR community due to its use for minimizing
stochastic objective functions, is the hallmark optimization algorithm in the ML community.
Originally proposed by Robbins and Monro [67] in the context of solving stochastic systems of
equations, the method is notable in that it can be employed to minimize a stochastic objective
with nice convergence guarantees while the per-iteration cost is only O(d) as opposed to O(nd)
(as in gradient descent).
In each iteration, the stochastic gradient method computes an unbiased estimator Gk of
the true gradient ∇F (wk). This estimator can be computed at very low cost; e.g., for (12), a
stochastic gradient can be computed as
∇SkF (w) = −
1
|Sk|
∑
i∈Sk
(
1
1 + eyi(wT xi)
)
yixi + 2λw, (15)
where Sk, known as the mini-batch, has elements chosen uniformly at random from {1, . . . , n}.
The step is then taken similar to gradient descent:
wk+1 ← wk − αk∇SkF (wk). (16)
Absolutely critical to the algorithm is the choice of the stepsize sequence {αk}. Unlike gradient
descent, a fixed stepsize (i.e., learning rate) does not guarantee convergence of the algorithm
to the minimizer of a strongly convex F , but rather only guarantees convergence to a neigh-
borhood of the minimizer. However, Robbins and Monro showed that with
∞∑
k=1
αk =∞ and
∞∑
k=1
α2k <∞,
9
one can guarantee a sublinear rate of convergence (almost surely) to the minimizer [11].
Note that the stochastic gradient method is not, strictly speaking, a descent method since
−∇SkF (wk) is not guaranteed to be a descent direction for F from wk and the objective func-
tion does not decrease monotonically over the optimization process. However, we will refer to
it as SGD, for stochastic gradient descent, as is often done in the literature.
The convergence rate of SGD is slower than that of gradient descent. In particular, when
F is strongly convex, it only guarantees that an expected -accurate solution (i.e., one with
E[F (wk)] − F (w∗) ≤ ) is obtained once k ≥ O(1/), and when F is merely convex, it only
guarantees that such a solution is found once k ≥ O(1/2) [11]. On the other hand, as
previously mentioned, if the size of Sk is bounded by a constant (independent of n or k), then
the per-iteration cost of SGD is O(n) times smaller than that of gradient descent.
This trade-off between convergence rate and per-iteration cost can be analyzed in the
context of ML, with strong results in favor of SGD; e.g., see [12]. To outline the ideas behind
this analysis, let us ignore regularization terms and recall that our ultimate goal is to solve (7)
with some accuracy . This means that we want to obtain w such that f(w) − f(w∗) ≤ ,
where w∗ is the optimal solution to (7). Instead, however, we solve problem (8) to some
accuracy ̂, obtaining ŵ̂ such that E[f̂(ŵ̂) − f̂(ŵ)] ≤ ̂, where ŵ is the optimal solution
to (8). If we use ŵ̂ as our approximate solution to (7), then, from (9) and (10) and since
E[f̂(ŵ)− f̂(w∗)] ≤ 0, we have with probability at least 1− δ that
E[f(ŵ̂)− f(w∗)] = E[f(ŵ̂)− f̂(ŵ̂)] + E[f̂(ŵ̂)− f̂(ŵ)]
+ E[f̂(ŵ)− f̂(w∗)] + E[f̂(w∗)− f(w∗)]
≤ O
√C + log(1δ )
n
+ ̂. (17)
Thus, to achieve expected -optimality with respect to (7) while balancing the contributions
of the terms on the right-hand side of (17), we should aim to have, say,
O
√C + log(1δ )
n
 ≤ 
2
and ̂ ≤ 
2
. (18)
We can now compare algorithms by quantifying the computational costs they require to
satisfy these bounds. For example, suppose that we apply some algorithm to solve problem (8),
where, for a given n, the cost of obtaining ŵ̂ satisfying the latter bound in (18) is c(n, ),
which increases with both n and 1/. For a fixed family of functions p(w, ·) with w ∈ W and
complexity C, obtaining the former bound in (18) requires n ≥ O(2) (ignoring log factors).
Considering now the optimization algorithm and its cost c(n, ), it is clear that any algorithm
that computes f̂ , its gradient, or its Hessian at any point has a cost of at least O(n) = O(1/2)
to perform a single iteration, regardless of the rate at which it converges to a minimizer of
f̂ . This is the case, e.g., for the gradient descent method. SGD, on the other hand, has a
per-iteration cost that is independent of n and can be shown to converge to an 2 -optimal
solution within at most O(1/2) iterations (when the objective function is convex and one can
sample indefinitely from the input × output space according to the distribution P ). From this
discussion, we can conclude that, at least in theory, SGD is a superior algorithm for large-scale
(i.e., large n) ML applications.
In practice, however, standard SGD is not necessarily the most effective approach to solve
optimization problems in ML. Indeed, there is a great deal of active research in the ML and
optimization communities on developing improvements and/or alternatives to SGD. In the
subsequent two sections, we discuss two categories of such methods: variance reducing and
10
second-order methods. However, there are a variety of approaches even beyond these two
categories. For example, one extension of SGD that has often been found to perform better
in practice is SGD with momentum; see Algorithm 1. This algorithm is a stochastic variant
of the classical momentum method by Polyak [66], which enjoys an improved convergence
rate compared to standard gradient descent. SGD with momentum has been shown to be
quite successful in machine learning, especially deep learning, our topic in §3; e.g., see [80].
It is shown in [80] that Nesterov’s accelerated gradient method [60] can be cast as a classical
momentum approach. That said, to the best of our knowledge, this stochastic version of the
momentum method does not have convergence guarantees. Some results analyzing stochastic
variants of acceleration methods can be found in [48].
Algorithm 1 SGD with Momentum
Parameters: learning rate α > 0; momentum weight η ∈ (0, 1); mini-batch size s ∈ N
Initialize: w0 ∈ Rn; v0 = 0 ∈ Rn
Iterate:
for k = 1, 2, . . . do
Generate Sk with |Sk| = s uniformly from {1, . . . , n}
Compute ∇SkF (wk) according to (15)
Set vk ← ηvk−1 + (1− η)∇SkF (wk)
Set wk+1 ← wk − αvk
end for
As a final remark on SGD, we note that aside from its slow convergence rate (in theory
and practice), SGD is very sensitive to parameter choices, such as the mini-batch size |Sk| and
learning rate. The best choice of these parameters heavily depends on the dataset, and the
wrong choice can severely slow progress or cause the algorithm to stall completely.
2.1.3 Variance reducing methods
The arguments for SGD that we raised in the previous section rely on the assumptions that the
true aim is to solve problem (7) and that one can sample indefinitely from the space of inputs
and outputs. However, in ML applications, the sample set {(xi, yi)}ni=1 is often given and fixed,
and if n is sufficiently large, then there is good reason to view a discrete uniform distribution
over the sample set as a good approximation to the distribution P . Thus, one can argue that
the conclusions of the previous section should only be used as a theoretical guideline, reminding
us that while (7) might be the true problem of interest, one can reasonably be interested in
the most efficient methods for solving (8), or, very often, the regularized problem (11).
Considering problem (11), one finds that SGD can be improved upon by exploiting the
structure of the objective F as a finite sum of n functions plus a simple convex term. Several
methods have been developed along these lines, such as SAG [74], SAGA [22], SDCA [76], and
SVRG [44]. SAG and SAGA, for example, rely on averaging the past n stochastic gradients
in a particular manner in an attempt to accumulate more accurate gradient estimates as the
optimization algorithm proceeds. As a result, they enjoy the same convergence rate as full
gradient methods (with better constant factors). However, these methods require the storage
of n past stochastic gradients so that components can be individually updated as the method
progresses. In contrast, SVRG does not require such storage, though it does require computing
the full gradient every O(n) iterations. For reference, we state SVRG as Algorithm 2. The
algorithm performs one full gradient computation at each outer iteration, then takes l steps
along random directions which are stochastic corrections of this full gradient. The inner loop
size l must satisfy certain conditions to ensure convergence [44].
11
Algorithm 2 SVRG
Parameters: learning rate α > 0; mini-batch size s ∈ N; inner loop size l ∈ N
Initialize: w̃0 ∈ Rn
Iterate:
for k = 1, 2, . . . do
Set w0 ← w̃k−1
Set v0 ← ∇F (w0)
Set w1 ← w0 − αv0
Iterate:
for t = 1, . . . , l − 1 do
Generate St with |St| = s uniformly from {1, . . . , n}
Compute ∇StF (wt) and ∇StF (w0) according to (15)
Set vt ← ∇StF (wt)−∇StF (w0) + v0
Set wt+1 ← wt − αvt
end for
Set w̃k = wt with t chosen uniformly from {0, . . . , l}
end for
The name SVRG, which stands for stochastic variance-reduced gradient, comes from the
fact that the algorithm can be viewed as a variance-reduced variant of SGD (specifically for
finite-sum minimization). To see this, first observe that the random directions taken by the
algorithm are in fact unbiased gradient estimates:
E[vt] = ∇F (wt)−∇F (w0) + v0 = ∇F (wt). (19)
Second, notice that computation of the full gradient at each outer iteration helps reduce the
variance of the stochastic gradient estimates used in SGD; indeed, if wt is “close” to w0, then
one should expect vt to be “closer” to ∇F (wt) than is ∇StF (wt) alone. In practice, SVRG
is somewhat more robust than SGD is to the choice of learning rate α, though it still can be
quite sensitive to the choice of l, the inner loop size.
A new method that combines some ideas from SVRG and SAGA, called SARAH [61], only
differs from SVRG in terms of the inner loop step, which in SARAH is given by
vt ← ∇StF (wt)−∇StF (wt−1) + vt−1. (20)
This change causes E[vt] 6= ∇F (wt) so that the steps in SARAH are not based on unbiased
gradient estimates. However, it attains improved convergence properties relative to SVRG.
In Tables 2 and 3, we summarize the complexity properties of several popular first-order
methods when applied to minimize strongly convex (Table 2) and convex (Table 3) problems.
Here, complexity refers to an upper bound on the number of iterations that may be required
to attain an -accurate solution. In the former case, recall κ := L/µ defined in §2.1.1, often
referred to as the condition number of a strongly convex problem.
Yet another branch of variance reducing methods are those that employ the standard SGD
step formula (16), but attempt to achieve a faster convergence rate by increasing the mini-
batch size during the optimization process. If done carefully (and one can sample indefinitely
from the input × output space), then such an approach can achieve a linear rate of convergence
for minimizing the expected risk (7); e.g., see [11]. Similar ideas have also been explored for
the case of minimizing finite sums; e.g., see [27].
12
Table 2: Complexity of first-order methods when minimizing strongly convex functions
Method Complexity
GD O (nκ log (1/))
SGD O (1/)
SVRG O ((n+ κ) log (1/))
SAG/SAGA O ((n+ κ) log (1/))
SARAH O ((n+ κ) log (1/))
Table 3: Complexity of first-order methods when minimizing (not strongly) convex functions
Method Complexity
GD O (n/)
SGD O
(
1/2
)
SVRG O (n+ (
√
n/))
SAGA O (n+ (n/))
SARAH O ((n+ (1/)) log(1/))
2.2 Second-order and quasi-Newton methods
Motivated by decades of work in the deterministic optimization research community, one of the
most active research areas in optimization for ML relates to how one might use second-order
derivative (i.e., curvature) information to speed up training. As in the deterministic setting,
the idea is to compute the kth step by approximately minimizing a quadratic model of the
objective function F about wk of the form
mk(s) = F (wk) +∇F (wk)T s+ 12s
TBks, (21)
where Bk is positive definite, i.e., Bk  0. A variety of algorithms of this type exist, each distin-
guished by how the curvature matrix Bk is obtained and how an (approximate or exact) min-
imizer sk is computed. The prototypical example is Newton’s method where Bk = ∇2F (wk),
assuming this matrix is positive (semi)definite. For example, for the case of the regularized
logistic regression problem (12), one finds that this Hessian matrix, like the gradient in (14),
comes from the sum of similar terms defined over the dataset:
∇2F (w) = 1
n
n∑
i=1
(
eyi(w
T xi)
(1 + eyi(wT xi))2
xix
T
i
)
+ 2λId×d. (22)
Unfortunately, the computation and storage of a Hessian matrix becomes prohibitively
expensive in ML applications when n and/or d is large. As an alternative, one may consider
using stochastic Hessian information by replacing the average in (22) with an average over a
small subset Sk ⊆ {1, . . . , n}, as is done for computing gradient estimates. In the case of (22),
this might appear to be a good idea since the stochastic Hessian is a sum of |Sk| rank-one
matrices and a scaled identity matrix, meaning that solving a system of equations with such
a matrix might not be too expensive. However, such a low-rank approximation might not
adequately capture complete curvature information, making the added costs of the algorithm
(as compared to those of SGD or one of its variants) not worthwhile. Recently, several variants
of sub-sampled Newton methods have been proposed, where the sample size |Sk| is increased
to improve the accuracy of the Hessian estimates as the algorithms progresses. We give a brief
overview of these ideas in §3.4.
Another class of algorithms based on models of the form (21) are quasi-Newton methods.
Interestingly, these approaches compute no explicit second-order derivatives; instead, they
13
construct Hessian approximation matrices entirely from first-order derivatives by applying
low-rank updates in each iteration. For example, let us briefly describe the most popular
quasi-Newton algorithm, known as the Broyden-Fletcher-Goldfarb-Shanno (BFGS) method.
In this approach, one first recognizes that the minimizer of (21) is −B−1k ∇F (wk), revealing
that it is actually convenient to compute inverse Hessian approximations. With B−1k in hand
along with the step sk = wk+1−wk and displacement yk = ∇F (wk+1)−∇F (wk), one chooses
B−1k+1 to minimize ‖B
−1 − B−1k ‖ subject to satisfying the secant equation sk = B
−1yk. Using
a carefully selected norm, the solution of this problem can be written explicitly as
B−1k+1 =
(
I −
sky
T
k
sTk yk
)
B−1k
(
I −
yks
T
k
yTk sk
)
+
sks
T
k
yTk sk
, (23)
where the difference between B−1k and B
−1
k+1 can be shown to be only a rank-two matrix.
For reference, a complete classical BFGS algorithm is stated as Algorithm 3.
Algorithm 3 BFGS method
Initialize: w0 ∈ Rn; B−10 ∈ Rn×n with B−10  0.
Iterate:
for k = 0, 1, . . . do
Set s̃k ← B−1k ∇F (wk)
Compute αk satisfying the Wolfe line search conditions [62] for F from wk along s̃k
Set sk ← αks̃k
Set yk ← ∇F (wk + sk)−∇F (wk)
Set B−1k+1 by (23)
Set wk+1 ← wk + sk
end for
It has been shown (e.g., see [62]), under certain conditions including strong convexity of
the objective function F , that the BFGS method yields the Dennis-Moré condition, namely,
limk→∞ ‖(Bk − ∇2F (wk))sk‖/‖sk‖ = 0, which in turn can be used to show that the BFGS
method converges locally superlinearly. Critical in this analysis is the condition that sTk yk > 0
for all k, which guarantees that Bk+1 in (23) is positive definite as long as Bk  0. When the
objective F is strongly convex, this holds automatically, but, for merely convex or potentially
nonconvex F , this is guaranteed by the Wolfe line search.
In the context of large-scale ML, the classical BFGS method is intractable for a variety of
reasons. Of course, there are the issues of the computational costs of computing exact gradients
and performing a line search in each iteration. However, in addition, there is the fact that
the Hessian approximations will almost certainly be dense, which might lead to storage issues
in addition to the expense of computing matrix-vector products with large dense matrices.
Fortunately, however, the optimization literature has already addressed these latter issues
with the idea of using limited memory quasi-Newton approaches, such as limited memory
BFGS, also known as L-BFGS [13].
For our purposes, let us simply give an overview of several variants of the (L-)BFGS
method that have been recently developed to address various challenges of ML applications.
One common feature of all of these approaches is that the line search component is completely
removed in favor of a predetermined stepsize sequence such as is used for SGD. Another
common feature is that the sequence {yk} no longer represents (exact) gradient displacements,
since exact gradients are too expensive to compute. Instead, the techniques mentioned in the
bullets below use different ideas for this sequence of vectors.
14
• If one defines yk as the difference of two stochastic gradient estimates formed using two
different mini-batches, i.e., yk = ∇Sk+1F (wk+1) −∇SkF (wk), then one typically fails to
have sTk yk > 0 and, even if this bound does hold, the Hessian approximation sequence
can be highly volatile. An alternative idea that overcomes these issues is to definte
yk = ∇SkF (wk+1) − ∇SkF (wk) so that the displacement is computed using the same
mini-batch at each point. This is what is proposed in the methods known as oBFGS
(oLBFGS) [75] and SGD-QN [10]. This idea requires two computations of a stochastic
gradient per iteration, one for each of the mini-batches Sk−1 (to compute the previous
displacement) and Sk (to compute the next step). The resulting method has been shown
to perform well for convex problems, though convergence eventually slows down when
noise in the gradient estimates starts to dominate the improvements made by the steps.
• In [7], it is proposed to use large overlapping (but still distinct) mini-batches on consec-
utive iterations within an L-BFGS framework. In other words, yk = ∇Sk+1F (wk+1) −
∇SkF (wk), with Sk+1 and Sk not independent, but containing a relatively large overlap.
Positive results on optimizing the training error for logistic regression were obtained by
combining L-BFGS with carefully designed distributed computations.
• Another stochastic (L-)BFGS method has been proposed to encourage the self-correcting
property of BFGS-type updating. In particular, it is known that (L-)BFGS behaves well
when the inner product yTk sk remains bounded above and below (away from zero). Hence,
in [19], a modification of the secant equation is proposed to ensure such bounds on yTk sk.
Letting yk = ∇FSk+1(wk+1) − ∇FSk(wk) and sk = wk+1 − wk, the method replaces the
secant equation with sk = B
−1vk, where vk = βksk + (1 − βk)yk for some βk ∈ (0, 1).
In particular, βk is chosen specifically to ensure that s
T
k vk = βks
T
k sk + (1 − βk)yTk sk
is bounded above and below by positive constants. With this damping of the update
vectors, the method exhibits stable performance in convex and nonconvex settings.
• An alternative idea aimed at ensuring that sTk yk > 0 has been proposed in [14] and
extended in [33] to a block version of the BFGS method. The key idea is to set yk
not as the difference of stochastic gradient estimates, but as yk = ∇2FS′k(wk)sk where
∇2FS′k(wk) is a sample Hessian computed on some batch S
′
k, different from the batch
that is used to compute the step sk. This approach has been successful on convex models
such as logistic regression. However, if the sample Hessian is computed using small mini-
batches (relative to dw), then y
T
k sk = s
T
k∇2FS′k(wk)sk may be small and the method may
become unstable.
Stochastic optimization methods (without variance reduction) cannot achieve a convergence
rate that is faster than sublinear, even if second-order information is used. However, using
second-order information is an attractive idea since, if the Hessian approximation matrices
converge to the Hessian at the solution, then the constant in the convergence rate can be
lessened as the effects of ill-conditioning can be reduced.
Unfortunately, despite practical improvements that have been observed, there has yet to
be a practical second-order method that provably achieves such improvements in theory. As of
now, most practical methods only provably achieve the convergence (rate) properties of SGD
as long as the Hessian (approximation) matrices remain well-behaved. For example, if the
sequence {Bk} (not necessarily produced by BFGS updates) satisfies, for all k,
∇F (wk)TE[B−1k ∇SkF (wk)] ≥ µ1‖∇F (wk)‖
2 for µ1 ∈ (0,∞),
and ‖E[B−1k ∇SkF (wk)]‖
2 ≤ µ2‖∇F (wk)‖2 for µ2 ∈ [µ1,∞),
then wk+1 ← wk−αkB−1k ∇SkF (wk) achieves the same convergence rate properties as SGD. It is
reasonable to assume that such bounds hold for the method discussed above, with appropriate
15
safeguards; however, one should be careful in a quasi-Newton context in which the stochastic
gradient estimates might be correlated with the Hessian approximations.
3 Deep Learning
We have seen that mathematical optimization plays an integral role in machine learning. In
particular, in §1.2, we saw that in hopes of solving a given learning problem, a careful sequence
of choices and practical approximations must be made before one arrives at a tractable problem
such as (8). We have also seen how, as in many traditional machine learning models, one can
arrive at a convex optimization problem such as (12) for which numerous types of algorithms
can be applied with well-known strong convergence guarantees. However, for a variety of
types of learning problems, researchers have found that ending up at a convex problem goes
perhaps too far in terms of simplifications of the function one is trying to learn to make
accurate predictions. Indeed, recent advances have shown that such convex models are unable
to provide predictors that are as powerful as those that can be achieved through more complex
nonconvex models. In this section, we provide an overview of recent developments in this area
of optimization for machine learning.
The major advancements that have been made along these lines involve the use of deep neu-
ral networks (DNNs). The corresponding branch of ML known as deep learning (or hierarchical
learning) represents classes of algorithms that attempt to construct high-level abstractions in
data by using a deep graph with multiple layers involving sequential linear and nonlinear
transformations [6, 51, 73, 37, 38, 23]. A variety of neural network types have been studied
in recent years, including fully-connected networks (FNNs) [84, 28], convolutional networks
(CNNs) [50], and recurrent networks (RNNs) [41, 57, 52]. For our purposes, we will mainly
refer to the first two types of networks, while keeping in mind the others.
While the idea of “high-level abstractions” might sound complicated, understanding the
basics of DNNs is not that difficult once one is familiar with the terminology. Deep neural
networks derive their name from being inspired by simplifications of models in neuroscience.
It is not necessary to be an expert in neuroscience to understand DNNs, but many do find it
convenient to borrow its terminology when describing the structure of a DNN and how one
combines input information through a sequence of stages until an ultimate output is produced.
The idea makes sense as to how the human brain takes various pieces of input from multiple
sources and combines them all through a multi-step process (learned since birth) in order to
make a prediction. For example, to classify an image as one of a dog, one combines bits of
information—e.g., sections that look like ears, a tail, and fur all oriented in the appropriate
manner—to make such a determination.
3.1 Formulation
Structurally, a DNN takes the form of a graph with subsets of nodes arranged in a sequence.
Each subset of nodes (or neurons) is called a layer, where in simple cases edges only exist
between neurons in a layer and the subsequent layer. However, besides its structure, the key
aspect of a DNN is how information is “fed” through it. In the simple case of a feed forward
network, this occurs as follows. First, each element of an input vector x = (x1, . . . , xdx) is
given to a different neuron in the first layer, also known as the input layer. The values in
this layer are then each passed to the neurons in the next layer after multiplication with
weights associated with the corresponding edges. Once at a given node, a value can be further
transformed through application of a (linear or nonlinear) activation function before values
continue to be passed through the network. The last layer of the network, which provides
the predicted output p(x), is known as the output layer, whereas layers between the input
16
and output are called hidden layers. The more hidden layers that are present, the deeper the
network. Figure 3 provides a partial illustration of a small fully-connected DNN for a simple
classification model with dx = 5, dy = 3, and two hidden layers.
In
p
u
t
L
ay
er
O
u
tp
u
t
L
ayer
Hidden Layers
x5
x4
x3
x2
x1
h14
h13
h12
h11
h24
h23
h22
h21
p3
p2
p1
[W1]54
[W1]11
[W2]44
[W2]11
[W3]43
[W3]11
Figure 3: Small fully-connected neural network with 2 hidden layers.
Mathematically, the application of a DNN starts by setting x(1) ← x as the input layer
values. One then applies repeated transformations (for each subsequent layer) of the form
x(j+1) ← sj(Wjx(j) + ωj) (24)
where each Wj is a matrix of edge weight parameters, ωj is a vector of shift parameters, and
sj is an activation function (common choices of which are componentwise sigmoid, tanh, and
ReLU (rectified linear unit) [20], along with the latter’s variants such as PReLU (Parametric-
ReLU) [53] and LReLU (Leaky-ReLU) [39]). For example, in the case of the network depicted
in Figure 3, h11 is the first component of the vector s1(W1x
(1)) while h23 is the third component
of the vector s2(W2h1), where h1 = (h11, h12, h13, h14). The parameters of this network are
the matrices W1 ∈ R4×5, W2 ∈ R4×4, and W3 ∈ R3×4, as well as the vectors ω1 ∈ R4, ω2 ∈ R4,
and ω3 ∈ R3. Thus, in total, this network has 59 parameters.
Other graph structures are common in deep learning, all designed, to some extent, for
specific purposes. For example, convolutional neural networks (CNNs) have received a lot of
attention in the context of image recognition (and other perceptual tasks). These networks
exploit the fact that the input consists of units, such as pixels of an image, that are inherently
connected due to their spatial relationships.
Let us describe some of the ideas underlying CNNs by describing the operation of its key
building block, a convolutional layer, first with a numerical example and then more broadly.
Consider the matrix of data values on the left-hand side of Figure 4. If one has a smaller
matrix, call it a filter, then the application of a convolutional layer results in another smaller
matrix formed by “sliding” the filter across the original matrix, taking the dot product of each
overlap, and storing the results. For example, in Figure 4, we illustrate the application of a
2× 2 filter to 4× 4 data, resulting in a 3× 3 matrix. The parameters to be optimized in this
convolutional layer are the entries of the filter (of which there might be many in a particular
layer, resulting in a set of smaller matrices, rather than only one). Even though we illustrate
this example with matrices, one can easily translate these operations to a graph structure
where each value in the input data corresponds to a node in the input layer, then a common
weight matrix (and, potentially, a common shift) is applied to obtain the values in the smaller
matrix corresponding to values in the first hidden layer.
What role can a filter play and how might it help with image recognition? Suppose that
the data matrix in Figure 4 represents the grayscale values of a two-dimensional image, with
17
1 0 9 2
2 8 0 8
9 1 7 0
1 8 0 2
1 0 9 2
2 8 0 8
9 1 7 0
1 8 0 2
9 0 17
3 15 0
17 1 9
1 0
0 1
Figure 4: Application of a filter in a convolutional layer. The original 4 × 4 data appears at the
left. On the right is illustrated how the filter—i.e., the 2× 2 matrix on the top left—can be passed
over the data matrix to produce the 3× 3 feature map at the right.
larger numbers corresponding to brighter pixels and smaller numbers corresponding to darker
ones. Then, a filter such as the one illustrated might help to detect sections with a bright
diagonal pattern. Extrapolating this idea to larger images and more complicated inputs (say,
with RGB values), one can imagine optimizing a set of filters, each intended to detect different
patterns, such as edges or blobs of color. Each matrix produced by applying a filter is referred
to as a feature map, which can be viewed as an image itself in which all patterns have been
filtered out except the one of interest for that filter. It is worthwhile to mention that the idea of
creating feature maps was inspired by processes in neuroscience—in this case, the connectivity
between neurons in an animal’s visual cortex.
CNNs involve other types of building blocks as well (e.g., pooling layers), all arranged
carefully in sequence. We leave the reader to explore the literature for further information.
For our purposes, let us, as an example, simply show the structure of a complete CNN; see
Figure 5. This CNN improved the state-of-the-art of image classification tasks for the ImageNet
Large Scale Visual Recognition Challenge [71]. In this challenge, the dataset contained around
1.2 million examples. The network involves around 60 million parameters.
Figure 5: CNN for image classification applied to the ILSVRC challenge [11].
For DNNs in general, the structure of the graph and the activation functions are typically
determined in advance, meaning that, to train it, one needs to solve an optimization problem
to minimize expected (or empirical) risk over the parameters w = (W1, ω1,W2, ω2, . . . ). Un-
fortunately, however, such a problem cannot in general be reduced to a convex optimization
problem. Indeed, the resulting problems are highly nonconvex with numerous saddle points
18
and local minimizers. Due to this, one might expect that training a DNN would be an impos-
sible task. However, with the vast amounts of data and high-performance computing power
available today, researchers have found that optimization methods can offer (approximate)
solutions leading to DNNs with great predictive powers.
The increased popularity of neural networks and deep learning in recent years has been due
to both theoretical and practical reasons. The universal approximation theorem established
in 1989 [42] shows that a feed-forward neural network with only a single hidden layer could,
under mild assumptions on the activation function, approximate any continuous function on a
compact subset of Rd. On the practical side, recent advances in optimization techniques and
the use of computational resources have helped to train DNNs for large-scale applications, such
as for speech recognition [40, 35], image classification [18, 47, 77], human action recognition
[43], video classification [45], forecasting [56, 36, 81, 83], machine translation [17, 2], and civil
engineering [26, 1, 46, 24]; see also [89].
3.2 Stochastic gradient descent
Given the complex structure of DNNs, one might think it would be difficult to implement an
optimization algorithm to optimize the parameter vector w in a problem of the form (8) when
p(w, xi) comes from a series of evaluations of the form (24). In particular, how can (stochastic)
gradients be computed? Fortunately, in the 1980s, a key observation was made that such
gradients can be computed efficiently using a process known as back propagation [70, 49]. In
essence, this involves the application of the chain rule through automatic differentiation. For
this tutorial, it is not necessary to look into the details of back propagation, but it is important
to recognize its importance in being able to efficiently apply algorithms such as (stochastic)
gradient descent and its variants, e.g., that we have described in §2.
But what can be said about convergence guarantees for such methods? After all, the opti-
mization problems in §2 are convex or even strongly convex, a setting in which nice theoretical
guarantees can be provided. What about training DNNs when the objective function is non-
convex with numerous local minimizers and saddle points? Therein lies a number of fascinating
questions about the use of DNNs that will inevitably lead to new research directions for years
to come. In short, while some theoretical guarantees (both for optimization and for learning)
have been provided, the practical gains achieved by the use of DNNs in recent years remains
somewhat of a mystery.
Let us highlight the enigmatic behavior of optimization algorithms applied to train DNNs
by citing the following. First, one has, e.g., in [11], a result which says that by applying SGD
to minimize a nonconvex objective function (drawing indefinitely from the input × output
space), one has a guarantee that the gradient of the expected risk will vanish, at least over
a subsequence; i.e., lim infk→∞ E[‖∇f(xk)‖2] = 0. This result is comforting in that it shows
that SGD can achieve a convergence guarantee similar to other state-of-the-art gradient-based
optimization algorithms. However, this and other guarantees in the literature are limited; after
all, whereas many gradient-based optimization algorithms ensure monotonic decrease of the
objective function, SG does not operate in this manner. So if a subsequence is converging to
a stationary point, how can we be sure that the stationary point is not a saddle point, poor
local minimizer, or perhaps some maximizer with objective value worse than the initial point?
In truth, we cannot be sure. That said, SGD does often seem to find good local, if not global
minima. On the other hand, it tends to slow down around stationary points, which can hinder
its progress in training DNNs [58, 63, 21].
In general, for nonconvex problems, convergence rates results for SGD do exist [29, 30],
but they are very limited, and in particular they are not applicable to the discussion in §1.3.
Hence, we cannot argue in the same manner that SGD is a superior method for nonconvex
19
optimization problems in ML. Moreover, learning bounds such as that in (10) are not useful,
because for many DNNs and CNNs the complexity C of the classifier class produced by a
neural network is much bigger than the number of training examples n. In fact, in [90] it
is empirically shown that neural networks can easily overfit typical types of datasets, if only
the data in these sets are randomly perturbed. The information inherent in a typical “real”
dataset is ruined by random perturbations, yet that does not stop the training process for a
DNN (e.g., using the momentum variant of SGD described in Algorithm 1) to find a “good”
solution for a dataset that is actually completely meaningless!
It remains an open question how one can design stochastic-gradient-type methods to opti-
mize parameters of a DNN so as to find good local minimizers and avoid poor local minimizers
and/or saddle points. Stochastic quasi-Newton methods described in §2.2 have been applied
to DNNs with mixed results. However, clearly, they are not aimed at exploiting negative cur-
vature, since they construct positive definite Hessian approximations. One alternative avenue
that is being explored in the context of deep learning is the use of non-stochastic second-
order methods, which have the benefit of observing accurate curvature information about the
objective function, so as to hopefully avoid saddle points.
3.3 Hessian-free methods
Let us now briefly describe a class of methods that form Bk in (21) as the true or a modified
Hessian matrix using the entire dataset. While such an approach might sound prohibitively
expensive, it is possible to employ such an approach through efficient use of parallel and
distributed computation across a network of computing nodes. In such settings, it is possible to
use full batch computation (e.g., to compute gradients exactly), though it is still not reasonable
to assume that one can compute and store a complete Hessian matrix. Fortunately, however,
in certain Newton-type methods one only needs a subroutine for computing Hessian-vector
products, i.e., products of a Hessian with a set of vectors. (For example, this is the case in
Newton-CG, wherein a step is computed by minimizing (21) approximately using the conjugate
gradient algorithm.) For these purposes, one finds that the back propagation algorithm for
DNNs can be modified to compute such Hessian-vector products, since they can be seen as
directional derivatives [65]. The cost of computing such a product is only a constant factor
more than computing a gradient. The resulting class of methods is often referred to as Hessian-
free since, while Hessian information is accessed and used, no Hessian matrix is ever stored
explicitly.
Additional complications arise in the context of DNNs since, due to nonconvexity of the
objective function, the true Hessian matrix might not be positive definite. In general, as in
deterministic optimization, two possible ways of handling this issue are to modify the Hessians
or employ a trust region methodology. Both of these directions are being explored in the
context of training DNNs. For example, in [54, 55], a Gauss-Newton method is proposed,
which approximates the Hessian matrix by the first term in the following formula for the
Hessian of F in (11) (ignoring the regularization term):
∇2F (w) = 1
n
n∑
i=1
∇p(w, xi)T∇2`(p(w, xi), yi)∇p(w, xi) + dy∑
j=1
[`(pj(w, xi), yi)∇2[pj(w, xi)]
 ,
where ∇2`(p(w, xi), yi) is the Hessian of the loss function `(·, ·) with respect to the first ar-
gument, ∇p(w, xi) is the Jacobian of the dy-dimensional function p(w, x) with respect to w,
and ∇2[pj(w, xi)] for all j ∈ {1, . . . , dy} are the element-wise Hessians with respect to w. The
sum of the first terms, known as the Gauss-Newton matrix, is positive semidefinite. If the
algorithm converges to a solution with zero loss, then `(pj(w, xi), zi) → 0, meaning that the
20
Gauss-Newton matrix converges to the true Hessian in the limit, which in turn must be posi-
tive semidefinite. However, when there is nonzero loss, the Gauss-Newton matrix differs from
the true Hessian and the method may converge to a saddle point. Since the Gauss-Newton
matrix is not necessarily nonsingular, a small regularization term of the form γI is often added
when forming Bk. In any case, to obtain sk ≈ −B−1k ∇F (wk), the methods in [54, 55] use a
(preconditioned) conjugate gradient method.
The idea of using a trust region methodology, say with Bk representing the true Hessian,
holds a lot of promise. That said, to maintain a Hessian-free nature, the trust region sub-
problem must be solved (approximately) using only Hessian-vector products. Two well-known
algorithms that serve this purpose are the Steihaug-Toint CG method [79, 82] and GLTR [32].
For training DNNs, numerical comparisons of these methods, as well as some newer alterna-
tives, can be found in [88]. In this study, all methods use 20–30 Hessian-vector multiplications
per iteration. It is found that the methods typically converge to different solutions with dif-
ferent testing losses and accuracies. One can go further and compute and follow directions of
negative curvature (requiring additional Hessian-vector products), which indeed can lead to
solutions with better properties. Additional experimentation and comparisons are needed to
demonstrate the potential benefits of such approaches, but in any case it is clear that for such
ideas to be effective, the low cost of computing Hessian-vector products (versus computing
and storing exact Hessian information) is essential.
3.4 Subsampled Hessian methods
Several variants of subsampled Newton methods have been proposed and analyzed for solving
(strongly) convex formulations of problem (11) [68, 69, 25, 9, 87]. All of these methods use
Bk = ∇2SkF (wk) as a Hessian approximation, where Sk is a random sample set. Some of
these methods also use stochastic gradients, though some assume that gradients are computed
exactly. In all cases, in contrast with the SGD, the size of Sk is increased to improve the
accuracy of the (gradient and) Hessian estimates as the algorithms converge. The schedule of
the increase of Sk and the final convergence results vary depending on the algorithm and the
analysis. The methods also differ by how the resulting Newton step is computed. In general,
the convergence rates that are recovered are similar to their deterministic counterparts.
For strongly convex problems, one can select a step size without performing a line search,
obviating the need to evaluate the objective function during the optimization process. However,
for nonconvex problems such as DNN training, evaluating F is essential for ensuring progress.
(For example, in trust region methods, one must accept or reject the step, and increase or
decrease the trust region radius, based on whether or not F decreases for a given step.) On the
other hand, as pointed out earlier, each trust-region subproblem solve requires several Hessian-
vector products. Hence, using a sampled Hessian for such products can mean significant savings
in the overall computational effort per iteration, while evaluating F and possibly even ∇F is
comparatively inexpensive. These ideas have been used in [54, 55], though without theoretical
justification.
Recently, in a series of papers [3, 15, 34], trust region, line search, and adaptive cubic reg-
ularization methods have been analyzed in convex and nonconvex cases using a very general
framework of random models. In this work, it is shown that standard optimization methods
that use random inexact gradient and Hessian information retain their convergence rates as
long as the gradient and Hessian estimates are sufficiently accurate with some positive proba-
bility. In the case of machine learning and sampled Hessian and gradients, the results simply
require that |Sk| has to be chosen sufficiently large with respect to the length of the step taken
by the algorithm. For example, in [3, 34], the size of |Sk| is connected to the trust region
radius. It is important to note that the requirement on the size of the sample set for a sampled
21
Hessian is significantly looser than that for the sampled gradient, supporting the idea that
using inexpensive Hessian estimates with exact gradients gives rise to algorithms with strong
theoretical behavior and good practical benefits. In [16, 8], convergence and convergence rate
analyses of a trust region method are carried out under relaxed conditions where F is also com-
puted inexactly, say, by sampling. The requirements on the sample set for evaluating F is even
stronger than those for the gradient. Still, this extension allows trust region methodologies to
be employed to minimize stochastic functions such as (7).
References
[1] H. Adeli. Neural networks in civil engineering: 1989–2000. Computer-Aided Civil and
Infrastructure Engineering, 16(2):126–142, 2001.
[2] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by
jointly learning to align and translate. arXiv:1409.0473, 2014.
[3] Afonso S Bandeira, Katya Scheinberg, and Luis Nunes Vicente. Convergence of
trust-region methods based on probabilistic models. SIAM Journal on Optimization,
24(3):1238–1264, 2014.
[4] P. L. Bartlett and S. Mendelson. Rademacher and gaussian complexities: Risk bounds
and structural results. J. Mach. Learn. Res., 3:463–482, March 2003.
[5] A. Beck and M. Teboulle. A fast iterative shrinkage-thresholding algorithm for linear
inverse problems. SIAM J. Imaging Sciences, 2(1):183–202, 2009.
[6] Y. Bengio. Learning deep architectures for ai. Foundations and trends R© in Machine
Learning, 2(1):1–127, 2009.
[7] Albert S. Berahas, Jorge Nocedal, and Martin Takac. A multi-batch l-bfgs method for ma-
chine learning. In Proceedings of the 29th International Conference on Neural Information
Processing Systems, NIPS’16, Cambridge, MA, USA, 2016. MIT Press.
[8] J. Blanchet, C. Cartis, M. Menickelly, and K. Scheinberg. Convergence rate analysis of a
stochastic trust region method for nonconvex optimization. 2016.
[9] R. Bollapragada, R. Byrd, and J. Nocedal. Exact and inexact subsampled newton methods
for optimization. arXiv:1609.08502, 2016.
[10] A. Bordes, L. Bottou, and P. Gallinari. Model selection through sparse maximum likeli-
hood estimation for multivariate gaussian or binary data. Journal of Machine Learning
Research, 10:1737–1754, December 2009.
[11] L. Bottou, F. E. Curtis, and J. Nocedal. Optimization Methods for Large-Scale Machine
Learning. Technical Report 1606.04838, arXiv, 2016.
[12] O. Bousquet and L. Bottou. The tradeoffs of large scale learning. In J. C. Platt, D. Koller,
Y. Singer, and S. T. Roweis, editors, Advances in Neural Information Processing Systems
20, pages 161–168. Curran Associates, Inc., 2008.
[13] R. H Byrd, J. Nocedal, and R. B Schnabel. Representations of quasi Newton matrices
and their use in limited memory methods. Mathematical Programming, 63:129–156, 1994.
[14] R.H. Byrd, S.L. Hansen, J. Nocedal, and Y.Singer. A Stochastic Quasi-Newton Method
for Large-Scale Optimization. Technical Report arXiv:1401.7020, arXiv, 2015.
[15] C. Cartis and K. Scheinberg. Global convergence rate analysis of unconstrained optimiza-
tion methods based on probabilistic models. Technical Report, ISE, Lehigh, 2015.
22
[16] C. Chen, M. Menickelly, and K. Scheinberg. Stochastic optimization using a trust-region
method and random models. 2015.
[17] Kyunghyun Cho, Bart Van Merriënboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi
Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using
rnn encoder-decoder for statistical machine translation. arXiv:1406.1078, 2014.
[18] Dan Ciregan, Ueli Meier, and Jürgen Schmidhuber. Multi-column deep neural networks
for image classification. In Computer Vision and Pattern Recognition (CVPR), 2012
IEEE Conference on, pages 3642–3649. IEEE, 2012.
[19] Frank Curtis. A self-correcting variable-metric algorithm for stochastic optimization. In
Proceedings of The 33rd International Conference on Machine Learning, page 632641,
2016.
[20] George E Dahl, Tara N Sainath, and Geoffrey E Hinton. Improving deep neural networks
for lvcsr using rectified linear units and dropout. In 2013 IEEE International Conference
on Acoustics, Speech and Signal Processing, pages 8609–8613. IEEE, 2013.
[21] Yann N Dauphin, Razvan Pascanu, Caglar Gulcehre, Kyunghyun Cho, Surya Ganguli, and
Yoshua Bengio. Identifying and attacking the saddle point problem in high-dimensional
non-convex optimization. In Advances in Neural Information Processing Systems, pages
2933–2941, 2014.
[22] A. Defazio, F. Bach, and S. Lacoste-Julien. Saga: A fast incremental gradient method
with support for non-strongly convex composite objectives. In Z. Ghahramani, M. Welling,
C. Cortes, N.D. Lawrence, and K.Q. Weinberger, editors, Advances in Neural Information
Processing Systems 27, pages 1646–1654. Curran Associates, Inc., 2014.
[23] Li Deng and Dong Yu. Deep learning. Signal Processing, 7:3–4, 2014.
[24] M.F. Elkordy, K.C. Chang, and G.C. Lee. Neural networks trained by analytically simu-
lated damage states. Journal of Computing in Civil Engineering, 7(2):130–145, 1993.
[25] M. A. Erdogdu and A. Montanari. Convergence rates of sub-sampled newton methods.
arXiv:1508.02810, 2015.
[26] I. Flood and N. Kartam. Neural networks in civil engineering I: Principles and under-
standing. Journal of computing in civil engineering, 8(2):131–148, 1994.
[27] Michael P. Friedlander and Mark Schmidt. Hybrid deterministic-stochastic methods for
data fitting. SIAM Journal on Scientific Computing, 34(3):A1380–A1405, 2012.
[28] C.R. Gent and C.P. Sheppard. Predicting time series by a fully connected neural network
trained by back propagation. Computing and Control Engineering Journal, 3(3):109–112,
1992.
[29] S. Ghadimi and G. Lan. Stochastic first-and zeroth-order methods for nonconvex stochas-
tic programming. SIOPT, 23(4):2341–2368, 2013.
[30] S. Ghadimi and G. Lan. Accelerated gradient methods for nonconvex nonlinear and
stochastic programming. Mathematical Programming, 156(1-2):59–99, 2016.
[31] G. Gnecco and M. Sanguineti. Approximation error bounds via rademacher’s complexity.
Applied Mathematical Sciences, 2(4):153 – 176, 2008.
[32] Nicholas IM Gould, Stefano Lucidi, Massimo Roma, and Philippe L Toint. Solving
the trust-region subproblem using the lanczos method. SIAM Journal on Optimization,
9(2):504–525, 1999.
[33] Robert Gower, Donald Goldfarb, and Peter Richtarik. Stochastic block bfgs: Squeezing
more curvature out of data. In Proceedings of The 33rd International Conference on
Machine Learning, page 18691878, 2016.
23
[34] S. Gratton, C. W. Royer, L. N. Vicente, and Z. Zhang. Complexity and global rates
of trust-region methods based on probabilistic models. Technical Report 17-09, Dept.
Mathematics, Univ. Coimbra, 2017.
[35] Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with
deep recurrent neural networks. In 2013 IEEE international conference on acoustics,
speech and signal processing, pages 6645–6649. IEEE, 2013.
[36] Zhenhai Guo, Weigang Zhao, Haiyan Lu, and Jianzhou Wang. Multi-step forecasting
for wind speed using a modified emd-based artificial neural network model. Renewable
Energy, 37(1):241–249, 2012.
[37] Martin T Hagan, Howard B Demuth, Mark H Beale, and Orlando De Jesús. Neural
network design, volume 20. PWS publishing company Boston, 1996.
[38] Simon Haykin. Neural networks, a comprehensive foundation. 1994.
[39] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Delving deep into rectifiers:
Surpassing human-level performance on imagenet classification. In Proceedings of the
IEEE International Conference on Computer Vision, pages 1026–1034, 2015.
[40] Geoffrey Hinton, Li Deng, Dong Yu, George E Dahl, Abdel-rahman Mohamed, Navdeep
Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick Nguyen, Tara N Sainath, et al. Deep
neural networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 29(6):82–97, 2012.
[41] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural Computation,
9:1735–1780, 1997.
[42] Kurt Hornik, Maxwell Stinchcombe, and Halbert White. Multilayer feedforward networks
are universal approximators. Neural networks, 2(5):359–366, 1989.
[43] Shuiwang Ji, Wei Xu, Ming Yang, and Kai Yu. 3d convolutional neural networks for hu-
man action recognition. IEEE transactions on pattern analysis and machine intelligence,
35(1):221–231, 2013.
[44] R. Johnson and T. Zhang. Accelerating stochastic gradient descent using predictive vari-
ance reduction. In C.J.C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K.Q.
Weinberger, editors, Advances in Neural Information Processing Systems 26, pages 315–
323. 2013.
[45] Andrej Karpathy, George Toderici, Sanketh Shetty, Thomas Leung, Rahul Sukthankar,
and Li Fei-Fei. Large-scale video classification with convolutional neural networks. In
Proceedings of the IEEE conference on Computer Vision and Pattern Recognition, pages
1725–1732, 2014.
[46] N. Kartam, I. Flood, and J. H Garrett. Artificial neural networks for civil engineers:
fundamentals and applications. American Society of Civil Engineers, 1997.
[47] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep
convolutional neural networks. In Advances in neural information processing systems,
pages 1097–1105, 2012.
[48] G. Lan. An optimal method for stochastic composite optimization. Mathematical Pro-
gramming, 133(1):365–397, 2012.
[49] Y. LeCun, L. Bottou, G. Orr, and K. Muller. Efficient BackProp. In Neural Networks:
Tricks of the trade. 1998.
[50] Yann LeCun and Yoshua Bengio. Convolutional networks for images, speech, and time
series. The handbook of brain theory and neural networks, 3361(10):1995, 1995.
24
[51] Yann LeCun, Yoshua Bengio, and Geoffrey Hinton. Deep learning. Nature, 521(7553):436–
444, 2015.
[52] M. Lukoševičius and H. Jaeger. Reservoir computing approaches to recurrent neural
network training. Computer Science Review, 3(3):127–149, 2009.
[53] Andrew L Maas, Awni Y Hannun, and Andrew Y Ng. Rectifier nonlinearities improve
neural network acoustic models. In Proc. ICML, volume 30, 2013.
[54] J. Martens. Deep learning via hessian-free optimization. In Proceedings of the 27th
International Conference on Machine Learning (ICML-10), pages 735–742, 2010.
[55] J. Martens and I. Sutskever. Training deep and recurrent networks with hessian-free
optimization. In Neural Networks: Tricks of the Trade, pages 479–535. Springer, 2012.
[56] C. McDeo, A. Jha, A.S. Chaphekar, and K. Ravikant. Neural networks for wave forecast-
ing. Ocean Engineering, 28(7):889–898, 2001.
[57] Tomas Mikolov, Martin Karafiát, Lukas Burget, Jan Cernockỳ, and Sanjeev Khudanpur.
Recurrent neural network based language model. In Interspeech, volume 2, page 3, 2010.
[58] E. Mizutani and S. E. Dreyfus. Second-order stagewise backpropagation for hessian-
matrix analyses and investigation of negative curvature. Neural Networks, 21(2):193–203,
2008.
[59] A Nemirovski, Juditsky, G Lan, and A Shapiro. SIAM Journal on optimization, 19.
[60] Yu. Nesterov. Introductory Lectures on Convex Optimization. Kluwer Academic Publsi-
hers, Boston, MA, 2004.
[61] L. M. Nguyen, J. Liu, K. Scheinberg, and M. Takáč. Sarah: A novel method for machine
learning problems using stochastic recursive gradient. arXiv:1703.00102, 2017.
[62] Jorge Nocedal and Stephen J. Wright. Numerical optimization. Springer Series in Oper-
ations Research and Financial Engineering. Springer, New York, second edition, 2006.
[63] R. Pascanu, Y. N. Dauphin, S. Ganguli, and Y. Bengio. On the saddle point problem for
non-convex optimization. CoRR, abs/1405.4604, 2014.
[64] R. Pasupathy and S. Ghosh. Simulation optimization: A concise overview and implemen-
tation guide. In TutORials in Operations Research, chapter 7, pages 122–150. INFORMS,
2013.
[65] B. A. Pearlmutter. Fast exact multiplication by the hessian. Neural computation,
6(1):147–160, 1994.
[66] B. T. Polyak. Some methods of speeding up the convergence of iteration methods. USSR
Computational Mathematics and Mathematical Physics, 4:791–803, 1964.
[67] H. Robbins and S. Monro. A Stochastic Approximation Method. The Annals of Mathe-
matical Statistics, 22(3):400–407, September 1951.
[68] F. Roosta-Khorasani and M. W. Mahoney. Sub-sampled newton methods i: Globally
convergent algorithms. arXiv:1601.047388, 2016.
[69] F. Roosta-Khorasani and M. W. Mahoney. Sub-sampled newton methods ii: Local con-
vergence rates. arXiv:1601.047388, 2016.
[70] D. E. Rumelhart, G. E. Hinton, and R. J. Williams. Neurocomputing: Foundations of
research. chapter Learning Representations by Back-propagating Errors, pages 696–699.
MIT Press, Cambridge, MA, USA, 1988.
25
[71] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Zh. Huang, A. Karpathy,
A. Khosla, M. Bernstein, A. C. Berg, and L. Fei-Fei. ImageNet Large Scale Visual Recog-
nition Challenge. International Journal of Computer Vision (IJCV), 115(3):211–252,
2015.
[72] A. Ruszczynski and A. Shapiro, editors. Stochastic Programming. Handbooks in Opera-
tions Research and Management Science, Volume 10. Elsevier, Amsterdam, 2003.
[73] Jürgen Schmidhuber. Deep learning in neural networks: An overview. Neural Networks,
61:85–117, 2015.
[74] M. Schmidt, N. LeRoux, and F. Bach. Minimizing finite sums with the stochastic average
gradient. arXiv preprint arXiv:1309.2388, 2013.
[75] N. N. Schraudolph, J. Yu, and S. Gunter. A stochastic quasi-newton method for online
convex optimization. In Marina Meila and Xiaotong Shen, editors, Proceedings of the
Eleventh International Conference on Artificial Intelligence and Statistics, volume 2 of
Proceedings of Machine Learning Research, pages 436–443, San Juan, Puerto Rico, 21–24
Mar 2007. PMLR.
[76] S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent
for regularized loss minimization. Mathematical Programming, pages 1–41, 2013.
[77] Karen Simonyan, Andrea Vedaldi, and Andrew Zisserman. Deep inside convolutional
networks: Visualising image classification models and saliency maps. arXiv:1312.6034,
2013.
[78] J.C. Spall. Introduction to Stochastic Search and Optimization: Estimation, Simulation,
and Control. Wiley Series in Discrete Mathematics and Optimization. Wiley, 2005.
[79] Trond Steihaug. The conjugate gradient method and trust regions in large scale opti-
mization. SIAM Journal on Numerical Analysis, 20(3):626–637, 1983.
[80] I. Sutskever, J. Martens, G. Dahl, and G. Hinton. On the importance of initialization
and momentum in deep learning. In Proceedings of the 30th International Conference on
International Conference on Machine Learning - Volume 28, ICML’13, pages III–1139–
III–1147. JMLR.org, 2013.
[81] Konda Thirumalaiah and MC Deo. River stage forecasting using artificial neural networks.
Journal of Hydrologic Engineering, 3(1):26–32, 1998.
[82] Ph L Toint. Towards an efficient sparsity exploiting newton method for minimization.
Sparse matrices and their uses, page 1981, 1981.
[83] Ching-Piao Tsai and Tsong-Lin Lee. Back-propagation neural network in tidal-level fore-
casting. Journal of Waterway, Port, Coastal, and Ocean Engineering, 125(4):195–202,
1999.
[84] Dimitris I Tsomokos, Sahel Ashhab, and Franco Nori. Fully connected network of super-
conducting qubits in a cavity. New Journal of Physics, 10(11):113020, 2008.
[85] V. N. Vapnik. The Nature of Statistical Learning Theory. Springer-Verlag, 1995.
[86] S. J. Wright. Optimization algorithms for data analysis. IAS/Park City Mathematics
Series, to appear.
[87] P. Xu, J. Yang, F. Roosta-Khorasani, Ch. Ré, and M. W. Mahoney. Sub-sampled newton
methods with non-uniform sampling. In D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon,
and R. Garnett, editors, Advances in Neural Information Processing Systems 29, pages
3000–3008. Curran Associates, Inc., 2016.
26
[88] A. Yektamaram. Optimization Algorithms for Machine Learning Designed for Parallel and
Distributed Environments. PhD thesis, ISE Department, Lehigh University, Bethlehem,
PA, 2017.
[89] Dong Yu and Li Deng. Deep learning and its applications to signal and information
processing. IEEE Signal Processing Magazine, 28(1):145–154, 2011.
[90] C. Zhang, S. Bengio, M. Hardt, B. Recht, and O. Vinyals. Understanding deep learning
requires rethinking generalization. arXiv:1611.03530, 2016.
27

