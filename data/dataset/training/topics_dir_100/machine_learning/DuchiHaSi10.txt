Adaptive Subgradient Methods
Adaptive Subgradient Methods for
Online Learning and Stochastic Optimization∗
John Duchi jduchi@cs.berkeley.edu
Computer Science Division
University of California, Berkeley
Berkeley, CA 94720 USA
Elad Hazan ehazan@ie.technion.ac.il
Technion - Israel Institute of Technology
Technion City
Haifa, 32000, Israel
Yoram Singer singer@google.com
Google
1600 Amphitheatre Parkway
Mountain View, CA 94043 USA
Abstract
We present a new family of subgradient methods that dynamically incorporate knowledge of
the geometry of the data observed in earlier iterations to perform more informative gradient-
based learning. Metaphorically, the adaptation allows us to find needles in haystacks in the
form of very predictive but rarely seen features. Our paradigm stems from recent advances
in stochastic optimization and online learning which employ proximal functions to control
the gradient steps of the algorithm. We describe and analyze an apparatus for adaptively
modifying the proximal function, which significantly simplifies setting a learning rate and
results in regret guarantees that are provably as good as the best proximal function that can
be chosen in hindsight. We give several efficient algorithms for empirical risk minimization
problems with common and important regularization functions and domain constraints. We
experimentally study our theoretical analysis and show that adaptive subgradient methods
outperform state-of-the-art, yet non-adaptive, subgradient algorithms.
Keywords: Subgradient methods, adaptivity, online learning, stochastic convex opti-
mization
1. Introduction
In many applications of online and stochastic learning, the input instances are of very high
dimension, yet within any particular instance only a few features are non-zero. It is often
the case, however, that infrequently occurring features are highly informative and discrim-
inative. The informativeness of rare features has led practitioners to craft domain-specific
feature weightings, such as TF-IDF (Salton and Buckley, 1988), which pre-emphasize in-
frequently occurring features. We use this old idea as a motivation for applying modern
∗. A preliminary version of this work was published in COLT 2010
1
Duchi, Hazan, and Singer
learning-theoretic techniques to the problem of online and stochastic learning, focusing
concretely on (sub)gradient methods.
Standard stochastic subgradient methods largely follow a predetermined procedural
scheme that is oblivious to the characteristics of the data being observed. In contrast,
our algorithms dynamically incorporate knowledge of the geometry of the data observed
in earlier iterations to perform more informative gradient-based learning. Informally, our
procedures give frequently occurring features very low learning rates and infrequent features
high learning rates, where the intuition is that each time an infrequent feature is seen, the
learner should “take notice.” Thus, the adaptation facilitates finding and identifying very
predictive but comparatively rare features.
1.1 The Adaptive Gradient Algorithm
Before introducing our adaptive gradient algorithm, which we term AdaGrad, we establish
notation. Vectors and scalars are lower case italic letters, such as x ∈ X . We denote a
sequence of vectors by subscripts, i.e. xt, xt+1, . . ., and entries of each vector by an additional
subscript, e.g. xt,j . The subdifferential set of a function f evaluated at x is denoted ∂f(x),
and a particular vector in the subdifferential set is denoted by f ′(x) ∈ ∂f(x) or gt ∈ ∂ft(xt).
When a function is differentiable, we write ∇f(x). We use 〈x, y〉 to denote the inner
product between x and y. The Bregman divergence associated with a strongly convex and
differentiable function ψ is
Bψ(x, y) = ψ(x)− ψ(y)− 〈∇ψ(y), x− y〉 .
We also make frequent use of the following two matrices. Let g1:t = [g1 · · · gt] denote the
matrix obtained by concatenating the subgradient sequence. We denote the ith row of this
matrix, which amounts to the concatenation of the ith component of each subgradient we
observe, by g1:t,i. We also define the outer product matrix Gt =
∑t
τ=1 gτgτ
⊤.
Online learning and stochastic optimization are closely related and basically interchange-
able (Cesa-Bianchi et al., 2004). In order to keep our presentation simple, we confine our
discussion and algorithmic descriptions to the online setting with the regret bound model.
In online learning, the learner repeatedly predicts a point xt ∈ X ⊆ Rd, which often repre-
sents a weight vector assigning importance values to various features. The learner’s goal is
to achieve low regret with respect to a static predictor x∗ in the (closed) convex set X ⊆ Rd
(possibly X = Rd) on a sequence of functions ft(x), measured as
R(T ) =
T
∑
t=1
ft(xt)− inf
x∈X
T
∑
t=1
ft(x) .
At every timestep t, the learner receives the (sub)gradient information gt ∈ ∂ft(xt). Stan-
dard subgradient algorithms then move the predictor xt in the opposite direction of gt while
maintaining xt+1 ∈ X via the projected gradient update (e.g. Zinkevich, 2003)
xt+1 = ΠX (xt − ηgt) = argmin
x∈X
‖x− (xt − ηgt)‖22 .
In contrast, let the Mahalanobis norm ‖·‖A =
√
〈·, A·〉 and denote the projection of a point
y onto X according to A by ΠAX (y) = argminx∈X ‖x− y‖A = argminx∈X 〈x− y,A(x− y)〉.
2
Adaptive Subgradient Methods
Using this notation, our generalization of standard gradient descent employs the update
xt+1 = Π
G
1/2
t
X
(
xt − ηG−1/2t gt
)
.
The above algorithm is computationally impractical in high dimensions since it requires
computation of the root of the matrix Gt, the outer product matrix. Thus we specialize the
update to
xt+1 = Π
diag(Gt)1/2
X
(
xt − η diag(Gt)−1/2gt
)
. (1)
Both the inverse and root of diag(Gt) can be computed in linear time. Moreover, as we
discuss later, when the gradient vectors are sparse the update above can often be performed
in time proportional to the support of the gradient. We now elaborate and give a more
formal discussion of our setting.
In this paper we consider several different online learning algorithms and their stochastic
convex optimization counterparts. Formally, we consider online learning with a sequence of
composite functions φt. Each function is of the form φt(x) = ft(x)+ϕ(x) where ft and ϕ are
(closed) convex functions. In the learning settings we study, ft is either an instantaneous
loss or a stochastic estimate of the objective function in an optimization task. The function
ϕ serves as a fixed regularization function and is typically used to control the complexity of
x. At each round the algorithm makes a prediction xt ∈ X and then receives the function
ft. We define the regret with respect to the fixed (optimal) predictor x
∗ as
Rφ(T ) ,
T
∑
t=1
[φt(xt)− φt(x∗)] =
T
∑
t=1
[ft(xt) + ϕ(xt)− ft(x∗)− ϕ(x∗)] . (2)
Our goal is to devise algorithms which are guaranteed to suffer asymptotically sub-linear
regret, namely, Rφ(T ) = o(T ).
Our analysis applies to related, yet different, methods for minimizing the regret (2).
The first is Nesterov’s primal-dual subgradient method (2009), and in particular Xiao’s
2010 extension, regularized dual averaging, and the follow-the-regularized-leader (FTRL)
family of algorithms (see for instance Kalai and Vempala, 2003; Hazan et al., 2006). In the
primal-dual subgradient method the algorithm makes a prediction xt on round t using the
average gradient ḡt =
1
t
∑t
τ=1 gτ . The update encompasses a trade-off between a gradient-
dependent linear term, the regularizer ϕ, and a strongly-convex term ψt for well-conditioned
predictions. Here ψt is the proximal term. The update amounts to solving
xt+1 = argmin
x∈X
{
η 〈ḡt, x〉+ ηϕ(x) +
1
t
ψt(x)
}
, (3)
where η is a fixed step-size and x1 = argminx∈X ϕ(x). The second method similarly has
numerous names, including proximal gradient, forward-backward splitting, and composite
mirror descent (Tseng, 2008; Duchi et al., 2010). We use the term composite mirror descent.
The composite mirror descent method employs a more immediate trade-off between the
current gradient gt, ϕ, and staying close to xt using the proximal function ψ,
xt+1 = argmin
x∈X
{η 〈gt, x〉+ ηϕ(x) +Bψt(x, xt)} . (4)
3
Duchi, Hazan, and Singer
Our work focuses on temporal adaptation of the proximal function in a data driven way,
while previous work simply sets ψt ≡ ψ, ψt(·) =
√
tψ(·), or ψt(·) = tψ(·) for some fixed ψ.
We provide formal analyses equally applicable to the above two updates and show how
to automatically choose the function ψt so as to achieve asymptotically small regret. We
describe and analyze two algorithms. Both algorithms use squared Mahalanobis norms as
their proximal functions, setting ψt(x) = 〈x,Htx〉 for a symmetric matrix Ht  0. The first
uses diagonal matrices while the second constructs full dimensional matrices. Concretely,
for some small fixed δ ≥ 0 (specified later, though in practice δ can be set to 0) we set
Ht = δI + diag(Gt)
1/2 (Diagonal) and Ht = δI +G
1/2
t (Full) . (5)
Plugging the appropriate matrix from the above equation into ψt in (3) or (4) gives rise
to our AdaGrad family of algorithms. Informally, we obtain algorithms which are similar
to second-order gradient descent by constructing approximations to the Hessian of the
functions ft, though we use roots of the matrices.
1.2 Outline of Results
We now outline our results, deferring formal statements of the theorems to later sections.
Recall the definitions of g1:t as the matrix of concatenated subgradients and Gt as the outer
product matrix in the prequel. The AdaGrad algorithm with full matrix divergences
entertains bounds of the form
Rφ(T ) = O
(
‖x∗‖2 tr(G
1/2
T )
)
and Rφ(T ) = O
(
max
t≤T
‖xt − x∗‖2 tr(G
1/2
T )
)
.
We further show that
tr
(
G
1/2
T
)
= d1/2
√
√
√
√inf
S
{
T
∑
t=1
〈gt, S−1gt〉 : S  0, tr(S) ≤ d
}
.
These results are formally given in Theorem 7 and its corollaries. When our proximal
function ψt(x) =
〈
x, diag(Gt)
1/2x
〉
we have bounds attainable in time at most linear in the
dimension d of our problems of the form
Rφ(T ) = O
(
‖x∗‖∞
d
∑
i=1
‖g1:T,i‖2
)
and Rφ(T ) = O
(
max
t≤T
‖xt − x∗‖∞
d
∑
i=1
‖g1:T,i‖2
)
.
Similar to the above, we will show that
d
∑
i=1
‖g1:T,i‖2 = d
1/2
√
√
√
√inf
s
{
T
∑
t=1
〈gt, diag(s)−1gt〉 : s  0, 〈1, s〉 ≤ d
}
.
We formally state the above two regret bounds in Theorem 5 and its corollaries.
Following are a simple example and corollary to Theorem 5 to illustrate one regime
in which we expect substantial improvements (see also the next subsection). Let ϕ ≡ 0
4
Adaptive Subgradient Methods
and consider Zinkevich’s online gradient descent algorithm. Given a compact convex set
X ⊆ Rd and sequence of convex functions ft, Zinkevich’s algorithm makes the sequence of
predictions x1, . . . , xT with xt+1 = ΠX (xt−(η/
√
t)gt). If the diameter of X is bounded, thus
supx,y∈X ‖x− y‖2 ≤ D2, then online gradient descent, with the optimal choice in hindsight
for the stepsize η (see the bound (7) in Sec. 1.4), achieves a regret bound of
T
∑
t=1
ft(xt)− inf
x∈X
T
∑
t=1
ft(x) ≤
√
2D2
√
√
√
√
T
∑
t=1
‖gt‖22 . (6)
When X is bounded via supx,y∈X ‖x− y‖∞ ≤ D∞, the following corollary is a simple
consequence of our Theorem 5, and we give a brief proof in Appendix C.
Corollary 1 Let the sequence {xt} ⊂ Rd be generated by the update (4) and assume that
maxt ‖x∗ − xt‖∞ ≤ D∞. Using stepsize η = D∞/
√
2, for any x∗, the following bound holds.
Rφ(T ) ≤
√
2dD∞
√
√
√
√ inf
s0,〈1,s〉≤d
T
∑
t=1
‖gt‖2diag(s)−1 =
√
2D∞
d
∑
i=1
‖g1:T,i‖2 .
The important feature of the bound above is the infimum under the square root, which
allows us to perform better than simply using the identity matrix, and the fact that the
stepsize is easy to set a priori. For example, if the set X = {x : ‖x‖∞ ≤ 1}, then D2 = 2
√
d
while D∞ = 2, which suggests that if we are learning a dense predictor over a box, the
adaptive method should perform well. Indeed, in this case we are guaranteed that the
bound in Corollary 1 is better than (6) as the identity matrix belongs to the set over which
we take the infimum.
To conclude the outline of results, we would like to point to two relevant research
papers. First, Zinkevich’s regret bound is tight and cannot be improved in a minimax
sense (Abernethy et al., 2008). Therefore, improving the regret bound requires further
reasonable assumptions on the input space. Second, in a independent work, performed
concurrently to the research presented in this paper, McMahan and Streeter (2010) study
competitive ratios, showing guaranteed improvements of the above bounds relative to fam-
ilies of online algorithms.
1.3 Improvements and Motivating Example
As mentioned in the prequel, we expect our adaptive methods to outperform standard online
learning methods when the gradient vectors are sparse, and we give empirical evidence
supporting this in Section 6. Here we give a few theoretical examples that show that for
sparse data—input sequences where gt has low cardinality—the adaptive methods herein
have better performance than non-adaptive methods. In our examples we use the hinge
loss, that is,
ft(x) = [1− yt 〈zt, x〉]+ ,
where yt is the label of example t and zt ∈ Rd is the data vector.
For our first example, which was also given by McMahan and Streeter (2010), consider
the following sparse random data scenario, where the vectors zt ∈ {−1, 0, 1}d. Assume that
5
Duchi, Hazan, and Singer
at in each round t, feature i appears with probability pi = min{1, ci−α} for some α ∈ (1,∞)
and a dimension-independent constant c. Then taking the expectation of the gradient terms
in the bound in Corollary 1, we have
E
d
∑
i=1
‖g1:T,i‖2 =
d
∑
i=1
E
[
√
|{t : |gt,i| = 1}|
]
≤
d
∑
i=1
√
E|{t : |gt,i| = 1}| =
d
∑
i=1
√
piT
by Jensen’s inequality. In the rightmost sum, we have c
∑d
i=1 i
−α/2 = O(log d) for α ≥
2, and
∑d
i=1 i
−α/2 = O(d1−α/2) for α ∈ (1, 2). If the domain X is a hypercube, say
X = {x : ‖x‖∞ ≤ 1}, then in Corollary 1 D∞ = 2, and the regret of AdaGrad is
O(max{log d, d1−α/2}
√
T ). For contrast, the standard regret bound (6) for online gradient
descent has D2 = 2
√
d and ‖gt‖22 ≥ 1, yielding best case regret O(
√
dT ). So we see that in
this sparse—yet heavy tailed—feature setting, AdaGrad’s regret guarantee is as much as
exponentially smaller in the dimension d than the non-adaptive regret bound.
Our remaining examples construct a sparse sequence for which there is a perfect pre-
dictor that the adaptive methods learn after d iterations, while standard online gradient
descent (Zinkevich, 2003) suffers significantly higher loss. We assume the domain X is com-
pact, so that for online gradient descent we set ηt = η/
√
t, which gives the optimal O(
√
T )
regret (the setting of η does not matter to the adversary we construct).
Diagonal Adaptation In this first example, we consider the diagonal version of our
proposed update (4) with X = {x : ‖x‖∞ ≤ 1}. Evidently, we can take D∞ = 2, and this
choice simply results in the update xt+1 = xt −
√
2 diag(Gt)
−1/2gt followed by projection
onto X (1) for AdaGrad (we use a pseudo-inverse if the inverse does not exist). Let ei
denote the ith unit basis vector, and assume that for each t, zt = ±ei for some i. Also let
yt = sign(〈1, zt〉) so that there exists a perfect classifier x∗ = 1 ∈ X ⊂ Rd. We initialize x1
to be the zero vector. Fix some ε > 0, and on rounds rounds t = 1, . . . , η2/ε2, set zt = e1.
After these rounds, simply choose zt = ±ei for index i ∈ {2, . . . , d} chosen at random. It is
clear that the update to parameter xi at these iterations is different, and amounts to
xt+1 = xt + ei AdaGrad xt+1 =
[
xt +
η√
t
]
[−1,1]d
(Gradient Descent) .
(Here [·][−1,1]d denotes the truncation of the vector to [−1, 1]d). In particular, after suffering
d− 1 more losses, AdaGrad has a perfect classifier. However, on the remaining iterations
gradient descent has η/
√
t ≤ ε and thus evidently suffers loss at least d/(2ε). Of course, for
small ε, we have d/(2ε) ≫ d. In short, AdaGrad achieves constant regret per dimension
while online gradient descent can suffer arbitrary loss (for unbounded t). It seems quite
silly, then, to use a global learning rate rather than one for each feature.
Full Matrix Adaptation We use a similar construction to the diagonal case to show
a situation in which the full matrix update from (5) gives substantially lower regret than
stochastic gradient descent. For full divergences we set X = {x : ‖x‖2 ≤
√
d}. Let
V = [v1 . . . vd] ∈ Rd×d be an orthonormal matrix. Instead of having zt cycle through
the unit vectors, we make zt cycle through the vi so that zt = ±vi. We let the label
yt = sign(
〈
1, V ⊤zt
〉
) = sign
(
∑d
i=1 〈vi, zt〉
)
. We provide an elaborated explanation in Ap-
pendix A. Intuitively, with ψt(x) = 〈x,Htx〉 and Ht set to be the full matrix from (5),
6
Adaptive Subgradient Methods
AdaGrad again needs to observe each orthonormal vector vi only once while stochastic
gradient descent’s loss can be made Ω(d/ε) for any ε > 0.
1.4 Related Work
Many successful algorithms have been developed over the past few years to minimize re-
gret in the online learning setting. A modern view of these algorithms casts the problem
as the task of following the (regularized) leader (see Rakhlin, 2009, and the references
therein) or FTRL in short. Informally, FTRL methods choose the best decision in hind-
sight at every iteration. Verbatim usage of the FTRL approach fails to achieve low regret,
however, adding a proximal1 term to the past predictions leads to numerous low regret al-
gorithms (Kalai and Vempala, 2003; Hazan and Kale, 2008; Rakhlin, 2009). The proximal
term strongly affects the performance of the learning algorithm. Therefore, adapting the
proximal function to the characteristics of the problem at hand is desirable.
Our approach is thus motivated by two goals. The first is to generalize the agnostic
online learning paradigm to the meta-task of specializing an algorithm to fit a particular
dataset. Specifically, we change the proximal function to achieve performance guarantees
which are competitive with the best proximal term found in hindsight. The second, as
alluded to earlier, is to automatically adjust the learning rates for online learning and
stochastic gradient descent on a per-feature basis. The latter can be very useful when our
gradient vectors gt are sparse, for example, in a classification setting where examples may
have only a small number of non-zero features. As we demonstrated in the examples above,
it is rather deficient to employ exactly the same learning rate for a feature seen hundreds
of times and for a feature seen only once or twice.
Our techniques stem from a variety of research directions, and as a byproduct we also
extend a few well-known algorithms. In particular, we consider variants of the follow-the-
regularized leader (FTRL) algorithms mentioned above, which are kin to Zinkevich’s lazy
projection algorithm. We use Xiao’s recently analyzed regularized dual averaging (RDA)
algorithm (2010), which builds upon Nesterov’s 2009 primal-dual subgradient method. We
also consider the forward-backward splitting (Fobos) algorithmic framework (Duchi and Singer,
2009) and its composite mirror-descent (proximal gradient) generalizations (Tseng, 2008;
Duchi et al., 2010), which in turn include as special cases projected gradients (Zinkevich,
2003) and mirror descent (Nemirovski and Yudin, 1983; Beck and Teboulle, 2003). Recent
work by several authors (Nemirovski et al., 2009; Juditsky et al., 2008; Lan, 2010; Xiao,
2010) considered efficient and robust methods for stochastic optimization, especially in the
case when the expected objective f is smooth. It may be interesting to investigate adaptive
metric approaches in smooth stochastic optimization.
The idea of adapting first order optimization methods is by no means new and can be
traced back at least to the 1970s with the work on space dilation methods of Shor (1972)
and variable metric methods, such as the BFGS family of algorithms (e.g. Fletcher, 1970).
This prior work often assumed that the function to be minimized was differentiable and, to
our knowledge, did not consider stochastic, online, or composite optimization. In her thesis,
Nedić (2002) studied variable metric subgradient methods, though it seems difficult to derive
1. The proximal term is also referred to as regularization in the online learning literature. We use the
phrase proximal term in order to avoid confusion with the statistical regularization function ϕ.
7
Duchi, Hazan, and Singer
explicit rates of convergence from the results there, and the algorithms apply only when
the constraint set X = Rd. More recently, Bordes et al. (2009) proposed a Quasi-Newton
stochastic gradient-descent procedure, which is similar in spirit to our methods. However,
their convergence results assume a smooth objective with positive definite Hessian bounded
away from 0. Our results apply more generally.
Prior to the analysis presented in this paper for online and stochastic optimization, the
strongly convex function ψ in the update equations (3) and (4) either remained intact or
was simply multiplied by a time-dependent scalar throughout the run of the algorithm.
Zinkevich’s projected gradient, for example, uses ψt(x) = ‖x‖22, while RDA (Xiao, 2010)
employs ψt(x) =
√
tψ(x) where ψ is a strongly convex function. The bounds for both types
of algorithms are similar, and both rely on the norm ‖·‖ (and its associated dual ‖·‖∗)
with respect to which ψ is strongly convex. Mirror-descent type first order algorithms,
such as projected gradient methods, attain regret bounds of the form (Zinkevich, 2003;
Bartlett et al., 2007; Duchi et al., 2010)
Rφ(T ) ≤
1
η
Bψ(x
∗, x1) +
η
2
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
∗ . (7)
Choosing η ∝ 1/
√
T gives Rφ(T ) = O(
√
T ). When Bψ(x, x
∗) is bounded for all x ∈ X , we
choose step sizes ηt ∝ 1/
√
t which is equivalent to setting ψt(x) =
√
tψ(x). Therefore, no
assumption on the time horizon is necessary. For RDA and follow-the-leader algorithms,
the bounds are similar (Xiao, 2010, Theorem 3):
Rφ(T ) ≤
√
Tψ(x∗) +
1
2
√
T
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
∗ . (8)
The problem of adapting to data and obtaining tighter data-dependent bounds for al-
gorithms such as those above is a natural one and has been studied in the mistake-bound
setting for online learning in the past. A framework that is somewhat related to ours is
the confidence weighted learning scheme by Crammer et al. (2008) and the adaptive regu-
larization of weights algorithm (AROW) of Crammer et al. (2009). These papers provide
mistake-bound analyses for second-order algorithms, which in turn are similar in spirit to
the second-order Perceptron algorithm (Cesa-Bianchi et al., 2005). The analyses by Cram-
mer and colleagues, however, yield mistake bounds dependent on the runs of the individual
algorithms and are thus difficult to compare with our regret bounds.
AROW maintains a mean prediction vector µt ∈ Rd and a covariance matrix Σt ∈ Rd×d
over µt as well. At every step of the algorithm, the learner receives a pair (zt, yt) where
zt ∈ Rd is the tth example and yt ∈ {−1,+1} is the label. Whenever the predictor µt
attains a margin value smaller than 1, AROW performs the update
βt =
1
〈zt,Σtzt〉+ λ
, αt = [1− yt 〈zt, µt〉]+ ,
µt+1 = µt + αtΣtytzt, Σt+1 = Σt − βtΣtxtx⊤t Σt. (9)
In the above scheme, one can force Σt to be diagonal, which reduces the run-time and stor-
age requirements of the algorithm but still gives good performance (Crammer et al., 2009).
8
Adaptive Subgradient Methods
In contrast to AROW, the AdaGrad algorithm uses the root of the inverse covariance ma-
trix, a consequence of our formal analysis. Crammer et al.’s algorithm and our algorithms
have similar run times, generally linear in the dimension d, when using diagonal matrices.
However, when using full matrices the runtime of AROW algorithm is O(d2), which is faster
than ours as it requires computing the root of a matrix.
In concurrent work, McMahan and Streeter (2010) propose and analyze an algorithm
which is very similar to some of the algorithms presented in this paper. Our analysis builds
on recent advances in online learning and stochastic optimization (Duchi et al., 2010; Xiao,
2010), whereas McMahan and Streeter use first-principles to derive their regret bounds.
As a consequence of our approach, we are able to apply our analysis to algorithms for
composite minimization with a known additional objective term ϕ. We are also able to
generalize and analyze both the mirror descent and dual-averaging family of algorithms.
McMahan and Streeter focus on what they term the competitive ratio, which is the ratio of
the worst case regret of the adaptive algorithm to the worst case regret of a non-adaptive
algorithm with the best proximal term ψ chosen in hindsight. We touch on this issue
briefly in the sequel, but refer the interested reader to McMahan and Streeter (2010) for
this alternative elegant perspective. We believe that both analyses shed insights into the
problems studied in this paper and complement each other.
There are also other lines of work on adaptive gradient methods that are not di-
rectly related to our work but nonetheless relevant. Tighter regret bounds using the vari-
ation of the cost functions ft were proposed by Cesa-Bianchi et al. (2007) and derived
by Hazan and Kale (2008). Bartlett et al. (2007) explore another adaptation technique for
ηt where they adapt the step size to accommodate both strongly and weakly convex func-
tions. Our approach differs from previous approaches as it does not focus on a particular
loss function or mistake bound. Instead, we view the problem of adapting the proximal
function as a meta-learning problem. We then obtain a bound comparable to the bound
obtained using the best proximal function chosen in hindsight.
2. Adaptive Proximal Functions
Examining the bounds (7) and (8), we see that most of the regret depends on dual norms
of f ′t(xt), and the dual norms in turn depend on the choice of ψ. This naturally leads to
the question of whether we can modify the proximal term ψ along the run of the algorithm
in order to lower the contribution of the aforementioned norms. We achieve this goal by
keeping second order information about the sequence ft and allow ψ to vary on each round
of the algorithms.
We begin by providing two corollaries based on previous work that give the regret of
our base algorithms when the proximal function ψt is allowed to change. These corollaries
are used in the sequel in our regret analysis. We assume that ψt is monotonically non-
decreasing, that is, ψt+1(x) ≥ ψt(x). We also assume that ψt is 1-strongly convex with
respect to a time-dependent semi-norm ‖·‖ψt . Formally, ψ is 1-strongly convex with respect
to ‖·‖ψ if
ψ(y) ≥ ψ(x) + 〈∇ψ(x), y − x〉+ 1
2
‖x− y‖2ψ .
9
Duchi, Hazan, and Singer
Strong convexity is guaranteed if and only if Bψt(x, y) ≥ 12 ‖x− y‖
2
ψt
. We also denote the
dual norm of ‖·‖ψt by ‖·‖ψ∗t . For completeness, we provide the proofs of following two results
in Appendix C, as they build straightforwardly on work by Duchi et al. (2010) and Xiao
(2010). For the primal-dual subgradient update, the following bound holds.
Proposition 2 Let the sequence {xt} be defined by the update (3). For any x∗ ∈ X ,
T
∑
t=1
ft(xt) + ϕ(xt)− ft(x∗)− ϕ(x∗) ≤
1
η
ψT (x
∗) +
η
2
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
ψ∗t−1
. (10)
For composite mirror descent algorithms a similar result holds.
Proposition 3 Let the sequence {xt} be defined by the update (4). Assume w.l.o.g. that
ϕ(x1) = 0. For any x
∗ ∈ X ,
T
∑
t=1
ft(xt) + ϕ(xt)− ft(x∗)− ϕ(x∗)
≤ 1
η
Bψ1(x
∗, x1) +
1
η
T−1
∑
t=1
[
Bψt+1(x
∗, xt+1)−Bψt(x∗, xt+1)
]
+
η
2
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
. (11)
The above corollaries allow us to prove regret bounds for a family of algorithms that
iteratively modify the proximal functions ψt in attempt to lower the regret bounds.
3. Diagonal Matrix Proximal Functions
We begin by restricting ourselves to using diagonal matrices to define matrix proximal
functions and (semi)norms. This restriction serves a two-fold purpose. First, the analysis for
the general case is somewhat complicated and thus the analysis of the diagonal restriction
serves as a proxy for better understanding. Second, in problems with high dimension
where we expect this type of modification to help, maintaining more complicated proximal
functions is likely to be prohibitively expensive. Whereas earlier analysis requires a learning
rate to slow changes between predictors xt and xt+1, we will instead automatically grow
the proximal function we use to achieve asymptotically low regret. To remind the reader,
g1:t,i is the ith row of the matrix obtained by concatenating the subgradients from iteration
1 through t in the online algorithm.
To provide some intuition for the algorithm we show in Alg. 1, let us examine the
problem
min
s
T
∑
t=1
d
∑
i=1
g2t,i
si
s.t. s  0, 〈1, s〉 ≤ c .
This problem is solved by setting si = ‖g1:T,i‖2 and scaling s so that 〈s, 1〉 = c. To see this,
we can write the Lagrangian of the minimization problem by introducing multipliers λ  0
and θ ≥ 0 to get
L(s, λ, θ) =
d
∑
i=1
‖g1:T,i‖22
si
− 〈λ, s〉+ θ(〈1, s〉 − c).
10
Adaptive Subgradient Methods
Input: η > 0, δ ≥ 0
Variables: s ∈ Rd, H ∈ Rd×d, g1:t,i ∈ Rt for i ∈ {1, . . . , d}
Initialize x1 = 0, g1:0 = []
For t = 1 to T
Suffer loss ft(xt)
Receive subgradient gt ∈ ∂ft(xt) of ft at xt
Update g1:t = [g1:t−1 gt], st,i = ‖g1:t,i‖2
Set Ht = δI + diag(st), ψt(x) =
1
2〈x,Ht x〉
Primal-Dual Subgradient Update (3):
xt+1 = argmin
x∈X
{
η
〈
1
t
t
∑
τ=1
gτ , x
〉
+ ηϕ(x) +
1
t
ψt(x)
}
.
Composite Mirror Descent Update (4):
xt+1 = argmin
x∈X
{η〈gt, x〉+ ηϕ(x) +Bψt(x, xt)}.
Figure 1: AdaGrad with diagonal matrices
Taking partial derivatives to find the infimum of L, we see that −‖g1:T,i‖22 /s2i −λi+ θ = 0,
and complementarity conditions on λisi (Boyd and Vandenberghe, 2004) imply that λi =
0. Thus we have si = θ
− 1
2 ‖g1:T,i‖2, and normalizing appropriately using θ gives that
si = c ‖g1:T,i‖2 /
∑d
j=1 ‖g1:T,j‖2. As a final note, we can plug si into the objective above to
see
inf
s
{
T
∑
t=1
d
∑
i=1
g2t,i
si
: s  0, 〈1, s〉 ≤ c
}
=
1
c
(
d
∑
i=1
‖g1:T,i‖2
)2
. (12)
Let diag(v) denote the diagonal matrix with diagonal v. It is natural to suspect that for s
achieving the infimum in Eq. (12), if we use a proximal function similar to ψ(x) = 〈x, diag(s)x〉
with associated squared dual norm ‖x‖2ψ∗ =
〈
x, diag(s)−1x
〉
, we should do well lowering the
gradient terms in the regret bounds (10) and (11).
To prove a regret bound for our Alg. 1, we note that both types of updates suffer losses
which include a term depending solely on the gradients obtained along their run. Thus,
the following lemma is applicable to both updates. (McMahan and Streeter (2010) use an
essentially identical lemma, which was originally proven by Auer and Gentile (2000).)
Lemma 4 Let gt = f
′
t(xt) and g1:t and st be defined as in Alg. 1. Then
T
∑
t=1
〈
gt, diag(st)
−1gt
〉
≤ 2
d
∑
i=1
‖g1:T,i‖2 .
Proof We prove the lemma by considering an arbitrary real-valued sequence {ai} and its
vector representation a1:i = [a1 · · · ai]. We are next going to show that
T
∑
t=1
a2t
‖a1:t‖2
≤ 2 ‖a1:T ‖2 , (13)
11
Duchi, Hazan, and Singer
where we define 00 = 0. We use induction on T to prove inequality (13). For T = 1, the
inequality trivially holds. Assume the bound (13) holds true for T − 1, in which case
T
∑
t=1
a2t
‖a1:t‖2
=
T−1
∑
t=1
a2t
‖a1:t‖2
+
a2T
‖a1:T ‖2
≤ 2 ‖a1:T−1‖2 +
a2T
‖a1:T ‖2
,
where the inequality follows from the inductive hypothesis. We define bT =
∑T
t=1 a
2
t and
use concavity to obtain that
√
bT − a2T ≤
√
bT − a2T 12√bT so long as bT − a
2
T ≥ 0.2 Thus,
2 ‖a1:T−1‖2 +
a2T
‖a1:T ‖2
= 2
√
bT − a2T +
a2T√
bT
≤ 2
√
bT = 2 ‖a1:T ‖2 .
Having proved the bound (13), we note that by construction that st,i = ‖g1:t,i‖2, so
T
∑
t=1
〈
gt, diag(st)
−1gt
〉
=
T
∑
t=1
d
∑
i=1
g2t,i
‖g1:t,i‖2
≤ 2
d
∑
i=1
‖g1:T,i‖2 .
To obtain a regret bound, we need to consider the terms consisting of the dual-norm
of the subgradient in the regret bounds (10) and (11), which is ‖f ′t(xt)‖2ψ∗t . When ψt(x) =
〈x, (δI + diag(st))x〉, it is easy to see that the associated dual-norm is
‖g‖2ψ∗t =
〈
g, (δI + diag(st))
−1g
〉
.
From the definition of st in Alg. 1, we clearly have ‖f ′t(xt)‖2ψ∗t ≤
〈
gt, diag(st)
−1gt
〉
. Note
that if st,i = 0 then gt,i = 0 by definition of st,i. Thus, for any δ ≥ 0, Lemma 4 implies
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
≤ 2
d
∑
i=1
‖g1:T,i‖2 . (14)
To obtain a bound for a primal-dual subgradient method, we set δ ≥ maxt ‖gt‖∞, in which
case ‖gt‖2ψ∗t−1 ≤
〈
gt, diag(st)
−1gt
〉
, and we follow the same lines of reasoning to achieve the
inequality (14).
It remains to bound the various Bregman divergence terms for Corollary 3 and the term
ψT (x
∗) for Corollary 2. We focus first on the composite mirror-descent update. Examining
the bound (11) and Alg. 1, we notice that
Bψt+1(x
∗, xt+1)−Bψt(x∗, xt+1) =
1
2
〈x∗ − xt+1, diag(st+1 − st)(x∗ − xt+1)〉
≤ 1
2
max
i
(x∗i − xt+1,i)2 ‖st+1 − st‖1 .
2. We note that we use an identical technique in the full-matrix case. See Lemma 8.
12
Adaptive Subgradient Methods
Since ‖st+1 − st‖1 = 〈st+1 − st, 1〉 and 〈sT , 1〉 =
∑d
i=1 ‖g1:T,i‖2, we have
T−1
∑
t=1
Bψt+1(x
∗, xt+1)−Bψt(x∗, xt+1) ≤
1
2
T−1
∑
t=1
‖x∗ − xt+1‖2∞ 〈st+1 − st, 1〉
≤ 1
2
max
t≤T
‖x∗ − xt‖2∞
d
∑
i=1
‖g1:T,i‖2 −
1
2
‖x∗ − x1‖2∞ 〈s1, 1〉 . (15)
We also have
ψT (x
∗) = δ ‖x∗‖22 + 〈x∗, diag(sT )x∗〉 ≤ δ ‖x∗‖
2
2 + ‖x∗‖
2
∞
d
∑
i=1
‖g1:T,i‖2 .
Combining the above arguments with Corollaries 2 and 3, and using (15) with the fact that
Bψ1(x
∗, x1) ≤ 12 ‖x∗ − x1‖
2
∞ 〈1, s1〉, we have proved the following theorem.
Theorem 5 Let the sequence {xt} be defined by Algorithm 1. For xt generated using the
primal-dual subgradient update (3) with δ ≥ maxt ‖gt‖∞, for any x∗ ∈ X ,
Rφ(T ) ≤
δ
η
‖x∗‖22 +
1
η
‖x∗‖2∞
d
∑
i=1
‖g1:T,i‖2 + η
d
∑
i=1
‖g1:T,i‖2 . (16)
For xt generated using the composite mirror-descent update (4), for any x
∗ ∈ X
Rφ(T ) ≤
1
2η
max
t≤T
‖x∗ − xt‖2∞
d
∑
i=1
‖g1:T,i‖2 + η
d
∑
i=1
‖g1:T,i‖2 . (17)
The above theorem is a bit unwieldy. We thus perform a few algebraic simplifications to
get the next corollary, which has a more intuitive form. Let us assume that X is compact
and set D∞ = supx∈X ‖x− x∗‖∞. Furthermore, define
γT ,
d
∑
i=1
‖g1:T,i‖2 = infs
{
T
∑
t=1
〈
gt, diag(s)
−1gt
〉
: 〈1, s〉 ≤
d
∑
i=1
‖g1:T,i‖2 , s  0
}
.
Also w.l.o.g. let 0 ∈ X . The following corollary is immediate (this is equivalent to Corol-
lary 1, though we have moved the
√
d term in the earlier bound).
Corollary 6 Assume that D∞ and γT are defined as above. For {xt} generated by Algo-
rithm 1 using the primal-dual subgradient update (3) with η = ‖x∗‖∞, for any x∗ ∈ X we
have
Rφ(T ) ≤ 2 ‖x∗‖∞ γT + δ
‖x∗‖22
‖x∗‖∞
≤ 2 ‖x∗‖∞ γT + δ ‖x∗‖1 .
Using the composite mirror descent update (4) to generate {xt} and setting η = D∞/
√
2,
we have
Rφ(T ) ≤
√
2D∞
d
∑
i=1
‖g1:T,i‖2 =
√
2D∞γT .
13
Duchi, Hazan, and Singer
As discussed in the introduction, Alg. 1 should have lower regret than non-adaptive
algorithms on sparse data, though this depends on the geometry of the underlying opti-
mization space X . For example, suppose that our learning problem is a logistic regression
with 0/1-valued features. Then the gradient terms are likewise based on 0/1-valued features
and sparse, so the gradient terms in the bound
∑d
i=1 ‖g1:T,i‖2 should all be much smaller
than
√
T . If some features appear much more frequently than others, then the infimal
representation of γT and the infimal equality in Corollary 1 show that we have significantly
lower regret by using higher learning rates for infrequent features and lower learning rates
on commonly appearing features. Further, if the optimal predictor is relatively dense, as is
often the case in predictions problems with sparse inputs, then ‖x∗‖∞ is the best p-norm
we can have in the regret.
More precisely, McMahan and Streeter (2010) show that if X is contained within an ℓ∞
ball of radius R and contains an ℓ∞ ball of radius r, then the bound in the above corollary
is within a factor of
√
2R/r of the regret of the best diagonal proximal matrix, chosen in
hindsight. So, for example, if X = {x ∈ Rd : ‖x‖p ≤ C}, then R/r = d1/p, which shows
that the domain X does effect the guarantees we can give on optimality of AdaGrad.
4. Full Matrix Proximal Functions
In this section we derive and analyze new updates when we estimate a full matrix for the
divergence ψt instead of a diagonal one. In this generalized case, we use the root of the
matrix of outer products of the gradients that we have observed to update our parameters.
As in the diagonal case, we build on intuition garnered from an optimization problem, and in
particular, we seek a matrix S which is the solution to the following minimization problem:
min
S
T
∑
t=1
〈
gt, S
−1gt
〉
s.t. S  0, tr(S) ≤ c . (18)
The solution is obtained by defining Gt =
∑t
τ=1 gτgτ
⊤ and setting S to be a normalized
version of the root of GT , that is, S = cG
1/2
T / tr(G
1/2
T ). For a proof, see Lemma 15 in
Appendix B.2, which also shows that when GT is not full rank we can instead use its pseudo-
inverse. If we iteratively use divergences of the form ψt(x) =
〈
x,G
1/2
t x
〉
, we might expect
as in the diagonal case to attain low regret by collecting gradient information. We achieve
our low regret goal by employing a similar doubling lemma to Lemma 4 and bounding the
gradient norm terms. The resulting algorithm is given in Alg. 2, and the next theorem
provides a quantitative analysis of the brief motivation above.
Theorem 7 Let Gt be the outer product matrix defined above and the sequence {xt} be
defined by Algorithm 2. For xt generated using the primal-dual subgradient update of (3)
and δ ≥ maxt ‖gt‖2, for any x∗ ∈ X
Rφ(T ) ≤
δ
η
‖x∗‖22 +
1
η
‖x∗‖22 tr(G
1/2
T ) + η tr(G
1/2
T ). (19)
For xt generated with the composite mirror-descent update of (4), if x
∗ ∈ X and δ ≥ 0
Rφ(T ) ≤
δ
η
‖x∗‖22 +
1
2η
max
t≤T
‖x∗ − xt‖22 tr(G
1/2
T ) + η tr(G
1/2
T ). (20)
14
Adaptive Subgradient Methods
Input: η > 0, δ ≥ 0
Variables: St ∈ Rd×d, Ht ∈ Rd×d, Gt ∈ Rd×d
Initialize x1 = 0, S0 = 0, H0 = 0, G0 = 0
For t = 1 to T
Suffer loss ft(xt)
Receive subgradient gt ∈ ∂ft(xt) of ft at xt
Update Gt = Gt−1 + gtg⊤t , St = G
1
2
t
Set Ht = δI + St, ψt(x) =
1
2〈x,Ht x〉
Primal-Dual Subgradient Update ((3)):
xt+1 = argmin
x∈X
{
η
〈
1
t
t
∑
τ=1
gτ , x
〉
+ ηϕ(x) +
1
t
ψt(x)
}
.
Composite Mirror Descent Update ((4)):
xt+1 = argmin
x∈X
{η〈gt, x〉+ ηϕ(x) +Bψt(x, xt)}.
Figure 2: AdaGrad with full matrices
Proof To begin, we consider the difference between the divergence terms at time t+1 and
time t from the regret (11) in Corollary 3. Let λmax(M) denote the largest eigenvalue of a
matrix M . We have
Bψt+1(x
∗, xt+1)−Bψt(x∗, xt+1) =
1
2
〈
x∗ − xt+1, (Gt+11/2 −Gt1/2)(x∗ − xt+1)
〉
≤ 1
2
‖x∗ − xt+1‖22 λmax(G
1/2
t+1 −G
1/2
t ) ≤
1
2
‖x∗ − xt+1‖22 tr(G
1/2
t+1 −G
1/2
t ) .
For the last inequality we used the fact that the trace of a matrix is equal to the sum of
its eigenvalues along with the property Gt+1
1/2−Gt1/2  0 (see Lemma 13 in Appendix B)
and therefore tr(G
1/2
t+1 −G
1/2
t ) ≥ λmax(G
1/2
t+1 −G
1/2
t ). Thus, we get
T−1
∑
t=1
Bψt+1(x
∗, xt+1)−Bψt(x∗, xt+1) ≤
1
2
T−1
∑
t=1
‖x∗ − xt+1‖22
(
tr(G
1/2
t+1)− tr(G
1/2
t )
)
.
Now we use the fact that G1 is a rank 1 PSD matrix with non-negative trace to see that
T−1
∑
t=1
‖x∗ − xt+1‖22
(
tr(G
1/2
t+1)− tr(G
1/2
t )
)
≤ max
t≤T
‖x∗ − xt‖22 tr(GT 1/2)− ‖x∗ − x1‖
2
2 tr(G
1/2
1 ) . (21)
It remains to bound the gradient terms common to all our bounds. We use the following
three lemmas, which essentially directly applicable. We prove the first two in Appendix B.1.
15
Duchi, Hazan, and Singer
Lemma 8 Let B  0 and B−1/2 denote the root of the inverse of B when B ≻ 0 and the
root of the pseudo-inverse of B otherwise. For any ν such that B − νgg⊤  0 the following
inequality holds.
2 tr((B − νgg⊤)1/2) ≤ 2 tr(B1/2)− ν tr(B−1/2gg⊤) .
Lemma 9 Let δ ≥ ‖g‖2 and A  0, then
〈
g, (δI +A1/2)−1g
〉
≤
〈
g,
(
(A+ gg⊤)†
)1/2
g
〉
.
Lemma 10 Let St = Gt
1/2 be as defined in Alg. 2 and A† denote the pseudo-inverse of A.
Then
T
∑
t=1
〈
gt, S
†
t gt
〉
≤ 2
T
∑
t=1
〈
gt, S
†
T gt
〉
= 2 tr(GT
1/2) .
Proof We prove the lemma by induction. The base case is immediate, since we have
〈
g1, (G
†
1)
1/2g1
〉
=
〈g1, g1〉
‖g1‖2
= ‖g1‖2 ≤ 2 ‖g1‖2 .
Now, assume the lemma is true for T − 1, so from the inductive assumption we get
T
∑
t=1
〈
gt, S
†
t gt
〉
≤ 2
T−1
∑
t=1
〈
gt, S
†
T−1gt
〉
+
〈
gT , S
†
T gT
〉
.
Since ST−1 does not depend on t we can rewrite
∑T−1
t=1
〈
gt, S
†
T−1gt
〉
as
tr
(
S†T−1,
T−1
∑
t=1
gtg
⊤
t
)
= tr((G†T−1)
1/2GT−1) ,
where the right-most equality follows from the definitions of St and Gt. Therefore, we get
T
∑
t=1
〈
gt, S
†
t gt
〉
≤ 2 tr((G†T−1)1/2GT−1) +
〈
gT , (G
†
T )
1/2gT
〉
= 2 tr(G
1/2
T−1) +
〈
gT , (G
†
T )
1/2gT
〉
.
Using Lemma 8 with the substitution B = GT , ν = 1, and g = gt lets us exploit the con-
cavity of the function tr(A1/2) to bound the above sum by 2 tr(G
1/2
T ). N
We can now finalize our proof of the theorem. As in the diagonal case, we have that the
squared dual norm (seminorm when δ = 0) associated with ψt is
‖x‖2ψ∗t =
〈
x, (δI + St)
−1x
〉
.
Thus it is clear that ‖gt‖2ψ∗t ≤
〈
gt, S
†
t gt
〉
. For the dual-averaging algorithms, we use
Lemma 9 above show that ‖gt‖2ψ∗t−1 ≤
〈
gt, S
†
t gt
〉
so long as δ ≥ ‖gt‖2. Lemma 10’s doubling
inequality then implies that
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
≤ 2 tr(G1/2T ) and
T
∑
t=1
∥
∥f ′t(xt)
∥
∥
2
ψ∗t−1
≤ 2 tr(G1/2T ) (22)
16
Adaptive Subgradient Methods
for the mirror-descent and primal-dual subgradient algorithm, respectively.
To finish the proof, Note that Bψ1(x
∗, x1) ≤ 12 ‖x∗ − x1‖
2
2 tr(G
1/2
1 ) when δ = 0. By com-
bining this with the first of the bounds (22) and the bound (21) on
∑T−1
t=1 Bψt+1(x
∗, xt+1)−
Bψt(x
∗, xt+1), Corollary 3 gives the theorem’s statement for the mirror-descent family of al-
gorithms. Combining the fact that
∑T
t=1 ‖f ′t(xt)‖
2
ψ∗t−1
≤ 2 tr(G1/2T ) and the bound (21) with
Corollary 2 gives the desired bound on Rφ(T ) for the primal-dual subgradient algorithms,
which completes the proof of the theorem.
As before, we can give a corollary that simplifies the bound implied by Theorem 7. The
infimal equality in the corollary uses Lemma 15 in Appendix B. The corollary underscores
that for learning problems in which there is a rotation U of the space for which the gradient
vectors gt have small inner products 〈gt, Ugt〉 (essentially a sparse basis for the gt) then
using full-matrix proximal functions can attain significantly lower regret.
Corollary 11 Assume that ϕ(x1) = 0. Then the regret of the sequence {xt} generated by
Algorithm 2 when using the primal-dual subgradient update with η = ‖x∗‖2 is
Rφ(T ) ≤ 2 ‖x∗‖2 tr(G
1/2
T ) + δ ‖x∗‖2 .
Let X be compact set so that supx∈X ‖x− x∗‖2 ≤ D. Taking η = D/
√
2 and using the
composite mirror descent update with δ = 0, we have
Rφ(T ) ≤
√
2D tr(G
1/2
T ) =
√
2dD
√
√
√
√inf
S
{
T
∑
t=1
g⊤t S
−1gt : S  0, tr(S) ≤ d
}
.
5. Derived Algorithms
In this section, we derive updates using concrete regularization functions ϕ and settings of
the domain X for the AdaGrad framework. We focus on showing how to solve Eqs. (3)
and (4) with the diagonal matrix version of the algorithms we have presented. We focus
on the diagonal case for two reasons. First, the updates often take closed-form in this
case and carry some intuition. Second, the diagonal case is feasible to implement in very
high dimensions, whereas the full matrix version is likely to be confined to a few thousand
dimensions. We also discuss how to efficiently compute the updates when the gradient
vectors are sparse.
We begin by noting a simple but useful fact. Let Gt denote either the outer product
matrix of gradients or its diagonal counterpart and let Ht = δI + G
1/2
t , as usual. Simple
algebraic manipulations yield that each of the updates (3) and (4) in the prequel can be
written in the following form (omitting the stepsize η):
xt+1 = argmin
x∈X
{
〈u, x〉+ ϕ(x) + 1
2
〈x,Htx〉
}
. (23)
In particular, at time t for the RDA update, we have u = ηtḡt. For the composite gradient
update (4),
η 〈gt, x〉+
1
2
〈x− xt, Ht(x− xt)〉 = 〈ηgt −Htxt, x〉+
1
2
〈x,Htx〉+
1
2
〈xt, Htxt〉
17
Duchi, Hazan, and Singer
so that u = ηgt−Htxt. We now derive algorithms for solving the general update (23). Since
most of the derivations are known, we generally provide only the closed-form solutions or
algorithms for the solutions in the remainder of the subsection, deferring detailed derivations
to Appendix E for the interested reader.
5.1 ℓ1-regularization
We begin by considering how to solve the minimization problems necessary for Alg. 1 with
diagonal matrix divergences and ϕ(x) = λ ‖x‖1. We consider the two updates we proposed
and denote the ith diagonal element of the matrix Ht = δI + diag(st) from Alg. 1 by
Ht,ii = δ + ‖g1:t,i‖2. For the primal-dual subgradient update, the solution to (3) amounts
to the following simple update for xt+1,i:
xt+1,i = sign (−ḡt,i)
ηt
Ht,ii
[|ḡt,i| − λ]+ . (24)
Comparing the update (24) to the standard dual averaging update (Xiao, 2010), which is
xt+1,i = sign (−ḡt,i) η
√
t [|ḡt,i| − λ]+ ,
it is clear that the difference distills to the step size employed for each coordinate. Our gen-
eralization of RDA yields a dedicated step size for each coordinate inversely proportional
to the time-based norm of the coordinate in the sequence of gradients. Due to the nor-
malization by this term the step size scales linearly with t, so when Ht,ii is small, gradient
information on coordinate i is quickly incorporated.
The composite mirror-descent update (4) has a similar form that essentially amounts to
iterative shrinkage and thresholding, where the shrinkage differs per coordinate:
xt+1,i = sign
(
xt,i −
η
Ht,ii
gt,i
)[∣
∣
∣
∣
xt,i −
η
Ht,ii
gt,i
∣
∣
∣
∣
− λη
Ht,ii
]
+
. (25)
We compare the actual performance of the newly derived algorithms to previously studied
versions in the next section.
For both updates it is clear that we can perform “lazy” computation when the gradient
vectors are sparse, a frequently occurring setting when learning for instance from text
corpora. Suppose that from time step t0 through t, the ith component of the gradient is
0. Then we can evaluate the above updates on demand since Ht,ii remains intact. For
composite mirror-descent, at time t when xt,i is needed, we update
xt,i = sign(xt0,i)
[
|xt0,i| −
λη
Ht0,ii
(t− t0)
]
+
.
Even simpler just in time evaluation can be performed for the the primal-dual subgradient
update. Here we need to keep an unnormalized version of the average ḡt. Concretely, we
keep track of ut = tḡt =
∑t
τ=1 gτ = ut−1 + gt, then use the update (24):
xt,i = sign(−ut,i)
ηt
Ht,ii
[ |ut,i|
t
− λ
]
+
,
where Ht can clearly be updated lazily in a similar fashion.
18
Adaptive Subgradient Methods
Input: v  0, a  0, c ≥ 0.
If
∑
i vi ≤ c return z∗ = v
Sort vi/ai into µ =
[
vij/aij
]
s.t. vij/aij ≥ vij+1/aij+1
Set ρ := max
{
ρ :
∑ρ
j=1 aijvij −
viρ
aiρ
∑ρ
j=1 a
2
ij
< c
}
Set θ =
∑ρ
j=1 aij vij−c∑ρ
j=1 a
2
ij
Return z∗ where z∗i = [vi − θai]+.
Figure 3: Project v  0 to {z : 〈a, z〉 ≤ c, z  0}.
5.2 ℓ1-ball Projections
We next consider the setting in which ϕ ≡ 0 and X = {x : ‖x‖1 ≤ c}, for which it is straight-
forward to adapt efficient solutions to continuous quadratic knapsack problems (Brucker,
1984). We use the matrix Ht = δI +diag(Gt)
1/2 from Alg. 1. We provide a brief derivation
sketch and an O(d log d) algorithm in this section. First, we convert the problem (23) into
a projection problem onto a scaled ℓ1-ball. By making the substitutions z = H
1/2x and
A = H−1/2, it is clear that problem (23) is equivalent to
min
z
∥
∥
∥
z +H−1/2u
∥
∥
∥
2
2
s.t. ‖Az‖1 ≤ c .
Now, by appropriate choice of v = −H−1/2u = −ηtH−1/2t ḡt for the primal-dual update (3)
and v = H
1/2
t xt − ηH
−1/2
t gt for the mirror-descent update (4), we arrive at the problem
min
z
1
2
‖z − v‖22 s.t.
d
∑
i=1
ai|zi| ≤ c . (26)
We can clearly recover xt+1 from the solution z
∗ to the projection (26) via xt+1 = H
−1/2
t z
∗.
By the symmetry of the objective (26), we can assume without loss of generality that
v  0 and constrain z  0, and a bit of manipulation with the Lagrangian (see Appendix E)
for the problem shows that the solution z∗ has the form
z∗i =
{
vi − θ∗ai if vi ≥ θ∗ai
0 otherwise
for some θ∗ ≥ 0. The algorithm in Figure 3 constructs the optimal θ and returns z∗.
5.3 ℓ2 Regularization
We now turn to the case where ϕ(x) = λ ‖x‖2 while X = Rd. This type of regularization
is useful for zeroing multiple weights in a group, for example in multi-task or multiclass
learning (Obozinski et al., 2007). Recalling the general proximal step (23), we must solve
min
x
〈u, x〉+ 1
2
〈x,Hx〉+ λ ‖x‖2 . (27)
There is no closed form solution for this problem, but we give an efficient bisection-based
procedure for solving (27). We start by deriving the dual. Introducing a variable z = x,
19
Duchi, Hazan, and Singer
Input: u ∈ Rd, H  0, λ > 0.
If ‖u‖2 ≤ λ
Return x = 0
Set v = H−1u, θmax = ‖v‖2 /λ− 1/σmin(H)
θmin = ‖v‖2 /λ− 1/σmax(H)
While θmax − θmin > ε
Set θ = (θmax + θmin)/2, α(θ) = −(H−1 + θI)−1v
If ‖α(θ)‖2 > λ
Set θmin = θ
Else
Set θmax = θ
Return x = −H−1(u+ α(θ))
Figure 4: Minimize 〈u, x〉+ 12 〈x,Hx〉+ λ ‖x‖2
we get the equivalent problem of minimizing 〈u, x〉 + 12 〈x,Hx〉 + λ ‖z‖2 subject to x = z.
With Lagrange multipliers α for the equality constraint, we obtain the Lagrangian
L(x, z, α) = 〈u, x〉+ 1
2
〈x,Hx〉+ λ ‖z‖2 + 〈α, x− z〉 .
Taking the infimum of L with respect to the primal variables x and z, we see that the
infimum is attained at x = −H−1(u+α). Coupled with the fact that infz λ ‖z‖2 − 〈α, z〉 =
−∞ unless ‖α‖2 ≤ λ, in which case the infimum is 0, we arrive at the dual form
inf
x,z
L(x, z, α) =
{
−12
〈
u+ α,H−1(u+ α)
〉
if ‖α‖2 ≤ λ
−∞ otherwise.
Setting v = H−1u, we further distill the dual to
min
α
〈v, α〉+ 1
2
〈
α,H−1α
〉
s.t. ‖α‖2 ≤ λ . (28)
We can solve problem (28) efficiently using a bisection search of its equivalent representation
in Lagrange form,
min
α
〈v, α〉+ 1
2
〈
α,H−1α
〉
+
θ
2
‖α‖22 ,
where θ > 0 is an unknown scalar. The solution to the latter as a function of θ is clearly
α(θ) = −(H−1+θI)−1v = −(H−1+θI)−1H−1u. Since ‖α(θ)‖2 is monotonically decreasing
in θ (consider the the eigen-decomposition of the positive definite H−1), we can simply
perform a bisection search over θ, checking at each point whether ‖α(θ)‖2 ≷ λ.
To find initial upper and lower bounds on θ, we note that
(1/σmax(H) + θ)
−1 ‖v‖2 ≤ ‖α(θ)‖2 ≤ (1/σmin(H) + θ)−1 ‖v‖2
where σmax(H) denotes the maximum singular value of H and σmin(H) the minimum. To
guarantee ‖α(θmax)‖2 ≤ λ, we thus set θmax = ‖v‖2 /λ − 1/σmax(H). Similarly, for θmin
we see that so long as θ ≥ ‖v‖2 /λ − 1/σmin(H) we have ‖α(θ)‖2 ≥ λ. The fact that
∂ ‖x‖2 = {z : ‖z‖2 ≤ 1} when x = 0 implies that the solution for the original problem (27)
is x = 0 if and only if ‖u‖2 ≤ λ. We provide pseudocode for solving (27) in Alg. 4.
20
Adaptive Subgradient Methods
5.4 ℓ∞ Regularization
We again let X = Rd but now choose ϕ(x) = λ ‖x‖∞. This type of update, similarly to
ℓ2, zeroes groups of variables, which is handy in finding structurally sparse solutions for
multitask or multiclass problems. Solving the ℓ∞ regularized problem amounts to
min
x
〈u, x〉+ 1
2
〈x,Hx〉+ λ ‖x‖∞ . (29)
The dual of this problem is a modified ℓ1-projection problem. As in the case of ℓ2 regu-
larization, we introduce an equality constrained variable z = x with associated Lagrange
multipliers α ∈ Rd to obtain
L(x, z, α) = 〈u, x〉+ 1
2
〈x,Hx〉+ λ ‖z‖∞ + 〈α, x− z〉 .
Performing identical manipulations to the ℓ2 case, we take derivatives and get that x =
−H−1(u+α) and, similarly, unless ‖α‖1 ≤ λ, infz L(x, z, α) = −∞. Thus the dual problem
for (29) is
max
α
− 1
2
(u+ α)H−1(u+ α) s.t. ‖α‖1 ≤ λ .
When H is diagonal we can find the optimal α∗ using the generalized ℓ1-projection in Alg. 3,
then reconstruct the optimal x via x = −H−1(u+ α∗).
5.5 Mixed-norm Regularization
Finally, we combine the above results to show how to solve problems with matrix-valued
inputs X ∈ Rd×k, where X = [x1 · · · xd]⊤. We consider mixed-norm regularization, which
is very useful for encouraging sparsity across several tasks (Obozinski et al., 2007). Now ϕ
is an ℓ1/ℓp norm, that is, ϕ(X) = λ
∑d
i=1 ‖xi‖p. By imposing an ℓ1-norm over p-norms of
the rows of X, entire rows are nulled at once.
When p ∈ {2,∞} and the proximal H in (23) is diagonal, the previous algorithms can
be readily used to solve the mixed norm problems. We simply maintain diagonal matrix
information for each of the rows x̄i of X separately, then solve one of the previous updates
for each row independently. We use this form of regularization in our experiments with
multiclass prediction problems in the next section.
6. Experiments
We performed experiments with several real world datasets with different characteristics:
the ImageNet image database (Deng et al., 2009), the Reuters RCV1 text classification
dataset (Lewis et al., 2004), the MNIST multiclass digit recognition problem, and the cen-
sus income dataset from the UCI repository (Asuncion and Newman, 2007). For uniformity
across experiments, we focus on the completely online (fully stochastic) optimization setting,
in which at each iteration the learning algorithm receives a single example. We measure
performance using two metrics: the online loss or error and the test set performance of
the predictor the learning algorithm outputs at the end of a single pass through the train-
ing data. We also give some results that show how imposing sparsity constraints (in the
21
Duchi, Hazan, and Singer
RDA FB AdaGrad-RDA AdaGrad-FB PA AROW
ECAT .051 (.099) .058 (.194) .044 (.086) .044 (.238) .059 .049
CCAT .064 (.123) .111 (.226) .053 (.105) .053 (.276) .107 .061
GCAT .046 (.092) .056 (.183) .040 (.080) .040 (.225) .066 .044
MCAT .037 (.074) .056 (.146) .035 (.063) .034 (.176) .053 .039
Table 1: Test set error rates and proportion non-zero (in parenthesis) on Reuters RCV1.
form of ℓ1 and mixed-norm regularization) affects the learning algorithm’s performance.
One benefit of the AdaGrad framework is its ability to straightforwardly generalize to do-
main constraints X 6= Rd and arbitrary regularization functions ϕ, in contrast to previous
adaptive online algorithms.
We experiment with RDA (Xiao, 2010), Fobos (Duchi and Singer, 2009), adaptive
RDA, adaptive Fobos, the Passive-Aggressive (PA) algorithm (Crammer et al., 2006), and
AROW (Crammer et al., 2009). To remind the reader, PA is an online learning procedure
with the update
xt+1 = argmin
x
[1− yt 〈zt, x〉]+ +
λ
2
‖x− xt‖22 ,
where λ is a regularization parameter. PA’s update is similar to the update employed
by AROW (see (9)), but the latter maintains second order information on x. By using a
representer theorem it is also possible to derive efficient updates for PA and AROW when
the loss is the logistic loss, log(1 + exp(−yt 〈zt, xt〉)). We thus we compare the above six
algorithms using both hinge and logistic loss.
6.1 Text Classification
The Reuters RCV1 dataset consists of a collection of approximately 800,000 text articles,
each of which is assigned multiple labels. There are 4 high-level categories, Economics,
Commerce, Medical, and Government (ECAT, CCAT, MCAT, GCAT), and multiple more
specific categories. We focus on training binary classifiers for each of the four major cate-
gories. The input features we use are 0/1 bigram features, which, post word stemming, give
data of approximately 2 million dimensions. The feature vectors are very sparse, however,
and most examples have fewer than 5000 non-zero features.
We compare the twelve different algorithms mentioned in the prequel as well as variants
of Fobos and RDA with ℓ1-regularization. We summarize the results of the ℓ1-regularized
runs as well as AROW and PA in Table 1. The results for both hinge and logistic losses
are qualitatively and quantitatively very similar, so we report results only for training with
the hinge loss in Table 1. Each row in the table represents the average of four different
experiments in which we hold out 25% of the data for a test set and perform an online pass
on the remaining 75% of the data. For RDA and Fobos, we cross-validate the stepsize
parameter η by simply running multiple passes and then choosing the output of the learner
that had the fewest mistakes during training. For PA and AROW we choose λ using the
same approach. We use the same regularization multiplier on the ℓ1 term for RDA and
Fobos, selected so that RDA achieved approximately 10% non-zero predictors.
It is evident from the results presented in Table 1 that the adaptive algorithms (AROW
and AdaGrad) are far superior to non-adaptive algorithms in terms of error rate on test
22
Adaptive Subgradient Methods
Alg. Avg. Prec. P@1 P@3 P@5 P@10 Prop. nonzero
AdaGrad RDA 0.6022 0.8502 0.8307 0.8130 0.7811 0.7267
AROW 0.5813 0.8597 0.8369 0.8165 0.7816 1.0000
PA 0.5581 0.8455 0.8184 0.7957 0.7576 1.0000
RDA 0.5042 0.7496 0.7185 0.6950 0.6545 0.8996
Table 2: Test set precision for ImageNet
data. The AdaGrad algorithms naturally incorporate sparsity as well since they are run
with ℓ1-regularization, though RDA has significantly higher sparsity levels (PA and AROW
do not have any sparsity). Furthermore, although omitted from the table to avoid clutter, in
every test with the RCV1 corpus, the adaptive algorithms outperformed the non-adaptive
algorithms. Moreover, both AdaGrad-RDA and AdaGrad-Fobos outperform AROW on
all the classification tasks. Unregularized RDA and Fobos attained similar results as did
the ℓ1-regularized variants (of course without sparsity), but we omit the results to avoid
clutter and because they do not give much more understanding.
6.2 Image Ranking
ImageNet (Deng et al., 2009) consists of images organized according to the nouns in the
WordNet hierarchy, where each noun is associated on average with more than 500 images
collected from the web. We selected 15,000 important nouns from the hierarchy and con-
ducted a large scale image ranking task for each noun. This approach is identical to the
task tackled by Grangier and Bengio (2008) using the Passive-Aggressive algorithm. To
solve this problem, we train 15,000 ranking machines using Grangier and Bengio’s visterms
features, which represent patches in an image with 79-dimensional sparse vectors. There
are approximately 120 patches per image, resulting in a 10,000-dimensional feature space.
Based on the results in the previous section, we focus on four algorithms for solving this
task: AROW, AdaGrad with RDA updates and ℓ1-regularization, vanilla RDA with ℓ1,
and Passive-Aggressive. We use the ranking hinge loss, which is [1− 〈x, z1 − z2〉]+ when
z1 is ranked above z2. We train a ranker xc for each of the image classes individually,
cross-validating the choice of initial stepsize for each algorithm on a small held-out set. To
train an individual ranker for class c, at each step of the algorithm we randomly sample a
positive image z1 for the category c and an image z2 from the training set (which with high
probability is a negative example for class c) and perform an update on the example z1−z2.
We let each algorithm take 100,000 such steps for each image category, we train four sets of
rankers with each algorithm, and the training set includes approximately 2 million images.
For evaluation, we use a distinct test set of approximately 1 million images. To evaluate
a set of rankers, we iterate through all 15,000 classes in the dataset. For each class we take
all the positive image examples in the test set and sample 10 times as many negative image
examples. Following Grangier and Bengio, we then rank the set of positive and negative
images and compute precision-at-k for k = {1, . . . , 10} and the average precision for each
category. The precision-at-k is defined as the proportion of examples ranked in the top k
for a category c that actually belong to c, and the average precision is the average of the
precisions at each position in which a relevant picture appears. Letting Pos(c) denote the
positive examples for category c and p(i) denote the position of the ith returned picture in
23
Duchi, Hazan, and Singer
0 1 2 3 4 5 6
x 10
4
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
Examples seen
M
is
ta
ke
s
 
 
PA
Ada RDA
RDA
Ada RDA L1/L2
RDA L1/L2
Figure 5: Learning curves on MNIST
list of images sorted by inner product with xc, the average precision is
1
|Pos(c)|
|Pos(c)|
∑
i=1
i
p(i)
.
We compute the mean of each measurement across all classes, performing this twelve times
for each of the sets of rankers trained. Table 2 summarizes our results. We do not re-
port variance as the variance was on the order of 10−5 for each algorithm. One apparent
characteristic to note from the table is that AdaGrad RDA achieves higher levels of spar-
sity than the other algorithms—using only 73% of the input features it achieves very high
performance. Moreover, it outperforms all the algorithms in average precision. AROW
has better results than the other algorithms in terms of precision-at-k for k ≤ 10, though
AdaGrad’s performance catches up to and eventually surpasses AROW’s as k grows.
6.3 Multiclass Optical Character Recognition
In the well-known MNIST multiclass classification dataset, we are given 28×28 pixel images
ai, and the learner’s task is to classify each image as a digit in {0, . . . , 9}. Linear classifiers
do not work well on a simple pixel-based representation. Thus we learn classifiers built
on top of a kernel machine with Gaussian kernels, as do Duchi and Singer (2009), which
gives a different (and non-sparse) structure to the feature space in contrast to our previous
experiments. In particular, for the ith example and jth feature, the feature value is zij =
K(ai, aj) , exp
(
− 1
2σ2
‖ai − aj‖22
)
. We use a support set of approximately 3000 images to
compute the kernels and trained multiclass predictors, which consist of one vector xc ∈ R3000
for each class c, giving a 30,000 dimensional problem. There is no known multiclass AROW
24
Adaptive Subgradient Methods
Test error rate Prop. nonzero
PA 0.062 1.000
Ada-RDA 0.066 1.000
RDA 0.108 1.000
Ada-RDA λ = 5 · 10−4 0.100 0.569
RDA λ = 5 · 10−4 0.138 0.878
Ada-RDA λ = 10−3 0.137 0.144
RDA λ = 10−3 0.192 0.532
Table 3: Test set error rates and sparsity proportions on MNIST. λ is the multiplier on
the ℓ1/ℓ2 norm.
algorithm. We therefore compare adaptive RDA with and without mixed-norm ℓ1/ℓ2 and
ℓ1/ℓ∞ regularization (see Sec. 5.5), RDA, and multiclass Passive Aggressive to one another
using the multiclass hinge loss (Crammer et al., 2006). For each algorithm we used the first
5000 of 60,000 training examples to choose the stepsize η (for RDA) and λ (for PA).
In Fig. 5, we plot the learning curves (cumulative mistakes made) of multiclass PA,
RDA, RDA with ℓ1/ℓ2 regularization, adaptive RDA, and adaptive RDA with ℓ1/ℓ2 regu-
larization (ℓ1/ℓ∞ is similar). From the curves, we see that Adaptive RDA seems to have
similar performance to PA, and the adaptive versions of RDA are vastly superior to their
non-adaptive counterparts. Table 3 further supports this, where we see that the adaptive
RDA algorithms outperform their non-adaptive counterparts both in terms of sparsity (the
proportion of non-zero rows) and test set error rates.
6.4 Income Prediction
The KDD census income dataset from the UCI repository (Asuncion and Newman, 2007)
contains census data extracted from 1994 and 1995 population surveys conducted by the
U.S. Census Bureau. The data consists of 40 demographic and employment related variables
which are used to predict whether a respondent has income above or below $50,000. We
quantize each feature into bins (5 per feature for continuous features) and take products of
features to give a 4001 dimensional feature space with 0/1 features. The data is divided
into a training set of 199,523 instances and test set of 99,762 test instances.
As in the prequel, we compare AROW, PA, RDA, and adaptive RDA with and without
ℓ1-regularization on this dataset. We use the first 10,000 examples of the training set to
select the step size parameters λ for AROW and PA and η for RDA. We perform ten ex-
periments on random shuffles of the training data. Each experiment consists of a training
pass through some proportion of the data (.05, .1, .25, .5, or the entire training set) and
computing the test set error rate of the learned predictor. Table 4 and Fig. 6 summarize the
results of these experiments. The variance of the test error rates is on the order of 10−6 so
we do not report it. As earlier, the table and figure make it clear that the adaptive methods
(AROW and AdaGrad-RDA) give better performance than non-adaptive methods. Fur-
ther, as detailed in the table, the AdaGrad methods can give extremely sparse predictors
that still give excellent test set performance. This is consistent with the experiments we
have seen to this point, where AdaGrad gives sparse but highly accurate predictors.
25
Duchi, Hazan, and Singer
0 0.2 0.4 0.6 0.8 1
0.044
0.046
0.048
0.05
0.052
0.054
0.056
Proportion train
T
es
t e
rr
or
 r
at
e
 
 
AROW
PA
RDA
Ada RDA
Figure 6: Test set error rates as function of proportion of training data seen on Census
Income dataset.
Prop. Train 0.05 0.10 0.25 0.50 1.00
AROW 0.049 0.048 0.046 0.045 0.044
PA 0.055 0.052 0.050 0.049 0.048
RDA 0.055 0.054 0.052 0.051 0.050
Ada-RDA 0.053 0.051 0.049 0.048 0.047
ℓ1 RDA 0.056 (0.075) 0.054 (0.066) 0.053 (0.058) 0.052 (0.053) 0.051 (0.050)
ℓ1 Ada-RDA 0.052 (0.062) 0.051 (0.053) 0.050 (0.044) 0.050 (0.040) 0.049 (0.037)
Table 4: Test set error rates as function of proportion of training data seen (proportion of
non-zeros in parenthesis where appropriate) on Census Income dataset.
6.5 Experiments with Sparsity-Accuracy Tradeoffs
In our final set of experiments, we investigate the tradeoff between the level of sparsity and
the classification accuracy for theAdaGrad-RDA algorithms. Using the same experimental
setup as for the initial text classification experiments described in Sec. 6.1, we record the
average test-set performance of AdaGrad-RDA versus the proportion of features that are
non-zero in the predictor AdaGrad outputs after a single pass through the training data.
To achieve this, we run AdaGrad with ℓ1-regularization, and we sweep the regularization
multiplier λ from 10−8 to 10−1. These values result in predictors ranging from a completely
dense predictor to an all-zeros predictor, respectively.
We summarize our results in Fig. 7, which shows the test set performance of AdaGrad
for each of the four categories ECAT, CCAT, GCAT, and MCAT. Within each plot, the
horizontal black line labeled AROW designates the baseline performance of AROW on the
26
Adaptive Subgradient Methods
ECAT CCAT
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
Proportion non−zero
T
es
t−
se
t e
rr
or
 r
at
e
 
 
AdaGrad
AROW
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
Proportion non−zero
T
es
t−
se
t e
rr
or
 r
at
e
 
 
AdaGrad
AROW
GCAT MCAT
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
Proportion non−zero
T
es
t−
se
t e
rr
or
 r
at
e
 
 
AdaGrad
AROW
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
0.02
0.04
0.06
0.08
0.1
0.12
0.14
0.16
Proportion non−zero
T
es
t−
se
t e
rr
or
 r
at
e
 
 
AdaGrad
AROW
Figure 7: Test set error rates as a function of proportion of non-zeros in predictor x output
by AdaGrad (AROW plotted for reference).
text classification task, though we would like to note that AROW generates fully dense
predictors. The plots all portray a similar story. With high regularization values, Ada-
Grad exhibits, as expected, poor performance as it retains no predictive information from
the learning task. Put another way, when the regularization value is high AdaGrad is
confined to an overly sparse predictor which exhibits poor generalization. However, as the
regularization multiplier λ decreases, the learned predictor becomes less sparse and eventu-
ally the accuracy of AdaGrad exceeds AROW’s accuracy. It is interesting to note that for
these experiments, as soon as the predictor resulting from a single pass through the data
has more than 1% non-zero coefficients, AdaGrad’s performance matches that of AROW.
We also would like to note that the variance in the test-set error rates for these experiments
is on the order of 10−6, and we thus do not draw error bars in the graphs. The performance
of AdaGrad as a function of regularization for other sparse datasets, especially in relation
to that of AROW, was qualitatively similar to this experiment.
27
Duchi, Hazan, and Singer
7. Conclusions
We presented a paradigm that adapts subgradient methods to the geometry of the prob-
lem at hand. The adaptation allows us to derive strong regret guarantees, which for some
natural data distributions achieve better performance guarantees than previous algorithms.
Our online regret bounds can be naturally converted into rate of convergence and gener-
alization bounds (Cesa-Bianchi et al., 2004). Our experiments show that adaptive meth-
ods, specifically AdaGrad-Fobos, AdaGrad-RDA, and AROW clearly outperform their
non-adaptive counterparts. Furthermore, the AdaGrad family of algorithms naturally in-
corporates regularization and gives very sparse solutions with similar performance to dense
solutions. Our experiments with adaptive methods use a diagonal approximation to the
matrix obtained by taking outer products of subgradients computed along the run of the
algorithm. It remains to be tested whether using the full outer product matrix can further
improve performance.
To conclude we would like to underscore a possible elegant generalization that inter-
polates between full-matrix proximal functions and diagonal approximations using block
diagonal matrices. Specifically, for v ∈ Rd let v = [v⊤[1] · · · v⊤[k]]⊤ where v[i] ∈ Rdi are sub-
vectors of v with
∑k
i=1 di = d. We can define the associated block-diagonal approximation
to the outer product matrix
∑t
τ=1 gτg
⊤
τ by
Gt =
t
∑
τ=1







gτ,[1]g
⊤
τ,[1] 0 · · · 0
0 gτ,[2]g
⊤
τ,[2]
. . . 0
...
. . .
. . . 0
0 · · · 0 gτ,[k]g⊤τ,[k]







.
In this case, a combination of Theorems 5 and 7 gives the next corollary.
Corollary 12 Let Gt be the block-diagonal outer product matrix defined above and the
sequence {xt} be defined by the RDA update of (3) with ψt(x) =
〈
x,G
1/2
t x
〉
. Then, for any
x∗ ∈ X ,
Rφ(T ) ≤
1
η
max
i
∥
∥
∥
x∗[i]
∥
∥
∥
2
2
tr(G
1/2
T ) + η tr(G
1/2
T ).
A similar bound holds for composite mirror-descent updates, and it is straightforward to
get infimal equalities similar to those in Corollary 11 with the infimum taken over block-
diagonal matrices. Such an algorithm can interpolate between the computational simplicity
of the diagonal proximal functions and the ability of full matrices to capture correlation in
the gradient vectors.
A few open questions stem from this line of research. The first is whether we can
efficiently use full matrices in the proximal functions, as in Section 4. A second open issue
is whether non-Euclidean proximal functions, such as the relative entropy, can be used.
We also think that the strongly convex case—when ft or ϕ is strongly convex—presents
interesting challenges that we have not completely resolved. We hope to investigate both
empirical and formal extensions of this work in the near future.
28
Adaptive Subgradient Methods
Acknowledgments
There are many people to whom we owe our sincere thanks for this research. Fernando
Pereira helped push us in the direction of working on adaptive online methods and has
been a constant source of discussion and helpful feedback. Samy Bengio provided us with
a processed version of the ImageNet dataset and was instrumental in helping to get our
experiments running, and Adam Sadovsky gave many indispensable coding suggestions.
The anonymous reviewers also gave several suggestions that improved the quality of the
paper. Lastly, Sam Roweis was a sounding board for some of our earlier ideas on the
subject, and we will miss him dearly.
Appendix A. Full Matrix Motivating Example
As in the diagonal case, as the adversary we choose ε > 0 and on rounds t = 1, . . . , η2/ε2
play the vector ±v1. After the first η2/ε2 rounds, the adversary simply cycles through the
vectors v2, . . . , vd. Thus, for Zinkevich’s projected gradient, we have xt = αt,1v1 for some
multiplier αt,1 > 0 when t ≤ η2/ε2. After the first η2/ε2 rounds, we perform the updates
xt+1 = Π‖x‖
2
≤
√
d
(
xt +
η√
t
vi
)
for some index i, but as in the diagonal case, η/
√
t ≤ ε, and by orthogonality of vi, vj , we
have xt = V αt for some αt  0, and the projection step can only shrink the multiplier
αt,i for index i. Thus, each coordinate incurs loss at least 1/(2ε), and projected gradient
descent suffers losses Ω(d/ε).
On the other hand, AdaGrad suffers loss at most d. Indeed, since g1 = v1 and ‖v1‖2 =
1, we have G21 = v1v
⊤
1 v1v
⊤
1 = v1v
⊤
1 = G1, so G1 = G
†
1 = G
1
2
1 , and
x2 = x1 +G
†
1 = x1 + v1v
⊤
1 v1 = x1 + v1.
Since 〈x2, v1〉 = 1, we see that AdaGrad suffers no loss (and Gt = G1) until a vector
zt = ±vi for i 6= 1 is played by the adversary. However, an identical argument shows that
Gt is simply updated to v1v
⊤
1 + viv
⊤
i , in which case xt = v1 + vi. Indeed, an inductive
argument shows that until all the vectors vi are seen, we have ‖xt‖2 <
√
d by orthogonality,
and eventually we have
xt =
d
∑
i=1
vi and ‖xt‖2 =
√
√
√
√
d
∑
i=1
‖vi‖22 =
√
d
so that xt ∈ X = {x : ‖x‖2 ≤
√
d} for AdaGrad for all t. All future predictions thus
achieve margin 1 and suffer no loss.
Appendix B. Technical Lemmas
Lemma 13 Let A  B  0 be symmetric d× d PSD matrices. Then A1/2  B1/2.
29
Duchi, Hazan, and Singer
Proof This is Example 3 of Davis (1963). We include a proof for convenience of the reader.
Let λ be any eigenvalue (with corresponding eigenvector x) of A1/2 − B1/2; we show that
λ ≥ 0. Clearly A1/2x−λx = B1/2x. Taking the inner product of both sides with A1/2x, we
have
∥
∥A1/2x
∥
∥
2
2
− λ
〈
A1/2x, x
〉
=
〈
A1/2x,B1/2x
〉
. We use the Cauchy-Schwarz inequality:
∣
∣
∣
∣
∥
∥
∥
A1/2x
∥
∥
∥
2
2
− λ
〈
A1/2x, x
〉
∣
∣
∣
∣
≤
∥
∥
∥
A1/2x
∥
∥
∥
2
∥
∥
∥
B1/2x
∥
∥
∥
2
=
√
〈Ax, x〉 〈Bx, x〉 ≤ 〈Ax, x〉 =
∥
∥
∥
A1/2x
∥
∥
∥
2
2
where the last inequality follows from the assumption that A  B. Thus we must have
λ
〈
A1/2x, x
〉
≥ 0, which implies λ ≥ 0.
The gradient of the function tr(Xp) is easy to compute for integer values of p. However,
when p is real we need the following lemma. The lemma tacitly uses the fact that there is
a unique positive semidefinite Xp when X  0 (Horn and Johnson, 1985, Theorem 7.2.6).
Lemma 14 Let p ∈ R and X ≻ 0. Then ∇Xtr(Xp) = pXp−1.
Proof We do a first order expansion of (X + A)p when X ≻ 0 and A is symmetric. Let
X = UΛU⊤ be the symmetric eigen-decomposition of X and V DV ⊤ be the decomposition
of Λ−1/2U⊤AUΛ−1/2. Then
(X +A)p = (UΛU⊤ +A)p = U(Λ + U⊤AU)pU⊤ = UΛp/2(I + Λ−1/2U⊤AUΛ−1/2)pΛp/2U⊤
= UΛp/2V ⊤(I +D)pV Λp/2U⊤ = UΛp/2V ⊤(I + pD + o(D))V Λp/2U⊤
= UΛpU⊤ + pUΛp/2V ⊤DV Λp/2U⊤ + o(UΛ−/2V ⊤DV Λp/2U⊤)
= Xp + UΛ(p−1)/2U⊤AUΛ(p−1)/2U⊤ + o(A) = Xp + pX(p−1)/2AX(p−1)/2 + o(A).
In the above, o(A) is a matrix that goes to zero faster than A → 0, and the second line
follows via a first-order Taylor expansion of (1+di)
p. From the above, we immediately have
tr((X +A)p) = trXp + p tr(Xp−1A) + o(trA),
which completes the proof.
B.1 Proof of Lemmas 8 and 9
We begin with the more difficult proof of Lemma 8.
Proof of Lemma 8 The core of the proof is based on the concavity of the function tr(A1/2).
However, careful analysis is required as A might not be strictly positive definite. We also
use the previous lemma which implies that the gradient of tr(A1/2) is 12A
−1/2 when A ≻ 0.
First, Ap is matrix-concave for A ≻ 0 and 0 ≤ p ≤ 1 (see, for example, Corollary 4.1
in Ando, 1979 or Theorem 16.1 in Bondar, 1994). That is, for A,B ≻ 0 and α ∈ [0, 1] we
have
(αA+ (1− α)B)p  αAp + (1− α)Bp . (30)
Now suppose simply A,B  0 (but neither is necessarily strict). Then for any δ > 0, we
have A+ δI ≻ 0 and B + δI ≻ 0 and therefore
(α(A+ δI) + (1− α)(B + δI))p  α(A+ δI)p + (1− α)(B + δI)p  αAp + (1− α)Bp ,
30
Adaptive Subgradient Methods
where we used Lemma 13 for the second matrix inequality. Moreover, αA+(1−α)B+δI →
αA+ (1− α)B as δ → 0. Since Ap is continuous (when we use the unique PSD root), this
line of reasoning proves that (30) holds for A,B  0. Thus, we proved that
tr((αA+ (1− α)B)p) ≥ α tr(Ap) + (1− α) tr(Bp) for 0 ≤ p ≤ 1 .
Recall now that Lemma 14 implies that the gradient of tr(A1/2) is 12A
−1/2 when A ≻ 0.
Therefore, from the concavity of A1/2 and the form of its gradient, we can use the standard
first-order inequality for concave functions so that for any A,B ≻ 0,
tr(A1/2) ≤ tr(B1/2) + 1
2
tr(B−1/2(A−B)) . (31)
Let A = B − νgg⊤  0 and suppose only that B  0. We must take some care since B−1/2
may not necessarily exist, and the above inequality does not hold true in the pseudo-inverse
sense when B 6≻ 0. However, for any δ > 0 we know that 2∇B tr((B+δI)1/2) = (B+δI)−1/2,
and A−B = −νgg⊤. From (31) and Lemma 13, we have
2 tr(B − tgg⊤)1/2 = 2 tr(A1/2) ≤ 2 tr((A+ δI)1/2)
≤ 2 tr(B + δI)1/2 − ν tr((B + δI)−1/2gg⊤) . (32)
Note that g ∈ Range(B), because if it were not, we could choose some u with Bu = 0 and
〈g, u〉 6= 0, which would give
〈
u, (B − cgg⊤)u
〉
= −c 〈g, u〉2 < 0, a contradiction. Now let
B = V diag(λ)V ⊤ be the eigen-decomposition of B. Since g ∈ Range(B),
g⊤(B + δI)−1/2g = g⊤V diag
(
1/
√
λi + δ
)
V ⊤g
=
∑
i:λi>0
1√
λi + δ
(g⊤vi)
2 −→
δ↓0
∑
i:λi>0
λ
−1/2
i (g
⊤vi)
2 = g⊤(B†)1/2g .
Thus, by taking δ ↓ 0 in (32), and since both tr(B + δI)1/2 and tr((B + δI)−1/2gg⊤) are
evidently continuous in δ, we complete the proof.
Proof of Lemma 9 We begin by noting that δ2I  gg⊤, so from Lemma 13 we get
(A + gg⊤)1/2  (A + δ2I)1/2. Since A and I are simultaneously diagonalizable, we can
generalize the inequality
√
a+ b ≤ √a +
√
b, which holds for a, b ≥ 0, to positive semi-
definite matrices, thus,
(A+ δ2I)1/2  A1/2 + δI .
Therefore, ifA+gg⊤ is of full rank, we have (A+gg⊤)−1/2  (A1/2+δI)−1 (Horn and Johnson,
1985, Corollary 7.7.4(a)). Since g ∈ Range((A+ gg⊤)1/2), we can apply an analogous lim-
iting argument to the one used in the proof of Lemma 8 and discard all zero eigenvalues of
A+ gg⊤, which completes the lemma.
31
Duchi, Hazan, and Singer
B.2 Solution to Problem (18)
We prove here a technical lemma that is useful in characterizing the solution of the opti-
mization problem below. Note that the second part of the lemma implies that we can treat
the inverse of the solution matrix S−1 as S†. We consider solving
min
S
tr(S−1A) subject to S  0, tr(S) ≤ c where A  0 . (33)
Lemma 15 If A is of full rank, then the minimizer of (33) is S = cA
1
2 / tr(A
1
2 ). If A is
not of full rank, then setting S = cA
1
2 / tr(A
1
2 ) gives
tr(S†A) = inf
S
{
tr(S−1A) : S  0, tr(S) ≤ c
}
.
In either case, tr(S†A) = tr(A
1
2 )2/c.
Proof Both proofs rely on constructing the Lagrangian for (33). We introduce θ ∈ R+ for
the trace constraint and Z  0 for the positive semidefinite constraint on S. In this case,
the Lagrangian is
L(S, θ, Z) = tr(S−1A) + θ(tr(S)− c)− tr(SZ).
The derivative of L with respect to S is
− S−1AS−1 + θI − Z. (34)
If S is full rank, then to satisfy the generalized complementarity conditions for the prob-
lem (Boyd and Vandenberghe, 2004), we must have Z = 0. Therefore, we get S−1AS−1 =
θI. We now can multiply by S on the right and the left to get that A = θS2, which implies
that S ∝ A 12 . If A is of full rank, the optimal solution for S ≻ 0 forces θ to be positive so
that tr(S) = c. This yields the solution S = cA
1
2 / tr(A
1
2 ). In order to verify optimality of
this solution, we set Z = 0 and θ = c−2 tr(A1/2)2 which gives ∇SL(S, θ, Z) = 0, as is indeed
required.
Suppose now thatA is not full rank and thatA = Q
[
Λ 0
0 0
]
Q⊤ is the eigen-decomposition
of A. Let n be the dimension of the null-space of A (so the rank of A is d− n). Define the
variables
Z(θ) =
[
0 0
0 θI
]
, S(θ, δ) =
1√
θ
Q
[
Λ
1
2 0
0 δI
]
Q⊤, S(δ) =
c
tr(A
1
2 ) + δn
Q
[
Λ
1
2 0
0 δI
]
Q⊤.
It is easy to see that trS(δ) = c, and clearly limδ→0 tr(S(δ)−1A) = tr(S(0)†A) = tr(A
1
2 ) tr(Λ
1
2 )/c =
tr(A
1
2 )2/c. Further, let g(θ) = infS L(S, θ, Z(θ)) be the dual of (33). From the above anal-
ysis and (34), it is evident that
−S(θ, δ)−1AS(θ, δ)−1 + θI − Z(θ) = −θQ
[
Λ−
1
2ΛΛ−
1
2 0
0 δ−2I · 0
]
Q⊤ + θI −
[
0 0
0 θI
]
= 0.
32
Adaptive Subgradient Methods
So S(θ, δ) achieves the infimum in the dual for any δ > 0, tr(S(0)Z(θ)) = 0, and
g(θ) =
√
θ tr(Λ
1
2 ) +
√
θ tr(Λ
1
2 ) +
√
θδn− θc.
Setting θ = tr(Λ
1
2 )2/c2 gives g(θ) = tr(Λ
1
2 )2/c − δn tr(Λ 12 )/c. Taking δ → 0 gives g(θ) =
tr(A
1
2 )2/c, which means that limδ→0 tr(S(δ)−1A) = tr(A
1
2 )2/c = g(θ). Thus the duality
gap for the original problem is 0 so S(0) is the limiting solution.
The last statement of the lemma is simply plugging S† = (A†)
1
2 tr(A
1
2 )/c in to the ob-
jective being minimized.
Appendix C. Proofs of Corollaries
Proof of Corollary 1 The proof corollary simply uses Theorem 5, Corollary 6, and the
fact that
inf
s
{
T
∑
t=1
d
∑
i=1
g2t,i
si
: s  0, 〈1, s〉 ≤ d
}
=
1
d
(
d
∑
i=1
‖g1:T,i‖2
)2
.
as in (12) in the beginning of Sec. 3. Plugging the γT term in from Corollary 6 and multi-
plying D∞ by
√
d completes the proof of the corollary.
Appendix D. Proofs of Propositions 2 and 3
We begin with the proof of Proposition 2. The proof essentially builds upon Xiao (2010)
and Nesterov (2009), with some modification to deal with the indexing of ψt. We include
the proof for completeness.
Proof of Proposition 2 Define ψ∗t to be the conjugate dual of tϕ(x) + ψt(x)/η:
ψ∗t (g) = sup
x∈X
{
〈g, x〉 − tϕ(x)− 1
η
ψt(x)
}
.
Since ψt/η is 1/η-strongly convex with respect to the norm ‖·‖ψt , the function ψ
∗
t has
η-Lipschitz continuous gradients with respect to ‖·‖ψ∗t :
‖∇ψ∗t (g1)−∇ψ∗t (g2)‖ψt ≤ η ‖g1 − g2‖ψ∗t (35)
for any g1, g2 (see, e.g., Nesterov, 2005, Theorem 1 or Hiriart-Urruty and Lemaréchal, 1996,
Chapter X). Further, a simple argument with the fundamental theorem of calculus gives
that if f has L-Lipschitz gradients, f(y) ≤ f(x) + 〈∇f(x), y − x〉+ (L/2) ‖y − x‖2, and
∇ψ∗t (g) = argmin
x∈X
{
−〈g, x〉+ tϕ(x) + 1
η
ψt(x)
}
. (36)
33
Duchi, Hazan, and Singer
Using the bound (35) and identity (36), we can give the proof of the corollary. Indeed,
letting gt ∈ ∂ft(xt) and defining zt =
∑t
τ=1 gτ , we have
T
∑
t=1
ft(xt) + ϕ(xt)− ft(x∗)− ϕ(x∗)
≤
T
∑
t=1
〈gt, xt − x∗〉 − ϕ(x∗) + ϕ(xt)
≤
T
∑
t=1
〈gt, xt〉+ ϕ(xt) + sup
x∈X
{
−
T
∑
t=1
〈gt, x〉 − Tϕ(x)−
1
η
ψT (x)
}
+ ψT (x
∗)
=
1
η
ψT (x
∗) +
T
∑
t=1
〈gt, xt〉+ ϕ(xt) + ψ∗T (−zT ) .
Since ψt+1 ≥ ψt, it is clear that
ψ∗T (−zT ) = −
T
∑
t=1
〈gt, xT+1〉 − Tϕ(xT+1)−
1
η
ψT (xT+1)
≤ −
T
∑
t=1
〈gt, xT+1〉 − (T − 1)ϕ(xT+1)− ϕ(xT+1)−
1
η
ψT−1(xT+1)
≤ sup
x∈X
(
−〈zT , x〉 − (T − 1)ϕ(x)−
1
η
ψT−1(x)
)
− ϕ(xT+1) = ψ∗T−1(−zT )− ϕ(xT+1).
The Lipschitz continuity of ∇ψ∗t , the identity (36), and the fact that zT − zT−1 = −gT give
T
∑
t=1
ft(xt) + ϕ(xt+1)− ft(x∗)− ϕ(x∗)
≤ 1
η
ψT (x
∗) +
T
∑
t=1
〈gt, xt〉+ ϕ(xt+1) + ψ∗T−1 (−zT )− ϕ(xT+1)
≤ 1
η
ψT (x
∗) +
T
∑
t=1
〈gt, xt〉+ ϕ(xt+1)− ϕ(xT+1)
+ ψ∗T−1 (−zT−1)−
〈
∇ψ∗T−1(zT−1), gT
〉
+
η
2
‖gT ‖2ψ∗T−1
=
1
η
ψT (x
∗) +
T−1
∑
t=1
〈gt, xt〉+ ϕ(xt+1) + ψ∗T−1(−zT−1) +
η
2
‖gT ‖2ψ∗T−1 .
We can repeat the same sequence of steps that gave the last equality to see that
T
∑
t=1
ft(xt) + ϕ(xt+1)− ft(x∗)− ϕ(x∗) ≤
1
η
ψT (x
∗) +
η
2
T
∑
t=1
‖gt‖2ψ∗t−1 + ψ
∗
0(−z0).
Recalling that x1 = argminx∈X {ϕ(x)} and that ψ∗0(0) = 0 completes the proof.
34
Adaptive Subgradient Methods
We now turn to the proof of Proposition 3. We begin by stating and fully proving an
(essentially) immediate corollary to Lemma 2.3 of Duchi et al. (2010).
Lemma 16 Let {xt} be the sequence defined by the update (4) and assume that Bψt(·, ·) is
strongly convex with respect to a norm ‖·‖ψt . Let ‖·‖ψ∗t be the associated dual norm. Then
for any x∗,
η (ft(xt)− ft(x∗)) + η (ϕ(xt+1)− ϕ(x∗)) ≤ Bψt(x∗, xt)−Bψt(x∗, xt+1) +
η2
2
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
Proof The optimality of xt+1 for (4) implies for all x ∈ X and ϕ′(xt+1) ∈ ∂ϕ(xt+1)
〈
x− xt+1, ηf ′(xt) +∇ψt(xt+1)−∇ψt(xt) + ηϕ′(xt+1)
〉
≥ 0. (37)
In particular, this obtains for x = x∗. From the subgradient inequality for convex functions,
we have ft(x
∗) ≥ ft(xt)+〈f ′t(xt), x∗ − xt〉, or ft(xt)−ft(x∗) ≤ 〈f ′t(xt), xt − x∗〉, and likewise
for ϕ(xt+1). We thus have
η [ft(xt) + ϕ(xt+1)− ft(x∗)− ϕ(x∗)]
≤ η
〈
xt − x∗, f ′t(xt)
〉
+ η
〈
xt+1 − x∗, ϕ′(xt+1)
〉
= η
〈
xt+1 − x∗, f ′t(xt)
〉
+ η
〈
xt+1 − x∗, ϕ′(xt+1)
〉
+ η
〈
xt − xt+1, f ′t(xt)
〉
=
〈
x∗ − xt+1,∇ψt(xt)−∇ψt(xt+1)− ηf ′t(xt)− ηϕ′(xt+1)
〉
+ 〈x∗ − xt+1,∇ψt(xt+1)−∇ψt(xt)〉+ η
〈
xt − xt+1, f ′t(xt)
〉
.
Now, by (37), the first term in the last equation is non-positive. Thus we have that
η [ft(xt) + ϕ(xt+1)− ft(x∗)− ϕ(x∗)]
≤ 〈x∗ − xt+1,∇ψt(xt+1)−∇ψt(xt)〉+ η
〈
xt − xt+1, f ′t(xt)
〉
= Bψt(x
∗, xt)−Bψt(xt+1, xt)−Bψt(x∗, xt+1) + η
〈
xt − xt+1, f ′t(xt)
〉
= Bψt(x
∗, xt)−Bψt(xt+1, xt)−Bψt(x∗, xt+1) + η
〈
η−
1
2 (xt − xt+1),
√
ηf ′t(xt)
〉
≤ Bψt(x∗, xt)−Bψt(xt+1, xt)−Bψt(x∗, xt+1) +
1
2
‖xt − xt+1‖2ψt +
η2
2
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
≤ Bψt(x∗, xt)−Bψt(x∗, xt+1) +
η2
2
∥
∥f ′t(xt)
∥
∥
2
ψ∗t
.
In the above, the first equality follows from simple algebra with Bregman divergences, the
second to last inequality follows from Fenchel’s inequality applied to the conjugate functions
1
2 ‖·‖
2
ψt
and 12 ‖·‖
2
ψ∗t
(Boyd and Vandenberghe, 2004, Example 3.27), and the last inequality
follows from the assumed strong convexity of Bψt with respect to the norm ‖·‖ψt .
Proof of Proposition 3 Sum the equation in the conclusion of the above lemma.
35
Duchi, Hazan, and Singer
Appendix E. Derivations of Algorithms
ℓ1-regularization We give the derivation for the primal-dual subgradient update, as com-
posite mirror-descent is entirely similar. We need to solve update (3), which amounts to
min
x
η 〈ḡt, x〉+
1
2t
δ ‖x‖22 +
1
2t
〈x, diag(st)x〉+ ηλ ‖x‖1 .
Let x̂ denote the optimal solution of the above optimization problem. Standard subgradient
calculus implies that when |ḡt,i| ≤ λ the solution is x̂i = 0. Similarly, when ḡt,i < −λ, then
x̂i > 0, the objective is differentiable, and the solution is obtained by setting the gradient
to zero:
ηḡt,i +
Ht,ii
t
x̂i + ηλ = 0 , so that x̂i =
ηt
Ht,ii
(−ḡt,i − λ) .
Likewise, when ḡt,i > λ then x̂i < 0, and the solution is x̂i =
ηt
Ht,ii
(−ḡt,i + λ). Combining
the three cases, we obtain the simple update (24) for xt+1,i.
ℓ1-ball projections The derivation we give is somewhat terse, and we refer the interested
reader to Brucker (1984) or Pardalos and Rosen (1990) for more depth. Recall that our
original problem (26) is symmetric in its objective and constraints, so we assume without
loss of generality that v  0 (otherwise, we reverse the sign of each negative component in
v, then flip the sign of the corresponding component in the solution vector). This gives
min
z
1
2
‖z − v‖22 s.t. 〈a, z〉 ≤ c, z  0 . (38)
Clearly, if 〈a, v〉 ≤ c the optimal z∗ = v, hence we assume that 〈a, v〉 > c. We also assume
without loss of generality that vi/ai ≥ vi+1/ai+1 for simplicity of our derivation. (We revisit
this assumption at the end of the derivation.) Introducing Lagrange multipliers θ ∈ R+ for
the constraint that 〈a, z〉 ≤ c and α ∈ Rd+ for the positivity constraint on z, we get
L(z, α, θ) = 1
2
‖z − v‖22 + θ(〈a, z〉 − c)− 〈α, z〉 .
Computing the gradient of L, we have ∇zL(z, α, θ) = z− v+ θa−α. Suppose that we knew
the optimal θ∗ ≥ 0. Using the complementarity conditions on z and α for optimality of
z (Boyd and Vandenberghe, 2004), we see that the solution z∗i satisfies
z∗i =
{
vi − θ∗ai if vi ≥ θ∗ai
0 otherwise .
Analogously, the complimentary conditions on 〈a, z〉 ≤ c show that given θ∗, we have
d
∑
i=1
ai [vi − θ∗ai]+ = c or
d
∑
i=1
a2i
[
vi
ai
− θ∗
]
+
= c .
Conversely, had we obtained a value θ ≥ 0 satisfying the above equation, then θ would
evidently induce the optimal z∗ through the equation zi = [vi − θai]+.
36
Adaptive Subgradient Methods
Now, let ρ be the largest index in {1, . . . , d} such that vi − θ∗ai > 0 for i ≤ ρ and
vi − θ∗ai ≤ 0 for i > ρ. From the assumption that vi/ai ≤ vi+1/ai+1, we have vρ+1/aρ+1 ≤
θ∗ < vρ/aρ. Thus, had we known the last non-zero index ρ, we would have obtained
ρ
∑
i=1
aivi −
vρ
aρ
ρ
∑
i=1
a2i =
ρ
∑
i=1
a2i
(
vi
ai
− vρ
aρ
)
< c ,
ρ
∑
i=1
aivi −
vρ+1
aρ+1
ρ
∑
i=1
a2i =
ρ+1
∑
i=1
a2i
(
vi
ai
− vρ+1
aρ+1
)
≥ c .
Given ρ satisfying the above inequalities, we can reconstruct the optimal θ∗ by noting that
the latter inequality should equal c exactly when we replace vρ/aρ with θ, that is,
θ∗ =
∑ρ
i=1 aivi − c
∑ρ
i=1 a
2
i
. (39)
The above derivation results in the following procedure (when 〈a, v〉 > c). We sort v in de-
scending order of vi/ai and find the largest index ρ such that
∑ρ
i=1 aivi−(vρ/aρ)
∑ρ−1
i=1 a
2
i <
c. We then reconstruct θ∗ using equality (39) and return the soft-thresholded values of vi
(see Alg. 3). It is easy to verify that the algorithm can be implemented in O(d log d) time. A
randomized search with bookkeeping (Pardalos and Rosen, 1990) can be straightforwardly
used to derive a linear time algorithm.
References
J. Abernethy, P. Bartlett, A. Rakhlin, and A. Tewari. Optimal strategies and minimax lower
bounds for online convex games. In Proceedings of the Twenty First Annual Conference
on Computational Learning Theory, 2008.
T. Ando. Concavity of certain maps on positive definite matrices and applications to
Hadamard products. Linear Algebra and its Applications, 26:203–241, 1979.
A. Asuncion and D. J. Newman. UCI machine learning repository, 2007. URL
http://www.ics.uci.edu/~mlearn/MLRepository.html.
P. Auer and C. Gentile. Adaptive and self-confident online learning algorithms. In Proceed-
ings of the Thirteenth Annual Conference on Computational Learning Theory, 2000.
P. L. Bartlett, E. Hazan, and A. Rakhlin. Adaptive online gradient descent. In Advances
in Neural Information Processing Systems 20, 2007.
A. Beck and M. Teboulle. Mirror descent and nonlinear projected subgradient methods for
convex optimization. Operations Research Letters, 31:167–175, 2003.
J. V. Bondar. Comments on and complements to Inequalities: Theory of Majorization and
Its Applications. Linear Algebra and its Applications, 199:115–129, 1994.
A. Bordes, L. Bottou, and P. Gallinari. Sgd-qn: Careful quasi-newton stochastic gradient
descent. Journal of Machine Learning Research, 10:1737–1754, 2009.
37
Duchi, Hazan, and Singer
S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004.
P. Brucker. An O(n) algorithm for quadratic knapsack problems. Operations Research
Letters, 3(3):163–166, 1984.
N. Cesa-Bianchi, A. Conconi, and C. Gentile. On the generalization ability of on-line learn-
ing algorithms. IEEE Transactions on Information Theory, 50(9):2050–2057, September
2004.
N. Cesa-Bianchi, A. Conconi, , and C. Gentile. A second-order perceptron algorithm. SIAM
Journal on Computing, 34(3):640–668, 2005.
N. Cesa-Bianchi, Y. Mansour, and G. Stoltz. Improved second-order bounds for prediction
with expert advice. Machine Learning, 66:321–352, 2007.
K. Crammer, O. Dekel, J. Keshet, S. Shalev-Shwartz, and Y. Singer. Online passive aggres-
sive algorithms. Journal of Machine Learning Research, 7:551–585, 2006.
K. Crammer, M. Dredze, and F. Pereira. Exact convex confidence-weighted learning. In
Advances in Neural Information Processing Systems 22, 2008.
K. Crammer, M. Dredze, and A. Kulesza. Adaptive regularization of weight vectors. In
Advances in Neural Information Processing Systems 23, 2009.
C. Davis. Notions generalizing convexity for functions defined on spaces of matrices. In
Proceedings of the Symposia in Pure Mathematics, volume 7, pages 187–201. American
Mathematical Society, 1963.
J. Deng, W. Dong, R. Socher, L. Li, K. Li, and L. Fei-Fei. ImageNet: a large-scale hierar-
chical image database. In Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, 2009.
J. Duchi and Y. Singer. Efficient online and batch learning using forward backward splitting.
Journal of Machine Learning Research, 10:2873–2908, 2009.
J. Duchi, S. Shalev-Shwartz, Y. Singer, and A. Tewari. Composite objective mirror descent.
In Proceedings of the Twenty Third Annual Conference on Computational Learning The-
ory, 2010.
R. Fletcher. A new approach to variable metric algorithms. Computer Journal, 13:317–322,
1970.
D. Grangier and S. Bengio. A discriminative kernel-based model to rank images from text
queries. IEEE Transactions on Pattern Analysis and Machine Intelligence, 30(8):1371–
1384, 2008.
E. Hazan and S. Kale. Extracting certainty from uncertainty: regret bounded by variation in
costs. In Proceedings of the Twenty First Annual Conference on Computational Learning
Theory, 2008.
38
Adaptive Subgradient Methods
E. Hazan, A. Kalai, S. Kale, and A. Agarwal. Logarithmic regret algorithms for online con-
vex optimization. In Proceedings of the Nineteenth Annual Conference on Computational
Learning Theory, 2006.
Jean-Baptiste Hiriart-Urruty and Claude Lemaréchal. Convex Analysis and Minimization
Algorithms II. Springer-Verlag, 1996.
Roger A. Horn and Charles R. Johnson. Matrix Analysis. Cambridge University Press,
1985.
A. Juditsky, A. Nemirovski, and C. Tauvel. Solving variational inequalities with the stochas-
tic mirror-prox algorithm. http://arxiv.org/abs/0809.0815, 2008.
A. Kalai and S. Vempala. Efficient algorithms for online decision problems. Journal of
Computer and System Sciences, 71(3):291–307, 2003.
G. Lan. An optimal method for stochastic composite optimization. Mathematical Program-
ming Series A, 2010. Online first; to appear.
David Lewis, Yiming Yang, Tony Rose, and Fan Li. RCV1: A new benchmark collection
for text categorization research. Journal of Machine Learning Research, 5:361–397, 2004.
H. B. McMahan and M. Streeter. Adaptive bound optimization for online convex optimiza-
tion. In Proceedings of the Twenty Third Annual Conference on Computational Learning
Theory, 2010.
A. Nedić. Subgradient Methods for Convex Minimization. PhD thesis, Massachusetts Insti-
tute of Technology, 2002.
A. Nemirovski, A. Juditsky, G. Lan, and A. Shapiro. Robust stochastic approximation
approach to stochastic programming. SIAM Journal on Optimization, 19(4):1574–1609,
2009.
A. S. Nemirovski and D. B. Yudin. Problem Complexity and Efficiency in Optimization.
John Wiley and Sons, 1983.
Y. Nesterov. Smooth minimization of nonsmooth functions. Mathematical Programming,
103:127–152, 2005.
Y. Nesterov. Primal-dual subgradient methods for convex problems. Mathematical Pro-
gramming, 120(1):221–259, 2009.
G. Obozinski, B. Taskar, and M. Jordan. Joint covariate selection for grouped classification.
Technical Report 743, Dept. of Statistics, University of California Berkeley, 2007.
P. M. Pardalos and J. B. Rosen. An algorithm for a singly constrained class of quadratic
programs subject to upper and lower bounds. Mathematical Programming, 46:321–328,
1990.
A. Rakhlin. Lecture notes on online learning. For the Statistical Machine Learning Course
at University of California, Berkeley, 2009.
39
Duchi, Hazan, and Singer
G. Salton and C. Buckley. Term weighting approaches in automatic text retrieval. Infor-
mation Processing and Management, 24(5), 1988.
N. Z. Shor. Utilization of the operation of space dilation in the minimization of convex func-
tions. Cybernetics and Systems Analysis, 6(1):7–15, 1972. Translated from Kibernetika.
P. Tseng. On accelerated proximal gradient methods for convex-concave optimization.
Technical report, Department of Mathematics, University of Washington, 2008.
L. Xiao. Dual averaging methods for regularized stochastic learning and online optimization.
Technical Report MSR-TR-2010-23, Microsoft Research, 2010.
M. Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In
Proceedings of the Twentieth International Conference on Machine Learning, 2003.
40

