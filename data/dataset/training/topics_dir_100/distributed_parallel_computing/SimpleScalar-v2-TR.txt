The SimpleScalar Tool Set, Version 2.0 
Doug Burger* Todd M. Austin 
Computer Sciences Department 
University of  Wisconsin-Madison 
1210 West Dayton Street 
Madison, Wisconsin 53706 USA 
MicroComputer Research Labs, JF3-359 
Intel Corporation, 2111 NE 25th Avenue 
Hillsboro, OR 97124 USA 
*Contact: dburger@cs.wisc.edu 
http://www.cs.wisc.edu/-mscalar/simplescalar.html 
This document describes release 2.0 o f  the $impleScalar tool 
set, a suite o f  free, publicly available simulation tools that offer 
both detailed and high-performance simulation o f  modern micro- 
processors. The new release offers more tools and capabilities, 
precompiled binaries, cleaner interfaces, better documentation, 
easier installation, improved portability, and higher perfor- 
mance. This paper contains a complete description o f  the tool 
set, including retrieval and installation instructions, a descrip- 
tion o f  how to use the tools, a description o f  the target SimpleS- 
calar architecture, and many details about the internals o f  the 
tools and how to customize them. With this guide, the tool set can 
be brought up and generating results in under an hour (on sup- 
ported plafforms ). 
1 Overview 
Modern processors are incredibly complex marvels of engi- 
neering that are becoming increasingly hard to evaluate. This 
paper describes the SimpleScalar tool set (release 2.0), which 
performs fast, flexible, and accurate simulation of modem pro- 
cessors that implement the SimpleScalar architecture (a close 
derivative of the MIPS architecture [4]). The tool set takes bina- 
ries compiled for the SimpleScalar architecture and simulates 
their execution on one of several provided processor simulators. 
We provide sets of precompiled binaries (including SPEC95), 
plus a modified version of GNU GCC (with associated utilities) 
that allows you to compile your own SimpleScalar test binaries 
from FORTRAN or C code. 
The advantages of the SimpleScalar tools are high flexibility, 
portability, extensibility, and performance. We include five e~e- 
cution-driven processor simulators in the release. They range 
from an extremely fast functional simulator to a detailed, out-of- 
order issue, superscalar processor simulator that supports non- 
blocking caches and speculative execution. 
The tool set is portable, requiring only that the GNU tools 
may be installed on the host system. The tool set has been tested 
extensively on many platforms (listed in Section 2). The tool set 
is easily extensible. We designed the instruction set to support 
This work was initially supported by NSF Grants CCR-9303030, CCR- 
9509589, and MIP-9505853, ONR Grant N00014-93-I-0465. a donation 
from Intei Corp., and by U.S. Army Intelligence Center and Fort Hua- 
chuca under Contract DABT63-95-C-0127 and ARPA order nn. D346. 
The current support for this work comes from a variety of sources, all of 
to which we are indebted. 
easy annotation of instructions, without requiring a retargeted 
compiler for incremental changes. The instruction definition 
method, along with the ported GNU tools, makes new simulators 
easy to write, and the old ones even simpler to extend. Finally, 
the simulators have been aggressively toned for performance, 
and can run codes approaching "'real" sizes in tractable amounts 
of time. On a 200-MHz Pentium Pro, the fastest, least detailed 
simulator simulates about four million machine cycles per sec- 
ond, whereas the most detailed processor simulator simulates 
about 150,000 per second. 
The current release (version 2.0) of the tools is a major 
improvement over the previous release. Compared to version 1.0, 
this release includes better documentation, enhanced perfor- 
mane.e, compatibility with more platforms, precompiled SPEC95 
SimpleScaiar binaries, cleaner interfaces, two new processor 
simulators, option and statistic management packages, a source- 
level debugger (DLite!) and a tool to trace the out-of-order pipe- 
line. 
The rest of this document contains information about obtain- 
ing, installing, running, using, and modifying the tool set. In 
Section 2 we provide a detailed procedure for downloading the 
release, installing it, and getting it up and running. In Section 3, 
we describe the SimpleScalar architecture and details about the 
target (simulated) system. In Section 4, we describe the SimpleS- 
calar processor simulators and discuss their internal workings. In 
Section 5, we describe two tools that enhance the utility of the 
tool set: a pipeline tracer and a source-level debugger (for step- 
ping through the program being simulated). In Section 6, we pro- 
vide the history of the tools' development, describe current and 
planned efforts to extend the tool set, and conclude. 
2 Installation and Use 
The only restrictions on using and distributing the tool set are 
that (1) the copyright notice must accompany all re-releases of 
the tool set, and (2) third parties (i.e., you) are forbidden to place 
any additional distribution restrictions on extensions to the tool 
set that you release. The copyright notice can be found in the dis- 
tribution directory as well as at the head of all simulator source 
files. We have included the copyright here as well: 
Copyright (C) 1994, 1995, 1996, 1997 by Todd M. Austin 
This tool set is distributed "as is" in the hope that it will be 
useful. The tool set comes with no warranty, and no author or 
m l 3 m  
distributor accepts any responsibility f o r  the consequences o f  its 
~ s e .  
Everyone is granted permission to copy, modify and redistrib- 
ute this tool set  under the fol lowing conditions: 
• T~'s tool set is distributed f o r  non-commercial use only. 
Pleuse contact the maintainer f o r  restrictions applying to 
commercial  use o f  these tools. 
• Permission is granted to anyone to make or  distribute cop- 
ies o f  this tool set, either as received or  modified, in any 
medium, provided that all copyright notices, permission and 
nonwarranty notices are preserved, and that the distributor 
grants the recipient permission f o r  fur ther  redistribution as 
permit ted by this document. 
• Permission is granted to distribute these tools in compiled 
or executable fo rm under the same conditior~v that apply f o r  
source code, provided that either: (1) it  is accompanied by 
the corresponding machine-readable source code, or  (2) it 
i$ accompanied by a written offer, with no time limit, to give 
anyone a machine-readable copy o f  the corresponding 
source code in return f o r  reimbursement o f  the cost o f  distri- 
bution. This written offer must  permit  verbatim duplication 
by anyone, or O)  it is distributed by someone who received 
only the executable form, and is accompanied by a copy o f  
the written offer o f  source code that they received concur- 
rently. 
In other words, you are welcome to use, share and improve 
these tools. You are forbidden to forbid anyone else to use, share 
and improve what you give them. 
2.1 Obtaining the tools 
The tools can either be obtained through the World Wide 
Web, or by conventional ftp. For example, to get the file q i m -  
p l e s i m ,  t a r .  gz  via the WWW, enter the URL: 
f t p  : I / f t p .  c s  . w £ s c .  e d u / s o h i / c o d e / s 4  ~ l e e e a l a r l  
sim~lesim, tar 
and to obtain the same file with traditional ftp: 
ftp ftI~ - os .wise. edu 
u m e E  : LIIOI¢I~qilOUB 
p a s s w o r d :  e n t e r  y o u r  e - m a L l  a d d r e s s  h e r e  
o d  s e h £ / C o d e / s ~ l e s c a l a r  
get simplesim, tar 
Note the "tar.gz" suffix: by requesting the file without the ".gz" 
suffix, the ftp server uncompresses it automatically. To get the 
compressed version, simply request the file with the ".gz" suffix. 
The five distribution files in the directory (which are symboIic 
links to the files containing the latest version of the tools) are: 
• simplesim.tar .gz - contains the simulator sources, the 
instruction set definition macros, and test program source 
and binaries. The directory is 1 MB compressed and 4 MB 
uncompressed. When the simulators are built, the directory 
(including object files) will require 11 MB. This file is 
required for installation of the tool set. 
• s impleuli ls . tar .gz - contains the GNU binutils source (ver- 
sion 2.5.2), retargeted to the SimpleScalar architecture. 
These utilities are not required to run the simulators them- 
selves, but is required to compile your own SimpleScalar 
benchmark binaries (e.g. test programs other than the ones 
we provide). The compressed file is 3 MB, the uncom- 
pressed file is 14 MB, and the build requires 52 MB. 
• s imple too ls . t a r .p  - contains the retargeted GNU compiler 
and library sources needed to build SimpleScalar bench- 
mark binaries (GCC 2.6.3, glibc 1.0.9, and f2c), as well as 
pre-built big- and little-endian versions of libc. This file is 
needed only to build benchmarks, not to compile or mn  the 
simulators. The tools are 11 MB compressed, 47 MB 
uncompressed, and the full installation requires 70 MB. 
• s implebeneh.big. tar .gz - contains a set of  the SPEC95 
benchmark binaries, compiled to the SimpleScalar architec- 
ture running on a big-endian host. The binaries take under 5 
MB compressed, and are 29 MB when uncompressed. 
• simplebench.l i t t le . tar .gz - same as above, except that the 
binaries were compiled to the SimpleScalar architecture 
running on a little-endian host. 
Once you have selected the appropriate files, place the down- 
loaded files into the desired target directory. If  you obtained the 
files with the ".gz" suffix, run the GNU decompress utility (gun- 
zip). The files should now have a ".tar" suffix. To remove the 
directories from the archive: 
t a r  x f  f J . l a n s m e . t a ~  
If you download and unpack all files, release, you should have 
the following subdirectories with following contents: 
• simplesim-2.0 - the sources of the SimpleScalar processor 
simulators, supporting scripts, and small test benchmarks. It 
also holds precompiled binaries of the test benchmarks. 
• binufils-2.5.2 - the GNU binary utilities code, ported to the 
SimpleScalar architecture. 
• ssbig .na .ss t r ix  - the mot directory for the tree in which the 
big-endian SimpleScalar binary utilities and compiler tools 
will be installed. The unpacked directories contain header 
files and a pre-compiled copy of libc and a necessary object 
file. 
• ssli t t le-na-sstrix - same as above, except that this directory 
holds the little-endian versions of the SimpleScalar utilities. 
• gcc-2.6.3 - the GNU C compiler code, targeted toward the 
SimpleScalar architecture. 
• gl ibc-l .09 - the GNU libraries code, ported to the SimpleS- 
calar architecture. 
• ['2c-1994.09.27 - the 1994 release of AT&T Bell Labs' 
FORTRAN to C translator code. 
• spec95-big - precompiled SimpleScalar SPEC95 bench- 
mark binaries (big-endian version). 
• spee95-little - precompiled SimpleScalar SPEC95 bench- 
mark binaries (little-endian version) 
2.2 Installing and running  Simplescalar 
We depict a graphical overview of the tool set in Figure 1. 
Benchmarks written in FORTRAN are convened to C using Bell 
Labs' f2c converter. Both benchmarks written in C and those 
converted from FORTRAN are compiled using the SimpleScalar 
version of GCC, which generates SimpleScalar assembly. The 
SimpleScalar assembler and loader, along with the necessary 
- - 1 4 - -  
F O R T R A N  C 
b e n c h m a r k  s o u r c e  b e n c h m a r k  sou rce  
S i m u l a t o r  s o u r c e  
(e.g., sim-outorder.c) 
Gtc°+  
~ S i m p l e S c a l a r  a s s e m b l y  
("Simple$calar-'~ 
GAS • ~ R E S U L T S  
~"7,-"2~2"~Jt~ " ~  S i m p l e S c a l a r  P r e c o m p i l e d  SS 
~ - " - "  - -  execu tab les  b i n a r i e s  (test,  S P E C 9 S )  
Figure 1. SimpleScalar tool set overview 
pored libraries, produce SimpleScalar executables that can then 
be fed directly into one of the provided simulators. (The simula- 
tors themselves are compiled with the host platform's native 
compiler; any ANSI C compiler will do). 
If you use the precompiled SPEC95 binaries or the precom- 
piled test programs, all you have to install is the simulator source 
itself. If you wish to compile your own benchmarks, you will 
have to install and build the GCC tree and optionally (recom- 
mended) the GNU binutils. If you wish to modify the support 
libraries, you will have to install, modify, and build the glibc 
source as well. 
The SimpleScalar architecture, like the MIPS architecture [4], 
supports both big-endian and little-endian executables. The tool 
set supports compilation for either of these targets; the names for 
the big-endian and little-endian architecture are ssbig-na-sstrix 
and ssfitfle-na-sstrix, respectively. You should use the target 
endian-ness that matches your host platform; the simulators may 
not work correctly if you force the compiler to provide cross- 
endian support. To determine which endian your host uses, run 
the endian  program located in the s i m p l e s i m - 2 . 0 /  direc- 
tory. For simplicity, the following instructions will assume a big- 
endian installation. In the following instructions, we will refer to 
the directory in which you are installing SimpleScalar as 
$ IDIR/. 
The simulators come equipped with their own loader, and 
thus you do not need to build the GNU binary utilities to run sim- 
ulations. However, many of these utilities are useful, and we rec- 
ommend that you install them. If desired, build the GNU binary 
utilities !: 
= d  $ZDIR/b£nut£11-2.5.2 
configure --hoitm$HOST --target-sa]~g-na- 
sstrix --with-~nu-as --wlth-~u-ld --pza- 
fixm$IDIl% 
make 
i. You must have GNU Make to do the majority of installations described 
in this document. To check if you have the GNU version, execute "make - 
v" or "gmake -v". The GNU version understands this switch and displays 
version information. 
make Install 
$HOST here is a "canonical configuration" string that represents 
your host architecture and system (CPU-COMPANY-SYSTEM). 
The string for a Sparostation running SunOS would be sparc-sun- 
sunos4.1.3, running Solaris: sparc-sun-solafis2, a 386 running 
Solaris: i386-sun-solaris2.4, etc. A complete list of supported 
$HOST strings resides in $ I D I R / g c c - 2 . 6 . 3  / INSTALL. 
This installation will create the needed directories in $ I D I R  
(these include b i n / ,  l i b / ,  i n c l u d e / ,  and man / ) .  Once the 
binutils have been built, build the simulators themselves. This is 
necessary to do before building GCC, since one of the binaries is 
needed for the cross-compiler build. You should edit $ I D I R /  
s imp 1 e s  i ra -  2 . 0 / M a k e  f i 1 e to use the desired compile flags 
(e.g., the correct optimization level). To use the GNU BFD 
loader instead of the custom loader in the simulators, uncomment 
-DBFD_LOADER in the Makefile. To build the simulators: 
od $IDZRlui~pleuim-2.0 
make 
If desired, build the compiler: 
,..,d $ ' r D T I % I @ G C - 2 . 6 . 3  
eonfi~re --hostffiSK08T --taEgetfasbi~-na- 
sutEix --wlth-gnu-as --wlth-gnu-ld --pra- 
fIx:$IDIR 
make LANGUAGES-c 
. . luimplasim-2.01ulm-safe ./enquire -f > I 
float .h-areas 
make install 
We provide pro-built copies of the necessary libranes J n s s b i g- 
na-sstrix/lib/, so you do not need to build the code in 
glibc-l.09, unless you change the library code. Building these 
libraries is tricky, and we do not recommend it unless you have a 
specific need to do so. In that event, to build the libraries: 
c d  $IDIRlglibc-l. 0 9  
configure --prefix= $/DIR/ooblg-na-satrix 
osbig-na-eotrlx 
oetenv CC $1DIKlb~n/subio-na-outEix-g== 
unuetenv TZ 
unsetenv MACHINE 
15 
make 
make install 
Note that you must have already built the SimpleScalar simula- 
tors to build this library, since the glibo build requires a compiled 
simulator to test target machine-specific parameters such as 
endian-ness. 
If you have FORTRAN benchmarks, you will need to build 
f'2c: 
e d  $ I D Z ~ l f 2 c - 1 9 9 4 . 0 9 . 2 7  
make 
make install 
The entire tool set should now be ready for use. We provide pre- 
compiled test binaries (big- and little-endian) and their sources in 
$IDIR/simplesim2.0/Uests). To run a test: 
c~ $ZDX~/ai~leaim-3.0 
81m-safe tests/bin.big/test-math 
The test should generate about a page of output, and will run very 
quickly. The release has been ported to---and should run on - - the  
following systems: 
- gcc/AIX 413/RS6000 
- xlc/AIX 413/RS6000 
- gcc/HPUX/PA-RISC 
- gcc/SunOS 4.1.3/SPARC 
- gcc/Linux 1.3/x86 
- gcc/Solaris 2/SPARC 
- gec/Solaris 2/x86 
- gee/DEC Unix 3.2/Alpha 
- c89/DEC Unix 3.2/Alpha 
- gce/FrceBSD 2.2/x86 
- gec/WindowsNT/x86 
3 The Simplescalar architecture 
The SimpleScalar architecture is derived from the MIPS-IV 
ISA [4.]. The tool suite defines both iittle-endian and big-endian 
versions of the architecture to improve portability (the version 
used on a given host machine is the one that matches the endian- 
ness of the host). The semantics of the SimpleScalar ISA arc a 
superset of  MIPS with the following notable differences and 
additions: 
• There are no arehitected delay slots: loads, stores, and con- 
trol transfers do not execute the succeeding instruction. 
• Loads and stores support two addressing modes---for all 
data types----in addition to those found in the MIPS architec- 
ture. These are: indexed (register+register), and auto-incre- 
ment/decrement. 
• A square-root instruction, which implements both single- 
and double-precision floating point square roots. 
• An extended 64-bit instruction encoding. 
We list all SimpleScalar instructions in Figure 2. A complete 
list of  the instruction semantics (as implemented in the simula- 
tor) can be found elsewhere [2]. In Table 1, we list the archi- 
tected registers in the SimpleScalar architecture, their hardware 
and software names (which are recognized by the assembler), 
and a description of each. Both the number and the semantics of 
the registers are identical to those in the MIPS-IV ISA. 
In Figure 3, we depict the three instruction encodings of Sim- 
pleScalar instructions: register, immediate, and jump formats. All 
instructions an: 64 bits in length. 
The register format is used for computational instructions. 
The immediate format supports the inclusion of a 16-bit constant. 
The jump format supports specification of 24-bit jump targets. 
The register fields are all 8 bits, to support extension of the archi- 
tected registers to 256 integer and floating point registers. Each 
instruction format has a fixed-location, 16-bit opcode field that 
facilitates fast instruction decoding. 
The annote field is a 16-bit field that can be modified post- 
compile, with annotations to instructions in the assembly files. 
The annotation interface is useful for synthesizing new instruc- 
tions without having to change and re.compile the assembler. 
Annotations are attached to the opcode, and come in two flavors: 
bit and field annotations. A bit annotation is written as follows: 
lw/a $=6,4 ( $r7 ) 
The annotation in this example is /a .  It specifies that the first bit 
of the annotation field should be set. Bit annotat ions/a through/p 
set bits 0 through 15, respectively. Field annotations are written 
in the form: 
lw16:4(7) $r6,4 ($r7) 
This annotation sets the specified 3-bit field (from bit 4 to bit 6 
within the 16-bit annotation field) to the value 7. 
System calls in SimpleSealar are managed by a proxy handler 
(located in s y s c a l l ,  c) that intercepts system calls made by 
the simulated binary, decodes the system call, copies the system 
call arguments, makes the corresponding call to the host's operat- 
ing system, and then copies the results of the call into the simu- 
lated program's memory. If  you are porting SimpleScalar to a 
new platform, you will have to code the system call translation 
from SimpleScalar to your host machine in s y s c a l l ,  c. A list 
of all SimpleScalar system calls is available elsewhere [2]. 
SimpleScalar uses a 31-bit address space, and its virtual 
memory is laid out as follows: 
O x O 0 0 0 0 0 0 0  Unused 
O x O 0 4 , 0 0 0 0 O  Start o f  t e x t  s e g m e n t  
O x l O 0 0 0 0 0 0  S t a r t  o f  d a t a  s e g m e n t  
O x T f f f e O 0 0  S t a c k  base  ( g r o w s  down)  
The top of the data segment (which includes init and bss) is held 
in mem_brk__point. The areas below the text segment and 
above the stack base are unused. 
4 Simulator internals 
In this section, we describe the functionality of the processor 
simulators that accompany the tool set. We describe each of the 
simulators, their functionality, command-line arguments, and 
internal structures. 
The compiler outputs binaries that arc compatible with the 
MIPS ECOFF object format. Library calls are handled with t h e  
ported version of GNU GLIBC and POSIX-compliant Unix sys- 
tem calls. The simulators currently execute only user-level code. 
All SimpleScalar-related extensions to GCC are contained in the 
c o n f i g / s s  subdirectory of the GCC source tree that comes 
with the distribution. 
The architecture is defined in s s  . d a f ,  which contains a 
16 
Control 
j - j u m p  
ja l  - j u m p  and  l ink  
j r  - j u m p  r eg i s t e r  
j a l r  - j u m p  and  l ink  r eg i s t e r  
beq  - b r a n c h  ~ 0 
b n e  - b r a n c h  [= 0 
b l ez  - b r a n c h  < =  0 
bg t z  - b r a n c h  > 0 
bl tz  - b r a n c h  < 0 
b g e z  - b r a n c h  > =  0 
be t  - branch F C C  T R U E  
b c f -  b r a n c h  F C C  F A L S E  
Load/Store 
lb - l oad  b y t e  
lbu  - l oad  b y t e  u n s i g n e d  
lh  - l oad  h a l f  ( shor t )  
l hu  - l oad  h a l f  ( shor t )  u n s i g n e d  
lw - load  w o r d  
d l w  - load  d o u b l e  w o r d  
l .s - load  s i n g l e - p r e c i s i o n  F P  
l .d - l oad  d o u b l e - p r e c i s i o n  F P  
sb  - s to re  b y t e  
sbu  - s to re  b y t e  u n s i g n e d  
s h  - s t o r e  h a l f  ( shor t )  
s h u  - s to re  h a l f  ( shor t )  u n s i g n e d  
s w  - s tore  w o r d  
d s w  - s t o r e  d o u b l e  w o r d  
s .s  - s t e r e  s i n g l e - p r e c i s i o n  F P  
s .d  - s to re  d o u b l e - p r e c i s i o n  F P  
a d d r e s s i n g  m o d e s :  
(c) 
( r e g + C )  (wi th  p r e / p o s t  i n c / d e c )  
( r eg+reg )  (w i t h  preJpos t  i nc /dec )  
Integer Arithmetic 
add - i n t e g e r  add  
addu  - i n t ege r  add  u n s i g n e d  
s u b  - i n t ege r  s u b t r a c t  
subu  - i n t ege r  s u b t r a c t  u n s i g n e d  
m u l t  - i n t e g e r  m u l t i p l y  
m u l t u  - i n t ege r  m u l t i p l y  u n s i g n e d  
d ie  - i n t ege r  d iv ide  
d ivu  - i n t e g e r  d iv ide  u n s i g n e d  
and  - log ica l  A N D  
o r -  log ica l  O R  
x o r  - log ica l  X O R  
n o r -  log ica l  N O R  
sll  - sh i f t  lef t  l og ica l  
srl  - sh i f t  r igh t  l og i ca l  
sra  - sh i f t  r i gh t  a r i t h m e t i c  
si t  - s e t  l ess  t han  
s l tu  - se t  l ess  t han  u n s i g n e d  
Figure 2. Summary of SimpleScalar instructions 
Floating Point Arithmetic 
add . s  - s i n g l e - p r e c i s i o n  (SP)  add  
add .d  - d o u b l e - p r e c i s i o n  ( D P )  add  
sub . s  - S P  s u b t r a c t  
s u b . d  - D P  s u b t r a c t  
m u l t . s  - SP  m u l t i p l y  
m u l t . d  - D P  m u l t i p l y  
div.s  - SP  d i v i d e  
d iv .d  - D P  d i v i d e  
abs . s  - SP  a b s o l u t e  v a l u e  
a b s . d  - D P  a b s o l u t e  v a l u e  
n e g . s  - S P  n e g a t i o n  
n e g . d  - D P  n e g a t i o n  
sqr t . s  - SP  s q u a r e  roo t  
sqr t .d  - D P  s q u a r e  roo t  
c v t  - int . ,  s i n g l e ,  d o u b l e  c o n v e r s i o n  
c . s  - SP  c o m p a r e  
c .d  - D P  c o m p a r e  
Miscellaneous 
n o p -  no  o p e r a t i o n  
s y s c a l l  - s y s t e m  cal l  
break - declare p r o g r a m  error 
Hardware Name Software Name Description 
$u $zero 
$1 
$2 -$3 
$4-$7 
$8-$15 
$16-$23 
$25-$25 
$26-$27 
$28 
$29 
$30 
¢k31 
"$hi 
$1o 
$I0-$131 
Srcc 
Sat 
SvO-$v1 
SaO-$a3 
$t0-$17 
SsO-$s7 
$18-$t9 
$kO-$kl 
Sgp 
Sra 
Shi 
Sfcc 
$1o 
SfO-$f31 
8-rs  
zero-valueo sourcelSlnK 
reserved by assembler 
In return result regs 
fn argument value regs 
temp regs, caller saved 
saved regs, callee saved 
temp regs, caller saved 
reserved by O S  
global pointer 
stack pointer 
saved regs. callee saved 
return address reg 
high result register 
low result register 
floating point registers 
floating point condition code 
Table 1: SimpleScalar architecture register definitions 
1 6 - a n n o t e  1 6 - o p c o d e  
R e g i s t e r  f o r m a t :  I [ 
63  
8.n 8 - rd  8 - n d s h a m t  
I m m e d i a t e  f o r m a t :  [ 
1 6 - a n n o t e  1 6 - o p c o d e  
I 
63 32 31 
1 6 - i m m  
J u m p  f o r m a t :  
1 6 - a n n o t e  1 6 - o p c o d e  6 - u n u s e d  
I I I I 
24- t a rge t  
I 
63 32 31 0 
Figure 3. SimpleScalar architecture instruction formats 
- -17 - -  
macro definition for each instruction in the instruction set. Each 
macro defines the opcode, name, flags, operand sources and des- 
tinations, and actions to be taken for a particular instruction. 
The instruction actions (which appear as macros) that are 
common to all simulators are defined in -~s. h. Those actions 
that require different implementations in different simulators are 
defined in each simulator code file. 
When running a simulator, m a i n ( )  (defined in m a i n . c )  
does all the initialization and loads the target binary into mem- 
ory. The routine then calls . ~ i m _ m a i n  ( ), which is simulator- 
specific, defined in each simulator code file. s ± m _ n ~ i n  ( ) pre- 
decodes the entire text segment for faster simulation, and then 
begins simulation from the target program entry point. 
The foliowing command-line arguments are available in all 
simulators included with the release." 
-h prints the simulator help message. 
-d turn on the debug message. 
-i start execution in the DLite! debugger (see 
Section 5.2). This option is not supported in 
the siro-fast simulator. 
-q terminate immediately (for use with -dump- 
config). 
-dumpconfig <file> 
generate a configuration file saving the com- 
mand-line parameters. Comments are per- 
mitted in the conflg files, and begin with a #. 
-config <file> read in and use a configuration file. These 
files may reference other config files. 
4.1 Func t iona l  s imula t ion  
The fastest, least detailed simulator (sire-fast) resides in 
s i m - £ a = t : ,  c. aim-fast does no time accounting, only func- 
tional simulation it executes each instruction serially, simulat- 
ing no instructions in parallel, sire-fast is optimized for raw 
speed, and assumes no cache, instruction checking, and has no 
support for DLite!_ 
A separate version of aim-fast, called aim-safe, also performs 
functional simulation, but checks for correct alignment and 
access permissions for each memory reference. Although similar, 
sire-fast and sire-safe are split (i.e., protection is not toggled 
with a command-line argument in a merged simulator) to maxi- 
mize performance. Neither of the simulators accept any addi- 
tional command-line arguments. Both versions are very simple: 
less than 300 lines of cede---they therefore make good starting 
points for understanding the internal workings of the simulators. 
In addition to the simulator file, both sim-fast  and sire-safe use 
the following code files (not including header files): m a l n .  c, 
=yscall.c, memory.c, regs_c, loader.c, ~s.c, 
endian, c, and misc. c. ~im-safe als0 uses dl ite. c. 
4.2 Cache  s imula t ion  
The SimpleScalar distribution comes with two functional 
cache simulators; siro-cache and sim-eJaeetah. Both use the file 
cache.c, and they use sim-cache.c and sim-chee- 
t a h .  c, respectively. These simulators are ideal for fast simula- 
tion of caches if the effect of cache performance on execution 
time is not needed. 
sire-cache accepts the following arguments, in addition to the 
universal arguments described in Section 4: 
-cache:dll <config> 
-cache:dl2 <config> 
-cache:ill <config:> 
-cache:il2 <config> 
-tlb:dtlb <config> 
-tlb:itlb <config> 
-flush <boolean> 
configures a level-one data cache. 
configures a level-two data cache. 
configures a level-one instr, cache. 
configures a level-two instr, cache. 
configures the data TLB. 
configures the instruction "['LB. 
flush all caches on a system call; 
(<boolean> = 01 1 I tree I TRUE I false I FALSE). 
-icompress remap SimpleScalar's 64--bit 
instructions to a 32-bit equivalent in 
the simulation (i.e., model a 
machine with 4-word instructions). 
-pester <star> generate a text-based profile, as 
described in Section 4.3. 
The cache configuration (<config>) is formatted as follows: 
, ( n a . l ~ 8  :~ - 4:lo, e l l "  e :~ : . ( l h e ~ . ' ~ a  ~ = , ( a m  = o , " ~  : c ~ a ] ~ " l  :~ 
Each of these fields has the following meaning: 
<name> cache name, must be unique. 
<nsetz> number of sets in the cache. 
<baize> block size (for TLBs, use the page size). 
<assoc> associativity of the cache (power of two). 
<repl> replacement policy (1 1 f I r), where 
l = L R U , f =  FIFO, r = random replacement. 
The cache size is therefore the product of <nsets>, <baize>, and 
<assoc>. To have a unified level in the hierarchy, "point" the 
instruction cache to the name of the data cache in the correspond- 
ing level, as in the following example: 
- c a c h e  : £ 1 1  £ 1 1 : 1 2 8  : 64, : 1 : ' 1  
- c a c h e  : J . 1 2  d 1 2  
-cache : dll dlI:256:32:1:i 
-oeohe : d12 u12:1024:64:2:1 
The defaults used in sire-cache are as follows: 
L1 instruction cache: ii 1:256:32:1:1 (8 KB) 
L1 data cache: dl1:256:32:1:1 (8 KB) 
L2 unified cache: u12:1024:64:4:! (256 KB) 
instruction TLB: itlb: 16:4096:4:1 (64 entries) 
data TLB: dtlb:32:4096:4:l (128 entries) 
sire-cheetah is based on work performed by Ragin Sugumar and 
Santosh Abraham while they were at the University of Michigan. 
It uses their Cheetah cache simulation engine [6] to generate sim- 
ulation results for multiple cache configurations with a single 
simulation. The Cheetah engine simulates fully associative 
caches efficiently, as well as simulating a sometimes-optimal 
replacement policy. This policy was called MIN by Belady [I], 
although the simulator refers to it as opt. Opt uses future knowl- 
edge to select a replacement; it chooses the block that will be ref- 
erenced the furthest in the future (if at all). This policy is optimal 
for read-only instruction streams. It is not optimal for write-back 
caches because it may be more expensive to replace a block ref- 
erenced further in the future if the block must be written back, as 
opposed to a clean block referenced slightly less far in the future. 
Horwitz et el. [3] formally described an optimal algorithm that 
includes writes; however, only MIN is implemented in the simu- 
- - 1 8 - -  
-refs [inst I data 
-C [fa I sa I dm] 
lator. 
We have included the Cheetah engine as a stand-alone library, 
which is built and resides in the l i b c h e e t a h /  directory, sire- 
cheetah accepts the following command-line arguments, in addi- 
tion to those listed at the beginning of  Section 4: 
I unified] 
specify which reference stream to analyze. 
fully associative, set associative, or direct- 
mapped cache. 
-R [Iru I opt] replacement policy. 
-a <sets> log base 2 minimum bound on number of 
sets to simulate simultaneously. 
-b <sets> log base 2 maximum bound on set number. 
-l <line> cache line size (in bytes). 
-n <assoc> maximum associativity to analyze (in log 
base 2). 
-in <interval> cache size interval to report when simulating 
fully associative caches. 
-M <size> maximum cache size of interest. 
-C <size> cache size for direct-mapped analyses. 
Both of these simulators are ideal for performing high-level 
cache studies that do not take access time of the caches into 
account (e.g., studies that are concerned only with miss rates). To 
measure the effect of  cache organization upon the execution time 
of  real programs, however, the timing simulator described in 
Section 4.4 must be used. 
4.3 Profiling 
The d is~but ion  comes with a functional simulator that pro- 
duces voluminous and varied profile information, sim-profile 
can generate detailed profiles on instruction classes and 
addresses, text symbols, memory accesses, branches, and data 
segment symbols. 
sim-profile takes the following command-line arguments, 
which toggle the various profiling features: 
-iclass instruction class profiling (e.g. ALU, 
branch). 
-iprof instruction profiling (e.g., bnez, addi). 
-brprof branch class profiling (e.g., direct, calls, con- 
ditional). 
-amprof addr. mode profiling (e.g., displaced, R+R). 
-segprof load/store segment profiling (e.g., data, 
heap). 
-tsymprof execution profile by text symbol (functions). 
-dsymprof reference profile by data segment symbol. 
-taddrprof execution profile by text address. 
-ail turn on all profiling listed above. 
Three of the simulators (aim-profile, sire-cache, and sire-out- 
o rder )  support text segment profiles for statistical integer 
counters. The supported counters include any added by users, so 
long as they are correctly "registered" with the SimpleScalar 
stats package included with the simulator code (see Section 4.5). 
To use the counter profiles, simply add the command-line flag: 
-pcstat <star> 
where <stat> is the integer counter that you 
wish to profile by text address. 
To generate the statistics for the profile, follow the following 
example: 
sim-profile -pcstat ~im_num_insn test-math >&! 
tes t-math, out 
objdump -dl test-math >! test-math.dis 
textprof.pl test-math.dis test-math.out 
s im_num_insn_by_ oc 
We show a segment of the text profile output in Figure 4. Make 
sure that "objdump" is the version created when compiling the 
binutils. Also, the first line of  t e x t p r o f  . p l  must be changed 
to reflect your system's path to Perl (which must be installed on 
your system for you to use this script). As an aside, note that "- 
taddrprof '  is equivalent to "'-l~stat sim_num_insn". 
4.4 Out-of-order processor timing simulation 
The most complicated and detailed simulator in the distribu- 
tion, by far, is s im-ou torder  (the main code file for which is 
s i m - o u t o r d e r ,  c - - a b o u t  3500 lines long). This simulator 
supports out-of-order issue and execution, based on the Register 
Update Unit [5]. The RUU scheme uses a reorder buffer to auto- 
matically rename registers and hold the results of  pending 
instructions. Each cycle the reorder buffer retires completed 
instructions in program order to the architected register file. 
The processor's memory system employs a load/store queue. 
Store values are placed in the queue if  the store is speculative. 
Loads are dispatched to the memory system when the addresses 
of all previous stores are known. Loads may be satisfied either by 
the memory system or by an earlier store value residing in the 
queue, if  their addresses match. Speculative loads may generate 
cache misses, but speculative TLB misses stall the pipeline until 
the branch condition is known. 
We depict the simulated pipeline of s im-ou to rde r  in 
Figure5. The main loop of  the simulator, located in 
s i r e _ m a i n  ( ) ,  is structured as follows: 
r u u _ i n : t t  ( ) t 
f o =  ( I s )  { 
z-uu._c ,-mm~4 t: ( ) I 
ruu ._wr l t  e b a c k  ( ) ; 
l a q _ r e f r e a h (  ) i 
ruu_:TLasue ( ) ; 
r u n _ d i s p a t c h  ( ) ; 
r u u _ f e t e h  ( ) ; 
} 
This loop is executed once for each target (simulated) 
machine cycle. By walking the pipeline in reverse, inter-stage 
latch synchronization can be handled correctly with only one 
pass through each stage. W h e n  the target p rog ram terminates 
w i t h  an e x i t ( )  system cal l ,  the s imu la to r  per forms a 
l o n g j m p  ( ) to m a i n  ( ) to generate the statistics. 
The fetch stage of  the pipeline is implemented in 
r u u _ f e t c h  ( ) .  The fetch unit models the machine instruction 
bandwidth, and takes the following inputs: the program counter, 
the predictor state, and misprediction detection from the branch 
execution unit(s). Each cycle, it fetches instructions from only 
one 1-cache line (and it blocks on an l-cache miss until the miss 
completes). After fetching the instructions, it places them in the 
dispatch queue, and probes the line predictor to obtain the correct 
1 9  
e x e c u t e d - " - ' l P e  t O04DlalO: ( 13, 0.01): 
1 3 t i m e s ~ -  strtod.c:79 
O0401alE: ( 13, 0.01) : 
strtod.c:87 
never - - . . . ~  X 00401a20 : 
elecUteCl~4 v E 00401a28: 
strtod.c:89 
00401a30: ( 13, 0.01] : 
00401a38: ( 13, 0.01): 
00401a40: ( 13, 0.01): 
<strtod+220> addiu Sal[5],$zero[O],l 
<strLod+228> bclf 00401a30 <strtod+240> 
<strtod+230> addiu Ssl[17],$sl[17],l 
<strtod+238> j 00401a58 <strtod+268> 
<strtod+240> mul_d Sf2,$f20,Sf4 
<strtod+248> addiu Sv012],$vl[3],-4B 
<strtod+250> mtcl Sv0[2],~f0 
Figure 4. Sample output from text segment statistical profile 
1[ 
Figure 5. Pipeline for sim-outorder 
[ :  
i i i  
cache line to access in the next cycle. 
The code for the dispatch stage of the pipeline resides in 
r u u _ d i  s p a t = c h  ( ) .  This routine is where instruction decoding 
and register renaming is performed. The function uses the 
instructions in the input queue filled by the fetch stage, a pointer 
to the active RUU, and the rename table. Once per cycle, the dis- 
patcher takes as many instructions as possible (up to the dispatch 
width of the target machine) from the fetch queue and places 
them in the scheduler queue. This routine is the one in which 
branch mispredictions are noted. (When a misprediction occurs, 
the simulator uses speculative state buffers, which are managed 
with a copy-on-write policy). The dispatch routine enters and 
links instructions into the RUU and the load/store queue (LSQ), 
as well as splitting memory operations into t w o  separate instruc- 
tions (the addition to compute the effective address and the mem- 
ory operation itself). 
The issue stage of the pipeline is contained in 
ruu_issue ( ) and Isq_refresh ( ). These routines model 
instruction wakeup and issue to the functional units, txacking reg- 
ister and memory dependences. Each cycle, the scheduling rou- 
tines locate the instructions for which the register inputs are all 
ready. The issue of ready loads is stalled if there is an earlier 
store with an unresolved effective address in the load/store 
queue. If the address of the earlier store matches that of the wait- 
ing load, the store value is forwarded to the load. Otherwise, the 
load is sent to the memory system. 
The execute stage is also handled in r u u _ i s s u e  ( ). Each 
cycle, the routine gets as many ready instructions as possible 
from the scheduler queue (up to the issue width). The functional 
units'  availability is also checked, and if  they have available 
access ports, the instructions are issued. Finally, the routine 
schedules writeback events using the latency of the functional 
units (memory operations probe the data cache to obtain the cor- 
rect latency of the operation). Data TLB misses stall the issue of 
the memory operation, are serviced in the commit  stage of  the 
pipeline, and currently assume a fixed latency. The functional 
units '  latencies are hardcoded in the definition of 
fu_config [ ] in sim-outorder, c. 
The writeback stage resides in r u u  w r i t = e b a c k  ( ). Each 
cycle it scans the event queue for instruction completions. When 
it finds a completed instruction, it walks the dependence chain of 
instruction outputs to mark instructions that are dependent on the 
completed instruction. If  a dependent instruction is waiting only 
for that completion, the routine marks it as ready to be issued. 
The writeback stage also detects branch mispredictions; when it 
determines that a branch misprediction has occurred, it rolls the 
state back to the checkpoint, discarding the erroneously issued 
instructions. 
r u u _ c o m m i  t ( ) handles the instructions from the writeback 
stage that are ready to commit. This routine does in-order com- 
mitting of instructions, updating of the data caches (or memory) 
with s to re  values, and data TLB miss handling. The routine keeps 
retiring instructions at the head of the RUU that are ready to 
commit until the head instruction is one that is not ready. When 
- -  2 0 - -  
an instruction is committed, its result is placed into the archi- 
tected register file, and the RUU/LSQ resources devoted to that 
instruction are reclaimed. 
s im-outorder  runs about an ordar of magnitude slower than 
sire-fast. In addition to the arguments listed at the beginning of 
Section 4, s im-outorder  uses the following command-line argu- 
ments: 
Specifying the processor core 
-fetch:ifqsize <size> 
set the fetch width to be <size> instructions. 
Must be a power of two. The default is 4. 
-fetch:speed <ratio> 
set the ratio of the front end speed relative to 
the execution core (allowing <ratio> times as 
many instructions to be fetched as decoded 
per cycle). 
-fetch:mplat <cycles> 
set the branch misprediction latency. The 
default is 3 cycles. 
-decode:width <insts> 
set the decode width to be <insts>, which 
must be a power of two. The default is 4. 
-issue:width <insts> 
set the maximum issue width in a given 
cycle. Must be a power of two. The default is 
4. 
-issue:inorder force the simulator to use in-order issue. The 
default is false. 
-issue:wrongpath 
allow instructions to issue after a misspecula- 
tion. The default is true. 
-ruu:size <insts> 
capacity of the RUU (in instructions). The 
default is 16. 
-lsq:size <insts> 
capacity of the load/store queue (in instruc- 
tions). The default is 8. 
-res:ialu <num> 
specify number of integer ALUs. The default 
i s4 .  
-res:imult <num> 
specify number of integer multipliers/divid- 
ers. The default is 1. 
-res:memports <num> 
specify number of L1 cache ports. The 
default is 2. 
-res:fpalu <num> 
specify number of floating point ALUs. The 
default is 4. 
-res: fpmult <num> 
specify number of floating point muitipliers/ 
dividers. The default is 1. 
Specifying the memory  hierarchy 
All of the cache arguments and formats used in sire-cache 
(listed at the beginning of Section 4.2) are also used in sim-out- 
order, with the following additions; 
-cache:rill lat <cycles> 
Specify the 
The default 
-cache:d121at <cycles> 
Specify the 
The default 
-cache:il 1 lat <cycles> 
specify the 
cache. The 
-cacbe:il21at <cycles> 
specify the 
cache. The 
-mem:lat <lst> <next> 
hit latency of the L1 data cache. 
is 1 cycle. 
hit latency of the L2 data cache. 
is 6 cycles. 
hit latency of the L1 instruction 
default is 1 cycle. 
hit latency of the L2 instruction 
default is 6 cycles. 
specify main memory access latency (first, 
re.s0. The defaults are 18 cycles and 2 cycles. 
-mem:width <bytes> 
specify width of memory bus in bytes. The 
default is 8 bytes. 
-tlb:lat <cycles> 
specify latency (in cycles) to service a TLB 
miss. The default is 30 cycles. 
Specifying the b ranch  predictor 
Branch prediction is specified by choosing the following flag 
with one of the six subsequent arguments. The default is a bimo- 
dal predictor with 2048 entries. 
-bpred <type> 
nottaken 
taken 
perfect 
bimod 
always predict not taken. 
always predict taken. 
perfect predictor. 
bimodal predictor, using a branch target 
buffer (BTB) with 2-bit counters. 
21ev 2-level adaptive predictor. 
comb combined predictor (bimodal and 2-level 
adaptive). 
The predictor-specific arguments are listed below: 
-bpred:bimod <size> 
set the bimodal predictor table size to be 
<size> entries. 
-bpred:21ev <llsize> <12size> <hist_size> <got> 
specify the 2-level adaptive predictor. 
<llsize> specifies the number of entries in 
the first-level table, <12size> specifies the 
number of entries in the second-level table, 
<hist_size> specifies the history width, and 
<xor> allows you to xor the history and the 
address in the second level of the predictor. 
This organization is depicted in Figure 6. In 
Table 2 we show how these parameters cor- 
respond to modern prediction schemes. The 
default settings for the four parameters are 1, 
1024, 8, and 0, respectively. 
-bpred:comb <size> 
set the recta-table size of the combined pre- 
dictor to be <size> entries. The default is 
1024. 
-bpred:ras <size> 
set the return stack size to <size> (0 entries 
means to return stack). The default is 8. 
21 
branch r- 
address 
~ a t t c r n  2 - b i t  m t o r y  p r e d i c t o r s  
branch 
prediction 
hist_size 
Figure 6. 2-level adaptive predictor structure 
p r e d i c t o r  l l _ s i z e  h i s t _ s i z e  12_size x o r  
G A g  1 W 2 w 0 
G A p  1 W >2 w 0 
PAg N W 2 w 0 
PAp N W 2N+W 0 
gshare I W 2w I 
Table 2: Branch predictor )arameters 
entries. 
-bprcxi:bth <sets> <assoc> 
configure the BTB to have <sets> sets and an 
associativity of <assoc.>. The defaults are 
512 sets and an associativity of 4. 
-bpred:spec_update <stage> 
allow speculative updates of the branch pre- 
dictor in the decode or writeback stages 
(<stage> = [IDIWB]). The default is non- 
speculative updates in the commit stage. 
VisuulizaUon 
-pestat <sLat> 
record statistic <star> by text address; 
described in Section 4.3. 
-ptrace <file,> <range,> 
pipeline tracing, described in Section 5. 
4 . 5  S i m u l a t o r  c o d e  f i l e  d e s c r i p t i o n s  
The following list describes the functionality of the C code 
flies in the s i m p l e s i m - 2 . 0 /  directory, which are used by all 
of  the simulators. 
• b i t = m a p ,  h: Contains support macros for performing bit- 
map manipulation. 
• b p r e d .  [ c , h ] :  Handles the creation, functionality, and 
updates of the branch predictors, b p r e d _ c r e a t e ( ) ,  
bpred_lookup ( ), and bpred_update ( ) are the key 
interface functions. 
• cache. [c,h]: Contains general functions to support 
multiple cache types (e.g., TLBs, instruction and data 
caches). Uses a linked-list for tag comparisons in caches of 
low associativity (less than or equal to four), and a hash 
table for tag comparisons in higher-associativity caches. 
The important interfaces are c a c h e _ c r e a t e  ( ),  
cache_access (), cache_probe (), 
cache_flush (), and cache_f lush_addr (). 
• dlite _ [c, h] : Contains the code for Diite!, the source- 
level target program debugger. 
• e n d i a n .  [ c ,  h ]  : Defines a few simple functions to deter- 
mine byte- and word-order on the host and target platforms. 
• e v a l .  [ c ,  h]  : Contains code to evaluate expressions, used 
in DLite!. 
• e v e n t q .  [ c ,  h ] :  Defines functions and macros to handle 
ordered event queues (used for ordering writebacks). The 
important interface functions are e v e n t q . . . q u e u e  ( ) and 
eventq_service_events (). 
• loader. [c, h]: Loads the target program into memory, 
sets up the segment sizes and addresses, sets up the initial 
call stack, and obtains the target program entry point. The 
interface is id_load__prog ( ). 
• m a i n .  c: Performs all initialization and launches the main 
simulator function. The key functions are 
sim_options ( ), sim_config ( ), sim_main ( ), 
andsim stats (). 
• m e m o r y .  [ c , h ] :  Contains functions for reading from, 
writing m, initializing, and dumping the contents of the tar- 
get main memory. Memory is implemented as a large flat 
space, each portion of which is allocated on demand. 
mem._acces  s ( ) is the important interface function. 
• m i s c .  [ c ,  h ]  : Contains numerous useful support func- 
tions, such as fatal (), panic (), warn ( ), info (), 
debug (), getcore (), and elapsed_time ( ). 
• options. [c,h]: Contains the $impleScalar options 
package code, used to process command-l ine arguments 
and/or option specifications from config files. Options are 
registered with an option database (see the functions called 
o p t = _ r e g _ *  ( ) ) .  o p t = . . . . p r i n l - _ h e l p O  generates a help 
listing, and o p t - . . . p r ± n t _ o p l - i o n s  () prints the current 
options' state. 
• p t = r a c e .  [ c , h ] :  Contains code to collect and produce 
pipeline traces from s im-outorder .  
• r a n g e .  [ c ,  h ] : Holds code that interprets program range 
commands used in DLiteI. 
• r e g s .  [ c ,  h]  : Contains functions to initialize the register 
files and dump their contents. 
• r e s o u r c e .  [ c ,  h ] :  Contains code to manage functional 
unit resources, divided up into classes. The three defined 
functions create the resource pools and busy tables 
( r e s _ c r e a t = e _ . p o o  1 ( ) ), return a resource from the spec- 
ified pool if available ( r e g _ g e t  ( ) ), and dump the con- 
tents of a pool (res_dump ( ) ). 
• s i r e . h :  Contains a few extern variable declarations and 
function prototypes. 
• s t a t s .  [ c ,  h ]  : Contains routines to handle statistics mea- 
suring target program behavior. As with the options pack- 
age, counters are "registered" by type with an internal 
database. The s t a t _ r e ~ t _ *  ( ) routines register counters 
of various types, and s t = a t _ r e g  f o r m u l a  ( ) allows you 
22 
to register expressions constructed of other statistics. 
s~at_print_sta~s() prints all registered statistics. 
The statistics package also has facilities to measure distribu- 
tions; s e a t _ r e g _ d i s t  ( ) creates an array distribution, 
stat_reg_sdise ( ) creates a sparse array distribution, 
and s t a r - _ a d d _ s a m p l e  ( ) updates a distribution. 
• s s .  [ c ,  h ] : Defines macros to expedite the processing of 
instructions, numerous constants needed across simulators, 
and a function to print out individual instructions in a read- 
able format. 
• s s. clef: Holds a list of macro calls (the macros are defined 
in the simulators and s s . h  and a s . c ) ,  each of which 
defines an instruction. The macro calls accept as arguments 
the opcode, name of the instruction, sources, destinations, 
actions to execute, and other information. This file serves as 
the definition of the instruction set. 
• s y m b o l .  [ c ,  h] : Holds routines to handle program sym- 
bol and line information (used in DLite!). 
• syscall. [c, h] : Contains code that acts as the interface 
between the SimpleScalar system calls (which are POSIX- 
compliant) and the system calls on the host machine. 
• sysprobe, c: Determines byte and word order on the host 
platform, and generates appropriate compiler flags. 
• vers £on. h: Defines the version number and release date 
of the distribution. 
5 Utilities 
In this section we describe the utilities that accompany the 
SimpleScalar tool set; pipeline tracing and a source-level debug- 
ger. 
5 .1  O u t - o f - o r d e r  p i p e l i n e  t r a c i n g  
The tool set provides the ability to extract and view traces of 
the out-of-order pipeline. Using the "-ptrace" option, a detailed 
history of all instructions executed in a range may be saved to a 
file. The information saved includes instruction fetch, retirement, 
and stage transitions. The syntax of this command is as follows: 
-ptrace <file> <start>:<end> 
<file> is the file to which the trace will be 
saved. <start> and <end> are the instruction 
numbers at which the trace will be started 
and stopped. If they are leR blank, the trace 
will start at the beginning and/or stop at the 
end of the program, respectively. 
For example: 
-ptrace FOO.tre 100:500 
trace from instructions 100 to 500, store the 
trace in file FOO.src. 
-ptxace FOO.trc :10000 
trace from program beginning to instruction 
10000. 
-ptrace FOO.trc : 
trace the entire program execution. 
The traces may be viewed with the pipeview.pl Perl script, 
which is provided in the simplesim-2.0 directory. (You will have 
to update the first line o f p i p e v i e w ,  p l  to have the correct path 
to your local Perl binary, and you must have P e r  installed on 
your system). 
p.4.pev J.ew. p l  <pt:rac8_£'l ].e > 
We depict sample output from the pipetracer in Figure 7. 
5 . 2  T h e  DLi teZ  d e b u g g e r  
Release 2.0 of Simple, Scalar includes a lightweight symbolic 
debugger called DLite!, which runs with all simulators except for 
sim-fast. DLitel allows you to step through the benchmark target 
code, not the simulator code. The debugger can be incorporated 
into a simulator by adding only four function calls (which have 
already been added to all simulators in the distribution). The 
needed four function prototypes arc in d l  i t e .  h. 
To use the debugger in a simulation, add the "-i" option 
(which stands for interactive) to the simulator command line. 
Below we list the set of commands that DLite! accepts. 
Gett ing help  and gett ing out: 
help [string] print command reference. 
version print DLite! version information. 
quit exit simulator. 
terminate generate statistics and exit simulator. 
R u n n i n g  and setting breakpoints:  
step execute next instruction and break. 
cont [addr] continue execution (optionally continuing 
starting at <addr>). 
break <addr> set breakpoint at <addr>, returns <id> of 
breakpoint. 
dbreak <addr> [r,w,x] 
set data breakpoint at <addr> for (0ead, 
(w)rite, and/or e(x)ecute, returns <id> of 
breakpoint. 
rbreak <range> [r,w,x] 
set breakpoint at <range> for (r)ead, (w)rite, 
and/or e(x)ecute, returns <id> of breakpoint. 
breaks list active code and data breakpoints. 
delete </d> delete breakpoint <id>. 
clear clear all breakpeints (code and data). 
Pr int ing information:  
print [modifiers] <expr> 
print the value of <expr> using optional 
modifiers. 
display [modifiers] <expr> 
display the value of <expr> using optional 
modifiers. 
option <string> print the value of option <string>. 
options print the values of all options. 
stat <string> print the value of a statistical variable. 
stats print the values of all statistical variables. 
whatis <expr> pnnt the type of<expr>. 
regs print all register contents. 
iregs print all instruction register contents. 
fpregs pnnt all floating point register contents. 
mstate [string] print machine-specific state. 
dump <addr> [count] 
- - 2 3 - -  
new cycle 
indicator 
new instruction 
definitions 
current pipeline 
state 
r- 
@ 610 
gf = '0x0040d0g8: addiu 
gg = '0x0040d0a0: beq 
r2, r4, -1' 
r3, rS, Ox30' 
[IF] [DA] [EX] 
gf gb fy 
gg gc fz 
gd~ ga+ 
pipeline event: 
(misprediction 
detected), see output 
header for event defs 
fq 
is 
ft 
fu 
t t t 
inst. being inst. being inst. inst. writing 
fetched, or in decoded, or executing results into 
fetch queue awaiting issue RUU, or 
awaiting retire 
t 
inst. retiring 
results to 
register file 
Figure 7. Example of sim-outorder pipetrace 
dump memory  at <addr> (optionally for 
<count> words). 
dis <oddr> [count] 
disassemble instructions at <addr> (option- 
ally for <count> instructions). 
symbols print the value o f  all program symbols. 
tsymbois print the value of  all program text symbols. 
dsymbols print the value o f  all program data symbols.  
symbol <string> 
print the value of  symbol  <string>. 
Lega l  a r g u m e n t s :  
Arguments <addr>, <cnt>, <expr>, and <id> arc any legal 
expression: 
<expr> <---- <factor> +I- <expr> 
<factor-> ¢--- <term> *l/ <factor> 
<term> <-- ( <expr> ) 
I - <term> I <const> I <symbol> I <file:loc> 
<-- <literal> I <function name> I <:register> 
<-- [0-9]+ I Ox[0-9,a-fJ+ 1 0[0-7]+ 
<- $r[0-31] I $f[0-31] I Spc I $fcc I Shi I $1o 
<symbol> 
<literaL> 
<register> 
Lega l  r anges :  
<range> 
<address> 
<instruction> 
<cycle> 
~-- <address> I <insU'uction> I <cycle> 
<--- @<function name>: [+<literal>} 
(--- [<literal> }: (<literal> } 
(--- # [ <li teral> }: ( <literal> } 
Omitting optional  arguments to the left o f  the colon will default 
to the smallest value permitted in that range. Omitt ing an 
optional argument at the right o f  the colon will defau]t to the 
largest value permitted in that range. 
Lega l  c o m m a n d  modi f ie rs :  
b print a byte 
h print a half  (short) 
w print a word (default) 
t print in decimal  format (default) 
o print in octal format 
x print in hex format 
1 print in binary format 
f print float 
d print double 
c print character 
$ print string 
E x a m p l e s  o f  legal c o m m a n d s :  
b r e a k  t a a i n + a  
break 0 x 4 0 0 1 4 8  
dbreak otdin w 
d b : e a . k  aye_count WE 
rbreak @main:+279 
rbreak 2 0 0 0 : 3 5 0 0  
rbreak # : 1 0 0  c~q~le 
rbreak : 
0 t o  , - .yc=la  1 0 0  
e n t i r e  e x e e u t  4 o n  
6 Summary 
The SimpleScalar  tool set was written by Todd Austin over 
about one and a half  years, between 1994 and 1996. He continues 
to add improvements and updates. The ancestors of  the tool set 
date back to the mid to late 1980s, to tools written by Manoj 
Franklin. At  the time the tools were developed, both individuals 
were research assistants at the University of  Wisconsin-Madison 
Computer  Sciences Department,  supervised by Professor Guri 
Sohi. Scott Breach provided valuable assistance with the imple- 
mentation of  the proxy system calls. The first release was assem- 
bled, debugged, and documented by Doug Burger, also a 
research assistant at Wisconsin,  who is the maintainer of  the sec- 
ond release as well. Kevin Skadron, currently at Princeton, 
implemented many of  the more recent branch prediction mecha- 
nisms. 
Many exciting extensions to SimpleScalar  are both underway 
and planned. Efforts have Ix:gun to extend the processor simula- 
tors to simulate multithreaded processors and multiprocessors.  A 
Linux pert to SimpleScalar  (enabling simulation o f  the OS on a 
kernel with publicly available sources) is planned, using device- 
level emulation and a user-level file system. Other plans include 
24 
extending the tool set to simulate ISAs other than SimpleScalar 
and MIPS (Alpha and SPARC ISA support will be the first addi- 
tions). 
As they stand now, these tools provide researchers with a simula- 
tion infrastructure that is fast, flexible, and efficient. Changes in 
both the target hardware and software may be made with mini- 
mal effort. We hope that you find these tools useful, and encour- 
age you to contact us with ways that we can improve the release, 
documentation, and the tools themselves. 
References 
[1] L .A .  Belady. A Study of Replacement Algorithms for a 
Virtual-Storage Computer. IBM Systems Journal, 5(2):78-- 
101, 1966. 
[2] Doug Burger and Todd M. Austin. The SimpleScalar Tool 
Set Version 2.0. Technical Report 1342, Computer Sci- 
ences Department, University of  Wisconsin, Madison, WI, 
1997. 
[3] L.P.  Horwitz, R. M. Karp, R. E. Miller, and A. Winograd. 
Index Register Allocation. Journal of the ACM, 13(1):43- 
61, January 1966. 
[4] Charles Price. MIPS IV Instruction Set, revision 3.1. MIPS 
Technologies, Inc., Mountain View, CA, January 1995. 
[5] Gurindar S. Sohi. Instruction Issue Logic for High-Perfor- 
mance, Interruptible, Multiple Functional Unit, Pipelined 
Computers. IEEE Transactions on Computers, 39(3):349- 
359, March 1990. 
[6] Rahin A. Sugumar and SantoshG. Abraham. Efficient 
Simulation of  Caches under Optimal Replacement with 
Applications to Miss Characterization. In Proceedings of 
the 1993 ACM Sigmetrics Conference on Measurements 
and Modeling of Computer Systems, pages 24-35, May 
1993. 
- - 2 5 m  

