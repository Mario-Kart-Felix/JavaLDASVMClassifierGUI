Volume 26 ( 2007 ), Number 1 pp. 80–113 
A Survey of General-Purpose Computation on Graphics 
Hardware 
John D. Owens, David Luebke, Naga Govindaraju, Mark Harris, Jens Krüger, Aaron E. Lefohn, and Timothy J. Purcell 
Abstract 
The rapid increase in the performance of graphics hardware, coupled with recent improvements in its programma- 
bility, have made graphics hardware a compelling platform for computationally demanding tasks in a wide va- 
riety of application domains. In this report, we describe, summarize, and analyze the latest research in mapping 
general-purpose computation to graphics hardware. 
We begin with the technical motivations that underlie general-purpose computation on graphics processors 
(GPGPU) and describe the hardware and software developments that have led to the recent interest in this �eld. 
We then aim the main body of this report at two separate audiences. First, we describe the techniques used in 
mapping general-purpose computation to graphics hardware. We believe these techniques will be generally useful 
for researchers who plan to develop the next generation of GPGPU algorithms and techniques. Second, we survey 
and categorize the latest developments in general-purpose application development on graphics hardware. 
Categories and Subject Descriptors (according to ACM CCS) : I.3.1 [Computer Graphics]: Hardware Architecture; 
I.3.6 [Computer Graphics]: Methodology and Techniques; D.2.2 [Software Engineering]: Design Tools and Tech- 
niques 
1. Introduction: Why GPGPU? 
Commodity computer graphics chips, known generically as 
Graphics Processing Units or GPUs, are probably today’s 
most powerful computational hardware for the dollar. Re- 
searchers and developers have become interested in har- 
nessing this power for general-purpose computing, an ef- 
fort known collectively as GPGPU (for “General-Purpose 
computing on the GPU”). In this article we summarize the 
principal developments to date in the hardware and soft- 
ware behind GPGPU, give an overview of the techniques and 
computational building blocks used to map general-purpose 
computation to graphics hardware, and survey the various 
general-purpose computing tasks to which GPUs have been 
applied. We begin by reviewing the motivation for and chal- 
lenges of general-purpose GPU computing. Why GPGPU? 
1.1. Powerful and Inexpensive 
Recent graphics architectures provide tremendous memory 
bandwidth and computational horsepower. For example, the 
�agship NVIDIA GeForce 7900 GTX ($378 as of October 
2006) boasts 51.2 GB/sec memory bandwidth; the similarly- 
priced ATI Radeon X1900 XTX can sustain a measured 
240 GFLOPS, both measured with GPUBench [BFH04a]. 
Compare to 8.5 GB/sec and 25.6 GFLOPS theoretical peak 
for the SSE units of a dual-core 3.7 GHz Intel Pentium Ex- 
treme Edition 965 [Int06]). GPUs also use advanced proces- 
sor technology; for example, the ATI X1900 contains 384 
million transistors and is built on a 90-nanometer fabrication 
process. 
Graphics hardware is fast and getting faster quickly. 
For example, the arithmetic throughput (again measured by 
GPUBench) of NVIDIA’s current-generation launch prod- 
uct, the GeForce 7800 GTX (165 GFLOPS), more than 
triples that of its predecessor, the GeForce 6800 Ultra 
(53 GFLOPS). In general, the computational capabilities of 
GPUs, measured by the traditional metrics of graphics per- 
formance, have compounded at an average yearly rate of 1.7 
(pixels/second) to 2.3 (vertices/second). This rate of growth 
signi �cantly outpaces the often-quoted Moore’s Law as ap- 
plied to traditional microprocessors; compare to a yearly rate 
of roughly 1.4 for CPU performance [EWN05] (Figure 1). 
Why is graphics hardware performance increasing more 
rapidly than that of CPUs? Semiconductor capability, driven 
by advances in fabrication technology, increases at the same 
rate for both platforms. The disparity can be attributed to 
c The Eurographics Association and Blackwell Publishing 2007. Published by Blackwell 
Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main Street, Malden, 
MA 02148, USA. 
The canonical version of this article is available at 
http://www.blackwell-synergy.com/. 
http://www.blackwell-synergy.com/doi/abs/10.1111/j.1467-8659.2007.01012.x
Please cite this article as: John D. Owens, David Luebke, Naga Govindaraju, Mark Harris, 
Jens Krüger, Aaron E. Lefohn, and Tim Purcell. A Survey of General-Purpose Computation 
on Graphics Hardware. Computer Graphics Forum, 26(1):80–113, March 2007.  We 
acknowledge Computer Graphics Forum, Eurographics (The European Association for 
Computer Graphics) and Blackwell Publishing. 
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
0
100
200
300
G
F
L
O
P
S
G
F
L
O
P
S
2002 2004 2006
Year
NVIDIA
ATI
Intel
dual-core
Figure 1: The programmable floating-point performance of
GPUs (measured on the multiply-add instruction, counting 2
floating-point operations per MAD) has increased dramati-
cally over the last four years when compared to CPUs.
fundamental architectural differences: CPUs are optimized
for high performance on sequential code, with many transis-
tors dedicated to extracting instruction-level parallelism with
techniques such as branch prediction and out-of-order exe-
cution. On the other hand, the highly data-parallel nature of
graphics computations enables GPUs to use additional tran-
sistors more directly for computation, achieving higher arith-
metic intensity with the same transistor count. We discuss
the architectural issues of GPU design further in Section 2.
1.2. Flexible and Programmable
Modern graphics architectures have become flexible as
well as powerful. Early GPUs were fixed-function pipelines
whose output was limited to 8-bit-per-channel color val-
ues, whereas modern GPUs now include fully programmable
processing units that support vectorized floating-point oper-
ations on values stored at full IEEE single precision (but note
that the arithmetic operations themselves are not yet per-
fectly IEEE-compliant). High level languages have emerged
to support the new programmability of the vertex and pixel
pipelines [BFH∗04b,MGAK03,MDP∗04]. Additional levels
of programmability are emerging with every major genera-
tion of GPU (roughly every 18 months). For example, cur-
rent generation GPUs introduced vertex texture access, full
branching support in the vertex pipeline, and limited branch-
ing capability in the fragment pipeline. The next generation
will expand on these changes and add “geometry shaders”,
or programmable primitive assembly, bringing flexibility to
an entirely new stage in the pipeline [Bly06]. The raw speed,
increasing precision, and rapidly expanding programmabil-
ity of GPUs make them an attractive platform for general-
purpose computation.
1.3. Limitations and Difficulties
The GPU is hardly a computational panacea. Its arithmetic
power results from a highly specialized architecture, evolved
and tuned over years to extract maximum performance on
the highly parallel tasks of traditional computer graphics.
The increasing flexibility of GPUs, coupled with some in-
genious uses of that flexibility by GPGPU developers, has
enabled many applications outside the original narrow tasks
for which GPUs were originally designed, but many appli-
cations still exist for which GPUs are not (and likely never
will be) well suited. Word processing, for example, is a clas-
sic example of a “pointer chasing” application, dominated
by memory communication and difficult to parallelize.
Today’s GPUs also lack some fundamental comput-
ing constructs, such as efficient “scatter” memory opera-
tions (i.e., indexed-write array operations) and integer data
operands. The lack of integers and associated operations
such as bit-shifts and bitwise logical operations (AND, OR,
XOR, NOT) makes GPUs ill-suited for many computation-
ally intense tasks such as cryptography (though upcoming
Direct3D 10-class hardware will add integer support and
more generalized instructions [Bly06]). Finally, while the re-
cent increase in precision to 32-bit floating point has enabled
a host of GPGPU applications, 64-bit double precision arith-
metic remains a promise on the horizon. The lack of double
precision hampers or prevents GPUs from being applicable
to many very large-scale computational science problems.
Furthermore, graphics hardware remains difficult to ap-
ply to non-graphics tasks. The GPU uses an unusual pro-
gramming model (Section 2.3), so effective GPGPU pro-
gramming is not simply a matter of learning a new language.
Instead, the computation must be recast into graphics terms
by a programmer familiar with the design, limitations, and
evolution of the underlying hardware. Today, harnessing the
power of a GPU for scientific or general-purpose compu-
tation often requires a concerted effort by experts in both
computer graphics and in the particular computational do-
main. But despite the programming challenges, the poten-
tial benefits—a leap forward in computing capability, and
a growth curve much faster than traditional CPUs—are too
large to ignore.
1.4. GPGPU Today
A vibrant community of developers has emerged around
GPGPU (http://GPGPU.org/), and much promising
early work has appeared in the literature. We survey GPGPU
applications, which range from numeric computing oper-
ations, to non-traditional computer graphics processes, to
physical simulations and “game physics”, to data mining.
We cover these and more applications in Section 5.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Vertex 
Buffer
Vertex 
Processor
Rasterizer
Fragment
Processor
Texture
Frame
Buffer
Figure 2: The modern graphics hardware pipeline. The ver-
tex and fragment processor stages are both programmable
by the user.
2. Overview of Programmable Graphics Hardware
In this section we will outline the evolution of the GPU and
describe its current hardware and software.
2.1. Overview of the Graphics Pipeline
The application domain of interactive 3D graphics has sev-
eral characteristics that differentiate it from more general
computation domains. In particular, interactive 3D graph-
ics applications require high computation rates and exhibit
substantial parallelism. Building custom hardware that takes
advantage of the native parallelism in the application, then,
allows higher performance on graphics applications than can
be obtained on more traditional microprocessors.
All of today’s commodity GPUs structure their graphics
computation in a similar organization called the graphics
pipeline. This pipeline is designed to allow hardware imple-
mentations to maintain high computation rates through par-
allel execution. The pipeline is divided into several stages.
All geometric primitives pass through each stage: vertex
operations, primitive assembly, rasterization, fragment op-
erations, and composition into a final image. In hardware,
each stage is implemented as a separate piece of hardware
on the GPU in what is termed a task-parallel machine or-
ganization. Figure 2 shows the pipeline stages in current
GPUs. For more detail on GPU hardware and the graphics
pipeline, NVIDIA’s GeForce 6 series of GPUs is described
by Kilgariff and Fernando [KF05] and Montrym and More-
ton [MM05]. From a software perspective, the OpenGL Pro-
gramming Guide is an excellent reference [OSW∗03].
2.2. Programmable Hardware
As graphics hardware has become more powerful, one of the
primary goals of each new generation of GPU has been to
increase the visual realism of rendered images. The graph-
ics pipeline described above was historically a fixed-function
pipeline, where the limited number of operations available at
each stage of the graphics pipeline were hardwired for spe-
cific tasks. However, the success of offline rendering systems
such as Pixar’s RenderMan [Ups90] demonstrated the ben-
efit of more flexible operations, particularly in the areas of
lighting and shading. Instead of limiting lighting and shad-
ing operations to a few fixed functions, RenderMan evalu-
ated a user-defined shader program on each primitive, with
impressive visual results.
Over the past seven years, graphics vendors have trans-
formed the fixed-function pipeline into a more flexible pro-
grammable pipeline. This effort has been primarily concen-
trated on two stages of the graphics pipeline: the vertex stage
and the fragment stage. In the fixed-function pipeline, the
vertex stage included operations on vertices such as trans-
formations and lighting calculations. In the programmable
pipeline, these fixed-function operations are replaced with
a user-defined vertex program. Similarly, the fixed-function
operations on fragments that determine the fragment’s color
are replaced with a user-defined fragment program.
Each new generation of GPUs has increased the function-
ality and generality of these two programmable stages. 1999
marked the introduction of the first programmable stage,
NVIDIA’s register combiner operations that allowed a lim-
ited combination of texture and interpolated color values to
compute a fragment color. In 2002, ATI’s Radeon 9700 led
the transition to floating-point computation in the fragment
pipeline.
The vital step for enabling general-purpose computation
on GPUs was the introduction of fully programmable hard-
ware and an assembly language for specifying programs
to run on each vertex [LKM01] or fragment. This pro-
grammable shader hardware is explicitly designed to pro-
cess multiple data-parallel primitives at the same time. As of
2006, the vertex shader and pixel shader standards are both
in their third revision, and the OpenGL Architecture Review
Board maintains extensions for both [Ope04, Ope03]. The
instruction sets of each stage are limited compared to CPU
instruction sets; they are primarily math operations, many of
which are graphics-specific. The newest addition to the in-
struction sets of these stages has been limited control flow
operations.
In general, these programmable stages input a limited
number of 32-bit floating-point 4-vectors. The vertex stage
outputs a limited number of 32-bit floating-point 4-vectors
that will be interpolated by the rasterizer; the fragment
stage outputs up to 4 floating-point 4-vectors, typically col-
ors. Each programmable stage can access constant registers
across all primitives and also read-write registers per primi-
tive. The programmable stages have limits on their numbers
of inputs, outputs, constants, registers, and instructions; with
each new revision of the vertex shader and pixel [fragment]
shader standard, these limits have increased.
GPUs typically have multiple vertex and fragment pro-
cessors (for example, the ATI Radeon X1900 XTX features
8 vertex processors and 48 fragment processors). Fragment
processors have the ability to fetch data from textures, so
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
they are capable of memory gather. However, the output ad-
dress of a fragment is always determined before the frag-
ment is processed—the processor cannot change the output
location of a pixel—so fragment processors are incapable of
memory scatter. Vertex processors recently acquired texture
capabilities, and they are capable of changing the position
of input vertices, which ultimately affects where in the im-
age pixels will be drawn. Thus, vertex processors are capable
of both gather and scatter. Unfortunately, vertex scatter can
lead to memory and rasterization coherence issues further
down the pipeline. Combined with the lower performance of
vertex processors, this limits the utility of vertex scatter in
current GPUs.
2.3. Introduction to the GPU Programming Model
As we discussed in Section 1, GPUs are a compelling so-
lution for applications that require high arithmetic rates
and data bandwidths. GPUs achieve this high performance
through data parallelism, which requires a programming
model distinct from the traditional CPU sequential program-
ming model. In this section, we briefly introduce the GPU
programming model using both graphics API terminology
and the terminology of the more abstract stream program-
ming model, because both are common in the literature.
The stream programming model exposes the parallelism
and communication patterns inherent in the application
by structuring data into streams and expressing compu-
tation as arithmetic kernels that operate on streams. Pur-
cell et al. [PBMH02] characterize their ray tracer in the
stream programming model; Owens [Owe05] and Lefohn et
al. [LKO05] discuss the stream programming model in the
context of graphics hardware, and the Brook programming
system [BFH∗04b] offers a stream programming system for
GPUs.
Because typical scenes have more fragments than vertices,
in modern GPUs the programmable stage with the highest
arithmetic rates is the fragment stage. A typical GPGPU
program uses the fragment processor as the computation
engine in the GPU. Such a program is structured as fol-
lows [Har05a]:
1. First, the programmer determines the data-parallel por-
tions of his application. The application must be seg-
mented into independent parallel sections. Each of these
sections can be considered a kernel and is implemented
as a fragment program. The input and output of each ker-
nel program is one or more data arrays, which are stored
(sometimes only transiently) in textures in GPU memory.
In stream processing terms, the data in the textures com-
prise streams, and a kernel is invoked in parallel on each
stream element.
2. To invoke a kernel, the range of the computation (or the
size of the output stream) must be specified. The pro-
grammer does this by passing vertices to the GPU. A
typical GPGPU invocation is a quadrilateral (quad) ori-
ented parallel to the image plane, sized to cover a rect-
angular region of pixels matching the desired size of the
output array. Note that GPUs excel at processing data in
two-dimensional arrays, but are limited when processing
one-dimensional arrays.
3. The rasterizer generates a fragment for every pixel loca-
tion in the quad, producing thousands to millions of frag-
ments.
4. Each of the generated fragments is then processed by the
active kernel fragment program. Note that every frag-
ment is processed by the same fragment program. The
fragment program can read from arbitrary global mem-
ory locations (with texture reads) but can only write to
memory locations corresponding to the location of the
fragment in the frame buffer (as determined by the ras-
terizer). The domain of the computation is specified for
each input texture (stream) by specifying texture coordi-
nates at each of the input vertices, which are then inter-
polated at each generated fragment. Texture coordinates
can be specified independently for each input texture, and
can also be computed on the fly in the fragment program,
allowing arbitrary memory addressing.
5. The output of the fragment program is a value (or vec-
tor of values) per fragment. This output may be the final
result of the application, or it may be stored as a texture
and then used in additional computations. Complex ap-
plications may require several or even dozens of passes
(“multipass”) through the pipeline.
While the complexity of a single pass through the pipeline
may be limited (for example, by the number of instructions,
by the number of outputs allowed per pass, or by the limited
control complexity allowed in a single pass), using multiple
passes allows the implementation of programs of arbitrary
complexity. For example, using an OpenGL simulation with
the addition of floating-point compositing operations, Peercy
et al. [POAU00] demonstrated that even the fixed-function
pipeline, given enough passes, can implement arbitrary Ren-
derMan shaders.
2.4. GPU Program Flow Control
Flow control is a fundamental concept in computation.
Branching and looping are such basic concepts that it can
be daunting to write software for a platform that supports
them to only a limited extent. The latest GPUs support vertex
and fragment program branching in multiple forms, but their
highly parallel nature requires care in how they are used.
This section surveys some of the limitations of branching on
current GPUs and describes a variety of techniques for iter-
ation and decision-making in GPGPU programs. Harris and
Buck [HB05] provide more detail on GPU flow control.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
2.4.1. Hardware Mechanisms for Flow Control
There are three basic implementations of data-parallel
branching in use on current GPUs: predication, MIMD
branching, and SIMD branching.
Architectures that support only predication do not have
true data-dependent branch instructions. Instead, the GPU
evaluates both sides of the branch and then discards one of
the results based on the value of the Boolean branch condi-
tion. The disadvantage of predication is that evaluating both
sides of the branch can be costly, but not all current GPUs
have true data-dependent branching support. The compiler
for high-level shading languages like Cg or the OpenGL
Shading Language automatically generates predicated as-
sembly language instructions if the target GPU supports only
predication for flow control.
In Multiple Instruction Multiple Data (MIMD) architec-
tures that support branching, different processors can follow
different paths through the program. In Single Instruction
Multiple Data (SIMD) architectures, all active processors
must execute the same instructions at the same time. The
only MIMD processors in a current GPU are the vertex pro-
cessors of the NVIDIA GeForce 6 and 7 series and NV40-
and G70-based Quadro GPUs. Classifying GPU fragment
processors is more difficult. The programming model is ef-
fectively Single Program Multiple Data (SPMD), meaning
that threads (pixels) can take different branches. However,
in terms of architecture and performance, fragment proces-
sors on current GPUs process pixels in SIMD groups. Within
a SIMD group, when evaluation of the branch condition is
identical for all pixels in the group, only the taken side of the
branch must be evaluated. However, if one or more of the
processors evaluates the branch condition differently, then
both sides must be evaluated and the results predicated. As
a result, divergence in the branching of simultaneously pro-
cessed fragments can lead to reduced performance.
2.4.2. Moving Branching Up The Pipeline
Because explicit branching can hamper performance on
GPUs, it is useful to have multiple techniques to reduce the
cost of branching. A useful strategy is to move flow-control
decisions up the pipeline to an earlier stage where they can
be more efficiently evaluated.
Static Branch Resolution On the GPU, as on the CPU,
avoiding branching inside inner loops is beneficial. For ex-
ample, when evaluating a partial differential equation (PDE)
on a discrete spatial grid, an efficient implementation divides
the processing into multiple loops: one over the interior of
the grid, excluding boundary cells, and one or more over
the boundary edges. This static branch resolution results in
loops that contain efficient code without branches. (In stream
processing terminology, this technique is typically referred
to as the division of a stream into substreams.) On the GPU,
the computation is divided into two fragment programs: one
for interior cells and one for boundary cells. The interior pro-
gram is applied to the fragments of a quad drawn over all but
the outer one-pixel edge of the output buffer. The boundary
program is applied to fragments of lines drawn over the edge
pixels. Static branch resolution is further discussed by Good-
night et al. [GWL∗03], Harris and James [HJ03], and Lefohn
et al. [LKHW03].
Pre-computation In the example above, the result of a
branch was constant over a large domain of input (or range
of output) values. Similarly, sometimes the result of a branch
is constant for a period of time or a number of iterations of a
computation. In this case we can evaluate the branches only
when the results are known to change, and store the results
for use over many subsequent iterations. This can result in
a large performance boost. This technique is used to pre-
compute an obstacle offset array in the Navier-Stokes fluid
simulation example in the NVIDIA SDK [Har05b].
Z-Cull Precomputed branch results can be taken a step fur-
ther by using another GPU feature to entirely skip unnec-
essary work. Modern GPUs have a number of features de-
signed to avoid shading pixels that will not be seen. One of
these is Z-cull. Z-cull is a hierarchical technique for com-
paring the depth (Z) of an incoming block of fragments with
the depth of the corresponding block of fragments in the Z-
buffer. If the incoming fragments will all fail the depth test,
then they are discarded before their pixel colors are calcu-
lated in the fragment processor. Thus, only fragments that
pass the depth test are processed, work is saved, and the ap-
plication runs faster. In fluid simulation, “land-locked” ob-
stacle cells can be “masked” with a z-value of zero so that
all fluid simulation computations will be skipped for those
cells. If the obstacles are fairly large, then a lot of work is
saved by not processing these cells. Sander et al. described
this technique [STM04] together with another Z-cull accel-
eration technique for fluid simulation, and Harris and Buck
provide pseudocode [HB05]. Z-cull was also used by Purcell
et al. to accelerate GPU ray tracing [PBMH02].
Data-Dependent Looping With Occlusion Queries An-
other GPU feature designed to avoid drawing what is not
visible is the hardware occlusion query (OQ). This feature
provides the ability to query the number of pixels updated by
a rendering call. These queries are pipelined, which means
that they provide a way to get a limited amount of data (an in-
teger count) back from the GPU without stalling the pipeline
(which would occur when actual pixels are read back). Be-
cause GPGPU applications almost always draw quads with
known pixel coverage, OQ can be used with fragment kill
functionality to get a count of fragments updated and killed.
This allows the implementation of global decisions con-
trolled by the CPU based on GPU processing. Purcell et
al. demonstrated this in their GPU ray tracer [PBMH02],
and Harris and Buck provide pseudocode for the tech-
nique [HB05]. Occlusion queries can also be used for subdi-
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
vision algorithms, such as the adaptive radiosity solution of
Coombe et al. [CHL04].
2.5. Impact of DX10 Hardware
The next major generation of GPUs are widely expected to
support Microsoft’s Direct3D 10 API, part of Microsoft’s
DirectX multimedia APIs, and appear sometime from late
2006 to early 2007. Blythe’s recent Siggraph paper [Bly06]
summarizes the major hardware and software changes that
will characterize these upcoming GPUs.
The impact on GPGPU from this new hardware may not
be felt for some time as GPGPU developers migrate their
applications to the new feature set and become comfortable
with the performance aspects of the new hardware and soft-
ware, but we expect that the following features will be of
particular interest for general-purpose computing.
• DX10 introduces a new programmable unit to the
pipeline, the geometry shader, that is placed after the ver-
tex shader. The input to the GS is an entire primitive. The
major difference between the GS and the previous ver-
tex/fragment shaders is that it can output anywhere from 0
to many primitives. This ability to procedurally create new
elements is expected to be broadly useful in both graph-
ics tasks (such as shadow volume calculations) and more
general-purpose tasks.
• GPGPU application developers have long requested more
flexible operations on memory buffers. While operations
such as render-to-texture and render-to-vertex-array have
partially met these requests, upcoming DX10 hardware
promises both greater functionality and greater perfor-
mance in this area. One new operation in DX10 hardware
will be the “stream output”, allowing the output of the ge-
ometry shader to be directly stored into a memory buffer.
• The new shader model (4.0) associated with DX10 hard-
ware unifies the basic instruction set between the pro-
grammable shader units (though each programmable
shader still has stage-specific specializations). Along with
increases in a variety of shader limits, such as instruc-
tion count, register space, and render targets, shader hard-
ware now supports 32-bit integers. This integer capability
is expected to both enhance current GPGPU applications
(particularly in memory address calculations) as well as
enable new ones (such as cryptography). The precision
of floating-point computation is also expected to signifi-
cantly improve in DX10 hardware.
3. Programming Systems
Successful programming for any development platform re-
quires at least three basic components: a high-level language
for code development, a debugging environment, and profil-
ing tools. CPU programmers have a large number of well-
established languages, debuggers, and profilers to choose
from when writing applications. Conversely, GPU program-
mers have just a small handful of languages to choose from,
and few if any full-featured debuggers and profilers.
In this section we look at the high-level languages that
have been developed for GPU programming, and the debug-
ging tools that are available for GPU programmers. Code
profiling and tuning tends to be a very architecture-specific
task. GPU architectures have evolved very rapidly, making
profiling and tuning primarily the domain of the GPU man-
ufacturer. As such, we will not discuss code profiling tools
in this section.
3.1. High-level Shading Languages
Most high-level GPU programming languages today share
one thing in common: they are designed around the idea that
GPUs generate pictures. As such, the high-level program-
ming languages are often referred to as shading languages.
That is, they are a high-level language that compiles a shader
program into a vertex shader and a fragment shader to pro-
duce the image described by the program.
Cg [MGAK03], HLSL [Mic05a], and the OpenGL Shad-
ing Language [KBR04] all abstract the capabilities of the
underlying GPU and allow the programmer to write GPU
programs in a more familiar C-like programming language.
They do not stray far from their origins as languages de-
signed to shade polygons. All retain graphics-specific con-
structs: vertices, fragments, textures, etc. Cg and HLSL pro-
vide abstractions that are very close to the hardware, with
instruction sets that expand as the underlying hardware ca-
pabilities expand. The OpenGL Shading Language was de-
signed looking a bit further out, with many language features
(e.g. integers) that do not directly map to hardware available
today.
Sh is a shading language implemented on top of
C++ [MDP∗04]. Sh provides a shader algebra for manipu-
lating and defining procedurally parameterized shaders. Sh
manages buffers and textures, and handles shader partition-
ing into multiple passes. Sh also provides a stream program-
ming abstraction suitable for GPGPU programming.
Finally, Ashli [BP03] works at a level one step above
that of Cg, HLSL, or the OpenGL Shading Language. Ashli
reads as input shaders written in HLSL, the OpenGL Shad-
ing Language, or a subset of RenderMan. Ashli then auto-
matically compiles and partitions the input shaders to run on
a programmable GPU.
3.2. GPGPU Languages and Libraries
More often than not, the graphics-centric nature of shading
languages makes GPGPU programming more difficult than
it needs to be. As a simple example, initiating a GPGPU
computation usually involves drawing a primitive. Looking
up data from memory is done by issuing a texture fetch. The
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
GPGPU program may conceptually have nothing to do with
drawing geometric primitives and fetching textures, yet the
shading languages described in the previous section force
the GPGPU application writer to think in terms of geomet-
ric primitives, fragments, and textures. Instead, GPGPU al-
gorithms are often best described as memory and math op-
erations, concepts much more familiar to CPU program-
mers. The programming systems below attempt to provide
GPGPU functionality while hiding the GPU-specific details
from the programmer.
The Brook programming language extends ANSI C with
concepts from stream programming [BFH∗04b]. Brook can
use the GPU as a compilation target. Brook streams are con-
ceptually similar to arrays, except all elements can be oper-
ated on in parallel. Kernels are the functions that operate on
streams. Brook automatically maps kernels and streams into
fragment programs and texture memory.
Scout is a GPU programming language designed for sci-
entific visualization [MIA∗04]. Scout allows runtime map-
ping of mathematical operations over data sets for visualiza-
tion.
Accelerator is a system from Microsoft Research that
aims to simplify GPGPU programming by providing a high-
level data-parallel programming model in a library that is
accessible from within traditional imperative programming
languages [TPO06]. Accelerator translates data-parallel op-
erations on the fly to GPU pixel shaders, demonstrating sig-
nificant speedups over C versions running on the CPU.
CGiS is a data-parallel programming language from the
Saarland University Compiler Design Lab with similar aims
to Brook and Accelerator, but with a slightly different ap-
proach [LFW06]. Like Brook, CGiS provides stream data
types, but instead of explicit kernels that run on the GPU,
the language invokes GPU computation via a built-in data-
parallel forall operator.
Finally, the Glift template library provides a generic
template library designed to simplify GPU data struc-
ture design and separate GPU algorithms from data struc-
tures [LKS∗06]. Glift defines GPU computation as par-
allel iteration over the elements of a data structure. The
model generalizes the stream computation model and con-
nects GPGPU with CPU-based parallel data structure li-
braries such as the Standard Template Adaptive Parallel Li-
brary (STAPL) [AJR∗01]. The library integrates with a C++,
Cg, and OpenGL GPU development environment.
3.3. Debugging Tools
Until recently, support for debugging on GPUs was fairly
limited, and the features necessary for a good GPU debugger
were not well defined. The advent of GPGPU programming
makes it clear that a GPU debugger should have similar ca-
pabilities as traditional CPU debuggers, including variable
Figure 3: Examples of fragment program “printf” debug-
ging. The left image encodes ray-object intersection hit
points as r, g, b color. The right image draws a point at each
location where a photon was stored in a photon map. (Im-
ages generated by Purcell et al. [PDC∗03].)
watches, program break points, and single-step execution.
GPU programs often involve user interaction. While a de-
bugger does not need to run the application at full speed, the
application being debugged should maintain some degree of
interactivity. A GPU debugger should be easy to add to and
remove from an existing application, should mangle GPU
state as little as possible, and should execute the debug code
on the GPU, not in a software rasterizer. Finally, a GPU de-
bugger should support the major GPU programming APIs
and vendor-specific extensions.
In many cases, graphically displaying the data for a given
set of pixels gives a much better sense of whether a compu-
tation is correct than a text box full of numbers would. This
visualization is essentially a “printf-style” debug, where the
values of interest are printed to the screen. Figure 3 shows
some examples of printf-style debugging that many GPGPU
programmers have become adept at implementing as part of
the debugging process. The ideal GPGPU debugger would
automate printf-style debugging, including programmable
scale and bias for values outside the display range (e.g. float-
ing point data), while also retaining the true data value at
each point if it is needed.
There are a few different systems for debugging GPU pro-
grams available to use, but nearly all are missing one or more
of the important features we just discussed.
gDEBugger [Gra06] and GLIntercept [Tre06] are tools
designed to help debug OpenGL programs. Both are able to
capture and log OpenGL state from a program. gDEBugger
allows a programmer to set breakpoints and watch OpenGL
state variables at runtime, as well as to profile applications
using GPU hardware performance signals. There is currently
no specific support for debugging shaders, but both support
runtime shader editing.
The Microsoft Shader Debugger [Mic05b], however,
does provide runtime variable watches and breakpoints for
shaders. The shader debugger is integrated into the Visual
Studio IDE, and provides all the same functionality pro-
grammers are used to for traditional programming. Unfortu-
nately, debugging requires the shaders to be run in software
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
emulation rather than on the hardware. In contrast, the Apple
OpenGL Shader Builder [App06b] also has a sophisticated
IDE and actually runs shaders in real time on the hardware
during shader debug and edit. The downside to this tool is
that it was designed for writing shaders, not for computation.
The shaders are not run in the context of the application, but
in a separate environment designed to help facilitate shader
writing.
While many of the tools mentioned so far provide a lot of
useful features for debugging, none provide any support for
shader data visualization or printf-style debugging. Some-
times this is the single most useful tool for debugging pro-
grams. The Image Debugger [Bax06] was among the first
tools to provide this functionality by providing a printf-like
function over a region of memory. The region of memory
gets mapped to a display window, allowing a programmer
to visualize any block of memory as an image. The Image
Debugger does not provide any special support for shader
programs, so programmers must write shaders such that the
output gets mapped to an output buffer for visualization.
The Shadesmith Fragment Program Debugger [PS03] was
the first system to automate printf-style debugging while
providing basic shader debugging functionality like break-
points, program stepping, and programmable scale and bias
for the image printf. While Shadesmith represents a big step
in the right direction for GPGPU debugging, it still has
many limitations, the largest of which is that Shadesmith is
currently limited to debugging assembly language shaders.
Additionally, Shadesmith only works for OpenGL fragment
programs, and provides no support for debugging OpenGL
state.
Finally, Duca et al. recently described a system that not
only provides debugging for graphics state but also both ver-
tex and fragment programs [DNB∗05]. Their system builds
a database of graphics state for which the user writes SQL-
style queries. Based on the queries, the system extracts the
necessary graphics state and program data and draws the
appropriate data into a debugging window. The system is
build on top of the Chromium [HHN∗02] library, enabling
debugging of any OpenGL applications without modifica-
tion to the original source program. This promising approach
combines graphics state debugging and program debugging
with visualizations in a transparent and hardware-rendered
approach.
4. GPGPU Techniques
This section is targeted at the developer of GPGPU libraries
and applications. We enumerate the techniques required to
efficiently map complex applications to the GPU and de-
scribe some of the building blocks of GPU computation.
4.1. Stream Operations
Recall from Section 2.3 that the stream programming
model is a useful abstraction for programming GPUs. There
are several fundamental operations on streams that many
GPGPU applications implement as a part of computing their
final results: map, reduce, scatter and gather, scan, stream fil-
tering, sort, and search. In the following sections we define
each of these operations, and briefly describe a GPU imple-
mentation for each.
4.1.1. Map
Perhaps the simplest operation, the map (or apply) operation
operates just like a mapping function in Lisp. Given a stream
of data elements and a function, map will apply the function
to every element in the stream. A simple example of the map
operator is applying scale and bias to a set of input data for
display in a color buffer.
The GPU implementation of map is straightforward, and
perhaps best illustrated with an example. Assume we have a
stream of data with values in the range [0.0..1.0). We would
like to convert these values to the range [0..255], perhaps for
mapping to a display. A kernel to do this would multiply
each element in the stream by 256 and take the floor of that
value, to produce an output stream in the desired range. This
application of a function to an input stream is the essence of
the map operation.
4.1.2. Reduce
Sometimes a computation requires computing a smaller
stream from a larger input stream, possibly to a single ele-
ment stream. This type of computation is called a reduction.
For example, a reduction can be used to compute the sum or
maximum of all the elements in a stream.
On GPUs, reductions can be performed by alternately ren-
dering to and reading from a pair of textures. On each ren-
dering pass, the size of the output, the computational range,
is reduced by one half. In general, we can compute a reduc-
tion over a set of n data elements in O( np logn) time steps
using the parallel GPU hardware (with p elements processed
in one time step), compared to O(n) time steps for a sequen-
tial reduction on the CPU. To produce each element of the
output, a fragment program reads two values, one from a cor-
responding location on either half of the previous pass result
buffer, and combines them using the reduction operator (for
example, addition or maximum). These passes continue until
the output is a one-by-one buffer, at which point we have our
reduced result. For a two-dimensional reduction, the frag-
ment program reads four elements from four quadrants of
the input texture, and the output size is halved in both di-
mensions at each step. Buck et al. describe GPU reductions
in more detail in the context of the Brook programming lan-
guage [BFH∗04b].
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
4.1.3. Scatter and Gather
Two fundamental memory operations with which most pro-
grammers are familiar are write and read. If the write and
read operations access memory indirectly, they are called
scatter and gather respectively. A scatter operation looks like
the C code d[a] = v where the value v is being stored
into the data array d at address a. A gather operation is just
the opposite of the scatter operation. The C code for gather
looks like v = d[a].
The GPU implementation of gather is essentially a depen-
dent texture fetch operation. A texture fetch from texture d
with computed texture coordinates a performs the indirect
memory read that defines gather. Unfortunately, scatter is not
as straightforward to implement. Fragments have an implicit
destination address associated with them: their location in
frame buffer memory. A scatter operation would require that
a program change the framebuffer write location of a given
fragment, or would require a dependent texture write oper-
ation. Since neither of these mechanisms exist on today’s
GPU, GPGPU programmers must resort to various tricks to
achieve a scatter. These tricks include rewriting the problem
in terms of gather; tagging data with final addresses during
a traditional rendering pass and then sorting the data by ad-
dress to achieve an effective scatter; and using the vertex
processor to scatter (since vertex processing is inherently a
scattering operation). Buck has described these mechanisms
for changing scatter to gather in greater detail [Buc05b].
4.1.4. Scan
A simple and common parallel algorithmic building block is
the all-prefix-sums operation, also known as scan [HS86].
For each element in a sequence of elements, prefix-sum
computes the sum of all previous elements in the sequence.
Blelloch summarized a variety of potential applications of
scan [Ble90]. The first implementation of scan on GPUs
was presented by Horn and demonstrated for the applica-
tions of collision detection and subdivision surfaces [Hor05].
Hensley et al. used a similar scan implementation to gener-
ate summed-area tables on the GPU [HSC∗05]. The algo-
rithms of Horn and Hensley et al. were efficient in the num-
ber of passes (O(logn)) executed, but required O(n logn) to-
tal work, a factor of logn worse than the optimal sequential
work complexity ofO(n). Sengupta et al. and Greß et al. pre-
sented O(n) algorithms for GPUs [SLO06,GGK06]. Greß et
al. construct a list of potentially intersecting bounding box
pairs and utilize scan to remove the non-intersecting pairs.
The algorithm of Sengupta et al. is notable for its method
of switching from a tree-based work-efficient algorithm to
Horn’s brute-force algorithm as it approaches the root of the
tree. This hybrid approach more efficiently uses all of the
parallelism provided by the GPU.
4.1.5. Stream Filtering
Many algorithms require the ability to select a subset of ele-
ments from a stream, and discard the rest. The location and
number of elements to be filtered is variable and not known
a priori. Example algorithms that benefit from this stream
filtering operation include simple data partitioning (where
the algorithm only needs to operate on stream elements with
positive keys and is free to discard negative keys) and colli-
sion detection (where only objects with intersecting bound-
ing boxes need further computation).
Horn has described a technique called stream com-
paction [Hor05] that implements stream filtering on the
GPU. Using a combination of scan (Section 4.1.4) and
search, stream filtering can be achieved in O(logn) passes.
4.1.6. Sort
A sort operation allows us to transform an unordered set
of data into an ordered set of data. Sorting is a classic al-
gorithmic problem that has been solved by several different
techniques on the CPU. Many of these algorithms are data-
dependent and generally require scatter operations; there-
fore, they are not directly applicable to a clean GPU im-
plementation. Recall from Section 2.4 that data-dependent
operations are difficult to implement efficiently, and we just
saw in Section 4.1.3 that scatter is not implemented for frag-
ment processors on today’s GPUs. To make efficient use of
GPU resources, a GPU-based sort should be oblivious to the
input data, and should not require scatter.
Most GPU-based sorting implementations [BP04,
CND03,GZ06,KSW04,KW05a,PDC∗03,Pur04] have been
based on sorting networks. The main idea behind a sorting
network is that a given network configuration will sort input
data in a fixed number of steps, regardless of the input data.
Additionally, all the nodes in the network have a fixed com-
munication pattern. The fixed communication pattern means
the problem can be stated in terms of gather rather than
scatter, and the fixed number of stages for a given input size
means the sort can be implemented without data-dependent
branching. This yields an efficient GPU-based sort, with an
overall O(n log2 n) computational complexity.
Kipfer et al. and Purcell et al. implement a bitonic merge
sort [Bat68] and Callele et al. use a periodic balanced sort-
ing network [DPRS89]. The implementation details of each
technique vary, but the high-level strategy for each is the
same. The data to be sorted is stored in texture memory. Each
of the fixed number of stages for the sort is implemented as
a fragment program that does a compare-and-swap opera-
tion. The fragment program simply fetches two texture val-
ues, and based on the sort parameters, determines which of
them to write out for the next pass. Figure 4 shows a simple
bitonic merge sort.
Sorting networks can also be implemented efficiently us-
ing the texture mapping and blending functionalities of the
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
1
2
3
4
5
6
7
8
7
6
1
3
8
5
2
4
5
6
3
8
1
2
7
4
2
6
3
8
1
5
4
7
2
5
3
7
1
6
4
8
7
5
3
2
8
6
4
1
7
5
2
3
8
6
1
4
Figure 4: A simple parallel bitonic merge sort of eight ele-
ments requires six passes. Elements at the head and tail of
each arrow are compared, with larger elements moving to
the head of the arrow.
0
1
2
3
4
5
0M 2M 4M 6M 8M
Database size
S
o
rt
in
g
 t
im
e
 (
s
e
c
s
)
GPU Bitonic Sort
(PDC
*
03) CPU Qsort (MSVC)
CPU Qsort (Intel Compiler)
GPU Bitonic Sort (KW05)
GPU PBSN (GRM05)
GPU Bitonic Sort (GRHM05) Fixed
GPU Bitonic Sort (GRHM05) Prog
Figure 5: Performance of CPU-based and GPU-based sort-
ing algorithms on 16-bit floating point values. The CPU-
based Qsort available in the Intel compiler is optimized us-
ing hyperthreading and SSE instructions. We observe that
the cache-efficient GPU-based sorting network algorithm is
nearly 6 times faster than the optimized CPU implementa-
tion on a 3.4 GHz PC with an NVIDIA GeForce 6800 Ultra
GPU. Furthermore, the fixed-function pipeline implementa-
tion described by Govindaraju et al. [GRH∗05] is nearly 1.2
times faster than their implementation with fragment pro-
grams.
GPU [GRM05]. In each step of the sorting network, a com-
parator mapping is created at each pixel on the screen and
the color of the pixel is compared against exactly one other
pixel. The comparison operations are implemented using
the blending functionality and the comparator mapping is
implemented using the texture mapping hardware, thus en-
tirely eliminating the need for fragment programs. Govin-
daraju et al. [GRH∗05] have also analyzed the cache effi-
ciency of sorting network algorithms and presented an im-
proved bitonic sorting network algorithm with a better data
access pattern and data layout. The precision of the underly-
ing sorting algorithm using comparisons with fixed-function
blending hardware is limited to the precision of the blending
hardware. For example, the current blending hardware has
16-bit floating point precision. Alternatively, the limitation
to 16-bit values on current GPUs can be alleviated by us-
ing a single-line fragment program for evaluating the condi-
tionals, but the fragment program implementation on current
GPUs is slightly slower than the fixed-function pipeline. Fig-
ure 5 highlights the performance of different GPU-based and
CPU-based sorting algorithms on different sequences com-
posed of 16-bit floating point values using a high-end PC. A
sorting library implementing the algorithm for 16-bit and 32-
bit floats is freely available for noncommercial use [GPU06].
Greß and Zachmann [GZ06] present a novel algorithm,
GPU-ABiSort, to further enhance the sorting performance
on GPUs. Their algorithm is based on an adaptive bitonic
sorting algorithm and achieves an optimal performance of
O(n logn) for any computation time T in the range of
O(log2 n) ≤ T ≤ O(n logn). The algorithm maps well to
the GPU and is able to achieve comparable performance to
GPUSort [GPU06] on an NVIDIA 7800 GTX GPU.
GPUs have also been used to efficiently perform 1-D and
3-D adaptive sorting of sequences [GHLM05]. Unlike sort-
ing network algorithms, the computational complexity of
adaptive sorting algorithms is dependent on the extent of dis-
order in the input sequence, and work well for nearly-sorted
sequences. The extent of disorder is computed using Knuth’s
measure of disorder. Given an input sequence I, the measure
of disorder is defined as the minimal number of elements
that need to be removed for the rest of the sequence to re-
main sorted. The algorithm proceeds in multiple iterations.
In each iteration, the unsorted sequence is scanned twice.
In the first pass, the sequence is scanned from the last el-
ement to the first, and an increasing sequence of elements
M is constructed by comparing each element with the cur-
rent minimum. In the second pass, the sorted elements in
the increasing sequence are computed by comparing each
element in M against the current minimum in I −M. The
overall algorithm is simple and requires only comparisons
against the minimum of a set of values. The algorithm is
therefore useful for fast 3D visibility ordering of elements
where the minimum comparisons are implemented using the
depth buffer [GHLM05].
External memory sorting algorithms are used to orga-
nize large terabyte-scale datasets. These algorithms proceed
in two phases and use limited main memory to order the
data. Govindaraju et al. [GGKM06] present a novel exter-
nal memory sorting algorithm to sort billion-record wide-
key databases using a GPU. In the first phase, GPUTeraSort
pipelines the following tasks on the CPU, disk controller
and GPU: read disk asynchronously, build keys, sort using a
GPU, generate runs and write disk. In this phase, GPUTera-
Sort uses the data parallelism and high memory bandwidth
on GPUs to quickly sort large runs. In the second phase,
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
GPUTeraSort uses a similar task pipeline to read, merge and
write the runs. GPUTeraSort offloads the compute-intensive
and memory-intensive tasks to the GPU; therefore, it is able
to achieve higher I/O performance and better memory per-
formance than CPU-only algorithms. In practice, GPUTera-
Sort outperforms the Indy PennySort† record and is able
to achieve the best reported price-to-performance on large
databases.
4.1.7. Search
The last stream operation we discuss, search, allows us to
find a particular element within a stream. Search can also
be used to find the set of nearest neighbors to a specified
element. Nearest neighbor search is used extensively when
computing radiance estimates in photon mapping (Sec-
tion 5.4.2) and in database queries (e.g. find the 10 nearest
restaurants to point X). When searching, we will use the par-
allelism of the GPU not to decrease the latency of a single
search, but rather to increase search throughput by executing
multiple searches in parallel.
Binary Search The simplest form of search is the binary
search. This is a basic algorithm, where an element is lo-
cated in a sorted list in O(logn) time. Binary search works
by comparing the center element of a list with the element
being searched for. Depending on the result of the compar-
ison, the search then recursively examines the left or right
half of the list until the element is found, or is determined
not to exist.
The GPU implementation of binary search [Hor05,
PDC∗03, Pur04] is a straightforward mapping of the stan-
dard CPU algorithm to the GPU. Binary search is inher-
ently serial, so we can not parallelize lookup of a single el-
ement. That means only a single pixel’s worth of work is
done for a binary search. We can easily perform multiple bi-
nary searches on the same data in parallel by sending more
fragments through the search program.
Nearest Neighbor Search Nearest neighbor search is a
slightly more complicated form of search. In this search,
we want to find the k nearest neighbors to a given element.
On the CPU, this has traditionally been done using a k-d
tree [Ben75]. During a nearest neighbor search, candidate
elements are maintained in a priority queue, ordered by dis-
tance from the “seed” element. At the end of the search, the
queue contains the nearest neighbors to the seed element.
Unfortunately, the GPU implementation of nearest neigh-
bor search is not as straightforward. We can search a k-d tree
data structure [FS05], but it is difficult to efficiently main-
tain a priority queue. The important detail about the prior-
ity queue is that candidate neighbors can be removed from
† http://research.microsoft.com/barc/
SortBenchmark
the queue if closer neighbors are found. Purcell et al. pro-
pose a data structure for finding nearest neighbors called
the kNN-grid [PDC∗03, Pur04]. The grid approximates a
nearest-neighbor search, but is unable to reject candidate
neighbors once they are added to the list. The quality of the
search then depends on the density of the grid and the order
in which candidate neighbors are visited during the search.
The next section of this article discusses GPGPU data struc-
tures like arrays and the kNN-grid.
4.2. Data Structures
Every GPGPU algorithm must operate on data stored in an
appropriate structure. This section describes the data struc-
tures used thus far for GPU computation. Effective GPGPU
data structures must support fast and coherent parallel ac-
cesses as well as efficient parallel iteration, and must also
work within the constraints of the GPU memory model. We
first describe this model and explain common patterns seen
in many GPGPU structures, then present data structures un-
der three broad categories: dense arrays, sparse arrays, and
adaptive arrays. Lefohn et al. [LKO05,LKS∗06] give a more
detailed overview of GPGPU data structures and the GPU
memory model.
The GPU Memory Model As described in Section 2.3,
GPU data are almost always stored in texture memory. To
maintain parallelism, operations on these textures are lim-
ited to read-only or write-only access within a kernel. Write
access is further limited by the lack of scatter support (Sec-
tion 4.1.3). Outside of kernels, users may allocate or delete
textures, copy data between the CPU and GPU, copy data
between GPU textures, or bind textures for kernel access.
Lastly, most GPGPU data structures are built using 2D tex-
tures for three reasons. First, GPU’s 2D memory layout
and rasterization pattern (i.e., iteration traversal pattern) are
closely coupled to deliver the best possible memory access
pattern. Second, the maximum 1D texture size is often too
small for most problems, and third, current GPUs cannot ef-
ficiently write to a slice of a 3D texture.
Iteration In modern C/C++ programming, algorithms are
defined in terms of iteration over the elements of a data
structure. The stream programming model described in Sec-
tion 2.3 performs an implicit data-parallel iteration over a
stream. Iteration over a dense set of elements is usually ac-
complished by drawing a single large quad. This is the com-
putation model supported by Brook, Sh, and Scout. Complex
structures, however, such as sparse arrays, adaptive arrays,
and grid-of-list structures often require more complex iter-
ation constructs [BFGS03, KW03, LKHW04]. These range
iterators are usually defined using numerous smaller quads,
lines, or point sprites.
Generalized Arrays via Address Translation The major-
ity of data structures used thus far in GPGPU programming
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Figure 6:GPU-based multidimensional arrays usually store
data in 2D texture memory. Address translators for N-D ar-
rays generally convert N-D addresses to 1D, then to 2D.
are random-access multidimensional containers, including
dense arrays, sparse arrays, and adaptive arrays. Lefohn
et al. [LKS∗06] show that these virtualized grid structures
share a common design pattern. Each structure defines a vir-
tual grid domain (the problem space), a physical grid domain
(usually a 2D texture), and an address translator between the
two domains. A simple example is a 1D array represented
with a 2D texture. In this case, the virtual domain is 1D, the
physical domain is 2D, and the address translator converts
between them [LKO05,PBMH02].
In order to provide programmers with the abstraction
of iterating over elements in the virtual domain, GPGPU
data structures must support both virtual-to-physical and
physical-to-virtual address translation. For example, in the
1D array example above, an algorithm reads from the 1D
array using a virtual-to-physical (1D-to-2D) translation. An
algorithm that writes to the array, however, must convert
the 2D pixel (physical) position of each stream element to
a 1D virtual address before performing computations on
1D addresses. A number of authors describe optimization
techniques for pre-computing these address translation op-
erations before the fragment processor [BFGS03, CHL04,
KW03,LKHW04]. These optimizations pre-compute the ad-
dress translation using the CPU, the vertex processor, and/or
the rasterizer.
The Brook programming systems provide virtualized in-
terfaces to most GPU memory operations for contiguous,
multidimensional arrays. Sh provides a subset of the op-
erations for large 1D arrays. The Glift template library
provides virtualized interfaces to GPU memory opera-
tions for any structure that can be defined using the pro-
grammable address translation paradigm. These systems
also define iteration constructs over their respective data
structures [BFH∗04b,LKS∗06,MDP∗04].
4.2.1. Dense Arrays
The most common GPGPU data structure is a contigu-
ous multidimensional array. These arrays are often imple-
mented by first mapping from N-D to 1D, then from 1D to
2D [BFH∗04b, PBMH02]. For 3D-to-2D mappings, Harris
et al. describe an alternate representation, flat 3D textures,
that directly maps the 2D slices of the 3D array to 2D mem-
ory [HBSL03]. Figures 6 and 7 show diagrams of these ap-
proaches.
Figure 7: For the special case of 3D-to-2D conversions or
flat 3D textures, 2D slices of the 3D array are packed into a
single 2D texture. This structure maintains 2D locality and
therefore supports native bilinear filtering.
Iteration over dense arrays is performed by drawing large
quads that span the range of elements requiring computa-
tion. Brook, Glift, and Sh provide users with fully virtualized
CPU/GPU interfaces to these structures. Lefohn et al. give
code examples for optimized implementations [LKO05].
4.2.2. Sparse Arrays
Sparse arrays are multidimensional structures that store only
a subset of the grid elements defined by their virtual domain.
Example uses include sparse matrices and implicit surface
representations.
Static Sparse Arrays We define static to mean that the
number and position of stored (non-zero) elements does not
change throughout GPU computation, although the GPU
computation may update the value of the stored elements. A
common application of static sparse arrays is sparse matri-
ces. These structures can use complex, pre-computed pack-
ing schemes to represent the active elements because the
structure does not change.
Sparse matrix structures were first presented by Bolz et
al. [BFGS03] and Krüger et al. [KW03]. Bolz et al. treat
each row of a sparse matrix as a separate stream and pack the
rows into a single texture. They simultaneously iterate over
all rows containing the same number of non-zero elements
by drawing a separate small quad for each row. They perform
the physical-to-virtual and virtual-to-physical address trans-
lations in the fragment stage using a two-level lookup table.
In contrast, for random sparse matrices, Krüger et al. pack all
active elements into vertex buffers and iterate over the struc-
ture by drawing a single-pixel point for each element. Each
point contains a pre-computed virtual address. Krüger et al.
also describe a packed texture format for banded sparse ma-
trices. Buck et al. [BFH∗04b] later introduced a sparse ma-
trix Brook example application that performs address trans-
lation with only a single level of indirection. The scheme
packs the non-zero elements of each row into identically
sized streams. As such, the approach applies to sparse matri-
ces where all rows contain approximately the same number
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Physical MemoryPage TableVirtual Domain
Figure 8: Page table address data structures can be used to
represent dynamic sparse or adaptive GPGPU data struc-
tures. For sparse arrays, page tables map only a subset of
possible pages to texture memory. Page-table-based adap-
tive arrays map either uniformly sized physical pages to
a varying number of virtual pages or vice versa. Page ta-
bles consume more memory than a tree structure but offer
constant-time memory accesses and support efficient data-
parallel insertion and deletion of pages. Example applica-
tions include ray tracing acceleration structures, adaptive
shadow maps, and deformable implicit surfaces [LKHW04,
LSK∗05, PBMH02]. Lefohn et al. describe these structures
in detail [LKS∗06].
of non-zero elements. Section 4.4 contains more detail about
GPGPU linear algebra.
Dynamic Sparse Arrays Dynamic sparse arrays are similar
to those described in the previous section but support inser-
tion and deletion of non-zero elements during GPU compu-
tation. An example application for a dynamic sparse array is
the data structure for a deforming implicit surface.
Multidimensional page table address translators are an at-
tractive option for dynamic sparse (and adaptive) arrays be-
cause they provide fast data access and can be easily up-
dated. Like the page tables used in modern CPU architec-
tures and operating systems, page table data structures en-
able sparse mappings by mapping only a subset of possible
pages into physical memory. Page table address translators
support constant access time and storage proportional to the
number of elements in the virtual address space. The transla-
tions always require the same number of instructions and are
therefore compatible with the current fragment processor’s
SIMD architecture. Figure 8 shows a diagram of a sparse 2D
page table structure.
Lefohn et al. represent a sparse dynamic volume using a
CPU-based 3D page table with uniformly-sized 2D physical
pages [LKHW04]. They store the page table on the CPU,
the physical data on the GPU, and pre-compute all address
translations using the CPU, vertex processor, and rasterizer.
The GPU creates page allocations and deletion requests by
rendering a small bit-vector message. The CPU decodes this
message and performs the requested memory management
operations. Strzodka et al. use a page discretization and sim-
ilar message-passing mechanism to define sparse iteration
over a dense array [ST04]. Lefebvre et al. [LDN04] describe
using a page table to implement a virtual texture system.
4.2.3. Adaptive Structures
Adaptive arrays are a generalization of sparse arrays and rep-
resent structures such as quadtrees, octrees, kNN-grids, and
k-d trees. These structures non-uniformly map data to the
virtual domain and are useful for very sparse or multiresolu-
tion data. Similar to their CPU counterparts, GPGPU adap-
tive address translators are represented with a tree, a page
table, or a hash table. Example applications include ray trac-
ing acceleration structures, photon maps, adaptive shadow
maps, and octree textures.
Static Adaptive Structures Purcell et al. use a static adap-
tive array to represent a uniform-grid ray tracing acceler-
ation structure [PBMH02]. The structure uses a one-level,
3D page table address translator with varying-size physi-
cal pages. A CPU-based pre-process packs data into the
varying-size pages and stores the page size and page origin
in the 3D page table. The ray tracer advances rays through
the page table using a 3D line drawing algorithm. Rays tra-
verse the variable-length triangle lists one render pass at a
time. The conditional execution techniques described in Sec-
tion 2.4 are used to avoid performing computation on rays
that have reached the end of the triangle list.
Foley et al. recently introduced the first k-d tree for GPU
ray tracing [FS05]. A k-d tree adaptively subdivides space
into axis-aligned bounding boxes whose size and position
are determined by the data rather than a fixed grid. Like
the uniform grid structure, the query input for their struc-
ture is the ray origin and direction and the result is the ori-
gin and size of a triangle list. In their implementation, a
CPU-based pre-process creates the k-d tree address trans-
lator and packs the triangle lists into texture memory. They
present two new k-d tree traversal algorithms that are GPU-
compatible and, unlike previous algorithms, do not require
the use of a stack. Thrane and Simonsen [TS05] also de-
scribe and analyze static adaptive ray tracing acceleration
structures. They introduce a GPU bounding-volume hierar-
chy (BVH) structure and compare it to a GPU k-d tree.
Dynamic Adaptive Arrays Purcell et al. introduced the
first dynamic adaptive GPU array, the kNN-grid photon
map [PDC∗03]. The structure uses a one-level page table
with either variable-sized or fixed-sized pages. They update
the variable-page-size version by sorting data elements and
searching for the beginning of each page. The fixed-page-
size variant limits the number of data elements per page but
avoids the costly sorting and searching steps.
Lefohn et al. use a mipmap hierarchy of page ta-
bles to define quadtree-like and octree-like dynamic struc-
tures [LSK∗05,LKS∗06]. They apply the structures to GPU-
based adaptive shadow mapping and dynamic octree tex-
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Physical Memory
Tree 
Address TranslatorVirtual Domain
Figure 9: Tree-based address translators can be used in
place of page tables to represent adaptive data structures
such as quadtrees, octrees and k-d trees [FS05, LHN05].
Trees consume less memory than page table structures but
result in longer access times and are more costly to incre-
mentally update.
tures. The structure achieves adaptivity by mapping a vary-
ing number of virtual pages to uniformly sized physical
pages. The page tables consume more memory than a tree-
based approach but support constant-time accesses and can
be efficiently updated by the GPU. The structures support
data-parallel iteration over the active elements by drawing
a point sprite for each mapped page and using the vertex
processor and rasterizer to pre-compute physical-to-virtual
address translations.
In the limit, multilevel page tables are synonymous with
N-tree structures. Coombe et al. and Lefebvre et al. de-
scribe dynamic tree-based structures [CHL04,LHN05]. Tree
address translators consume less memory than a page ta-
ble (O(logn)), but result in slower access times (O(logn))
and require non-uniform (non-SIMD) computation. Coombe
et al. use a CPU-based quadtree translator [CHL04] while
Lefebvre et al. describe a GPU-based octree-like transla-
tor [LHN05]. Figure 9 depicts a tree-based address trans-
lator.
4.2.4. Non-Indexable Structures
All the structures discussed thus far support random ac-
cess and therefore trivially support data-parallel accesses.
Nonetheless, researchers are beginning to explore non-
indexable structures. Ernst et al. and Lefohn et al. both de-
scribe GPU-based stacks [EVG04,LKS∗06].
Efficient dynamic parallel data structures are an active
area of research. For example, structures such as priority
queues (Section 4.1.7), sets, linked lists, and hash tables have
not yet been demonstrated on GPUs. While several dynamic
adaptive tree-like structures have been implemented, many
open problems remain in efficiently building and modifying
these structures, and many structures (e.g., k-d trees) have
not yet been constructed on the GPU. Continued research in
understanding the generic components of GPU data struc-
tures may also lead to the specification of generic algo-
rithms, such as in those described in Section 4.1.
4.3. Differential Equations
Differential equations arise in many disciplines of science
and engineering. Their efficient solution is necessary for ev-
erything from simulating physics for games to detecting fea-
tures in medical imaging. Typically differential equations
are solved for entire arrays of input. For example, physi-
cally based simulations of heat transfer or fluid flow typi-
cally solve a system of equations representing the temper-
ature or velocity sampled over a spatial domain. This sam-
pling means that there is high data parallelism in these prob-
lems, which makes them suitable for GPU implementation.
Figure 10: Solving the wave equation PDE on the GPU al-
lows for fast and stable rendering of water surfaces. (Image
generated by Krüger et al. [KBW06].)
There are two main classes of differential equations: or-
dinary differential equations (ODEs) and partial differential
equations (PDEs). An ODE is an equality involving a func-
tion and its derivatives. An ODE of order n is an equation of
the form F(x,y, ∂y∂x , · · · , ∂
ny
∂xn ) = 0 where
∂ny
∂xn is the nth deriva-
tive with respect to x. A very simple yet prominent exam-
ple for ODEs is particle tracing where ∂x̃∂t = ṽ(x̃(t), t) is to
be solved over time (Figure 11). PDEs, on the other hand,
are equations involving functions and their partial deriva-
tives, like the wave equation ∂
2ψ
∂x2 +
∂2ψ
∂y2 +
∂2ψ
∂z2 =
∂2ψ
v2∂t2 (Fig-
ure 10). ODEs typically arise in the simulation of the motion
of objects, and this is where GPUs have been applied to their
solution. Particle system simulation involves moving many
point particles according to local and global forces. This re-
sults in simple ODEs that can be solved via explicit inte-
gration (most have used the well-known Euler, Midpoint,
or Runge-Kutta methods). This is relatively simple to im-
plement on the GPU: a simple fragment program is used
to update each particle’s position and velocity, which are
stored as 3D vectors in textures. Kipfer et al. presented a
method for simulating particle systems on the GPU includ-
ing inter-particle collisions by using the GPU to quickly sort
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
the particles to determine potential colliding pairs [KSW04].
In simultaneous work, Kolb et al. produced a GPU particle
system simulator that supported accurate collisions of parti-
cles with scene geometry by using GPU depth comparisons
to detect penetration [KLRS04]. Krüger et al. presented a
scientific flow exploration system that supports a wide va-
riety of of visualization geometries computed entirely on
the GPU [KKKW05] (Figure 11). A simple GPU particle
system example is provided in the NVIDIA SDK [Gre04].
Nyland et al. extended this example to add n-body gravita-
tional force computation [NHP04]. Related to particle sys-
tems is cloth simulation. Green demonstrated a very simple
GPU cloth simulation using Verlet integration [Ver67] with
basic orthogonal grid constraints [Gre03]. Zeller extended
this with shear constraints which can be interactively bro-
ken by the user to simulate cutting of the cloth into multiple
pieces [Zel05].
Figure 11: GPU-computed stream ribbons in a 3D flow
field. The entire process from vectorfield interpolation and
integration to curl computation, and finally geometry gener-
ation and rendering of the stream ribbons, is performed on
the GPU [KKKW05].
When solving PDEs, the two common methods of sam-
pling the domain of the problem are finite differences and
finite element methods (FEM). The former has been much
more common in GPU applications due to the natural map-
ping of regular grids to the texture sampling hardware
of GPUs. Most of this work has focused on solving the
pressure-Poisson equation that arises in the discrete form of
the Navier-Stokes equations for incompressible fluid flow.
Among the numerical methods used to solve these systems
are the conjugate gradient method (Bolz et al. [BFGS03]
and Krüger andWestermann [KW03]), the multigrid method
(Bolz et al. [BFGS03] and Goodnight et al. [GWL∗03]), and
simple Jacobi and red-black Gauss-Seidel iteration (Harris
et al. [HBSL03]).
The earliest work on using GPUs to solve PDEs was
done by Rumpf and Strzodka, who mapped mathemati-
cal structures like matrices and vectors to textures and lin-
ear algebra operations to GPU features such as blending
and the OpenGL imaging subset. They applied the GPU
to segmentation and non-linear diffusion in image process-
ing [RS01b, RS01a] and used GPUs to solve finite ele-
ment discretizations of PDEs like the anisotropic heat equa-
tion [RS01c]. Recent work by Rumpf and Strzodka [RS05]
discusses the use of finite element schemes for PDE solvers
on GPUs in detail. Lefohn and Whitaker applied GPUs to
the solution of sparse, non-linear PDEs (level-set equations)
for volume segmentation [LW02,Lef03].
4.4. Linear Algebra
As GPU flexibility has increased over the last decade, re-
searchers were quick to realize that many linear algebraic
problems map very well to the pipelined SIMD hardware in
these processors. Furthermore, linear algebra techniques are
of special interest for many real-time visual effects important
in computer graphics. A particularly good example is fluid
simulation (Section 5.2), for which the results of the numer-
ical computation can be computed in and displayed directly
from GPU memory.
Larsen and McAllister described an early pre-floating-
point implementation of matrix multiplies. Adopting a tech-
nique from parallel computing that distributes the computa-
tion over a logically cube-shaped lattice of processors, they
used 2D textures and simple blending operations to perform
the matrix product [LM01]. Thompson et al. proposed a gen-
eral computation framework running on the GPU vertex pro-
cessor; among other test cases they implemented some linear
algebra operations and compared the timings to CPU imple-
mentations. Their test showed that especially for large ma-
trices a GPU implementation has the potential to outperform
optimized CPU solutions [THO02].
With the availability of 32-bit IEEE floating point textures
and more sophisticated shader functionality in 2003, Hilles-
land et al. presented numerical solution techniques to least
squares problems [HMG03]. Bolz et al. [BFGS03] presented
a representation for matrices and vectors. They implemented
a sparse matrix conjugate gradient solver and a regular-
grid multigrid solver for GPUs, and demonstrated the effec-
tiveness of their approach by using these solvers for mesh
smoothing and solving the incompressible Navier-Stokes
equations. Goodnight et al. presented another multigrid
solver; their solution focused on an improved memory layout
of the domain [GWL∗03] that avoids the context-switching
latency that arose with the use of OpenGL pbuffers.
Other implementations avoided this pbuffer latency by
using the DirectX API. Moravánszky [Mor02] proposed a
GPU-based linear algebra system for the efficient repre-
sentation of dense matrices. Krüger and Westermann took
a broader approach and presented a general linear algebra
framework supporting basic operations on GPU-optimized
representations of vectors, dense matrices, and multiple
types of sparse matrices [KW03].
Using this set of operations, encapsulated into C++
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
classes, Krüger and Westermann enabled more complex al-
gorithms to be built without knowledge of the underlying
GPU implementation [KW03]. For example, a conjugate
gradient solver was implemented with fewer than 20 lines
of C++ code. This solver in turn can be used for the solution
of PDEs such as the Navier-Stokes equations for fluid flow
(Figure 12).
Figure 12: This image shows a 2D Navier-Stokes fluid
flow simulation with arbitrary obstacles. It runs on a stag-
gered 512 by 128 grid. Even with additional features like
vorticity confinement enabled, such simulations perform
at about 300 fps on current GPUs such as ATI’s Radeon
X1800 [KW03].
Apart from their applications in numerical simulation,
linear algebra operators can be used for GPU perfor-
mance evaluation and comparison to CPUs. For instance
Brook [BFH∗04b] featured a spMatrixVec test that used a
padded compressed sparse row format.
Galoppo et al. [GGHM05] presented an approach to effi-
ciently solve dense linear systems. In contrast to the sparse
matrix approaches, they stored the entire matrix as a single
2D texture, allowing them to efficiently modify matrix en-
tries. The results show that even for dense matrices the GPU
is able to outperform highly optimized ATLAS implementa-
tions.
Instead of focusing on iterative methods, Kass et al. re-
cently described a direct tridiagonal linear solver on GPUs
used for interactive depth of field simulation [KLO06].
A general evaluation of the suitability of GPUs for linear
algebra operations was done by Fatahalian et al. [FSH04].
They focused on matrix-matrix multiplication and discov-
ered that these operations are strongly limited by mem-
ory bandwidth when implemented on the GPU. They ex-
plained the reasons for this behavior and proposed architec-
tural changes to further improve GPU linear algebra perfor-
mance. To better adapt to such future hardware changes and
to address vendor-specific hardware differences, Jiang and
Snir presented a first evaluation of automatically tuning GPU
linear algebra code [JS05].
The major limitation of all of these approaches is the lack
of double precision on current GPUs making them unusable
for certain applications. To overcome this issue Göddeke et
al. [GST06] analyzed native, emulated, and mixed precision
approaches for systems of linear equations as they typically
arise in the FEM context. They reported speedups of four
to five for a mixed precision CPU-GPU over a native CPU
implementation. Later Strzodka and Göddeke showed that
these iterative refinement methods can be generalized to ar-
bitrary convergent iterative processes [SG06].
4.5. Data Queries
In this section, we provide a brief overview of the ba-
sic database queries that can be performed efficiently on a
GPU [GLW∗04].
Given a relational table T of m attributes (a1,a2, ...,am), a
basic SQL query takes the form
Select A
from T
where C
where A is a list of attributes or aggregations defined on in-
dividual attributes and C is a Boolean combination of pred-
icates that have the form ai op a j or ai op constant. The
operator op may be any of the following: =, =,>,≥,<,≤.
Broadly, SQL queries involve three categories of basic oper-
ations: predicates, Boolean combinations, aggregations, and
join operations and are implemented efficiently using graph-
ics processors as follows:
Predicates We can use the depth test and the stencil test
functionality for evaluating predicates in the form of ai op
constant. Predicates involving comparisons between two
attributes, ai op a j, are transformed to (ai− a j) op 0 us-
ing the programmable pipeline and are evaluated using the
depth and stencil tests.
Boolean combinations A Boolean combination of predi-
cates is expressed in a conjunctive normal form. The sten-
cil test can be used repeatedly to evaluate a series of log-
ical operators with the intermediate results stored in the
stencil buffer.
Aggregations These include simple operations such as
COUNT, AVG, and MAX. The COUNT query can
be implemented using the counting capability of the
occlusion queries. The SUM query is computed as
∑ki=0 2
i COUNT(Select a j from T where a j =
2i) where k is the number of bits in the data represen-
tation. Similarly, the AVG and MAX queries are imple-
mented using COUNT operation at each bit-location in
the data representation.
Join Operations Join operations combine the records in
multiple relations with a common key attribute. They
are computationally expensive, and can be accelerated by
sorting the records based on the join key. The fast sort-
ing algorithms described in Section 4.1.6 are used to effi-
ciently order the records based on the join key [GM05].
The attributes of each database record are stored in the
multiple channels of a single texel, or in the same texel lo-
cation of multiple textures, and are accessed at run-time to
evaluate the queries.
The above queries are key routines used in general rela-
tional databases. Bustos et al. [BDHK06] presented nearest
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
neighbor search algorithms for point datasets using GPUs.
The nearest neighbor queries often arise in multimedia
databases, data mining and information retrieval applica-
tions. They represent datasets using multiple 2D textures,
and at run time, a simple fragment program is used to com-
pute the distance between the dataset vectors and the input
vector. Then, the nearest neighbor is computed using a par-
allel reduction operation on the GPU. In order to handle
large high-dimensional data sets, their technique partitions
the dataset into blocks. The algorithm is iteratively applied
to each block and the nearest neighbor result is readback to
the CPU.
5. GPGPU Applications
Using many of the algorithms and techniques described in
the previous section, in this section we survey the broad
range of applications and tasks implemented on graphics
hardware.
5.1. Early Work
The use of computer graphics hardware for general-purpose
computation has been an area of active research for many
years, beginning on machines like the Ikonas [Eng78], the
Pixel Machine [PH89], and Pixel-Planes 5 [FPE∗89]. Pixar’s
Chap [LP84] was one of the earliest processors to explore
a programmable SIMD computational organization, on 16-
bit integer data; Flap [LHPL87], described three years later,
extended Chap’s integer capabilities with SIMD floating-
point pipelines. These early graphics computers were typi-
cally graphics compute servers rather than desktop worksta-
tions. Early work on procedural texturing and shading was
performed on the UNC Pixel-Planes 5 and PixelFlow ma-
chines [RTB∗92,OL98]. This work can be seen as precursor
to the high-level shading languages in common use today
for both graphics and GPGPU applications. The PixelFlow
SIMD graphics computer [EMP∗97] was also used to crack
UNIX password encryption [KI99].
The wide deployment of GPUs in the last several years
has resulted in an increase in experimental research with
graphics hardware. The earliest work on desktop graph-
ics processors used non-programmable (“fixed-function”)
GPUs. Lengyel et al. used rasterization hardware for robot
motion planning [LRDG90]. Hoff et al. described the use
of z-buffer techniques for the computation of Voronoi di-
agrams [HCK∗99] and extended the method to proxim-
ity detection [HZLM01]. Bohn used fixed-function graph-
ics hardware in the computation of artificial neural net-
works [Boh98]. Convolution and wavelet transforms with
the fixed-function pipeline were realized by Hopf and
Ertl [HE99a,HE99b].
Programmability in GPUs first appeared in the form of
vertex programs combined with a limited form of fragment
programmability via extensive user-configurable texture ad-
dressing and blending operations. While these don’t con-
stitute a true ISA, so to speak, they were abstracted in a
very simple shading language in Microsoft’s pixel shader
version 1.0 in Direct3D 8.0. Trendall and Stewart gave a
detailed summary of the types of computation available on
these GPUs [TS00]. Thompson et al. used the programmable
vertex processor of an NVIDIA GeForce 3 GPU to solve
the 3-Satisfiability problem and to perform matrix multipli-
cation [THO02]. A major limitation of this generation of
GPUs was the lack of floating-point precision in the frag-
ment processors. Strzodka showed how to combine mul-
tiple 8-bit texture channels to create virtual 16-bit precise
operations [Str02], and Harris analyzed the accumulated er-
ror in boiling simulation operations caused by the low pre-
cision [Har02]. Strzodka constructed and analyzed special
discrete schemes which, for certain PDE types, allow re-
production of the qualitative behavior of the continuous so-
lution even with very low computational precision, e.g. 8
bits [Str04].
5.2. Physically Based Simulation
Early GPU-based physics simulations used cellular tech-
niques such as cellular automata (CA). Greg James of
NVIDIA demonstrated the “Game of Life” cellular automata
and a 2D physically based wave simulation running on
NVIDIA GeForce 3 GPUs [Jam01a, Jam01b, Jam01c]. Har-
ris et al. used a Coupled Map Lattice (CML) to simulate
dynamic phenomena that can be described by partial differ-
ential equations, such as boiling, convection, and chemical
reaction-diffusion [HCSL02]. The reaction-diffusion portion
of this work was later extended to a finite difference imple-
mentation of the Gray-Scott equations using floating-point-
capable GPUs [HJ03]. Kim and Lin used GPUs to simu-
late dendritic ice crystal growth [KL03]. Related to cellular
techniques are lattice simulation approaches such as Lattice-
Boltzmann Methods (LBM), used for fluid and gas simula-
tion. LBM represents fluid velocity in “packets” traveling
in discrete directions between lattice cells. Li et al. have
used GPUs to apply LBM to a variety of fluid flow prob-
lems [LWK03,LFWK05].
Full floating point support in GPUs has enabled the next
step in physically based simulation: finite difference and fi-
nite element techniques for the solution of systems of partial
differential equations (PDEs). Spring-mass dynamics on a
mesh were used to implement basic cloth simulation on a
GPU [Gre03, Zel05]. Several researchers have also imple-
mented particle system simulation on GPUs (Section 4.3).
Several groups have used the GPU to successfully simu-
late fluid dynamics. Four papers in the summer of 2003 pre-
sented solutions of the Navier-Stokes equations (NSE) for
incompressible fluid flow on the GPU [BFGS03, GWL∗03,
HBSL03, KW03]. Harris provides an introduction to the
NSE and a detailed description of a basic GPU implemen-
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
tation [Har04]. Harris et al. combined GPU-based NSE so-
lutions with PDEs for thermodynamics and water conden-
sation and light scattering simulation to implement visual
simulation of cloud dynamics [HBSL03]. Recently Hagen
et al. [HLN06] simulated the dynamics of ideal gases in two
and three dimensions described by the Euler equations on
the GPU.
Other recent work includes flow calculations around
arbitrary obstacles [BFGS03, KW03, LLW04]. Sander et
al. [STM04] described the use of GPU depth-culling hard-
ware to accelerate flow around obstacles, and sample code
that implements this technique is made available by Har-
ris [Har05b]. Rumpf and Strzodka used a quantized FEM
approach to solving the anisotropic heat equation on a
GPU [RS01c] (Section 4.3). Kolb and Cuntz [KC05] simu-
lated fluids with the SPH method using flattened 3D textures
and point sprites on the GPU.
Related to fluid simulation is the visualization of flows,
which has been implemented using graphics hardware to ac-
celerate line integral convolution and Lagrangian-Eulerian
advection [HWSE99, JEH01,WHE01].
Recently rigid body simulation for computer games has
been shown to perform very well on GPUs. Havok [Bon06,
GH06] demonstrated an API for rigid body and particle sim-
ulation on GPUs, featuring full collisions between rigid bod-
ies and particles, as well as support for simulating and ren-
dering on separate GPUs in a multi-GPU system. Running
on a PC with dual NVIDIA GeForce 7900 GTX GPUs and
a dual-core AMD Athlon 64 X2 CPU, Havok FX achieves
more than a 10x speedup running on GPUs compared to an
equivalent, highly optimized multithreaded CPU implemen-
tation running on the dual-core CPU alone.
5.3. Signal and Image Processing
The high computational rates of the GPU have made graph-
ics hardware an attractive target for demanding applications
such as those in signal and image processing. Among the
most prominent applications in this area are those related
to image segmentation (Section 5.3.1) as well as a variety
of other applications across the gamut of signal, image, and
video processing (Section 5.3.2).
5.3.1. Segmentation
The segmentation problem seeks to identify features embed-
ded in 2D or 3D images. A driving application for segmen-
tation is medical imaging. A common problem in medical
imaging is to identify a 3D surface embedded in a volume
image obtained with an imaging technique such as Magnetic
Resonance Imaging (MRI) or Computed Tomograph (CT)
Imaging. Fully automatic segmentation is an unsolved im-
age processing research problem. Semi-automatic methods,
however, offer great promise by allowing users to interac-
tively guide image processing segmentation computations.
GPGPU segmentation approaches have made a significant
contribution in this area by providing speedups of more than
10 times and coupling the fast computation to an interactive
volume renderer.
Image thresholding is a simple form of segmentation that
determines if each pixel in an image is within the segmented
region based on the pixel value. Yang and Welch [YW03]
used register combiners to perform thresholding and basic
convolutions on 2D color images. Their NVIDIA GeForce4
GPU implementation demonstrated a 30% speed increase
over a 2.2GHz Intel Pentium 4 CPU. Viola et al. performed
threshold-based 3D segmentations combined with an inter-
active visualization system and observed an approximately
8 times speedup over a CPU implementation [VKG03].
Implicit surface deformation is a more powerful and accu-
rate segmentation technique than thresholding but requires
significantly more computation. These level-set techniques
specify a partial differential equation (PDE) that evolves an
initial seed surface toward the final segmented surface. The
resulting surface is guaranteed to be a continuous, closed
surface.
Rumpf and Strzodka were the first to implement level-
set segmentation on GPUs [RS01a]. They supported 2D im-
age segmentation using a 2D level-set equation with inten-
sity and gradient image-based forces. Lefohn et al. extended
that work and demonstrated the first 3D level-set segmen-
tation on the GPU [LW02]. Their implementation also sup-
ported a more complex evolution function that allowed users
to control the curvature of the evolving segmentation, thus
enabling smoothing of noisy data. These early implementa-
tions computed the PDE on the entire image despite the fact
that only pixels near the segmented surface require compu-
tation. As such, these implementations were not faster than
highly optimized sparse CPU implementations.
The first GPU-based sparse segmentation solvers came a
year later. Lefohn et al. [LKHW03,LKHW04] demonstrated
a sparse (narrow-band) 3D level-set solver, using the sparse
data structure techniques of Section 4.2.2, that provided a
speedup of 10–15 times over a highly optimized CPU-based
solver [Ins03] (Figure 13). Concurrently, Sherbondy et al.
presented a GPU-based 3D segmentation solver based on the
Perona-Malik PDE [SHN03]. They also performed sparse
computation, but had a dense (complete) memory represen-
tation. They used the depth culling technique for conditional
execution to perform sparse computation. Both of these seg-
mentation systems were integrated with interactive volume
renderers.
Griesser et al.’s recent work concentrates specifically on
GPU-based foreground/background segmentation for im-
age sequences [GDNV05,Gri05], using an iterative solution
run to convergence on a 3×3 neighborhood at each pixel.
They incorporate darkness compensation into their algo-
rithm and typically achieve frame times on the order of 4ms
on 640×480 images with an NVIDIA GeForce 6800GT.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Figure 13: Interactive volume segmentation and visualiza-
tion of Magnetic Resonance Imaging (MRI) data on the
GPU enables fast and accurate medical segmentations. Im-
age generated by Lefohn et al. [LKHW04].
5.3.2. Other Signal and Image Processing Applications
Computer Vision Fung et al. use graphics hardware
to accelerate image projection and compositing oper-
ations [FTM02] in a camera-based head-tracking sys-
tem [FM04]; their implementation has been released as the
open-source OpenVIDIA computer vision library [Ope06],
whose website also features a good bibliography of papers
for GPU-based computer/machine vision applications.
Yang and Pollefeys used GPUs for real-time stereo depth
extraction from multiple images [YP05]. Their pipeline first
rectifies the images using per-pixel projective texture map-
ping, then computes disparity values between the two im-
ages, and, using adaptive aggregation windows and cross
checking, chooses the most accurate disparity value. Their
implementation was more than four times faster than a com-
parable CPU-based commercial system. Both Geys et al. and
Woetzel and Koch addressed a similar problem using a plane
sweep algorithm. Geys et al. compute depth from pairs of
images using a fast plane sweep to generate a crude depth
map, then use a min-cut/max-flow algorithm to refine the
result [GKV04]; the approach of Woetzel and Koch begins
with a plane sweep over images from multiple cameras and
pays particular attention to depth discontinuities [WK04].
Image Processing The process of image registration es-
tablishes a correlation between two images by means of
a (possibly non-rigid) deformation. Before the emergence
of programmable hardware, Rezk-Salama et al.’s 1999
work [RSHGE99] exploited the trilinear interpolation capa-
bilities of 3D texturing hardware for nonlinear image reg-
istration in a medical volume rendering application, with
the hardware implementation two orders of magnitude faster
than the software implementation. The work of Strzodka et
al. is one of the earliest to use the programmable floating
point capabilities of graphics hardware in this area [SDR03,
SDR04]; their image registration implementation is based on
the multi-scale gradient flow registration method of Clarenz
et al. [CDR02] and uses an efficient multi-grid represen-
tation of the image multi-scales, a fast multi-grid regular-
ization, and an adaptive time-step control of the iterative
solvers. They achieve per-frame computation time of under
2 seconds on pairs of 256×256 images.
Strzodka and Garbe describe a real-time system that com-
putes and visualizes motion on 640×480 25 Hz 2D image
sequences using graphics hardware [SG04]. Their system
assumes that image brightness only changes due to motion
(due to the brightness change constraint equation). Using
this assumption, they estimate the motion vectors from cal-
culating the eigenvalues and eigenvectors of the matrix con-
structed from the averaged partial space and time derivatives
of image brightness. In the context of video compression,
Kelly and Kokaram describe their gradient-based motion es-
timator [KK04], implemented on the GPU, that uses a hi-
erarchical Wiener-based algorithm that is robust to noise.
Both of these papers demonstrate performance improve-
ments over a CPU implementation.
Computed tomography (CT) methods that reconstruct
an object from its projections are computationally inten-
sive and often accelerated by special-purpose hardware.
Xu and Mueller implement three 3D reconstruction algo-
rithms (Feldkamp Filtered Backprojection, SART, and EM)
on programmable graphics hardware, achieving high-quality
floating-point 1283 reconstructions from 80 projections in
time frames from seconds to tens of seconds [XM05].
Erra recently introduced fractal image compression to the
GPU with a brute-force Cg implementation that achieved a
speedup of over 100:1 over a comparable CPU implementa-
tion [Err05].
Signal Processing Motivated by the high arithmetic ca-
pabilities of modern GPUs, several projects have devel-
oped GPU implementations of the fast Fourier transform
(FFT) [BFH∗04b, JvHK04, MA03, MAH02, SL05, SW04,
Wlo03]. (The GPU Gems 2 chapter by Sumanaweera and
Liu, in particular, gives a detailed description of the FFT
and their GPU implementation [SL05].) In general, these
implementations operate on 1D or 2D input data, use a
Cooley-Tukey radix-2 decimation-in-time approach (with
the exception of Jansen et al.’s decimation-in-frequency ap-
proach [JvHK04]), and require one fragment-program pass
per FFT stage. Govindaraju et al. suggest that the Stockham
formulation of the FFT is better suited for the GPU by avoid-
ing the need for bit reversal [GLGM06]; in their implemen-
tation they focus on efficient cache utilization. The real and
imaginary components of the FFT can be computed using
two components of the 4-vectors in each fragment proces-
sor, so many implementations support processing two FFTs
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
in parallel; other implementations use multiple render tar-
gets [GLGM06] or clever packing [Hor06] to fully utilize
the 4-wide arithmetic units in the fragment processors on a
single FFT.
Daniel Horn’s open-source “libgpufft” FFT li-
brary [Hor06] is one of the performance leaders in
GPU FFTs. Horn’s implementation is written in Brook,
runs efficiently on both NVIDIA and ATI hardware, and is
notable for its full use of 4-wide arithmetic on a single FFT
in the fragment program and its identical communication
pattern across all stages. Owens et al.’s analysis of this
library [OSH05] showed that repeated computation of
1D FFTs on the GPU had comparable performance to a
highly tuned CPU implementation [FJ98]; the GPU was
limited by overhead, memory bandwidth, and the lack of
write-back GPU caches, while the CPU was limited by
computation. GPUs are correspondingly better than CPUs
on 2D FFTs because of poorer CPU cache performance on
2D FFTs [Buc05a].
A GPU implementation of the related discrete cosine
transform (DCT), used in JPEG and MPEG compression,
was recently presented by Green [Gre05]. The discrete
wavelet transform (DWT), used in the JPEG2000 standard,
is another useful fundamental signal processing operation; a
group from the Chinese University of Hong Kong has de-
veloped a GPU implementation of the DWT [WWHL04],
which has been integrated into an open-source JPEG2000
codec called “JasPer” [Ada05].
Smirnov and Chuieh compared finite-impulse-response
(FIR) filter performance for three FIR components from
GNU Radio [SC05], finding that GPU FIR performance was
superior to CPU performance for very large numbers of FIR
taps, and that replacing CPU stages of a GNU radio receiver
with GPU stages also improved overall performance.
Infinite impulse response (IIR) filters, unlike FIR filters,
have an impulse response with infinite extent. As a result,
each evaluation of an infinite impuse response filter depends
on the result from the previous sample. This serial depen-
dence has been refactored into a parallel GPU-compatible
formulation in two ways. Simon Green described an im-
plementation of separable 2D IIRs by drawing one row
or column of an image, synchronizing between each itera-
tion [Gre05]. More recently, Kass et al. presented a more
efficient parallel formulation of 2D IIRs on the GPU using
cyclic reduction implemented with a parallel-prefix scan for-
mulation [KLO06].
Tone Mapping Tone mapping is the process of mapping
pixel intensity values with high dynamic range to the smaller
range permitted by a display. Goodnight et al. implemented
an interactive, time-dependent tone mapping system on
GPUs [GWWH03]. In their implementation, they chose the
tone-mapping algorithm of Reinhard et al. [RSSF02], which
is based on the “zone system” of photography, for two rea-
sons. First, the transfer function that performs the tone map-
ping uses a minimum of global information about the im-
age, making it well-suited to implementation on graphics
hardware. Second, Reinhard et al.’s algorithm can be adap-
tively refined, allowing a GPU implementation to trade off
efficiency and accuracy. Among the tasks in Goodnight et
al.’s pipeline was an optimized implementation of a Gaus-
sian convolution. On an ATI Radeon 9800, they were able
to achieve highly interactive frame rates with few adaptation
zones (limited by mipmap construction) and a few frames
per second with many adaptation zones (limited by the per-
formance of the Gaussian convolution).
Audio Gallo and Tsingos characterized GPUs for two au-
dio rendering kernels [GT04], analyzing the performance
of variable-delay-line and filtering operations. Their imple-
mentation was 20% slower than a CPU implementation, and
they identified floating-point texture resampling and long 1D
texture support as desirable features for improving perfor-
mance. Jędrzejewski used ray tracing techniques on GPUs
to compute echoes of sound sources in highly occluded en-
vironments [Jęd04]. BionicFX has developed commercial
“Audio Video Exchange” (AVEX) software that accelerates
audio effect calculations using GPUs [Bio06].
Image/Video Processing Frameworks Apple’s Core Im-
age and Core Video frameworks allow GPU acceleration
of image and video processing tasks [App06a]; the open-
source framework Jahshaka uses GPUs to accelerate video
compositing [Jah06].
5.4. Global Illumination
Perhaps not surprisingly, one of the early areas of GPGPU
research was aimed at improving the visual quality of GPU-
generated images. Many of the techniques described below
accomplish this by simulating an entirely different image
generation process from within a fragment program (e.g. a
ray tracer). These techniques use the GPU strictly as a com-
puting engine. Other techniques leverage the GPU to per-
form most of the rendering work, and augment the result-
ing image with global effects. Figure 14 shows images from
some of the techniques we discuss in this section.
5.4.1. Ray Tracing
Ray tracing is a rendering technique based on simulating
light interactions with surfaces [Whi80]. It is nearly the re-
verse of the traditional GPU rendering algorithm: the color
of each pixel in an image is computed by tracing rays out
from the scene camera and discovering which surfaces are
intersected by those rays and how light interacts with those
surfaces. The ray-surface intersection serves as a core for
many global illumination algorithms. Perhaps it is not sur-
prising, then, that ray tracing was one of the earliest GPGPU
global illumination techniques to be implemented.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
(a) (b) (c) (d)
Figure 14: Sample images from several global illumination techniques implemented on the GPU. (a) Ray tracing and photon
mapping [PDC∗03]. (b) Radiosity [CHL04]. (c) Subsurface scattering [CHH03]. (d) Final gather by rasterization [Hac05].
Ray tracing consists of several types of computation: ray
generation, ray-surface intersection, and ray-surface shad-
ing. Generally, there are too many surfaces in a scene to test
every ray against every surface for intersection, so special
data structures (called acceleration structures) are used to
reduce the total number of surfaces rays need to be tested
against. Ray-surface shading generally requires generating
additional rays to test against the scene (e.g. shadow rays,
reflection rays, etc.) The earliest GPGPU ray tracing sys-
tems demonstrated that the GPU was capable of not only
performing ray-triangle intersections [CHH02], but that the
entire ray tracing computation including acceleration struc-
ture traversal and shading could be implemented entirely
within a set of fragment programs [PBMH02, Pur04]. Sec-
tion 4.2 enumerates several of the data structures used in this
ray tracer.
Nearly all of the major ray tracing acceleration structures
have been implemented in some form on the GPU: uni-
form grids [PBMH02, Pur04], k-d trees [FS05], and bound-
ing volume hierarchies [TS05]. Detailed comparisons be-
tween GPU implementations of these three acceleration
structures can be found in Thrane and Simonsen’s masters
thesis [TS05]. All of these structures are limited to acceler-
ating ray tracing of static scenes. The efficient implementa-
tion of dynamic ray tracing acceleration structures is an ac-
tive research topic for both CPU and GPU-based ray tracers.
Recent work by Carr et al. [CHCH06] describes a dynamic
bounding volume hierarchy acceleration structure, though
the current implementation is limited to accelerating only a
single mesh.
Some of the early GPU-based ray tracing work required
special drivers, as features like fragment programs and float-
ing point buffers were relatively new and rapidly evolving.
There are currently open-source GPU-based ray tracers that
run with standard drivers and APIs [Chr05,KL04].
Finally, Weiskopf et al. have implemented nonlinear ray
tracing on the GPU [WSE04]. Nonlinear ray tracing is a
technique that can be used for visualizing gravitational phe-
nomena such as black holes, or light propagation through
media with a varying index of refraction (which can pro-
duce mirages). Their technique builds upon the linear ray
tracing discussed previously, and approximates curved rays
with multiple ray segments.
5.4.2. Photon Mapping
Photon mapping [Jen96] is a two-stage global illumination
algorithm. The first stage consists of emitting photons from
the light sources in the scene, simulating the photon interac-
tions with surfaces, and finally storing the photons in a data
structure for lookup during the second stage. The second
stage in the photon mapping algorithm is a rendering stage.
Initial surface visibility and direct illumination are computed
first, often by ray tracing. Then, the light contributed to each
surface point by the environment (indirect) or through focus-
ing by reflection or refraction (caustic) is computed. These
computations are done by querying the photon map to get
estimates for the amount of energy that arrived from these
sources.
Tracing photons is much like ray tracing (Section 5.4.1).
Constructing the photon map and indexing the map to find
good energy estimates at each image point are much more
difficult on the GPU than the CPU. Purcell et al. imple-
mented two different techniques for constructing the pho-
ton map and a technique for querying the photon map, all
of which run at interactive rates [PDC∗03] (Sections 4.1.7
and 4.2 contain some implementation details). Figure 14a
shows an image rendered with this system. Larsen and Chris-
tensen load-balance photon mapping between the GPU and
the CPU and exploit inter-frame coherence to achieve very
high frame rates for photon mapping [LC04].
Finally, caustics rendering can be performed interactively
on the GPU using image-space techniques. Wyman and
Davis [WD06] describe a caustics rendering technique that
works by rendering the scene from the light source, and stor-
ing the x,y,z location for the nearest diffuse surface. They
then evaluate indirect illumination by directly drawing these
photons, or by performing an image-space nearest neighbor
search. Shah et al. [SKP06] describe a caustics rendering
technique which works by splatting photons into a caustics
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
map via point rendering. Caustics are then rendered by pro-
jecting visible scene points into the light source coordinate
system and indexing into the caustic map, much like current
shadow mapping techniques.
5.4.3. Radiosity
At a high level, radiosity works much like photon mapping
when computing global illumination for diffuse surfaces. In
a radiosity-based algorithm, energy is transferred around the
scene much like photons are. Unlike photon mapping, the
energy is not stored in a separate data structure that can be
queried at a later time. Instead, the geometry in the scene is
subdivided into patches or elements, and each patch stores
the energy arriving on that patch.
The classical radiosity algorithm [GTGB84] solves
for all energy transfer simultaneously. Classical radiosity
was implemented on the GPU with an iterative Jacobi
solver [CHH03]. The implementation was limited to matri-
ces of around 2000 elements, severely limiting the complex-
ity of the scenes that can be rendered.
An alternate method for solving radiosity equations,
known as progressive radiosity, iterates through the energy
transfer until the system reaches a steady state [CCWG88].
A GPU implementation of progressive radiosity can render
scenes with over one million elements [CHL04,CH05]. Fig-
ure 14b shows a sample image created with progressive re-
finement radiosity on the GPU.
5.4.4. Subsurface Scattering
Most real-world surfaces do not completely absorb, reflect,
or refract incoming light. Instead, incoming light usually
penetrates the surface and exits the surface at another lo-
cation. This subsurface scattering effect is an important
component in modeling the appearance of transparent sur-
faces [HK93]. This subtle yet important effect has also been
implemented on the GPU [CHH03]. Figure 14c shows an
example of GPU subsurface scattering. The GPU implemen-
tation of subsurface scattering uses a three-pass algorithm.
First, the amount of light on a given patch in the model is
computed. Second, a texture map of the transmitted radiosity
is built using precomputed scattering links. Finally, the gen-
erated texture is applied to the model. This method for com-
puting subsurface scattering runs in real time on the GPU.
5.4.5. Hybrid Rendering
Finally, several GPGPU global illumination methods that
have been developed do not fit with any of the classically
defined rendering techniques. Some methods use traditional
GPU rendering in unconventional ways to obtain global illu-
mination effects. Others combine traditional GPU rendering
with global illumination effects. We call all of these tech-
niques hybrid global illumination techniques.
The Parthenon renderer generates global illumination im-
ages by rasterizing the scene multiple times, from differ-
ent points of view [Hac05]. These scene rasterizations are
accumulated to form an estimate of the indirect illumina-
tion at each visible point. This indirect illumination esti-
mate is combined with direct illumination computed by tra-
ditional GPU rendering techniques. A sample image from
the Parthenon renderer is shown in Figure 14d. In a similar
fashion, Nijasure computes a sparse sampling of the scene
for indirect illumination into cubemaps [Nij03]. The indirect
illumination is progressively computed and summed with di-
rect lighting to produce a fully illuminated scene.
Szirmay-Kalos et al. demonstrate how to approxi-
mate ray tracing on the GPU by localizing environment
maps [SKALP05]. They use fragment programs to correct
reflection map lookups to more closely match what a ray
tracer would compute. Their technique can also be used to
generate multiple refractions or caustics, and runs in real
time on the GPU.
Finally, Gautron et al. describe a technique for accelerat-
ing irradiance caching using the GPU [GKBP05]. They use
the GPU to compute irradiance contributions (via splatting)
and geometric data, the CPU to traverse the irradiance data,
and the GPU to combine direct and indirect illumination for
the final image. Their technique shows well over an order of
magnitude speedup over a traditional irradiance cache im-
plementation.
5.5. Geometric Computing
GPUs have been widely used for performing a number of
geometric computations. These geometric computations are
used in many applications including motion planning, virtual
reality, etc. and include the following.
Constructive Solid Geometry (CSG) operations
CSG operations are used for geometric model-
ing in computer-aided design applications. Basic
CSG operations involve Boolean operations such as
union, intersection, and difference, and can be imple-
mented efficiently using the depth test and the stencil
test [GHF86,GMTF89,GKMV03,RR86,SLJ98].
Distance Fields and Skeletons Distance fields compute
the minimum distance of each point to a set of objects
and are useful in applications such as path planning and
navigation. Distance computation can be performed either
using a fragment program or by rendering the distance
function of each object in image space [HCK∗99,SOM04,
SPG03,ST04].
Collision Detection GPU-based collision detection algo-
rithms rasterize the objects and perform either 2D or 2.5-
D overlap tests in screen space [BW03,GRLM03,HTG03,
HTG04,HCK∗99,KP03,VSC01]. Furthermore, visibility
computations can be performed using occlusion queries
and used to compute both intra- and inter-object collisions
among multiple objects [GLM05].
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
Transparency Computation Transparency computations
require the sorting of 3D primitives or their image-space
fragments in a back-to-front or a front-to-back order and
can be performed using depth peeling [Eve01] or by
image-space occlusion queries [GHLM05].
Particle Tracing Particle tracing—and in general gener-
ation of vector-field visualizing primitives—has been
an active field of research, particularly since the avail-
ability of geometry creation and modification features
on GPUs. Recent applications make use of either the
copy-to-vertex-buffer [KLRS04, KC05], the render-to-
vertex-buffer [KSW04, KKKW05] or the vertex-texture-
fetch [KW05b, KKW05] functionality to displace primi-
tives.
Compression and LOD Techniques Quite often CPU-
based LOD techniques that are able to efficiently handle
large amounts of data suffer from the problem that the
speedup due to the reduced geometry is often neutralized
by the time for the bus transfer of the updated geometry.
Therefore, GPU-based LOD [DVS03, BS05, JWLL05]
and compression techniques [KSW05] minimize the
transfer by expanding the data on the GPU only during
rendering.
These algorithms perform computations in image space,
and require little or no pre-processing. Therefore, they work
well on deformable objects. However, the accuracy of these
algorithms is limited to image precision, and can be an issue
in some geometric computations such as collision detection.
Recently, Govindaraju et al. proposed a simple technique to
overcome the image-precision error by sufficiently “fatten-
ing” the primitives [GLM04]. The technique has been used
in performing reliable inter- and intra-object collision com-
putations among general deformable meshes [GKJ∗05].
The performance of many geometric algorithms on GPUs
is also dependent upon the layout of polygonal meshes; a
better layout more effectively utilizes the vertex caches on
GPUs. Recently, Yoon et al. proposed a novel method for
computing cache-oblivious layouts of polygonal meshes and
applied it to improve the performance of geometric appli-
cations such as view-dependent rendering and collision de-
tection on GPUs [YLPM05]. Their method does not require
any knowledge of cache parameters and does not make as-
sumptions on the data access patterns of applications. A user
constructs a graph representing an access pattern of an appli-
cation, and the cache-oblivious algorithm constructs a mesh
layout that works well with the cache parameters. The cache-
oblivious algorithm was able to achieve 2–20 times improve-
ment on many complex scenarios without any modification
to the underlying application or the run-time algorithm.
5.6. Databases and Data Mining
Database Management Systems (DBMSs) and data min-
ing algorithms are an integral part of a wide variety of
commercial applications such as online stock market trad-
ing and intrusion detection systems. Many of these appli-
cations analyze large volumes of online data and are highly
computation- and memory-intensive. As a result, researchers
have been actively seeking new techniques and architec-
tures to improve the query execution time. The high mem-
ory bandwidth and the parallel processing capabilities of
the GPU can significantly accelerate the performance of
many essential database queries such as conjunctive selec-
tions, aggregations, semi-linear queries and join queries.
These queries are described in Section 4.5. Govindaraju et al.
compared the performance of SQL queries on an NVIDIA
GeForce 6800 against a 2.8 GHz Intel Xeon processor. Pre-
liminary comparisons indicate up to an order of magnitude
improvement for the GPU over a SIMD-optimized CPU im-
plementation [GLW∗04].
GPUs are highly optimized for performing rendering op-
erations on geometric primitives and can use these capabil-
ities to accelerate spatial database operations. Sun et al. ex-
ploited the color blending capabilities of GPUs for spatial se-
lection and join operations on real world datasets [SAA03].
Bandi et al. integrated GPU-based algorithms for improving
the performance of spatial database operations into Oracle
9I DBMS [BSAE04].
Recent research has also focused attention on the effec-
tive utilization of graphics processors for fast stream min-
ing algorithms. In these algorithms, data is collected con-
tinuously and the underlying algorithm performs contin-
uous queries on the data stream as opposed to one-time
queries in traditional systems. Many researchers have advo-
cated the use of GPUs as stream processors for compute-
intensive algorithms [BFH∗04b, FF88,Man03, Ven03]. Re-
cently, Govindaraju et al. have presented fast streaming al-
gorithms using the blending and texture mapping function-
alities of GPUs [GRM05]. Data is streamed to and from the
GPU in real time, and a speedup of 2–5 times is demon-
strated on online frequency and quantile estimation queries
over high-end CPU implementations. The high growth rate
of GPUs, combined with their substantial processing power,
are making the GPU a viable architecture for commercial
database and data mining applications.
6. Conclusions: Looking Forward
The field of GPGPU computing is maturing. Early efforts
were characterized by a somewhat ad hoc approach and a
“GPGPU for its own sake” attitude; the challenge of achiev-
ing non-graphics computation on the graphics platform over-
shadowed analysis of the techniques developed or careful
comparison to well optimized, best-in-class CPU analogs.
Today researchers seeking to publish GPGPUwork typically
face a much higher bar, set by careful analyses such as Fata-
halian et al.’s examination of matrix multiplication [FSH04].
The bar is higher for novelty as well as analysis; new work
must go beyond simply “porting” an existing algorithm to
the GPU, to demonstrating general principles and techniques
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
200
300
400
500
600
700
800
20G 40G 53G 60G
Data Size
Ti
m
e 
(in
 s
ec
on
ds
)
7800 GT
6800 Ultra
Xeon
Pentium 4
6800
Figure 15: Performance of GPUTeraSort on a low-end PC
with a $250 commodity GPU and an optimized CPU-based
algorithm on high-end CPUs costing $1500. GPUTeraSort
is able to achieve 3 times better performance-price and
also scales better on gigabyte-scale databases. Result from
Govindaraju et al. [GGKM06].
or making significantly new and non-obvious use of the
hardware. Fortunately, the accumulated body of knowledge
on general techniques and building blocks surveyed in Sec-
tion 4 means that GPGPU researchers need not continually
reinvent the wheel. Meanwhile, developers wishing to use
GPUs for general-purpose computing have a broad array
of applications to learn from and build on. GPGPU algo-
rithms continue to be developed for a wide range of prob-
lems, from options pricing to protein folding. On the sys-
tems side, several research groups have major ongoing ef-
forts to perform large-scale GPGPU computing by harness-
ing large clusters of GPU-equipped computers. The emer-
gence of high-level programming languages provided a huge
leap forward for GPU developers generally, and languages
like BrookGPU [BFH∗04b] hold similar promise for non-
graphics developers who wish to harness the power of GPUs.
More broadly, GPUs may be seen as the first genera-
tion of commodity data-parallel coprocessors. Their tremen-
dous computational capacity and rapid growth curve, far
outstripping traditional CPUs, highlight the advantages of
domain-specialized data-parallel computing. We can expect
increased programmability and generality from future GPU
architectures, but not without limit; neither vendors nor users
want to sacrifice the specialized performance and architec-
ture that have made GPUs successful in the first place. The
next generation of GPU architects face the challenge of strik-
ing the right balance between improved generality and ever-
increasing performance.
At the same time, other desktop parallel machines are be-
ginning to appear in the mass market. CPU vendors are ag-
gressively pursuing multicore designs, including a hetero-
geneous example in the Cell processor produced by IBM,
Sony, and Toshiba [PAB∗05]. The tiled architecture of Cell
provides a dense computational fabric well suited to the
stream programming model discussed in Section 2.3, similar
in many ways to GPUs but oriented toward running fewer
threads with more available resources than the very large
number of fine-grained, lightweight threads on the GPU.
Perhaps the most important challenge is to find the
right high-level programming model for aggressively multi-
threaded parallel computation. Heterogenous systems such
as the Sony Playstation 3, which joins a Cell processor and
a modern GPU with a high-bandwidth 20GB/s bus, present
even more interesting opportunities and challenges. Current
graphics APIs, and GPGPU languages layered on top of
graphics APIs, hide much of the complexity of parallel ex-
ecution (such as scheduling, synchronization, locks, and so
on) with an “implicitly parallel” programming model. For
example, pixel computations must be completely indepen-
dent (e.g., no communication with neighboring pixels) and
do not include scatter operations that would enable multiple
fragment processors to write to the same pixel. GPUs are
growing more general, low-level GPGPU programming is
being supplanted by high-level languages and toolkits, and
new general-purpose data-parallel contenders such as the
Cell chip have emerged. Can the GPGPU research commu-
nity build on its experience with successful, high-level paral-
lel programming models to transcend its computer graphics
roots and develop the computational idioms, techniques, and
frameworks for the desktop parallel computing environment
of the future?
This article is an updated and extended version of the au-
thors’ 2005 State of the Art Report, presented at Eurograph-
ics 2005 [OLG∗05].
References
[Ada05] ADAMS M.: JasPer project. http://www.
ece.uvic.ca/~mdadams/jasper/, 2005.
[AJR∗01] AN P., JULA A., RUS S., SAUNDERS S.,
SMITH T., TANASE G., THOMAS N., AMATO N.,
RAUCHWERGER L.: STAPL: An adaptive, generic par-
allel C++ library. In Workshop on Languages and Com-
pilers for Parallel Computing (Aug. 2001), pp. 193–208.
[App06a] Apple Computer Core Image. http://www.
apple.com/macosx/tiger/coreimage.html,
2006.
[App06b] Apple Computer OpenGL shader builder
/ profiler. http://developer.apple.com/
graphicsimaging/opengl/, 2006.
[Bat68] BATCHER K. E.: Sorting networks and their ap-
plications. In Proceedings of the AFIPS Spring Joint
Computing Conference (Apr. 1968), vol. 32, pp. 307–314.
[Bax06] BAXTER B.: The image debugger. http://
www.billbaxter.com/projects/imdebug/,
2006.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
[BDHK06] BUSTOS B., DEUSSEN O., HILLER S., KEIM
D.: A graphics hardware accelerated algorithm for near-
est neighbor search. In Proceedings of the 6th Interna-
tional Conference on Computational Science, vol. 3994 of
Lecture Notes in Computer Science. Springer, May 2006,
pp. 196–199.
[Ben75] BENTLEY J. L.: Multidimensional binary search
trees used for associative searching. Communications of
the ACM 18, 9 (Sept. 1975), 509–517.
[BFGS03] BOLZ J., FARMER I., GRINSPUN E.,
SCHRÖDER P.: Sparse matrix solvers on the GPU:
Conjugate gradients and multigrid. ACM Transactions on
Graphics (Proceedings of ACM SIGGRAPH 2003) 22, 3
(July 2003), 917–924.
[BFH04a] BUCK I., FATAHALIAN K., HANRAHAN P.:
GPUBench: Evaluating GPU performance for numeri-
cal and scientific applications. In 2004 ACM Workshop
on General-Purpose Computing on Graphics Processors
(Aug. 2004), pp. C–20.
[BFH∗04b] BUCK I., FOLEY T., HORN D., SUGERMAN
J., FATAHALIAN K., HOUSTON M., HANRAHAN P.:
Brook for GPUs: Stream computing on graphics hard-
ware. ACM Transactions on Graphics 23, 3 (Aug. 2004),
777–786.
[Bio06] BionicFX. http://www.bionicfx.com/,
2006.
[Ble90] BLELLOCH G.: Vector Models for Data-Parallel
Computing. MIT Press, 1990.
[Bly06] BLYTHE D.: The Direct3D 10 system. ACM
Transactions on Graphics 25, 3 (Aug. 2006), 724–734.
[Boh98] BOHN C. A.: Kohonen feature mapping through
graphics hardware. In Proceedings of the Joint Confer-
ence on Information Sciences (1998), vol. II, pp. 64–67.
[Bon06] BOND A.: Havok FX: GPU-accelerated physics
for PC games. In Proceedings of Game Developers
Conference 2006 (Mar. 2006). http://www.havok.
com/content/view/187/77/.
[BP03] BLEIWEISS A., PREETHAM A.: Ashli—
Advanced shading language interface. ACM SIGGRAPH
Course Notes (July 2003). http://www.ati.com/
developer/SIGGRAPH03/AshliNotes.pdf.
[BP04] BUCK I., PURCELL T.: A toolkit for computation
on GPUs. In GPU Gems, Fernando R., (Ed.). Addison
Wesley, Mar. 2004, pp. 621–636.
[BS05] BOUBEKEUR T., SCHLICK C.: Generic mesh re-
finement on GPU. In Graphics Hardware 2005 (July
2005), pp. 99–104.
[BSAE04] BANDI N., SUN C., AGRAWAL D., EL
ABBADI A.: Hardware acceleration in commercial
databases: A case study of spatial operations. In Pro-
ceedings of the Thirtieth International Conference on Very
Large Data Bases (Sept. 2004), pp. 1021–1032.
[Buc05a] BUCK I.: GPGPU: General-purpose compu-
tation on graphics hardware—high level languages for
GPUs. ACM SIGGRAPH Course Notes (Aug. 2005).
[Buc05b] BUCK I.: Taking the plunge into GPU comput-
ing. In GPU Gems 2, Pharr M., (Ed.). Addison Wesley,
Mar. 2005, ch. 32, pp. 509–519.
[BW03] BACIU G., WONG W. S. K.: Image-based tech-
niques in a hybrid collision detector. IEEE Transactions
on Visualization and Computer Graphics 9, 2 (Apr. 2003),
254–271.
[CCWG88] COHEN M. F., CHEN S. E., WALLACE J. R.,
GREENBERG D. P.: A progressive refinement approach
to fast radiosity image generation. In Computer Graph-
ics (Proceedings of SIGGRAPH 88) (Aug. 1988), vol. 22,
pp. 75–84.
[CDR02] CLARENZ U., DROSKE M., RUMPF M.: To-
wards fast non-rigid registration. In Inverse Problems,
Image Analysis and Medical Imaging, AMS Special Ses-
sion Interaction of Inverse Problems and Image Analysis
(2002), vol. 313, AMS, pp. 67–84.
[CH05] COOMBE G., HARRIS M.: Global illumination
using progressive refinement radiosity. In GPU Gems
2, Pharr M., (Ed.). Addison Wesley, Mar. 2005, ch. 39,
pp. 635–647.
[CHCH06] CARR N. A., HOBEROCK J., CRANE K.,
HART J. C.: Fast GPU ray tracing of dynamic meshes
using geometry images. In Proceedings of the 2006 Con-
ference on Graphics Interface (June 2006), pp. 203–209.
[CHH02] CARR N. A., HALL J. D., HART J. C.: The ray
engine. InGraphics Hardware 2002 (Sept. 2002), pp. 37–
46.
[CHH03] CARR N. A., HALL J. D., HART J. C.: GPU
algorithms for radiosity and subsurface scattering. In
Graphics Hardware 2003 (July 2003), pp. 51–59.
[CHL04] COOMBE G., HARRIS M. J., LASTRA A.: Ra-
diosity on graphics hardware. In Proceedings of the 2004
Conference on Graphics Interface (May 2004), pp. 161–
168.
[Chr05] CHRISTEN M.: Ray Tracing on GPU. Master’s
thesis, University of Applied Sciences Basel, 2005.
[CND03] CALLELE D., NEUFELD E., DELATHOUWER
K.: Sorting on a GPU. http://www.cs.usask.ca/
faculty/callele/gpusort/gpusort.html,
2003.
[DNB∗05] DUCA N., NISKI K., BILODEAU J., BOLITHO
M., CHEN Y., COHEN J.: A relational debugging engine
for the graphics pipeline. ACM Transactions on Graphics
24, 3 (Aug. 2005), 453–463.
[DPRS89] DOWD M., PERL Y., RUDOLPH L., SAKS M.:
The periodic balanced sorting network. Journal of the
ACM 36, 4 (Oct. 1989), 738–757.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
[DVS03] DACHSBACHER C., VOGELGSANG C., STAM-
MINGER M.: Sequential point trees. ACM Transactions
on Graphics 22, 3 (July 2003), 657–662.
[EMP∗97] EYLES J., MOLNAR S., POULTON J., GREER
T., LASTRA A., ENGLAND N., WESTOVER L.: Pix-
elFlow: The realization. In 1997 SIGGRAPH / Euro-
graphics Workshop on Graphics Hardware (Aug. 1997),
pp. 57–68.
[Eng78] ENGLAND J. N.: A system for interactive mod-
eling of physical curved surface objects. In Computer
Graphics (Proceedings of SIGGRAPH 78) (Aug. 1978),
vol. 12, pp. 336–340.
[Err05] ERRA U.: Toward real time fractal image com-
pression using graphics hardware. In International Sym-
posium on Visual Computing 2005 (Dec. 2005), vol. 3804
of Lecture Notes in Computer Science, Springer-Verlag,
pp. 723–728.
[Eve01] EVERITT C.: Interactive Order-Independent
Transparency. Tech. rep., NVIDIA Corporation,
May 2001. http://developer.nvidia.com/
object/Interactive_Order_Transparency.
html.
[EVG04] ERNST M., VOGELGSANG C., GREINER G.:
Stack implementation on programmable graphics hard-
ware. In Proceedings of Vision, Modeling, and Visual-
ization (Nov. 2004), pp. 255–262.
[EWN05] EKMAN M., WARG F., NILSSON J.: An
in-depth look at computer performance growth. ACM
SIGARCH Computer Architecture News 33, 1 (Mar.
2005), 144–147.
[FF88] FOURNIER A., FUSSELL D.: On the power of the
frame buffer. ACM Transactions on Graphics 7, 2 (1988),
103–128.
[FJ98] FRIGO M., JOHNSON S. G.: FFTW: An adaptive
software architecture for the FFT. In Proceedings of the
1998 International Conference on Acoustics, Speech, and
Signal Processing (May 1998), vol. 3, pp. 1381–1384.
[FM04] FUNG J., MANN S.: Computer vision signal pro-
cessing on graphics processing units. In Proceedings of
the IEEE International Conference on Acoustics, Speech,
and Signal Processing (May 2004), vol. 5, pp. 93–96.
[FPE∗89] FUCHS H., POULTON J., EYLES J., GREER T.,
GOLDFEATHER J., ELLSWORTH D., MOLNAR S., TURK
G., TEBBS B., ISRAEL L.: Pixel-Planes 5: A hetero-
geneous multiprocessor graphics system using processor-
enhanced memories. In Computer Graphics (Proceedings
of SIGGRAPH 89) (July 1989), vol. 23, pp. 79–88.
[FS05] FOLEY T., SUGERMAN J.: KD-Tree acceleration
structures for a GPU raytracer. In Graphics Hardware
2005 (July 2005), pp. 15–22.
[FSH04] FATAHALIAN K., SUGERMAN J., HANRAHAN
P.: Understanding the efficiency of GPU algorithms
for matrix-matrix multiplication. In Graphics Hardware
2004 (Aug. 2004), pp. 133–138.
[FTM02] FUNG J., TANG F., MANN S.: Mediated reality
using computer graphics hardware for computer vision.
In 6th International Symposium on Wearable Computing
(Oct. 2002), pp. 83–89.
[GDNV05] GRIESSER A., DE ROECK S., NEUBECK A.,
VAN GOOL L.: GPU-based foreground-background seg-
mentation using an extended colinearity criterion. In
Proceedings of Vision, Modeling, and Visualization (Nov.
2005), pp. 319–326.
[GGHM05] GALOPPO N., GOVINDARAJU N. K., HEN-
SON M., MANOCHA D.: LU-GPU: Efficient algorithms
for solving dense linear systems on graphics hardware. In
Proceedings of the ACM/IEEE Conference on Supercom-
puting (Nov. 2005), p. 3.
[GGK06] GRESS A., GUTHE M., KLEIN R.: GPU-based
collision detection for deformable parameterized surfaces.
Computer Graphics Forum 25, 3 (Sept. 2006), 497–506.
[GGKM06] GOVINDARAJU N. K., GRAY J., KUMAR
R., MANOCHA D.: GPUTeraSort: High performance
graphics coprocessor sorting for large database manage-
ment. In Proceedings of the 2006 ACM SIGMOD Inter-
national Conference onManagement of Data (June 2006),
pp. 325–336.
[GH06] GREEN S., HARRIS M.: Game physics simula-
tion on NVIDIA GPUs. In Proceedings of Game De-
velopers Conference 2006 (Mar. 2006). http://www.
havok.com/content/view/187/77/.
[GHF86] GOLDFEATHER J., HULTQUIST J. P. M.,
FUCHS H.: Fast constructive-solid geometry display in
the Pixel-Powers graphics system. In Computer Graph-
ics (Proceedings of SIGGRAPH 86) (Aug. 1986), vol. 20,
pp. 107–116.
[GHLM05] GOVINDARAJU N. K., HENSON M., LIN
M. C., MANOCHA D.: Interactive visibility ordering
of geometric primitives in complex environments. In
Proceedings of the 2005 Symposium on Interactive 3D
Graphics and Games (Apr. 2005), pp. 49–56.
[GKBP05] GAUTRON P., KŘIVÁNEK J., BOUATOUCH
K., PATTANAIK S. N.: Radiance cache splatting: A GPU-
friendly global illumination algorithm. In Eurographics
Symposium on Rendering (June 2005), pp. 55–64.
[GKJ∗05] GOVINDARAJU N. K., KNOTT D., JAIN N.,
KABUL I., TAMSTORF R., GAYLE R., LIN M. C.,
MANOCHA D.: Interactive collision detection between
deformable models using chromatic decomposition. ACM
Transactions on Graphics 24, 3 (Aug. 2005), 991–999.
[GKMV03] GUHA S., KRISHNAN S., MUNAGALA K.,
VENKATASUBRAMANIAN S.: Application of the two-
sided depth test to CSG rendering. In 2003 ACM Sym-
posium on Interactive 3D Graphics (Apr. 2003), pp. 177–
180.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
[GKV04] GEYS I., KONINCKX T. P., VAN GOOL L.: Fast
interpolated cameras by combining a GPU based plane
sweep with a max-flow regularisation algorithm. In Pro-
ceedings of the 2nd International Symposium on 3D Data
Processing, Visualization and Transmission (Sept. 2004),
pp. 534–541.
[GLGM06] GOVINDARAJU N. K., LARSEN S., GRAY J.,
MANOCHA D.: A memory model for scientific algo-
rithms on graphics processors. In Proceedings of the 2006
ACM/IEEE Conference on Supercomputing (Nov. 2006).
To appear.
[GLM04] GOVINDARAJU N. K., LIN M. C., MANOCHA
D.: Fast and reliable collision culling using graphics hard-
ware. In Proceedings of ACM Virtual Reality and Soft-
ware Technology (Nov. 2004), pp. 2–9.
[GLM05] GOVINDARAJU N. K., LIN M. C., MANOCHA
D.: Quick-CULLIDE: Efficient inter- and intra-object
collision culling using graphics hardware. In Proceedings
of IEEE Virtual Reality (Mar. 2005), pp. 59–66.
[GLW∗04] GOVINDARAJU N. K., LLOYD B., WANG W.,
LIN M., MANOCHA D.: Fast computation of database op-
erations using graphics processors. In Proceedings of the
2004 ACM SIGMOD International Conference on Man-
agement of Data (June 2004), pp. 215–226.
[GM05] GOVINDARAJU N. K., MANOCHA D.: Efficient
relational database management using graphics proces-
sors. In ACM SIGMOD Workshop on Data Management
on New Hardware (June 2005), pp. 29–34.
[GMTF89] GOLDFEATHER J., MOLNAR S., TURK G.,
FUCHS H.: Near real-time CSG rendering using tree
normalization and geometric pruning. IEEE Computer
Graphics & Applications 9, 3 (May 1989), 20–28.
[GPU06] GPUSort: A high performance GPU sorting li-
brary. http://gamma.cs.unc.edu/GPUSORT/,
2006.
[Gra06] Graphic Remedy gDEBugger. http://www.
gremedy.com/, 2006.
[Gre03] GREEN S.: NVIDIA cloth sample.
http://download.developer.nvidia.
com/developer/SDK/Individual_Samples/
samples.html#glsl_physics, 2003.
[Gre04] GREEN S.: NVIDIA particle system sam-
ple. http://download.developer.nvidia.
com/developer/SDK/Individual_Samples/
samples.html#gpu_particles, 2004.
[Gre05] GREEN S.: Image processing tricks
in OpenGL. In Proceedings of Game Devel-
opers Conference 2005 (Mar. 2005). http:
//download.nvidia.com/developer/
presentations/2005/GDC/OpenGL_Day/
OpenGL_Image_Processing_Tricks.pdf.
[GRH∗05] GOVINDARAJU N. K., RAGHUVANSHI N.,
HENSON M., TUFT D., MANOCHA D.: A Cache-
Efficient Sorting Algorithm for Database and Data Min-
ing Computations using Graphics Processors. Tech. Rep.
TR05-016, University of North Carolina, 2005.
[Gri05] GRIESSER A.: Real-Time, GPU-based
Foreground-Background Segmentation. Tech. Rep.
BIWI-TR-269, Computer Vision Lab, ETH Zürich, Aug.
2005.
[GRLM03] GOVINDARAJU N. K., REDON S., LIN
M. C., MANOCHA D.: CULLIDE: Interactive collision
detection between complex models in large environments
using graphics hardware. In Graphics Hardware 2003
(July 2003), pp. 25–32.
[GRM05] GOVINDARAJU N. K., RAGHUVANSHI N.,
MANOCHA D.: Fast and approximate stream mining
of quantiles and frequencies using graphics processors.
In Proceedings of the 2005 ACM SIGMOD Interna-
tional Conference on Management of Data (June 2005),
pp. 611–622.
[GST06] GÖDDEKE D., STRZODKA R., TUREK S.: Per-
formance and accuracy of hardware-oriented native-,
emulated- and mixed-precision solvers in FEM simula-
tions. International Journal of Parallel, Emergent and
Distributed Systems (2006). To appear.
[GT04] GALLO E., TSINGOS N.: Efficient 3D audio
processing with the GPU. In 2004 ACM Workshop
on General-Purpose Computing on Graphics Processors
(Aug. 2004), pp. C–42.
[GTGB84] GORAL C. M., TORRANCE K. E., GREEN-
BERG D. P., BATTAILE B.: Modelling the interaction
of light between diffuse surfaces. In Computer Graph-
ics (Proceedings of SIGGRAPH 84) (July 1984), vol. 18,
pp. 213–222.
[GWL∗03] GOODNIGHT N., WOOLLEY C., LEWIN G.,
LUEBKE D., HUMPHREYS G.: A multigrid solver for
boundary value problems using programmable graphics
hardware. In Graphics Hardware 2003 (July 2003),
pp. 102–111.
[GWWH03] GOODNIGHT N., WANG R., WOOLLEY C.,
HUMPHREYS G.: Interactive time-dependent tone map-
ping using programmable graphics hardware. In Proceed-
ings of the 14th Eurographics Workshop on Rendering
(June 2003), pp. 26–37.
[GZ06] GRESS A., ZACHMANN G.: GPU-ABiSort: Op-
timal parallel sorting on stream architectures. In Pro-
ceedings of the 20th IEEE International Parallel and Dis-
tributed Processing Symposium (Apr. 2006).
[Hac05] HACHISUKA T.: High-quality global illumina-
tion rendering using rasterization. In GPU Gems 2, Pharr
M., (Ed.). Addison Wesley, Mar. 2005, ch. 38, pp. 615–
633.
[Har02] HARRIS M. J.: Analysis of Error in a CML Dif-
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
fusion Operation. Tech. Rep. TR02-015, University of
North Carolina, 2002.
[Har04] HARRIS M.: Fast fluid dynamics simulation on
the GPU. In GPU Gems, Fernando R., (Ed.). Addison
Wesley, Mar. 2004, pp. 637–665.
[Har05a] HARRIS M.: Mapping computational concepts
to GPUs. In GPU Gems 2, Pharr M., (Ed.). Addison Wes-
ley, Mar. 2005, ch. 31, pp. 493–508.
[Har05b] HARRIS M.: NVIDIA fluid code sam-
ple. http://download.developer.nvidia.
com/developer/SDK/Individual_Samples/
samples.html#gpgpu_fluid, 2005.
[HB05] HARRIS M., BUCK I.: GPU flow control idioms.
In GPU Gems 2, Pharr M., (Ed.). Addison Wesley, Mar.
2005, ch. 34, pp. 547–555.
[HBSL03] HARRIS M. J., BAXTER III W., SCHEUER-
MANN T., LASTRA A.: Simulation of cloud dynamics
on graphics hardware. In Graphics Hardware 2003 (July
2003), pp. 92–101.
[HCK∗99] HOFF III K., CULVER T., KEYSER J., LIN
M., MANOCHA D.: Fast computation of generalized
Voronoi diagrams using graphics hardware. In Proceed-
ings of SIGGRAPH 99 (Aug. 1999), Computer Graphics
Proceedings, Annual Conference Series, pp. 277–286.
[HCSL02] HARRIS M. J., COOMBE G., SCHEUERMANN
T., LASTRA A.: Physically-based visual simulation on
graphics hardware. In Graphics Hardware 2002 (Sept.
2002), pp. 109–118.
[HE99a] HOPF M., ERTL T.: Accelerating 3D convolu-
tion using graphics hardware. In IEEE Visualization ’99
(Oct. 1999), pp. 471–474.
[HE99b] HOPF M., ERTL T.: Hardware based wavelet
transformations. In Proceedings of Vision, Modeling, and
Visualization (Nov. 1999), pp. 317–328.
[HHN∗02] HUMPHREYS G., HOUSTON M., NG R.,
FRANK R., AHERN S., KIRCHNER P., KLOSOWSKI J.:
Chromium: A stream-processing framework for interac-
tive rendering on clusters. ACM Transactions on Graphics
21, 3 (July 2002), 693–702.
[HJ03] HARRIS M. J., JAMES G.: Simulation and anima-
tion using hardware accelerated procedural textures. In
Proceedings of Game Developers Conference 2003 (Mar.
2003).
[HK93] HANRAHAN P., KRUEGER W.: Reflection from
layered surfaces due to subsurface scattering. In Proceed-
ings of SIGGRAPH 93 (Aug. 1993), Computer Graphics
Proceedings, Annual Conference Series, pp. 165–174.
[HLN06] HAGEN T. R., LIE K.-A., NATVIG J. R.: Solv-
ing the Euler equations on graphics processing units. In
Proceedings of the 6th International Conference on Com-
putational Science, vol. 3994 of Lecture Notes in Com-
puter Science. Springer, May 2006, pp. 220–227.
[HMG03] HILLESLAND K. E., MOLINOV S.,
GRZESZCZUK R.: Nonlinear optimization frame-
work for image-based modeling on programmable
graphics hardware. ACM Transactions on Graphics 22, 3
(July 2003), 925–934.
[Hor05] HORN D.: Stream reduction operations for
GPGPU applications. In GPU Gems 2, Pharr M., (Ed.).
Addison Wesley, Mar. 2005, ch. 36, pp. 573–589.
[Hor06] HORN D.: libgpufft. http://sourceforge.
net/projects/gpufft/, 2006.
[HS86] HILLIS W. D., STEELE JR. G. L.: Data parallel
algorithms. Communications of the ACM 29, 12 (Dec.
1986), 1170–1183.
[HSC∗05] HENSLEY J., SCHEUERMANN T., COOMBE
G., SINGH M., LASTRA A.: Fast summed-area table
generation and its applications. Computer Graphics Fo-
rum 24, 3 (Sept. 2005), 547–555.
[HTG03] HEIDELBERGER B., TESCHNER M., GROSS
M.: Real-time volumetric intersections of deforming ob-
jects. In Proceedings of Vision, Modeling, and Visualiza-
tion (Nov. 2003), pp. 461–468.
[HTG04] HEIDELBERGER B., TESCHNER M., GROSS
M.: Detection of collisions and self-collisions using
image-space techniques. Journal of WSCG 12, 3 (Feb.
2004), 145–152.
[HWSE99] HEIDRICH W., WESTERMANN R., SEIDEL
H.-P., ERTL T.: Applications of pixel textures in visual-
ization and realistic image synthesis. In 1999 ACM Sym-
posium on Interactive 3D Graphics (Apr. 1999), pp. 127–
134.
[HZLM01] HOFF III K. E., ZAFERAKIS A., LIN M. C.,
MANOCHA D.: Fast and simple 2D geometric proximity
queries using graphics hardware. In 2001 ACM Sympo-
sium on Interactive 3D Graphics (Mar. 2001), pp. 145–
148.
[Ins03] The Insight Toolkit. http://www.itk.org/,
2003.
[Int06] Intel processors product list. http://www.
intel.com/products/processor, 2006.
[Jah06] JAHSHAKA: Jahshaka image processing toolkit.
http://www.jahshaka.org/, 2006.
[Jam01a] JAMES G.: NVIDIA game of life sam-
ple. http://download.developer.nvidia.
com/developer/SDK/Individual_Samples/
samples.html#GL_GameOfLife, 2001.
[Jam01b] JAMES G.: NVIDIA water surface simula-
tion sample. http://download.developer.
nvidia.com/developer/SDK/Individual_
Samples/samples.html#WaterInteraction,
2001.
[Jam01c] JAMES G.: Operations for hardware-accelerated
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
procedural texture animation. In Game Programming
Gems 2, Deloura M., (Ed.). Charles River Media, 2001,
pp. 497–509.
[Jęd04] JĘDRZEJEWSKI M.: Computation of Room
Acoustics on Programmable Video Hardware. Master’s
thesis, Polish-Japanese Institute of Information Technol-
ogy, Warsaw, Poland, 2004.
[JEH01] JOBARD B., ERLEBACHER G., HUSSAINI
M. Y.: Lagrangian-Eulerian advection for unsteady flow
visualization. In IEEE Visualization 2001 (Oct. 2001),
pp. 53–60.
[Jen96] JENSEN H. W.: Global illumination using pho-
ton maps. In Rendering Techniques ’96 (Proceedings of
the 6th Eurographics Rendering Workshop) (June 1996),
pp. 21–30.
[JS05] JIANG C., SNIR M.: Automatic tuning matrix
multiplication performance on graphics hardware. In
Proceedings of the Fourteenth International Conference
on Parallel Architecture and Compilation Techniques
(PACT) (Sept. 2005), pp. 185–196.
[JvHK04] JANSEN T., VON RYMON-LIPINSKI B.,
HANSSEN N., KEEVE E.: Fourier volume rendering
on the GPU using a Split-Stream-FFT. In Proceedings
of Vision, Modeling, and Visualization (Nov. 2004),
pp. 395–403.
[JWLL05] JI J., WU E., LI S., LIU X.: Dynamic LOD
on GPU. In Proceedings of Computer Graphics Interna-
tional 2005 (June 2005), pp. 108–114.
[KBR04] KESSENICH J., BALDWIN D., ROST R.:
The OpenGL Shading Language version 1.10.59.
http://www.opengl.org/documentation/
oglsl.html, Apr. 2004.
[KBW06] KRÜGER J., BÜRGER K., WESTERMANN
R.: Interactive screen-space accurate photon tracing on
GPUs. In Eurographics Symposium on Rendering (June
2006), pp. 319–329.
[KC05] KOLB A., CUNTZ N.: Dynamic particle coupling
for GPU-based fluid simulation. In Proceedings of the
18th Symposium on Simulation Technique (Sept. 2005),
pp. 722–727.
[KF05] KILGARIFF E., FERNANDO R.: The GeForce 6
series GPU architecture. InGPUGems 2, Pharr M., (Ed.).
Addison Wesley, Mar. 2005, ch. 30, pp. 471–491.
[KI99] KEDEM G., ISHIHARA Y.: Brute force attack on
UNIX passwords with SIMD computer. In Proceedings of
the 8th USENIX Security Symposium (Aug. 1999), pp. 93–
98.
[KK04] KELLY F., KOKARAM A.: Graphics hardware
for gradient based motion estimation. In Embedded Pro-
cessors for Multimedia and Communications (Apr. 2004),
vol. 5309 of Proceedings of the SPIE, pp. 92–103.
[KKKW05] KRÜGER J., KIPFER P., KONDRATIEVA P.,
WESTERMANN R.: A particle system for interactive vi-
sualization of 3D flows. IEEE Transactions on Visual-
ization and Computer Graphics 11, 6 (Nov./Dec. 2005),
744–756.
[KKW05] KONDRATIEVA P., KRÜGER J., WESTER-
MANN R.: The application of GPU particle tracing to
diffusion tensor field visualization. In IEEE Visualization
2005 (Oct. 2005), pp. 73–78.
[KL03] KIM T., LIN M. C.: Visual simulation of ice crys-
tal growth. In 2003 ACM SIGGRAPH / Eurographics
Symposium on Computer Animation (Aug. 2003), pp. 86–
97.
[KL04] KARLSSON F., LJUNGSTEDT C. J.: Ray trac-
ing fully implemented on programmable graphics hard-
ware. Master’s thesis, Chalmers University of Technol-
ogy, 2004.
[KLO06] KASS M., LEFOHN A., OWENS J.: Interactive
Depth of Field. Tech. Rep. # 06-01, Pixar, 2006. http:
//graphics.pixar.com/DepthOfField/.
[KLRS04] KOLB A., LATTA L., REZK-SALAMA C.:
Hardware-based simulation and collision detection for
large particle systems. In Graphics Hardware 2004 (Aug.
2004), pp. 123–132.
[KP03] KNOTT D., PAI D. K.: CInDeR: Collision and in-
terference detection in real-time using graphics hardware.
In Proceedings of the 2003 Conference on Graphics In-
terface (June 2003), pp. 73–80.
[KSW04] KIPFER P., SEGAL M., WESTERMANN R.:
UberFlow: A GPU-based particle engine. In Graphics
Hardware 2004 (Aug. 2004), pp. 115–122.
[KSW05] KRÜGER J., SCHNEIDER J., WESTERMANN
R.: DuoDecim—a structure for point scan compression
and rendering. In Proceedings of the Symposium on Point-
Based Graphics 2005 (June 2005), pp. 99–108.
[KW03] KRÜGER J., WESTERMANN R.: Linear alge-
bra operators for GPU implementation of numerical algo-
rithms. ACM Transactions on Graphics 22, 3 (July 2003),
908–916.
[KW05a] KIPFER P., WESTERMANN R.: Improved GPU
sorting. In GPU Gems 2, Pharr M., (Ed.). Addison Wes-
ley, Mar. 2005, ch. 46, pp. 733–746.
[KW05b] KRÜGER J., WESTERMANN R.: GPU simu-
lation and rendering of volumetric effects for computer
games and virtual environments. Computer Graphics Fo-
rum 24, 3 (Sept. 2005), 685–693.
[LC04] LARSEN B. D., CHRISTENSEN N. J.: Simulating
photon mapping for real-time applications. In Eurograph-
ics Symposium on Rendering (June 2004), pp. 123–132.
[LDN04] LEFEBVRE S., DARBON J., NEYRET F.: Uni-
fied Texture Management for Arbitrary Meshes. Tech.
Rep. 5210, INRIA, May 2004.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
[Lef03] LEFOHN A. E.: A Streaming Narrow-Band Al-
gorithm: Interactive Computation and Visualization of
Level-Set Surfaces. Master’s thesis, University of Utah,
Dec. 2003.
[LFW06] LUCAS P., FRITZ N., WILHELM R.: The CGiS
compiler. In Proceedings of the 15th International Con-
ference on Compiler Construction, vol. 3923 of Lecture
Notes in Computer Science. Springer, Mar. 2006, pp. 105–
108.
[LFWK05] LI W., FAN Z., WEI X., KAUFMAN A.:
GPU-based flow simulation with complex boundaries. In
GPU Gems 2, Pharr M., (Ed.). Addison Wesley, Mar.
2005, ch. 47, pp. 747–764.
[LHN05] LEFEBVRE S., HORNUS S., NEYRET F.: Octree
textures on the GPU. In GPU Gems 2, Pharr M., (Ed.).
Addison Wesley, Mar. 2005, ch. 37, pp. 595–613.
[LHPL87] LEVINTHAL A., HANRAHAN P., PAQUETTE
M., LAWSON J.: Parallel computers for graphics appli-
cations. ACM SIGOPS Operating Systems Review 21, 4
(Oct. 1987), 193–198.
[LKHW03] LEFOHN A. E., KNISS J. M., HANSEN
C. D., WHITAKER R. T.: Interactive deformation and vi-
sualization of level set surfaces using graphics hardware.
In IEEE Visualization 2003 (Oct. 2003), pp. 75–82.
[LKHW04] LEFOHN A. E., KNISS J. M., HANSEN
C. D., WHITAKER R. T.: A streaming narrow-band algo-
rithm: Interactive computation and visualization of level-
set surfaces. IEEE Transactions on Visualization and
Computer Graphics 10, 4 (July/Aug. 2004), 422–433.
[LKM01] LINDHOLM E., KILGARD M. J., MORETON
H.: A user-programmable vertex engine. In Proceedings
of ACM SIGGRAPH 2001 (Aug. 2001), Computer Graph-
ics Proceedings, Annual Conference Series, pp. 149–158.
[LKO05] LEFOHN A., KNISS J., OWENS J.: Implement-
ing efficient parallel data structures on GPUs. In GPU
Gems 2, Pharr M., (Ed.). Addison Wesley, Mar. 2005,
ch. 33, pp. 521–545.
[LKS∗06] LEFOHN A. E., KNISS J., STRZODKA R.,
SENGUPTA S., OWENS J. D.: Glift: An abstraction for
generic, efficient GPU data structures. ACM Transactions
on Graphics 26, 1 (Jan. 2006), 60–99.
[LLW04] LIU Y., LIU X., WU E.: Real-time 3D fluid sim-
ulation on GPU with complex obstacles. In Proceedings
of Pacific Graphics 2004 (Oct. 2004), pp. 247–256.
[LM01] LARSEN E. S., MCALLISTER D.: Fast matrix
multiplies using graphics hardware. In Proceedings of the
2001 ACM/IEEE Conference on Supercomputing (Nov.
2001), p. 55.
[LP84] LEVINTHAL A., PORTER T.: Chap – a SIMD
graphics processor. In Computer Graphics (Proceedings
of SIGGRAPH 84) (July 1984), vol. 18, pp. 77–82.
[LRDG90] LENGYEL J., REICHERT M., DONALD B. R.,
GREENBERG D. P.: Real-time robot motion planning us-
ing rasterizing computer graphics hardware. In Computer
Graphics (Proceedings of ACM SIGGRAPH 90) (Aug.
1990), vol. 24, pp. 327–335.
[LSK∗05] LEFOHN A., SENGUPTA S., KNISS J., STR-
ZODKA R., OWENS J. D.: Dynamic adaptive shadow
maps on graphics hardware. In ACM SIGGRAPH 2005
Conference Abstracts and Applications (Aug. 2005).
[LW02] LEFOHN A. E., WHITAKER R. T.: A GPU-
Based, Three-Dimensional Level Set Solver with Curva-
ture Flow. Tech. Rep. UUCS-02-017, University of Utah,
2002.
[LWK03] LI W., WEI X., KAUFMAN A.: Implementing
lattice Boltzmann computation on graphics hardware. In
The Visual Computer (Dec. 2003), vol. 19, pp. 444–456.
[MA03] MORELAND K., ANGEL E.: The FFT
on a GPU. In Graphics Hardware 2003 (July
2003), pp. 112–119. http://www.cs.unm.edu/
~kmorel/documents/fftgpu/.
[MAH02] MITCHELL J. L., ANSARI M. Y., HART E.:
Advanced image processing with DirectX R© 9 pixel
shaders. In ShaderX2: Shader Programming Tips and
Tricks with DirectX 9.0, Engel W. F., (Ed.). Wordware
Publishing, 2002, pp. 457–464.
[Man03] MANOCHA D.: Interactive geometric and scien-
tific computations using graphics hardware. ACM SIG-
GRAPH Course Notes (July 2003).
[MDP∗04] MCCOOL M., DU TOIT S., POPA T., CHAN
B., MOULE K.: Shader algebra. ACM Transactions on
Graphics 23, 3 (Aug. 2004), 787–795.
[MGAK03] MARK W. R., GLANVILLE R. S., AKELEY
K., KILGARD M. J.: Cg: A system for programming
graphics hardware in a C-like language. ACM Transac-
tions on Graphics 22, 3 (July 2003), 896–907.
[MIA∗04] MCCORMICK P. S., INMAN J., AHRENS J. P.,
HANSEN C., ROTH G.: Scout: A hardware-accelerated
system for quantitatively driven visualization and analy-
sis. In IEEE Visualization 2004 (Oct. 2004), pp. 171–178.
[Mic05a] Microsoft high-level shading language.
http://msdn.microsoft.com/library/
default.asp?url=/library/en-us/
directx9_c/directx/graphics/reference/
hlslreference/hlslreference.asp, 2005.
[Mic05b] Microsoft shader debugger. http://msdn.
microsoft.com/library/default.asp?url=
/library/en-us/directx9_c/directx/
graphics/Tools/ShaderDebugger.asp, 2005.
[MM05] MONTRYM J., MORETON H.: The GeForce
6800. IEEE Micro 25, 2 (Mar./Apr. 2005), 41–51.
[Mor02] MORAVÁNSZKY A.: Dense matrix algebra on
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
the GPU. In ShaderX2: Shader Programming Tips and
Tricks with DirectX 9.0, Engel W. F., (Ed.). Wordware
Publishing, 2002, pp. 352–380.
[NHP04] NYLAND L., HARRIS M., PRINS J.: N-
body simulations on a GPU. In 2004 ACM Workshop
on General-Purpose Computing on Graphics Processors
(Aug. 2004), pp. C–37.
[Nij03] NIJASURE M.: Interactive Global Illumination on
the Graphics Processing Unit. Master’s thesis, University
of Central Florida, 2003.
[OL98] OLANO M., LASTRA A.: A shading language
on graphics hardware: The PixelFlow shading system.
In Proceedings of SIGGRAPH 98 (July 1998), Com-
puter Graphics Proceedings, Annual Conference Series,
pp. 159–168.
[OLG∗05] OWENS J. D., LUEBKE D., GOVINDARAJU
N., HARRIS M., KRÜGER J., LEFOHN A. E., PURCELL
T.: A survey of general-purpose computation on graphics
hardware. In Eurographics 2005, State of the Art Reports
(Sept. 2005), pp. 21–51.
[Ope03] OPENGL ARCHITECTURE REVIEW BOARD:
ARB fragment program. Revision 26. http:
//oss.sgi.com/projects/ogl-sample/
registry/ARB/fragment_program.txt,
22 Aug. 2003.
[Ope04] OPENGL ARCHITECTURE REVIEW BOARD:
ARB vertex program. Revision 45. http:
//oss.sgi.com/projects/ogl-sample/
registry/ARB/vertex_program.txt, 27 Sept.
2004.
[Ope06] OpenVIDIA: GPU-accelerated computer vi-
sion library. http://openvidia.sourceforge.
net/, 2006.
[OSH05] OWENS J. D., SENGUPTA S., HORN D.: As-
sessment of Graphic Processing Units (GPUs) for De-
partment of Defense (DoD) Digital Signal Processing
(DSP) Applications. Tech. Rep. ECE-CE-2005-3, Depart-
ment of Electrical and Computer Engineering, University
of California, Davis, Oct. 2005. http://www.ece.
ucdavis.edu/cerl/techreports/2005-3/.
[OSW∗03] OPENGL ARCHITECTURE REVIEW BOARD,
SHREINER D., WOO M., NEIDER J., DAVIS T.: OpenGL
Programming Guide: The Official Guide to Learning
OpenGL. Addison-Wesley, 2003.
[Owe05] OWENS J.: Streaming architectures and technol-
ogy trends. In GPU Gems 2, Pharr M., (Ed.). Addison
Wesley, Mar. 2005, ch. 29, pp. 457–470.
[PAB∗05] PHAM D., ASANO S., BOLLIGER M., DAY
M. N., HOFSTEE H. P., JOHNS C., KAHLE J.,
KAMEYAMA A., KEATY J., MASUBUCHI Y., RILEY
M., SHIPPY D., STASIAK D., WANG M., WARNOCK
J., WEITZEL S., WENDEL D., YAMAZAKI T., YAZAWA
K.: The design and implementation of a first-generation
CELL processor. In Proceedings of the International
Solid-State Circuits Conference (Feb. 2005), pp. 184–186.
[PBMH02] PURCELL T. J., BUCK I., MARK W. R.,
HANRAHAN P.: Ray tracing on programmable graph-
ics hardware. ACM Transactions on Graphics 21, 3 (July
2002), 703–712.
[PDC∗03] PURCELL T. J., DONNER C., CAMMARANO
M., JENSEN H. W., HANRAHAN P.: Photon mapping on
programmable graphics hardware. In Graphics Hardware
2003 (July 2003), pp. 41–50.
[PH89] POTMESIL M., HOFFERT E. M.: The Pixel Ma-
chine: A parallel image computer. In Computer Graph-
ics (Proceedings of SIGGRAPH 89) (July 1989), vol. 23,
pp. 69–78.
[POAU00] PEERCY M. S., OLANO M., AIREY J., UN-
GAR P. J.: Interactive multi-pass programmable shading.
In Proceedings of ACM SIGGRAPH 2000 (July 2000),
Computer Graphics Proceedings, Annual Conference Se-
ries, pp. 425–432.
[PS03] PURCELL T. J., SEN P.: Shadesmith fragment
program debugger. http://graphics.stanford.
edu/projects/shadesmith/, 2003.
[Pur04] PURCELL T. J.: Ray Tracing on a Stream Proces-
sor. PhD thesis, Stanford University, Mar. 2004.
[RR86] ROSSIGNAC J. R., REQUICHA A. A. G.: Depth-
buffering display techniques for constructive solid geom-
etry. IEEE Computer Graphics & Applications 6, 9 (Sept.
1986), 29–39.
[RS01a] RUMPF M., STRZODKA R.: Level set segmen-
tation in graphics hardware. In Proceedings of the IEEE
International Conference on Image Processing (ICIP ’01)
(Oct. 2001), vol. 3, pp. 1103–1106.
[RS01b] RUMPF M., STRZODKA R.: Nonlinear diffusion
in graphics hardware. In Data Visualization 2001 (Pro-
ceedings of the EG/IEEE VisSym) (May 2001), pp. 75–84.
[RS01c] RUMPF M., STRZODKA R.: Using graphics
cards for quantized FEM computations. In Proceedings
of VIIP 2001 (2001), pp. 193–202.
[RS05] RUMPF M., STRZODKA R.: Graphics processor
units: New prospects for parallel computing. In Numer-
ical Solution of Partial Differential Equations on Paral-
lel Computers, vol. 51 of Lecture Notes in Computational
Science and Engineering. Springer-Verlag, 2005, pp. 89–
134.
[RSHGE99] REZK-SALAMA C., HASTREITER P.,
GREINER G., ERTL T.: Non-linear Registration of Pre-
and Intraoperative Volume Data Based On Piecewise
Linear Transformations. In Proceedings of Vision,
Modeling, and Visualization (Nov. 1999), pp. 365–372.
[RSSF02] REINHARD E., STARK M., SHIRLEY P., FER-
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
WERDA J.: Photographic tone reproduction for digital im-
ages. ACM Transactions on Graphics 21, 3 (July 2002),
267–276.
[RTB∗92] RHOADES J., TURK G., BELL A., STATE A.,
NEUMANN U., VARSHNEY A.: Real-time procedural
textures. In 1992 Symposium on Interactive 3D Graph-
ics (Mar. 1992), vol. 25, pp. 95–100.
[SAA03] SUN C., AGRAWAL D., ABBADI A. E.: Hard-
ware acceleration for spatial selections and joins. In Pro-
ceedings of the 2003 ACM SIGMOD International Con-
ference on Management of Data (June 2003), pp. 455–
466.
[SC05] SMIRNOV A., CHIUEH T.: An Implementation
of a FIR Filter on a GPU. Tech. rep., Experimental
Computer Systems Lab, Stony Brook University, 2005.
http://www.ecsl.cs.sunysb.edu/fir/.
[SDR03] STRZODKA R., DROSKE M., RUMPF M.: Fast
image registration in DX9 graphics hardware. Journal of
Medical Informatics and Technologies 6 (Nov. 2003), 43–
49.
[SDR04] STRZODKA R., DROSKE M., RUMPF M.: Im-
age registration by a regularized gradient flow: A stream-
ing implementation in DX9 graphics hardware. Comput-
ing 73, 4 (Nov. 2004), 373–389.
[SG04] STRZODKA R., GARBE C.: Real-time motion es-
timation and visualization on graphics cards. In IEEE Vi-
sualization 2004 (Oct. 2004), pp. 545–552.
[SG06] STRZODKA R., GÖDDEKE D.: Mixed precision
methods for convergent iterative schemes. In Proceedings
of the Workshop on Edge Computing Using New Com-
modity Architectures (May 2006), pp. D–59–60.
[SHN03] SHERBONDY A., HOUSTON M., NAPEL S.:
Fast volume segmentation with simultaneous visualiza-
tion using programmable graphics hardware. In IEEE Vi-
sualization 2003 (Oct. 2003), pp. 171–176.
[SKALP05] SZIRMAY-KALOS L., ASZÓDI B., LAZÁNYI
I., PREMECZ M.: Approximate ray-tracing on the GPU
with distance imposters. Computer Graphics Forum 24, 3
(Sept. 2005), 685–704.
[SKP06] SHAH M. A., KONTTINEN J., PATTANAIK
S. N.: Caustics mapping: An image-space technique for
real-time caustics. IEEE Transactions on Visualization
and Computer Graphics (2006). To appear.
[SL05] SUMANAWEERA T., LIU D.: Medical image re-
construction with the FFT. In GPU Gems 2, Pharr M.,
(Ed.). Addison Wesley, Mar. 2005, ch. 48, pp. 765–784.
[SLJ98] STEWART N., LEACH G., JOHN S.: An improved
Z-buffer CSG rendering algorithm. In 1998 SIGGRAPH
/ Eurographics Workshop on Graphics Hardware (Aug.
1998), pp. 25–30.
[SLO06] SENGUPTA S., LEFOHN A. E., OWENS J. D.:
A work-efficient step-efficient prefix sum algorithm. In
Proceedings of the Workshop on Edge Computing Using
New Commodity Architectures (May 2006), pp. D–26–27.
[SOM04] SUD A., OTADUY M. A., MANOCHA D.: DiFi:
Fast 3D distance field computation using graphics hard-
ware. Computer Graphics Forum 23, 3 (Sept. 2004), 557–
566.
[SPG03] SIGG C., PEIKERT R., GROSS M.: Signed dis-
tance transform using graphics hardware. In IEEE Visu-
alization 2003 (Oct. 2003), pp. 83–90.
[ST04] STRZODKA R., TELEA A.: Generalized distance
transforms and skeletons in graphics hardware. In Pro-
ceedings of EG/IEEE TCVG Symposium on Visualization
(VisSym ’04) (2004), pp. 221–230.
[STM04] SANDER P., TATARCHUK N., MITCHELL
J. L.: Explicit Early-Z Culling for Efficient Fluid Flow
Simulation and Rendering. Tech. rep., ATI Research,
Aug. 2004. http://www.ati.com/developer/
techreports/ATITechReport_EarlyZFlow.
pdf.
[Str02] STRZODKA R.: Virtual 16 bit precise operations
on RGBA8 textures. In Proceedings of Vision, Modeling,
and Visualization (Nov. 2002), pp. 171–178.
[Str04] STRZODKA R.: Hardware Efficient PDE Solvers
in Quantized Image Processing. PhD thesis, University of
Duisburg-Essen, 2004.
[SW04] SCHIWIETZ T., WESTERMANN R.: GPU-PIV. In
Proceedings of Vision, Modeling, and Visualization (Nov.
2004), pp. 151–158.
[THO02] THOMPSON C. J., HAHN S., OSKIN M.: Using
modern graphics architectures for general-purpose com-
puting: A framework and analysis. In Proceedings of the
35th Annual ACM/IEEE International Symposium on Mi-
croarchitecture (Nov. 2002), pp. 306–317.
[TPO06] TARDITI D., PURI S., OGLESBY J.: Accelera-
tor: Using data-parallelism to program GPUs for general-
purpose uses. In Proceedings of the Twelfth International
Conference on Architectural Support for Programming
Languages and Operating Systems (Oct. 2006).
[Tre06] TREBILCO D.: GLIntercept. http://
glintercept.nutty.org/, 2006.
[TS00] TRENDALL C., STEWART A. J.: General calcula-
tions using graphics hardware, with applications to inter-
active caustics. In Rendering Techniques 2000: Proceed-
ings of the 11th Eurographics Rendering Workshop (June
2000), pp. 287–298.
[TS05] THRANE N., SIMONSEN L. O.: A Comparison
of Acceleration structures for GPU Assisted Ray Tracing.
Master’s thesis, University of Aarhus, Aug. 2005.
[Ups90] UPSTILL S.: The RenderMan Companion: A
Programmer’s Guide to Realistic Computer Graphics.
Addison-Wesley, 1990.
c© The Eurographics Association and Blackwell Publishing 2007.
Owens, Luebke, Govindaraju, Harris, Krüger, Lefohn, and Purcell / A Survey of General-Purpose Computation on Graphics Hardware
[Ven03] VENKATASUBRAMANIAN S.: The graphics card
as a stream computer. In SIGMOD-DIMACS Workshop
on Management and Processing of Data Streams (2003).
[Ver67] VERLET L.: Computer “experiments” on classical
fluids. I. Thermodynamical properties of Lennard-Jones
molecules. Phys. Rev., 159 (July 1967), 98–103.
[VKG03] VIOLA I., KANITSAR A., GRÖLLER M. E.:
Hardware-based nonlinear filtering and segmentation us-
ing high-level shading languages. In IEEE Visualization
2003 (Oct. 2003), pp. 309–316.
[VSC01] VASSILEV T., SPANLANG B., CHRYSANTHOU
Y.: Fast cloth animation on walking avatars. Computer
Graphics Forum 20, 3 (Sept. 2001), 260–267.
[WD06] WYMAN C., DAVIS S.: Interactive image-space
techniques for approximating caustics. In SI3D ’06:
Proceedings of the 2006 Symposium on Interactive 3D
Graphics and Games (Mar. 2006), pp. 153–160.
[WHE01] WEISKOPF D., HOPF M., ERTL T.: Hardware-
accelerated visualization of time-varying 2D and 3D vec-
tor fields by texture advection via programmable per-pixel
operations. In Proceedings of Vision, Modeling, and Visu-
alization (Nov. 2001), pp. 439–446.
[Whi80] WHITTED T.: An improved illumination model
for shaded display. Communications of the ACM 23, 6
(June 1980), 343–349.
[WK04] WOETZEL J., KOCH R.: Multi-camera real-
time depth estimation with discontinuity handling on PC
graphics hardware. In Proceedings of the 17th Interna-
tional Conference on Pattern Recognition (Aug. 2004),
pp. 741–744.
[Wlo03] WLOKA M.: Interactive geometric and scientific
computations using graphics hardware—implementing a
GPU-efficient FFT. ACM SIGGRAPH Course Notes (July
2003). Presented by John Spitzer.
[WSE04] WEISKOPF D., SCHAFHITZEL T., ERTL T.:
GPU-based nonlinear ray tracing. Computer Graphics Fo-
rum 23, 3 (Sept. 2004), 625–633.
[WWHL04] WANG J., WONG T.-T., HENG P.-A.,
LEUNG C.-S.: Discrete wavelet transform on GPU.
http://www.cse.cuhk.edu.hk/~ttwong/
software/dwtgpu/dwtgpu.html, Aug. 2004.
[XM05] XU F., MUELLER K.: Accelerating popular to-
mographic reconstruction algorithms on commodity PC
graphics hardware. IEEE Transactions on Nuclear Sci-
ence 52, 3 (June 2005), 654–663.
[YLPM05] YOON S.-E., LINDSTROM P., PASCUCCI V.,
MANOCHA D.: Cache-oblivious mesh layouts. ACM
Transactions on Graphics 24, 3 (Aug. 2005), 886–893.
[YP05] YANG R., POLLEFEYS M.: A versatile stereo
implementation on commodity graphics hardware. Real-
Time Imaging 11, 1 (Feb. 2005), 7–18.
[YW03] YANG R., WELCH G.: Fast image segmentation
and smoothing using commodity graphics hardware. jour-
nal of graphics tools 7, 4 (2003), 91–100.
[Zel05] ZELLER C.: Cloth simulation on the GPU. In
ACM SIGGRAPH 2005 Conference Abstracts and Appli-
cations (Aug. 2005).
c© The Eurographics Association and Blackwell Publishing 2007.

