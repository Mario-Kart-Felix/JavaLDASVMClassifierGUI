ar
X
iv
:1
70
6.
08
10
0v
1 
 [
cs
.A
I]
  2
5 
Ju
n 
20
17
Specifying Non-Markovian Rewards in MDPs Using LDL on Finite Traces
(Preliminary Version)
Ronen Brafman
Ben-Gurion University, Beer-Sheva, Israel
brafman@cs.bgu.ac.il
Giuseppe De Giacomo & Fabio Patrizi
Sapienza Università di Roma, Italy
{degiacomo,patrizi}@dis.uniroma1.it
Abstract
In Markov Decision Processes (MDPs), the reward
obtained in a state depends on the properties of the
last state and action. This state dependency makes
it difficult to reward more interesting long-term be-
haviors, such as always closing a door after it has
been opened, or providing coffee only following
a request. Extending MDPs to handle such non-
Markovian reward function was the subject of two
previous lines of work, both using variants of LTL
to specify the reward function and then compiling
the new model back into a Markovian model. Build-
ing upon recent progress in the theories of temporal
logics over finite traces, we adopt LDLf for spec-
ifying non-Markovian rewards and provide an ele-
gant automata construction for building a Marko-
vian model, which extends that of previous work
and offers strong minimality and compositionality
guarantees.
1 Introduction
Markov Decision Processes (MDPs) are a central model for
sequential decision making under uncertainty. They are used
to model and solve many real-world problems, and to ad-
dress the problem of learning to behave well in unknown
environments. The Markov assumption is a key element of
this model. It states that the effects of an action depend
only on the state in which it was executed, and that re-
ward given at a state depends only on the previous action
and state. It has long been observed [Bacchus et al., 1996;
Thiébaux et al., 2006] that many performance criteria call for
more sophisticated reward functions that do not depend on
the last state only. For example, we may want to reward a
robot that eventually delivers coffee each time it gets a re-
quest; or, to reward the robot for keeping its operating envi-
ronment tidy, e.g., by closing doors after opening; or, to en-
sure it will access restricted areas only after having acquired
the right permission. All these rewards are non-Markovian.
Recently, Littman, in his IJCAI 2015 invited talk “Program-
ming Agents via Rewards,” advocated that it may actually be
more convenient, from a design perspective, to assign rewards
to the satisfaction of declarative temporal properties, rather
than to states.
To extend MDPs with non-Markovian rewards we need a
language for specifying such rewards. Markovian rewards are
specified as a function R from the previous state and action
to the reals. R can be specified using an explicit reward ma-
trix, or implicitly, by associating a reward with properties of
the last state and action. With non-Markovian rewards, an ex-
plicit representation is no longer possible, as the number of
possible histories or futures of a state is infinite. Hence, we
must use an implicit specification that can express proper-
ties of past (or future) states. To date, two specification lan-
guages have been proposed. [Bacchus et al., 1996] suggests
using a temporal logic of the past. Whether state si satisfies
such a past temporal formula depends on the entire sequence
of states leading up to it: s1, s2, . . . , si. Thus, we can reward
appropriate response to a “bring-coffee” command by associ-
ating a reward with the property the “bring-coffee” command
was issued in the past, and now I have coffee. A second pro-
posal, by [Thiébaux et al., 2006], uses a temporal logic of the
future with a special symbol to denote awarding a reward. At
each step, one checks whether this symbol must be true in the
current state, for the reward formula to be satisfied in the ini-
tial state. If that is the case, the current state is rewarded. This
language is a little less intuitive, and its semantics is more
complicated.
Existing MDP solution methods, possibly with the ex-
ception of Monte-Carlo tree search algorithms, rely heavily
on the Markov assumption, and cannot be applied directly
with non-Markovian rewards. To address this, both propos-
als above transform the non-Markovian model to an equiv-
alent Markovian one that can be solved using existing algo-
rithms, by enriching the state with information about the past.
For example, suppose we extend our state to record whether
a ”bring-coffee” command was issued earlier. A reward for
bringing coffee in states that indicate that the ”bring-coffee”
command was issued in the past, is now Markovian. It re-
wards the same behaviors as the earlier non-Markovian re-
ward on the original state. We call a model obtained by ex-
tending the state space of the original non-Markovian MDP,
an extended MDP.
Using an extended MDP is a well-known idea. Since
state space size affects the practical and theoretical com-
plexity of most MDP solution algorithms, the main ques-
tion is how to minimally enrich the state so as to make
rewards Markovian. [Bacchus et al., 1996] provide algo-
rithms for constructing an extended MDP that attempt
to minimize size by reducing the amount of information
about the past that is maintained. While their construc-
tion does not generate the minimal extended MDP, they
allude to using automata minimization techniques to ac-
complish this. [Thiébaux et al., 2006], instead, use a con-
struction that works well with forward search based algo-
rithms, such as LAO* [Hansen and Zilberstein, 2001] and
LRTDP [Bonet and Geffner, 2003]. Unlike classical dynamic
programming methods that require the entire state space a-
priori, these algorithms generate reachable states only. With
a good heuristic function, they often generate only a fraction
of the state space. So, while the augmented search space they
obtain is not minimal, because states are constructed on the
fly during forward search, their approach does not require a-
priori enumeration of the state space, and never generates an
unreachable state. They call this property blind minimality.
The aim of this paper is to bring to bear develop-
ments in the theory of temporal logic over finite traces
to the problem of specifying and solving MDP with non-
Markovian rewards. We adopt LDLf , a temporal logic of
the future interpreted over finite traces, which extends
LTLf , the classical linear-time temporal logic over finite
traces [De Giacomo and Vardi, 2013]. LDLf has the same
computational features of LTLf but it is more expres-
sive, as it captures monadic second order logic (MSO)
on finite traces (i.e., inductively defined properties), in-
stead of first-order logic (FO), as LTLf . A number of
techniques based on automata manipulation have been de-
veloped for LDLf , to address tasks such as satisfiabil-
ity, model checking, reactive synthesis, and planning un-
der full/partial observability [De Giacomo and Vardi, 2013;
De Giacomo and Vardi, 2015; De Giacomo and Vardi, 2016;
Torres and Baier, 2015; Camacho et al., 2017]. We exploit
such techniques to generate an extended MDP with good
properties.
Our formalism has three important advantages: 1. En-
hanced expressive power. We move from linear-time tem-
poral logics used by past authors to LDLf , paying no ad-
ditional (worst-case) complexity costs. LDLf can encode in
polynomial time LTLf , regular expressions (RE), the past LTL
(PLTL) of [Bacchus et al., 1996], and virtually all examples
of [Thiébaux et al., 2006]. Often, LDLf can represent more
compactly and more intuitively conditions specified in LTLf
or PLTL. Future logics are more commonly used in the model
checking community, as they are considered more natural for
expressing desirable properties. This is especially true with
complex properties that require the power of LDLf . 2. Mini-
mality and Compositionality. We generate a minimal equiv-
alent extended MDP, exploiting existing techniques for con-
structing automata that track the satisfiability of an LDLf
formula. This construction is relatively simple and composi-
tional: if a new reward formula is to be added, we only need to
optimize the corresponding automaton and add it to the cur-
rent (extended) MDP. If the current MDP was minimal, the
resulting (extended) MDP is minimal, too. 3. Blind Minimal-
ity. The automaton used to identify when a reward should be
given can be constructed in a forward manner using progres-
sion, providing blind minimality as in [Thiébaux et al., 2006].
If, instead, we want pure minimality, unlike the construction
of [Bacchus et al., 1996], we can exploit the forward con-
struction to never generate unreachable states, before apply-
ing automata minimization. Hence, we have the best of both
worlds.
2 Background
MDPs. A Markov Decision Process (MDP) M =
⟨S,A,T r,R⟩ consists of a set S of states, a set A of actions,
a transition function Tr ∶ S ×A → Prob(S) that returns for
every state s and action a a distribution over the next state.
We can further restrict actions to be defined on a subset of S
only, and use A(s) to denote the actions applicable in s. The
reward function, R ∶ S ×A → R, specifies the real-valued re-
ward received by the agent when applying action a in state s.
In this paper, states in S are truth assignments to a set P of
primitive propositions. Hence, if ϕ is a propositional formula
and s a state, we can check whether s ⊧ ϕ.
A solution to an MDP, called a policy, assigns an action
to each state, possibly conditioned on past states and actions.
The value of policy ρ at s, vρ(s), is the expected sum of (pos-
sibly discounted) rewards when starting at state s and select-
ing actions based on ρ. Every MDP has an optimal policy, ρ∗,
i.e., one that maximizes the expected sum of rewards for every
starting state s ∈ S. In the case of infinite horizon, there exists
an optimal policy that is stationary ρ ∶ S → A (i.e., ρ depends
only on the current state) and deterministic [Puterman, 2005].
There are diverse methods for computing an optimal policy.
With the exception of online simulation-based methods, they
rely on the fact that both transitions and rewards depend on
the last state only – i.e., are independent of earlier states and
actions (Markov property). The theoretical and practical com-
plexity of solution algorithms is strongly impacted by ∣S∣.
LTLf and LDLf . LTLf is essentially LTL [Pnueli, 1977]
interpreted over finite, instead of infinite, traces. LTLf is as
expressive as FO over finite traces and star-free RE, thus
strictly less expressive than RE, which in turn are as expres-
sive as MSO over finite traces. RE themselves are not conve-
nient for expressing temporal specifications, since, e.g., they
miss direct constructs for negation and conjunction. For this
reason, [De Giacomo and Vardi, 2013] introduced LDLf (lin-
ear dynamic logic on finite traces), which merges LTLf with
RE, through the syntax of the well-known logic of programs
PDL, propositional dynamic logic [Fischer and Ladner, 1979;
Harel et al., 2000; Vardi, 2011], but interpreted over finite
traces.
We consider a variant of LDLf that works also on empty
traces. Formally, LDLf formulas ϕ are built as follows:
ϕ ∶∶= tt ∣ ¬ϕ ∣ ϕ1 ∧ϕ2 ∣ ⟨ρ⟩ϕ
ρ ∶∶= φ ∣ ϕ? ∣ ρ1 + ρ2 ∣ ρ1;ρ2 ∣ ρ
∗
where tt stands for logical true; φ is a propositional formula
overP (including true, not to be confused with tt); ρ denotes
path expressions, which are RE over propositional formulas
φ with the addition of the test construct ϕ? typical of PDL.
We use abbreviations [ρ]ϕ ≐ ¬⟨ρ⟩¬ϕ, as in PDL, ff ≐ ¬tt ,
to denote false, and φ ≐ ⟨φ⟩tt to denote the occurence of
proposition φ.
Intuitively, ⟨ρ⟩ϕ states that, from the current step in the
trace, there exists an execution satisfying the RE ρ such that
its last step satisfies ϕ, while [ρ]ϕ states that, from the current
step, all executions satisfying the RE ρ are such that their last
step satisfies ϕ. Tests are used to insert into the execution path
checks for satisfaction of additional LDLf formulas.
The semantics of LDLf is given in terms of finite traces, i.e.,
finite sequences π = π0, . . . , πn of elements from the alphabet
2P . We define π(i) ≐ πi, length(π) ≐ n + 1, and π(i, j) ≐
πi, πi+1, . . . , πj . When j > n, π(i, j) ≐ π(i, n).
In decision processes, traces are usually sequences
of states and actions, i.e., they have the form:
⟨s0, a1, s1, . . . , sn−1, an⟩. These can still be represented
as traces of the form π = π0, . . . , πn, by extending the set
P to include one proposition pa per action a, and setting
πi ≐ si ∪ {pa ∣ a = ai+1}. In this way, πi denotes the pair(si, ai+1). We will always assume this form, even if referring
to sequences of states and actions. Given a finite trace π, an
LDLf formula ϕ, and a position i, we define when ϕ is true
at step i, written π, i ⊧ ϕ, by (mutual) induction, as follows:
• π, i ⊧ tt ;
• π, i ⊧ ¬ϕ iff π, i /⊧ ϕ;
• π, i ⊧ ϕ1 ∧ϕ2 iff π, i ⊧ ϕ1 and π, i ⊧ ϕ2;
• π, i ⊧ ⟨ρ⟩ϕ iff there exists i ≤ j ≤ length(π) such that
π(i, j) ∈ L(ρ) and π, j ⊧ ϕ, where the relation π(i, j) ∈
L(ρ) is as follows:
– π(i, j) ∈ L(φ) if j=i+1, j ≤ length(π), and π(i) ⊧
φ (φ propositional);
– π(i, j) ∈ L(ϕ?) if j = i and π, i ⊧ ϕ;
– π(i, j) ∈ L(ρ1 + ρ2) if π(i, j) ∈ L(ρ1) or π(i, j) ∈
L(ρ2);
– π(i, j) ∈ L(ρ1;ρ2) if there exists k such that
π(i, k) ∈ L(ρ1) and π(k, j) ∈ L(ρ2);
– π(i, j) ∈ L(ρ∗) if j = i or there exists k such that
π(i, k) ∈ L(ρ) and π(k, j) ∈ L(ρ∗).
Observe that if i > length(π), the above definitions still apply.
In particular, [ρ]ϕ is trivially true and ⟨ρ⟩ϕ trivially false.
We say that a trace π satisfies an LDLf formula ϕ, written
π ⊧ ϕ, if π,0 ⊧ ϕ. Also, sometimes we denote by L(ϕ) the
set of traces that satisfy ϕ: L(ϕ) = {π ∣ π ⊧ ϕ}.
LDLf is as expressive as MSO over finite words. It cap-
tures LTLf , by seeing next and until as the abbreviations
○ϕ ≐ ⟨true⟩ϕ and ϕ1 U ϕ2 ≐ ⟨(ϕ1?; true)∗⟩ϕ2, and any RE
r, with the formula ⟨r⟩end , where end ≐ [true?]ff expresses
that the trace has ended. Note that in addition to end we can
also denote the last element of the trace as last ≐ [true]end
or equivalently last ≐ [true]ff . The latter has also an LTLf -
equivalent: ¬○true, instead end does not.
The properties mentioned at the beginning of the introduc-
tion can be expressed in LDLf as follows: [true∗](requestp→⟨true∗⟩coffeep) (all coffee requests from person p will even-
tually be served); [true∗]([openDoord]closeDoor d) (every
time the robot opens door d it closes it immediately after);
⟨((¬restrda)∗;permissiona; (¬restrda)∗; restrda)∗;(¬restrda)∗⟩end
(before entering restricted area a the robot must have per-
mission for a). While the LTLf -equivalents of the first two
formulas are immediate, i.e., ◻(requestp → ◇coffeep) and
◻(openDoord→○closeDoord), that for the third one is not.
We can associate each LDLf formula ϕ with an (expo-
nentially large) NFA Aϕ that accepts exactly the traces sat-
isfying ϕ. A simple direct algorithm (LDLf2NFA) for com-
puting the NFA given the LDLf formula is reported be-
low. Its correctness relies on the fact that (i) every LDLf
formula ϕ can be associated with a polynomial alternat-
ing automaton on words (AFW) Aϕ accepting exactly the
traces that satisfy ϕ [De Giacomo and Vardi, 2013], and (ii)
every AFW can be transformed into an NFA, see, e.g.,
[De Giacomo and Vardi, 2013].
The algorithm assumes that the LDLf formula is in nega-
tion normal form (NNF), i.e., with negation symbols occur-
ring only in front of propositions (any LDLf formula can be
rewritten in NNF in linear time), and that P includes the spe-
cial proposition last , denoting the last element of the trace.
Let δ be the following auxiliary function, which takes in input
an LDLf formula ψ (in NNF) and a propositional interpreta-
tion Π for P (including last ), and returns a positive boolean
formula whose atoms are quoted ψ subformulas:
δ(tt,Π) = true
δ(ff ,Π) = false
δ(φ,Π) = { true if Π ⊧ φ
false if Π /⊧ φ (φ prop.)
δ(ϕ1 ∧ϕ2,Π) = δ(ϕ1,Π) ∧ δ(ϕ2,Π)
δ(ϕ1 ∨ϕ2,Π) = δ(ϕ1,Π) ∨ δ(ϕ2,Π)
δ(⟨φ⟩ϕ,Π) =
⎧⎪⎪⎪⎨⎪⎪⎪⎩
E(ϕ) if last /∈ Π and Π ⊧ φ (φ prop.)
δ(E(ϕ), ǫ) if last ∈ Π and Π ⊧ φ
false if Π /⊧ φ
δ(⟨ψ?⟩ϕ,Π) = δ(ψ,Π) ∧ δ(ϕ,Π)
δ(⟨ρ1 + ρ2⟩ϕ,Π) = δ(⟨ρ1⟩ϕ,Π) ∨ δ(⟨ρ2⟩ϕ,Π)
δ(⟨ρ1;ρ2⟩ϕ,Π) = δ(⟨ρ1⟩⟨ρ2⟩ϕ,Π)
δ(⟨ρ∗⟩ϕ,Π) = δ(ϕ,Π) ∨ δ(⟨ρ⟩F⟨ρ∗⟩ϕ, Π)
δ([φ]ϕ,Π) =
⎧⎪⎪⎪
⎨
⎪⎪⎪⎩
ϕ if last /∈ Π and Π ⊧ φ (φ prop.)
δ(ϕ, ǫ) if last ∈ Π and Π ⊧ φ
true if Π /⊧ φ
δ([ψ?]ϕ,Π) = δ(nnf (¬ψ),Π)∨ δ(ϕ,Π)
δ([ρ1 + ρ2]ϕ,Π) = δ([ρ1]ϕ,Π)∧ δ([ρ2]ϕ,Π)
δ([ρ1;ρ2]ϕ,Π) = δ([ρ1][ρ2]ϕ,Π)
δ([ρ∗]ϕ,Π) = δ(ϕ,Π)∧ δ([ρ]T[ρ∗]ϕ, Π)
δ(Fψ,Π) = false
δ(Tψ,Π) = true
where E(ϕ) recursively replaces in ϕ all occurrences of
atoms of the form Tψ and Fψ by E(ψ); and δ(tt , ǫ) is de-
fined as:
δ(tt , ǫ) = true
δ(ff , ǫ) = false
δ(φ, ǫ) = false (φ prop.)
δ(⟨ρϕ⟩, ǫ) = false
δ([ρ]ϕ, ǫ) = true
δ(ϕ1 ∧ϕ2, ǫ) = δ(ϕ1, ǫ)∧ δ("ϕ2", ǫ)
δ(ϕ1 ∨ϕ2, ǫ) = δ(ϕ1, ǫ)∨ δ(ϕ2, ǫ)
δ(Fϕ, ǫ) = false (for any ϕ)
δ(Tϕ, ǫ) = true (for any ϕ)
The NFA Aϕ for an LDLf formula ϕ is then built in a forward
fashion as shown below, where: states ofAϕ are sets of atoms
(recall that each atom is a quoted ϕ subformula) to be inter-
preted as conjunctions; the empty conjunction ∅ stands for
true; q′ is a set of quoted subformulas of ϕ denoting a mini-
mal interpretation such that q′ ⊧ ⋀(ψ∈q) δ(ψ,Π) (notice that
we trivially have (∅, a,∅) ∈ ̺ for every a ∈ Σ).
1: algorithm LDLf2NFA()
2: input LDLf formula ϕ
3: output NFA Aϕ = (2
P ,S,{s0}, ̺,{sf})
4: s0 ← {ϕ} ▷ single initial state
5: sf ← ∅ ▷ single final state
6: S ← {s0, sf}, ̺← ∅
7: while (S or ̺ change) do
8: if (q ∈ S and q′ ⊧ ⋀(ψ∈q) δ(ψ,Π)) then
9: S ← S ∪ {q′} ▷ update set of states
10: ̺← ̺ ∪ {(q,Π, q′)} ▷ update transition relation
Theorem 1. [De Giacomo and Vardi, 2015] Algorithm
LDLf2NFA terminates in at most an exponential number of
steps, and generates a set of states S whose size is at most
exponential in the size of the formula ϕ.
Note that one can remove the proposition last ∈
P by suitably adding an extra final state to Aϕ
[De Giacomo and Vardi, 2015]. The NFA Aϕ is correct, that
is:
Theorem 2. [De Giacomo and Vardi, 2015] For every finite
trace π: π ⊧ ϕ iff π ∈ L(Aϕ).
Finally, we can transform the NFA Aϕ into a DFA in expo-
nential time, following the standard procedure, and then pos-
sibly put it in (the unique) minimal form, in polynomial time
[Rabin and Scott, 1959]. Thus, we can transform any LDLf
formula into a DFA of double exponential size. While this is
a worst-case complexity, in most cases the size of the DFA is
actually manageable [Tabakov and Vardi, 2005].
3 Specifying Decision Processes with
Non-Markovian Rewards
In this section we extend MDPs with LDLf -based reward
functions resulting in a non-Markovian reward decision pro-
cess (NMRDP). Then, we show how to construct an equiva-
lent extended MDP with Markovian rewards.
A non-Markovian reward decision process (NMRDP) is a
tuple M = ⟨S,A,T r,R⟩, where S,A and Tr are as in an
MDP, andR is redefined as R ∶ (S ×A)∗ → R. The reward is
now a real-valued function over finite state-action sequences.
Given a (possibly infinite) trace π, the value of π is:
v(π) =
∣π∣
∑
i=1
γi−1R(⟨π(1), π(2), . . . , π(i)⟩),
where 0 < γ ≤ 1 is the discount factor and π(i) denotes the
pair (si−1, ai). Since every policy ρ ∶ S∗ → A induces a dis-
tribution over the set of possible infinite traces, we can now
define the value of a policy ρ given an initial state s0 to be
vρ(s) = Eπ∼M,ρ,s0v(π)
That is, vρ(s) is the expected value of infinite traces, where
traces are distributed according to the distribution over traces
defined by the initial state s0, the transition function Tr, and
the policy ρ.
Specifying a non-Markovian reward function explicitly is
cumbersome and unintuitive, even if we only want to reward
a finite number of traces. But, typically, we want to reward
behaviors that correspond to various patterns. LDLf provides
us with an intuitive and convenient language for specifying
R implicitly, using a set of pairs {(ϕi, ri)mi=1}. Intuitively, if
the current trace is π = ⟨s0, a1, . . . , sn−1, an⟩, the agent re-
ceives at sn a reward ri for every formula ϕi satisfied by π.
Formally:
R(π) = ∑
1≤i≤m∶π⊧ϕi
ri
From now on, we shall assume that R is thus specified.
Coming back to our running example, we could have the
following formulas ϕi, each associated with reward ri:
ϕ1 = [true∗](requestp → ⟨true∗⟩coffeep)
ϕ2 = [true∗]([openDoord]closeDoor d)
ϕ3 =
⟨((¬restrda)∗;permissiona; (¬restrda)∗; restrda)∗;(¬restrda)∗⟩end
4 Building an Equivalent Markovian Model
When the rewards are Markovian, one can compute vρ (for
stationary ρ) and an optimal policy ρ∗ using Bellman’s dy-
namic programming equations [Puterman, 2005]. However,
this is not the case when the reward is non-Markovian and
the policy is non-stationary. The standard solution for this
problem is to formulate an extended MDP in which the re-
wards are Markovian, that is equivalent to the original NM-
RDP [Bacchus et al., 1996; Thiébaux et al., 2006].
Definition 1 ([Bacchus et al., 1996]). An NMRDP M =
⟨S,A,T r,R⟩ is equivalent to an extended MDP M′ =
⟨S′,A,T r′,R′⟩ if there exist two functions τ ∶ S′ → S and
σ ∶ S → S′ such that
1. ∀s ∈ S ∶ τ(σ(s)) = s;
2. ∀s1, s2 ∈ S and s
′
1 ∈ S
′: if Tr(s1, a, s2) > 0 and τ(s′1) =
s1, there exists a unique s
′
2 ∈ S
′ such that τ(s′2) = s2 and
Tr(s′1, a, s′2) = Tr(s1, a, s2);
3. For any feasible trajectory ⟨s0, a1, . . . , sn−1, an⟩ ofM
and ⟨s′0, a1, . . . , s′n−1, an⟩ of M′, such that τ(s′i) = si
and σ(s0) = s′0, we have R(⟨s0, a1, . . . , sn−1, an⟩) =
R′(⟨s′0, a1, . . . , s′n−1, an⟩).
As in previous work, we restrict our attention to extended
MDPs such that S′ = Q × S, for some set Q.
Given an NMRDPM = ⟨S,A,T r,R⟩, we now show how
to construct an equivalent extended MDP. For each reward
formula ϕi, we consider the corresponding (minimal) DFA
Aϕi = (2P ,Qi, qi0, δi, Fi), where:
• 2P is the input alphabet of the automaton;
• Qi is the finite set of states;
• qi0 ∈ Qi is the initial state;
• δi ∶ Q × 2
P → Q is the deterministic transition function
(which is total);
• Fi ⊆Qi are the accepting states.
We now define the equivalent extended MDP M′ =
⟨S′,A′, T r′,R′⟩ where:
• S′ = Q1 ×⋯ ×Qm × S is the set of states;
• A′ = A;
• Tr ′ ∶ S′ ×A′ × S′ → [0,1] is defined as follows:
Tr
′(q1, . . . , qm, s, a, q′1, . . . , q′m, s′) =
{ Tr(s, a, s′) if ∀i ∶ δ(qi, s) = q′i
0 otherwise;
• R′ ∶ S′ ×A→ R is defined as:
R(q1, . . . , qm, s, a) = ∑
i∶δ(qi,s)∈Fi
ri
That is, the state space is a product of the states of the orig-
inal MDP and the various automata. The actions set is the
same. Given action a, the s component of the state progresses
according to the original MDP dynamics, and the other com-
ponents progress according to the transition function of the
corresponding automata. Finally, in every state, and for every
1 ≤ i ≤m, the agent receives the reward associated with ϕi if
the FSA Aϕi reached a final state.
Theorem 3. The NMRDP M = ⟨S,A,T r,R⟩ is equivalent
to the extended MDPM′ = ⟨S′,A′, T r′,R′⟩.
Proof. Recall that every s′ ∈ S′ has the form (q1, . . . , qm, s).
Define τ(q1, . . . , qm, s) = s. Define σ(s) = (q10, . . . , qm0, s).
We have τ(σ(s)) = s. Condition 2 is easily verifiable by
inspection. For condition 3, consider a possible trace π =
⟨s0, a1, . . . , sn−1, an⟩. We use σ to obtain s′0 = σ(s0) and
given si, we define s
′
i (for 1 ≤ i < n) to be the unique
state (q1i, . . . , qmi, si) such that qji = δi(qji−1, ai) for all
1 ≤ j ≤ m. We now have a corresponding possible trace of
M′, i.e., π′ = ⟨s′0, a1, s′1 . . . , s′n−1, an⟩. This is the only feasi-
ble trajectory ofM′ that satisfies Condition 3. The reward at
π = ⟨s0, a1, s1 . . . , sn−1, an⟩ depends only on whether or not
each formula ϕi is satisfied by π. However, by construction
of the automatonAϕi and the transition function Tr
′, π ⊧ ϕi
iff s′n−1 = (q1, . . . , qm, s′n) and qi ∈ Fi.
Let ρ′ be a policy for the MarkovianM′. It is easy to define
an equivalent policy onM: Let π = ⟨s0, a1, s1 . . . , sn−1, an⟩
be the current history of the process. Let qin denote the cur-
rent state of automaton Aϕi given input π. Define ρ(π) ∶=
ρ′(q1n, . . . , qmn, sn).
Theorem 4 ([Bacchus et al., 1996]). Given an NMRDP M,
let ρ′ be an optimal policy for an equivalent MDPM′. Then,
policy ρ forM that is equivalent to ρ′ is optimal forM.
5 Minimality and Compositionality
One advantage of our construction is that it benefits from two
types of minimality and from compositionality. The Marko-
vian model is obtained by taking the synchronous product of
the original MDP and an FSA that is itself the synchronous
product of smaller FSAs, one for each formula. We can ap-
ply the simple, standard automaton minimization algorithm to
obtain a minimal automaton, thus obtaining a minimal MDP.
But even better, as we show below, it is enough to ensure that
each FSAAϕi in the above construction is minimal to ensure
the overall minimality of the extended MDP.
Theorem 5. If every automaton Aϕi (1 ≤ i ≤ m) is minimal
then the extended MDP defined above is minimal.
Proof. Let As be the synchronous product of Aϕi (1 ≤ i ≤
m). We show that no two distinct states of the synchronous
product As are equivalent, and therefore, all of them are
needed, hence the thesis.
Suppose that there are two distinct states of the syn-
chronous product As that are equivalent. Then, being As a
DFA, such two states are bisimilar. Two states ofAs are bisim-
ilar (denoted by ∼) iff: (q1, . . . , qn) ∼ (t1, . . . , tm) implies
• for all i. qi ∈ Fi iff ti ∈ Fi;
• for all a. δs(q1, . . . , qm) = (q′1, . . . , q′m) implies
δs(t1, . . . , tm, a) = (t′1, . . . , t′m) and (q′1, . . . , q′m) ∼(t′1, . . . , t′m);
• for all a. δs(t1, . . . , tm) = (t′1, . . . , t′m) implies
δs(q1, . . . , qm, a) = (q′1, . . . , q′m) and (q′1, . . . , q′m) ∼(t′1, . . . , t′m).
Now we show that (q1, . . . , qm) ∼ (t1, . . . , tm) implies
qi = ti, for all i. To check this we show that the relation
“project on i”,Πi((q1, . . . , qm) ∼ (t1, . . . , tm)) extracting the
i-th component on the left and on the right of ∼ is a bisimu-
lation for states in Ai. Indeed it is immediate to verify that
Πi((q1, . . . , qm) ∼ (t1, . . . , tm)) implies
• qi ∈ Fi iff ti ∈ Fi;
• for all a, δi(qi, a) = q′i implies δi(ti, a) = t′i and
Πi((q′1, . . . , q′m) ∼ (t′1, . . . , t′m));
• for all a, δi(ti, a) = t′i implies δi(qi, a) = qi and
Πi((q′1, . . . , q′m) ∼ (t′1, . . . , t′m)).
Hence if there are two distinct states (q1, . . . , qm) ∼(t1, . . . , tm) then at least for one i it must be the case that qi
and ti are distinct and bisimilar and hence equivalent. But
this is impossible since each DFA Aϕi is minimal.
In general, if we take the synchronous product of two min-
imised DFA’s we may be able to minimize it further. But since
in our case we need to keep the final states of the different
DFA’s distinct (to assign the proper rewards), as the proof of
theorem above shows, no further minimization is possible.
Observe that the above theorem also implies that the con-
struction is compositional, and hence, incremental – if we
care for a new formula, we do not need to change the MDP,
but simply extend it with one additional component. If the
original MDP was minimal and the new component is mini-
mal, then so is the resulting MDP.
[Thiébaux et al., 2006] consider a different minimality cri-
terion, blind minimality, which essentially says that, given an
initial state s0 for our NMRDPM, one can construct the set
of states reachable from s0 in M
′ without having to gener-
ate any unreachable extended state. In particular, this implies
that one does not generate the entire automaton for each for-
mula, but construct only its reachable states. Moreover, one
can even focus on a subset of reachable states that correspond
to trajectories of interest.
We enjoy both notions. We can progress the extended MDP,
starting from the initial state, building it on the fly. But we can
also start by generating the reachable states of each automa-
ton separately; minimize each automaton, and take their syn-
chronous product. While the automata are theoretically large
(as is the reachable state space), in practice, experience shows
them to be quite small. Once we have the minimal structure of
the automaton, we can progress the extended MDP working
with the product of the MDP and automaton states.
6 Getting rewards for complete traces only
We may want to reward an agent for its entire behavior rather
than for each prefix of it. This means that the value of a se-
quence π = ⟨s0, a1, s1 . . . , sn−1, an⟩ is defined as follows:
v(π) = ∑
i∶π⊧ϕi
ri
Behaviors optimal w.r.t. this definition will differ from ones
that are optimal w.r.t. the original definition in which rewards
are collected following each action. The point is that an agent
must now attempt to make as many formulas true at once, as
it does not get any “credit” for having achieved them in the
past.
Given an NMRDP M with the above reward semantics,
we can easily generate an equivalent MDP using the above
construction, preceded by the following steps:
1. Add a special action stop to A.
2. Add a new proposition done to S.
3. No action is applicable in a state in which done is true.
4. The only effect of the stop action is to make done be
true.
5. Convert every reward formula ϕi to done ∧ϕi.
Interestingly, when focussing on complete traces, our
framework becomes an extension of Goal MDP planning that
handles temporally extended goals, see, e.g, Chapter 6 and
Chapter 4 of [Geffner and Bonet, 2013].
7 Comparison with previous proposals
Capturing PLTL rewards. The setting proposed can be
seen as an extension of [Bacchus et al., 1996]. There, rewards
are assigned to partial traces whenever the last state of the
trace satisfies a past-LTL (PLTL) formulas. Without introduc-
ing explicitly PLTL, but given a partial trace π0, . . . , πn we re-
verse it into πn, . . . , π0 and evaluate it over the LTLf formula
ϕ obtained from the PLTL formula by simply replacing the
past operators with the corresponding future operators (e.g.,
replace since with eventually). Then, the setting remains anal-
ogous to the one shown above.
In particular, we can construct the NFA Aϕ associated with
ϕ and, instead of reversing the partial traces, reverseAϕ, thus
getting an NFA A−ϕ, by simply reversing the edge directions
and switching initial and final states. This can be done in lin-
ear time. If we now determinize (and minimize) A−ϕ, getting
the (minimal) DFA A−ϕ, we can proceed exactly as above.
Given the above essential equivalence of PLTL and LTLf ,
and the fact that LDLf is strictly more expressive than LTLf ,
we conclude that our setting is strictly more expressive than
the one in [Bacchus et al., 1996]. In principle, we could sim-
ply replace PLTL with past-LDLf . But defining properties in
past-LDLf is likely to be unnatural, since we would have
to reverse the regular expressions in the eventualities, and
since these have a procedural flavour, it would be some-
how like reversing a program. In addition, since the au-
tomata construction algorithm is based on progression, un-
like [Bacchus et al., 1996], we can use information about the
initial state to prevent the generation of unreachable states.
Finally, we note that in [Bacchus et al., 1997], the authors
extend their work to handle NMRDPs in factored form and
attempt to ensure that the extended state retains this factored
form. We note that our construction retains the original form
of the MDP, whether factored or not, and generates a natural
factored extended state, using one factor per reward formula.
Comparing with $FLTL rewards. In [Thiébaux et al., 2002;
Gretton et al., 2003; Thiébaux et al., 2006] a sophisticated
temporal logic, called $FLTL is introduced, which is able to
specify explicitly when a partial (finite) trace gets a rewards.
The exact expressive power of $FLTL has not been assessed
yet, and it is open whether it is able to capture PLTL rewards of
[Bacchus et al., 1996] and vice-versa. As a result, it remains
open to compare our setting, based on LDLf , with $FLTL.
However, as $FLTL is based on LTL, which cannot capture
MSO, it would be rather surprising if $FLTL was able to cap-
ture the LDLf rewards proposed here.
We can show, though, how some $FLTL formulas
can be expressed in LDLf
1. We consider the examples
of [Thiébaux et al., 2006]. Some of these show how the PLTL
formulas used in [Bacchus et al., 1996] can be expressed in
$FLTL. By the relationship between PLTL and LDLf discussed
above, it is immediate that these admit an LDLf equivalent
formula. For instance, ¬pU(p ∧ $), which rewards only the
first time p is achieved, is equivalent to the PLTL formula
p ∧ ¬⊖xp, which can be, in turn, rewritten in LDLf as⟨¬p∗;p⟩end or in LTLf syntax as ¬pU(p ∧ last). There are
also $FLTL formulas for which no equivalent in PLTL is re-
ported. This is the case, e.g., of ¬qU((¬p ∧ ¬q) ∨ (q ∧ $)),
which rewards the holding of p until the occurrence of q, and
whose LDLf translation is ⟨q∗;p⟩end or, in LTLf , pU(q ∧
last). Observe how simpler it is to have an intuition of the
semantics when using the LDLf version compared with the
$FLTL one. In particular, the latter requires a rigorous appli-
cation of the semantics even to simply check that the property
is as claimed above. In addition, various properties compactly
expressible in LDLf require much more sophisticated encod-
ing when only standard temporal operators are used. Finally,
computationally, we can offer the benefits of true minimality
and blind minimality (reachability) as well as compositional-
ity.
8 Conclusion
We presented a new language for specifying non-Markovian
rewards in MDPs. Our language is more expressive than pre-
vious proposals and being based on a standard temporal log-
ics of the future, is likely to be more intuitive to use. We
showed how to construct a minimal equivalent MDP, and
since we rely on general methods for tracking temporal for-
mulas, the construction is cleaner. Being based on progres-
sion, it can use information about the initial state to prune
1For further examples see Appendix A.
unreachable states.
One problem with non-Markovian rewards is that the re-
ward is only obtained when the entire sequence satisfies
the property. This is especially true if we wish to give re-
wards for complete traces only. In that case, the reward
comes as a ”surprise” when the last action stop is cho-
sen. We can help solution algorithms if we can start re-
warding such behaviors even before the formula is sat-
isfied, helping to guide both search and learning algo-
rithms towards better behaviors. In future work we intend
to examine the use of monitoring notions developed for
LTLf and LDLf [Bauer et al., 2010; De Giacomo et al., 2014;
Maggi et al., 2011]. Using such monitors one could extract
early rewards that guide the process to get full rewards later.
Another important direction for future work is exploiting
non-Markovian rewards in reinforcement learning (RL) to
provide better guidance to the learning agent, as well as ex-
tending inverse RL methods to learn to assign non-Markovian
rewards in a state. We are currently exploring this latter issue
when the set of formulasϕi is given, but the associated reward
ri is unknown.
References
[Bacchus et al., 1996] Fahiem Bacchus, Craig Boutilier, and
Adam J. Grove. Rewarding behaviors. In Proc. of AAAI,
pages 1160–1167, 1996.
[Bacchus et al., 1997] Fahiem Bacchus, Craig Boutilier, and
Adam J. Grove. Structured solution methods for non-
markovian decision processes. In Proc. of AAAI, pages
112–117, 1997.
[Baier et al., 2008] Jorge A. Baier, Christian Fritz, Meghyn
Bienvenu, and Sheila A. McIlraith. Beyond classical plan-
ning: Procedural control knowledge and preferences in
state-of-the-art planners. In AAAI, 2008.
[Bauer et al., 2010] Andreas Bauer, Martin Leucker, and
Christian Schallhart. Comparing LTL semantics for run-
time verification. Logic and Computation, 2010.
[Bonet and Geffner, 2003] B. Bonet and H. Geffner. Labeled
RTDP: Improving the convergence of real-time dynamic
programming. In ICAPS’03, 2003.
[Camacho et al., 2017] Alberto Camacho, Eleni Triantafil-
lou, Christian Muise, Jorge A. Baier, and Sheila McIl-
raith. Non-deterministic planning with temporally ex-
tended goals: LTL over finite and infinite traces. In Proc.
of AAAI, 2017.
[De Giacomo and Vardi, 2013] Giuseppe De Giacomo and
Moshe Y. Vardi. Linear temporal logic and linear dynamic
logic on finite traces. In Proc. of IJCAI, 2013.
[De Giacomo and Vardi, 2015] Giuseppe De Giacomo and
Moshe Y. Vardi. Synthesis for LTL and LDL on finite
traces. In Proc. of IJCAI, 2015.
[De Giacomo and Vardi, 2016] Giuseppe De Giacomo and
Moshe Y. Vardi. Ltlf and ldlf synthesis under partial ob-
servability. In Proc. of IJCAI, pages 1044–1050, 2016.
[De Giacomo et al., 2014] Giuseppe De Giacomo, Riccardo
De Masellis, Marco Grasso, Fabrizio Maria Maggi, and
Marco Montali. Monitoring business metaconstraints
based on LTL and LDL for finite traces. In Proc. of BPM,
2014.
[Fischer and Ladner, 1979] Michael J. Fischer and
Richard E. Ladner. Propositional dynamic logic of
regular programs. Journal of Computer and System
Sciences, 18, 1979.
[Fritz and McIlraith, 2007] Christian Fritz and Sheila A.
McIlraith. Monitoring plan optimality during execution.
In ICAPS, 2007.
[Geffner and Bonet, 2013] Hector Geffner and Blai Bonet. A
Coincise Introduction to Models and Methods for Auto-
mated Planning. Morgan&Claypool, 2013.
[Gretton et al., 2003] Charles Gretton, David Price, and
Sylvie Thiébaux. Implementation and comparison of so-
lution methods for decision processes with non-markovian
rewards. In Proc. of UAI, pages 289–296, 2003.
[Hansen and Zilberstein, 2001] E. A. Hansen and S. Zilber-
stein. LAO*: A heuristic search algorithm that finds so-
lutions with loops. Artificial Intelligence, 129(1-2):35–62,
2001.
[Harel et al., 2000] David Harel, Dexter Kozen, and Jerzy
Tiuryn. Dynamic Logic. MIT Press, 2000.
[Levesque et al., 1997] H. J. Levesque, R. Reiter, Y. Lesper-
ance, F. Lin, and R. Scherl. GOLOG: A logic program-
ming language for dynamic domains. J. of Logic Program-
ming, 31, 1997.
[Maggi et al., 2011] Fabrizio Maria Maggi, Marco Montali,
Michael Westergaard, and Wil M. P. van der Aalst. Moni-
toring business constraints with linear temporal logic: An
approach based on colored automata. In Proc. of BPM,
2011.
[Pnueli, 1977] Amir Pnueli. The temporal logic of programs.
In Proc. of FOCS, pages 46–57. IEEE Computer Society,
1977.
[Puterman, 2005] Martin L. Puterman. Markov Decision
Processes: Discrete Stochastic Dynamic Programming.
Wiley, 2005.
[Rabin and Scott, 1959] M. O. Rabin and D. Scott. Finite
automata and their decision problems. IBM J. Res. Dev.,
3:114–125, April 1959.
[Tabakov and Vardi, 2005] Deian Tabakov and Moshe Y.
Vardi. Experimental evaluation of classical automata con-
structions. In Proc. of LPAR, 2005.
[Thiébaux et al., 2002] Sylvie Thiébaux, Froduald Kabanza,
and John K. Slaney. Anytime state-based solution methods
for decision processes with non-markovian rewards. In
Proc. of UAI, pages 501–510, 2002.
[Thiébaux et al., 2006] Sylvie Thiébaux, Charles Gretton,
John K. Slaney, David Price, and Froduald Kabanza.
Decision-theoretic planning with non-markovian rewards.
J. Artif. Intell. Res. (JAIR), 25:17–74, 2006.
[Torres and Baier, 2015] Jorge Torres and Jorge A. Baier.
Polynomial-time reformulations of LTL temporally ex-
tended goals into final-state goals. In Proc. of IJCAI, pages
1696–1703, 2015.
[Vardi, 2011] Moshe Y. Vardi. The rise and fall of linear time
logic. In Proc. of GandALF, 2011.
A Appendix: Examples of Translations of
PLTL and $FLTL formulas to LDLf
Examples of Translations of PLTL and $FLTL
formulas to LDLf
In this section, we show how formulas used
in [Bacchus et al., 1996] and in [Thiébaux et al., 2006]
can be encoded in LTLf and LDLf :
1. A reward is offered only at the first state where a goal G
holds.
• PLTL: G ∧ ¬⊖⊟G
• $FLTL: ¬GU(G ∧ $)
• LTLf : ¬GU(G ∧ last)
• LDLf : ⟨¬G∗;G⟩end
2. A reward is offered at every state that follows G (in-
cluded):
• PLTL: xG
• $FLTL: ◻(G→ ◻$)
• LTLf : ◇G
• LDLf : ⟨true∗;G; true∗⟩end
3. Achievement ofG is rewarded periodically, at most once
every k steps:
• PLTL: G ∧ ¬(⊖≤kG), where:
– ⊖≤kG ≐ ⋁ki=1⊖iG and ⊖iG ≐ ⊖ . . .⊖´¹¹¹¹¹¹¹¸¹¹¹¹¹¹¶
i times
G
• $FLTL: ◻((○k+1G ∧ ◻k¬G)→ ○k+1$), where:
– ○
iG ≐ ○ . . .○²
i times
G and ◻iG = ⋀ij=1 ○ . . .○²
j times
G
• LTLf : ◇(○k(G ∧ last)) ∧ (⋀k−1j=0 ○j¬G)
• LDLf : ⟨¬G∗;G; (¬Gk;¬G∗;G)∗)⟩end, where:
– Gk = (G; . . . ;G´¹¹¹¹¹¹¹¹¹¹¹¹¹¹¹¸¹¹¹¹¹¹¹¹¹¹¹¹¹¹¶
k times
)
4. Achievement ofG is rewarded whenever it occurs within
k steps of a state where ¬G holds (we assume k ≥ 1):
• PLTL: G ∧⊖≤k¬G
• $FLTL: ◻(¬G→ ◻k(G→ $))
• LTLf : ◇(¬G ∧ ◻k(last → G))
• LDLf : ⟨true∗;¬G;G+((¬G1+. . .+¬Gk);G)⟩end
5. A reward is issued wheneverG is achieved and followed
immediately by H and then by I:
• PLTL: ⊖2G ∧⊖H ∧ I
• $FLTL: ◻((G ∧○H ∧○2I) → ○2$)
• LTLf : ◇(G ∧○H ∧○2(I ∧ last))
• LDLf : ⟨true∗;G;H ; I⟩end
6. Achievement of G is rewarded whenever it follows C:
• PLTL: G ∧⊖C
• $FLTL: ◻(C → ○◻(G→ $))
• LTLf : ◇(C ∧○◇ (G ∧ last))
• LDLf : ⟨true∗;C; true∗;G⟩end
7. Only the first achievement of G that follows C is re-
warded:
• PLTL: G ∧⊖(¬GS C)
• $FLTL: ◻(C → ○(¬GU(G ∧ $)))
• LTLf : ◇(C ∧ ¬GU(G ∧ last))
• LDLf : ⟨true∗;C;¬G;¬G∗;G⟩end
8. G is rewarded whenever it follows C immediately:
• PLTL: G ∧⊖C
• $FLTL: ◻((C ∧○G) → ○$)
• LTLf : ◇(C ∧○(G ∧ last))
• LDLf : ⟨true∗;C;G⟩end
9. Achievement of G is rewarded whenever occurring
within k steps (k ≥ 1) of C:
• PLTL: G ∧⊖≤kC
• $FLTL: ◻(C → ◻k(G→ $))
• LTLf : ◇(G ∧ last ∧ (⋁ki=0 ○kC))
• LDLf : ⟨true∗;C;G+((true1+. . .+truek);G)⟩end
10. Only the first achievement ofG occurring within k steps
(k ≥ 1) of C is rewarded:
• PLTL: G ∧⊖≤kC ∧ (¬GS C)
• $FLTL:◻(C∧(○G→ ○$)∧(○¬G∧○2G→ ○2$)∧
. . . ∧ (○¬G ∧ . . . ∧ ○k¬G ∧○k+1G→ ○k+1$))
• LTLf : ◇(C ∧ ◻k(last ↔ G))
• LDLf : ⟨true∗;C;G+ ((¬G1 + . . .+¬Gk);G)⟩end
11. Reward is issued if G has always been true:
• PLTL: ⊟G
• $FLTL: $U ¬Q
• LTLf : ◻G
• LDLf : ⟨G∗⟩end
12. The holding of C until G is rewarded:
• PLTL: G ∧⊖⊟C
• $FLTL: ¬GU((¬C ∧ ¬G) ∨ (G ∧ $))
• LTLf : C U(G ∧ last)
• LDLf : ⟨C∗;G⟩end
Additional Examples
Here we present some examples of LDLf formulas for which
there seem not to be any LTLf translation.
It is known that the LDLf formula ⟨(tttt)∗⟩end (parity) is
not expressible in LTLf . Also the formula φ = ⟨(pr)∗⟩end
seems to be so. Indeed, a reasonable (and perhaps the most
natural) LTLf candidate for this formula would be a formula
like the following:
ψ = last ∨ (p ∧ ◻(p→ r) ∧ ◻(r → (p ∨ last))).
However, this formula does not capture φ. To see this, con-
sider the following trace:
π = {p, r}{p, r}{p, r}{p, r}.
While this satisfies φ, it does not satisfy ψ, as the last oc-
currence of p is not followed by r, as required by ψ.
We do not prove that the desired LTLf formula does not
exist but we observe that this is very unlikely. Indeed, on
traces of the same form as π (with variable length), there is no
way to distinguish the states on a local basis. Thus, the only
way to check whether the property captured by φ is enforced
seems to be checking whether a state is in even or odd posi-
tion (states at odd position are required to satisfy p and states
at even position must satisfy r). But this cannot be the case,
as LTLf cannot express parity.
Consider the example of the introduction, where a robot
is rewarded if it accesses a restricted area only after having
acquired the right permission. This can be captured in LDLf
by the following formula:
φ = ⟨(¬r∗;p;¬r∗; r)∗⟩◻¬r,
where proposition p stands for “permission granted” and r for
“restricted area entered”. This formula essentially says that
any occurrence of r must be preceded by at least one occur-
rence of p that is not already followed by another occurrence
of r. In other words, all occurrences of p are “ consumed”
when r is seen. Again, it is very unlikely that some LTLf for-
mula exists for this property, as LTLf is not able to distinguish,
in general, distinct occurrences of a same proposition along a
run.
For an attempt to find an LTLf formula, consider the fol-
lowing LTLf formula:
ψ4 = (◇r) → ¬(¬pU r),
which expresses that if an r is seen in the future, it must be
preceded by a p. This formula imposes a constraint on the
first occurrence of r only
We could then try with φ5 = ◻φ4, but this would not work
either. Indeed, φ5 is not satisfied even by the following sim-
ple trace τ = {p}{}{r}. In this case, indeed, φ4 would not
be satisfied in the second state. Formula φ5 shows a problem
that occurs often when trying to capture an LDLf formula in
LTLf , i.e., the impossibility of distinguishing the different oc-
currences of a same property.
Examples of Procedural Constraints in LDLf
Interesting examples of LDLf formulas, can be obtained by
considering that LDLf , differently from LTLf , is able to easily
express procedural constraints [De Giacomo and Vardi, 2015;
Fritz and McIlraith, 2007; Baier et al., 2008]. In particular,
we can introduce a sort of propositional variant of GOLOG
[Levesque et al., 1997]:
δ ∶∶= A ∣ ϕ? ∣ δ1 + δ2 ∣ δ1; δ2 ∣ δ∗ ∣
if φ then δ1 else δ2 ∣ while φ do δ
Note that if and while can be seen as abbreviations for LDLf
path expression [Fischer and Ladner, 1979], namely:
if φ then δ1else δ2 ≐ (φ?; δ1) + (¬φ?; δ2)
while φ do δ ≐ (φ?; δ)∗;¬φ?
Hence, we can assign rewards to LDLf formulas expressing
the traces satisfying procedural constrains. For example:
[true∗]⟨while(cold ∧ heatingOn)) do
¬turnOffHeating∗;heat⟩end
which says that at every point, while it is cold and the heating
is on then heat, possibly allowing other action except turning
off heating; and
⟨while(true)do
if (cold ∧windowOpen))then
closeWindow;
turnOnFirePlace+ turnOnHeating⟩end
which says that all along if it is cold and the window is open,
then immediately close the window and either turn on the fire
place or the heating system (differently form before, no other
actions can interleave this sequence).

