SRILM ‚Äî AN EXTENSIBLE LANGUAGE MODELING TOOLKIT
Andreas Stolcke
Speech Technology and Research Laboratory
SRI International, Menlo Park, CA, U.S.A.
http://www.speech.sri.com/
ABSTRACT
SRILM is a collection of C++ libraries, executable programs, and
helper scripts designed to allow both production of and experimen-
tation with statistical language models for speech recognition and
other applications. SRILM is freely available for noncommercial
purposes. The toolkit supports creation and evaluation of a vari-
ety of language model types based on N-gram statistics, as well
as several related tasks, such as statistical tagging and manipu-
lation of N-best lists and word lattices. This paper summarizes
the functionality of the toolkit and discusses its design and imple-
mentation, highlighting ease of rapid prototyping, reusability, and
combinability of tools.
1. INTRODUCTION
Statistical language modeling is the science (and often art) of
building models that estimate the prior probabilities of word
strings. Language modeling has many applications in natural lan-
guage technology and other areas where sequences of discrete ob-
jects play a role, with prominent roles in speech recognition and
natural language tagging (including specialized tasks such as part-
of-speech tagging, word and sentence segmentation, and shallow
parsing). As pointed out in [1], the main techniques for effec-
tive language modeling have been known for at least a decade, al-
though one suspects that important advances are possible, and in-
deed needed, to bring about significant breakthroughs in the appli-
cation areas cited above‚Äîsuch breakthroughs just have been very
hard to come by [2, 3].
Various software packages for statistical language modeling
have been in use for many years‚Äîthe basic algorithms are simple
enough that one can easily implement them with reasonable effort
for research use. One such package, the CMU-Cambridge LM
toolkit [1], has been in wide use in the research community and
has greatly facilitated the construction of language models (LMs)
for many practitioners.
This paper describes a fairly recent addition to the set of
publicly available LM tools, the SRI Language Modeling Toolkit
(SRILM). Compared to existing LM tools, SRILM offers a pro-
gramming interface and an extensible set of LM classes, several
non-standard LM types, and more a comprehensive functionality
that goes beyond language modeling to include tagging, N-best
rescoring, and other applications. This paper describes the design
philosophy and key implementation choices in SRILM, summa-
rizes its capabilities, and concludes by discussing deficiencies and
plans for future development. For lack of space we must refer to
other publications for an introduction to language modeling and its
role in speech recognition and other areas [3, 4].
2. DESIGN GOALS AND HISTORY
SRILM grew out of a dissatisfaction with previously available LM
tools at SRI, and a desire to design an LM toolkit from the ground
up, with the following goals in mind:
 Efficient and careful implementation of state-of-the-art LM
algorithms, to support development of competitive systems,
mainly in speech recognition.
 Flexibility and extendibility, so as to facilitate research into
new types of LMs, while being able to reuse existing compo-
nents.
 A rational, clean software design, providing both an applica-
tion programming interface (API) and a convenient toolbox of
commands for LM building and testing.
The design was influenced by other related software imple-
mentations. The CMU-Cambridge toolkit [1], and discussions
with its original author, Roni Rosenfeld, served as a general inspi-
ration and reference point. The HTK Lattice Toolkit [5] (to which
SRILM has an interface) provided many good ideas for a viable and
efficient API for language models. The decision to explore object-
oriented design was based on a prior project, an implementation of
various types of statistical grammars in the Common Lisp Object
System [6]. The software build system was borrowed from SRI‚Äôs
DecipherTM speech recognition system [7].
A first implementation with minimal functionality for standard
N-gram models was created prior to the 1995 Johns Hopkins Lan-
guage Modeling Summer Workshop [8]. By the end of the work-
shop, support for dynamic LM interpolation and N-best rescoring
had been added, and a small community of users outside SRI with
an associated mailing list existed. Over the next four years a se-
ries of alpha versions were made available to this small group,
while much of the current functionality (described below) was be-
ing added. In July 1999 a beta version was released for general dis-
tribution under an open source license, followed about a year later
by version 1.0. As of this writing, the latest released version is 1.3,
which added a word graph rescoring tool, a test suite, and sup-
port for Windows platforms (previous versions were Unix-only).
Most ongoing government-funded LM research and development
at SRI is based on SRILM; we therefore expect a steady stream of
functionality enhancements (as well as bug fixes) to continue.
3. FUNCTIONALITY
3.1. Basic LM operations
The main purpose of SRILM is to support language model esti-
mation and evaluation. Estimation means the creation of a model
from training data; evaluation means computing the probability
of a test corpus, conventionally expressed as the test set perplexity.
Since most LMs in SRILM are based on N-gram statistics, the tools
to accomplish these two purposes are named ngram-count and
ngram, respectively. A standard LM (trigram with Good-Turing
discounting and Katz backoff for smoothing) would be created by
ngram-count -text TRAINDATA -lm LM
The resulting LM may then be evaluated on a test corpus using
ngram -lm LM -ppl TESTDATA -debug 2
The ngram -debug option controls the level of detail of
diagnostic output. A value of 2 means that probabilities are to
be reported at the word level, including the order of N-gram used,
in addition to the standard log probabilities and perplexities. Some
additional statistics that also help gauge LM quality are the number
of out-of-vocabulary (OOV) words and the ‚Äúhit rates‚Äù of various
levels of N-grams (in LMs based on N-grams) [1]; these are either
computed by ngram itself or (as in the case of hit rates) tallied by
auxiliary scripts that analyze the ngram output.
SRILM by itself performs no text conditioning, and treats ev-
erything between whitespace as a word. Normalization and to-
kenization of text are highly corpus-dependent, and are typically
accomplished with filters that preprocess the data.
3.2. Bells and whistles
The programs ngram-count and ngram have a rather large
number of options to control the many parameters of LM estima-
tion and testing. The most important parameters for LM training
are
 the order of N-grams to use (e.g., unigram, bigram). There is
no built-in limit on the length of N-grams.
 the type of discounting algorithm to use. Currently sup-
ported methods include Good-Turing, absolute, Witten-Bell,
and modified Kneser-Ney [9]. Each of these discounting meth-
ods requires its own set of parameters, as well as a choice of
whether higher- and lower-order estimates are to be combined
via backoff or interpolation.
 an optional predefined vocabulary to limit or augment the set
of words from the training data.
 whether unknown words are to be discarded or treated as a
special ‚Äúunknown word‚Äù token.
 whether to collapse case distinctions in the input text.
Beyond LM estimation, ngram-count performs useful N-gram
count manipulations, such as generating counts from text, sum-
ming count files, and recomputing lower-order counts from higher-
order counts. ngram-count handles integer or fractional counts,
although only a subset of the smoothing algorithms supports the
latter (generally speaking, those that rely on counts-of-counts
statistics do not).
The main parameters controlling LM evaluation are the order
of N-gram to use (which can be lower than what the LM includes,
so that a 4-gram model may conveniently be used also as a bigram
or trigram model), and the variant of N-gram model to use‚Äîfor
example, a word-based, class-based, or interpolated N-gram, as
well as any additional parameters associated with that type of LM.
The types of models supported are described further in Section 3.3.
Beyond LM evaluation, ngram is really a tool to manipulate
LMs in a variety of ways. Besides computing test set log probabil-
ities from text or counts, it can
 renormalize a model (recomputing backoff weights)
 approximate a class-based or interpolated N-gram with a stan-
dard word-based backoff LM
 prune N-gram parameters, using an entropy criterion [10]
 prepare LMs for conversion to finite-state graphs by removing
N-grams that would be superseded by backoffs
 generate random sentences from the distribution embodied by
the LM.
The ability to approximate class-based and interpolated N-
gram LMs by a single word N-gram model deserves some dis-
cussion. Both of these operations are useful in situations where
other software (e.g., a speech recognizer) supports only standard
N-grams. Class N-grams are approximated by expanding class la-
bels into their members (which can contain multiword strings) and
then computing the marginal probabilities of word N-gram strings.
This operation increases the number of N-grams combinatorially,
and is therefore feasible only for relatively small models.
An interpolated backoff model is obtained by taking the union
of N-grams of the input models, assigning each N-gram the
weighted average of the probabilities from those models (in some
of the models this probability might be computed by backoff), and
then renormalizing the new model. We found that such interpo-
lated backoff models consistently give slightly lower perplexities
than the corresponding standard word-level interpolated models.
The reason could be that the backoff distributions are themselves
obtained by interpolation, unlike in standard interpolation, where
each component model backs off individually.
3.3. Language model types
Besides the standard word-based N-gram backoff models, SRILM
implements several other LM types, most of them based on N-
grams as basic building blocks.
Class-based models ‚Äî N-grams over word classes are an ef-
fective way to increase the robustness of LMs and to incorporate
domain knowledge, e.g., by defining word classes reflecting the
task semantics. SRILM allows class members to be multiword
strings (e.g., ‚Äúsan francisco‚Äù can be a member of class ‚ÄúCITY-
NAME‚Äù). This, and the fact that words can belong to more than
one class, requires the use of dynamic programming to evaluate
a class N-gram. Word classes may be defined manually or by a
separate program, ngram-class, which induces classes from
bigram statistics using the Brown algorithm [11].
Cache models ‚Äî This well-known LM technique assigns
nonzero probability to recent words, thus modeling the tendency
of words to reoccur over short spans [12]. They are usually inter-
polated with a standard model to obtain an adaptive LM.
Disfluency and hidden event language models ‚Äî Hidden event
LMs incorporate special words that appear in the model‚Äôs N-
grams, but are not overt in the observed word stream. Instead, they
correspond to the states of a hidden Markov model, and can be
used to model linguistic events such as unmarked sentence bound-
aries. Optionally, these events can be associated with nonlexical
likelihoods to condition the LM on other knowledge sources (e.g.,
prosody) [13]. A special type of hidden event LM can model
speech disfluencies by allowing the hidden events to modify the
word history; for example, a word deletion event would erase one
or more words to model a false start [14].
Skip language models ‚Äî In this LM, words in the history are
probabilistically skipped, allowing more distant words to take their
places. The skipping probabilities associated with each word are
estimated using expectation maximization.
HMMs of N-grams ‚Äî This LM consists of a hidden Markov
model (HMM) where each state is associated with its own N-gram
distribution. The model generates from a certain state until the lo-
cal N-gram issues an end-of-sentence, at which point it transitions
probabilistically to a neighboring state. HMMs of N-grams pro-
vide a general framework that can encode a variety of LM types
proposed in the literature, such as sentence-level mixtures [15] and
pivot LMs [16].
Dynamically interpolated LMs ‚Äî Two or more LMs can be
interpolated linearly at the word level such that the interpolation
weights reflect the likelihoods of the models given the recent N-
gram history [8]. With a null history, we obtain the usual static
LM interpolation approach that is often used to combine different
sources of training material into a single model.
3.4. Other applications of language models
Over the years SRILM has evolved to include tools that go beyond
simple LM construction and evaluation, covering mainly LM ap-
plications arising in speech recognition.
disambig ‚Äî an HMM-based tagger that uses N-gram LMs of
arbitrary order to model the prior on tag sequences.
hidden-ngram ‚Äî a word boundary tagger, based on hidden
event N-gram models.
segment-nbest ‚Äî a rescoring tool that applies a language
model over a sequence of adjoining N-best lists, thereby over-
coming sentence segmentation mismatch [17].
lattice-tool ‚Äî a tool to rescore and expand word lattices.
nbest-lattice ‚Äî a tool to perform word error minimiza-
tion on N-best lists [18] or construct confusion networks
(‚Äúsausages‚Äù) [19]. Together with a helper script, this tool also
implements a word posterior-based N-best generalization of
the ROVER algorithm [20, 21].
nbest-scripts ‚Äî a collection of wrapper scripts that manip-
ulate and rescore N-best lists.
pfsg-scripts ‚Äî for converting LMs to word graphs.
nbest-optimize ‚Äî optimizes log linear score combination
for word posterior-based (‚Äúsausage‚Äù) decoding.
4. DESIGN AND IMPLEMENTATION
SRILM is designed and implemented in three layers.
1. At the core are libraries comprising about 50 C++ classes
for language models and miscellaneous objects (such as vo-
cabulary symbol tables, N-best lists, word graphs, DP trel-
lises), which in turn make use of a library of efficient container
classes (e.g., arrays, hash tables).
2. The 14 main executable tools such as ngram-count,
ngram, and taggers, are written in C++ on top of the API
provided by the libraries.
3. Numerous helper and wrapper scripts perform miscellaneous
tasks that are more conveniently implemented in the gawk and
Bourne shell scripting languages.
We summarize the characteristics of each implementation layer.
4.1. Class libraries
C++ class libraries implement the API of SRILM. Object-oriented
programming turns out to be an excellent match for LM implemen-
tation, for several reasons. A class hierarchy naturally reflects the
specialization relation between different LM types (e.g., a class N-
gram is a special case of an N-gram, which is a special case of an
LM). Inheritance allows new LM variants to be derived from ex-
isting ones with minimal effort. A new LM class minimally needs
to define only a wordProb function, the method used to compute
conditional probabilities given a word and its history.1 Most LM
functions are defined generically, and need not be reimplemented
for a new derived LM class. For example, sentenceProb is
defined in terms of wordProb and typically inherited from the
generic LM class; however, a given LM can define its own ver-
sion of sentenceProb, for efficiency or to change the standard
behavior.
Hash tables, arrays, tries, and other basic data structures have
been implemented from scratch, for speed and compactness under
the types of uses associated with LM data structures.2 Templatized
data structures and functions are very useful beyond the low-level
containers; N-gram statistics and estimation functions, for exam-
ple, are templatized to support both integer and fractional counts.
4.2. Executable tools
The executable tools are designed to be both self-contained and
combinable in useful ways. Thus, as shown earlier, a standard LM
can be built from a text file in a single invocation. More complex
manipulations are possible by chaining together tools, using the
Unix standard input/output and ‚Äúpipe‚Äù mechanism. Thus, a class-
based N-gram model can be trained, pruned, expanded into a word
trigram model, and interpolated with another model using the fol-
lowing pipeline (some options have been omitted to save space):
replace-words-with-classes TRAINDATA | \
ngram-count -text - -lm - | \
ngram -lm - -prune 1e-5 -write-lm - | \
ngram -lm - -expand-classes 3 -write-lm - | \
ngram -lm - -mix-lm LM2 -write-lm MIXLM
4.3. Helpers and wrappers
Miscellaneous other tools are implemented in gawk and shell
scripts, either because they involve simple text manipula-
tions that are more conveniently done this way (such as
replace-words-with-classes in the example above), or
because they only require a wrapper that combines the basic tools.
An example of the latter is change-lm-vocab, a script that
modifies the vocabulary of an existing N-gram LM. The script
eliminates N-grams that have become OOV (using the textual LM
format) and then lets ngram fill in new unigrams and renormalize
the backoff weights. Other scripts parse the diagnostic output of
the tools, such as compute-best-mix, which computes opti-
mal interpolation weights from ngram -ppl output.
1Often a read function is also needed, but can be borrowed from an
existing class if the same external representation is used, as is frequently
the case with N-gram based models.
2We considered switching to the Standard Template Library (STL) for
containers, but found that this would incur a significant loss of both speed
and compactness.
4.4. File formats
SRILM uses standard file formats where possible‚Äîin particular,
the ARPA format for N-gram backoff LMs. Word graphs use SRI‚Äôs
probabilistic finite-state grammar (PFSG) format, which can be
converted to and from that used by AT&T‚Äôs finite state machine
toolkit [22]. Where new file formats were needed we chose easy-
to-parse textual representations. All the main tools can read and
write compressed files, as large amounts of data and models are
often associated with LM work. We avoided binary file formats
because of their lack of portability and flexibility, and prefer to use
compressed textual formats instead.
5. SHORTCOMINGS AND FUTURE DEVELOPMENTS
Many well-established LM techniques are not implemented in
SRILM, such as deleted interpolation or maximum entropy model-
ing, mainly because these have not proven essential in our work so
far. One candidate for future addition is a more flexible class-based
model, since refinements of class-based LMs seem to provide an
effective and efficient way to incorporate grammatical information
into the LM [23]. The low-level implementation of data struc-
tures is currently biased toward speed and convenience rather than
memory usage; it might be worthwhile to reevaluate this choice
to accommodate ever-larger training corpora. SRILM currently as-
sumes single-byte character encoding and uses only whitespace for
tokenization; it would be desirable to include support for multi-
byte character sets and SGML-tagged formats at some point. Ul-
timately, however, development of the toolkit will continue to be
driven by research needs, and is therefore hard to predict.
Availability. SRILM is freely available for noncommer-
cial users under an Open Source Community License, designed
to ensure that enhancements by others find their way back
into the user community. Licensing for commercial purposes
is also available. Documentation and software are online at
http://www.speech.sri.com/projects/srilm/.
6. ACKNOWLEDGMENTS
Fuliang Weng wrote the initial version of the lattice rescoring tool in
SRILM; Dimitra Vergyri developed the score combination optimizer based
on simplex search; Anand Venkataraman contributed N-best decoding
and other enhancements to the statistical tagging tools. Development of
SRILM has benefited greatly from its use and constructive criticism by
many colleagues at SRI, the Johns Hopkins summer workshops, and the
larger research community. Barbara Peskin helped improve this paper
with valuable suggestions. The work described here was in part supported
by DARPA under contract N66001-97-C-8544 and by NSF-STIMULATE
grant IRI-9619921. The views herein are those of the author and do not
reflect the policies of the funding agencies.
7. REFERENCES
[1] P. Clarkson and R. Rosenfeld, ‚ÄúStatistical language modeling using
the CMU-Cambridge toolkit‚Äù, in G. Kokkinakis, N. Fakotakis, and
E. Dermatas, editors, Proc. EUROSPEECH, vol. 1, pp. 2707‚Äì2710,
Rhodes, Greece, Sep. 1997.
[2] F. Jelinek, ‚ÄúUp from trigrams! The struggle for improved language
models‚Äù, in Proc. EUROSPEECH, pp. 1037‚Äì1040, Genova, Italy,
Sep. 1991.
[3] R. Rosenfeld, ‚ÄúTwo decades of statistical language modeling: Where
do we go from here?‚Äù, Proceedings of the IEEE, vol. 88, 2000.
[4] D. Jurafsky and J. H. Martin, Speech and Language Processing: An
Introduction to Natural Language Processing, Computational Lin-
guistics, and Speech Recognition, Prentice-Hall, Upper Saddle River,
NJ, 2000.
[5] J. J. Odell, Lattice and Language Model Toolkit Reference Manual,
Entropic Cambridge Research Laboratories, Inc., 1995.
[6] A. Stolcke, Bayesian Learning of Probabilistic Language Models,
PhD thesis, University of California, Berkeley, CA, July 1994.
[7] H. Murveit, J. Butzberger, V. Digalakis, and M. Weintraub, ‚ÄúLarge-
vocabulary dictation using SRI‚Äôs DECIPHER speech recognition sys-
tem: Progressive search techniques‚Äù, in Proc. ICASSP, vol. II, pp.
319‚Äì322, Minneapolis, Apr. 1993.
[8] M. Weintraub, Y. Aksu, S. Dharanipragada, S. Khudanpur, H. Ney,
J. Prange, A. Stolcke, F. Jelinek, and E. Shriberg, ‚ÄúLM95 Project
Report: Fast training and portability‚Äù, Research Note 1, Center for
Language and Speech Processing, Johns Hopkins University, Balti-
more, Feb. 1996.
[9] S. F. Chen and J. Goodman, ‚ÄúAn empirical study of smoothing tech-
niques for language modeling‚Äù, Technical Report TR-10-98, Com-
puter Science Group, Harvard University, Aug. 1998.
[10] A. Stolcke, ‚ÄúEntropy-based pruning of backoff language models‚Äù,
in Proceedings DARPA Broadcast News Transcription and Under-
standing Workshop, pp. 270‚Äì274, Lansdowne, VA, Feb. 1998. Mor-
gan Kaufmann.
[11] P. F. Brown, V. J. Della Pietra, P. V. deSouza, J. C. Lai, and R. L.
Mercer, ‚ÄúClass-based n-gram models of natural language‚Äù, Compu-
tational Linguistics, vol. 18, pp. 467‚Äì479, 1992.
[12] R. Kuhn and R. de Mori, ‚ÄúA cache-base natural language model for
speech recognition‚Äù, IEEE PAMI, vol. 12, pp. 570‚Äì583, June 1990.
[13] A. Stolcke, E. Shriberg, D. Hakkani-TuÃàr, and G. TuÃàr, ‚ÄúModeling
the prosody of hidden events for improved word recognition‚Äù, in
Proc. EUROSPEECH, vol. 1, pp. 307‚Äì310, Budapest, Sep. 1999.
[14] A. Stolcke and E. Shriberg, ‚ÄúStatistical language modeling for speech
disfluencies‚Äù, in Proc. ICASSP, vol. 1, pp. 405‚Äì408, Atlanta, May
1996.
[15] R. Iyer, M. Ostendorf, and J. R. Rohlicek, ‚ÄúLanguage modeling with
sentence-level mixtures‚Äù, in Proc. ARPA HLT Workshop, pp. 82‚Äì86,
Plainsboro, NJ, Mar. 1994.
[16] K. W. Ma, G. Zavaliagkos, and M. Meteer, ‚ÄúSub-sentence discourse
models for conversational speech recognition‚Äù, in Proc. ICASSP,
vol. II, pp. 693‚Äì696, Seattle, WA, May 1998.
[17] A. Stolcke, ‚ÄúModeling linguistic segment and turn boundaries for N-
best rescoring of spontaneous speech‚Äù, in G. Kokkinakis, N. Fako-
takis, and E. Dermatas, editors, Proc. EUROSPEECH, vol. 5, pp.
2779‚Äì2782, Rhodes, Greece, Sep. 1997.
[18] A. Stolcke, Y. Konig, and M. Weintraub, ‚ÄúExplicit word error min-
imization in N-best list rescoring‚Äù, in G. Kokkinakis, N. Fakotakis,
and E. Dermatas, editors, Proc. EUROSPEECH, vol. 1, pp. 163‚Äì166,
Rhodes, Greece, Sep. 1997.
[19] L. Mangu, E. Brill, and A. Stolcke, ‚ÄúFinding consensus in speech
recognition: Word error minimization and other applications of con-
fusion networks‚Äù, Computer Speech and Language, vol. 14, pp. 373‚Äì
400, Oct. 2000.
[20] J. G. Fiscus, ‚ÄúA post-processing system to yield reduced word er-
ror rates: Recognizer output voting error reduction (ROVER)‚Äù, in
Proceedings IEEE Automatic Speech Recognition and Understand-
ing Workshop, pp. 347‚Äì352, Santa Barbara, CA, 1997.
[21] A. Stolcke, H. Bratt, J. Butzberger, H. Franco, V. R. Rao Gadde,
M. PlaucheÃÅ, C. Richey, E. Shriberg, K. SoÃànmez, F. Weng, and
J. Zheng, ‚ÄúThe SRI March 2000 Hub-5 conversational speech tran-
scription system‚Äù, in Proceedings NIST Speech Transcription Work-
shop, College Park, MD, May 2000.
[22] M. Mohri, F. Pereira, and M. Riley, ‚ÄúFSM Library‚Äî
general-purpose finite-state machine software tools, version 3.6‚Äù,
http://www.research.att.com/sw/tools/fsm/, 1998.
[23] W. Wang, Y. Liu, and M. P. Harper, ‚ÄúRescoring effectiveness of
language models using different levels of knowledge and their inte-
gration‚Äù, in Proc. ICASSP, Orlando, FL, May 2002.

