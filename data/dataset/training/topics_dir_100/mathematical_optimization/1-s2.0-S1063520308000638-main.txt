Appl. Comput. Harmon. Anal. 26 (2009) 301–321Contents lists available at ScienceDirect
Applied and Computational Harmonic Analysis
www.elsevier.com/locate/acha
CoSaMP: Iterative signal recovery from incomplete
and inaccurate samples ✩
D. Needell a,∗, J.A. Tropp b
a Department of Mathematics, University of California at Davis, 1 Shields Ave., Davis, CA 95616, USA
b Applied and Computational Mathematics, MC 217-50, California Institute of Technology, Pasadena, CA 91125, USA
a r t i c l e i n f o a b s t r a c t
Article history:
Received 18 March 2008
Revised 16 July 2008
Accepted 17 July 2008
Available online 22 July 2008
Communicated by Charles K. Chui
Keywords:
Algorithms
Approximation
Basis pursuit
Compressed sensing
Orthogonal matching pursuit
Restricted isometry property
Signal recovery
Sparse approximation
Uncertainty principle
Compressive sampling offers a new paradigm for acquiring signals that are compressible
with respect to an orthonormal basis. The major algorithmic challenge in compressive
sampling is to approximate a compressible signal from noisy samples. This paper describes
a new iterative recovery algorithm called CoSaMP that delivers the same guarantees as
the best optimization-based approaches. Moreover, this algorithm offers rigorous bounds
on computational cost and storage. It is likely to be extremely efficient for practical
problems because it requires only matrix–vector multiplies with the sampling matrix. For
compressible signals, the running time is just O(N log2 N), where N is the length of the
signal.
Published by Elsevier Inc.
1. Introduction
In applications, most signals of interest contain scant information relative to their ambient dimension, but the classical
approach to signal acquisition ignores this fact. We usually collect a complete representation of the target signal and process
this representation to sieve out the actionable information. Then we discard the rest. Contemplating this ugly inefficiency,
one might ask if it is possible instead to acquire compressive samples. In other words, is there some type of measurement
that automatically winnows out the information from a signal? Incredibly, the answer is sometimes yes.
Compressive sampling refers to the idea that, for certain types of signals, a small number of nonadaptive samples carries
sufficient information to approximate the signal well. Research in this area has two major components:
Sampling: How many samples are necessary to reconstruct signals to a specified precision? What type of samples? How
can these sampling schemes be implemented in practice?
Reconstruction: Given the compressive samples, what algorithms can efficiently construct a signal approximation?
✩ Initially presented at Information Theory and Applications, 31 January 2008, San Diego.
* Corresponding author.
E-mail addresses: dneedell@math.ucdavis.edu (D. Needell), jtropp@acm.caltech.edu (J.A. Tropp).1063-5203/$ – see front matter Published by Elsevier Inc.
doi:10.1016/j.acha.2008.07.002
302 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321The literature already contains a well-developed theory of sampling, which we summarize below. Although algorithmic
work has been progressing, the state of knowledge is less than complete. We assert that a practical signal reconstruction
algorithm should have all of the following properties.
• It should accept samples from a variety of sampling schemes.
• It should succeed using a minimal number of samples.
• It should be robust when samples are contaminated with noise.
• It should provide optimal error guarantees for every target signal.
• It should offer provably efficient resource usage.
This paper presents and analyzes a novel signal reconstruction algorithm that achieves these desiderata. The algorithm
is called CoSaMP, from the acrostic compressive sampling matching pursuit. As the name suggests, the new method is ul-
timately based on orthogonal matching pursuit (OMP) [39], but it incorporates several other ideas from the literature to
accelerate the algorithm and to provide strong guarantees that OMP cannot. Before we describe the algorithm, let us deliver
an introduction to the theory of compressive sampling.
1.1. Rudiments of compressive sampling
To enhance intuition, we focus on sparse and compressible signals. For vectors in CN , define the 0 “quasinorm”
‖x‖0 =
∣∣supp(x)∣∣ = ∣∣{ j: x j = 0}∣∣.
We say that a signal x is s-sparse when ‖x‖0  s. Sparse signals are an idealization that we do not encounter in applications,
but real signals are quite often compressible, which means that their entries decay rapidly when sorted by magnitude. As a
result, compressible signals are well approximated by sparse signals. We can also talk about signals that are compressible
with respect to other orthonormal bases, such as a Fourier or wavelet basis. In this case, the sequence of coefficients
in the orthogonal expansion decays quickly. It represents no loss of generality to focus on signals that are compressible
with respect to the standard basis, and we do so without regret. For a more precise definition of compressibility, turn to
Section 2.5.
In the theory of compressive sampling, a sample is a linear functional applied to a signal. The process of collecting
multiple samples is best viewed as the action of a sampling matrix Φ on the target signal. If we take m samples, or mea-
surements, of a signal in CN , then the sampling matrix Φ has dimensions m × N . A natural question now arises: How many
measurements are necessary to acquire s-sparse signals?
The minimum number of measurements m  2s on account of the following simple argument. The sampling matrix
must not map two different s-sparse signals to the same set of samples. Therefore, each collection of 2s columns from the
sampling matrix must be nonsingular. Although certain Vandermonde matrices arising from Reed–Solomon codes satisfy
this property, these matrices are not really suitable for signal acquisition because they contain column submatrices that are
very badly conditioned. As a result, some sparse signals are mapped to very similar sets of samples, and it is unstable to
invert the sampling process numerically.
Instead, Candès and Tao proposed the stronger condition that the geometry of sparse signals should be preserved under
the action of the sampling matrix [6]. To quantify this idea, they defined the rth restricted isometry constant of a matrix Φ
as the least number δr for which
(1 − δr)‖x‖22  ‖Φx‖22  (1 + δr)‖x‖22 whenever ‖x‖0  r. (1.1)
We have written ‖ · ‖2 for the 2 vector norm. When δr < 1, these inequalities imply that each collection of r columns
from Φ is nonsingular, which is the minimum requirement for acquiring (r/2)-sparse signals. When δr  1, the sampling
operator very nearly maintains the 2 distance between each pair of (r/2)-sparse signals. In consequence, it is possible to
invert the sampling process stably.
To acquire s-sparse signals, one therefore hopes to achieve a small restricted isometry constant δ2s with as few samples
as possible. A striking fact is that many types of random matrices have excellent restricted isometry behavior. For example,
we can often obtain δ2s  0.1 with
m = O(s logα N)
measurements, where α is a small integer. Unfortunately, no deterministic sampling matrix is known to satisfy a comparable
bound. Even worse, it is computationally difficult to check the inequalities (1.1), so it may never be possible to exhibit an
explicit example of a good sampling matrix.
As a result, it is important to understand how random sampling matrices behave. The two quintessential examples are
Gaussian matrices and partial Fourier matrices.
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 303Gaussian matrices: If the entries of
√
mΦ are independent and identically distributed standard normal variables then
m  Cr log(N/r)
ε2
⇒ δr  ε (1.2)
except with probability e−cm . See [6] for details.
Partial Fourier matrices: If
√
mΦ is a uniformly random set of m rows drawn from the N × N unitary discrete Fourier
transform (DFT), then
m  Cr log
5 N · log(ε−1)
ε2
⇒ δr  ε (1.3)
except with probability N−1. See [35] for the proof.
Here and elsewhere, we follow the analyst’s convention that upright letters (c,C, . . .) refer to positive, universal constants
that may change from appearance to appearance.
The Gaussian matrix is important because it has optimal restricted isometry behavior. Indeed, for any m × N matrix,
δr  0.1 ⇒ m  Cr log(N/r),
on account of profound geometric results of Kashin [25] and Garnaev–Gluskin [16]. Even though partial Fourier matrices
may require additional samples to achieve a small restricted isometry constant, they are more interesting for the following
reasons [3].
• There are technologies that acquire random Fourier measurements at unit cost per sample.
• The sampling matrix can be applied to a vector in time O(N log N).
• The sampling matrix requires only O(m log N) storage.
Other types of sampling matrices, such as the random demodulator [37], enjoy similar qualities. These traits are essential for
the translation of compressive sampling from theory into practice.
1.2. Signal recovery algorithms
The major algorithmic challenge in compressive sampling is to approximate a signal given a vector of noisy samples. The
literature describes a huge number of approaches to solving this problem. They fall into three rough categories:
Greedy pursuits: These methods build up an approximation one step at a time by making locally optimal choices at each
step. Examples include OMP [39], stagewise OMP (StOMP) [14], and regularized OMP (ROMP) [30,31].
Convex relaxation: These techniques solve a convex program whose minimizer is known to approximate the target sig-
nal. Many algorithms have been proposed to complete the optimization, including interior-point methods [3,26], projected
gradient methods [15], and iterative thresholding [11].
Combinatorial algorithms: These methods acquire highly structured samples of the signal that support rapid reconstruction
via group testing. This class includes Fourier sampling [18,20], chaining pursuit [21], and HHS pursuit [22], as well as some
algorithms of Cormode–Muthukrishnan [9] and Iwen [24].
At present, each type of algorithm has its native shortcomings. Many of the combinatorial algorithms are extremely fast—
sublinear in the length of the target signal—but they require a large number of somewhat unusual samples that may not
be easy to acquire. At the other extreme, convex relaxation algorithms succeed with a very small number of measurements,
but they tend to be computationally burdensome. Greedy pursuits—in particular, the ROMP algorithm—are intermediate in
their running time and sampling efficiency.
CoSaMP, the algorithm described in this paper, is at heart a greedy pursuit. It also incorporates ideas from the com-
binatorial algorithms to guarantee speed and to provide rigorous error bounds [22]. The analysis is inspired by the work
on ROMP [30,31] and the work of Candès–Romberg–Tao [4] on convex relaxation methods. In particular, we establish the
following result.
Theorem A (CoSaMP). Suppose that Φ is an m × N sampling matrix with restricted isometry constant δ2s  c. Let u = Φx + e be a
vector of samples of an arbitrary signal, contaminated with arbitrary noise. For a given precision parameter η, the algorithm CoSaMP
produces an s-sparse approximation a that satisfies
‖x − a‖2  C · max
{
η,
1√
s
‖x − xs/2‖1 + ‖e‖2
}
where xs/2 is a best (s/2)-sparse approximation to x. The running time is O(L · log(‖x‖2/η)), where L bounds the cost of a matrix–
vector multiply with Φ or Φ∗ . Working storage is O(N).
304 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321Let us expand on the statement of this result. First, recall that many types of random sampling matrices satisfy the
restricted isometry hypothesis when the number of samples m = O(s logα N). Therefore, the theorem applies to a wide class
of sampling schemes when the number of samples is proportional to the target sparsity and logarithmic in the ambient
dimension of the signal space.
The algorithm produces an s-sparse approximation whose 2 error is comparable with the scaled 1 error of the best
(s/2)-sparse approximation to the signal. Of course, the algorithm cannot resolve the uncertainty due to the additive noise,
so we also pay for the energy in the noise. This type of error bound is structurally optimal, as we discuss in Section 2.5.
Some disparity in the sparsity levels (here, s versus s/2) seems to be necessary when the recovery algorithm is computa-
tionally efficient [34].
We can interpret the error guarantee as follows. In the absence of noise, the algorithm can recover an s-sparse signal to
arbitrarily high precision. Performance degrades gracefully as the energy in the noise increases. Performance also degrades
gracefully for compressible signals. The theorem is ultimately vacuous for signals that cannot be approximated by sparse
signals, but compressive sampling is not an appropriate technique for this class.
The running time bound indicates that each matrix–vector multiplication reduces the error by a constant factor (if we
amortize over the entire execution). That is, the algorithm has linear convergence.1 We find that the total runtime is roughly
proportional to the reconstruction signal-to-noise ratio
R-SNR = 10 log10
( ‖x‖2
‖x − a‖2
)
dB.
For compressible signals, one can show that R-SNR = O(log s). The runtime is also proportional to the cost of a matrix–
vector multiply. For sampling matrices with a fast multiply, the algorithm is accelerated substantially. In particular, for the
partial Fourier matrix, a matrix–vector multiply requires time O(N log N). It follows that the total runtime is O(N log N ·
R-SNR). For most signals of interest, this cost is nearly linear in the signal length!
The algorithm requires the sparsity level s as part of its input. There are several strategies for choosing s. The simplest
method is to deduce the sparsity level s from the number m of measurements. When the signal length N is large in
comparison with the other parameters, phase transition analysis [13] suggests that we can recover most sparse signals when
m ≈ 2s log N . Therefore, the estimate s ≈ m/2 log N is often reasonable. For particular applications, it may be preferable to
undertake an empirical study of the relationship between the parameters.
A second approach is to run CoSaMP using a range of sparsity levels and to select the best approximation obtained. To
limit the time cost, one may vary s along a geometric progression, say s = 1,2,4,8, . . . ,m, which increases the runtime
by a factor no worse than O(log m). To determine the quality of the output a, we may compute the error ‖Φa − u‖2 in
approximating the samples, which reflects the actual approximation error. See Appendix A for more details.
1.3. Notation
Let us instate several pieces of notation that are carried throughout the paper. For p ∈ [1,∞], we write ‖ · ‖p for the
usual p vector norm. We reserve the symbol ‖ · ‖ for the spectral norm, i.e., the natural norm on linear maps from 2 to 2.
Suppose that x is a signal in CN and r is a positive integer. We write xr for the signal in CN that is formed by restricting
x to its r largest-magnitude components. Ties are broken lexicographically. This signal is a best r-sparse approximation to x
with respect to any p norm. Suppose now that T is a subset of {1,2, . . . , N}. We define the restriction of the signal to the
set T as
x|T =
{
xi, i ∈ T ,
0, otherwise.
We occasionally abuse notation and treat x|T as an element of CT , the linear space of complex-valued functions on the set T .
We write ΦT for the column submatrix of Φ whose columns are listed in the set T . Finally, we define the pseudoinverse of
a tall, full-rank matrix A by the formula A† = (A∗ A)−1 A∗ .
1.4. Organization
The rest of the paper has the following structure. In Section 2 we introduce the CoSaMP algorithm, we state the major
theorems in more detail, and we discuss implementation and resource requirements. Section 3 describes some consequences
of the restricted isometry property that pervade our analysis. The central theorem is established for sparse signals in Sec-
tions 4 and 5. We extend this result to general signals in Section 6. Finally, Section 7 places the algorithm in the context of
previous work. The appendix presents variations on the algorithm.
1 Mathematicians sometimes refer to linear convergence as “exponential convergence.”
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 3052. The CoSaMP algorithm
This section gives an overview of the algorithm, along with explicit pseudocode. It presents the major theorems on the
performance of the algorithm. Then it covers details of implementation and bounds on resource requirements.
2.1. Intuition
The most difficult part of signal reconstruction is to identify the locations of the largest components in the target signal.
CoSaMP uses an approach inspired by the restricted isometry property. Suppose that the sampling matrix Φ has restricted
isometry constant δs  1. For an s-sparse signal x, the vector y = Φ∗Φx can serve as a proxy for the signal because the
energy in each set of s components of y approximates the energy in the corresponding s components of x. In particular, the
largest s entries of the proxy y point toward the largest s entries of the signal x. Since the samples have the form u = Φx,
we can obtain the proxy just by applying the matrix Φ∗ to the samples.
The algorithm invokes this idea iteratively to approximate the target signal. At each iteration, the current approximation
induces a residual, the part of the target signal that has not been approximated. As the algorithm progresses, the samples
are updated so that they reflect the current residual. These samples are used to construct a proxy for the residual, which
permits us to identify the large components in the residual. This step yields a tentative support for the next approximation.
We use the samples to estimate the approximation on this support set using least squares. This process is repeated until we
have found the recoverable energy in the signal.
2.2. Overview
As input, the CoSaMP algorithm requires four pieces of information:
• Access to the sampling operator via matrix–vector multiplication.
• A vector of (noisy) samples of the unknown signal.
• The sparsity of the approximation to be produced.
• A halting criterion.
The algorithm is initialized with a trivial signal approximation, which means that the initial residual equals the unknown
target signal. During each iteration, CoSaMP performs five major steps:
(1) Identification. The algorithm forms a proxy of the residual from the current samples and locates the largest components
of the proxy.
(2) Support merger. The set of newly identified components is united with the set of components that appear in the current
approximation.
(3) Estimation. The algorithm solves a least-squares problem to approximate the target signal on the merged set of compo-
nents.
(4) Pruning. The algorithm produces a new approximation by retaining only the largest entries in this least-squares signal
approximation.
(5) Sample update. Finally, the samples are updated so that they reflect the residual, the part of the signal that has not been
approximated.
These steps are repeated until the halting criterion is triggered. In the body of this work, we concentrate on methods that
use a fixed number of iterations. Appendix A discusses some other simple stopping rules that may also be useful in practice.
Pseudocode for CoSaMP appears as Algorithm 1. This code describes the version of the algorithm that we analyze in this
paper. Nevertheless, there are several adjustable parameters that may improve performance: the number of components
selected in the identification step and the number of components retained in the pruning step. Another variation appears
in Appendix A.
2.3. Performance guarantees
This section describes our theoretical analysis of the behavior of CoSaMP. The next section covers the resource require-
ments of the algorithm. Our results depend on a set of hypotheses that has become common in the compressive sampling
literature. Let us frame the standing assumptions:
COSAMP Hypotheses
• The sparsity level s is fixed.
• The m × N sampling operator Φ has restricted isometry constant δ4s  0.1.
• The signal x ∈ CN is arbitrary, except where noted.
306 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321• The noise vector e ∈ Cm is arbitrary.
• The vector of samples u = Φx + e.
We also define the unrecoverable energy ν in the signal. This quantity measures the baseline error in our approximation that
occurs because of noise in the samples or because the signal is not sparse.
ν = ‖x − xs‖2 + 1√
s
‖x − xs‖1 + ‖e‖2. (2.1)
We postpone a more detailed discussion of the unrecoverable energy until Section 2.5.
Our key result is that CoSaMP makes significant progress during each iteration where the approximation error is large
relative to the unrecoverable energy.
Theorem 2.1 (Iteration invariant). For each iteration k  0, the signal approximation ak is s-sparse and∥∥x − ak+1∥∥2  0.5∥∥x − ak∥∥2 + 10ν.
In particular,∥∥x − ak∥∥2  2−k‖x‖2 + 20ν.
The proof of Theorem 2.1 will occupy us for most of this paper. In Section 4, we establish an analog for sparse signals.
The version for general signals appears as a corollary in Section 6.
Theorem 2.1 has some immediate consequences for the quality of reconstruction with respect to standard signal metrics.
In this setting, a sensible definition of the signal-to-noise ratio (SNR) is
SNR = 10 log10
(‖x‖2
ν
)
.
The reconstruction SNR is defined as
R-SNR = 10 log10
( ‖x‖2
‖x − a‖2
)
.
Both quantities are measured in decibels. Theorem 2.1 implies that, after k iterations, the reconstruction SNR satisfies
R-SNR  min{3k,SNR − 13} − 3.
In words, each iteration increases the reconstruction SNR by about 3 decibels until the error nears the noise floor. To reduce
the error to its minimal value, the number of iterations is proportional to the SNR.
Let us consider a slightly different scenario. Suppose that the signal x is s-sparse, so the unrecoverable energy is ν = ‖e‖2.
Define the dynamic range
Δ = 10 log10
(
max|xi |
min|xi |
)
where i ranges over supp(x).
Algorithm 1. CoSaMP recovery algorithm
CoSaMP(Φ , u, s)
Input: Sampling matrix Φ , noisy sample vector u, sparsity level s
Output: An s-sparse approximation a of the target signal
a0 ← 0 {Trivial initial approximation}
v ← u {Current samples = input samples}
k ← 0
repeat
k ← k + 1
y ← Φ∗ v {Form signal proxy}
Ω ← supp(y2s) {Identify large components}
T ← Ω ∪ supp(ak−1) {Merge supports}
b|T ← Φ†T u {Signal estimation by least-squares}
b|T c ← 0
ak ← bs {Prune to obtain next approximation}
v ← u − Φak {Update current samples}
until halting criterion true
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 307Assume moreover that the minimum nonzero component of the signal is at least 40ν . Using the fact that ‖x‖2  √s‖x‖∞ ,
it is easy to check that ‖x − a‖2  min |xi | as soon as the number k of iterations satisfies
k  3.3Δ + log2 √s + 1.
It follows that the support of the approximation a must contain every entry in the support of the signal x.
This discussion suggests that the number of iterations might be substantial if we require a high reconstruction SNR
or if the signal has a very wide dynamic range. This initial impression is not entirely accurate. We have established that,
when the algorithm performs arithmetic to high enough precision, then a fixed number of iterations suffices to reduce the
approximation error to the same order as the unrecoverable energy. See [29] for details about these results.
Remark 2.2. In the hypotheses, a bound on the restricted isometry constant δ2s also suffices. Indeed, Corollary 3.4 of the
sequel implies that δ4s  0.1 holds whenever δ2s  0.025.
Remark 2.3. The expression (2.1) for the unrecoverable energy can be simplified using Lemma 7 from [22], which states
that, for every signal y ∈ CN and every positive integer t , we have
‖y − yt‖2 
1
2
√
t
‖y‖1.
Choosing y = x − xs/2 and t = s/2, we reach
ν  1.71√
s
‖x − xs/2‖1 + ‖e‖2. (2.2)
In words, the unrecoverable energy is controlled by the scaled 1 norm of the signal tail.
2.4. Implementation and resource requirements
CoSaMP was designed to be a practical method for signal recovery. An efficient implementation of the algorithm requires
some ideas from numerical linear algebra, as well as some basic techniques from the theory of algorithms. This section
discusses the key issues and develops an analysis of the running time for the two most common scenarios.
We focus on the least-squares problem in the estimation step because it is the major obstacle to a fast implementation of
the algorithm. The algorithm guarantees that the matrix ΦT never has more than 3s columns, so our assumption δ4s  0.1
implies that the matrix ΦT is extremely well conditioned. As a result, we can apply the pseudoinverse Φ
†
T = (Φ∗T ΦT )−1Φ∗T
very quickly using an iterative method, such as Richardson’s iteration [1, Section 7.2.3] or conjugate gradient [1, Section 7.4].
These techniques have the additional advantage that they only interact with the matrix ΦT through its action on vectors. It
follows that the algorithm performs better when the sampling matrix has a fast matrix–vector multiply.
Section 5 contains an analysis of the performance of iterative least-squares algorithms in the context of CoSaMP. In
summary, if we initialize the least-squares method with the current approximation ak−1, then the cost of solving the least-
squares problem is O(L ), where L bounds the cost of a matrix–vector multiply with ΦT or Φ∗T . This implementation
ensures that Theorem 2.1 holds at each iteration.
Let us stress that direct methods for least squares are likely to be extremely inefficient in this setting. The first reason
is that each least-squares problem may contain substantially different sets of columns from Φ . As a result, it becomes
necessary to perform a completely new QR or SVD factorization during each iteration at a cost of O(s2m). The second
problem is that computing these factorizations typically requires direct access to the columns of the matrix, which is
problematic when the matrix is accessed through its action on vectors. Third, direct methods have storage costs O(sm),
which may be deadly for large-scale problems.
The remaining steps of the algorithm involve standard techniques. Let us estimate the operation counts.
Proxy: Forming the proxy is dominated by the cost of the matrix–vector multiply Φ∗v .
Identification: We can locate the largest 2s entries of a vector in time O(N) using the approach in [8, Chapter 9]. In practice,
it may be faster to sort the entries of the signal in decreasing order of magnitude at cost O(N log N) and then select the first
2s of them. The latter procedure can be accomplished with quicksort, mergesort, or heapsort [8, Section II]. To implement
the algorithm to the letter, the sorting method needs to be stable because we stipulate that ties are broken lexicographically.
This point is not important in practice.
Support merger: We can merge two sets of size O(s) in expected time O(s) using randomized hashing methods [8, Chap-
ter 11]. One can also sort both sets first and use the elementary merge procedure [8, p. 29] for a total cost O(s log s).
LS estimation: We use Richardson’s iteration or conjugate gradient to compute Φ†T u. Initializing the least-squares algorithm
requires a matrix–vector multiply with Φ∗ . Each iteration of the least-squares method requires one matrix–vector multiplyT
308 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321Table 1
Operation count for CoSaMP. Big-O notation is omitted for legibility. The dimensions of the sampling matrix Φ
are m × N; the sparsity level is s. The number L bounds the cost of a matrix–vector multiply with Φ or Φ∗
Step Standard multiply Fast multiply
Form proxy mN L
Identification N N
Support merger s s
LS estimation sm L
Pruning s s
Sample update sm L
Total per iteration O(mN) O(L )
each with ΦT and Φ∗T . Since ΦT is a submatrix of Φ , the matrix–vector multiplies can also be obtained from multiplication
with the full matrix. We prove in Section 5 that a constant number of least-squares iterations suffices for Theorem 2.1 to
hold.
Pruning: This step is similar to identification. Pruning can be implemented in time O(s), but it may be preferable to sort
the components of the vector by magnitude and then select the first s at a cost of O(s log s).
Sample update: This step is dominated by the cost of the multiplication of Φ with the s-sparse vector ak .
Table 1 summarizes this discussion in two particular cases. The first column shows what happens when the sampling
matrix Φ is applied to vectors in the standard way, but we have random access to submatrices. The second column shows
what happens when the sampling matrix Φ and its adjoint Φ∗ both have a fast multiply with cost L , where we assume
that L  N . A typical value is L = O(N log N). In particular, a partial Fourier matrix satisfies this bound.
Finally, we note that the storage requirements of the algorithm are also favorable. Aside from the storage required by
the sampling matrix, the algorithm constructs only one vector of length N , the signal proxy. The sample vectors u and v
have length m, so they require O(m) storage. The signal approximations can be stored using sparse data structures, so they
require at most O(s log N) storage. Similarly, the index sets that appear require only O(s log N) storage. The total storage is
at worst O(N).
The following result summarizes this discussion.
Theorem 2.4 (Resource requirements). Each iteration of CoSaMP requires O(L ) time, where L bounds the cost of a multiplication
with the matrix Φ or Φ∗ . The algorithm uses storage O(N).
2.5. The unrecoverable energy
Since the unrecoverable energy ν plays a central role in our analysis of CoSaMP, it merits some additional discussion. In
particular, it is informative to examine the unrecoverable energy in a compressible signal. Let p be a number in the interval
(0,1). We say that x is p-compressible with magnitude R if the sorted components of the signal decay at the rate
|x|(i)  R · i−1/p for i = 1,2,3, . . . .
When p = 1, this definition implies that ‖x‖1  R · (1 + log N). Therefore, the unit ball of 1-compressible signals is similar
to the 1 unit ball. When p ≈ 0, this definition implies that p-compressible signals are very nearly sparse. In general,
p-compressible signals are well approximated by sparse signals:
‖x − xs‖1  Cp · R · s1−1/p,
‖x − xs‖2  Dp · R · s1/2−1/p,
where Cp = (1/p − 1)−1 and Dp = (2/p − 1)−1/2. These results follow by writing each norm as a sum and approximating
the sum with an integral. We see that the unrecoverable energy (2.1) in a p-compressible signal is bounded as
ν  2Cp · R · s1/2−1/p + ‖e‖2. (2.3)
When p is small, the first term in the unrecoverable energy decays rapidly as the sparsity level s increases. For the class of
p-compressible signals, the bound (2.3) on the unrecoverable energy is sharp, modulo the exact values of the constants.
With these inequalities, we can see that CoSaMP recovers compressible signals efficiently. Let us calculate the number
of iterations required to reduce the approximation error from ‖x‖2 to the optimal level (2.3). For compressible signals, the
energy ‖x‖2  2R , so
R-SNR  log
(
2R
1/2−1/p
)
= log(1/p − 1) + (1/p − 1/2) log s.2Cp · R · s
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 309Therefore, the number of iterations required to recover a generic p-compressible signal is O(log s), where the constant in
the big-O notation depends on p.
The term “unrecoverable energy” is justified by several facts. First, we must pay for the 2 error contaminating the
samples. To check this point, define S = supp(xs). The matrix Φ S is nearly an isometry from S2 to m2 , so an error in
the large components of the signal induces an error of equivalent size in the samples. Clearly, we can never resolve this
uncertainty.
The term s−1/2‖x − xs‖1 is also required on account of classical results about the Gel’fand widths of the N1 ball in N2 ,
due to Kashin [25] and Garnaev–Gluskin [16]. In the language of compressive sampling, their work has the following inter-
pretation. Let Φ be a fixed m × N sampling matrix. Suppose that, for every signal x ∈ CN , there is an algorithm that uses
the samples u = Φx to construct an approximation a that achieves the error bound
‖x − a‖2  C√
s
‖x‖1.
Then the number m of measurements must satisfy m  cs log(N/s).
3. Restricted isometry consequences
When the sampling matrix satisfies the restricted isometry inequalities (1.1), it has several other properties that we
require repeatedly in the proof that the CoSaMP algorithm is correct. Our first observation is a simple translation of (1.1)
into other terms.
Proposition 3.1. Suppose Φ has restricted isometry constant δr . Let T be a set of r indices or fewer. Then∥∥Φ∗T u∥∥2  √1 + δr‖u‖2,∥∥Φ†T u∥∥2  1√1 − δr ‖u‖2,∥∥Φ∗T ΦT x∥∥2  (1 ± δr)‖x‖2,∥∥(Φ∗T ΦT )−1x∥∥2  11 ± δr ‖x‖2,
where the last two statements contain an upper and lower bound, depending on the sign chosen.
Proof. The restricted isometry inequalities (1.1) imply that the singular values of ΦT lie between
√
1 − δr and √1 + δr . The
bounds follow from standard relationships between the singular values of ΦT and the singular values of basic functions
of ΦT . 
A second consequence is that disjoint sets of columns from the sampling matrix span nearly orthogonal subspaces. The
following result quantifies this observation.
Proposition 3.2 (Approximate orthogonality). Suppose Φ has restricted isometry constant δr . Let S and T be disjoint sets of indices
whose combined cardinality does not exceed r. Then∥∥Φ∗SΦT ∥∥  δr .
Proof. Abbreviate R = S ∪ T , and observe that Φ∗SΦT is a submatrix of Φ∗RΦR − I. The spectral norm of a submatrix never
exceeds the norm of the entire matrix. We discern that∥∥Φ∗SΦT ∥∥  ∥∥Φ∗RΦR − I∥∥  max{(1 + δr) − 1,1 − (1 − δr)} = δr
because the eigenvalues of Φ∗RΦR lie between 1 − δr and 1 + δr . 
This result will be applied through the following corollary.
Corollary 3.3. Suppose Φ has restricted isometry constant δr . Let T be a set of indices, and let x be a vector. Provided that r 
|T ∪ supp(x)|,∥∥Φ∗T Φ · x|T c ∥∥2  δr‖x|T c ‖2.
Proof. Define S = supp(x) \ T , so we have x|S = x|T c . Thus,∥∥Φ∗T Φ · x|T c ∥∥2 = ∥∥Φ∗T Φ · x|S∥∥2  ∥∥Φ∗T Φ S∥∥‖x|S‖2  δr‖x|T c ‖2,
owing to Proposition 3.2. 
310 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321As a second corollary, we show that δ2r gives weak control over the higher restricted isometry constants.
Corollary 3.4. Let c and r be positive integers. Then δcr  c · δ2r .
Proof. The result is clearly true for c = 1,2, so we assume c  3. Let S be an arbitrary index set of size cr, and let
M = Φ∗SΦ S − I. It suffices to check that ‖M‖  c · δ2r . To that end, we break the matrix M into r × r blocks, which we
denote M i j . A block version of Gershgorin’s theorem states that ‖M‖ satisfies at least one of the inequalities∣∣‖M‖ − ‖M ii‖∣∣  ∑
j =i
‖M i j‖, where i = 1,2, . . . , c.
The derivation is entirely analogous with the usual proof of Gershgorin’s theorem, so we omit the details. For each diag-
onal block, we have ‖M ii‖  δr because of the restricted isometry inequalities (1.1). For each off-diagonal block, we have
‖M i j‖  δ2r because of Proposition 3.2. Substitute these bounds into the block Gershgorin theorem and rearrange to com-
plete the proof. 
Finally, we present a result that measures how much the sampling matrix inflates nonsparse vectors. This bound permits
us to establish the major results for sparse signals and then transfer the conclusions to the general case.
Proposition 3.5 (Energy bound). Suppose that Φ verifies the upper inequality of (1.1), viz.
‖Φx‖2 
√
1 + δr‖x‖2 when ‖x‖0  r.
Then, for every signal x,
‖Φx‖2 
√
1 + δr
[
‖x‖2 + 1√
r
‖x‖1
]
.
Proof. First, observe that the hypothesis of the proposition can be regarded as a statement about the operator norm of Φ
as a map between two Banach spaces. For a set I ⊂ {1,2, . . . , N}, write B I2 for the unit ball in 2(I). Define the convex body
S = conv
{ ⋃
|I|r
B I2
}
⊂ CN ,
and notice that, by hypothesis, the operator norm
‖Φ‖S→2 = max
x∈S ‖Φx‖2 
√
1 + δr .
Define a second convex body
K =
{
x: ‖x‖2 + 1√
r
‖x‖1  1
}
⊂ CN ,
and consider the operator norm
‖Φ‖K→2 = max
x∈K ‖Φx‖2.
The content of the proposition is the claim that
‖Φ‖K→2  ‖Φ‖S→2.
To establish this point, it suffices to check that K ⊂ S .
Choose a vector x ∈ K . We partition the support of x into sets of size r. Let I0 index the r largest-magnitude components
of x, breaking ties lexicographically. Let I1 index the next largest r components, and so forth. Note that the final block I J
may have fewer than r components. We may assume that x|I j is nonzero for each j.
This partition induces a decomposition
x = x|I0 +
J∑
j=0
x|I j = λ0 y0 +
J∑
j=0
λ j y j
where
λ j = ‖x|I j ‖2 and y j = λ−1j x|I j .
By construction, each vector y j belongs to S because it is r-sparse and has unit 2 norm. We will prove that
∑
j λ j  1,
which implies that x can be written as a convex combination of vectors from the set S . As a consequence, x ∈ S . It emerges
that K ⊂ S .
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 311Fix j in the range {1,2, . . . , J }. It follows that I j contains at most r elements and I j−1 contains exactly r elements.
Therefore,
λ j = ‖x|I j ‖2 
√
r‖x|I j ‖∞ 
√
r · 1
r
‖x|I j−1‖1
where the last inequality holds because the magnitude of x on the set I j−1 dominates its largest entry in I j . Summing these
relations, we obtain
J∑
j=1
λ j 
1√
r
J∑
j=1
‖x|I j−1‖1 =
1√
r
‖x‖1.
It is clear that λ0 = ‖x|I0‖2  ‖x‖2. We may conclude that
J∑
j=0
λ j  ‖x‖2 + 1√
r
‖x‖1  1
because x ∈ K . 
4. The iteration invariant: Sparse case
We now commence the proof of Theorem 2.1. For the moment, let us assume that the signal is actually sparse. Section 6
removes this assumption.
The result states that each iteration of the algorithm reduces the approximation error by a constant factor, while adding
a small multiple of the noise. As a consequence, when the approximation error is large in comparison with the noise, the
algorithm makes substantial progress in identifying the unknown signal.
Theorem 4.1 (Iteration invariant: Sparse case). Assume that x is s-sparse. For each k  0, the signal approximation ak is s-sparse, and∥∥x − ak+1∥∥2  0.5∥∥x − ak∥∥2 + 7.5‖e‖2.
In particular,∥∥x − ak∥∥2  2−k‖x‖2 + 15‖e‖2.
The argument proceeds in a sequence of short lemmas, each corresponding to one step in the algorithm. Throughout
this section, we retain the assumption that x is s-sparse.
4.1. Approximations, residuals, etc.
Fix an iteration k  1. We write a = ak−1 for the signal approximation at the beginning of the iteration. Define the
residual r = x − a, which we interpret as the part of the signal we have not yet recovered. Since the approximation a is
always s-sparse, the residual r must be 2s-sparse. Notice that the vector v of updated samples can be viewed as noisy
samples of the residual:
v
def= u − Φa = Φ(x − a) + e = Φr + e.
4.2. Identification
The identification phase produces a set of components where the residual signal still has a lot of energy.
Lemma 4.2 (Identification). The set Ω = supp(y2s), where y = Φ∗v is the signal proxy, contains at most 2s indices, and
‖r|Ωc ‖2  0.2223‖r‖2 + 2.34‖e‖2.
Proof. The identification phase forms a proxy y = Φ∗ v for the residual signal. The algorithm then selects a set Ω of 2s
components from y that have the largest magnitudes. The goal of the proof is to show that the energy in the residual on
the set Ωc is small in comparison with the total energy in the residual.
Define the set R = supp(r). Since R contains at most 2s elements, our choice of Ω ensures that ‖y|R‖2  ‖y|Ω‖2. By
squaring this inequality and canceling the terms in R ∩ Ω , we discover that
‖y|R\Ω‖2  ‖y|Ω\R‖2.
Since the coordinate subsets here contain few elements, we can use the restricted isometry constants to provide bounds on
both sides.
312 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321First, observe that the set Ω \ R contains at most 2s elements. Therefore, we may apply Proposition 3.1 and Corollary 3.3
to obtain
‖y|Ω\R‖2 =
∥∥Φ∗Ω\R(Φr + e)∥∥2  ∥∥Φ∗Ω\RΦr∥∥2 + ∥∥Φ∗Ω\R e∥∥2  δ4s‖r‖2 + √1 + δ2s‖e‖2.
Likewise, the set R \ Ω contains 2s elements or fewer, so Proposition 3.1 and Corollary 3.3 yield
‖y|R\Ω‖2 =
∥∥Φ∗R\Ω(Φr + e)∥∥2  ∥∥Φ∗R\ΩΦ · r|R\Ω∥∥2 − ∥∥Φ∗R\ΩΦ · r|Ω∥∥2 − ∥∥Φ∗R\Ω e∥∥2
 (1 − δ2s)‖r|R\Ω‖2 − δ2s‖r‖2 −
√
1 + δ2s‖e‖2.
Since the residual is supported on R , we can rewrite r|R\Ω = r|Ωc . Finally, combine the last three inequalities and rearrange
to obtain
‖r|Ωc ‖2  (δ2s + δ4s)‖r‖2 + 2
√
1 + δ2s‖e‖2
1 − δ2s .
Invoke the numerical hypothesis that δ2s  δ4s  0.1 to complete the argument. 
4.3. Support merger
The next step of the algorithm merges the support of the current signal approximation a with the newly identified set
of components. The following result shows that components of the signal x outside this set have very little energy.
Lemma 4.3 (Support merger). Let Ω be a set of at most 2s indices. The set T = Ω ∪ supp(a) contains at most 3s indices, and
‖x|T c ‖2  ‖r|Ωc ‖2.
Proof. Since supp(a) ⊂ T , we find that
‖x|T c ‖2 =
∥∥(x − a)|T c ∥∥2 = ‖r|T c ‖2  ‖r|Ωc ‖2,
where the inequality follows from the containment T c ⊂ Ωc . 
4.4. Estimation
The estimation step of the algorithm solves a least-squares problem to obtain values for the coefficients in the set T . We
need a bound on the error of this approximation.
Lemma 4.4 (Estimation). Let T be a set of at most 3s indices, and define the least-squares signal estimate b by the formulae
b|T = Φ†T u and b|T c = 0,
where u = Φx + e. Then
‖x − b‖2  1.112‖x|T c ‖2 + 1.06‖e‖2.
This result assumes that we solve the least-squares problem in infinite precision. In practice, the right-hand side of the
bound contains an extra term owing to the error from the iterative least-squares solver. In Section 5, we study how many
iterations of the least-squares solver are required to make the least-squares error negligible in the present argument.
Proof. Note first that
‖x − b‖2  ‖x|T c ‖2 + ‖x|T − b|T ‖2.
Using the expression u = Φx + e and the fact Φ†T ΦT = IT , we calculate that
‖x|T − b|T ‖2 =
∥∥x|T − Φ†T (Φ · x|T + Φ · x|T c + e)∥∥2 = ∥∥Φ†T (Φ · x|T c + e)∥∥2  ∥∥(Φ∗T ΦT )−1Φ∗T Φ · x|T c ∥∥2 + ∥∥Φ†T e∥∥2.
The cardinality of T is at most 3s, and x is s-sparse, so Proposition 3.1 and Corollary 3.3 imply that
‖x|T − b|T ‖2  1
1 − δ3s
∥∥Φ∗T Φ · x|T c ∥∥2 + 1√1 − δ3s ‖e‖2 
δ4s
1 − δ3s ‖x|T
c ‖2 + ‖e‖2√
1 − δ3s .
Combine the bounds to reach
‖x − b‖2 
[
1 + δ4s
1 − δ3s
]
‖x|T c ‖2 + ‖e‖2√
1 − δ3s .
Finally, invoke the hypothesis that δ3s  δ4s  0.1. 
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 3134.5. Pruning
The final step of each iteration is to prune the intermediate approximation to its largest s terms. The following lemma
provides a bound on the error in the pruned approximation.
Lemma 4.5 (Pruning). The pruned approximation bs satisfies
‖x − bs‖2  2‖x − b‖2.
Proof. The intuition is that bs is close to b, which is close to x. Rigorously,
‖x − bs‖2  ‖x − b‖2 + ‖b − bs‖2  2‖x − b‖2.
The second inequality holds because bs is the best s-sparse approximation to b. In particular, the s-sparse vector x is a
worse approximation. 
4.6. Proof of Theorem 4.1
We now complete the proof of the iteration invariant for sparse signals, Theorem 4.1. At the end of an iteration, the
algorithm forms a new approximation ak = bs , which is evidently s-sparse. Applying the lemmas we have established, we
easily bound the error:∥∥x − ak∥∥2 = ‖x − bs‖2
 2‖x − b‖2 Pruning (Lemma 4.5)
 2 · (1.112‖x|T c ‖2 + 1.06‖e‖2) Estimation (Lemma 4.4)
 2.224‖r|Ωc ‖2 + 2.12‖e‖2 Support merger (Lemma 4.3)
 2.224 · (0.2223‖r‖2 + 2.34‖e‖2) + 2.12‖e‖2 Identification (Lemma 4.2)
< 0.5‖r‖2 + 7.5‖e‖2
= 0.5∥∥x − ak−1∥∥2 + 7.5‖e‖2.
To obtain the second bound in Theorem 4.1, simply solve the error recursion and note that
(1 + 0.5 + 0.25 + · · ·) · 7.5‖e‖2  15‖e‖2.
This point completes the argument.
5. Analysis of iterative least-squares
To develop an efficient implementation of CoSaMP, it is critical to use an iterative method when we solve the least-
squares problem in the estimation step. The two natural choices are Richardson’s iteration and conjugate gradient. The
efficacy of these methods rests on the assumption that the sampling operator has small restricted isometry constants.
Indeed, since the set T constructed in the support merger step contains at most 3s components, the hypothesis δ4s  0.1
ensures that the condition number
κ
(
Φ∗T ΦT
) = λmax(Φ∗T ΦT )
λmin(Φ
∗
T ΦT )
 1 + δ3s
1 − δ3s < 1.223.
This condition number is closely connected with the performance of Richardson’s iteration and conjugate gradient. In this
section, we show that Theorem 4.1 holds if we perform a constant number of iterations of either least-squares algorithm.
5.1. Richardson’s iteration
For completeness, let us explain how Richardson’s iteration can be applied to solve the least-squares problems that
arise in CoSaMP. Suppose we wish to compute A†u where A is a tall, full-rank matrix. Recalling the definition of the
pseudoinverse, we realize that this amounts to solving a linear system of the form
(A∗ A)b = A∗u.
This problem can be approached by splitting the Gram matrix:
A∗ A = I + M,
314 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321where M = A∗ A − I. Given an initial iterate z0, Richardon’s method produces the subsequent iterates via the formula
z+1 = A∗u − M z.
Evidently, this iteration requires only matrix–vector multiplies with A and A∗ . It is worth noting that Richardson’s method
can be accelerated [1, Section 7.2.5], but we omit the details.
It is quite easy to analyze Richardson’s iteration [1, Section 7.2.1]. Observe that∥∥z+1 − A†u∥∥2 = ∥∥M(z − A†u)∥∥2  ‖M‖∥∥z − A†u∥∥2.
This recursion delivers∥∥z − A†u∥∥2  ‖M‖∥∥z0 − A†u∥∥2 for  = 0,1,2, . . . .
In words, the iteration converges linearly.
In our setting, A = ΦT where T is a set of at most 3s indices. Therefore, the restricted isometry inequalities (1.1) imply
that
‖M‖ = ∥∥Φ∗T ΦT − I∥∥  δ3s.
We have assumed that δ3s  δ4s  0.1, which means that the iteration converges quite fast. Once again, the restricted
isometry behavior of the sampling matrix plays an essential role in the performance of the CoSaMP algorithm.
Conjugate gradient provides even better guarantees for solving the least-squares problem, but it is somewhat more
complicated to describe and rather more difficult to analyze. We refer the reader to [1, Section 7.4] for more information.
The following lemma summarizes the behavior of both Richardson’s iteration and conjugate gradient in our setting.
Lemma 5.1 (Error bound for LS). Richardson’s iteration produces a sequence {z} of iterates that satisfy∥∥z − Φ†T u∥∥2  0.1 · ∥∥z0 − Φ†T u∥∥2 for  = 0,1,2, . . . .
Conjugate gradient produces a sequence of iterates that satisfy∥∥z − Φ†T u∥∥2  2 · ρ · ∥∥z0 − Φ†T u∥∥2 for  = 0,1,2, . . . ,
where
ρ =
√
κ(Φ∗T ΦT ) − 1√
κ(Φ∗T ΦT ) + 1
 0.072.
5.2. Initialization
Iterative least-squares algorithms must be seeded with an initial iterate, and their performance depends heavily on a
wise selection thereof. CoSaMP offers a natural choice for the initializer: the current signal approximation. As the algo-
rithm progresses, the current signal approximation provides an increasingly good starting point for solving the least-squares
problem. The following shows that the error in the initial iterate is controlled by the current approximation error.
Lemma 5.2 (Initial iterate for LS). Let x be an s-sparse signal with noisy samples u = Φx + e. Let ak−1 be the signal approximation at
the end of the (k − 1)th iteration, and let T be the set of components identified by the support merger. Then∥∥ak−1 − Φ†T u∥∥2  2.112∥∥x − ak−1∥∥2 + 1.06‖e‖2.
Proof. By construction of T , the approximation ak−1 is supported inside T , so
‖x|T c ‖2 =
∥∥(x − ak−1)∣∣T c ∥∥2  ∥∥x − ak−1∥∥2.
Using Lemma 4.4, we may calculate how far ak−1 lies from the solution to the least-squares problem.∥∥ak−1 − Φ†T u∥∥2  ∥∥x − ak−1∥∥2 + ∥∥x − Φ†T u∥∥2  ∥∥x − ak−1∥∥2 + 1.112‖x|T c ‖2 + 1.06‖e‖2
 2.112
∥∥x − ak−1∥∥2 + 1.06‖e‖2. 
5.3. Iteration count
We need to determine how many iterations of the least-squares algorithm are required to ensure that the approximation
produced is sufficiently good to support the performance of CoSaMP.
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 315Corollary 5.3 (Estimation by iterative LS). Suppose that we initialize the LS algorithm with z0 = ak−1 . After at most three iterations,
both Richardson’s iteration and conjugate gradient produce a signal estimate b that satisfies
‖x − b‖2  1.112‖x|T c ‖2 + 0.0022
∥∥x − ak−1∥∥2 + 1.062‖e‖2.
Proof. Combine Lemmas 5.1 and 5.2 to see that three iterations of Richardson’s method yield∥∥z3 − Φ†T u∥∥2  0.002112∥∥x − ak−1∥∥2 + 0.00106‖e‖2.
The bound for conjugate gradient is slightly better. Let b|T = z3. According to the estimation result, Lemma 4.4, we have∥∥x − Φ†T u∥∥2  1.112‖x|T c ‖2 + 1.06‖e‖2.
An application of the triangle inequality completes the argument. 
5.4. CoSaMP with iterative least-squares
Finally, we need to check that the sparse iteration invariant, Theorem 4.1 still holds when we use an iterative least-
squares algorithm.
Theorem 5.4 (Sparse iteration invariant with iterative LS). Suppose that we use Richardson’s iteration or conjugate gradient for the
estimation step, initializing the LS algorithm with the current approximation ak−1 and performing three LS iterations. Then Theorem 4.1
still holds.
Proof. We repeat the calculation in Section 4.6 using Corollary 5.3 instead of the simple estimation lemma. To that end,
recall that the residual r = x − ak−1. Then
∥∥x − ak∥∥2  2‖x − b‖2
 2 · (1.112‖x|T c ‖2 + 0.0022‖r‖2 + 1.062‖e‖2)
 2.224‖r|Ωc ‖2 + 0.0044‖r‖2 + 2.124‖e‖2
 2.224 · (0.2223‖r‖2 + 2.34‖e‖2) + 0.0044‖r‖2 + 2.124‖e‖2
< 0.5‖r‖2 + 7.5‖e‖2
= 0.5∥∥x − ak−1∥∥2 + 7.5‖e‖2.
This bound is precisely what is required for the theorem to hold. 
6. Extension to general signals
In this section, we finally complete the proof of the main result for CoSaMP, Theorem 2.1. The remaining challenge is to
remove the hypothesis that the target signal is sparse, which we framed in Theorems 4.1 and 5.4. Although this difficulty
might seem large, the solution is simple and elegant. It turns out that we can view the noisy samples of a general signal as
samples of a sparse signal contaminated with a different noise vector that implicitly reflects the tail of the original signal.
Lemma 6.1 (Reduction to sparse case). Let x be an arbitrary vector in CN . The sample vector u = Φx + e can also be expressed as
u = Φxs + ẽ where
‖̃e‖2  1.05
[
‖x − xs‖2 + 1√
s
‖x − xs‖1
]
+ ‖e‖2.
Proof. Decompose x = xs + (x − xs) to obtain u = Φxs + ẽ where ẽ = Φ(x − xs) + e. To compute the size of the error term,
we simply apply the triangle inequality and Proposition 3.5:
‖̃e‖2 
√
1 + δs
[
‖x − xs‖2 + 1√
s
‖x − xs‖1
]
+ ‖e‖2.
Finally, invoke the fact that δs  δ4s  0.1 to obtain
√
1 + δs  1.05. 
This lemma is just the tool we require to complete the proof of Theorem 2.1.
316 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321Proof of Theorem 2.1. Let x be a general signal, and use Lemma 6.1 to write the noisy vector of samples u = Φxs + ẽ. Apply
the sparse iteration invariant, Theorem 4.1, or the analog for iterative least-squares, Theorem 5.4. We obtain∥∥xs − ak+1∥∥2  0.5∥∥xs − ak∥∥2 + 7.5‖̃e‖2.
Invoke the lower and upper triangle inequalities to obtain∥∥x − ak+1∥∥2  0.5∥∥x − ak∥∥2 + 7.5‖̃e‖2 + 1.5‖x − xs‖2.
Finally, recall the estimate for ‖̃e‖2 from Lemma 6.1, and simplify to reach∥∥x − ak+1∥∥2  0.5∥∥x − ak∥∥2 + 9.375‖x − xs‖2 + 7.875√s ‖x − xs‖1 + 7.5‖e‖2 < 0.5
∥∥x − ak∥∥2 + 10ν,
where ν is the unrecoverable energy (2.1). 
6.1. Proof of Theorem A
We have now collected all the material we need to establish the main result. Fix a precision parameter η. After at most
O(log(‖x‖2/η)) iterations, CoSaMP produces an s-sparse approximation a that satisfies
‖x − a‖2  C · (η + ν)
in consequence of Theorem 2.1. Apply inequality (2.2) to bound the unrecoverable energy ν in terms of the 1 norm. We
see that the approximation error satisfies
‖x − a‖2  C · max
{
η,
1√
s
‖x − xs/2‖1 + ‖e‖2
}
.
According to Theorem 2.4, each iteration of CoSaMP is completed in time O(L ), where L bounds the cost of a matrix–
vector multiplication with Φ or Φ∗ . The total runtime, therefore, is O(L log(‖x‖2/η)). The total storage is O(N).
Finally, in the statement of the theorem, we replace δ4s with δ2s by means of Corollary 3.4, which states that δcr  c · δ2r
for any positive integers c and r.
7. Discussion and related work
CoSaMP draws on both algorithmic ideas and analytic techniques that have appeared before. This section describes the
other major signal recovery algorithms, and it compares them with CoSaMP. It also attempts to trace the key ideas in the
algorithm back to their sources.
7.1. Algorithms for compressive sampling
We begin with a short discussion of the major algorithmic approaches to signal recovery from compressive samples.
We focus on provably correct methods, although we acknowledge that some ad hoc techniques provide excellent empirical
results.
The initial discovery works on compressive sampling proposed to perform signal recovery by solving a convex optimiza-
tion problem [3,12]. Given a sampling matrix Φ and a noisy vector of samples u = Φx + e with ‖e‖2  ε, consider the
mathematical program
min ‖y‖1 subject to ‖Φ y − u‖2  ε. (7.1)
In words, we look for a signal reconstruction that is consistent with the samples but has minimal 1 norm. The intuition
behind this approach is that minimizing the 1 norm promotes sparsity, so allows the approximate recovery of compressible
signals. Candès, Romberg, and Tao established in [4] that a minimizer a of (7.1) satisfies
‖x − a‖2  C
[
1√
s
‖x − xs‖1 + ε
]
(7.2)
provided that the sampling matrix Φ has restricted isometry constant δ4s  0.2. In [2], the hypothesis on the restricted
isometry constant is sharpened to δ2s 
√
2 − 1. The error bound for CoSaMP is equivalent, modulo the exact value of the
constants.
The literature describes a huge variety of algorithms for solving the optimization problem (7.1). The most common ap-
proaches involve interior-point methods [3,26], projected gradient methods [15], or iterative thresholding [11]. The interior-
point methods are guaranteed to solve the problem to a fixed precision in time O(m2N1.5), where m is the number of
measurements and N is the signal length [32]. Note that the constant in the big-O notation depends on some of the problem
data. The other convex relaxation algorithms, while sometimes faster in practice, do not currently offer rigorous guarantees.
CoSaMP provides rigorous bounds on the runtime that are much better than the available results for interior-point methods.
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 317Tropp and Gilbert proposed the use of a greedy iterative algorithm called orthogonal matching pursuit (OMP) for signal
recovery [39]. The algorithm initializes the current sample vector v = u. In each iteration, it forms the signal proxy y = Φ∗v
and identifies a component of the proxy with largest magnitude. It adds the new component to the set T of previously
identified components. Then OMP forms a new signal approximation by solving a least-squares problem: a = Φ†T u. Finally,
it updates the samples v = u − Φa. These steps are repeated until a halting criterion is satisfied.
Tropp and Gilbert were able to prove a weak result for the performance of OMP [39]. Suppose that x is a fixed, s-sparse
signal, and let m = Cs log N . Draw an m × N sampling matrix Φ whose entries are independent, zero-mean subgaussian2
random variables with equal variances. Given noiseless measurements u = Φx, OMP reconstructs x after s iterations, except
with probability N−1. In this setting, OMP must fail for some sparse signals [33], so it does not provide the same uniform
guarantees as convex relaxation. It is unknown whether OMP succeeds for compressible signals or whether it succeeds
when the samples are contaminated with noise.
Donoho et al. invented another greedy iterative method called stagewise OMP, or StOMP [14]. This algorithm uses the
signal proxy to select multiple components at each step, using a rule inspired by ideas from wireless communications.
The algorithm is faster than OMP because of the selection rule, and it sometimes provides good performance, although
parameter tuning can be difficult. There are no rigorous results available for StOMP.
Very recently, Needell and Vershynin developed and analyzed another greedy approach, called regularized OMP, or ROMP
[30,31]. This algorithm is similar to OMP but uses a more sophisticated selection rule. Among the s largest entries of the
signal proxy, it identifies the largest subset whose entries differ in magnitude by at most a factor of two. The work on
ROMP represents an advance because the authors establish under restricted isometry hypotheses that their algorithm can
approximately recover any compressible signal from noisy samples. More precisely, suppose that the sampling matrix Φ
has restricted isometry constant δ8s  0.01/
√
log s. Given noisy samples u = Φx + e, ROMP produces a 2s-sparse signal
approximation a that satisfies
‖x − a‖2  C
√
log s
[
1√
s
‖x − xs‖1 + ‖e‖2
]
.
This result is comparable with the result for convex relaxation, aside from the extra logarithmic factor in the restricted
isometry hypothesis and the error bound. The results for CoSaMP show that it does not suffer these parasitic factors, so its
performance is essentially optimal.
After we initially presented this work, Dai and Milenkovic developed an algorithm called Subspace Pursuit that is very
similar to CoSaMP. They established that their algorithm offers performance guarantees analogous with those for CoSaMP.
See [10] for details.
Finally, we note that there is a class of sublinear algorithms for signal reconstruction from compressive samples. A sub-
linear algorithm uses time and space resources that are asymptotically smaller than the length of the signal. One of the
earliest such techniques is the Fourier sampling algorithm of Gilbert et al. [18,20]. This algorithm uses random (but struc-
tured) time samples to recover signals that are compressible with respect to the discrete Fourier basis. Given s polylog(N)
samples,3 Fourier sampling produces a signal approximation a that satisfies
‖x − a‖2  C‖x − xs‖2
except with probability N−1. The result for Fourier sampling holds for each signal (rather than for all). Later, Gilbert et
al. developed two other sublinear algorithms, chaining pursuit [21] and HHS pursuit [22], that offer uniform guarantees for
all signals. Chaining pursuit has an error bound
‖x − a‖1  C log N‖x − xs‖1
which is somewhat worse than (7.2). HHS pursuit achieves the error bound (7.2). These methods all require more mea-
surements than the linear and superlinear algorithms (by logarithmic factors), and these measurements must be highly
structured. As a result, the sublinear algorithms may not be useful in practice.
The sublinear algorithms are all combinatorial in nature. They use ideas from group testing to identify the support of
the signal quickly. There are several other combinatorial signal recovery methods due to Cormode–Muthukrishnan [9] and
Iwen [24]. These algorithms have drawbacks similar to the sublinear approaches.
7.2. Relative performance
Table 2 summarizes the relative behavior of these algorithms in terms of the following criteria.
General samples: Does the algorithm work for a variety of sampling schemes? Or does it require structured samples? The
designation “RIP” means that a bound on a restricted isometry constant suffices. “Subgauss.” means that the algorithm
succeeds for the class of subgaussian sampling matrices.
2 A subgaussian random variable Z satisfies P{|Z | > t}  ce−ct2 for all t > 0.
3 The term polylog indicates a function that is dominated by a polynomial in the logarithm of its argument.
318 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321Table 2
Comparison of several signal recovery algorithms
CoSaMP OMP ROMP Convex opt. Fourier sampl. HHS pursuit
General samples RIP Subgauss. RIP RIP no no
Opt. # samples yes yes no yes no no
Uniformity yes no yes yes no yes
Stability yes ? yes yes yes yes
Running time O(mN) O(smN) O(smN) LP(N , m) s polylog(N) poly(s log N)
Notes. The notation s refers to the sparsity level; m refers the number of measurements; N refers to the signal length. See the text for comments on specific
designations.
Optimal number of samples: Can the algorithm recover s sparse signals from O(s log N) measurements? Or are its sampling
requirements higher (by logarithmic factors)?
Uniformity: Does the algorithm recover all signals given a fixed sampling matrix? Or do the results require a sampling
matrix to be drawn at random for each signal?
Stability: Does the algorithm succeed when (a) the signal is compressible but not sparse and (b) when the samples are
contaminated with noise? In most cases, stable algorithms have error bounds similar to (7.2). See the discussion above for
details.
Running time: What is the worst-case cost of the algorithm to recover a real-valued s-sparse signal to a fixed relative
precision, given a sampling matrix with no special structure? The designation LP(N , m) indicates the cost of solving a
linear program with N variables and m constraints, which is O(m2N1.5) for an interior-point method. Note that most of the
algorithms can also take advantage of fast matrix–vector multiplies to obtain better running times.
Of the linear and superlinear algorithms, CoSaMP achieves the best performance on all these metrics. Although CoSaMP
is slower than the sublinear algorithms, it makes up for this shortcoming by allowing more general sampling matrices and
requiring fewer samples. See [23] for a much more detailed comparison of compressive sampling recovery algorithms.
7.3. Key ideas
We conclude with a historical overview of the ideas that inform the CoSaMP algorithm and its analysis.
The overall greedy iterative structure of CoSaMP has a long history. The idea of approaching sparse approximation
problems in this manner dates to the earliest algorithms. In particular, methods for variable selection in regression, such as
forward selection and its relatives, all take this form [28]. Temlyakov’s survey [36] describes the historical role of greedy
algorithms in nonlinear approximation. Mallat and Zhang introduced greedy algorithms into the signal processing literature
and proposed the name matching pursuit [27]. Gilbert, Strauss, and their collaborators showed how to incorporate greedy
iterative strategies into fast algorithms for sparse approximation problems, and they established the first rigorous guarantees
for greedy methods [17,18]. Tropp provided a new theoretical analysis of OMP in his work [38]. Subsequently, Tropp and
Gilbert proved that OMP was effective for compressive sampling [39].
Unlike the simplest greedy algorithms, CoSaMP identifies many components during each iteration, which allows the
algorithm to run faster for many types of signals. It is not entirely clear where this idea first appeared. Several early
algorithms of Gilbert et al. incorporate this approach [19,40], and it is an essential feature of the Fourier sampling algorithm
[18,20]. More recent compressive sampling recovery algorithms also select multiple indices, including chaining pursuit [21],
HHS pursuit [22], StOMP [14], and ROMP [31].
CoSaMP uses the restricted isometry properties of the sampling matrix to ensure that the identification step is success-
ful. Candès and Tao isolated the restricted isometry conditions in their work on convex relaxation methods for compressive
sampling [5]. The observation that restricted isometries can also be used to ensure the success of greedy methods is rela-
tively new. This idea plays a role in HHS pursuit [22], but it is expressed more completely in the analysis of ROMP [31].
The pruning step of CoSaMP is essential to maintain the sparsity of the approximation, which is what permits us to use
restricted isometries in the analysis of the algorithm. It also has significant ramifications for the running time because it
impacts the speed of the iterative least-squares algorithms. This technique originally appeared in HHS pursuit [22].
The iteration invariant, Theorem 2.1, states that if the error is large then CoSaMP makes substantial progress. This
approach to the overall analysis echoes the analysis of other greedy iterative algorithms, including the Fourier sampling
method [18,20] and HHS pursuit [22].
Finally, mixed-norm error bounds, such as that in Theorem A, have become an important feature of the compressive
sampling literature. This idea appears in the work of Candès–Romberg–Tao on convex relaxation [4]; it is used in the
analysis of HHS pursuit [22]; it also plays a role in the theoretical treatment of Cohen–Dahmen–DeVore [7].
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 319Acknowledgments
We would like to thank Martin Strauss for many inspiring discussions. He is ultimately responsible for many of the ideas
in the algorithm and analysis. We would also like to thank Roman Vershynin for suggestions that drastically simplified the
proofs.
Appendix A. Algorithmic variations
This appendix describes other possible halting criteria and their consequences. It also proposes some other variations on
the algorithm.
A.1. Halting rules
There are three natural approaches to halting the algorithm. The first, which we have discussed in the body of the paper,
is to stop after a fixed number of iterations. Another possibility is to use the norm ‖v‖2 of the current samples as evidence
about the norm ‖r‖2 of the residual. A third possibility is to use the magnitude ‖y‖∞ of the entries of the proxy to bound
the magnitude ‖r‖∞ of the entries of the residual.
It suffices to discuss halting criteria for sparse signals because Lemma 6.1 shows that the general case can be viewed
in terms of sampling a sparse signal. Let x be an s-sparse signal, and let a be an s-sparse approximation. The residual
r = x − a. We write v = Φr + e for the induced noisy samples of the residual and y = Φ∗v for the signal proxy.
The discussion proceeds in two steps. First, we argue that an a priori halting criterion will result in a guarantee about
the quality of the final signal approximation.
Theorem A.1 (Halting I). The halting criterion ‖v‖2  ε ensures that
‖x − a‖2  1.06 ·
(
ε + ‖e‖2
)
.
The halting criterion ‖y‖∞  η/
√
2s ensures that
‖x − a‖∞  1.12η + 1.17‖e‖2.
Proof. Since r is 2s-sparse, Proposition 3.1 ensures that√
1 − δ2s ‖r‖2 − ‖e‖2  ‖v‖2.
If ‖v‖2  ε, it is immediate that
‖r‖2  ε + ‖e‖2√
1 − δ2s .
The definition r = x − a and the numerical bound δ2s  δ4s  0.1 dispatch the first claim.
Let R = supp(r), and note that |R|  2s. Proposition 3.1 results in
(1 − δ2s)‖r‖2 −
√
1 + δ2s‖e‖2  ‖y|R‖2.
Since
‖y|R‖2 
√
2s‖y|R‖∞ 
√
2s‖y‖∞,
we find that the requirement ‖y‖∞  η/
√
2s ensures that
‖r‖∞  η +
√
1 + δ2s‖e‖2
1 − δ2s .
The numerical bound δ2s  0.1 completes the proof. 
Second, we check that each halting criterion is triggered when the residual has the desired property.
Theorem A.2 (Halting II). The halting criterion ‖v‖2  ε is triggered as soon as
‖x − a‖2  0.95 ·
(
ε − ‖e‖2
)
.
The halting criterion ‖y‖∞  η/
√
2s is triggered as soon as
‖x − a‖∞  0.45η
s
− 0.68‖e‖2√
s
.
320 D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321Proof. Proposition 3.1 shows that
‖v‖2 
√
1 + δ2s‖r‖2 + ‖e‖2.
Therefore, the condition
‖r‖2  ε − ‖e‖2√
1 + δ2s
ensures that ‖v‖2  ε. Note that δ2s  0.1 to complete the first part of the argument.
Now let R be the singleton containing the index of a largest-magnitude coefficient of y. Proposition 3.1 implies that
‖y‖∞ = ‖y|R‖2 
√
1 + δ1‖v‖2.
By the first part of this theorem, the halting criterion ‖y‖∞  η/
√
2s is triggered as soon as
‖x − a‖2  0.95 ·
(
η√
2s
√
1 + δ1
− ‖e‖2
)
.
Since x − a is 2s-sparse, we have the bound ‖x − a‖2 
√
2s‖x − a‖∞ . To wrap up, recall that δ1  δ2s  0.1. 
A.2. Other variations
Here is a version of the algorithm that is, perhaps, simpler than Algorithm 1. At each iteration, we approximate the
current residual rather than the entire signal. This approach is similar to HHS pursuit [22]. The inner loop changes in the
following manner.
Identification: As before, select Ω = supp(y2s).
Estimation: Solve a least-squares problem with the current samples instead of the original samples to obtain an approxima-
tion of the residual signal. Formally, b = Φ†Ω v . In this case, one initializes the iterative least-squares algorithm with the zero
vector to take advantage of the fact that the residual is becoming small.
Approximation merger: Add this approximation of the residual to the previous approximation of the signal to obtain a new
approximation of the signal: c = ak−1 + b.
Pruning: Construct the s-sparse signal approximation: ak = cs .
Sample update: Update the samples as before: v = u − Φak .
By adapting the argument in this paper, we have been able to show that this algorithm also satisfies Theorem A. We
believe this version is quite promising for applications. See [29] for other variations.
References
[1] Å. Björck, Numerical Methods for Least Squares Problems, SIAM, Philadelphia, 1996.
[2] E.J. Candès, The restricted isometry property and its implications for compressed sensing, C. R. Math. Acad. Sci. Paris, Ser. I 346 (2008) 589–592.
[3] E. Candès, J. Romberg, T. Tao, Robust uncertainty principles: Exact signal reconstruction from highly incomplete Fourier information, IEEE Trans. Inform.
Theory 52 (2) (2006) 489–509.
[4] E. Candès, J. Romberg, T. Tao, Stable signal recovery from incomplete and inaccurate measurements, Comm. Pure Appl. Math. 59 (8) (2006) 1207–1223.
[5] E.J. Candès, T. Tao, Decoding by linear programming, IEEE Trans. Inform. Theory 51 (12) (2005) 4203–4215.
[6] E.J. Candès, T. Tao, Near optimal signal recovery from random projections: Universal encoding strategies? IEEE Trans. Inform. Theory 52 (12) (2006)
5406–5425.
[7] A. Cohen, W. Dahmen, R. DeVore, Compressed sensing and best k-term approximation, IGPM Report, RWTH-Aachen, July 2006.
[8] T. Cormen, C. Lesierson, L. Rivest, C. Stein, Introduction to Algorithms, second ed., MIT Press, Cambridge, MA, 2001.
[9] G. Cormode, S. Muthukrishnan, Combinatorial algorithms for compressed sensing, Technical report, DIMACS, 2005.
[10] W. Dai, O. Milenkovic, Subspace pursuit for compressive sensing: Closing the gap between performance and complexity, available at:
http://www.dsp.ece.rice.edu/cs/SubspacePursuit.pdf (preprint).
[11] I. Daubechies, M. Defrise, C.D. Mol, An iterative thresholding algorithm for linear inverse problems with a sparsity constraint, Comm. Pure Appl.
Math. 57 (2004) 1413–1457.
[12] D.L. Donoho, Compressed sensing, IEEE Trans. Inform. Theory 52 (4) (2006) 1289–1306.
[13] D.L. Donoho, J. Tanner, Counting faces of randomly projected polytopes when the projection radically lowers dimension, Department of Statistics
Technical Report 2006-11, Stanford University, 2006.
[14] D.L. Donoho, Y. Tsaig, I. Drori, J.-L. Starck, Sparse solution of underdetermined linear equations by stagewise orthogonal matching pursuit (StOMP),
submitted for publication.
[15] M.A.T. Figueiredo, R.D. Nowak, S.J. Wright, Gradient projection for sparse reconstruction: Application to compressed sensing and other inverse problems,
IEEE J. Select. Top. Signal Process.: Special Issue on Convex Optimization Methods for Signal Processing 1 (4) (2007) 586–598.
D. Needell, J.A. Tropp / Appl. Comput. Harmon. Anal. 26 (2009) 301–321 321[16] A. Garnaev, E. Gluskin, On widths of the Euclidean ball, Sov. Math. Dokl. 30 (1984) 200–204.
[17] A.C. Gilbert, S. Guha, P. Indyk, Y. Kotidis, S. Muthukrishnan, M.J. Strauss, Fast, small-space algorithms for approximate histogram maintenance, in: ACM
Symposium on Theoretical Computer Science, 2002.
[18] A.C. Gilbert, S. Guha, P. Indyk, S. Muthukrishnan, M.J. Strauss, Near-optimal sparse Fourier representations via sampling, in: Proceedings of the 2002
ACM Symposium on Theory of Computing STOC, 2002.
[19] A.C. Gilbert, M. Muthukrishnan, M.J. Strauss, Approximation of functions over redundant dictionaries using coherence, in: Proceedings of the 14th
Annual ACM-SIAM Symposium on Discrete Algorithms, 2003.
[20] A.C. Gilbert, S. Muthukrishnan, M.J. Strauss, Improved time bounds for near-optimal sparse Fourier representation via sampling, in: Proceedings of SPIE
Wavelets XI, San Diego, CA, 2005.
[21] A. Gilbert, M. Strauss, J. Tropp, R. Vershynin, Algorithmic linear dimension reduction in the 1 norm for sparse vectors, submitted for publication.
[22] A. Gilbert, M. Strauss, J. Tropp, R. Vershynin, One sketch for all: Fast algorithms for compressed sensing, in: Proceedings of the 39th ACM Symp. Theory
of Computing, San Diego, 2007.
[23] P. Indyk, R. Berinde, Sparse recovery using sparse matrices, CSAIL technical report, Massachusetts Institute of Technology, 2008.
[24] M. Iwen, A deterministic sub-linear time sparse Fourier algorithm via non-adaptive compressed sensing methods, in: Proc. ACM-SIAM Symposium on
Discrete Algorithms (SODA), 2008.
[25] B. Kashin, The widths of certain finite dimensional sets and classes of smooth functions, Izvestia 41 (1977) 334–351.
[26] S.-J. Kim, K. Koh, M. Lustig, S. Boyd, D. Gorinevsky, A method for l1-regularized least squares, IEEE J. Select. Top. Signal Process. 1 (4) (2007) 606–617.
[27] S. Mallat, Z. Zhang, Matching pursuits with time–frequency dictionaries, IEEE Trans. Signal Process. 41 (12) (1993) 3397–3415.
[28] A.J. Miller, Subset Selection in Regression, second ed., Chapman and Hall, London, 2002.
[29] D. Needell, J.A. Tropp, CoSaMP: Iterative signal recovery from incomplete and inaccurate samples, ACM Technical Report 2008-01, California Institute
of Technology, Pasadena, 2008.
[30] D. Needell, R. Vershynin, Signal recovery from incomplete and inaccurate measurements via regularized orthogonal matching pursuit, submitted for
publication.
[31] D. Needell, R. Vershynin, Uniform uncertainty principle and signal recovery via regularized orthogonal matching pursuit, Found. Comput. Math. (2008),
in press.
[32] Y.E. Nesterov, A.S. Nemirovski, Interior Point Polynomial Algorithms in Convex Programming, SIAM, Philadelphia, 1994.
[33] H. Rauhut, On the impossibility of uniform sparse reconstruction using greedy methods, Sampl. Theory Signal Image Process. (2008),
doi:10.1007/s10208-008-9031-3, in press.
[34] G. Reeves, M. Gastpar, Sampling bounds for sparse support recovery in the presence of noise, in: Proceedings of the IEEE International Symposium on
Information Theory (ISIT 2008), Toronto, Canada, July 2008.
[35] M. Rudelson, R. Vershynin, Sparse reconstruction by convex relaxation: Fourier and Gaussian measurements, in: Proceedings of the 40th Annual
Conference on Information Sciences and Systems, Princeton, 2006.
[36] V. Temlyakov, Nonlinear methods of approximation, Found. Comput. Math. 3 (1) (2003) 33–107.
[37] J.A. Tropp, Beyond Nyquist: Efficient sampling of sparse, bandlimited signals, presented at SampTA, June 2007; available at: http://www.acm.
caltech.edu/~jtropp/slides/Tro07-Beyond-Nyquist-Talk-long.pdf.
[38] J.A. Tropp, Greed is good: Algorithmic results for sparse approximation, IEEE Trans. Inform. Theory 50 (10) (2004) 2231–2242.
[39] J.A. Tropp, A.C. Gilbert, Signal recovery from random measurements via orthogonal matching pursuit, IEEE Trans. Inform. Theory 53 (12) (2007) 4655–
4666.
[40] J.A. Tropp, A.C. Gilbert, S. Muthukrishnan, M.J. Strauss, Improved sparse approximation over quasi-incoherent dictionaries, in: Proc. 2003 IEEE Interna-
tional Conference on Image Processing, Barcelona, 2003.

