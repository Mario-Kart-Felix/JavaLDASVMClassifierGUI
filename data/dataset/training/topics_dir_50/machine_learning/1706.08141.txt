ar
X
iv
:1
70
6.
08
14
1v
1 
 [
st
at
.M
L
] 
 2
5 
Ju
n 
20
17
Proceedings of Machine Learning Research vol 65:1–33, 2017
A Unified Analysis of Stochastic Optimization Methods Using
Jump System Theory and Quadratic Constraints
Bin Hu BHU38@WISC.EDU
Wisconsin Institute for Discovery, University of Wisconsin, Madison, USA
Peter Seiler SEILE017@UMN.EDU
Department of Aerospace Engineering and Mechanics, University of Minnesota, Minneapolis, USA
Anders Rantzer RANTZER@CONTROL.LTH.SE
Department of Automatic Control, Lund University, Lund, Sweden
Abstract
We develop a simple routine unifying the analysis of several important recently-developed stochas-
tic optimization methods including SAGA, Finito, and stochastic dual coordinate ascent (SDCA).
First, we show an intrinsic connection between stochastic optimization methods and dynamic jump
systems, and propose a general jump system model for stochastic optimization methods. Our pro-
posed model recovers SAGA, SDCA, Finito, and SAG as special cases. Then we combine jump
system theory with several simple quadratic inequalities to derive sufficient conditions for conver-
gence rate certifications of the proposed jump system model under various assumptions (with or
without individual convexity, etc). The derived conditions are linear matrix inequalities (LMIs)
whose sizes roughly scale with the size of the training set. We make use of the symmetry in the
stochastic optimization methods and reduce these LMIs to some equivalent small LMIs whose sizes
are at most 3× 3. We solve these small LMIs to provide analytical proofs of new convergence rates
for SAGA, Finito and SDCA (with or without individual convexity). We also explain why our pro-
posed LMI fails in analyzing SAG. We reveal a key difference between SAG and other methods,
and briefly discuss how to extend our LMI analysis for SAG. An advantage of our approach is
that the proposed analysis can be automated for a large class of stochastic methods under various
assumptions (with or without individual convexity, etc).
Keywords: Empirical risk minimization, SAGA, Finito, SDCA, SAG, semidefinite programming,
jump systems, quadratic constraints, control theory
1. Introduction
Convergence proofs for optimization methods are typically derived in a case-by-case manner. It
is an important task to develop more unifying analysis which can be automatically generalized for
complicated algorithms. The aim of this paper is to develop a unified analysis routine for a class of
recently-developed stochastic optimization methods used in empirical risk minimization. Consider
the following finite sum minimization
minimize
x∈Rp
g(x) :=
1
n
n
∑
i=1
fi(x) (1)
where g : Rp → R is the objective function. The framework of (1) is useful for empirical risk
minimization problems, e.g. ℓ2-regularized logistic regression problems (Teo et al., 2007).
c© 2017 B. Hu, P. Seiler & A. Rantzer.
HU SEILER RANTZER
A widely-used approach for solving (1) is the stochastic gradient (SG) method (Robbins and
Monro, 1951; Bottou and LeCun, 2003). However, the SG method only linearly converges to some
tolerance of the optimum of (1) given a well-chosen constant stepsize. If a diminishing stepsize is
used, the SG method will converge to the optimum but at a sublinear rate.
More recently, a class of new stochastic optimization methods have been proposed based on
the idea of gradient aggregation. These methods converge linearly to the optimum point while
preserving the iteration cost of the SG method. This family of gradient aggregation methods include
SAG (Roux et al., 2012; Schmidt et al., 2013), SAGA (Defazio et al., 2014a), Finito (Defazio et al.,
2014b), SDCA (Shalev-Shwartz and Zhang, 2013; Shalev-Shwartz, 2016) and SVRG (Johnson and
Zhang, 2013). Existing linear rate bounds of SAG, SAGA, Finito, SDCA and SVRG are derived in
a case-by-case manner. Moreover, the existing rate results for SAG, SAGA and Finito require the
individual convexity of fi. It is beneficial to develop a unified analysis framework which can be
used to justify the existing rate results and obtain new rate bounds under various conditions (with or
without individual convexity, etc).
Recently, semidefinite programs have been used to certify the performance of deterministic opti-
mization methods (Drori and Teboulle, 2014; Kim and Fessler, 2016; Lessard et al., 2016; Nishihara
et al., 2015; Taylor et al., 2017). Specifically, Lessard et al. (2016) provides a general analysis for
deterministic first-order optimization methods (full gradient method, Nesterov’s method, heavy ball
method, etc) by adapting the integral quadratic constraint (IQC) framework (Megretski and Rantzer,
1997) from control theory. The key insight there is that the deterministic first-order methods can be
viewed as interconnections of a linear time-invariant (LTI) dynamic system and a nonlinearity. Then
quadratic inequalities can be used to characterize the nonlinearity and formulate LMI conditions.
In this paper, we present a unified analysis framework for a large class of stochastic optimization
methods including SAGA, Finito and SDCA. Our approach here is inspired by the work of Lessard
et al. (2016), and can be viewed as its stochastic extension. In our paper, the key insight is that many
stochastic first-order methods can be viewed as an interconnection of a linear jump system and a
static nonlinearity. Notice that a linear jump system is described by a linear state space model whose
state matrices are functions of a jump parameter sampled from a given distribution. Since Lyapunov
theory for jump systems has been well established in the controls field, we can incorporate quadratic
constraints to obtain semidefinite programs for linear rate analysis of these stochastic optimization
methods. Our main contributions are summarized as follows.
1. We present a unified jump system perspective on SAG, SAGA, Finito and SDCA. Specifically,
we propose a general jump system model which governs the dynamics of a large family of
stochastic methods including SAG, SAGA, Finito and SDCA.
2. We present a unified (and in some sense even automated) analysis framework for SAGA,
Finito and SDCA using jump system perspectives and quadratic constraints. LMI conditions
for a large class of stochastic methods under various conditions (with or without individual
convexity, etc) are derived using one technique, and then solved to provide rate certificates.
3. We analytically solve the resultant LMIs to prove linear rate bounds for SAGA, Finito, and
SDCA under different assumptions on g and fi. Our results provide alternative proofs for
many existing rate bounds. In addition, we prove that SAGA without individual convex-
ity achieves an ǫ-optimal iteration complexity Õ
(
( L
2
m2
+ n) log(1
ǫ
)
)
. We also prove Finito
without individual convexity achieves an ǫ-optimal complexity of Õ
(
n log(1
ǫ
)
)
if n ≥ 48L2
m2
.
2
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
4. Our quadratic constraint approach reveals a key difference between SAG and other methods.
Specifically, SAGA, SDCA, and Finito only require simple quadratic inequalities used in this
paper while SAG further requires more advanced quadratic inequalities to decode convexity.
For this reason, the analysis of SAG is more involved, and our proposed LMI fails in analyzing
SAG. We briefly sketch how to extend our LMI analysis for SAG. The extension requires
incorporating more advanced quadratic inequalities into the LMI formulations.
The main advantage of our framework is its flexibility. The existing analysis for SAG, SAGA,
Finito and SDCA is derived in a case-by-case manner. Our jump system framework provides a uni-
fied routine for analysis of such methods. Our analysis is highly repeatable and even “automated” in
the sense that all LMI conditions are formulated using one technique and can be numerically solved
to guide our analytical rate proof constructions. We emphasize that we view our LMI-based method
as a complement rather than a replacement for existing proof techniques. One can always solve
our proposed LMIs numerically and use the numerical results to narrow down possible Lyapunov
function structures and useful function inequalities even before trying to construct proofs. This
complements several existing proof techniques which more or less require guessing the required
Lyapunov functions at the early stage of proof constructions. We will further explain this point after
our main LMI condition is presented.
The rest of the paper is organized as follows. Section 2 introduces the notation and reviews
the concepts of linear jump systems. In Section 3, we present a general jump system model which
governs the dynamics of a large family of stochastic optimization methods including SAG, SAGA,
Finito and SDCA. Section 4 presents a unified LMI analysis for the proposed jump system model.
A unified LMI condition is derived using jump system theory and several function properties in the
form of simple quadratic constraints. We apply the LMI condition and successfully prove various
rate bounds for SAGA, SDCA, and Finito with or without individual convexity. We also explain
why our proposed LMI fails in analyzing SAG. We reveal a key difference between SAG and other
methods, and briefly discuss how to extend our LMI analysis for SAG. We present the main technical
proofs in Section 5. Finally, we conclude with several future directions (Section 6).
2. Preliminaries
2.1. Notation and Background
The set of p-dimensional real vectors is denoted as Rp. The p × p identity matrix and the p × p
zero matrix are denoted as Ip and 0p, respectively. The n × n identity matrix is denoted as In, and
the n × n zero matrix is denoted as 0n. Let ei denote the n-dimensional vector whose entries are
all 0 except the i-th entry which is 1. Let e denote the n-dimensional vector whose entries are all
1. Let 0̃ denote the n-dimensional vector whose entries are all 0. For simplicity, 0 is occasionally
used to denote a zero vector or a zero matrix when there is no confusion on the dimension. The
Kronecker product of two matrices A and B is denoted by A⊗ B. Notice (A⊗ B)T = AT ⊗BT
and (A ⊗ B)(C ⊗D) = (AC) ⊗ (BD) when the matrices have compatible dimensions. When a
matrix P is negative semidefinite (definite), we will use the notation P ≤ (<)0. When P is positive
definite, we use the notation P > 0.
A continuously differentiable function f : Rp → R is L-smooth if for all x, y ∈ Rp we have
‖∇f(x)−∇f(y)‖ ≤ L‖x−y‖. The continuously differentiable function f is said to be m-strongly
convex if for all x, y ∈ Rp we have f(x) ≥ f(y) +∇f(y)T (x− y) + m2 ‖x− y‖2. Notice f is said
3
HU SEILER RANTZER
to be convex if f is 0-strongly convex. Let F(m,L) denote the set of continuously differentiable
functions f : Rp → R that are L-smooth and m-strongly convex. Hence F(0, L) denotes the set of
continuously differentiable convex functions that are L-smooth.
For any f ∈ F(m,L) with m > 0, there exist a unique x∗ ∈ Rp such that ∇f(x∗) = 0. In
addition, the following inequality holds for any x ∈ Rp (Lessard et al., 2016, Proposition 5)
[
x− x∗
∇f(x)
]T [ −2mLIp (L+m)Ip
(L+m)Ip −2Ip
] [
x− x∗
∇f(x)
]
≥ 0 (2)
However, a function satisfying the above inequality may not belong to F(m,L), and may not
even be convex. The set of continuously differentiable functions satisfying (2) with some unique
global minimum x∗ is denoted as S(m,L). This class of functions has sector-bounded gradients,
and includes F(m,L) as its subset. We emphasize that the functions in S(m,L) may not be convex.
A general assumption adopted in this paper is that g ∈ S(m,L) with m > 0. This is weaker than
the assumption g ∈ F(m,L). Three sets of assumptions are typically used for fi, i.e. fi ∈ F(m,L),
fi ∈ F(0, L) or fi being L-smooth. Given an arbitrary reference point x∗ (the value of ∇fi(x∗)
may not be 0) and any x ∈ Rp, the following inequality always holds
[
x− x∗
∇fi(x)−∇fi(x∗)
]T [
2LγIp (L− γ)Ip
(L− γ)Ip −2Ip
] [
x− x∗
∇fi(x)−∇fi(x∗)
]
≥ 0 (3)
where γ is determined by the assumptions on fi as follows
γ :=



−m if fi ∈ F(m,L)
0 if fi ∈ F(0, L)
L if fi is L-smooth
. (4)
Notice (3) is just a summary of the definition of L-smoothness and the so-called co-coercivity
condition (Lessard et al., 2016, Proposition 5).
Finally, the underlying probability space for the sampling index ik is denoted as (Ω,F ,P). Let
Fk be the σ-algebra generated by (i1, i2, . . . , ik). Clearly, ik is Fk-adapted and we obtain a filtered
probability space (Ω,F , {Fk},P) which the stochastic method is defined on.
2.2. Stochastic Jump Systems
A linear jump system is described by the following set of recursive equations:
ξk+1 = Aikξ
k +Bikw
k
vk = Cikξ
k +Dikw
k.
(5)
At each step k, the jump parameter ik is a random variable taking value in a finite set N =
{1, · · · , n}. In addition, Aik : N → Rnξ×nξ , Bik : N → Rnξ×nw , Cik : N → Rnv×nξ , and
Dik : N → Rnv×nw are functions of ik. When ik = i ∈ N , clearly we have Aik = Ai, Bik = Bi,
Cik = Ci, and Dik = Di. If the process {ik : k = 1, 2, . . .} is a Markov chain, the resultant jump
system (5) is termed as a discrete-time Markovian jump linear system (MJLS). There is a large body
of literature on MJLS in the controls field (Costa et al., 2006; Dragan et al., 2010). We confine our
scope to the special case where ik is an identically and independently distributed (IID) process, i.e.
4
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
P(ik = i | Fk−1) = P(ik = i) for all k ≥ 0 and i ∈ N . When ik is sampled from a uniform
distribution, we have P(ik = i) =
1
n
. When ik is generated cyclically based on a deterministic
order, (5) is not a jump system but a linear periodic system. There is also a large body of control
literature on linear periodic systems (Bittanti and Colaneri, 2008). When ik is a constant, then the
state matrices are constant matrices and the model (5) is just an LTI system. LTI system theory is
also well established (Hespanha, 2009).
3. A General Jump System Model for Stochastic Optimization Methods
Now we introduce the following general jump system model which governs the dynamics of a large
family of stochastic optimization methods.
ξk+1 = Aikξ
k +Bikw
k
vk = Cξk
wk =





∇f1(vk)
∇f2(vk)
...
∇fn(vk)





(6)
The above model builds upon the linear jump system model (5) by further enforcing a nonlinear
relationship between wk and vk, i.e. wk =
[
∇f1(vk)T · · · ∇fn(vk)T
]T
. We can represent a large
family of stochastic optimization methods using the unified jump system model (6) with properly
chosen (Aik , Bik , C). In this paper, we consider the following stochastic methods.
1. SAGA (Defazio et al., 2014a): The iteration rule is the follows
xk+1 = xk − α
(
∇fik(xk)− ykik +
1
n
n
∑
i=1
yki
)
(7)
where at each step k, a random training example ik is drawn uniformly from the set N and
yk+1i :=
{
∇fi(xk) if i = ik
yki otherwise
. (8)
2. SAG (Roux et al., 2012; Schmidt et al., 2013): The main iteration rule is
xk+1 = xk − α
(
∇fik(xk)− ykik
n
+
1
n
n
∑
i=1
yki
)
(9)
where at each k, ik is uniformly drawn from the set N and yki is updated by (8).
3. Finito (Defazio et al., 2014b): Suppose xki ∈ Rp and yki ∈ Rp for each k and all i ∈ N . At
each k, an index ik is drawn from the set N , and xk+1i is updated as
xk+1i :=
{
1
n
∑n
i=1 x
k
i − α
∑n
i=1 y
k
i if i = ik
xki otherwise
. (10)
5
HU SEILER RANTZER
where α is the stepsize 1. Then yk+1i is updated as
yk+1i :=
{
∇fi(xk+1i ) if i = ik
yki otherwise
. (11)
4. SDCA (Shalev-Shwartz, 2016, Algorithm 1): There are several versions of SDCA. For sim-
plicity, we consider SDCA without duality, which solves the ℓ2-regularized problem
minimize
x∈Rp
g(x) :=
1
n
n
∑
i=1
fi(x) +
m
2
‖x‖2 (12)
To solve the above problem, SDCA without duality requires updating xk ∈ Rp and yk+1i ∈ Rp
at each step. It first updates xk using yki as follows
xk =
1
mn
n
∑
i=1
yki (13)
Then yk+1i is updated as
yk+1i :=
{
yki − αmn(∇fi(xk) + yki ) if i = ik
yki otherwise
. (14)
where ik is randomly sampled from N . In the actual computation, the update (13) for k ≥ 1
is performed using the formula xk = xk−1 − α(∇fik−1(xk−1) + yk−1i ) due to efficiency
considerations. However, (13) is more general and governs the updates of SDCA for all k.
To represent the above methods in the general jump system model (6), we can choose the state
matrices as Aik = Ãik ⊗ Ip, Bik = B̃ik ⊗ Ip, and C = C̃ ⊗ Ip where Ãik , B̃ik and C̃ are defined
according to Table 1.
Method Ãik B̃ik C̃
SAGA
[
In − eikeTik 0̃
−α
n
(e− neik)T 1
]
[
eike
T
ik
−αeTik
]
[
0̃T 1
]
SAG
[
In − eikeTik 0̃
−α
n
(e− eik)T 1
]
[
eike
T
ik
−α
n
eTik
]
[
0̃T 1
]
Finito
[
In − eikeTik 0̃
−α(eikeT ) In − eik(eTik −
1
n
eT )
] [
eike
T
ik
0̃0̃T
]
[
−αeT 1
n
eT
]
SDCA In − αmneikeTik −αmneikeTik
1
mn
eT
Table 1: State Matrices for Feedback Representations of SAG, SAGA, Finito, and SDCA
For illustrative purposes, we explain the jump system formulation for SAGA. The jump system
formulations for SAG, Finito, and SDCA are further explained in Appendix A. For SAGA, we
1. One typical choice of α under the big data condition is α = 1
2nm
.
6
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
define the stacked vector yk :=
[
(yk1 )
T · · · (ykn)T
]T
. Then the SAGA gradient update rule (8)
can be rewritten as:
yk+1 =
(
(In − eikeTik)⊗ Ip
)
yk +
(
(eike
T
ik
)⊗ Ip
)
wk (15)
where wk =
[
∇f1(xk)T · · · ∇fn(xk)T
]T
. Notice
∑n
i=1 y
k
i = (e
T ⊗ Ip)yk and ∇fik(xk) − ykik =
(eTik ⊗ Ip)(w
k − yk). Thus the iteration rule (7) can be rewritten as follows:
xk+1 = xk − α(eTik ⊗ Ip)(w
k − yk)− α
n
(eT ⊗ Ip)yk
= xk − α
n
(
(e− neik)T ⊗ Ip
)
yk − α(eTik ⊗ Ip)w
k
(16)
Now the update rules in (15) and (16) can be expressed as:
[
yk+1
xk+1
]
=
[
(In − eikeTik)⊗ Ip 0̃⊗ Ip
−α
n
(e− neik)T ⊗ Ip Ip
] [
yk
xk
]
+
[
(eike
T
ik
)⊗ Ip
(−αeTik)⊗ Ip
]
wk
vk =
[
0̃T ⊗ Ip Ip
]
[
yk
xk
]
wk =



∇f1(vk)
...
∇fn(vk)



(17)
which is exactly in the form of the general jump system model (6) with ξk =
[
yk
xk
]
.
The computation of wk at each k requires a full gradient computation (or n individual oracle
accesses). However, Bik is sparse such that Bikw
k only involves one individual oracle access. The
low per-iteration cost of stochastic methods is captured by the sparsity of Bik . Most entries of w
k
are “phantom” iterates which facilitates our analysis but do not appear in the actual computation.
Since g ∈ S(m,L) with m > 0, there exists unique x∗ ∈ Rp satisfying ∇g(x∗) = 0. To
make (6) a good model for optimization methods, we have to ensure its equilibrium point is related
to x∗. Define w∗ :=
[
∇f1(x∗)T . . . ∇fn(x∗)T
]T
, and v∗ := x∗. If (6) is an optimization
method which converges to x∗, then ξk should converge to some equilibrium state ξ∗ capturing the
information of x∗ and satisfying
ξ∗ = Aiξ
∗ +Biw
∗
v∗ = Cξ∗
w∗ =



∇f1(v∗)
...
∇fn(v∗)



(18)
for all i ∈ N . Now we set up ξ∗ for SAGA, SAG, Finito, and SDCA as follows.
1. For SAG and SAGA, we have ξk :=
[
yk
xk
]
and ξ∗ :=
[
w∗
x∗
]
. If we can show that ξk converges
to ξ∗, then we can conclude that xk converges to x∗ and yki converges to ∇fi(x∗).
7
HU SEILER RANTZER
2. For Finito, we have xk :=
[
(xk1)
T · · · (xkn)T
]T
, ξ∗ =
[
yk
xk
]
and ξ∗ =
[
w∗
e⊗ x∗
]
. If we can
show that ξk converges to ξ∗, then yki converges to ∇fi(x∗) and xki converges to x∗.
3. For SDCA (without duality), we have ξk = yk and ξ∗ = −w∗. For the ℓ2-regularized problem
(12) with strongly-convex g, the optimal point x∗ satisfies mx∗ + 1
n
∑n
i=1 ∇fi(x∗) = 0.
Hence, if ξk converges to ξ∗, then yki converges to −∇fi(x∗) and xk converges to x∗.
It is straightforward to verify that (18) holds for the above ξ∗ due to the fact ∇g(x∗) = 0.
4. Analysis of Stochastic Methods Using Semidefinite Programs
4.1. An Unified LMI Condition for Analysis of Stochastic Methods
From the above discussion, we always want to show ξk converges to ξ∗ at a given linear rate ρ. Now
we present a unified LMI condition for such linear convergence using jump system theory and the
basic quadratic inequalities (2) (3) which capture the key properties of the loss functions.
Theorem 1 Consider the general jump system model (6), where Ai = Ãi⊗ Ip, Bi = B̃i ⊗ Ip, and
C = C̃ ⊗ Ip. Assume ik is sampled in an IID manner from a uniform distribution P(ik = i) = 1n .
Suppose there exists a unique x∗ ∈ Rp such that ∇g(x∗) = 0. The function fi is assumed to satisfy
the following two inequalities for any x ∈ Rp,
[
x− x∗
∑n
i=1 ∇fi(x)
n
−
∑n
i=1 ∇fi(x∗)
n
]T
[
2LνIp (L− ν)Ip
(L− ν)Ip −2Ip
]
[
x− x∗
∑n
i=1 ∇fi(x)
n
−
∑n
i=1 ∇fi(x∗)
n
]
≥ 0
(19)
[
x− x∗
∇fi(x)− fi(x∗)
]T [
2LγIp (L− γ)Ip
(L− γ)Ip −2Ip
] [
x− x∗
∇fi(x)− fi(x∗)
]
≥ 0 (20)
where ν and γ are some prescribed scalars. Define D̃ψ1 ∈ R2n+2 and D̃ψ2 ∈ R(2n+2)×n as
D̃ψ1 =
[
L ν L γ . . . L γ
]T
D̃ψ2 =
[
− 1
n
e 1
n
e −e1 e1 . . . −en en
]T
.
(21)
If ∃ an nξ × nξ matrix P̃ = P̃ T > 0 and nonnegative scalars λ1, λ2 such that
[
1
n
∑n
i=1 Ã
T
i P̃ Ãi − ρ2P̃ 1n
∑n
i=1 Ã
T
i P̃ B̃i
1
n
∑n
i=1 B̃
T
i P̃ Ãi
1
n
∑n
i=1 B̃
T
i P̃ B̃i
]
+
[
C̃T D̃Tψ1
D̃Tψ2
]
([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0 1
1 0
])
[
D̃ψ1C̃ D̃ψ2
]
≤ 0
(22)
then all k ≥ 1 and ξ0 ∈ Rnξ , the following inequality holds
E
[
(ξk+1 − ξ∗)T (P̃ ⊗ Ip)(ξk+1 − ξ∗)
]
≤ ρ2E
[
(ξk − ξ∗)T (P̃ ⊗ Ip)(ξk − ξ∗)
]
. (23)
Consequently, E
[
‖ξk − ξ∗‖2
]
≤ ρ2k
(
cond(P̃ )‖ξ0 − ξ∗‖2
)
holds for all k ≥ 1 and ξ0 ∈ Rnξ ,
where cond denotes the condition number of a given positive definite matrix.
8
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Proof A detailed proof is presented in Section 5.1. Here we briefly sketch the proof idea. Denote
P = P̃ ⊗ Ip, and define a Lyapunov function by V (ξk) = (ξk − ξ∗)TP (ξk − ξ∗). Then one
can use the LMI condition and the basic quadratic inequalities (19) (20) to show that V satisfies
EV (ξk+1)−ρ2EV (ξk) ≤ 0. This immediately leads to the desired conclusion. We can see the LMI
condition gives us an automated way to search quadratic Lyapunov functions.
The initial condition ‖ξ0 − ξ∗‖2 is related to the so-called variance term since ξ∗ is typically
determined by x∗ and ∇fi(x∗). When ρ2 is given, the testing condition (22) is linear in P̃ , λ1, and
λ2. Therefore, (22) is an LMI whose feasible set is convex and can be effectively searched using
the state-of-the-art convex optimization techniques, e.g. interior point method. Many optimization
solvers are available such that coding this LMI condition is a straightforward task.
One can automate the proposed LMI analysis of stochastic optimization methods by modifying
the values of ν and γ to reflect various assumptions on g and fi. For SAG, SAGA and Finito, we
always assume g ∈ S(m,L) with m > 0 and hence we should set ν = −m in our analysis. The
value of γ is chosen based on the assumptions on fi as follows.
γ =



−m if fi ∈ F(m,L)
0 if fi ∈ F(0, L)
L if fi is L-smooth
For SDCA, (12) is considered. We assume 1
n
∑n
i=1 fi ∈ F(0, L). By co-coercivity, we can set
ν = 0. In addition, we have γ = 0 if fi ∈ F(0, L) and γ = L if fi is only assumed to be L-smooth.
4.2. Numerical Pre-Analysis of Stochastic Methods Using Semidefinite Programs
Theorem 1 provides a simple unified tool for linear rate analysis of stochastic optimization methods
governed by the general jump system model (6). In principle, one can implement LMI (22) once.
Then given a stochastic method (6), one only needs to modify the (Ãi, B̃i, C̃) matrices in the code.
Notice the size of the LMI condition (22) scales proportionally with n, and hence we can only solve
LMI (22) numerically for n up to several hundred. However, these numerical results with n being
several hundred provide informative clues for further proof constructions. Notice the following two
questions are important when analyzing a finite-sum method using Lyapunov arguments:
1. Which inequalities describing the function properties should be used in the proof?
2. What is the simplest form of Lyapunov function required by the proof?
Answers to these questions in the early stage of the analysis can guide researchers in their search
for proofs. Usually one has to make a rough guess based on personal expertise. Theorem 1 provides
a complementary numerical tool for this purpose. The numerical feasibility results from LMI (22)
with n being several hundred roughly answer the questions above by providing clues for selecting
related function inequalities and simplified forms of Lyapunov functions. For example, numerical
tests of LMI (22) for SAGA show that enforcing the Lyapunov function to be diagonal does not
change the feasibility results. This suggests using a diagonal Lyapunov function for SAGA. When
analyzing Finito, the numerical tests of (22) immediately indicate that Finito requires Lyapunov
functions with off-diagonal terms. When we test the existing rate results for SAG (Schmidt et al.,
2013, Theorem 1), LMI (22) becomes infeasible. This indicates that the analysis of SAG requires
9
HU SEILER RANTZER
less conservative function inequalities in addition to the simple quadratic inequalities (19) (20). The
details of the numerical tests of LMI (22) are presented in Appendix B. Notice our proposed analysis
heavily relies on the quadratic constraints used in the LMI formulations. Some stochastic methods,
e.g. SAGA, SDCA and Finito, are relatively easier to analyze, since they only require the simple
quadratic inequalities (19) (20). Some other methods, e.g. SAG, are more involved, and require
more advanced quadratic constraints in addition to (19) (20). Theorem 1 provides a simple tool to
distinguish these two classes of stochastic methods. We will further discuss SAG in Section 4.5.
Next, we reduce LMI (22) to some equivalent small LMIs for SAGA, Finito, and SDCA.
4.3. Dimension Reduction for the Proposed LMI
The preliminary numerical test results of LMI (22) actually shed light on possible simplifications
of the proposed LMI condition. Based on the preliminary numerical tests documented in Appendix
B, it seems that (22) is sufficient for analysis of SAGA, Finito, and SDCA. As mentioned before,
we notice various simplified parameterizations of P̃ are required for different algorithms. These
simplified parameterizations seem not to introduce further conservatism into our analysis. The
resultant LMI (22) with such P̃ consists of blocks which have the special form µIn + qee
T where
µ and q are some scalars. We summarize our preliminary findings in Table 2.
Method Parameterization of P̃ Matrix Form of the Resultant LMI (22)
SAGA
[
p1In 0̃
0̃T p2
]


µ1In + q1ee
T q4e µ6In + q6ee
T
q4e
T µ2 q5e
T
µ6In + q6ee
T q5e µ3In + q3ee
T


SDCA p1In + p2ee
T
[
µ1In + q1ee
T µ3In + q3ee
T
µ3In + q3ee
T µ2In + q2ee
T
]
Finito
[
p1In + p2ee
T p3ee
T
p3ee
T p4In + p5ee
T
]


µ1In + q1ee
T µ4In + q4ee
T µ6In + q6ee
T
µ4In + q4ee
T µ2In + q2ee
T µ5In + q5ee
T
µ6In + q6ee
T µ5In + q5ee
T µ3In + q3ee
T


Table 2: Parameterization of P̃ and Matrix Forms in (22) for SAGA, SDCA and Finito
The special matrix form of (22) is due to the same assumption on fi for all i and the uniform
sampling of ik. We can take advantage of the special matrix forms and convert (22) into equivalent
small LMIs whose sizes do not depend on n. For example, we know
[
µ1In+q1eeT µ3In+q3eeT
µ3In+q3eeT µ2In+q2eeT
]
≤ 0
if and only if [ µ1 µ3µ3 µ2 ] ≤ 0 and [ µ1 µ3µ3 µ2 ]+n [ q1 q3q3 q2 ] ≤ 0. Hence the analysis of SDCA actually involves
two coupled 2 × 2 LMIs. Similar linear algebra tricks can be used to convert (22) into equivalent
small LMIs for SAGA and Finito. This leads to the following simplified testing conditions.
Theorem 2 Suppose ik is uniformly sampled and m > 0. Let a testing rate 0 ≤ ρ ≤ 1 be given.
1. (SAGA): Suppose g ∈ S(m,L), and γ is defined by (4) based on assumptions on fi. If there
exist positive scalars p1, p2, and non-negative scalars λ1, λ2 such that
[
p2α
2 +
(
n−1
n
− ρ2
)
np1 −α2p2
−α2p2 p1 + α2p2 − 2λ2
]
≤ 0 (24)
[
(1− ρ2)p2 − 2λ1mL+ 2λ2Lγ −αp2 + (m+ L)λ1 + (L− γ)λ2
−αp2 + (m+ L)λ1 + (L− γ)λ2 p1 + α2p2 − 2λ2 − 2λ1
]
≤ 0 (25)
10
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Then SAGA (7) (8) initialized with any x0 ∈ Rp and y0i ∈ Rp satisfies
E
[
‖xk − x∗‖2 + p1
p2
n
∑
i=1
‖yki −∇fi(x∗)‖2
]
≤ ρ2kR0 (26)
where R0 = ‖x0 − x∗‖2 + p1
p2
∑n
i=1 ‖y0i −∇fi(x∗)‖2.
2. (Finito): Suppose g ∈ S(m,L), and γ is defined by (4) based on assumptions on fi. If there
exist scalars p1, p2, p3, p4, p5 and non-negative scalars λ1, λ2 such that p1 > 0, p4 > 0 and
[
p1 + np2 np3
np3 p4 + np4
]
> 0 (27)


p2 − p1 + n(1− ρ2)p1 p3 −p2
p3 p5 − p4 + n(1− ρ2)p4 −p3
−p2 −p3 p1 + p2 − 2λ2

 ≤ 0 (28)



X11 X12 X13
X12 (p4 + np5)(1− ρ2)− 2Lmλ1−2Lγλ2n p3 +
(L+m)λ1+(L−γ)λ2
n
X13 p3 +
(L+m)λ1+(L−γ)λ2
n
p1+p2−2λ1−2λ2
n



≤ 0 (29)
X11 = (1−
1
n
− ρ2)p1 +
p2
n
− nρ2p2 + (n− 2)p2 − 2(1−
1
n
)p3αn
+ (p4 + p5 − 2Lmλ1 + 2Lγλ2)α2n
(30)
X12 = (1− ρ2)p3n− p3 − (p4 + np5 − 2Lmλ1 + 2Lγλ2)α (31)
X13 = (1−
1
n
)p2 − (p3 + λ1(L+m) + λ2(L− γ))α (32)
Then Finito (10) (11) with any initial condition x0i ∈ Rp and y0i ∈ Rp satisfies
EV k ≤ ρ2kV 0 (33)
where V k = (ξk − ξ∗)TP (ξk − ξ∗), ξk =
[
yk
xk
]
, P =
[
p1In + p2ee
T p3ee
T
p3ee
T p4In + p5ee
T
]
⊗ Ip.
3. (SDCA): Suppose 1
n
∑n
i=1 fi ∈ F(0, L). Set γ = 0 if fi ∈ F(0, L), and set γ = L if fi is
only L-smooth. Denote α̃ = αmn. If there exist real scalars p1, p2 and nonnegative λ1, λ2
such that p1 > 0, p1 + np2 > 0, and
[
p1(α̃
2 − 2α̃ + n(1− ρ2)) + p2α̃2 p1(α̃2 − α̃) + α̃2p2
p1(α̃
2 − α̃) + α̃2p2 (p1 + p2)α̃2 − 2λ2
]
≤ 0 (34)
[
X11 X12
X12 (p1 + p2)α̃
2 − 2(λ1 + λ2)
]
≤ 0 (35)
X11 = p1(α̃
2 − 2α̃+ n(1− ρ2)) + p2(α̃− n)2 − n2ρ2p2 +
2γLλ2
m2
(36)
X12 = p1(α̃
2 − α̃) + α̃(α̃− n)p2 +
λ1L+ (L− γ)λ2
m
(37)
11
HU SEILER RANTZER
Then SDCA (13) (14) with stepsize α and initial condition yk0 satisfies
E
[
‖xk − x∗‖2 + p1
p2m2n2
n
∑
i=1
‖yki +∇fi(x∗)‖2
]
≤ ρ2kR0 (38)
where R0 = ‖x0 − x∗‖2 + p1
p2m2n2
∑n
i=1 ‖y0i +∇fi(x∗)‖2.
Proof One can compute analytical expressions of the matrix on the left side of (22) and prove this
theorem using the linear algebra tricks mentioned before. Detailed proofs are left to Appendix C.
4.4. New Analytical Rate Bounds for SAGA, Finito, and SDCA
We can analytically solve the LMIs in Theorem 2, and prove the following rate results for SAGA,
Finito and SDCA.
Corollary 3 (Rate Bounds for SAGA) Assume ik is uniformly sampled from N , and g ∈ S(m,L)
with m > 0. Consider SAGA (7) (8) initialized from x0 ∈ Rp and y0i ∈ Rp.
1. If fi ∈ F(m,L), then for any 0 < α ≤ 12L , one has
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
2Lα− 1
(Lα− 1)n, 2mα−
αm2
(1− Lα)L
})k
R0 (39)
where R0 = ‖x0 − x∗‖2 + α
L
∑n
i=1 ‖y0i − ∇fi(x∗)‖2. The following bound also holds for
any α ≤ 49L
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
9Lα− 4
(3Lα− 4)n, 2mα−
3αm2
(4− 3Lα)L
})k
R0 (40)
where R0 = ‖x0 − x∗‖2 + 2α3L
∑n
i=1 ‖y0i −∇fi(x∗)‖2.
2. If fi ∈ F(0, L), then for any 0 < α ≤ 12L , one has
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
2Lα− b
(Lα− b)n, 2(1 − b)mα−
αm2(1− b)2
(2− b− Lα)L
})k
R0 (41)
where b can be any scalar in [2Lα, 1], and R0 = ‖x0 − x∗‖2 + bα
L
∑n
i=1 ‖y0i − ∇fi(x∗)‖2.
More specifically, when α = 13L , we can set b =
5
6 and get the following bound:
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
1
3n
,
m
10L
})k
R0 (42)
where R0 = ‖x0 − x∗‖2 + 5
18L2
∑n
i=1 ‖y0i −∇fi(x∗)‖2.
12
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
3. If fi is only assumed to be L-smooth, then the following bound holds for any α ≤ 3m8L2 ,
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
b− 2
(b− 1)n,
3mα
2
− 2bL2α2
})k
R0 (43)
where b can be any scalar satisfying 2 ≤ b ≤ 3m
4αL2
, and R0 = ‖x0−x∗‖2+ bα2∑ni=1 ‖y0i −
∇fi(x∗)‖2. Specifically, when α = m8L2 , we can set b = 3 and get the following bound:
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
1
2n
,
3m2
32L2
})k
R0 (44)
where R0 = ‖x0 − x∗‖2 + 3m2
64L4
∑n
i=1 ‖y0i − ∇fi(x∗)‖2. When α = m4(m2n+L2) , we can set
b = 2(m
2n+L2)
L2
and obtain
E
[
‖xk − x∗‖2
]
≤
(
1− m
2
8(m2n+ L2)
)k
R0 (45)
where R0 = ‖x0−x∗‖2+ m2
8(m2n+L2)L2
∑n
i=1 ‖y0i−∇fi(x∗)‖2. Hence, the ǫ-optimal iteration
complexity of SAGA without individual convexity is Õ
(
( L
2
m2
+ n) log(1
ǫ
)
)
.
Corollary 4 (Rate Bounds for Finito) Assume ik is uniformly sampled from N , and g ∈ S(m,L)
with m > 0. Consider Finito (10) (11) initialized from x0i ∈ Rp and y0i ∈ Rp. Define vk =
1
n
∑n
i=1 x
k
i − α
∑n
i=1 y
k
i .
1. If fi ∈ F(m,L) and n ≥
√
50L
m
, then Finito with α = 15L satisfies
E
[
m
10L
n
∑
i=1
‖xki − x∗‖2 + ‖vk − x∗‖2
]
≤
(
1−min
{
1
2n
,
m
20L
})k
R0 (46)
where R0 = m10L
∑n
i=1 ‖x0i − x∗‖2 + 15L2
∑n
i=1 ‖y0i −∇fi(x∗)‖2 + ‖v0 − x∗‖2.
2. If fi ∈ F(0, L) and n ≥
√
64L
m
, then Finito with α = 18L satisfies
E
[
m
16L
n
∑
i=1
‖xki − x∗‖2 + ‖vk − x∗‖2
]
≤
(
1−min
{
1
3n
,
5m
176L
})k
R0 (47)
where R0 = m16L
∑n
i=1 ‖x0i − x∗‖2 + 116L2
∑n
i=1 ‖y0i −∇fi(x∗)‖2 + ‖v0 − x∗‖2.
3. If fi is L-smooth and n ≥ 48L
2
m2
, then Finito with α = 12nm satisfies
E
[
3
8n
n
∑
i=1
‖xki − x∗‖2 + ‖vk − x∗‖2
]
≤
(
1− 1
3n
)k
R0 (48)
where R0 = 38n
∑n
i=1 ‖x0i − x∗‖2 + 1n2m2
∑n
i=1 ‖y0i −∇fi(x∗)‖2 + ‖v0 − x∗‖2.
13
HU SEILER RANTZER
Corollary 5 (Rate Bounds for SDCA without Duality) Assume ik is uniformly sampled from N ,
and
∑n
i=1 fi ∈ F(0, L). Consider SDCA (13) (14) initialized from y0i .
1. If fi ∈ F(0, L), then for any 0 < α ≤ 2L+2mn , one has
E
[
‖xk − x∗‖2 + α
(1− αmn)mn
n
∑
i=1
‖yki +∇fi(x∗)‖2
]
≤ (1−mα)k R0 (49)
where R0 = ‖x0 − x∗‖2 + α(1−αmn)mn
∑n
i=1 ‖y0i +∇fi(x∗)‖2.
2. If fi is L-smooth, then (49) holds for any 0 < α ≤ mL2+m2n . When α = m(m2n+L2) , the
following bound holds
E
[
‖xk − x∗‖2 + 1
L2n
n
∑
i=1
‖yki +∇fi(x∗)‖2
]
≤
(
1− m
2
m2n+ L2
)k
R0 (50)
where R0 = ‖x0 − x∗‖2 + 1
L2n
∑n
i=1 ‖y0i +∇fi(x∗)‖2.
All the proofs are presented in Section 5. All three corollaries are actually proved via ana-
lytically solving the LMI conditions in Theorem 2. When fi is assumed to be only smooth (not
necessarily convex), we only need to modify the value of γ to be L and then analytically construct
a feasible solution for the resultant LMIs. We believe our rate bounds for SAGA and Finito without
individual convexity (Statement 3 in Corollary 3 and Statement 3 in Corollary 4) are new. Now we
briefly discuss the connections between our results and some existing rate bounds.
1. (SAGA) Statement 1 in Corollary 3 is new in the sense that it works for a range of α and also
highlights the trade-off between the dependence of ρ2 on n and m
L
. Notice that (39) works
better under the big data condition while (40) is less conservative with large condition number
L/m. Suppose fi ∈ F(m,L). If one chooses α = 13L in (40) and applies the fact L ≥ m,
(40) directly leads to
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
1
3n
,
m
3L
})k
(
‖x0 − x∗‖2 + 2
9L2
n
∑
i=1
‖y0i −∇fi(x∗)‖2
)
(51)
The convergence rate in the above bound agrees with the result in Defazio et al. (2014a,
Section 2). On the other hand, one can also choose α = 13L in (39) and obtain
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
1
2n
,
m
6L
})k
(
‖x0 − x∗‖2 + 1
3L2
n
∑
i=1
‖y0i −∇fi(x∗)‖2
)
(52)
Clearly, the above bound is better than (51) under the big data condition n ≥ 3L
m
. In principle,
one can generate a family of bounds to describe this trade-off in more details. But all these
bounds will only affect the iteration complexity Õ
(
(n+ L
m
) log(1
ǫ
)
)
by a constant factor.
14
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Actually, we can also recover some other existing rate bounds for SAGA with individual
convexity by modifying the proofs. See Remark 6 for further discussions.
We notice that for any fixed m and L, SAGA (with n sufficiently large) can achieve a rate
ρ2 = 1− 1
cn
where c is arbitrarily close to 1. For example, consider fi ∈ F(m,L). Given any
c ∈ (1,∞), we can choose a sufficiently small α to ensure Lα−12Lα−1 < c. For this specific value
of α, (39) just leads to a rate bound ρ2 = 1− 1
cn
under the condition
(
2mα− αm2(1−Lα)L
)
n ≥
2Lα−1
Lα−1 . Similar arguments also work when fi ∈ F(0, L) or fi being L-smooth.
2. (Finito): When fi ∈ F(m,L) with m > 0, our result states a linear rate bound for α = 15L ,
which is a stepsize independent of the parameter m. This could be useful since sometimes
m is unknown for practical problems. On the other hand, the rate proofs in Defazio et al.
(2014b, Theorem 1) work for α = 12nm under the big data condition n ≥ 2Lm .
In general, our rate bounds for Finito are not as good as the rate bounds for SAGA. This is due
to the fact that the LMI conditions for Finito are more complicated and involve more decision
variables. We are only able to analytically solve these LMIs under the big data condition,
although our preliminary numerical tests on the feasibility of these LMIs suggest that Finito
and SAGA have similar convergence rates.
3. (SDCA) Statement 1 in the above corollary is very similar to Shalev-Shwartz (2015, Theorem
1). Actually, when α = 1
L+mn , (49) becomes
E
[
‖xk − x∗‖2 + 1
Lmn
n
∑
i=1
‖yki +∇fi(x∗)‖2
]
≤
(
1− m
L+mn
)k
R0 (53)
where R0 = ‖x0 − x∗‖2 + 1
Lmn
∑n
i=1 ‖y0i +∇fi(x∗)‖2. This is almost identical to Shalev-
Shwartz (2015, Theorem 1). Statement 1 in Corollary 5 is slightly stronger since it only
requires α ≤ 2
L+2mn . Notice Shalev-Shwartz (2015, Theorem 1) requires α ≤ 1L+mn . Sim-
ilarly, Statement 2 in Corollary 5 slightly improves Shalev-Shwartz (2015, Theorem 2) by
allowing a slightly larger value of α.
4.5. Further Discussion on SAG
Finally, we explain why Theorem 1 fails in recovering the existing SAG rate bounds in Schmidt
et al. (2013, Theorem 1), and briefly sketch how to extend our LMI-based analysis for SAG. The
fundamental reason is that the proof of Schmidt et al. (2013, Theorem 1) requires g ∈ F(m,L),
which is stronger than the condition g ∈ S(m,L). Notice in Theorem 1, we only incorporate one
property of g, i.e.
[
vk − x∗
∇g(vk)
]T [ −2mLIp (L+m)Ip
(L+m)Ip −2Ip
] [
vk − x∗
∇g(vk)
]
≥ 0 (54)
The above inequality couples vk with x∗, and is satisfied for any g ∈ S(m,L). However, the
proof for Schmidt et al. (2013, Theorem 1) actually relies on some advanced inequalities 2 coupling
f(vk+1) with f(vk). Such advanced inequalities typically require g ∈ F(m,L). In other words, the
2. See (11) in Schmidt et al. (2013) for such an inequality.
15
HU SEILER RANTZER
convexity of g is required in the convergence proof of SAG while our proofs for SAGA and Finito
hold for some non-convex g.
Here is a similar example. The linear convergence of the full gradient descent method does
not require convexity of the objective function, and can be proved using a basic quadratic inequality
similar to (54). However, the linear convergence of Nesterov’s accelerated method cannot be proved
using this simple inequality and relies on some advanced inequalities coupling the current iterates
with the past iterates. These advanced inequalities decode convexity much better than the simple
inequality used in the proof of the full gradient descent method. One such advanced inequality is the
so-called weighted off-by-one IQC (Lessard et al., 2016, Lemma 10). See Lessard et al. (2016, Sec-
tion 4.5) for a detailed discussion on how to incorporate the weighted off-by-one IQC for analysis
of Nesterov’s accelerated method. The use of the weighted off-by-one IQC typically leads to larger
LMIs which are difficult to solve analytically. Very recently, Hu and Lessard (2017) have proposed
another inequality of similar nature to simplify the LMI-based analysis of Nesterov’s accelerated
method. The resultant LMI in Hu and Lessard (2017) is smaller and can be solved analytically to re-
cover the standard rate of Nesterov’s method. To summarize, more advanced quadratic inequalities
which further exploit the property of convexity are required in the analysis of Nesterov’s accelerated
method, and this makes the analysis of Nesterov’s accelerated method much more complicated than
the analysis of the full gradient descent method.
Due to similar reasons, the analysis of SAG is more involved than other stochastic methods.
Our quadratic constraint approach actually reveals the difficulties in analyzing different methods:
SAGA, SDCA, and Finito only require simple constraints (19) (20) while SAG further requires
more advanced quadratic constraints, e.g. weighted off-by-one IQC.
Now we briefly sketch two ways to address the analysis of SAG. First, one can combine our
proposed jump system theory with the quadratic constraint derivation procedure in Hu and Lessard
(2017). We can obtain a modified LMI condition which searches for a Lyapunov function in the
form of
(
(ξk − ξ∗)TP (ξk − ξ∗) + g(vk)− g(x∗)
)
where P is some positive semidefinite matrix.
We have some preliminary numerical rate results indicating that formulating such an LMI to search
for Lyapunov functions in the more general form is sufficient to numerically analyze SAG. Actually,
the original proof of Schmidt et al. (2013, Theorem 1) constructs such a Lyapunov function (Schmidt
et al., 2013, Section B.2).
Another way to address the analysis of SAG is to incorporate the weighted off-by-one IQC
(Lessard et al., 2016, Lemma 10) into our jump system framework. In this case, we can formulate
an LMI condition to search for a quadratic function which is not a Lyapunov function in the tech-
nical sense but serves the purpose of linear convergence certifications. See Lessard et al. (2016,
Remarks on Lyapunov Functions) for more explanations. We also have some preliminary numerical
rate results suggesting that applying the weighted off-by-one IQC can recover the linear conver-
gence rates in Schmidt et al. (2013, Theorem 1) and lead to new linear rate bounds under various
assumptions on fi.
Although there is no technical difficulty in incorporating these more advanced quadratic con-
straints into the LMI formulations for SAG, we have not been able to analytically solve these resul-
tant LMIs. In addition, the use of such advanced quadratic constraints requires much heavier math-
ematical notation. For readability purposes, we do not include a detailed numerical rate analysis of
SAG in this paper. See Lessard et al. (2016) and Hu and Lessard (2017) for detailed discussions on
weighted off-by-one IQC and other more advanced quadratic constraints.
16
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
5. Main Technical Proofs
We present the proofs of Theorem 1, Corollary 3, Corollary 4, and Corollary 5 in this section. The
proof of Theorem 2 is quite tedious, and hence left to Appendix C.
5.1. Proof of the Main LMI Condition (Theorem 1)
Based on the state space model in (6) and (18), we have
ξk+1 − ξ∗ = Aik(ξk − ξ∗) +Bik(wk − w∗)
vk − v∗ = C(ξk − ξ∗)
(55)
Denote P = P̃ ⊗ Ip, and define the Lyapunov function by V (ξk) = (ξk − ξ∗)TP (ξk − ξ∗).
Based on (55), we have the following key relation:
E[V (ξk+1) | Fk−1]
=E[(ξk+1 − ξ∗)TP (ξk+1 − ξ∗) | Fk−1]
=
n
∑
i=1
P(ik = i)
[
Ai(ξ
k − ξ∗) +Bi(wk − w∗)
]T
P
[
Ai(ξ
k − ξ∗) +Bi(wk − w∗)
]
=
[
ξk − ξ∗
wk − w∗
]T
[
1
n
∑n
i=1A
T
i PAi
1
n
∑n
i=1A
T
i PBi
1
n
∑n
i=1B
T
i PAi
1
n
∑n
i=1 B
T
i PBi
]
[
ξk − ξ∗
wk − w∗
]
(56)
Suppose Dψ1 = D̃ψ1 ⊗ Ip and Dψ2 = D̃ψ2 ⊗ Ip. Notice we always have
[
2LνIp (L− ν)Ip
(L− ν)Ip −2Ip
]
=
[
LIp −Ip
νIp Ip
]T [
0p Ip
Ip 0p
] [
LIp −Ip
νIp Ip
]
(57)
Moreover, we have C(ξk − ξ∗) = vk − x∗. Hence another key relation also holds as follows
[
ξk − ξ∗
wk − w∗
]T [
CTDTψ1
DTψ2
]([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0p Ip
Ip 0p
])
[
Dψ1C Dψ2
]
[
ξk − ξ∗
wk − w∗
]
=λ1
[
vk − x∗
∑n
i=1(∇fi(vk)−∇fi(x∗))
n
]T
[
2LνIp (L− ν)Ip
(L− ν)Ip −2Ip
]
[
vk − x∗
∑n
i=1(∇fi(vk)−∇fi(x∗))
n
]
+
λ2
n
n
∑
i=1
[
vk − x∗
∇fi(vk)−∇fi(x∗)
]T [
2LγIp (L− γ)Ip
(L− γ)Ip −2Ip
] [
vk − x∗
∇fi(vk)−∇fi(x∗)
]
≥ 0
(58)
The last step follows from (19) and (20), which are some simple quadratic inequalities capturing
the properties of fi. Now we can take the Kronecker product of the left side of (22) with Ip and
immediately get
[
1
n
∑n
i=1A
T
i PAi − ρ2P 1n
∑n
i=1 A
T
i PBi
1
n
∑n
i=1B
T
i PAi
1
n
∑n
i=1 B
T
i PBi
]
+
[
CTDTψ1
DTψ2
]([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0p Ip
Ip 0p
])
[
Dψ1C Dψ2
]
≤ 0
(59)
17
HU SEILER RANTZER
Therefore, left and right multiply the above inequality by [(ξk − ξ∗)T , (wk − w∗)T ] and [(ξk −
ξ∗)T , (wk − w∗)T ]T and apply (56), (58) to show that V satisfies:
E[V (ξk+1) | Fk−1]− ρ2V (ξk) ≤ 0 (60)
We can take full expectation to get EV (ξk+1)−ρ2EV (ξk) ≤ 0. Consequently, we immediately
have EV (ξk) ≤ ρ2kV (ξ0) and E[‖ξk − ξ∗‖2] ≤ ρ2k
(
cond(P )‖ξ0 − ξ∗‖2
)
.
5.2. Analytical Proof for SAGA (Corollary 3)
To prove Statement 1, we set γ = −m to reflect the assumption fi ∈ F(m,L). Hence LMI (25)
becomes
[
(1− ρ2)p2 − 2λ1mL− 2λ2mL −αp2 + (L+m)(λ1 + λ2)
−αp2 + (L+m)(λ1 + λ2) p1 + α2p2 − 2(λ1 + λ2)
]
≤ 0 (61)
By Shur complements, LMIs (24) (25) are equivalent to
p1 + α
2p2 − 2λ2 ≤ 0 (62)
ρ2 ≥ 1− 1
n
−
(
α4p22
p1 + α2p2 − 2λ2
− α2p2
)
1
np1
(63)
ρ2 ≥ 1− 2(λ1 + λ2)mLp−12 −
(−αp2 + (L+m)(λ1 + λ2))2
(p1 + α2p2 − 2(λ1 + λ2))p2
(64)
We can see that (63) describes how ρ2 depends on n, while (64) describes how ρ2 depends on m
and L. We need the common feasible set for both (63) and (64).
More formally, given the testing rate ρ2 = 1−min
{
2Lα−1
(Lα−1)n , 2mα− αm
2
(1−Lα)L
}
, it is straight-
forward to verify 0 ≤ ρ2 ≤ 1 when α ≤ 12L . For this particular rate, the condition (62) (63) (64) is
feasible with p1 =
1
L
, p2 =
1
α
, λ1 = 0, and λ2 =
1
L
. By Theorem 2, (39) holds as desired. Simi-
larly, given the testing rate ρ2 = 1−min
{
9Lα−4
(3Lα−4)n , 2mα− 3αm
2
(4−3Lα)L
}
, we can choose p1 =
2
3L ,
p2 =
1
α
, λ1 = 0, and λ2 =
1
L
to prove the bound (40). Therefore, Statement 1 is true.
To prove Statement 2, we set γ = 0 in (25) to reflect the assumption fi ∈ F(0, L). Again, by
Schur complements, LMIs (24) (25) are equivalent to (62) (63) and
ρ2 ≥ 1− 2λ1mLp−12 −
(−αp2 + (L+m)λ1 + Lλ2)2
(p1 + α2p2 − 2λ1 − 2λ2)p2
(65)
Given the testing rate ρ2 = 1−min
{
2Lα−b
(Lα−b)n , 2(1 − b)mα−
m2(1−b)2α
(2−b−Lα)L
}
, it is straightforward
to verify 0 ≤ ρ2 ≤ 1 when b ≥ 2Lα. For this particular rate, the condition (62) (63) (65) is feasible
with p1 =
b
L
> 0, p2 =
1
α
, λ1 =
1−b
L
≥ 0, and λ2 = bL . By Theorem 2, (41) holds as desired.
When α = 13L , we can choose any b ∈ [23 , 1] and (41) holds. Hence we can easily obtain (42) by
choosing b = 56 and applying the fact
m
L
≤ 1.
To prove Statement 3, we set γ = L in (25) to reflect the assumption fi being L-smooth. Again,
by Schur complements, LMIs (24) (25) are equivalent to (62), (63) and
ρ2 ≥ 1− 2λ1mLp−12 + 2λ2L2p−12 −
(−αp2 + (L+m)λ1)2
(p1 + α2p2 − 2λ1 − 2λ2)p2
(66)
18
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Given the testing rate ρ2 = 1 − min
{
b−2
(b−1)n ,
3mα
2 − 2bL2α2
}
, it is straightforward to verify
0 ≤ ρ2 ≤ 1 when 2 ≤ b ≤ 3m4αL2 . For this particular rate, the condition (62) (63) (66) is feasible
with p1 = bα > 0, p2 =
1
α
, λ1 =
1
L
≥ 0, and λ2 = bα. Notice the facts m ≤ L and b ≥ 2 are
required when checking the feasibility of the LMI condition. By Theorem 2, (43) holds as desired.
When α = m
8L2
, we can choose any b ∈ [2, 3] and (43) holds. Hence we can easily obtain (44) by
choosing b = 3 and applying the fact m
L
≤ 1. Similarly, when α = m2
4(m2n+L2)
, we can choose any
2 ≤ b ≤ 3(m2n+L2)
L2
and (43) holds. Hence we can also obtain (45) by choosing b = 2(m
2n+L2)
L2
and
apply the fact 2m
2
2m2n+L2
≥ m2
8(m2n+L2)
. This completes the proof.
Remark 6 Based on the above proof, we can actually recover two other known results in Defazio
et al. (2014a). First, it is known that SAGA achieves the rate ρ2 = 1− m2(mn+L) given the assumption
fi ∈ F(m,L) and the stepsize α = 12(mn+L) . To recover this result, we first consider the case where
L ≥ 2m. Clearly αL < 12 . Then the formula (39) leads to a rate ρ2 = 1− mmn+L + m
2
(L+2mn)L . If
L ≥ 2m, then the above rate bound is always better than ρ2 = 1 − m2(mn+L) . On the other hand,
if L ≤ 2m, we can use p2 = 1α , λ1 = 0, λ2 = 1L and p1 = 0.75λ2 to prove the LMI condition is
feasible with ρ2 = 1−min
{
15mn−L
n(15mn+9L) ,
m
mn+L − 2m
2
(3L+5mn)L
}
. Under the condition L ≤ 2m, this
rate bound is always lower than 1 − m2(mn+L) . Consequently, we successfully recover the existing
rate bound ρ2 = 1 − m2(mn+L) for α = 12(mn+L) . Second, when fi is only assumed to convex and
smooth, i.e. fi ∈ F(0, L), we can also choose α = 13(mn+L) in (41) and set b = 23 . This leads to
E
[
‖xk − x∗‖2
]
≤
(
1−min
{
2m
L+ 2mn
,
2m
9(L+mn)
− m
2
27L2 + 36mnL
})k
R0
=
(
1− 2m
9(L+mn)
+
m2
27L2 + 36mnL
)k
R0
≤
(
1− m
6(mn+ L)
)k
R0
(67)
where R0 = ‖x0−x∗‖2+ 29(mn+L)L
∑n
i=1 ‖y0i −∇fi(x∗)‖2. The rate bound here is also consistent
with the known result in Defazio et al. (2014a).
5.3. Analytical Proof for Finito (Corollary 4)
First, we need the following linear algebra result to relax the LMI conditions (28) (29) to some
simpler testing conditions.
Lemma 7 Suppose Y11, Y12, Y22, α, and n are scalars. In addition, Y11 ≤ 0, Y22 ≤ 0, α > 0 and
n > 0. The following two statements are true.
1. If Y12 ≤ 0, then
[
Y11 + αnY12 Y12
Y12 Y22 +
Y12
αn
]
≤ 0.
2. If Y12 ≥ 0, then
[
Y11 − αnY12 Y12
Y12 Y22 − Y12αn
]
≤ 0.
19
HU SEILER RANTZER
Proof Statement 1 can be proved using the fact
[
αn 1
1 1
αn
]
≥ 0. Statement 2 can be proved using the
fact
[
αn −1
−1 1
αn
]
≥ 0.
Next, we relax the LMIs (28) (29) to some simpler (but more conservative) testing conditions.
The relaxed conditions are sufficiently useful for analysis of Finito under some big data condition.
Corollary 8 Consider Finito (10) (11) with ik sampled from a uniform distribution. Define v
k =
1
n
∑n
i=1 x
k
i − α
∑n
i=1 y
k
i . Suppose g ∈ S(m,L) with m > 0, and γ is defined by (4) based on
assumptions on fi. Given any testing rate 1− 1n ≤ ρ2 ≤ 1, if there exist positive scalars p1, p4, and
nonnegative scalars λ1, λ2 such that
α2 − 2λ2 + p1 < 0 (68)
n(1− ρ2)p1 − p1 + 2α2 −
2α4
α2 − 2λ2 + p1
≤ 0 (69)
n(1− ρ2)p4 − p4 +
2
n2
− 2α
2
n2(α2 − 2λ2 + p1)
≤ 0 (70)
p4 − ρ2 + 2Lγλ2 − 2Lmλ1 + 1−
((L+m)λ1 + (L− γ)λ2 − α)2
α2 − 2λ1 − 2λ2 + p1
≤ 0 (71)
then Finito (10) (11) with any initial condition x0i ∈ Rp and y0i ∈ Rp satisfies
E
[
p4
n
∑
i=1
‖xki − x∗‖2 + p1
n
∑
i=1
‖yki −∇fi(x∗)‖2 + ‖vk − x∗‖2
]
≤ ρ2kR0 (72)
where R0 = p4
∑n
i=1 ‖x0i − x∗‖2 + p1
∑n
i=1 ‖y0i −∇fi(x∗)‖2 + ‖v0 − x∗‖2.
Proof Consider p2 = α
2, p3 = −αn , and p5 = 1n2 . Clearly, we have
[
p1 + np2 np3
np3 p4 + np5
]
=
[
p1 0
0 p4
]
+ n
[
−α
1
n
]
[
−α 1
n
]
> 0 (73)
Applying Schur complement with respect to the (3, 3)-entry of (28), we can immediately rewrite
(28) as p1 + p2 − 2λ2 = α2 − 2λ1 + p1 ≤ 0 and
[
Y11+αnY12 Y12
Y12 Y22+
Y12
αn
]
≤ 0, where Y11 is equal to
the left side of (69), Y22 is equal to the left side of (70), and Y12 =
α3
n(α2−2λ2+p1) −
α
n
. Similarly, we
can apply Schur complement with respect to the (3, 3)-entry of (29) and rewrite (29) as p1 + p2 −
2λ1−2λ2 ≤ 0 and
[
Z11−αnZ12 Z12
Z12 Z22−Z12αn
]
≤ 0, where Z11 = p1(1−ρ2− 1n), Z22 = p4(1−ρ2− 1n),
and Z12 is equal to the multiplication of α and the left side of (71). Based on the conditions in the
corollary statement, we can directly apply Lemma 7 to show that (28) and (29) hold. Finally, notice
[
p1In + p2ee
T p3ee
T
p3ee
T p4In + p5ee
T
]
=
[
p1 0
0 p4
]
⊗ In +
[
−αe
1
n
e
]
[
−αeT 1
n
eT
]
(74)
We can directly apply Statement 3 in Theorem 2 to complete the proof of this corollary.
20
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Now we can choose p1, p4, λ1 and λ2 to prove Corollary 4. Notice (69), (70), and (71) are
equivalent to
ρ2 ≥ 1− 1
n
+
2α2(p1 − 2λ2)
np1(α2 − 2λ2 + p1)
(75)
ρ2 ≥ 1− 1
n
+
2(p1 − 2λ2)
n3p4(α2 − 2λ2 + p1)
(76)
ρ2 ≥ 1− 2Lmλ1 + 2Lγλ2 + p4 −
((L+m)λ1 + (L− γ)λ2 − α)2
α2 − 2λ1 − 2λ2 + p1
(77)
1. To prove Statement 1, we set γ = −m to reflect the assumption fi ∈ F(m,L). We choose
p1 =
α
L
, p4 = 0.5mα, λ1 = 0, and λ2 =
α
L
. Then (75), (76), and (77) become
ρ2 ≥ 1− 1
n
+
2αL
n(1− αL) (78)
ρ2 ≥ 1− 1
n
+
4
n3mα(1− Lα) (79)
ρ2 ≥ 1− 1.5mα + m
2α
L(1− Lα) (80)
When α = 15L , the testing rate ρ
2 = 1 − min
{
1
2n ,
m
20L
}
satisfies (78) and (80). In addi-
tion, this testing rate also satisfies (79) under the further assumption n ≥
√
50L
m
. Therefore,
Statement 1 directly follows from Corollary 8.
2. To prove Statement 2, we set γ = 0 to reflect the assumption fi ∈ F(0, L). We choose
p1 =
α
2L , p4 = 0.5mα, λ1 =
α
2L , and λ2 =
α
2L . Then (75), (76), and (77) become
ρ2 ≥ 1− 1
n
+
4αL
n(1− 2αL) (81)
ρ2 ≥ 1− 1
n
+
4
n3mα(1 − 2Lα) (82)
ρ2 ≥ 1− 0.5mα+ m
2α
2L(3 − 2Lα) (83)
When α = 18L , the testing rate ρ
2 = 1 − min
{
1
3n ,
5m
176L
}
satisfies (81) and (83). In addi-
tion, this testing rate also satisfies (82) under the further assumption n ≥
√
64L
m
. Therefore,
Statement 2 directly follows from Corollary 8.
3. To prove Statement 3, we set γ = L to reflect the assumption fi being L-smooth. We choose
p1 = 4α
2, p4 = 0.75mα, λ1 =
α
L
, and λ2 = 4α
2. Then (75), (76), and (77) become
ρ2 ≥ 1− 1
3n
(84)
ρ2 ≥ 1− 1
n
+
32
9n3mα
(85)
ρ2 ≥ 1− 1.25mα + 8L2α2 + m
2α
L(2 + 3Lα)
(86)
21
HU SEILER RANTZER
When α = 12nm , the testing rate ρ
2 = 1 − 13n satisfies (84). This testing rate also satisfies
(85) if n ≥ 11. Moreover, this testing rate also satisfies (86) under the further assumption
n ≥ 48L2
m2
. Due to the fact L ≥ m, we always have n ≥ 11 when n ≥ 48L2
m2
. Therefore,
Statement 3 directly follows from Corollary 8.
Now the proof is complete.
5.4. Analytical Proof for SDCA (Corollary 5)
To prove Statement 1 in Corollary 5, we set γ = 0 to reflect the assumption fi ∈ F(0, L). When
α ≤ 2
L+2mn , we have α̃ = αmn ≤ 2mnL+2mn < 1. Given the testing rate ρ2 = 1 − mα = 1 − α̃n ,
it is straightforward to verify 0 ≤ ρ2 ≤ 1 when α ≤ 2
L+2mn . For this particular rate, the coupled
LMI conditions (34) and (35) in Statement 2 of Theorem 2 are feasible with p1 =
1
α̃
, p2 =
1−α̃
α̃2
,
λ1 = 0, and λ2 =
(1−α̃)mn
α̃L
. To see this, first notice p2 > 0 and 0 < λ2 ≤ 12 given the fact
α̃ ≤ 2mn
L+2mn < 1. With the given rate ρ
2 = 1 − α̃
n
and the current choice of (p1, p2, λ1, λ2), LMIs
(34) and (35) become
[
n
α̃
(1− ρ2)− 1 0
0 1− 2λ2
]
=
[
0 0
0 1− 2λ2
]
≤ 0 (87)
[
−1− 2n(1−α̃)
α̃
+ (1− ρ2)(n
α̃
+ n
2(1−α̃)
α̃2
) 0
0 1− 2λ2
]
=
[
n(1− 1
α̃
) 0
0 1− 2λ2
]
≤ 0 (88)
The above LMIs hold due to the fact λ2 ≤ 12 and α̃ < 1. By Theorem 2, (49) holds.
To prove Statement 2 in Corollary 5, we set γ = 0 to reflect the assumption fi ∈ F(0, L). When
α ≤ m
L2+m2n
, we have α̃ = αmn ≤ m2n
L2+m2n
< 1. Given the testing rate ρ2 = 1−mα = 1− α̃
n
, it is
straightforward to verify 0 ≤ ρ2 ≤ 1 when α ≤ m
L2+m2n
. For this particular rate, the coupled LMI
conditions (34) and (35) in Statement 2 of Theorem 2 are feasible with p1 =
1
α̃
, p2 =
1−α̃
α̃2
, λ1 =
(1−α̃)mn
α̃L
, and λ2 =
1
2 . With the given rate ρ
2 = 1− α̃
n
and the current choice of (p1, p2, λ1, λ2), the
left side of (34) becomes a zero matrix and clearly (34) holds. In addition, (35) becomes
[
n(1− 1
α̃
) + L
2
m2
0
0 −2λ1
]
≤ 0 (89)
The above inequality holds since we have α̃ ≤ m2n
L2+m2n . By Theorem 2, we can conclude that
Statement 2 is true.
6. Conclusion and Future Work
In this paper, we developed a unified routine for analysis of stochastic optimization methods and
demonstrate the utility of our proposed routine by analyzing SAGA, Finito, and SDCA under vari-
ous conditions (with or without individual convexity, etc). Our routine includes five steps:
1. Choose proper (Ai, Bi, C) to rewrite the stochastic optimization method as a special case of
our general jump system model (6).
2. Apply Theorem 1 to obtain an LMI testing condition for the linear convergence rate analysis.
22
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
3. Test LMI (22) numerically to narrow down Lyapunov function structures and useful function
inequalities required by the further analysis.
4. Apply linear algebra tricks to convert LMI (22) into some equivalent small LMIs whose size
do not depend on n.
5. Construct analytical proofs for linear convergence rate bounds using the resultant small LMIs.
The first step is case-dependent. However, this step is usually straightforward and technically
not difficult. The second and third steps are completely automated and require no tricks at all.
These two steps can even be done for non-uniform sampling strategy if we slightly modify the
LMI condition in Theorem 1. In principle, one can implement (22) once, and just needs to update
(Ãi, B̃i, C̃) matrices given any new method. The fourth step is case-dependent but only requires
very basic linear algebra tricks. As long as the assumptions on fi are the same for all i and a uniform
sampling is used, one should be able to obtain such equivalent small LMIs. The fifth step is the most
technical step. This step is case-dependent and can be non-trivial for some complicated algorithms,
e.g. Finito. However, at least one can numerically solve the resultant small LMIs using semidefinite
programming solvers and use the numerical results to guide the analytical proofs.
In the third step, one may realize that LMI (22) is not sufficient for analysis of certain meth-
ods, e.g. SAG. Then one needs to exploit more advanced function properties and incorporate more
advanced quadratic constraints into the LMI formulations. See Lessard et al. (2016) and Hu and
Lessard (2017) for detailed discussions on weighted off-by-one IQC and other advanced quadratic
constraints. The applications of these advanced quadratic constraints require much heavier mathe-
matical notation. A detailed analysis of more complicated stochastic methods using such advanced
quadratic constraints is beyond the scope of this paper, and will be pursued in future research.
We believe our work is just a starting point for further studies of empirical risk minimization
using tools from control theory. We briefly comment on several possible extensions of our proposed
framework to conclude the paper.
Non-uniform sampling strategy: Theorem 1 can be easily modified to handle non-uniform
sampling strategy. However, the LMI dimension reduction in this case is non-trivial since the solu-
tion for the resultant LMI cannot be easily parameterized using a few scalar decision variables. It
requires more efforts to investigate how to reduce the dimension of the resultant LMI in this case. A
possible solution may involve properly scaling Lyapunov functions with the sampling distribution.
Stochastic quadratic constraints and SVRG: SVRG (Johnson and Zhang, 2013) is an impor-
tant method which cannot be represented by our jump system model (6). The main issue is that
SVRG has a deterministic periodic component which cannot be captured by a jump system model.
One needs to take the periodicity and the randomness into accounts simultaneously. It will be in-
teresting to develop an LMI-based approach for automated analysis and design of SVRG and its
non-convex variants (Allen-Zhu and Hazan, 2016). One possible idea is to absorb the randomness
and the periodicity into an uncertainty block whose input/output behavior can be characterized by
some stochastic quadratic constraints. Similar ideas have already been used to recover the standard
convergence results of the SG method (Hu, 2016, Chapter 6).
Automated design procedure of stochastic optimization methods: One may apply our pro-
posed LMIs to numerically design stochastic optimization methods for practical problems. A direct
design approach relies on grid search and is similar to the design procedure in Lessard et al. (2016,
23
HU SEILER RANTZER
Section 6). A more general design approach may be developed using the following sparse optimiza-
tion formulation. Based on our general model (6), a stochastic method is typically characterized by
the matrices (Ai, Bi, C). Hence, the design of stochastic methods can be formulated as a sparse
optimization problem where we need to select (Ai, C) and sparse Bi for i = 1, . . . , n to minimize
the convergence rate ρ under the LMI constraint (22) and some other structure constraints. The
sparsity of Bi is important since it ensures the per-iteration cost of the resultant method to be low.
Larger family of non-convex functions: Notice the main assumption in this paper is g ∈
S(m,L), and the convexity of g is not required. There exist convergence results for other families
of non-convex functions, e.g. functions satisfying Polyak-Lojasiewicz (PL) inequality (Karimi et al.,
2016; Reddi et al., 2016a,b). It is interesting to investigate how to extend our quadratic constraint
approach for more general non-convex functions.
Accelerated methods: Various acceleration techniques (Nitanda, 2014; Lin et al., 2015; Shalev-
Shwartz and Zhang, 2016; Defazio, 2016) have been proposed to improve the convergence guaran-
tees of the stochastic optimization methods when the big data condition is not met. We will extend
our LMI method to analyze stochastic accelerated methods (with or without individual convexity)
in the future.
Randomly-Permuted ADMM with multiple blocks: The alternating direction method of mul-
tipliers (ADMM) (Boyd et al., 2011) is an important distributed optimization algorithm. There are
some initial convergence results on ADMM with multiple blocks (Hong and Luo, 2012; Chen et al.,
2016). The quantification of the mean-square convergence rates of the so-called randomly-permuted
ADMM with multiple blocks (Sun et al., 2015) remains an open topic. IQCs have been successfully
applied to analyze ADMM with two blocks (Nishihara et al., 2015). The extension of jump system
theory for random-permuted ADMM with multiple blocks is an important future task.
Asynchronous settings: In parallel computing, the algorithm performance will typically be
impacted by the communication delay and memory contention (Recht et al., 2011; Zhang and Kwok,
2014). In this case, it is necessary to assess the robustness of the optimization methods with respect
to the delays in the gradient update. There exist many IQCs for time-varying delays in the controls
literature (Kao, 2012; Kao and Lincoln, 2004; Kao and Rantzer, 2007; Pfifer and Seiler, 2015). One
may apply a scaling trick to tailor these IQCs for convergence rate analysis (Hu and Seiler, 2016).
Hence the IQC analysis may be extended to study the impacts of time delays on SAG, SAGA, Finito,
SDCA and other related stochastic optimization methods.
Acknowledgments
The authors would like to thank the anonymous reviewers for their constructive comments. Bin Hu
and Peter Seiler were supported by the National Science Foundation under Grant No. NSF-CMMI-
1254129 entitled CAREER: Probabilistic Tools for High Reliability Monitoring and Control of
Wind Farms. Bin Hu and Peter Seiler were also supported by the NASA Langley NRA Cooper-
ative Agreement NNX12AM55A entitled Analytical Validation Tools for Safety Critical Systems
Under Loss-ofControl Conditions, Dr. Christine Belcastro technical monitor. Anders Rantzer is a
member of the LCCC Linnaeus Center and the ELLIIT Excellence Center at Lund University. His
contribution was supported by the Swedish Research Council, grant 2016-04764, and the Institute
for Mathematics and its Applications at University of Minnesota.
24
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
References
Zeyuan Allen-Zhu and Elad Hazan. Variance reduction for faster non-convex optimization. In
Proceedings of The 33rd International Conference on Machine Learning, pages 699–707, 2016.
S. Bittanti and P. Colaneri. Periodic systems: filtering and control. Springer Science & Business
Media, 2008.
L. Bottou and Y. LeCun. Large scale online learning. In Advances in neural information processing
systems, pages 217–224, 2003.
S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein. Distributed optimization and statistical
learning via the alternating direction method of multipliers. Foundations and Trends R© in Ma-
chine Learning, 3(1):1–122, 2011.
C. Chen, B. He, Y. Ye, and X. Yuan. The direct extension of ADMM for multi-block convex
minimization problems is not necessarily convergent. Mathematical Programming, 155(1-2):
57–79, 2016.
O. Costa, M. Fragoso, and R. Marques. Discrete-time Markov jump linear systems. Springer Science
& Business Media, 2006.
Inc. CVX Research. CVX: Matlab software for disciplined convex programming, version 2.0.
http://cvxr.com/cvx, August 2012.
A. Defazio. A simple practical accelerated method for finite sums. In Advances in Neural Informa-
tion Processing Systems, pages 676–684, 2016.
A. Defazio, F. Bach, and S. Lacoste-Julien. SAGA: A fast incremental gradient method with support
for non-strongly convex composite objectives. In Advances in Neural Information Processing
Systems, 2014a.
A. Defazio, J. Domke, and T. Caetano. Finito: A faster, permutable incremental gradient method for
big data problems. In Proceedings of the 31st International Conference on Machine Learning,
pages 1125–1133, 2014b.
V. Dragan, T. Morozan, and A. Stoica. Mathematical methods in robust control of discrete-time
linear stochastic systems. Springer, 2010.
Y. Drori and M. Teboulle. Performance of first-order methods for smooth convex minimization: a
novel approach. Mathematical Programming, 145(1-2):451–482, 2014.
M. Grant and S. Boyd. Graph implementations for nonsmooth convex programs. In Recent Ad-
vances in Learning and Control, Lecture Notes in Control and Information Sciences, pages 95–
110. Springer-Verlag Limited, 2008.
J. Hespanha. Linear systems theory. Princeton university press, 2009.
M. Hong and Z. Luo. On the linear convergence of the alternating direction method of multipliers.
arXiv preprint arXiv:1208.3922, 2012.
25
HU SEILER RANTZER
B. Hu. A Robust Control Perspective on Optimization of Strongly-Convex Functions. PhD thesis,
University of Minnesota, 2016.
B. Hu and L. Lessard. Dissipativity theory for Nesterov’s accelerated method. In Proceedings of
the 34th International Conference on Machine Learning, 2017.
B. Hu and P. Seiler. Exponential decay rate conditions for uncertain linear systems using integral
quadratic constraints. IEEE Transactions on Automatic Control, 61(11):3561–3567, 2016.
R. Johnson and T. Zhang. Accelerating stochastic gradient descent using predictive variance reduc-
tion. In Advances in Neural Information Processing Systems, pages 315–323, 2013.
C. Kao. On stability of discrete-time LTI systems with varying time delays. IEEE Transactions on
Automatic Control, 57:1243–1248, 2012.
C. Kao and A. Rantzer. Stability analysis of systems with uncertain time-varying delays. Automat-
ica, 43(6):959–970, 2007.
C.Y. Kao and B. Lincoln. Simple stability criteria for systems with time-varying delays. Automatica,
40:1429–1434, 2004.
H. Karimi, J. Nutini, and M. Schmidt. Linear convergence of gradient and proximal-gradient meth-
ods under the Polyak-Lojasiewicz condition. In Joint European Conference on Machine Learning
and Knowledge Discovery in Databases, pages 795–811, 2016.
D. Kim and J. Fessler. Optimized first-order methods for smooth convex minimization. Mathemat-
ical programming, 159(1-2):81–107, 2016.
L. Lessard, B. Recht, and A. Packard. Analysis and design of optimization algorithms via integral
quadratic constraints. SIAM Journal on Optimization, 26(1):57–95, 2016.
H. Lin, J. Mairal, and Z. Harchaoui. A universal catalyst for first-order optimization. In Advances
in Neural Information Processing Systems, pages 3384–3392, 2015.
A. Megretski and A. Rantzer. System analysis via integral quadratic constraints. IEEE Transactions
on Automatic Control, 42:819–830, 1997.
R. Nishihara, L. Lessard, B. Recht, A. Packard, and M. Jordan. A general analysis of the conver-
gence of ADMM. In Proceedings of the 32nd International Conference on Machine Learning,
pages 343–352, 2015.
A. Nitanda. Stochastic proximal gradient descent with acceleration techniques. In Advances in
Neural Information Processing Systems, pages 1574–1582, 2014.
H. Pfifer and P. Seiler. Integral quadratic constraints for delayed nonlinear and parameter-varying
systems. Automatica, 56:36 – 43, 2015.
B. Recht, C. Re, S. Wright, and F. Niu. Hogwild: A lock-free approach to parallelizing stochastic
gradient descent. In Advances in Neural Information Processing Systems, pages 693–701, 2011.
26
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
S. Reddi, A. Hefny, S. Sra, B. Póczós, and A. Smola. Stochastic variance reduction for nonconvex
optimization. In Proceedings of The 33rd International Conference on Machine Learning, pages
314–323, 2016a.
S. Reddi, S. Sra, B. Póczós, and A. Smola. Fast incremental method for nonconvex optimization.
In IEEE Conf. on Decision and Control, pages 1971–1977, 2016b.
H. Robbins and S. Monro. A stochastic approximation method. The Annals of Mathematical Statis-
tics, 22(3):400–407, 1951.
N. Roux, M. Schmidt, and F. Bach. A stochastic gradient method with an exponential convergence
rate for strongly-convex optimization with finite training sets. In Advances in Neural Information
Processing Systems, 2012.
M. Schmidt, N. Roux, and F. Bach. Minimizing finite sums with the stochastic average gradient.
ArXiv preprint, 2013.
S. Shalev-Shwartz and T. Zhang. Stochastic dual coordinate ascent methods for regularized loss.
The Journal of Machine Learning Research, 14(1):567–599, 2013.
S. Shalev-Shwartz and T. Zhang. Accelerated proximal stochastic dual coordinate ascent for regu-
larized loss minimization. Mathematical Programming, 155:105–145, 2016.
Shai Shalev-Shwartz. SDCA without duality. arXiv preprint arXiv:1502.06177, 2015.
Shai Shalev-Shwartz. SDCA without duality, regularization, and individual convexity. In Proceed-
ings of the 33rd International Conference on Machine Learning, pages 747–754, 2016.
R. Sun, Z. Luo, and Y. Ye. On the expected convergence of randomly permuted ADMM. arXiv
preprint arXiv:1503.06387, 2015.
A. Taylor, J. Hendrickx, and F. Glineur. Smooth strongly convex interpolation and exact worst-case
performance of first-order methods. Mathematical Programming, 161(1-2):307–345, 2017.
C. Teo, A. Smola, S. Vishwanathan, and Q. Le. A scalable modular convex solver for regular-
ized risk minimization. In Proceedings of the 13th ACM SIGKDD international conference on
Knowledge discovery and data mining, pages 727–736, 2007.
K.C. Toh, M.J. Todd, and R.H. Tutuncu. SDPT3 - a matlab software package for semidefinite
programming. Optimization Methods and Software, 11:545–581, 1999.
R.H Tutuncu, K.C. Toh, and M.J. Todd. Solving semidefinite-quadratic-linear programs using
SDPT3. Mathematical Programming Ser. B, 95:189–217, 2003.
R. Zhang and J. Kwok. Asynchronous distributed ADMM for consensus optimization. In Proceed-
ings of the 31st International Conference on Machine Learning, pages 1701–1709, 2014.
27
HU SEILER RANTZER
Appendix A. Jump System Formulations of SAG, Finito, and SDCA
1. (SAG): Define wk =
[
∇f1(xk)T · · · ∇fn(xk)T
]T
, and then the SAG gradient update rule (8)
can still be rewritten as (15). Notice
∑n
i=1 y
k
i = (e
T ⊗ Ip)yk and ∇fik(xk) − ykik = (e
T
ik
⊗
Ip)(w
k − yk). Thus the iteration rule (9) can be rewritten as follows:
xk+1 = xk − α
(
∇fik(xk)− ykik
n
+
1
n
n
∑
i=1
yki
)
= xk − α
n
(eTik ⊗ Ip)(w
k − yk)− α
n
(eT ⊗ Ip)yk
= xk − α
n
(
(e− eik)T ⊗ Ip
)
yk − α
n
(eTik ⊗ Ip)w
k
(90)
At this point, both the gradient update in (15) and the iteration update in (90) depend on
wk =
[
∇f1(xk)T · · · ∇fn(xk)T
]T
. The key step in the modeling is to ”separate out” this
nonlinear term. Setting vk = xk and then wk =
[
∇f1(vk)T · · · ∇fn(vk)T
]T
. Now the
update rules in (15) and (90) can be expressed as:
[
yk+1
xk+1
]
=
[
(In − eikeTik)⊗ Ip 0̃⊗ Ip
−α
n
(e− eik)T ⊗ Ip Ip
] [
yk
xk
]
+
[
(eike
T
ik
)⊗ Ip
(−α
n
eTik)⊗ Ip
]
wk
vk =
[
0̃T ⊗ Ip Ip
]
[
yk
xk
]
wk =



∇f1(vk)
...
∇fn(vk)



(91)
which is exactly in the form of the general jump system model (6) with ξk =
[
yk
xk
]
. Recall
that w∗ =
[
∇f1(x∗)T . . . ∇fn(x∗)T
]T
. It is trivial to set ξ∗ =
[
(w∗)T (x∗)T
]T
, and
verify that (18) holds.
2. (Finito): Recall that we denote yk =
[
(yk1 )
T · · · (ykn)T
]T
and xk =
[
(xk1)
T · · · (xkn)T
]T
.
We set vk as
vk =
1
n
n
∑
i=1
xki − α
n
∑
i=1
yki (92)
Again, we set wk =
[
∇f1(vk)T · · · ∇fn(vk)T
]T
. Then we can immediately rewrite (11) as
yk+1 =
(
(In − eikeTik)⊗ Ip
)
yk +
(
(eike
T
ik
)⊗ Ip
)
wk (93)
It is also straightforward to rewrite (10) as
xk+1 =
(
(In − eikeTik +
1
n
(eike
T ))⊗ Ip
)
xk − α
(
(eike
T )⊗ Ip
)
yk (94)
28
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
Therefore, we can combine (92), (93), and (94) to obtain
[
yk+1
xk+1
]
=
[
(In − eikeTik)⊗ Ip (0̃0̃T )⊗ Ip
−α(eikeT )⊗ Ip (In − eikeTik +
1
n
(eike
T ))⊗ Ip
] [
yk
xk
]
+
[
(eike
T
ik
)⊗ Ip
(0̃0̃T )⊗ Ip
]
wk
vk =
[
−αeT ⊗ Ip 1neT ⊗ Ip
]
[
yk
xk
]
wk =



∇f1(vk)
...
∇fn(vk)



(95)
which is exactly in the form of the general jump system model (6) with ξk =
[
yk
xk
]
.
Notice ξk ∈ R(n+1)p for SAG and SAGA, but ξk ∈ R2np for Finito. Hence in general, Finito
requires more memory compared with SAG and SAGA. Based on the fact
∑n
i=1∇fi(x∗) =
0, we can set ξ∗ =
[
w∗
e⊗ x∗
]
, and verify that (18) holds. Therefore, if ξk converges to ξ∗,
then yki converges to ∇fi(x∗) and xki converges to x∗.
3. (SDCA): We still have yk =
[
(yk1 )
T · · · (ykn)T
]T
. The update rule (13) can be rewritten
as
xk =
1
mn
(eT ⊗ Ip)yk (96)
Again, wk =
[
∇f1(vk)T · · · ∇fn(vk)T
]T
. Hence we can set vk = xk and rewrite the update
rule (14) as
yk+1 =
(
(In − αmneikeTik)⊗ Ip
)
yk − αmn
(
(eike
T
ik
)⊗ Ip
)
wk (97)
We can augment (96) and (97) as
yk+1 =
(
(In − αmneikeTik)⊗ Ip
)
yk − αmn
(
(eike
T
ik
)⊗ Ip
)
wk
vk =
(
1
mn
eT ⊗ Ip
)
yk
wk =



∇f1(vk)
...
∇fn(vk)



(98)
which is exactly in the form of the general jump system model (6) with ξk = yk. Notice the
state ξk is completely determined by yk, and does not directly depend on xk.
Appendix B. Numerical Tests Using the LMI Condition in Theorem 1
We can numerically solve LMI (22) in Theorem 1 and get some rough ideas of the feasibility of the
proposed LMI conditions.
29
HU SEILER RANTZER
First, we apply the proposed LMI condition to analyze the convergence rate of SAGA. The most
relevant existing result for this case was presented in Defazio et al. (2014a, Section 2) and states
the following fact. Under the assumption that g ∈ F(m,L) and fi ∈ F(m,L), the SAGA iteration
with the stepsize α = 13L converges at a linear rate ρ =
√
1−min{ m3L , 14n} in the mean square
sense. Therefore, for any m, L, and n, we can choose ρ =
√
1−min{ m3L , 14n} and numerically test
the feasibility of the resultant LMI (22) using CVX (CVX Research, 2012; Grant and Boyd, 2008)
with the solver SDPT3 (Tutuncu et al., 2003; Toh et al., 1999). As discussed before, we should set
ν = γ = −m to reflect the assumptions g ∈ F(m,L) and fi ∈ F(m,L). A practical issue is
that the LMI is homogeneous, i.e. if (P̃ , λ1, λ2) is a feasible solution then (cP̃ , cλ1, cλ2) is also a
feasible solution for any c > 0. This homogeneity can cause numerical issues. One method to break
this homogeneity is to replace P̃ > 0 with the condition P̃ ≥ 10−2I . Based on some preliminary
feasibility tests with relatively small n (n < 100), the proposed LMI remains feasible even if the
following simple parameterization of P̃ is used
P̃ =
[
p1In 0̃
0̃T p2
]
(99)
We notice that LMI (22) seems always feasible with the choice of ρ =
√
1−min{ m3L , 14n}. This
numerically confirms the existing rate result for n being up to several hundred. We further notice
that the LMI can be feasible with ρ2 smaller than 1−min{ m3L , 14n}. This indicates that one may get
sharper rate bounds for SAGA using our proposed LMI. Finally, treating P̃ as an unknown matrix
or parameterizing P̃ as (99) often does not change the feasibility of the resultant LMI. This implies
that adopting the parameterization (99) does not introduce further conservatism into our analysis.
Similar testing can also be performed if fi is only assumed to be L-smooth. We only need to
modify the value of γ to be L. The numerical results suggest that using a simple parameterization
(99) does not introduce further conservatism in this case. We can also perform such naive numerical
analysis for SDCA, Finito and SAG for n being up to several hundred. The numerical results
obtained by the proposed semidefinite programs actually inspire our analytical proofs for SAGA,
SDCA, and Finito.
Appendix C. Proof of Theorem 2
The proof is based on the following key linear algebra result which can be used to transform certain
high dimensional LMIs into two much smaller coupled LMIs.
Lemma 9 The following statements are true:
1. µ1In + q1ee
T > 0 if and only if µ1 > 0 and µ1 + nq1 > 0.
2.
[
µ1In + q1ee
T µ3In + q3ee
T
µ3In + q3ee
T µ2In + q2ee
T
]
≤ 0 (100)
30
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
if and only if
[
µ1 µ3
µ3 µ2
]
≤ 0, (101)
[
µ1 µ3
µ3 µ2
]
+ n
[
q1 q3
q3 q2
]
≤ 0 (102)
3.


µ1In + q1ee
T q4e µ6In + q6ee
T
q4e
T µ2 q5e
T
µ6In + q6ee
T q5e µ3In + q3ee
T

 ≤ 0 (103)
if and only if


µ1 0 µ6
0 µ2 0
µ6 0 µ3

 ≤ 0, (104)


µ1 + nq1
√
nq4 µ6 + nq6√
nµ4 µ2
√
nq5
µ6 + nq6
√
nq5 µ3 + nq3

 ≤ 0 (105)
4.


µ1In + q1ee
T µ4In + q4ee
T µ6In + q6ee
T
µ4In + q4ee
T µ2In + q2ee
T µ5In + q5ee
T
µ6In + q6ee
T µ5In + q5ee
T µ3In + q3ee
T

 ≤ 0 (106)
if and only if


µ1 µ4 µ6
µ4 µ2 µ5
µ6 µ5 µ3

 ≤ 0, (107)


µ1 µ4 µ6
µ4 µ2 µ5
µ6 µ5 µ3

+ n


q1 q4 q6
q4 q2 q5
q6 q5 q3

 ≤ 0 (108)
Proof Let Q ∈ Rn×(n−1) be a matrix such that
[
e√
n
Q
]
is orthogonal. Then
[
e√
n
Q
]T
(µ1In + q1ee
T )
[
e√
n
Q
]
= diag(µ1 + nq1, µ1, . . . , µ1) (109)
Statement 1 directly follows since
[
e√
n
Q
]
is invertible. Similarly, Statement 2 can be immediately
proved using the following fact:
[
e√
n
0̃ Q 0Q
0̃ e√
n
0Q Q
]T
[
µ1In + q1ee
T µ3In + q3ee
T
µ3In + q3ee
T µ2In + q2ee
T
]
[
e√
n
0̃ Q 0Q
0̃ e√
n
0Q Q
]
(110)
=diag
([
µ1 + nq1 µ3 + nq3
µ3 + nq3 µ2 + nq2
]
,
[
µ1 µ3
µ3 µ2
]
⊗ In−1
)
(111)
31
HU SEILER RANTZER
Statement 4 can be proved using a similar argument. Finally, Statement 3 can be proved using
Statement 2 and a Schur complement argument.
When analyzing SDCA, we can apply Statement 2 of the above lemma to convert LMI (22) into
two coupled 2×2 LMIs whose feasibility can be checked analytically. Similarly, Statement 3 of the
above lemma is useful for the rate analysis of SAGA, and Statement 4 of the above lemma is useful
for the rate analysis of Finito. Now we only need to substitute (Ãi, B̃i, C̃) and P̃ into the left side
of (22), and then Theorem 2 directly follows from the above lemma.
1. To prove Statement 1 of Theorem 2, recall that we have P̃ =
[
p1In 0̃
0̃T p2
]
. For SAGA, it is
straightforward to verify
1
n
n
∑
i=1
ÃiP̃ Ãi =
[
(p2α
2
n
+ n−1
n
p1)In − α
2p2
n2
eeT 0̃
0̃T p2
]
(112)
1
n
n
∑
i=1
B̃iP̃ Ãi =
[
−α2p2
n
In +
α2p2
n2
eeT
−αp2
n
eT
]
(113)
1
n
n
∑
i=1
B̃iP̃ B̃i =
p1 + α
2p2
n
In (114)
In addition, we have
[
C̃T D̃Tψ1
D̃Tψ2
]
([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0 1
1 0
])
[
D̃ψ1C̃ D̃ψ2
]
=
λ1


0n 0̃ 0n
0̃T −2mL m+L
n
eT
0n
m+L
n
e − 2
n2
eeT

+ λ2


0n 0̃ 0n
0̃T 2Lγ L−γ
n
eT
0n
L−γ
n
e − 2
n
In


(115)
Now we can directly prove Statement 1 of Theorem 2 by applying Statement 3 of Lemma 9
to convert (22) into small coupled LMIs.
2. To prove Statement 2 of Theorem 2, recall that we have
P̃ =
[
p1In + p2ee
T p3ee
T
p3ee
T p4In + p5ee
T
]
(116)
Hence it is straightforward to verify:
1
n
n
∑
i=1
ÃiP̃ Ãi =
[
W11 W12
W T12 W22
]
(117)
1
n
n
∑
i=1
B̃iP̃ Ãi =


−p2
n
In +
1
n
(p2 − p3α)eeT
−p3
n
In +
(n+1)p3
n2
eeT

 (118)
1
n
n
∑
i=1
B̃iP̃ B̃i =
p1 + p2
n
In (119)
32
ANALYSIS OF STOCHASTIC OPTIMIZATION METHODS USING JUMP SYSTEM THEORY
where W11, W12 and W22 are computed as
W11 =
(
p2
n
+
n− 1
n
p1
)
In +
(
(1− 2
n
)p2 − 2(1 − n−1)p3α+ (p4 + p5)α2
)
eeT (120)
W12 =
p3
n
In +
(n− 1− n−1)p3 − p4α− np5α
n
eeT (121)
W22 =
(
p5
n
+ (1− 1
n
)p4
)
In +
(
p4
n2
+ (1− 1
n2
)p5
)
eeT (122)
Then we can combine Statement 4 of Lemma 9 with the following formula to prove State-
ment 2 of Theorem 2.
[
C̃T D̃Tψ1
D̃Tψ2
]
([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0 1
1 0
])
[
D̃ψ1C̃ D̃ψ2
]
=
λ1




−2Lmα2eeT 2Lmα
n
eeT − (m+L)α
n
eeT
2Lmα
n
eeT −2mL
n2
eeT L+m
n2
eeT
− (m+L)α
n
eeT L+m
n2
eeT − 2
n2
eeT




+ λ2




2Lγα2eeT −2Lγα
n
eeT − (L−γ)α
n
eeT
−2Lγα
n
eeT 2Lγ
n2
eeT L−γ
n2
eeT
− (L−γ)α
n
eeT L−γ
n2
eeT − 2
n
In




(123)
3. To prove Statement 3 of Theorem 2, we have P̃ = p1In + p2ee
T and α̃ = αmn. Hence it is
straightforward to obtain the following formulas:
1
n
n
∑
i=1
ÃiP̃ Ãi =
(
p1(α̃
2 − 2α̃+ n)
n
+
p2α̃
2
n
)
In −
p2(2α̃ − n)
n
eeT (124)
1
n
n
∑
i=1
B̃iP̃ Ãi =
(
p1(α̃
2 − α̃)
n
+
p2α̃
2
n
)
In −
α̃p2
n
eeT (125)
1
n
n
∑
i=1
B̃iP̃ B̃i =
(p1 + p2)α̃
2
n
In (126)
In addition, we can directly obtain
[
C̃T D̃Tψ1
D̃Tψ2
]
([
λ1 0̃
T
0̃ λ2
n
In
]
⊗
[
0 1
1 0
])
[
D̃ψ1C̃ D̃ψ2
]
=
λ1
[
0n
L
mn2
eeT
L
mn2
eeT − 2
n2
eeT
]
+ λ2
[
2Lγ
m2n2
eeT L−γ
mn2
eeT
L−γ
mn2
eeT − 2
n
In
] (127)
Now Statement 3 of Theorem 2 directly follows from Statement 2 of Lemma 9.
Now the proof of Theorem 2 is complete.
33

