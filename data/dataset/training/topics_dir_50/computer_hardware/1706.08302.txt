A Publish/Subscribe System Using Causal
Broadcast Over Dynamically Built Spanning Trees
João Paulo de Araujo∗, Luciana Arantes†,
Elias P. Duarte Jr.‡, Luiz A. Rodrigues§ and Pierre Sens¶
∗†¶Sorbonne Universités, UPMC Univ Paris 06, CNRS, INRIA, LIP6 – Paris, France
‡Federal University of Paraná – Curitiba, Brazil
§Western Paraná State University – Cascavel, Brazil
Email: ∗joao.araujo@lip6.fr, †luciana.arantes@lip6.fr,
‡elias@inf.ufpr.br, §luiz.rodrigues@unioeste.br, ¶pierre.sens@lip6.fr
Abstract—In this paper we present VCube-PS, a topic-based
Publish/Subscribe system built on the top of a virtual hypercube-
like topology. Membership information and published messages
to subscribers (members) of a topic group are broadcast over
dynamically built spanning trees rooted at the message’s source.
For a given topic, delivery of published messages respects causal
order. Performance results of experiments conducted on the
PeerSim simulator confirm the efficiency of VCube-PS in terms of
scalability, latency, number, and size of messages when compared
to a single rooted, not dynamically, tree built approach.
I. INTRODUCTION
Publish/Subscribe (Pub/Sub) systems consist of distributed
nodes where one or more publishers produce messages
(events) consumed by subscribers. Communication between
publishers and subscribers is conducted by an overlay in-
frastructure, which is generally composed by a set of nodes
that organize themselves for ensuring the delivery of pub-
lished messages to all (preferably only) interested subscribers.
Therefore, publishers and subscribers exchange information
asynchronously, without interacting directly [1], [2].
There basically exist two models of Pub/Sub systems: topic-
based [3], [4], [5], [6] and content-based [7], [8]. In the
first one, subscribers share a common knowledge on a set of
available topics and every published message is labeled with
one of these topics. A subscriber can register its interest in
one or more topics, and then it receives all published messages
related to these topics In the content-based model, events are
structured in multiple attributes, and subscribers express their
interests by specifying constraints over the values of these
attributes [9].
The advantage of topic-based model is that events/messages
can be statically grouped into topics, the diffusion of messages
to subscribers is usually based on multicast groups, and the
interface offered to the user is simple. Even if it offers limited
expressiveness for subscribers [1], the topic-based approach
is widely used by applications such as chat message systems,
Twitter, mobile devices notifications framework (e.g. Google
Cloud Messaging), and many others. On the other hand,
content-based model provides more flexibility to subscribers
for defining their event interests, but at the expense of more
complex user interfaces and the need of filtering.
In this work, we are interested in topic-based Pub/Sub
systems and, particularly, in offering an efficient support
for publishers to send messages to subscribers, guaranteing
causal order among published messages, low latency, and load
balancing.
In our proposed system, a user (node) can subscribe or
unsubscribe to a topic t. After becoming a subscriber of t
and, therefore, member of the t’s group, a node publish a
message m associated to the topic t. The message m is sent
to all subscribers of t using a broadcast protocol on top of a
spanning tree, composed just by the subscribers, whose root is
the publisher node of m. This tree is dynamically built on the
top of a hypercube-like topology, extended from the one used
in VCube [10], that presents strong logarithmic properties. We
consider that nodes do not fail but can dynamically join to
(new subscription) or leave from (cancel subscription) one or
more topic groups.
VCube-PS also ensures causal ordering between published
messages related to the same topic: if a process published
a message after a second message was delivered to it, then
no process delivers the latter after the former. We believe
that in Pub/Sub systems the guarantee of published messages
respecting causal order is an important and useful feature. For
instance, in a discussion group, a question published to the
group should never be delivered to any subscriber after the
answer, also published in the group, since question and answer
are causally related. For sake of scalability, VCube-PS uses the
causal barrier principle for implementing such a causal order
[11] where a message carries information about only those
message on which it directly depends.
Many Pub/Sub systems in the literature are based on broad-
cast trees [3], [4], [12]. However, they use usually only one
single generated tree, whose maintenance is sometimes costly
when the membership of the system changes, nodes which
are not subscribers (forwarders) may take part in the tree
such as in Scribe Pub/Sub system [3], increasing latency of
message delivery, and the broadcast of a new publication
is carried out by a single root node which, consequently,
can become a bottleneck. In VCube-PS there is no single
root node, but each node that publishes a message becomes
ar
X
iv
:1
70
6.
08
30
2v
1 
 [
cs
.D
C
] 
 2
6 
Ju
n 
20
17
the root of the corresponding spanning tree, providing load
balancing. Furthermore, a spanning tree is composed only
by the subscribers of the same topic and does not include
forwarder nodes. A third point to emphasize is that very few
Pub/Sub systems in the literature (to the best of our knowledge,
just JEDI [7]) provide causal ordering of published messages.
Performance experiments were conducted on the PeerSim
simulator [13] and comparative performance results confirm
the advantages of using per publisher dynamically built span-
ning trees for load balancing, latency, number and size of mes-
sages sake, as well as causal barrier approach for implementing
causal ordering.
The rest of the paper is organized as follows. Section II in-
troduces VCube. Section III presents the extensions and func-
tions added to VCube in order to accept topics, a discussion
about ordering of messages, and the description of VCube-
PS’s algorithms. Section IV contains some evaluation results
obtained from experiments conducted on PeerSim simulator.
Section V discusses some related work and, finally, Section VI
concludes the paper.
II. VCUBE
In VCube [10], a node i groups the other n − 1 nodes in
d = log2 n clusters forming a d-VCube, such that the cluster
number s (s > 0) has size 2s−1. The ordered set of nodes in
each cluster s is denoted by ci,s as follows, where ⊕ is the
bitwise exclusive or operator (xor).
ci,s = i⊕ 2s−1 ‖ ci⊕2s−1,k | k = 1, .., s− 1
VCube is a distributed failure diagnosis system and it defines
as the neighbors of a node i the first faulty-free node of each
cluster s in ci,s. Periodically, i tests the first node in the ci,s
to check whether it is correct or faulty. Figure 1 shows node
0’s hierarchical cluster-based logical organization of n = 8
nodes connected by a 3-VCube topology as well as a table
which contains the composition of all ci,s of the 3-VCube.
Let’s consider node p0 and that there are no failures. The
clusters of p0 are shown in the same figure. Each cluster c0,1,
c0,2, and c0,3 is tested once, i.e., p0 only performs tests on
nodes 1, 2, 4 which will then inform p0 about the state of the
other nodes of their respective cluster.
III. VCUBE-PS: PUBLISH/SUBSCRIBE SYSTEM
We consider a distributed system composed of a finite set of
Π = {p0, .., pn−1} nodes(users) with n = 2d processes, d > 0.
Each node has a unique id and nodes communicate only by
message passing. Each single node executes one task and a
user of the Pub/Sub system corresponds to a node. Therefore,
the terms node, user, and process are interchangeable in this
work.
Nodes communicate by sending and receiving messages.
The network is fully connected: each pair of nodes is con-
nected by a bidirectional point-to-point channel and there is no
network partitioning. Nodes do not fail and links are reliable.
Thus, messages exchanged between any two processes are
never lost, corrupted or duplicated. Each message is uniquely
identified by the identity of the source (s), the topic (t), and
sequence number c given by the logical clock of the source.
The system is asynchronous, i.e., relative processor speeds and
message transmission delay are unbounded.
VCube topology model has been extended to satisfy VCube-
PS’s needs. Thus, similarly to VCube, VCube-PS, organizes its
nodes in a logical hypercube-like topology. However, as we
consider that nodes do not fail, VCube-PS exploits VCube’s
organization but not its failure detection feature. Even though
it is possible to draw the analogy in which a node that is not
subscribed to a topic t is considered faulty in relation to t.
Therefore, in VCube-PS, the first node of each cluster s in
ci,s in relation to topic t should also be a subscriber of t.
The following functions are provided to node i of VCube-PS
by the virtual topology:
• FF NEIGHBORi(t, s): if t = ‘ ∗ ’, the function returns the
first node in ci,s; otherwise it returns the first node in ci,s
which is also a member of group t. If there is no such a
node, the function returns ⊥ (no neighbor).
• NEIGHBORHOODi(t, h): returns a set that contains all nodes
virtually connected to i according to FF NEIGHBORi(t, s),
for s = 1, .., h and topic t. The parameter h can range
from 1 to log2N . For h = log2N the function returns
all neighbors of i, if t = ‘ ∗ ’, no matter the topic;
otherwise all neighbors of i that is subscriber of t. For
any other value of h < log2 n, the function returns only
a subset of the first neighbors, i.e., those first neighbors
whose respective cluster number s is smaller or equal to h
(s ≤ h). For instance, in Figure 1, if t = ‘ ∗ ’, NEIGHBOR-
HOOD0(∗, 3) = {1, 2, 4}, NEIGHBORHOOD0(∗, 2) = {1, 2},
and NEIGHBORHOOD4(∗, 2) = {5, 6}. On the other hand,
if only nodes 0, 3, and 4 have joined topic t1, NEIGHBOR-
HOOD0(t1, 3) = {3, 4} and NEIGHBORHOOD4(t1, 2) = ⊥.
• CLUSTERi(j): The function returns the index s of the cluster
of node i that contains node j, (1 ≤ s ≤ log2N ). For
instance, in Figure 1, CLUSTER0(1) = 1, CLUSTER0(2) =
CLUSTER0(3) = 2, and CLUSTER0(4) = CLUSTER0(5) =
s c0,s c1,s c2,s c3,s c4,s c5,s c6,s c7,s
1 1 0 3 2 5 4 7 6
2 2 3 3 2 0 1 1 0 6 7 7 6 4 5 5 4
3 4 5 6 7 5 4 7 6 6 7 4 5 7 6 5 4 0 1 2 3 1 0 3 2 2 3 0 1 3 2 1 0
Fig. 1. VCube hierarchical organization.
CLUSTER0(6) = CLUSTER0(7) = 3.
Causal and Per-source FIFO Reception Orders: For each
topic, VCube-PS respects causal order of published messages,
implementing, thus, a causal broadcast.
Causal Order: if a process publishes a message m′ after it
has delivered m, then no process in the system will deliver m
after m′.
Note that if a process i never delivers m′ (e.g., i leaves the
system before delivering m′) or delivers m′ but never delivers
m (e.g., i was not in the system when m was published), the
causal order of published messages is not violated.
In order to implement the causal order of published mes-
sages, we apply the principle of causal barrier [11]. The
advantage of the causal barrier approach is that it does not
control causality based on nodes’ identity (per node vector) but
by using direct dependencies of messages which renders the
algorithm more scalable and suitable for dynamics of nodes
(subscriptions and unsubscriptions).
Let m and m′ be two application messages published
for topic t. Message m immediately precedes message m′
(denoted m ≺im m′) if (1) the publishing of m causally
precedes the publishing of m′ and (2) there exists no message
m′′ such that the publishing of m causally precedes the
publishing of m′′, and the publishing of m′′ causally precedes
the publishing of m′. The causal barrier of m (cbm) consists
of the set of messages that are immediate predecessors of m.
Figure 2 shows a distributed system with three nodes (p0,
p1, and p2) that have subscribed to the same topic t. We
note ms,t,c the message m published by s with sequence
number c for topic t. On the left of the figure, we have a
timing diagram with the publishing and delivery of messages
and on the right the graph with message dependencies. We
can observe that the delivery of m1,t,1 is conditioned by the
delivery of m0,t,1 (m0,t,1 ≺im m1,t,1) since p1 delivered
m0,t,1 before publishing m1,t,1, (i.e., cbm1,t,1 = {m0,t,1}).
On the other hand, m1,t,2 directly depends on m2,t,1 and
m1,t,1 (i.e., cbm1,t,2 = {m2,t,1,m1,t,1}). Note that since m0,t,1
precedes m1,t,1 that precedes m1,t,2, m0,t,1 is an indirect
dependency of m1,t,2, not included, therefore, in cbm1,t,2 .
Fig. 2. Example of causal barrier.
Let’s now suppose, in the same figure, that p3 subscribes
to t after message m2,t,1 was published to the other nodes,
i.e., in this case, node p3 will never receive nor deliver m2,t,1.
Hence, after having delivered m1,t,1, p3 can deliver m1,t,2.
Since nodes can dynamically subscribe to or unsubscribe
from a topic in VCube-PS, our implementation of message
causal order must distinguish between the case where a
message will be delivered (e.g., m1,t,1) from the one that it will
never be delivered (e.g., m2,t,1 by p3). To this end, VCube-PS
implements FIFO order property related to publish messages
of a topic.
Per-source FIFO Reception Order: messages published by a
same publisher are received by subscribers in the same order as
they were produced. In other words, ms,t,c can be broadcast to
the current subscribers of t provided that the previous message
m′s,t,c−1 was received (not necessarily delivered) by all the
subscribers presented in the system when m′ was broadcast.
Such a broadcast ordering allows a subscriber node of t to
know that it will never receive a given message, i.e., if m′s,t,c′
is the very first message that i receives from s to topic t when
joining t’s group, i will never receive ms,t,c, if c < c′.
In VCube-PS, per-source FIFO reception order is ensured
by acknowledgement of published messages: a source node
broadcasts a new message only after having received all the
acknowledges it waits for, related to the previous message it
broadcast. Note that the per-source FIFO reception order is in
regard to the reception of messages and not delivery, as the
traditional FIFO order definition.
VCube-PS Algorithm Description: The algorithms that
implement VCube-PS are described in the following.
Types of messages and local variables: each message contains
a set (cb) with the direct dependencies of the message (causal
barrier). The value of the data field depends on the type of
the message: for subscription (SUB) and unsubscription (UNS)
messages d holds no data; when the message is used to publish
an event (PUB) it holds the published message itself; lastly
when comprised in an confirmation message (ACK), partial
membership information can be stored in the data field.
The following local variables are kept by every node i:
• counteri: it acts as a logical clock that is incremented for
every event (subscribe, unsubscribe or publish) produced by
node i;
• br queuei[MAX TOPICS]: each br queuei[t] is a set
that keeps the pending messages related to the topic t
(PUB,SUB, or UNS) but which have not been broadcast yet;
• viewi[MAX TOPICS]: set of latest subscription and un-
subscription operations process i is aware of. Each viewi[t]
has the format 〈n, o, rc〉 where n is the identity of the
node that has joined or left the topic t; o is equal to SUB
(subscription) or UNS (unsubscription) and rc stores the
value of the logical clock of n (countern) at the moment
the operation took place;
• causal barrieri[MAX TOPICS]: each
causal barrieri[t] is composed by the set of identifiers
of those messages 〈s, c〉 (broadcast source and sequence
counter) which are immediate predecessors of the next
message that will be published by i for topic t;
• acksi: set of pending ACK messages for which i
waits confirmation. Each item in acksi has the format
〈j, nb, 〈s, t, c, v〉〉 where j is the parenting node and nb
the number of children. The set v is used to gather the
membership information sent by ACK messages;
• msgsi: set of messages that are temporarily kept by i
because they have not been delivered yet. Upon delivering
m, identified by 〈s, t, c〉, the latter can be removed from
msgi;
• recsi[MAX TOPICS]: each recsi[t] is composed by the
set of identifiers of the messages received by i for topic t
and not delivered yet because its respective causal barrier
can not be satisfied. Each element has the format 〈s, c, cb〉
where s is the source identity of the message m whose
counter is c, and cb corresponds to the causal barrier of m,
i.e., the set of direct predecessor messages of m that must
be delivered by i before delivering m;
• delvsi[MAX TOPICS]: each delvsi[t] corresponds to
the set of identifiers of the last message delivered by i for
topic t. Each element of the set is the tuple 〈s, c〉 where s
is the source identity of the message whose counter is c;
• first reci[MAX TOPICS]: each first reci[t] keeps
the identifiers of the first message received from each
publisher for a topic t.
In the algorithms, the symbol ⊥ represents a null element
while the underscore ( ) is used to indicate any element.
Description of the algorithms: the three functions offered to
the application are presented in Algorithm 1. The implemen-
tation of these functions use the procedure CO BROADCAST
(Algorithm 2), differing the type of message broadcast.
Thereby, no matter the type of message (subscription, unsub-
scription or the publish of an event), the same kind of spanning
tree will be used.
A node i can publish a message to a topic t only if it
is subscribed to t (line 21), and the process of subscribing
involves reseting viewi[t] (line 6). When i first subscribes
to t, CO BROADCAST creates a task T1(t) responsible for
broadcast messages to the members of t (Algorithm 2, line 11).
Whenever CO BROADCAST is invoked for broadcasting some
data related to a topic t, it creates a message m with the
type of the data, increments its local counter (counteri) and
then inserts m in a queue br queue[t] which is handled by
T1(t). The use of a separated task for handling messages of a
topic ensures that the source of the message and its receivers
(publisher and subscribers in the case of a PUB message)
remain decoupled (producer/consumer approach).
In Algorithm 2, each task T1(t) continuously removes, at
each iteration, the first message m from its queue br queue[t]
and starts its broadcast. However, the next message is removed
from the queue only when there is certainty, i.e., reception of
all ACK messages from the previous broadcast (line 38). The
way T1(t) treats a message depends on its type. When i pub-
lishes a PUB message m, the task includes m in first reci[t],
Algorithm 1 Functions offered to the application: process i
1: Init
2: counteri ← 0
3: ∀t ∈MAX TOPICS : viewi[t]← ∅
4: function SUBSCRIBE(topic t)
5: if 〈i, SUB, 〉 /∈ viewi[t] then
6: viewi[t]← {〈i, SUB, counteri〉} . Reset viewi[t]
7: CO BROADCAST(SUB, t, )
8: return OK
9: end if
10: return NOK
11: end function
12: function UNSUBSCRIBE(topic t)
13: if 〈i, SUB, 〉 ∈ viewi[t] then
14: viewi[t]← viewi[t] r {〈i, SUB, counteri〉}
15: CO BROADCAST(UNS, t, )
16: return OK
17: end if
18: return NOK
19: end function
20: function PUBLISH(topic t, message data)
21: if 〈i, SUB, 〉 ∈ viewi[t] then
22: CO BROADCAST(PUB, t, data)
23: return OK
24: end if
25: return NOK
26: end function
if i has not previously broadcast any message related to t since
it last joined it. Then, it delivers m to the application, includes
in m the information about the identifiers of those messages
on which m directly depends, and resets the causal barrier
for t, setting m as its only element (lines 18-26). When a
node subscribes to a topic t, it has to notify all the members
of t about it as well as it has to be notified about the other
subscribers of t. Since initially it has no knowledge about
the members of t it sends the subscription to all the nodes
in the system. For any other message (UNS or PUB) to t,
the node sends only to the subscribers of t (lines 27-37).
These latter are locally computed using the NEIGHBORHOODi
function presented in Algorithm 3. Specially, when a node i
unsubscribes from t, beyond broadcasting it to the subscribers
of t, it also resets the data structures of i related to t (lines 39-
44), except for the viewi[t]. Doing so, i prevents old data
from interfering in the delivery of new messages in the case
of a re-subscription to t. The last values of viewi[t] are kept
until a re-subscription to t, since they are used for forwarding
messages addressed to t that i may receive just after it left the
topic.
For every message node i broadcasts, it has to wait for a
confirmation ACK from each of its receiving child nodes. Node
i keeps track of the number of ACKs it has to receive related to
a message m by adding an entry to acksi (line 33). However, a
child of i will send the ACK confirming the reception of m only
after it receives the ACKs for m from its own children. Thus
ACKs messages will start to propagate from leaves towards
the root, the source of m. Eventually the latter receives all
the ACK messages it waits for and, in this case, task T1(t)
publishes the next message in br queuei[t]. These waves of
SUB, UNS or PUB messages and their respective ACK messages
from/to the source ensure the per-source FIFO reception order
Algorithm 2 Causal broadcast algorithm and deliver executed by process i
1: Init
2: ∀t ∈ MAX TOPICS: viewi[t] ← ∅; first reci[t] ← ∅; recsi[t] ←
∅; delvi[t]← ∅; br queuei[t]← ∅
3: msgi ← ∅
4: create Task T2
5: procedure CO BROADCAST(message type type, topic t, message data)
6: NEW(m)
7: m.type← type; m.s← i; m.t← t
8: m.c← counteri; m.data← data
9: counteri ← counteri + 1
10: if type = SUB and @ T1(t) then
11: create Task T1(t)
12: end if
13: br queuei[t].insert(m)
14: end procedure
15: Task T1(topic t)
16: loop
17: m← br queuei[t].first() . block if queue empty
18: if m.type = PUB then
19: if 〈i, 〉 /∈ first reci[t] then
20: first reci[t]← first reci[t] ∪ {〈i,m.c〉}
21: end if,
22: CO DELIVER(m)
23: delvsi[t]← delvsi[t] r {〈i, 〉} ∪ {〈i,m.c〉}
24: m.cb← causal barrieri[t]
25: causal barrieri[t]← {〈i,m.c〉}
26: end if
27: if m.type = SUB then
28: ngbi ← NEIGHBORHOODi(‘ ∗ ’, log2 N)
29: else
30: ngbi ← NEIGHBORHOODi(t, log2 N)
31: end if
32: if ngbi 6= ∅ then
33: acksi ← acksi ∪ {〈⊥,#(ngbi), 〈i, t,m.c, ∅〉〉}
34: end if
35: for all j ∈ ngbi do
36: SEND(m) to pj
37: end for
38: wait until acksi ∩ {〈⊥, , 〈m.s,m.t,m.c, 〉〉} = ∅
39: if m.type = UNS then
40: first reci[t]← ∅
41: recsi[t]← ∅
42: delvi[t]← ∅
43: msgi ← msgi r {m | m.t = t}
44: end if
45: end loop
46: Task T2
47: loop
48: upon receive m from pj . block if no message
49: if m.type 6= ACK then
50: if m.type = SUB then
51: ngbi ← NEIGHBORHOODi(‘ ∗ ’, CLUSTERi(j) −1)
52: else
53: ngbi ← NEIGHBORHOODi(t, CLUSTERi(j) −1)
54: end if
55: if ngbi = ∅ then . leaf node
56: NEW(m′)
57: m′.type← ACK,m′.s← m.s;m′.t← m.t
58: m′.c← m.c;m.data← ∅
59: SEND ACKS(j,m′)
60: else . propagate m
61: acksi ← acksi ∪ {〈j,#(ngbi), 〈m.s,m.t,m.c, ∅〉〉}
62: for all k ∈ ngbi do
63: SEND(m) to pk
64: end for
65: end if
66: else . m.type = ACK
67: k, nb, v ← k′, nb′, v′ : 〈k′, nb′, 〈m.s,m.c,m.t, v′〉〉 ∈ acksi
68: acksi ← acksi r 〈k, nb, 〈m.s,m.c,m.t, v〉〉
69: m.data← m.data ∪ v
70: if nb > 1 then
71: acksi ← acksi ∪ 〈k, nb− 1, 〈m.s,m.c,m.t,m.data〉〉
72: else if k 6= ⊥ then . All pending ACKs were received
73: SEND ACKS(k,m)
74: end if
75: end if
76: if 〈i, SUB, 〉 ∈ viewi[t] then . i is subscribed to t
77: if m.type = PUB then
78: if @〈m.s, 〉 ∈ first reci[t] then
79: first reci[t]← first reci[t] ∪ {〈m.s,m.c〉}
80: end if
81: recsi[t]← recsi[t] ∪ {〈m.s,m.c,m.cb〉}
82: msgsi ← msgsi ∪ {m}
83: CHECK RECS(t) . received messages may be delivered
84: else if m.type = ACK then
85: viewi[t]← UPDATE(viewi[t],m.data)
86: else
87: viewi[t]← UPDATE(viewi[t], {〈m.s,m.type,m.c〉})
88: if m.type = UNS then
89: first reci[t]← first reci[t] r {〈m.s, 〉}
90: end if
91: end if
92: end if
93:
94: end loop
of published messages of the topic.
Task T2 of Algorithm 2 is responsible for the reception of
messages. Likewise in the initial broadcast, the retransmission
of a message depends on its type. Except for confirmation
messages, all others are sent from the root (source) to leaves
and upon reaching a leaf node i, a wave of ACK messages
starts to be propagated up (lines 55-59). ACKs have a double
purpose: reception confirmation as well as to carry mem-
bership information. In the case of the latter, the procedure
SEND ACKS, presented in Algorithm 3 (lines 56-61), decides
whether to add membership information to the ACK that is
going to be sent to the parent node or not. SUB messages are
the way a new subscriber uses to notify other members of the
topic about its subscription. But, instead of adding membership
information only to answer SUB messages, SEND ACKS does
it whenever a message m is the first message received from
a source s to a topic t. This strategy guarantees that after
i receives a first message from s, i will receive the next
messages from s, despite the dynamics of the system (nodes
may join or leave any topic at any moment).
As stated before, the transmission of the ACK for a message
m is conditioned to the reception of the ACKs of the child
nodes. And as a node i receives the ACKs from its children it
gathers membership information that come with them and that
will be transmitted to its own parent (lines 67-74). Moreover, if
i itself is a member of m.t, it will update its own membership
set with the information provided by its sub-tree (line 85).
For this, the procedure UPDATE, depicted in Algorithm 3,
merges two membership sets, keeping the most recent element
for each node n (with respect to the counter rc present in
the element, that represents the logical time in n where the
operation contained in the element happened).
When node i receives a PUB message m from s related
to a topic t, if i is subscribed to t it must also deliver the
Algorithm 3 Auxiliary functions and procedures
1: function UPDATE(set1, set2)
2: for all 〈n1, , rc1〉 ∈ set1 do
3: if ∃ 〈n1, , rc2〉 ∈ set2 then
4: if rc2 > rc1 then
5: set1 ← set1 r {〈n1, , rc1〉}
6: else
7: set2 ← set2 r {〈n1, , rc2〉}
8: end if
9: end if
10: end for
11: return set1 ∪ set2
12: end function
13: function CLUSTERi(j)
14: return s such that i ∈ cj,s
15: end function
16: function FF NEIGHBORi(t, s)
17: for all k ∈ ci,s do
18: if t = ‘ ∗ ’ or 〈k, SUB, 〉 ∈ view[t] then
19: return k
20: end if
21: end for
22: return ⊥
23: end function
24: function NEIGHBORHOODi(t, h)
25: ngb← ∅
26: for s← 1 to h do
27: if (j ← FF NEIGHBORi(t, s) 6= ⊥ then
28: ngb← ngb ∪ {j}
29: end if
30: end for
31: return ngb
32: end function
33: function CHECK CB(topic t, causal barrier cb)
34: for all 〈s, c〉 ∈ cb do
35: if (∃ 〈s′, c′〉 ∈ delvsi[t]: s = s′ and c′ ≥ c) or (∃ 〈s′, c′〉 ∈
first reci[t]: s = s′ and c′ > c) then
36: cb← cb r {〈s, c〉}
37: end if
38: end for
39: return (cb = ∅)
40: end function
41: procedure CHECK RECS(topic t)
42: repeat
43: delMsg ← 0
44: for all 〈s, c, cb〉 ∈ recsi[t] do
45: if CHECK CB(t, cb) then
46: CO DELIVER(m),m ∈ msgsi: m.s = s, m.t = t, and
m.c = c
47: recsi[t]← recsi[t] r {〈s, c, cb〉}
48: delvsi[t]← delvsi[t] r {〈s, 〉} ∪ {〈s, c〉}
49: causal barrieri[t]← causal barrieri[t]r cb ∪ {〈s, c〉}
50: msgsi ← msgsi r {m}
51: delMsg ← delMsg + 1
52: end if
53: end for
54: until (delMsg = 0)
55: end procedure
56: procedure SEND ACKS(j, m)
57: if 〈i, SUB, 〉 ∈ viewi[m.t] and @〈m.s, 〉 ∈ first reci[m.t] then
58: m.data← m.data ∪ {〈i, SUB, c〉 : 〈i, SUB, c〉 ∈ view[m.t]}
59: end if
60: SEND(m) to pj
61: end procedure
message. Although, before delivering it, i must assure the
causal order is respected. Initially, i includes the identification
of m in recsi[t] set and m in msgsi. Moreover, if m is the first
message received for t from s, i includes it in first reci[t]
(lines 77-83). Then, i invokes the function CHECKRECS
(Algorithm 3) in order to verify which received messages
can be delivered to the application. To this end, this function
recursively checks direct causal dependencies by calling the
function CHECKCB (line 45 of Algorithm 3). A message m
can be delivered to i only when every message m′ on which
m causally depends either was already delivered to i or will
never be received by i since VCube-PS not considered i as
a subscriber of t during the construction of the spanning tree
that broadcast m′. In other words, the first publication received
from s′ to topic t by i has a higher sequence number than the
one of m′. Such detection of the first message is possible
thanks to the first reci[t] set and the fact that, for the same
source, publication of messages of the same topic respect per-
source FIFO order. After the delivery of m (CO DELIVER
function, line 46 of Algorithm 3), the tuple that identifies m
in recsi[t] set is transferred to delvsi[t] set and m is deleted
from msgi (lines 47-50). When a subscriber i of t receives
a UNS message m, it must also remove from first rec i[t]
the element that contains m.s (line 89). This guarantees that
if s re-subscribes to t, the condition imposed in function
SEND ACKS (Algorithm 3) will work as expected.
It is worth remarking that when i unsubscribes from a topic
t, messages related to t must not be delivered by i anymore.
On the other hand, i continues to forward messages related to
t to the other subscribers of t in the spanning tree. This can
happen during the time where not all subscribers received the
unsubscription message from i. It also sends ACK messages
to its parent node in the respective spanning tree. These ACK
messages are related to published messages that it has received
and forwarded before leaving t or before its parent node
receives its UNS message. There exists a moment where i will
have sent all requested ACK messages, removing them from
its acki set and, therefore, it will no more take part in the
broadcast of messages related to t.
IV. EXPERIMENTAL RESULTS
In order to assess the performance of VCube-PS with
different configuration scenarios, we conducted some exper-
iments on top of the event-driven PeerSim [13] simulator. In
the majority of scenarios, we compared VCube-PS with an
approach, denoted SRPT (Single Root Per Topic), which is
similar to Scribe [3], where a single multicast tree per topic,
composed by both subscribers and not subscribers (forwarders)
is used to publish all messages of the topic. SRPT maps each
topic into a node that acts as the root of the broadcast tree
for the respective topic. Forwarders receive and re-transmit
published messages but do not deliver them.
In the experiments, we consider that each message ex-
changed between two processes consumes tpc+tq+tt+tpp+td
units of time (u.t.). Apart from td which represents the
time necessary for a subscriber to satisfy all causal depen-
dencies before delivering a message to the application, all
other components are based on a packet-switched network
delay model [14]: tpc accounts for the processing time of a
message inside a node, e.g., checksum verification and routing
decisions; tq is the time a message must wait in queue before
being transmitted; tt is the time necessary to transmit all bits of
the message into the link, and tpp expresses how long it takes
for a message to transverse the link and reach the next hop.
Assuming that there is no broadcast facility available in the
system, if a message is sent to multiple destinations, a copy of
it is queued for each of the destinations. For our experiments,
the ratio between tpc and tpp has an impact in the threshold
value for starting to queue messages as well as how fast the
queue grows. Hence, based on [15], we set tpc = tt = 1 u.t.
and tpp = 100 u.t. (1/100 ratio). The time a message stays
queued (tq) is a function of the rate of incoming/outgoing
messages and can vary for each message. Likewise, when a
node i receives a message m, td will depend on how fast i
will receive all the preceding messages of m. If there is no
preceding message td = 0.
The number of nodes N used in the simulations varies from
8 up to 1024, in a power of two. Each experiment was executed
40 times and for the results that comprise average values we
also provide the standard deviation.
We consider the following metrics:
• Latency: the time that a published message takes to be
delivered by all subscribers.
• Number of messages: overall number of PUB messages.
• Number of messages to be processed by a node: size of the
queue of each node.
• Size of PUB messages: characterizes the number of direct
causal dependencies that PUB messages hold.
• Number of false positives: number of messages received by
nodes that act as forwarders of messages of type PUB.
Scenario with one publisher: The aim of this experiment is
to show the logarithmic properties of VCube-PS. We consider
that one publisher broadcasts only one message. Hence, when
a subscriber receives the message, there is no delay for
delivering it, since causal order of published messages is not
applied in this case. Figure 3 depicts the delivery latency when
the number of nodes of the system varies and either 100%
or 25% of them are subscribers. The set of subscribers is
randomly chosen following a uniform distribution and fixed at
the beginning of each execution. We should remark that when
100% of the nodes are subscribers, SRPT has no forwarder
and, therefore, the latency for both Pub/Sub systems is always
proportional to log2N . The only difference in this case is that
SRPT has an additional hop as the message to be published
must be sent to the root of its single tree.
In the case of 1024 nodes with 25% of subscribers uniformly
distributed, latency in VCube-PS is in average 420 units of
time which results in a reduction of 31% compared to the
latency presented by SRPT in the same scenario (620 u.t.)
The higher standard deviation observed for SRPT with 25% of
subscribers in scenarios with fewer nodes is due to the greater
 0
 100
 200
 300
 400
 500
 600
 700
8 16 32 64 128 256 512 1024
A
V
G
 
D
e
l
i
v
e
r
y
 
L
a
t
e
n
c
y
 
(
u
.
t
.
)
Number of nodes
VCube-PS - 25%
VCube-PS - 100%
SRPT - 25%
SRPT - 100%
Fig. 3. Average latency for the delivery of one message to each subscriber.
number of forwarders that have an impact in the average of the
delivery time of all nodes. On the other hand, as the number of
nodes increases, the number of samples (delivery time at each
node) tends the average of all executions to a similar value.
Moreover, with 100% of subscribers in SRPT , the standard
deviation is not zero since there exists a probability that the
root node is the publisher itself and, therefore, SRPT performs
just like VCube-PS, with no additional hop.
 0
 25
 50
 75
 100
 125
 150
 175
 200
 225
 250
 275
 300
 325
 350
 375
 400
 425
 450
 475
8 16 32 64 128 256 512 1024
A
v
e
r
a
g
e
 
N
u
m
b
e
r
 
o
f
 
P
U
B
 
M
e
s
s
a
g
e
s
Number of nodes
VCube-PS
SRPT
Fig. 4. Average number of PUB messages with 25% of subscribers.
Despite latency, forwarders induce an increase in the num-
ber of messages propagated throughout the network. Figure 4
depicts the average number of PUB messages for the two
approaches with 25% of nodes as subscribers. In VCube-PS,
this number is always equal to the number of subscribers, since
there is no forwarder in the multicast tree. On the other hand,
the forwarders in SRPT are responsible for up to 2.7 times
more messages (for 8 nodes) when compared to VCube-PS.
As the number of nodes increases this difference is reduced,
although VCube-PS generates, in average, at least 43% fewer
messages than SRPT (1024 nodes).
Scenario with several publishers: In these experiments, all
nodes are subscribers of just one topic and the number of
publishers varies. Each publisher i sends one message at time
ti which is chosen by a uniform distribution between [0, 1000]
units of time. Figure 5 shows in logarithmic scale the average
reception latency when the number of nodes of the system
varies and either 100% or 25% of them are publishers. Since
 128
 256
 512
 1024
 2048
 4096
 8192
 16364
 8  16  32  64  128  256  512  1024
A
v
e
r
a
g
e
 
R
e
c
e
p
t
i
o
n
 
L
a
t
e
n
c
y
 
(
u
.
t
.
)
Number of nodes
VCube-PS - 25%
VCube-PS - 100%
SRPT - 25%
SRPT - 100%
(a) 1/100 ratio (tpp = 100).
 128
 256
 512
 1024
 2048
 4096
 8192
 16364
 8  16  32  64  128  256  512  1024
A
v
e
r
a
g
e
 
R
e
c
e
p
t
i
o
n
 
L
a
t
e
n
c
y
 
(
u
.
t
.
)
Number of nodes
VCube-PS - 25%
VCube-PS - 100%
SRPT - 25%
SRPT - 100%
(b) 1/1000 ratio (tpp = 1000).
Fig. 5. Average reception latency with 25% and 100% of publishers (logarithmic scale).
the ratio between processing time (tpc) and propagation time
(tpp) has an impact in load contention, we consider the ratio
1/100 (Figure 5(a)), which is used in all other evaluation of this
work, but also a propagation time which is ten times greater,
(tpp = 1000 u.t.), leading to a ratio 1/1000 (Figure 5(b)).
We can observe in Figure 5(a) is the stability of VCube-PS
for both percentages of publishers, with a maximum increase
of 5.7% (1024 nodes and 100% of publishers). This result
corroborates that the use of one tree per publisher helps to
distribute the load, since each message transverses a different
path in the network. On the other hand, as SRPT imposes
a unique tree for disseminating messages to subscribers of
a topic, if f several messages arrive at the root node of the
tree at the same time they will be queued before transmission,
increasing, thus, reception latency. The numbers for SRPT up
to 128 nodes are in average one hop in time higher compared
to VCube-PS due to the additional hop used by SRPT . The
arrival rate of messages in this case is close to the output rate,
leading to no contention. Beyond this number of nodes, the
root receives more messages than it can process and transmit
per interval of time and starts to saturate.
Comparing Figure 5(b) with Figure 5(a), we observe lower
increase in average reception latency for SRPT in relation
to VCube-PS since a 1/1000 ratio induces a higher latency
in reception of messages by a node, although its output
throughput remains the same. Figure 5(b) shows an increase
of only 37% for 256 nodes (100% of publishers).
Table I shows the distribution of messages among nodes. For
1024 nodes and ratio 1/100 where all of them are publishers
and subscribers, the table groups nodes with similar average
size of queue (given by intervals).
We observe an uneven distribution of load among the nodes
in SRPT when compared to VCube-PS: 98% of the nodes
in VCube-PS has an average load between (4, 16] messages
while, although 44% of the nodes in SRPT have in average
between (0, 2] messages in their buffers, 50% of the nodes
simply do not participate of the routing of any message. More-
over, in SRPT , one node (the root of the tree) has an average
load of 9240 (σ = 4617) messages, which is a bottleneck
that increases the overall reception latency and limits the load
of the other nodes to just a few messages. Besides that, since
TABLE I
AVERAGE SIZE OF THE QUEUE PER GROUP OF NODES.
# of messages # of nodes (VCube-PS) # of nodes (SRPT)
0 0 512
(0, 2] 0 448
(2, 4] 0 60
(4, 8] 495 3
(8, 16] 510 0
(16, 32] 19 0
(32, 4096] 0 0
(4096, 8192] 0 1
each node publishes one message, in VCube-PS we have 1024
different trees which leads to an uniform distribution of sent
messages where any node transmits exactly 1024 messages.
On the other hand, in SRPT the relation between the number
of nodes and the amount of messages they publish is reduced
exponentially.
Ordering of messages: In order to evaluate the size of
message and latency due to message ordering, we consider
that one node s, chosen randomly, publishes a first message
ms. Then upon receiving it, each node k waits for a random
time (tw) before broadcasting a message mk, similarly to a
message discussion group service. Additionally, a node k has
to wait at least p messages before broadcasting its own. To this
end, there are j (j ≥ 1) nodes that broadcast independently
a message each in the beginning of the experiment. Just after
receiving all these initial messages, any node can publish a
message.
Figure 6 groups messages according to the size interval of
their causal barriers for VCube-PS. When it is necessary to
wait just one message before broadcasting its own, 51.6%
of the messages generated in the system have less than 5
preceding messages. More precisely, 19.9% of all messages
have just one causal dependency. On the other hand, if a node
has to wait for more messages, 10 in the case of Figure 6,
before broadcasting its own, a larger number of nodes will
have 10 or more direct dependencies. In this case, 35.2% of
the messages have size 10 (10 direct dependencies) and 79.7%
of them have fewer than 15. However, in both cases, due to
 0
 5
 10
 15
 20
 25
 30
 35
 40
 45
 50
 55
0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90
P
e
r
c
e
n
t
a
g
e
 
o
f
 
m
e
s
s
a
g
e
s
Number of causal dependencies
Wait 1 message
Wait 10 messages
Fig. 6. Frequency distribution for the number of causal dependencies of a
message in a network running VCube-PS with 256 nodes.
both the use of causal barriers and multiple tree-roots used
by VCube-PS, the size of the dependency list of most of the
messages keeps close to the dependency threshold.
It is worth also pointing out the additional delay imposed
by the causal barrier before delivering a message to the
application. If messages take too long to be delivered, this
delay may lead to a cascade effect that could make the
system unfeasible. In our simulations, when a node waits for
1 message before broadcasting its own, about 95.1% of the
messages are delivered in less than 10 u.t. after the reception
(87.2% of them with no delay). Only 81 messages (out of
65280) have a delay higher than 50 u.t., with an upper limit
of 150 units of time. Increasing the number of the waiting
messages to 10, 457 messages will wait more than 50 u.t.
to be delivered (maximum 187), although the number of
messages with no delay remains high (84.2%).
Scenario with several topics: In order to evaluate popularity
of topics in Twitter, the authors in [16] carried out some
experiments that show that roughly 60% of the topics have
only one message published and 83% of them have no more
than 5. On the other hand, only 0.15% of the topics are related
to more than 1000 messages each. This behavior follows a
Zipf-like distribution with a calculated coefficient of 0.825
according to the data provided in the article.
 400
 420
 440
 460
 480
 500
 520
 540
 560
 580
 600
 620
 640
 660
 680
 700
27 28 29 210 211 212 213 214
A
v
e
r
a
g
e
 
R
e
c
e
p
t
i
o
n
 
L
a
t
e
n
c
y
 
(
u
.
t
.
)
Number of messages
VCube-PS - Uniform
VCube-PS - Zipf
SRPT - Uniform
SRPT - Zipf
Fig. 7. Average reception latency with 256 nodes and 128 topics for two
distribution of messages per topic.
Figure 7 presents the average reception latency in a network
with 256 nodes and 128 topics where the number of published
messages varies. The topic associated with each message is
chosen following one of the two distributions: uniform or Zipf
with a coefficient equals to 0.825. Each node publishes a new
message in average every 500 u.t. for a topic randomly chosen
until a maximum number of messages is reached. Thereby, the
messages are uniformly distributed among the publishers, but
not necessarily among the topics. The minimum difference of
around 100 u.t. is due to the additional hop used by SRPT
to send a message to the root of the topic. No matter the
distribution of messages among the topics, VCube-PS always
relies on the same root for a given node, while SRPT may
take advantage in the case of a uniform distribution. This is
the reason why the behavior of SRPT is the same as VCube-
PS’s for a uniform distribution of messages. However, when
the number of messages sent per node increases beyond a
threshold, VCube-PS presents higher latency due to contention
in the source of the messages, i.e., the root of the tree. On the
other hand, for the Zipf distribution, SRPT presents an average
reception latency 30.6% higher compared to the uniform distri-
bution (for 214 messages). For this same situation, VCube-PS
increases the latency, in average, only 9.2%. In a non-uniform
distribution, the higher number of messages, the closer the
behavior to the previous discussion with several publishers.
The use of a tree rooted on the a message’s source makes
VCube-PS scalable in terms of publishers, while SRPT is
scalable in terms of topics. However, in a real scenario, like
the one presented by [16], even if a great number of topics
may exist, most of the messages are concentrated in a small
set of them.
Scenario with dynamics of subscriptions: In the current
experiments, we are interested in evaluating how VCube-PS
adapts itself to the changes in the membership set of a topic.
When a node i leaves a given topic t, it can still receive
some messages addressed to t. It happens because not all other
subscribers of t received i′s unsubscription message yet. We
consider these messages as false-positives. However, this is a
temporary situation, since after a finite interval of time other
subscribers will receive the unsubscription message from i.
In order to assess such a behavior, we consider one publisher
that publishes several messages to the topic t. Due to the Per-
source FIFO, one message will be broadcast one after the
reception of the ACKs from the previous one. For a given
number of nodes, 75% of the nodes are randomly chosen
as subscribers of a topic. Furthermore, at the same time the
publisher starts the broadcast of its first message, 12.5% or
25% of the subscribers leave and new ones join the topic. The
publisher sends 256 messages. Table II summarizes the results
of such a scenario.
The number of false-positives reach at most 7.6% of the
total number of delivered messages (1024 nodes with 25% of
churn). In this case, 192 nodes leave the topic at the same time.
In the best case, all other subscribers would be notified in up
to (log2 n ∗ tpp), but it is necessary to consider the queuing
TABLE II
DYNAMICS OF SUBSCRIPTIONS.
Churn Nodes AVG false-positives (std dev) AVG deliveries (std dev)
12.5% 512 2433.1 (764.4) 97445.5 (655.7)
12.5% 1024 10525.7 (1207.1) 194506.8 (943.6)
25% 512 3475.9 (899.9) 96193.9 (1001.7)
25% 1024 14590.4 (1717.8) 191706.3 (1549.8)
of messages in other nodes of the spanning tree (including
unsubscriptions and new subscriptions). With 1024 nodes and
75% of them as subscribers, 196608 messages should be
delivered. Although, when there is 25% of churn, in average
97.5% of them are delivered.
V. RELATED WORK
Numerous Pub/Sub systems in the literature, such as
Scribe [3], Bayeux [4], DYNATOPS [6], and Dynamoth [5],
are based on topics. Compared to content-based, topic-based
systems provide simpler and more efficient implementations.
They are usually deployed in contexts where efficient and fast
notification is required.
Similarly to VCube-PS, many Pub/Sub systems use tree-
based overlays (e.g., Scribe [3], Bayeux [4], Marshmal-
low [12], DR-Tree [8], DYNATOPS [6]). The advantage
of using trees is the logarithmic guaranties on publication
delivery time and number of messages. However, contrarily
to VCube-PS, in current solution, there exists often one single
multicast tree (usually one per topic in topic-based systems),
statically constructed from the start or as nodes join the
system. Consequently, every publication should be broadcast
from the root of this tree that might, then, become a bottleneck.
Moreover, many of these multicast trees include unrelated
intermediate hops and nodes that are not subscribers which
have to forward the message, presenting thus the problem
of false positives and the need of message filtering (e.g.DR-
Tree [8],Scribe [3]). Finally, their maintenance cost is usually
high, specially in presence of churn.
Several solutions (e.g. Scribe [3], DYNATOPS [6], etc.)
construct independent multicast trees on top of Distributed
Hash Table (DHT) overlays (e.g Pastry, CAN). They adopt
the rendezvous point approach, where a node, responsible for
the hashed key of a topic name, becomes the rendezvous point,
i.e., the root of the multicast related to the topic. Some DHT
overlay like PeerCube [17] and HOMED [18] are based on a
hipercubic topology themselves.
Even if defining a coherent order for notifications in
Pub/Sub systems is fundamental, few of them support event
ordering [19], [7], [20], [21], specially total order. The authors
in [19] propose a top-basic Pub/Sub system where messages
published on different topics are either delivered in the same
order to all subscribers of these topics or tagged as out-of
order (weak total order) while in [20], the task of ordering
messages is distributed across sequencer nodes which totally
order messages for the same topic. Considering FIFO links,
Zhang et al. present in [21] a distributed total order protocol for
a content-based Pub/Sub system where a broker can determine
if a message can be delivered immediately or, by collaborating
with other brokers, that a consistent delivery order is required.
JEDI [7] is a Pub/Sub system that ensures causal order. The
latter is implemented by the use of a return value, a message
by which a receiver notifies an event delivery to the producer
of the event, unlike to VCube-PS, which does not require these
extra messages since a message causality dependencies are
included in the message itself (causal barrier).
VI. CONCLUSION
This work presented VCube-PS, a distributed topic-based
Pub/Sub system. Spanning trees are dynamically built on the
top of a hypercube-like topology and used to both propa-
gate information about membership changes and disseminate
publish message to the subscribers of a topic. While other
approaches use a node as the rendezvous point of the tree of
a topic, we configure a distributed spanning tree rooted on
the source of every message, without any cost due to VCube
virtual topology and functions. The spanning trees contain
only subscribers of the topic which induce trees of shorter
height when compared to a per-topic single root tree and,
therefore, lower latencies and smaller number of messages.
VCube-PS also provides causal ordering of messages whose
implementation uses the causal barrier approach, adapted to
cope with the dynamics of the system.
Experimental results from simulations on PeerSim confirm
the logarithmic behavior of VCube-PS. Compared to an ap-
proach with one single root per topic, our solution performs
better when there is a high publication rate per topic since it
provides load balancing of publication. Furthermore, VCube-
PS does not present permanent forwarders which induce
false positives but only temporary ones due to subscription
dynamics which eventually do not take part in the system.
REFERENCES
[1] R. Baldoni, L. Querzoni, and A. Virgillito, “Distributed event routing in
publish/subscribe communication systems: a survey,” Tech. Rep., 2005.
[2] C. Esposito, D. Cotroneo, and S. Russo, “On reliability in pub-
lish/subscribe services,” Comput. Netw., vol. 57, no. 5, pp. 1318–1343,
Apr. 2013.
[3] M. Castro, P. Druschel, A. M. Kermarrec, and A. I. T. Rowstron, “Scribe:
a large-scale and decentralized application-level multicast infrastruc-
ture,” IEEE J. Sel. Areas Commun., vol. 20, no. 8, pp. 1489–1499, Oct
2002.
[4] S. Q. Zhuang, B. Y. Zhao, A. D. Joseph, R. H. Katz, and J. D.
Kubiatowicz, “Bayeux: An architecture for scalable and fault-tolerant
wide-area data dissemination,” in NOSSDAV ’01, 2001, pp. 11–20.
[5] J. Gascon-Samson, F. Garcia, B. Kemme, and J. Kienzle, “Dynamoth:
A scalable pub/sub middleware for latency-constrained applications in
the cloud,” in ICDCS, 2015, pp. 486–496.
[6] Y. Zhao, K. Kim, and N. Venkatasubramanian, “Dynatops: A dynamic
topic-based publish/subscribe architecture,” in DEBS, 2013, pp. 75–86.
[7] G. Cugola, E. Di Nitto, and A. Fuggetta, “The jedi event-based infras-
tructure and its application to the development of the opss wfms,” IEEE
Trans. Softw. Eng., vol. 27, no. 9, pp. 827–850, Sep. 2001.
[8] S. Bianchi, P. Felber, and M. G. Potop-Butucaru, “Stabilizing distributed
r-trees for peer-to-peer content routing,” IEEE Trans. Parallel Distrib.
Syst., vol. 21, no. 8, pp. 1175–1187, 2010.
[9] P. T. Eugster, P. A. Felber, R. Guerraoui, and A.-M. Kermarrec, “The
many faces of publish/subscribe,” ACM Comput. Surv., vol. 35, no. 2,
pp. 114–131, Jun. 2003.
[10] E. P. Duarte, Jr., L. C. E. Bona, and V. K. Ruoso, “VCube: A provably
scalable distributed diagnosis algorithm,” in Work. on Latest Advances
in Scalable Algorithms for Large-Scale Systems, 2014, pp. 17–22.
[11] R. Prakash, M. Raynal, and M. Singhal, “An efficient causal ordering
algorithm for mobile computing environments,” in ICDCS, 1996, pp.
744–751.
[12] S. Gao, G. Li, and P. Zhao, “Marshmallow: A content-based publish-
subscribe system over structured p2p networks,” in 7th Int1l Conf.
Comput. Intellig. Security, Dec 2011, pp. 290–294.
[13] A. Montresor and M. Jelasity, “Peersim: A scalable p2p simulator,” in
2009 IEEE Ninth International Conference on Peer-to-Peer Computing,
Sept 2009, pp. 99–100.
[14] J. F. Kurose and K. W. Ross, Computer Networking: A Top-Down
Approach (6th Edition), 6th ed. Pearson, 2012.
[15] R. Ramaswamy, N. Weng, and T. Wolf, “Characterizing network pro-
cessing delay,” in GLOBECOM, vol. 3, Nov 2004, pp. 1629–1634 Vol.3.
[16] C. Sanli and R. Lambiotte, “Local variation of hashtag spike trains and
popularity in twitter,” PLOS ONE, vol. 10, no. 7, pp. 1–18, 07 2015.
[17] E. Anceaume, R. Ludinard, A. Ravoaja, and F. Brasileiro, “Peercube:
A hypercube-based p2p overlay robust against collusion and churn,” in
SSS, 2008, pp. 15–24.
[18] Y. Choi, K. Park, and D. Park, “Homed: a peer-to-peer overlay architec-
ture for large-scale content-based publish/subscribe system,” in DEBS,
2004, pp. 20–25.
[19] R. Baldoni, S. Bonomi, M. Platania, and L. Querzoni, “Dynamic
message ordering for topic-based publish/subscribe systems,” in IPDPS,
2012, pp. 909–920.
[20] C. Lumezanu, N. Spring, and B. Bhattacharjee, “Decentralized message
ordering for publish/subscribe systems,” in Middleware, 2006.
[21] K. Zhang, V. Muthusamy, and H. Jacobsen, “Total order in content-based
publish/subscribe systems,” in ICDCS, 2012, pp. 335–344.

