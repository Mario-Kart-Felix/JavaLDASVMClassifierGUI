Semantics of Programming Languages
Computer Science Tripos, Part 1B
2008–9
Peter Sewell
Computer Laboratory
University of Cambridge
Schedule:
Lectures 1–8: LT1, MWF 11am, 26 Jan – 11 Feb
Lectures 9–12: LT1, MWF 11am, 27 Feb – 6 March
Time-stamp: <2009-01-04 22:22:54 pes20>
c©Peter Sewell 2003–2009
1
Contents
Syllabus 3
Learning Guide 4
Summary of Notation 5
1 Introduction 8
2 A First Imperative Language 12
2.1 Operational Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.2 Typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.3 L1: Collected Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
3 Induction 42
3.1 Abstract Syntax and Structural Induction . . . . . . . . . . . . . . . . . . . . . . . . 44
3.2 Inductive Definitions and Rule Induction . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.3 Example Proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.4 Inductive Definitions, More Formally (optional) . . . . . . . . . . . . . . . . . . . . . 61
3.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4 Functions 63
4.1 Function Preliminaries: Abstract Syntax up to Alpha Conversion, and Substitution . 65
4.2 Function Behaviour . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
4.3 Function Typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
4.4 Local Definitions and Recursive Functions . . . . . . . . . . . . . . . . . . . . . . . . 76
4.5 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.6 L2: Collected Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
4.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
5 Data 86
5.1 Products, Sums, and Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
5.2 Mutable Store . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
5.3 Evaluation Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
5.4 L3: Collected Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
5.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
6 Subtyping and Objects 100
6.1 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
7 Semantic Equivalence 107
7.1 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8 Concurrency 113
8.1 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
9 Low-level semantics 122
10 Epilogue 122
A How To Do Proofs 126
A.1 How to go about it . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
A.2 And in More Detail... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.2.1 Meet the Connectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.2.2 Equivalences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.2.3 How to Prove a Formula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
A.2.4 How to Use a Formula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
A.3 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
A.3.1 Proving the PL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
A.3.2 Using the PL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
A.4 Sequent Calculus Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
2
Syllabus
This course is a prerequisite for Types (Part II), Denotational Semantics (Part II), and
Topics in Concurrency (Part II).
Aims
The aim of this course is to introduce the structural, operational approach to program-
ming language semantics. It will show how to specify the meaning of typical programming
language constructs, in the context of language design, and how to reason formally about
semantic properties of programs.
Lectures
• Introduction. Transition systems. The idea of structural operational semantics.
Transition semantics of a simple imperative language. Language design options.
• Types. Introduction to formal type systems. Typing for the simple imperative lan-
guage. Statements of desirable properties.
• Induction. Review of mathematical induction. Abstract syntax trees and struc-
tural induction. Rule-based inductive definitions and proofs. Proofs of type safety
properties.
• Functions. Call-by-name and call-by-value function application, semantics and typ-
ing. Local recursive definitions.
• Data. Semantics and typing for products, sums, records, references.
• Subtyping. Record subtyping and simple object encoding.
• Semantic equivalence. Semantic equivalence of phrases in a simple imperative lan-
guage, including the congruence property. Examples of equivalence and non-equivalence.
• Concurrency. Shared variable interleaving. Semantics for simple mutexes; a serial-
izability property.
• Low-level semantics. Monomorphic typed assembly language.
Objectives
At the end of the course students should
• be familiar with rule-based presentations of the operational semantics and type systems
for some simple imperative, functional and interactive program constructs
• be able to prove properties of an operational semantics using various forms of induction
(mathematical, structural, and rule-based)
• be familiar with some operationally-based notions of semantic equivalence of program
phrases and their basic properties
Recommended reading
Hennessy, M. (1990). The semantics of programming languages. Wiley. Out of print, but
available on the web at http://www.cogs.susx.ac.uk/users/matthewh/semnotes.ps.gz
* Pierce, B.C. (2002). Types and programming languages. MIT Press.
Winskel, G. (1993). The formal semantics of programming languages. MIT Press.
3
Learning Guide
Books:
• Hennessy, M. (1990). The Semantics of Programming Languages. Wiley. Out of
print, but available on the web at http://www.cogs.susx.ac.uk/users/matthewh/
semnotes.ps.gz.
Introduces many of the key topics of the course.
• Pierce, B. C. (2002) Types and Programming Languages. MIT Press.
This is a graduate-level text, covering a great deal of material on programming language
semantics. The first half (through to Chapter 15) is relevant to this course, and some of the
later material relevant to the Part II Types course.
• Pierce, B. C. (ed) (2005) Advanced Topics in Types and Programming Languages. MIT
Press.
This is a collection of articles by experts on a range of programming-language semantics topics.
Most of the details are beyond the scope of this course, but it gives a good overview of the
state of the art. The contents are listed at http://www.cis.upenn.edu/~bcpierce/attapl/.
• Winskel, G. (1993). The Formal Semantics of Programming Languages. MIT Press.
An introduction to both operational and denotational semantics; recommended for the Part
II Denotational Semantics course.
Further reading:
• Plotkin, G. D.(1981). A structural approach to operational semantics. Technical
Report DAIMI FN-19, Aarhus University.
These notes first popularised the ‘structural’ approach to operational semantics—the ap-
proach emphasised in this course—but couched solely in terms of transition relations (‘small-
step’ semantics), rather than evaluation relations (‘big-step’, ‘natural’, or ‘relational’ seman-
tics). Although somewhat dated and hard to get hold of (the Computer Laboratory Library
has a copy), they are still a mine of interesting examples.
• The two essays:
Hoare, C. A. R.. Algebra and Models.
Milner, R. Semantic Ideas in Computing.
In: Wand, I. and R. Milner (Eds) (1996). Computing Tomorrow. CUP.
Two accessible essays giving somewhat different perspectives on the semantics of computation
and programming languages.
Implementations: Implementations of some of the languages are available on the course
web page, accessible via http://www.cl.cam.ac.uk/teaching/current.
They are written in Moscow ML. This is installed on the Intel Lab machines. If you want to
work with them on your own machine instead, there are Linux, Windows, and Mac versions
of Moscow ML available at http://www.dina.dk/~sestoft/mosml.html.
Exercises: The notes contain various exercises, some related to the implementations. Those
marked ⋆ should be straightforward checks that you are grasping the material; I suggest
you attempt most of these. Exercises marked ⋆⋆ may need a little more thought – both
proofs and some implementation-related; you should do some of each. Exercises marked
⋆⋆⋆ may need material beyond the notes, and/or be quite time-consuming. Below is a
possible selection of exercises for supervisions.
1. §2.4: 1, 3, 4, 8, 10, 11, 12 (all these should be pretty quick); §3.5: 14, 18, 18.
2. §4.7: 20, 21, 22, 23, 24; §5.5: 29; 2003.5.11.
3. §8.1 (37), 38; §6.1 32, 33, 34; 2003.6.12, mock tripos from www.
4
Tripos questions: This version of the course was first given in 2002–2003. The questions
since then are directly relevant, and there is an additional mock question on the course web
page. The previous version of the course (by Andrew Pitts) used a slightly different form
of operational semantics, ‘big-step’ instead of ‘small-step’ (see Page 82 of these notes), and
different example languages, so the notation in most earlier questions may seem unfamiliar
at first sight.
These questions use only small-step and should be accessible: 1998 Paper 6 Question 12,
1997 Paper 5 Question 12, and 1996 Paper 5 Question 12.
These questions use big-step, but apart from that should be ok: 2002 Paper 5 Question 9,
2002 Paper 6 Question 9, 2001 Paper 5 Question 9, 2000 Paper 5 Question 9, 1999 Paper 6
Question 9 (first two parts only), 1999 Paper 5 Question 9, 1998 Paper 5 Question 12, 1995
Paper 6 Question 12, 1994 Paper 7 Question 13, 1993 Paper 7 Question 10.
These questions depend on material which is no longer in this course (complete partial
orders, continuations, or bisimulation – see the Part II Denotational Semantics and Topics
in Concurrency courses): 2001 Paper 6 Question 9, 2000 Paper 6 Question 9, 1997 Paper 6
Question 12, 1996 Paper 6 Question 12, 1995 Paper 5 Question 12, 1994 Paper 8 Question
12, 1994 Paper 9 Question 12, 1993 Paper 8 Question 10, 1993 Paper 9 Question 10.
Feedback: Please do complete the on-line feedback form at the end of the course, and let
me know during it if you discover errors in the notes or if the pace is too fast or slow. A list
of corrections will be on the course web page.
Acknowledgements: These notes draw, with thanks, on earlier courses by Andrew Pitts,
on Benjamin Pierce’s book, and many other sources. Any errors are, of course, newly
introduced by me.
Summary of Notation
Each section is roughly in the order that notation is introduced. The grammars of the
languages are not included here, but are in the Collected Definitions of L1, L2 and L3 later
in this document.
5
Logic and Set Theory
Φ ∧ Φ′ and
Φ ∨ Φ′ or
Φ⇒ Φ′ implies
¬ Φ not
∀ x .Φ(x ) for all
∃ x .Φ(x ) exists
a ∈ A element of
{a1, ..., an} the set with elements a1, ..., an
A1 ∪ A2 union
A1 ∩ A2 intersection
A1 ⊆ A2 subset or equal
Finite Partial Functions
{a1 7→ b1, ..., an 7→ bn} finite partial function mapping each ai to bi
dom(s) set of elements in the domain of s
f + {a 7→ b} the finite partial function f extended or overridden with a maps to b
Γ, x :T the finite partial function Γ extended with {x 7→ T}
– only used where x not in dom(Γ)
Γ,Γ′ the finite partial function which is the union of Γ and Γ
– only used where they have disjoint domains
{l1 7→ n1, ..., lk 7→ nk} an L1 or L2 store – the finite partial function mapping each li to ni
{l1 7→ v1, ..., lk 7→ vk} an L3 store – the finite partial function mapping each li to vi
l1:intref, ..., lk:intref an L1 type environment – the finite partial function mapping each li to intref
ℓ:intref, ..., x :T , ... an L2 type environment
ℓ:Tloc , ..., x :T , ... an L3 type environment
{e1/x1, .., ek/xk} a substitution – the finite partial function {x1 7→ e1, ..., xk 7→ ek} mapping x1 to
Relations and auxiliary functions
〈e, s〉 −→ 〈e ′, s ′〉 reduction (or transition) step
〈e, s〉 −→∗ 〈e ′, s ′〉 reflexive transitive closure of −→
〈e, s〉 −→k 〈e ′, s ′〉 the k -fold composition of −→
〈e, s〉 −→ω has an infinite reduction sequence (a unary predicate)
〈e, s〉 6−→ cannot reduce (a unary predicate)
Γ ⊢ e:T in type environment Γ, expression e has type T
value(e) e is a value
fv(e) the set of free variables of e
{e/x}e ′ the expression resulting from substituting e for x in e ′
σ e the expression resulting from applying the substituting σ to e
〈e, s〉 ⇓ 〈v , s ′〉 big-step evaluation
Γ ⊢ s store s is well-typed with respect to type environment Γ
T <: T ′ type T is a subtype of type T ′
e ≃ e ′ semantic equivalence (informal)
e ≃TΓ e ′ semantic equivalence at type T with respect to type environment Γ
e
a−→ e ′ single thread transition step, labelled with action a
6
Particular sets
B = {true, false} the set of booleans
L = {l , l1, l2, ...} the set of locations
Z = {..,−1, 0, 1, ...} the set of integers
N = {0, 1, ...} the set of natural numbers
X = {x, y, ...} the set of L2 and L3 variables
LAB = {p, q, ...} the set of record labels
M = {m,m0,m1, ...} the set of mutex names
T the set of all types (in whichever language)
Tloc the set of all location types (in whichever language)
L1 the set of all L1 expressions
TypeEnv the set of all L1 type environments, finite partial functions from L to Z
TypeEnv2 the set of all L2 type environments, the finite partial functions from L ∪ X to Tloc ∪ T
such that ∀ ℓ ∈ dom(Γ).Γ(ℓ) ∈ Tloc and ∀ x ∈ dom(Γ).Γ(x ) ∈ T
A thread actions
Metavariables
b ∈ B boolean
n ∈ Z integer
ℓ ∈ L location
op binary operation
e, f expression (of whichever language)
v value (of whichever language)
s store (of whichever language)
T ∈ T type (of whichever language)
Tloc ∈ Tloc location type (of whichever language)
Γ type environment (also, set of propositional assumptions)
i , k , y natural numbers
c configuration (or state), typically 〈e, s〉 with expression e and store s
Φ formula
c tree constructor
R set of rules
(H , c) a rule with hypotheses H ⊆ A and conclusion c ∈ A for some set A
SR a subset inductively defined by the set of rules R
x ∈ X variable
σ substitution
lab ∈ LAB record label
E evaluation context
C arbitrary context
π permutation of natural numbers
m ∈ M mutex name
M state of all mutexes (a function M :M −→ B)
a thread action, for a ∈ A
Other
hole in a context
C [e] context C with e replacing the hole
7
1 Introduction
Semantics of Programming Languages
Peter Sewell
1B, 12 lectures
2008–9
In this course we will take a close look at programming languages. We will focus on how
one can define precisely what a programming language is – i.e., how the programs of the
language behave, or, more generally, what their meaning, or semantics, is.
Semantics - What is it?
How to describe a programming language? Need to give:
• the syntax of programs; and
• their semantics (the meaning of programs, or how they behave).
Styles of description:
• the language is defined by whatever some particular compiler does
• natural language ‘definitions’
• mathematically
Mathematical descriptions of syntax use formal grammars (eg BNF) –
precise, concise, clear. In this course we’ll see how to work with
mathematical definitions of semantics/behaviour.
Many programming languages that you meet are described only in natural language, e.g.
the English standards documents for C, Java, XML, etc. These are reasonably accessible
(though often written in ‘standardsese’), but there are some major problems. It is very
hard, if not impossible, to write really precise definitions in informal prose. The standards
often end up being ambiguous or incomplete, or just too large and hard to understand.
That leads to differing implementations and flaky systems, as the language implementors
and users do not have a common understanding of what it is. More fundamentally, natural
language standards obscure the real structure of languages – it’s all too easy to add a feature
and a quick paragraph of text without thinking about how it interacts with the rest of the
language.
Instead, as we shall see in this course, one can develop mathematical definitions of how
programs behave, using logic and set theory (e.g. the definition of Standard ML, the .NET
CLR, recent work on XQuery, etc.). These require a little more background to understand
and use, but for many purposes they are a much better tool than informal standards.
What do we use semantics for?
1. to understand a particular language - what you can depend on as a
programmer; what you must provide as a compiler writer
2. as a tool for language design:
(a) for expressing design choices, understanding language features
and how they interact.
(b) for proving properties of a language, eg type safety, decidability of
type inference.
3. as a foundation for proving properties of particular programs
8
Semantics complements the study of language implementation (cf. Compiler Construction
and Optimising Compilers). We need languages to be both clearly understandable, with
precise definitions, and have good implementations.
This is true not just for the major programming languages, but also for intermediate lan-
guages (JVM, CLR), and the many, many scripting and command languages, that have
often been invented on-the-fly without sufficient thought. How many of you will do lan-
guage design? lots!
More broadly, while in this course we will look mostly at semantics for conventional pro-
gramming languages, similar techniques can be used for hardware description languages,
verification of distributed algorithms, security protocols, and so on – all manner of subtle
systems for which relying on informal intuition alone leads to error. Some of these are
explored in Specification and Verification and Topics in Concurrency.
Warmup
In C, if initially x has value 3, what’s the value of the following?
x++ + x++ + x++ + x++
Slide 1
C♯
delegate int IntThunk();
class M {
public static void Main() {
IntThunk[] funcs = new IntThunk[11];
for (int i = 0; i <= 10; i++)
{
funcs[i] = delegate() { return i; };
}
foreach (IntThunk f in funcs)
{
System.Console.WriteLine(f());
}
}
}
9
Slide 2
Ruby (expected)
def printdouble(x) print x*2, "\n" end
x = 123
print "x is ", x, "\n"
printdouble(7)
print "x is ", x, "\n"
Output:
x is 123
14
x is 123
Slide 3
Ruby (unexpected)
def applydouble(y) yield y*2 end
x = 123
print "x is ", x, "\n"
applydouble(7) {|x| print x, "\n" }
print "x is ", x, "\n"
Output of this program is
?
(Thanks to Andrew Kennedy for the C♯ and Ruby examples.)
from Micro to Macro
• simple evaluation order
• what can be stored
• evaluation strategy (call-by-value, call-by-name)
• what can be abstracted over; what can be passed around
• what can/should type systems guarantee at compile-time
• ...
10
Various different approaches have been used for expressing semantics.
Styles of Semantic Definitions
• Operational semantics
• Denotational semantics
• Axiomatic, or Logical, semantics
...Static and dynamic semantics...
Operational: define the meaning of a program in terms of the computation steps it takes in
an idealised execution. Some definitions use structural operational semantics, in which the
intermediate states are described using the language itself; others use abstract machines,
which use more ad-hoc mathematical constructions.
Denotational: define the meaning of a program as elements of some abstract mathematical
structure, e.g. regarding programming-language functions as certain mathematical functions.
cf. the Denotational Semantics course.
Axiomatic or Logical: define the meaning of a program indirectly, by giving the axioms of
a logic of program properties. cf. Specification and Verification.
All these are dynamic semantics, describing behaviour in one way or another. In contrast
the static semantics of a language describes its compile-time typechecking.
‘Toy’ languages
Real programming languages are large, with many features and, often,
with redundant constructs – things that can be expressed in the rest of the
language.
When trying to understand some particular combination of features it’s
usual to define a small ‘toy’ language with just what you’re interested in,
then scale up later. Even small languages can involve delicate design
choices.
What’s this course?
Core
• operational semantics and typing for a tiny language
• technical tools (abstract syntax, inductive definitions, proof)
• design for functions, data and references
More advanced topics
• Subtyping and Objects
• Low-level Semantics (Typed Assembly Language)
• Semantic Equivalence
• Concurrency
11
(assignment and while ) L11,2,3,4
(functions and recursive definitions) L25,6
Operational semantics
Type systems
Implementations
Language design choices
Inductive definitions
Inductive proof – structural; rule
Abstract syntax up to alpha
(products, sums, records, references) L38
Subtyping
and Objects9
uuuuuuuuu
Semantic
Equivalence11
0000000000000000000000
TAL10 Concurrency12
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
In the core we will develop enough techniques to deal with the semantics of a non-trivial
small language, showing some language-design pitfalls and alternatives along the way. It
will end up with the semantics of a decent fragment of ML. The second part will cover a
selection of more advanced topics.
The Big Picture (a Semantic-O-Centric view...)
Discrete
Maths
&&LL
LL
LL
LL
LL
LL
LL
LL
LL
LL
LL
LL
LL
L RLFA
9
99
99
99
99
99
99
99
99
99
Logic
& Proof

ML










Java and
CSAA
yyrrr
rr
rr
rr
rr
rr
rr
rr
rr
rr
rr
rr
r
Computability
ttiiii
iiii
iiii
iiii
iiii
ii
Compiler
Construction
and Optimising
Compilers
Semantics
yyrrr
rr
rr
rr
rr
rr
rr
rr
rr
rr
rr
rr
rr
r









 
99
99
99
99
99
99
99
99
99
Foundations of
Functional
Programming
Types Topics inConcurrency Spec&Ver I,II
Denotational
Semantics
Advanced
Programming
Languages?
Admin
• Please let me know of typos, and if it is too fast/too slow/too
interesting/too dull (please complete the on-line feedback at the end)
• Not all previous Tripos questions are relevant (see the notes)
• Exercises in the notes.
• Implementations on web.
• Books (Hennessy, Pierce, Winskel)
2 A First Imperative Language
L1
12
L1 – Example
L1 is an imperative language with store locations (holding integers),
conditionals, and while loops. For example, consider the program
l2 := 0;
while !l1 ≥ 1 do (
l2 :=!l2+!l1;
l1 :=!l1 +−1)
in the initial store {l1 7→ 3, l2 7→ 0}.
L1 – Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Operations op ::= + |≥
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2
Write L1 for the set of all expressions.
Points to note:
• we’ll return later to exactly what the set L1 is when we talk about abstract syntax
• unbounded integers
• abstract locations – can’t do pointer arithmetic on them
• untyped, so have nonsensical expressions like 3 + true
• what kind of grammar is that?
• don’t have expression/command distinction
• doesn’t much matter what basic operators we have
• carefully distinguish metavariables b,n, ℓ, op , e etc. from program locations l etc..
2.1 Operational Semantics
In order to describe the behaviour of L1 programs we will use structural operational seman-
tics to define various forms of automata:
13
Transition systems
A transition system consists of
• a set Config, and
• a binary relation−→⊆ Config ∗ Config.
The elements of Config are often called configurations or states. The
relation−→ is called the transition or reduction relation. We write−→
infix, so c −→ c ′ should be read as ‘state c can make a transition to
state c ′’.
To compare with the automata you saw in Regular Languages and Finite Automata: a
transition system is like an NFAε with an empty alphabet (so only ε transitions) except (a)
it can have infinitely many states, and (b) we don’t specify a start state or accepting states.
Sometimes one adds labels (e.g. to represent IO) but mostly we’ll just look at the values of
terminated states, those that cannot do any transitions.
Some handy auxilary notation:
• −→∗ is the reflexive transitive closure of −→, so c −→∗ c′ iff there exist k ≥ 0 and
c0, .., ck such that c = c0 −→ c1... −→ ck = c′.
• 6−→ is a unary predicate (a subset of Config) defined by c 6−→ iff ¬ ∃ c′.c −→ c′.
• The transition relation is deterministic if for all states c there is at most one c′ such
that c −→ c′, ie if ∀ c.∀ c′, c′′.(c −→ c′ ∧ c −→ c′′) =⇒ c′ = c′′.
The particular transition systems we use for L1 are as follows.
L1 Semantics (1 of 4) – Configurations
Say stores s are finite partial functions from L to Z. For example:
{l1 7→ 7, l3 7→ 23}
Take configurations to be pairs 〈e, s〉 of an expression e and a store s , so
our transition relation will have the form
〈e, s〉 −→ 〈e ′, s ′〉
A finite partial function f from a set A to a set B is a set containing a finite number n ≥ 0
of pairs {(a1, b1), ..., (an , bn)}, often written {a1 7→ b1, ..., an 7→ bn}, for which
• ∀ i ∈ {1, ..,n}.ai ∈ A (the domain is a subset ofA)
• ∀ i ∈ {1, ..,n}.bi ∈ B (the range is a subset of B)
• ∀ i ∈ {1, ..,n}, j ∈ {1, ..,n}.i 6= j ⇒ ai 6= aj (f is functional, i.e. each element of A is
mapped to at most one element of B)
For a partial function f , we write dom(f ) for the set of elements in the domain of f (things
that f maps to something) and ran(f ) for the set of elements in the range of f (things that
something is mapped to by f ). For example, for the s above we have dom(s) = {l1, l3} and
ran(s) = {7, 23}. Note that a finite partial function can be empty, just {}.
We write store for the set of all stores.
14
Transitions are single computation steps. For example we will have:
〈l := 2+!l , {l 7→ 3}〉
−→ 〈l := 2 + 3, {l 7→ 3}〉
−→ 〈l := 5, {l 7→ 3}〉
−→ 〈skip, {l 7→ 5}〉
6−→
want to keep on until we get to a value v , an expression in
V = B ∪ Z ∪ {skip}.
Say 〈e, s〉 is stuck if e is not a value and 〈e, s〉 6−→. For example
2 + true will be stuck.
We could define the values in a different, but equivalent, style: Say values v are expressions
from the grammar v ::= b | n | skip.
Now define the behaviour for each construct of L1 by giving some rules that (together)
define a transition relation −→.
L1 Semantics (2 of 4) – Rules (basic operations)
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
How to read these? The rule (op +) says that for any instantiation of the metavariables
n, n1 and n2 (i.e. any choice of three integers), that satisfies the sidecondition, there is a
transition from the instantiated configuration on the left to the one on the right.
We use a strict naming convention for metavariables: n can only be instantiated by integers,
not by arbitrary expressions, cabbages, or what-have-you.
The rule (op1) says that for any instantiation of e1, e
′
1, e2, s, s
′ (i.e. any three expressions
and two stores), if a transition of the form above the line can be deduced then we can
deduce the transition below the line. We’ll be more precise about this later.
Observe that – as you would expect – none of these first rules introduce changes in the store
part of configurations.
15
Example
If we want to find the possible sequences of transitions of
〈(2 + 3) + (6 + 7), ∅〉 ... look for derivations of transitions.
(you might think the answer should be 18 – but we want to know what this
definition says happens)
(op1)
(op +)
〈2 + 3, ∅〉 −→ 〈5, ∅〉
〈(2 + 3) + (6 + 7), ∅〉 −→ 〈5 + (6 + 7), ∅〉
(op2)
(op +)
〈6 + 7, ∅〉 −→ 〈13, ∅〉
〈5 + (6 + 7), ∅〉 −→ 〈5 + 13, ∅〉
(op +)
〈5 + 13, ∅〉 −→ 〈18, ∅〉
First transition: using (op1) with e1 = 2 + 3, e
′
1 = 5, e2 = 6 + 7, op = +, s = ∅, s ′ = ∅,
and using (op +) with n1 = 2, n2 = 3, s = ∅. Note couldn’t begin with (op2) as e1 = 2 + 3
is not a value, and couldn’t use (op +) directly on (2 + 3) + (6 + 7) as 2 + 3 and 6 + 7 are
not numbers from Z – just expressions which might eventually evaluate to numbers (recall,
by convention the n in the rules ranges over Z only).
Second transition: using (op2) with e1 = 5, e2 = 6 + 7, e
′
2 = 13, op = +, s = ∅, s ′ = ∅,
and using (op +) with n1 = 6, n2 = 7, s = ∅. Note that to use (op2) we needed that e1 = 5
is a value. We couldn’t use (op1) as e1 = 5 does not have any transitions itself.
Third transition: using (op +) with n1 = 5, n2 = 13, s = ∅.
To find each transition we do something like proof search in natural deduction: starting
with a state (at the bottom left), look for a rule and an instantiation of the metavariables
in that rule that makes the left-hand-side of its conclusion match that state. Beware that
in general there might be more than one rule and one instantiation that does this. If there
isn’t a derivation concluding in 〈e, s〉 −→ 〈e ′, s ′〉 then there isn’t such a transition.
L1 Semantics (3 of 4) – store and sequencing
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
Example
〈l := 3; !l , {l 7→ 0}〉 −→ 〈skip; !l , {l 7→ 3}〉
−→ 〈!l , {l 7→ 3}〉
−→ 〈3, {l 7→ 3}〉
〈l := 3; l :=!l , {l 7→ 0}〉 −→ ?
〈15+!l , ∅〉 −→ ?
16
L1 Semantics (4 of 4) – The rest (conditionals and while)
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2; while e1 do e2) else skip, s〉
Example
If
e = (l2 := 0; while !l1 ≥ 1 do (l2 :=!l2+!l1; l1 :=!l1 +−1))
s = {l1 7→ 3, l2 7→ 0}
then
〈e, s〉 −→∗ ?
Slide 4
L1: Collected Definition
Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Operations op ::= + |≥
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2
Operational Semantics
Note that for each construct there are some computation rules, doing ‘real work’, and
some context (or congruence) rules, allowing subcomputations and specifying their or-
der.
Say stores s are finite partial functions from L to Z. Say values v are expressions from
the grammar v ::= b | n | skip.
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2; while e1 do e2) else skip, s〉
Determinacy
Theorem 1 (L1 Determinacy) If 〈e, s〉 −→ 〈e1, s1〉 and
〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉.
Proof - see later
Note that top-level universal quantifiers are usually left out – the theorem really says “For
all e, s, e1, s1, e2, s2, if 〈e, s〉 −→ 〈e1, s1〉 and 〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉”.
17
L1 Implementation
Many possible implementation strategies, including:
1. animate the rules — use unification to try to match rule conclusion
left-hand-sides against a configuration; use backtracking search to find
all possible transitions. Hand-coded, or in Prolog/LambdaProlog/Twelf.
2. write an interpreter working directly over the syntax of configurations.
Coming up, in ML and Java.
3. compile to a stack-based virtual machine, and an interpreter for that.
See Compiler Construction.
4. compile to assembly language, dealing with register allocation etc. etc.
See Compiler Construction/Optimizing Compilers.
L1 Implementation
Will implement an interpreter for L1, following the definition. Use mosml
(Moscow ML) as the implementation language, as datatypes and pattern
matching are good for this kind of thing.
First, must pick representations for locations, stores, and expressions:
type loc = string
type store = (loc * int) list
We’ve chosen to represent locations as strings, rather arbitrarily (really, so they pretty-print
trivially). A lower-level implementation would use ML references or, even lower, machine
pointers.
In the semantics, a store is a finite partial function from locations to integers. In the
implementation, we represent a store as a list of loc*int pairs containing, for each ℓ in the
domain of the store and mapped to n, exactly one element of the form (l,n). The order of
the list will not be important. This is not a very efficient implementation, but it is simple.
datatype oper = Plus | GTEQ
datatype expr =
Integer of int
| Boolean of bool
| Op of expr * oper * expr
| If of expr * expr * expr
| Assign of loc * expr
| Deref of loc
| Skip
| Seq of expr * expr
| While of expr * expr
The expression and operation datatypes have essentially the same form as the abstract
grammar. Note, though, that it does not exactly match the semantics, as that allowed
arbitrary integers whereas here we use the bounded Moscow ML integers – so not every
term of the abstract syntax is representable as an element of type expr, and the interpreter
will fail with an overflow exception if + overflows.
18
Store operations
Define auxiliary operations
lookup : store*loc -> int option
update : store*(loc*int) -> store option
which both return NONE if given a location that is not in the domain of the
store. Recall that a value of type T option is either NONE or
SOME v for a value v of T.
The single-step function
Now define the single-step function
reduce : expr*store -> (expr*store) option
which takes a configuration (e,s) and returns either
NONE, if 〈e, s〉 6−→,
or SOME (e’,s’), if it has a transition 〈e, s〉 −→ 〈e ′, s ′〉.
Note that if the semantics didn’t define a deterministic transition system
we’d have to be more elaborate.
(you might think it would be better ML style to use exceptions instead of these options;
that would be fine).
(op +), (op≥)
fun reduce (Integer n,s) = NONE
| reduce (Boolean b,s) = NONE
| reduce (Op (e1,opr,e2),s) =
(case (e1,opr,e2) of
(Integer n1, Plus, Integer n2) =>
SOME(Integer (n1+n2), s)
| (Integer n1, GTEQ, Integer n2) =>
SOME(Boolean (n1 >= n2), s)
| (e1,opr,e2) =>
...
Contrast this code with the semantic rules given earlier.
(op1), (op2)
...
if (is value e1) then
case reduce (e2,s) of
SOME (e2’,s’) =>
SOME (Op(e1,opr,e2’),s’)
| NONE => NONE
else
case reduce (e1,s) of
SOME (e1’,s’) =>
SOME(Op(e1’,opr,e2),s’)
| NONE => NONE )
19
Note that the code depends on global properties of the semantics, including the fact that it
defines a deterministic transition system, so the comments indicating that particular lines
of code implement particular semantic rules are not the whole story.
(assign1), (assign2)
| reduce (Assign (l,e),s) =
(case e of
Integer n =>
(case update (s,(l,n)) of
SOME s’ => SOME(Skip, s’)
| NONE => NONE)
| =>
(case reduce (e,s) of
SOME (e’,s’) =>
SOME(Assign (l,e’), s’)
| NONE => NONE ) )
The many-step evaluation function
Now define the many-step evaluation function
evaluate: expr*store -> (expr*store) option
which takes a configuration (e,s) and returns the (e’,s’) such that
〈e, s〉 −→∗ 〈e ′, s ′〉 6−→, if there is such, or does not return.
fun evaluate (e,s) =
case reduce (e,s) of
NONE => (e,s)
| SOME (e’,s’) => evaluate (e’,s’)
Demo
The full interpreter code is available on the web, in the file l1.ml, together with a pretty-
printer and the type-checker we will come to soon. You should make it go...
(* 2002-11-08 -- Time-stamp: <2004-01-03 16:17:04 pes20> -*-SML-*- *)
(* Peter Sewell *)
(* This file contains an interpreter, pretty-printer and type-checker
for the language L1. To make it go, copy it into a working
directory, ensure Moscow ML is available, and type
mosml -P full l1.ml
That will give you a MoscowML top level in which these definitions
are present. You can then type
doit ();
to show the reduction sequence of < l1:=3;!l1 , l1=0 >, and
doit2 ();
to run the type-checker on the same simple example; you can try
other examples analogously. This file doesn’t have a parser for
20
l1, so you’ll have to enter the abstract syntax directly, eg
prettyreduce (Seq( Assign ("l1",Integer 3), Deref "l1"), [("l1",0)]);
This has been tested with Moscow ML version 2.00 (June 2000), but
should work with any other implementation of Standard ML. *)
(* *********************)
(* the abstract syntax *)
(* *********************)
type loc = string
datatype oper = Plus | GTEQ
datatype expr =
Integer of int
| Boolean of bool
| Op of expr * oper * expr
| If of expr * expr * expr
| Assign of loc * expr
| Deref of loc
| Skip
| Seq of expr * expr
| While of expr * expr
(* **********************************)
(* an interpreter for the semantics *)
(* **********************************)
fun is_value (Integer n) = true
| is_value (Boolean b) = true
| is_value (Skip) = true
| is_value _ = false
(* In the semantics, a store is a finite partial function from
locations to integers. In the implementation, we represent a store
as a list of loc*int pairs containing, for each l in the domain of
the store, exactly one element of the form (l,n). The operations
lookup : store * loc -> int option
update : store * (loc * int) -> store option
both return NONE if given a location that is not in the domain of
the store. This is not a very efficient implementation, but it is
simple. *)
type store = (loc * int) list
fun lookup ( [], l ) = NONE
| lookup ( (l’,n’)::pairs, l) =
if l=l’ then SOME n’ else lookup (pairs,l)
fun update’ front [] (l,n) = NONE
| update’ front ((l’,n’)::pairs) (l,n) =
if l=l’ then
SOME(front @ ((l,n)::pairs) )
else
update’ ((l’,n’)::front) pairs (l,n)
21
fun update (s, (l,n)) = update’ [] s (l,n)
(* now define the single-step function
reduce : expr * store -> (expr * store) option
which takes a configuration (e,s) and returns either NONE, if it has
no transitions, or SOME (e’,s’), if it has a transition (e,s) -->
(e’,s’).
Note that the code depends on global properties of the semantics,
including the fact that it defines a deterministic transition
system, so the comments indicating that particular lines of code
implement particular semantic rules are not the whole story. *)
fun reduce (Integer n,s) = NONE
| reduce (Boolean b,s) = NONE
| reduce (Op (e1,opr,e2),s) =
(case (e1,opr,e2) of
(Integer n1, Plus, Integer n2) => SOME(Integer (n1+n2), s) (*op + *)
| (Integer n1, GTEQ, Integer n2) => SOME(Boolean (n1 >= n2), s)(*op >=*)
| (e1,opr,e2) => (
if (is_value e1) then (
case reduce (e2,s) of
SOME (e2’,s’) => SOME (Op(e1,opr,e2’),s’) (* (op2) *)
| NONE => NONE )
else (
case reduce (e1,s) of
SOME (e1’,s’) => SOME(Op(e1’,opr,e2),s’) (* (op1) *)
| NONE => NONE ) ) )
| reduce (If (e1,e2,e3),s) =
(case e1 of
Boolean(true) => SOME(e2,s) (* (if1) *)
| Boolean(false) => SOME(e3,s) (* (if2) *)
| _ => (case reduce (e1,s) of
SOME(e1’,s’) => SOME(If(e1’,e2,e3),s’) (* (if3) *)
| NONE => NONE ))
| reduce (Deref l,s) =
(case lookup (s,l) of
SOME n => SOME(Integer n,s) (* (deref) *)
| NONE => NONE )
| reduce (Assign (l,e),s) =
(case e of
Integer n => (case update (s,(l,n)) of
SOME s’ => SOME(Skip, s’) (* (assign1) *)
| NONE => NONE)
| _ => (case reduce (e,s) of
SOME (e’,s’) => SOME(Assign (l,e’), s’) (* (assign2) *)
| NONE => NONE ) )
| reduce (While (e1,e2),s) = SOME( If(e1,Seq(e2,While(e1,e2)),Skip),s) (* (while) *)
| reduce (Skip,s) = NONE
| reduce (Seq (e1,e2),s) =
(case e1 of
Skip => SOME(e2,s) (* (seq1) *)
| _ => ( case reduce (e1,s) of
SOME (e1’,s’) => SOME(Seq (e1’,e2), s’) (* (seq2) *)
| NONE => NONE ) )
(* now define the many-step evaluation function
22
evaluate : expr * store -> (expr * store) option
which takes a configuration (e,s) and returns the unique (e’,s’)
such that (e,s) -->* (e’,s’) -/->. *)
fun evaluate (e,s) = case reduce (e,s) of
NONE => (e,s)
| SOME (e’,s’) => evaluate (e’,s’)
The Java Implementation
Quite different code structure:
• the ML groups together all the parts of each algorithm, into the
reduce, infertype, and prettyprint functions;
• the Java groups together everything to do with each clause of the
abstract syntax, in the IfThenElse, Assign, etc. classes.
23
For comparison, here is a Java implementation – with thanks to Matthew Parkinson. This
includes code for type inference (the ML code for which is on Page 37) and printy-printing
(in l1.ml but not shown above).
Note the different code organisation between the ML and Java versions: the ML has a
datatype with a constructor for each clause of the abstract syntax grammar, and reduce
and infertype function definitions that each have a case for each of those constructors; the
Java has a subclass of Expression for each clause of the abstract syntax, each of which
defines smallStep and typecheck methods.
public class L1 {
public static void main(String [] args) {
Location l1 = new Location ("l1");
Location l2 = new Location ("l2");
Location l3 = new Location ("l3");
State s1 = new State()
.add(l1,new Int(1))
.add(l2,new Int(5))
.add(l3,new Int(0));
Environment env = new Environment()
.add(l1).add(l2).add(l3);
Expression e =
new Seq(new While(new GTeq(new Deref(l2),new Deref(l1)),
new Seq(new Assign(l3, new Plus(new Deref(l1),new Deref(l3))),
new Assign(l1,new Plus(new Deref(l1),new Int(1))))
),
new Deref(l3))
;
try{
//Type check
Type t= e.typeCheck(env);
System.out.println("Program has type: " + t);
//Evaluate program
System.out.println(e + "\n \n");
while(!(e instanceof Value) ){
e = e.smallStep(s1);
//Display each step of reduction
System.out.println(e + "\n \n");
}
//Give some output
System.out.println("Program has type: " + t);
System.out.println("Result has type: " + e.typeCheck(env));
System.out.println("Result: " + e);
System.out.println("Terminating State: " + s1);
} catch (TypeError te) {
System.out.println("Error:\n" + te);
System.out.println("From code:\n" + e);
} catch (CanNotReduce cnr) {
System.out.println("Caught Following exception" + cnr);
System.out.println("While trying to execute:\n " + e);
System.out.println("In state: \n " + s1);
}
}
}
class Location {
String name;
24
Location(String n) {
this.name = n;
}
public String toString() {return name;}
}
class State {
java.util.HashMap store = new java.util.HashMap();
//Used for setting the initial store for testing not used by
//semantics of L1
State add(Location l, Value v) {
store.put(l,v);
return this;
}
void update(Location l, Value v) throws CanNotReduce {
if(store.containsKey(l)) {
if(v instanceof Int) {
store.put(l,v);
}
else throw new CanNotReduce("Can only store integers");
}
else throw new CanNotReduce("Unknown location!");
}
Value lookup(Location l) throws CanNotReduce {
if(store.containsKey(l)) {
return (Int)store.get(l);
}
else throw new CanNotReduce("Unknown location!");
}
public String toString() {
String ret = "[";
java.util.Iterator iter = store.entrySet().iterator();
while(iter.hasNext()) {
java.util.Map.Entry e = (java.util.Map.Entry)iter.next();
ret += "(" + e.getKey() + " |-> " + e.getValue() + ")";
if(iter.hasNext()) ret +=", ";
}
return ret + "]";
}
}
class Environment {
java.util.HashSet env = new java.util.HashSet();
//Used to initially setup environment, not used by type checker.
Environment add(Location l) {
env.add(l); return this;
}
boolean contains(Location l) {
return env.contains(l);
}
}
class Type {
int type;
Type(int t) {type = t;}
public static final Type BOOL = new Type(1);
public static final Type INT = new Type(2);
public static final Type UNIT = new Type(3);
25
public String toString() {
switch(type) {
case 1: return "BOOL";
case 2: return "INT";
case 3: return "UNIT";
}
return "???";
}
}
abstract class Expression {
abstract Expression smallStep(State state) throws CanNotReduce;
abstract Type typeCheck(Environment env) throws TypeError;
}
abstract class Value extends Expression {
final Expression smallStep(State state) throws CanNotReduce{
throw new CanNotReduce("I’m a value");
}
}
class CanNotReduce extends Exception{
CanNotReduce(String reason) {super(reason);}
}
class TypeError extends Exception { TypeError(String reason) {super(reason);}}
class Bool extends Value {
boolean value;
Bool(boolean b) {
value = b;
}
public String toString() {
return value ? "TRUE" : "FALSE";
}
Type typeCheck(Environment env) throws TypeError {
return Type.BOOL;
}
}
class Int extends Value {
int value;
Int(int i) {
value = i;
}
public String toString(){return ""+ value;}
Type typeCheck(Environment env) throws TypeError {
return Type.INT;
}
}
class Skip extends Value {
public String toString(){return "SKIP";}
Type typeCheck(Environment env) throws TypeError {
return Type.UNIT;
}
}
26
class Seq extends Expression {
Expression exp1,exp2;
Seq(Expression e1, Expression e2) {
exp1 = e1;
exp2 = e2;
}
Expression smallStep(State state) throws CanNotReduce {
if(exp1 instanceof Skip) {
return exp2;
} else {
return new Seq(exp1.smallStep(state),exp2);
}
}
public String toString() {return exp1 + "; " + exp2;}
Type typeCheck(Environment env) throws TypeError {
if(exp1.typeCheck(env) == Type.UNIT) {
return exp2.typeCheck(env);
}
else throw new TypeError("Not a unit before ’;’.");
}
}
class GTeq extends Expression {
Expression exp1, exp2;
GTeq(Expression e1,Expression e2) {
exp1 = e1;
exp2 = e2;
}
Expression smallStep(State state) throws CanNotReduce {
if(!( exp1 instanceof Value)) {
return new GTeq(exp1.smallStep(state),exp2);
} else if (!( exp2 instanceof Value)) {
return new GTeq(exp1, exp2.smallStep(state));
} else {
if( exp1 instanceof Int && exp2 instanceof Int ) {
return new Bool(((Int)exp1).value >= ((Int)exp2).value);
}
else throw new CanNotReduce("Operands are not both integers.");
}
}
public String toString(){return exp1 + " >= " + exp2;}
Type typeCheck(Environment env) throws TypeError {
if(exp1.typeCheck(env) == Type.INT && exp2.typeCheck(env) == Type.INT) {
return Type.BOOL;
}
else throw new TypeError("Arguments not both integers.");
}
}
class Plus extends Expression {
Expression exp1, exp2;
Plus(Expression e1,Expression e2) {
exp1 = e1;
exp2 = e2;
}
Expression smallStep(State state) throws CanNotReduce {
27
if(!( exp1 instanceof Value)) {
return new Plus(exp1.smallStep(state),exp2);
} else if (!( exp2 instanceof Value)) {
return new Plus(exp1, exp2.smallStep(state));
} else {
if( exp1 instanceof Int && exp2 instanceof Int ) {
return new Int(((Int)exp1).value + ((Int)exp2).value);
}
else throw new CanNotReduce("Operands are not both integers.");
}
}
public String toString(){return exp1 + " + " + exp2;}
Type typeCheck(Environment env) throws TypeError {
if(exp1.typeCheck(env) == Type.INT && exp2.typeCheck(env) == Type.INT) {
return Type.INT;
}
else throw new TypeError("Arguments not both integers.");
}
}
class IfThenElse extends Expression {
Expression exp1,exp2,exp3;
IfThenElse (Expression e1, Expression e2,Expression e3) {
exp1 = e1;
exp2 = e2;
exp3 = e3;
}
Expression smallStep(State state) throws CanNotReduce {
if(exp1 instanceof Value) {
if(exp1 instanceof Bool) {
if(((Bool)exp1).value)
return exp2;
else
return exp3;
}
else throw new CanNotReduce("Not a boolean in test.");
}
else {
return new IfThenElse(exp1.smallStep(state),exp2,exp3);
}
}
public String toString() {return "IF " + exp1 + " THEN " + exp2 + " ELSE " + exp3;}
Type typeCheck(Environment env) throws TypeError {
if(exp1.typeCheck(env) == Type.BOOL) {
Type t = exp2.typeCheck(env);
if(exp3.typeCheck(env) == t)
return t;
else throw new TypeError("If branchs not the same type.");
}
else throw new TypeError("If test is not bool.");
}
}
class Assign extends Expression {
Location l;
Expression exp1;
28
Assign(Location l, Expression exp1) {
this.l = l;
this.exp1 = exp1;
}
Expression smallStep(State state) throws CanNotReduce{
if(exp1 instanceof Value) {
state.update(l,(Value)exp1);
return new Skip();
}
else {
return new Assign(l,exp1.smallStep(state));
}
}
public String toString() {return l + " = " + exp1;}
Type typeCheck(Environment env) throws TypeError {
if(env.contains(l) && exp1.typeCheck(env) == Type.INT) {
return Type.UNIT;
}
else throw new TypeError("Invalid assignment");
}
}
class Deref extends Expression {
Location l;
Deref(Location l) {
this.l = l;
}
Expression smallStep(State state) throws CanNotReduce {
return state.lookup(l);
}
public String toString() {return "!" + l;}
Type typeCheck(Environment env) throws TypeError {
if(env.contains(l)) return Type.INT;
else throw new TypeError("Location not known about!");
}
}
class While extends Expression {
Expression exp1,exp2;
While(Expression e1, Expression e2) {
exp1 = e1;
exp2 = e2;
}
Expression smallStep(State state) throws CanNotReduce {
return new IfThenElse(exp1,new Seq(exp2, this), new Skip());
}
public String toString(){return "WHILE " + exp1 + " DO {" + exp2 +"}";}
Type typeCheck(Environment env) throws TypeError {
if(exp1.typeCheck(env) == Type.BOOL && exp2.typeCheck(env) == Type.UNIT)
return Type.UNIT;
else throw new TypeError("Error in while loop");
}
}
29
L1 is a simple language, but it nonetheless involves several language design choices.
Language design 1. Order of evaluation
For (e1 op e2), the rules above say e1 should be fully reduced, to a
value, before we start reducing e2. For example:
〈(l := 1; 0) + (l := 2; 0), {l 7→ 0}〉 −→5 〈0, {l → 2 }〉
For right-to-left evaluation, replace (op1) and (op2) by
(op1b)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈e1 op e2, s〉 −→ 〈e1 op e ′2, s ′〉
(op2b)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op v , s〉 −→ 〈e ′1 op v , s ′〉
In this language (call it L1b)
〈(l := 1; 0) + (l := 2; 0), {l 7→ 0}〉 −→5 〈0, {l → 1 }〉
For programmers whose first language has left-to-right reading order, left-to-right evaluation
is arguably more intuitive than right-to-left. Nonetheless, some languages are right-to-left
for efficiency reasons (e.g. OCaml bytecode).
It is important to have the same order for all operations, otherwise we certainly have a
counter-intuitive language.
One could also underspecify, taking both (op1) and (op1b) rules. That language doesn’t
have the Determinacy property.
Sometimes ordering really is not always guaranteed, say for two writes l := 1; l := 2. In L1
it is defined, but if we were talking about a setting with a cache (either processors, or disk
block writes, or something) we might have to do something additional to force ordering.
Similarly if you have concurrency l := 1 | l := 2. Work on redesigning the Java Memory
Model by Doug Lea and Bill Pugh, which involves this kind of question, can be found at
http://www.cs.umd.edu/~pugh/java/memoryModel/.
One could also underspecify in a language definition but require each implementation to
use a consistent order, or require each implementation to use a consistent order for each
operator occurrence in the program source code. A great encouragement to the bugs...
Language design 2. Assignment results
Recall
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
So
〈l := 1; l := 2, {l 7→ 0}〉 −→ 〈skip; l := 2, {l 7→ 1}〉
−→∗ 〈skip, {l 7→ 2}〉
We’ve chosen ℓ := n to result in skip, and e1; e2 to only progress if
e1 = skip, not for any value. Instead could have this:
(assign1’) 〈ℓ := n, s〉 −→ 〈n, s + (ℓ 7→ n)〉 if ℓ ∈ dom(s)
(seq1’) 〈v ; e2, s〉 −→ 〈e2, s〉
Matter of taste?
30
Another possiblity: return the old value, e.g. in ANSI C signal handler installation sig-
nal(n,h). Atomicity?
Language design 3. Store initialisation
Recall that
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
both require ℓ ∈ dom(s), otherwise the expressions are stuck.
Instead, could
1. implicitly initialise all locations to 0, or
2. allow assignment to an ℓ /∈ dom(s) to initialise that ℓ.
These would both be bad design decisions, liable to lead to ghastly bugs, with locations
initialised on some code path but not others. Option 1 would be particularly awkward in
a richer language where values other than integers can be stored, where there may not be
any sensible value to default-initialise to.
Looking ahead, any reasonable type system will rule out, at compile-time, any program that
could reach a stuck expression of these forms.
Language design 4. Storable values
Recall stores s are finite partial functions from L to Z, with rules:
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
Can store only integers. 〈l := true, s〉 is stuck.
This is annoying – unmotivated irregularity – why not allow storage of any
value? of locations? of expressions???
Also, store is global....leading to ghastly programming in big code. Will
revisit later.
Language design 5. Operators and basic values
Booleans are really not integers (pace C)
How many operators? Obviously want more than just + and≥. But this is
semantically dull - in a full language would add in many, in standard
libraries.
(beware, it’s not completely dull - eg floating point specs! Even the L1 impl
and semantics aren’t in step.).
Exercise: fix the implementation to match the semantics.
Exercise: fix the semantics to match the implementation.
31
Slide 5
L1: Collected Definition
Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Operations op ::= + |≥
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2
Operational Semantics
Note that for each construct there are some computation rules, doing ‘real work’, and
some context (or congruence) rules, allowing subcomputations and specifying their or-
der.
Say stores s are finite partial functions from L to Z. Say values v are expressions from
the grammar v ::= b | n | skip.
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2; while e1 do e2) else skip, s〉
Expressiveness
Is L1 expressive enough to write interesting programs?
• yes: it’s Turing-powerful (try coding an arbitrary register machine in
L1).
• no: there’s no support for gadgets like functions, objects, lists, trees,
modules,.....
Is L1 too expressive? (ie, can we write too many programs in it)
• yes: we’d like to forbid programs like 3 + false as early as possible,
not wait for a runtime error (which might occur only on some execution
paths). We’ll do so with a type system.
2.2 Typing
L1 Typing
Type Systems
used for
• preventing certain kinds of errors
• structuring programs
• guiding language design
32
Type systems are also used to provide information to compiler optimisers; to enforce security
properties, from simple absence of buffer overflows to sophisticated information-flow policies;
and (in research languages) for many subtle properties, e.g. type systems that allow only
polynomial-time computation. There are rich connections with logic, which we’ll return to
later.
Run-time errors
Trapped errors. Cause execution to halt immediately. (E.g. jumping to an
illegal address, raising a top-level exception, etc.) Innocuous?
Untrapped errors. May go unnoticed for a while and later cause arbitrary
behaviour. (E.g. accessing data past the end of an array, security
loopholes in Java abstract machines, etc.) Insidious!
Given a precise definition of what constitutes an untrapped run-time error,
then a language is safe if all its syntactically legal programs cannot cause
such errors.
Usually, safety is desirable. Moreover, we’d like as few trapped errors as
possible.
We cannot expect to exclude all trapped errors, eg arith overflows, or out-of-memory errors,
but certainly want to exclude all untrapped errors.
So, how to do so? Can use runtime checks and compile-time checks – want compile-time
where possible.
Formal type systems
Divide programs into the good and the bad...
We will define a ternary relation Γ ⊢ e:T , read as ‘expression e has type
T , under assumptions Γ on the types of locations that may occur in e ’.
For example (according to the definition coming up):
{} ⊢ if true then 2 else 3 + 4 : int
l1:intref ⊢ if !l1 ≥ 3 then !l1 else 3 : int
{} 6⊢ 3 + false : T for any T
{} 6⊢ if true then 3 else false : int
Note that the last is excluded despite the fact that when you execute the program you will
always get an int – type systems define approximations to the behaviour of programs, often
quite crude – and this has to be so, as we generally would like them to be decidable, so that
compilation is guaranteed to terminate.
Types for L1
Types of expressions:
T ::= int | bool | unit
Types of locations:
Tloc ::= intref
Write T and Tloc for the sets of all terms of these grammars.
Let Γ range over TypeEnv, the finite partial functions from locations L
to Tloc. Notation: write a Γ as l1:intref, ..., lk:intref instead of
{l1 7→ intref, ..., lk 7→ intref}.
33
• concretely, T = {int, bool, unit} and Tloc = {intref}.
• in this (very small!) language, there is only one type in Tloc, so a Γ is (up to isomor-
phism) just a set of locations. Later, Tloc will be more interesting...
• our semantics only let you store integers, so we have stratified types into T and Tloc.
If you wanted to store other values, you’d say
T ::= int | bool | unit
Tloc ::= T ref
If you wanted to be able to manipulate references as first-class objects, the typing
would be
T ::= int | bool | unit | T ref
Tloc ::= T ref
and there would be consequent changes (what exactly?) to the syntax and the se-
mantics. This is our first sight of an important theme: type-system-directed language
design.
Defining the type judgement Γ ⊢ e:T (1 of 3)
(int) Γ ⊢ n:int for n ∈ Z
(bool) Γ ⊢ b:bool for b ∈ {true, false}
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
(op≥)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 ≥ e2:bool
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
Note that in (if) the T is arbitrary, so long as both premises have the same T .
In some rules we arrange the premises vertically, e.g.
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
but this is merely visual layout, equivalent to the horizontal layout below. Derivations using
such a rule should be written as if it was in the horizontal form.
(op +) Γ ⊢ e1:int Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
Example
To show {} ⊢ if false then 2 else 3 + 4:int we can give a type
derivation like this:
(if)
(bool)
{} ⊢ false:bool
(int)
{} ⊢ 2:int
{} ⊢ if false then 2 else 3 + 4:int
where∇ is
34
Example
To show {} ⊢ if false then 2 else 3 + 4:int we can give a type
derivation like this:
(if)
(bool)
{} ⊢ false:bool
(int)
{} ⊢ 2:int ∇
{} ⊢ if false then 2 else 3 + 4:int
where∇ is
(op +)
(int)
{} ⊢ 3:int
(int)
{} ⊢ 4:int
{} ⊢ 3 + 4:int
Defining the type judgement Γ ⊢ e:T (2 of 3)
(assign)
Γ(ℓ) = intref
Γ ⊢ e:int
Γ ⊢ ℓ := e:unit
(deref) Γ(ℓ) = intref
Γ ⊢!ℓ:int
Here the Γ(ℓ) = intref just means ℓ ∈ dom(Γ).
Defining the type judgement Γ ⊢ e:T (3 of 3)
(skip) Γ ⊢ skip:unit
(seq)
Γ ⊢ e1:unit
Γ ⊢ e2:T
Γ ⊢ e1; e2:T
(while)
Γ ⊢ e1:bool
Γ ⊢ e2:unit
Γ ⊢ while e1 do e2:unit
Note that the typing rules are syntax-directed – for each clause of the abstract syntax for
expressions there is exactly one rule with a conclusion of that form.
Properties
Theorem 2 (Progress) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) then either e
is a value or there exist e ′, s ′ such that 〈e, s〉 −→ 〈e ′, s ′〉.
Theorem 3 (Type Preservation) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s)
and 〈e, s〉 −→ 〈e ′, s ′〉 then Γ ⊢ e ′:T and dom(Γ) ⊆ dom(s ′).
From these two we have that well-typed programs don’t get stuck:
Theorem 4 (Safety) If Γ ⊢ e:T , dom(Γ) ⊆ dom(s), and
〈e, s〉 −→∗ 〈e ′, s ′〉 then either e ′ is a value or there exist e ′′, s ′′ such
that 〈e ′, s ′〉 −→ 〈e ′′, s ′′〉.
35
(we’ll discuss how to prove these results soon)
Semantic style: one could make an explicit definition of what configurations are runtime
errors. Here, instead, those configurations are just stuck.
For L1 we don’t need to type the range of the store, as by definition all stored things are
integers.
Type checking, typeability, and type inference
Type checking problem for a type system: given Γ, e,T , is Γ ⊢ e:T
derivable?
Typeability problem: given Γ and e , find T such that Γ ⊢ e:T is
derivable, or show there is none.
Second problem is usually harder than the first. Solving it usually results
in a type inference algorithm: computing a type T for a phrase e , given
type environment Γ (or failing, if there is none).
For this type system, though, both are easy.
More Properties
Theorem 5 (Decidability of typeability) Given Γ, e , one can decide
∃ T .Γ ⊢ e:T .
Theorem 6 (Decidability of type checking) Given Γ, e,T , one can
decide Γ ⊢ e:T .
Also:
Theorem 7 (Uniqueness of typing) If Γ ⊢ e:T and Γ ⊢ e:T ′ then
T = T ′.
The file l1.ml contains also an implementation of a type inference algorithm for L1 – take
a look.
Type inference - Implementation
First must pick representations for types and for Γ’s:
datatype type L1 =
int
| unit
| bool
datatype type loc =
intref
type typeEnv = (loc*type loc) list
Now define the type inference function
infertype : typeEnv -> expr -> type L1 option
In the semantics, type environments Γ are partial functions from locations to the singleton
set {intref}. Here, just as we did for stores, we represent them as a list of loc*type loc
pairs containing, for each ℓ in the domain of the type environment, exactly one element of
the form (l,intref).
36
The Type Inference Algorithm
fun infertype gamma (Integer n) = SOME int
| infertype gamma (Boolean b) = SOME bool
| infertype gamma (Op (e1,opr,e2))
= (case (infertype gamma e1, opr, infertype gamma e2) of
(SOME int, Plus, SOME int) => SOME int
| (SOME int, GTEQ, SOME int) => SOME bool
| => NONE)
| infertype gamma (If (e1,e2,e3))
= (case (infertype gamma e1, infertype gamma e2, infertype gamma e3) of
(SOME bool, SOME t2, SOME t3) =>
if t2=t3 then SOME t2 else NONE
| => NONE)
| infertype gamma (Deref l)
= (case lookup (gamma,l) of
SOME intref => SOME int
| NONE => NONE)
| infertype gamma (Assign (l,e))
= (case (lookup (gamma,l), infertype gamma e) of
(SOME intref,SOME int) => SOME unit
| => NONE)
| infertype gamma (Skip) = SOME unit
| infertype gamma (Seq (e1,e2))
= (case (infertype gamma e1, infertype gamma e2) of
(SOME unit, SOME t2) => SOME t2
| => NONE )
| infertype gamma (While (e1,e2))
= (case (infertype gamma e1, infertype gamma e2) of
(SOME bool, SOME unit) => SOME unit )
ahem.
The Type Inference Algorithm – If
...
| infertype gamma (If (e1,e2,e3))
= (case (infertype gamma e1,
infertype gamma e2,
infertype gamma e3) of
(SOME bool, SOME t2, SOME t3) =>
if t2=t3 then SOME t2 else NONE
| => NONE)
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
The Type Inference Algorithm – Deref
...
| infertype gamma (Deref l)
= (case lookup (gamma,l) of
SOME intref => SOME int
| NONE => NONE)
...
(deref) Γ(ℓ) = intref
Γ ⊢!ℓ:int
Again, the code depends on a uniqueness property (Theorem 7), without which we would
have to have infertype return a type L1 list of all the possible types.
Demo
37
Executing L1 in Moscow ML
L1 is essentially a fragment of Moscow ML – given a typable L1
expression e and an initial store s , e can be executed in Moscow ML by
wrapping it
let val skip = ()
and l1 = ref n1
and l2 = ref n2
.. .
and lk = ref nk
in
e
end;
where s is the store {l1 7→ n1, ..., lk 7→ nk} and all locations that occur
in e are contained in {l1, ..., lk}.
(watch out for ∼1 and -1)
Why Not Types?
• “I can’t write the code I want in this type system.”
(the Pascal complaint) usually false for a modern typed language
• “It’s too tiresome to get the types right throughout development.”
(the untyped-scripting-language complaint)
• “Type annotations are too verbose.”
type inference means you only have to write them where it’s useful
• “Type error messages are incomprehensible.”
hmm. Sadly, sometimes true.
• “I really can’t write the code I want.”
Garbage collection? Marshalling? Multi-stage computation?
Some languages build the type system into the syntax. Original FORTRAN, BASIC etc.
had typing built into variable names, with e.g. those beginning with I or J storing integers).
Sometimes one has typing built into the grammar, with e.g. separate grammatical classes
of expressions and commands. As the type systems become more expressive, however, they
quickly go beyond what can be captured in context-free grammars. They must then be
separated from lexing and parsing, both conceptually and in implementations.
38
2.3 L1: Collected Definition
Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Operations op ::= + |≥
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2
Operational Semantics
Note that for each construct there are some computation rules, doing ‘real work’, and some
context (or congruence) rules, allowing subcomputations and specifying their order.
Say stores s are finite partial functions from L to Z. Say values v are expressions from the
grammar v ::= b | n | skip.
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2;while e1 do e2) else skip, s〉
39
Typing
Types of expressions:
T ::= int | bool | unit
Types of locations:
Tloc ::= intref
Write T and Tloc for the sets of all terms of these grammars.
Let Γ range over TypeEnv, the finite partial functions from locations L to Tloc.
(int) Γ ⊢ n:int for n ∈ Z
(bool) Γ ⊢ b:bool for b ∈ {true, false}
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
(op ≥)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 ≥ e2:bool
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
(assign)
Γ(ℓ) = intref
Γ ⊢ e:int
Γ ⊢ ℓ := e:unit
(deref)
Γ(ℓ) = intref
Γ ⊢!ℓ:int
(skip) Γ ⊢ skip:unit
(seq)
Γ ⊢ e1:unit
Γ ⊢ e2:T
Γ ⊢ e1; e2:T
(while)
Γ ⊢ e1:bool
Γ ⊢ e2:unit
Γ ⊢ while e1 do e2:unit
40
2.4 Exercises
Exercise 1 ⋆Write a program to compute the factorial of the integer initially in location
l1. Take care to ensure that your program really is an expression in L1.
Exercise 2 ⋆Give full derivations of all the reduction steps of 〈(l0 := 7); (l1 := (!l0 +
2)), {l0 7→ 0, l1 7→ 0}〉.
Exercise 3 ⋆Give full derivations of the first four reduction steps of the 〈e, s〉 of the first
L1 example.
Exercise 4 ⋆Adapt the implementation code to correspond to the two rules (op1b) and
(op2b). Give some test cases that distinguish between the original and the new semantics.
Exercise 5 ⋆Adapt the implementation code to correspond to the two rules (assign1’) and
(seq1’). Give some test cases that distinguish between the original and the new semantics.
Exercise 6 ⋆⋆Fix the L1 implementation to match the semantics, taking care with the
representation of integers.
Exercise 7 ⋆⋆Fix the L1 semantics to match the implementation, taking care with the
representation of integers.
Exercise 8 ⋆Give a type derivation for (l0 := 7); (l1 := (!l0+2)) with Γ = l0:intref, l1:intref.
Exercise 9 ⋆Give a type derivation for the e on Page 17 with Γ = l1:intref, l2:intref, l3:intref
.
Exercise 10 ⋆Does Type Preservation hold for the variant language with rules (assign1’)
and (seq1’)? If not, give an example, and show how the type rules could be adjusted to make
it true.
Exercise 11 ⋆Adapt the type inference implementation to match your revised type system
from Exercise 10.
Exercise 12 ⋆Check whether mosml, the L1 implementation and the L1 semantics agree
on the order of evaluation for operators and sequencing.
Exercise 13 ⋆ (just for fun) Adapt the implementation to output derivation trees, in
ASCII, (or to show where proof search gets stuck) for −→ or ⊢.
41
3 Induction
Induction
We’ve stated several ‘theorems’, but how do we know they are true?
Intuition is often wrong – we need proof.
Use proof process also for strengthening our intuition about subtle
language features, and for debugging definitions – it helps you examine all
the various cases.
Most of our definitions are inductive – so to prove things about them, we
need the corresponding induction principles.
Three forms of induction
Prove facts about all natural numbers by mathematical induction.
Prove facts about all terms of a grammar (e.g. the L1 expressions) by
structural induction.
Prove facts about all elements of a relation defined by rules (e.g. the L1
transition relation, or the L1 typing relation) by rule induction.
We shall see that all three boil down to induction over certain trees.
Principle of Mathematical Induction
For any property Φ(x ) of natural numbers x ∈ N = {0, 1, 2, ...}, to
prove
∀ x ∈ N.Φ(x )
it’s enough to prove
Φ(0) and ∀ x ∈ N.Φ(x )⇒ Φ(x + 1).
i.e.
(
Φ(0) ∧ (∀ x ∈ N.Φ(x )⇒ Φ(x + 1))
)
⇒ ∀ x ∈ N.Φ(x )
(
Φ(0) ∧ (∀ x ∈ N.Φ(x )⇒ Φ(x + 1))
)
⇒ ∀ x ∈ N.Φ(x )
For example, to prove
Theorem 8 1 + 2 + ... + x = 1/2 ∗ x ∗ (x + 1)
use mathematical induction for
Φ(x ) = (1 + 2 + ... + x = 1/2 ∗ x ∗ (x + 1))
There’s a model proof in the notes, (annotated to say what’s going on), as an example of
good style. Writing a clear proof structure like this becomes essential
when things get more complex – you have to use the formalism to help
you get things right. Emulate it! (but without the annotations!)
(NB, the natural numbers include 0)
42
Theorem 8 1 + 2 + ... + x = 1/2 ∗ x ∗ (x + 1) .
Proof We prove ∀ x .Φ(x ), where
(state Φ explicitly)
Φ(x )
def
= (1 + 2 + ... + x = 1/2 ∗ x ∗ (x + 1))
by mathematical induction
(state the induction principle you’re using)
.
(Now show each conjunct of the premise of the induction principle)
Base case: (conjunct Φ(0) )
Φ(0) is
(instantiate Φ)
(1 + ... + 0 = 1/2 ∗ 0 ∗ (0 + 1)), which holds as both sides are equal to 0.
Inductive step: (conjunct ∀ x ∈ N.Φ(x) ⇒ Φ(x + 1) )
Consider an arbitrary k ∈ N (it’s a universal (∀), so consider an arbitrary one).
Suppose Φ(k) (to show the implication Φ(k) ⇒ Φ(k + 1), assume the premise and try to
show the conclusion).
We have to show Φ(k + 1), i.e. (state what we have to show explicitly)
(1 + 2 + ... + (k + 1)) = 1/2 ∗ (k + 1) ∗ ((k + 1) + 1)
Now, the left hand side is
(1 + 2 + ... + (k + 1)) = (1 + 2 + ... + k) + (k + 1) (rearranging)
= (1/2 ∗ k ∗ (k + 1)) + (k + 1) (using Φ(k) )
(say where you use the ‘induction hypothesis’ assumption Φ(k) made above)
and the right hand side is
1/2 ∗ (k + 1) ∗ ((k + 1) + 1) = 1/2 ∗ (k ∗ (k + 1) + (k + 1) ∗ 1 + 1 ∗ k + 1) (rearranging)
= 1/2 ∗ k ∗ (k + 1) + 1/2 ∗ ((k + 1) + k + 1) (rearranging)
= 1/2 ∗ k ∗ (k + 1) + (k + 1) (rearranging)
which is equal to the LHS.

Complete Induction
For reference we recall here the principle of complete induction, which is equivalent to the
principle of mathematical induction (anything you can prove with one, you could prove with
the other) but is sometimes more convenient:
For any property Φ(k) of natural numbers k ∈ N = {0, 1, 2, ...}, to prove
∀ k ∈ N.Φ(k)
it’s enough to prove
∀ k ∈ N.(∀ y ∈ N.y < k ⇒ Φ(y))⇒ Φ(k).
43
3.1 Abstract Syntax and Structural Induction
Abstract Syntax and Structural Induction
How to prove facts about all expressions, e.g. Determinacy for L1?
Theorem 1 (Determinacy) If 〈e, s〉 −→ 〈e1, s1〉 and
〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉 .
First, don’t forget the elided universal quantifiers.
Theorem 1 (Determinacy) For all e, s , e1, s1, e2, s2, if
〈e, s〉 −→ 〈e1, s1〉 and 〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉 .
Abstract Syntax
Then, have to pay attention to what an expression is.
Recall we said:
e ::= n | b | e op e | if e then e else e |
ℓ := e |!ℓ |
skip | e; e |
while e do e
defining a set of expressions.
Q: Is an expression, e.g. if !l ≥ 0 then skip else (skip; l := 0):
1. a list of characters [‘i’, ‘f’, ‘ ’, ‘!’, ‘l’, ..];
2. a list of tokens [ IF, DEREF, LOC "l", GTEQ, ..]; or
3. an abstract syntax tree?
if then else
≥
ssssss
skip ;
MMMMMMM
!l

0 skip l :=
?????
0
A: an abstract syntax tree. Hence: 2 + 2 6= 4
+
2

2
111
4
1 + 2 + 3 – ambiguous
(1 + 2) + 3 6= 1 + (2 + 3)
+
+

3
111
1

2
333
+
1

+
333
2

3
111
Parentheses are only used for disambiguation – they are not part of the
grammar. 1 + 2 = (1 + 2) = ((1 + 2)) = (((((1)))) + ((2)))
44
All those are (sometimes) useful ways of looking at expressions (for lexing and parsing you
start with (1) and (2)), but for semantics we don’t want to be distracted by concrete syntax
– it’s easiest to work with abstract syntax trees, which for this grammar are finite trees,
with ordered branches, labelled as follows:
• leaves (nullary nodes) labelled by B ∪ Z ∪ ({!} ∗ L) ∪ {skip} = {true, false, skip} ∪
{...,−1, 0, 1, ...} ∪ {!l , !l1, !l2, ...}.
• unary nodes labelled by {l :=, l1 :=, l2 :=, ...}
• binary nodes labelled by {+,≥, :=, ; ,while do }
• ternary nodes labelled by {if then else }
Abstract grammar suggests a concrete syntax – we write expressions as strings just for
convenience, using parentheses to disambiguate where required and infix/mixfix notation,
but really mean trees. Arguments about exactly what concrete syntax a language should
have – beloved amongst computer scientists everywhere – do not belong in a semantics
course.
Just as for natural numbers to prove ∀ x ∈ N.Φ(x ) it was enough to prove Φ(0) and all
the implications Φ(x ) ⇒ Φ(x + 1) (for arbitrary x ∈ N), here to prove ∀ e ∈ L1.Φ(e)
it is enough to prove Φ(c) for each nullary tree constructor c and all the implications
(Φ(e1) ∧ ... ∧ Φ(ek)) ⇒ Φ(c(e1, .., ek)) for each tree constructor of arity k ≥ 1 (and for
arbitrary e1 ∈ L1, .., ek ∈ L1).
Principle of Structural Induction (for abstract syntax)
For any property Φ(e) of expressions e , to prove
∀ e ∈ L1.Φ(e)
it’s enough to prove for each tree constructor c (taking k ≥ 0 arguments)
that if Φ holds for the subtrees e1, .., ek then Φ holds for the tree
c(e1, .., ek). i.e.
(
∀ c.∀ e1, .., ek.(Φ(e1) ∧ ... ∧ Φ(ek))⇒ Φ(c(e1, .., ek))
)
⇒ ∀ e.Φ(e)
where the tree constructors (or node labels) c are n , true, false, !l , skip,
l :=, while do , if then else , etc.
In particular, for L1: to show ∀ e ∈ L1.Φ(e) it’s enough to show:
nullary: Φ(skip)
∀ b ∈ {true, false}.Φ(b)
∀ n ∈ Z.Φ(n)
∀ ℓ ∈ L.Φ(!ℓ)
unary: ∀ ℓ ∈ L.∀ e.Φ(e)⇒ Φ(ℓ := e)
binary: ∀ op .∀ e1, e2.(Φ(e1) ∧ Φ(e2))⇒ Φ(e1 op e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2))⇒ Φ(e1; e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2))⇒ Φ(while e1 do e2)
ternary: ∀ e1, e2, e3.(Φ(e1) ∧ Φ(e2) ∧ Φ(e3))⇒ Φ(if e1 then e2 else e3)
(See how this comes directly from the grammar)
If you think of the natural numbers as the abstract syntax trees of the grammar n ::= zero |
succ (n) then Structural Induction for that grammar is exactly the same as the Principal
of Mathematical Induction.
45
Proving Determinacy (Outline)
Theorem 1 (Determinacy)If 〈e, s〉 −→ 〈e1, s1〉 and
〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉 .
Take
Φ(e)
def
= ∀ s , e ′, s ′, e ′′, s ′′.
(〈e, s〉 −→ 〈e ′, s ′〉 ∧ 〈e, s〉 −→ 〈e ′′, s ′′〉)
⇒ 〈e ′, s ′〉 = 〈e ′′, s ′′〉
and show ∀ e ∈ L1.Φ(e) by structural induction.
To do that we need to verify all the premises of the principle of structural induction – the
formulae in the second box below – for this Φ.
Φ(e)
def
= ∀ s, e ′, s ′, e ′′, s ′′.
(〈e, s〉 −→ 〈e ′, s ′〉 ∧ 〈e, s〉 −→ 〈e ′′, s ′′〉)
⇒ 〈e ′, s ′〉 = 〈e ′′, s ′′〉
nullary: Φ(skip)
∀ b ∈ {true, false}.Φ(b)
∀ n ∈ Z.Φ(n)
∀ ℓ ∈ L.Φ(!ℓ)
unary: ∀ ℓ ∈ L.∀ e.Φ(e) ⇒ Φ(ℓ := e)
binary: ∀ op .∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(e1 op e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(e1; e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(while e1 do e2)
ternary: ∀ e1, e2, e3.(Φ(e1) ∧ Φ(e2) ∧ Φ(e3)) ⇒ Φ(if e1 then e2 else e3)
We will come back later to look at some of these details.
3.2 Inductive Definitions and Rule Induction
Inductive Definitions and Rule Induction
How to prove facts about all elements of the L1 typing relation or the L1
reduction relation, e.g. Progress or Type Preservation?
Theorem 2 (Progress) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) then either e
is a value or there exist e ′, s ′ such that 〈e, s〉 −→ 〈e ′, s ′〉.
Theorem 3 (Type Preservation)If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) and
〈e, s〉 −→ 〈e ′, s ′〉 then Γ ⊢ e ′:T and dom(Γ) ⊆ dom(s ′).
Have to pay attention to what the elements of these relations really are...
46
Inductive Definitions
We defined the transition relation 〈e, s〉 −→ 〈e ′, s ′〉 and the typing
relation Γ ⊢ e:T by giving some rules, eg
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op +) Γ ⊢ e1:int Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
What did we actually mean?
These relations are just normal set-theoretic relations, written in infix or
mixfix notation.
For the transition relation:
• Start with A = L1 ∗ store ∗ L1 ∗ store.
• Write−→ ⊆ A infix, e.g. 〈e, s〉 −→ 〈e ′, s ′〉 instead of
(e, s , e ′, s ′) ∈−→.
For the typing relation:
• Start with A = TypeEnv ∗ L1 ∗ types.
• Write ⊢ ⊆ A mixfix, e.g. Γ ⊢ e:T instead of (Γ, e,T ) ∈ ⊢.
For each rule we can construct the set of all concrete rule instances,
taking all values of the metavariables that satisfy the side condition. For
example, for (op + ) and (op1) we take all values of n1, n2, s , n
(satisfying n = n1 + n2) and of e1, e2, s , e
′
1, s
′.
(op+ )
〈2 + 2, {}〉 −→ 〈4, {}〉 ,
(op + )
〈2 + 3, {}〉 −→ 〈5, {}〉 , ...
(op1)
〈2 + 2, {}〉 −→ 〈4, {}〉
〈(2 + 2) + 3, {}〉 −→ 〈4 + 3, {}〉 ,
(op1)
〈2 + 2, {}〉 −→ 〈false, {}〉
〈(2 + 2) + 3, {}〉 −→ 〈false + 3, {}〉
Note the last has a premise that is not itself derivable, but nonetheless this is a legitimate
instance of (op1).
Now a derivation of a transition 〈e, s〉 −→ 〈e ′, s ′〉 or typing judgment
Γ ⊢ e:T is a finite tree such that each step is a concrete rule instance.
〈2 + 2, {}〉 −→ 〈4, {}〉 (op+)
〈(2 + 2) + 3, {}〉 −→ 〈4 + 3, {}〉 (op1)
〈(2 + 2) + 3 ≥ 5, {}〉 −→ 〈4 + 3 ≥ 5, {}〉 (op1)
Γ ⊢!l :int (deref) Γ ⊢ 2:int (int)
Γ ⊢ (!l + 2):int (op +) Γ ⊢ 3:int (int)
Γ ⊢ (!l + 2) + 3:int (op +)
and 〈e, s〉 −→ 〈e ′, s ′〉 is an element of the reduction relation
(resp. Γ ⊢ e:T is an element of the transition relation) iff there is a
derivation with that as the root node.
47
Now, to prove something about an inductively-defined set...
Principle of Rule Induction
For any property Φ(a) of elements a of A, and any set of rules which
define a subset SR of A, to prove
∀ a ∈ SR.Φ(a)
it’s enough to prove that {a | Φ(a)} is closed under the rules, ie for each
concrete rule instance
h1 .. hk
c
if Φ(h1) ∧ ... ∧ Φ(hk) then Φ(c).
For some proofs a slightly different principle is useful – this variant allows you to assume
each of the hi are themselves members of SR.
Principle of rule induction (a slight variant)
For any property Φ(a) of elements a of A, and any set of rules which
inductively define the set SR, to prove
∀ a ∈ SR.Φ(a)
it’s enough to prove that
for each concrete rule instance
h1 .. hk
c
if Φ(h1) ∧ ... ∧ Φ(hk) ∧ h1 ∈ SR ∧ .. ∧ hk ∈ SR then Φ(c).
Proving Progress (Outline)
Theorem 2 (Progress) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) then either e
is a value or there exist e ′, s ′ such that 〈e, s〉 −→ 〈e ′, s ′〉.
Proof Take
Φ(Γ, e,T )
def
= ∀ s . dom(Γ) ⊆ dom(s)⇒
value(e) ∨ (∃ e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉)
We show that for all Γ, e,T , if Γ ⊢ e:T then Φ(Γ, e,T ), by rule
induction on the definition of ⊢.
48
Principle of Rule Induction (variant form): to prove Φ(a) for all a in the
set SR, it’s enough to prove that for each concrete rule instance
h1 .. hk
c
if Φ(h1) ∧ ... ∧ Φ(hk) ∧ h1 ∈ SR ∧ .. ∧ hk ∈ SR then Φ(c).
Instantiating to the L1 typing rules, have to show:
(int) ∀ Γ,n.Φ(Γ,n, int)
(deref) ∀ Γ, ℓ.Γ(ℓ) = intref ⇒ Φ(Γ, !ℓ, int)
(op +) ∀ Γ, e1, e2.(Φ(Γ, e1, int) ∧ Φ(Γ, e2, int) ∧ Γ ⊢ e1:int ∧ Γ ⊢ e2:int)
⇒ Φ(Γ, e1 + e2, int)
(seq) ∀ Γ, e1, e2,T .(Φ(Γ, e1, unit) ∧ Φ(Γ, e2,T ) ∧ Γ ⊢ e1:unit ∧ Γ ⊢ e2:T )
⇒ Φ(Γ, e1; e2,T )
etc.
Having proved those 10 things, consider an example
Γ ⊢ (!l + 2) + 3:int. To see why Φ(Γ, (!l + 2) + 3, int) holds:
Γ ⊢!l :int (deref) Γ ⊢ 2:int (int)
Γ ⊢ (!l + 2):int (op +) Γ ⊢ 3:int (int)
Γ ⊢ (!l + 2) + 3:int (op +)
Which Induction Principle to Use?
Which of these induction principles to use is a matter of convenience –
you want to use an induction principle that matches the definitions you’re
working with.
For completeness, observe the following:
Mathematical induction over N is equivalent to complete induction over N.
Mathematical induction over N is essentially the same as structural induction over n ::= zero |
succ (n).
Instead of using structural induction (for an arbitrary grammar), you could use complete
induction on the size of terms.
Instead of using structural induction, you could use rule induction: supposing some fixed
set of tree node labels (e.g. all the character strings), take A to be the set of all trees with
those labels, and consider each clause of your grammar (e.g.e ::= ... | e + e) to be a rule
e e
e + e
3.3 Example Proofs
Example Proofs
In the notes there are detailed example proofs for Determinacy (structural
induction), Progress (rule induction on type derivations), and Type
Preservation (rule induction on reduction derivations).
You should read them off-line, and do the exercises.
49
When is a proof a proof?
What’s a proof?
Formal: a derivation in formal logic (e.g. a big natural deduction proof
tree). Often far too verbose to deal with by hand (but can
machine-check such things).
Informal but rigorous: an argument to persuade the reader that, if
pushed, you could write a fully formal proof (the usual mathematical
notion, e.g. those we just did). Have to learn by practice to see when
they are rigorous.
Bogus: neither of the above.
Remember – the point is to use the mathematics to help you think about things that are too
complex to keep in your head all at once: to keep track of all the cases etc. To do that, and
to communicate with other people, it’s important to write down the reasoning and proof
structure as clearly as possible. After you’ve done a proof you should give it to someone
(your supervision partner first, perhaps) to see if they (a) can understand what you’ve said,
and (b) if they believe it.
Sometimes it seems hard or pointless to prove things because they seem
‘too obvious’....
1. proof lets you see (and explain) why they are obvious
2. sometimes the obvious facts are false...
3. sometimes the obvious facts are not obvious at all
4. sometimes a proof contains or suggests an algorithm that you need –
eg, proofs that type inference is decidable (for fancier type systems)
50
Theorem 1 (Determinacy)If 〈e, s〉 −→ 〈e1, s1〉 and 〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 =
〈e2, s2〉 .
Proof Take
Φ(e)
def
= ∀ s, e ′, s ′, e ′′, s ′′.(〈e, s〉 −→ 〈e ′, s ′〉 ∧ 〈e, s〉 −→ 〈e ′′, s ′′〉)⇒ 〈e ′, s ′〉 = 〈e ′′, s ′′〉
We show ∀ e ∈ L1.Φ(e) by structural induction.
Cases skip, b,n. For e of these forms there are no rules with a conclusion of the form
〈e, ...〉 −→ 〈.., ..〉 so the left hand side of the implication cannot hold, so the
implication is true.
Case !ℓ. Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈!ℓ, s〉 −→ 〈e ′, s ′〉∧〈!ℓ, s〉 −→ 〈e ′′, s ′′〉.
The only rule which could be applicable is (deref), in which case, for those tran-
sitions to be instances of the rule we must have
ℓ ∈ dom(s) ℓ ∈ dom(s)
e ′ = s(ℓ) e ′′ = s(ℓ)
s ′ = s s ′′ = s
so e ′ = e ′′ and s ′ = s ′′.
Case ℓ := e. Suppose Φ(e) (then we have to show Φ(ℓ := e)).
Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈ℓ := e, s〉 −→ 〈e ′, s ′〉 ∧ 〈ℓ := e, s〉 −→
〈e ′′, s ′′〉.
It’s handy to have this lemma:
Lemma 1 For all e ∈ L1, if e is a value then ∀ s.¬ ∃e ′, s ′.〈e, s〉 −→
〈e ′, s ′〉.
Proof By defn e is a value if it is of one of the forms n, b, skip. By
examination of the rules on slides ..., there is no rule with conclusion
of the form 〈e, s〉 −→ 〈e ′, s ′〉 for e one of n, b, skip. 
The only rules which could be applicable, for each of the two transitions, are
(assign1) and (assign2).
case 〈ℓ := e, s〉 −→ 〈e ′, s ′〉 is an instance of (assign1). Then for some n we have
e = n and ℓ ∈ dom(s) and e ′ = skip and s ′ = s + {ℓ 7→ n}.
case 〈ℓ := n, s〉 −→ 〈e ′′, s ′′〉 is an instance of (assign1) (note we are using
the fact that e = n here). Then e ′′ = skip and s ′′ = s + {ℓ 7→ n} so
〈e ′, s ′〉 = 〈e ′′, s ′′〉 as required.
case 〈ℓ := e, s〉 −→ 〈e ′′, s ′′〉 is an instance of (assign2). Then 〈n, s〉 −→
〈e ′′, s ′′〉, which contradicts the lemma, so this case cannot arise.
case 〈ℓ := e, s〉 −→ 〈e ′, s ′〉 is an instance of (assign2). Then for some e ′1 we have
〈e, s〉 −→ 〈e ′1, s ′〉 (*) and e ′ = (ℓ := e ′1).
case 〈ℓ := e, s〉 −→ 〈e ′′, s ′′〉 is an instance of (assign1). Then for some n we
have e = n, which contradicts the lemma, so this case cannot arise.
case 〈ℓ := e, s〉 −→ 〈e ′′, s ′′〉 is an instance of (assign2). Then for some
e ′′1 we have 〈e, s〉 −→ 〈e ′′1 , s ′′〉(**) and e ′′ = (ℓ := e ′′1 ). Now, by the
induction hypothesis Φ(e), (*) and (**) we have 〈e ′1, s ′〉 = 〈e ′′1 , s ′′〉, so
〈e ′, s ′〉 = 〈ℓ := e ′1, s ′〉 = 〈ℓ := e ′′1 , s ′′〉 = 〈e ′′, s ′′〉 as required.
Case e1 op e2. Suppose Φ(e1) and Φ(e2).
Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈e1 op e2, s〉 −→ 〈e ′, s ′〉∧〈e1 op e2, s〉 −→
〈e ′′, s ′′〉.
51
By examining the expressions in the left-hand-sides of the conclusions of the rules,
and using the lemma above, the only possibilities are those below (you should
check why this is so for yourself).
case op = + and 〈e1 + e2, s〉 −→ 〈e ′, s ′〉 is an instance of (op+) and 〈e1 +
e2, s〉 −→ 〈e ′′, s ′′〉 is an instance of (op+ ).
Then for some n1,n2 we have e1 = n1, e2 = n2, e
′ = n3 = e
′′ for n3 = n1+n2,
and s ′ = s = s ′′.
case op =≥ and 〈e1 ≥ e2, s〉 −→ 〈e ′, s ′〉 is an instance of (op≥) and 〈e1 ≥
e2, s〉 −→ 〈e ′′, s ′′〉 is an instance of (op≥).
Then for some n1,n2 we have e1 = n1, e2 = n2, e
′ = b = e ′′ for b = (n1 ≥ n2),
and s ′ = s = s ′′.
case 〈e1 op e2, s〉 −→ 〈e ′, s ′〉 is an instance of (op1) and 〈e1 op e2, s〉 −→
〈e ′′, s ′′〉 is an instance of (op1).
Then for some e ′1 and e
′′
1 we have 〈e1, s〉 −→ 〈e ′1, s ′〉 (*), 〈e1, s〉 −→ 〈e ′′1 , s ′′〉
(**), e ′ = e ′1 op e2, and e
′′ = e ′′1 op e2. Now, by the induction hypothesis
Φ(e1), (*) and (**) we have 〈e ′1, s ′〉 = 〈e ′′1 , s ′′〉, so 〈e ′, s ′〉 = 〈e ′1 op e2, s ′〉 =
〈e ′′1 op e2, s ′′〉 = 〈e ′′, s ′′〉 as required.
case 〈e1 op e2, s〉 −→ 〈e ′, s ′〉 is an instance of (op2) and 〈e1 op e2, s〉 −→
〈e ′′, s ′′〉 is an instance of (op2).
Similar, save that we use the induction hypothesis Φ(e2).
Case e1; e2. Suppose Φ(e1) and Φ(e2).
Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈e1; e2, s〉 −→ 〈e ′, s ′〉 ∧ 〈e1; e2, s〉 −→
〈e ′′, s ′′〉.
By examining the expressions in the left-hand-sides of the conclusions of the rules,
and using the lemma above, the only possibilities are those below.
case e1 = skip and both transitions are instances of (seq1).
Then 〈e ′, s ′〉 = 〈e2, s〉 = 〈e ′′, s ′′〉.
case e1 is not a value and both transitions are instances of (seq2). Then for some
e ′1 and e
′′
1 we have 〈e1, s〉 −→ 〈e ′1, s ′〉 (*), 〈e1, s〉 −→ 〈e ′′1 , s ′′〉 (**), e ′ = e ′1; e2,
and e ′′ = e ′′1 ; e2
Then by the induction hypothesis Φ(e1) we have 〈e ′1, s ′〉 = 〈e ′′1 , s ′′〉, so
〈e ′, s ′〉 = 〈e ′1; e2, s ′〉 = 〈e ′′1 ; e2, s ′′〉 = 〈e ′′, s ′′〉 as required.
Case while e1 do e2. Suppose Φ(e1) and Φ(e2).
Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈while e1 do e2, s〉 −→ 〈e ′, s ′〉 ∧
〈while e1 do e2, s〉 −→ 〈e ′′, s ′′〉.
By examining the expressions in the left-hand-sides of the conclusions of the rules
both must be instances of (while), so 〈e ′, s ′〉 = 〈if e1 then (e2;while e1 do e2) else skip, s〉 =
〈e ′′, s ′′〉.
Case if e1 then e2 else e3. Suppose Φ(e1), Φ(e2) and Φ(e3).
Take arbitrary s, e ′, s ′, e ′′, s ′′ such that 〈if e1 then e2 else e3, s〉 −→ 〈e ′, s ′〉 ∧
〈if e1 then e2 else e3, s〉 −→ 〈e ′′, s ′′〉.
By examining the expressions in the left-hand-sides of the conclusions of the rules,
and using the lemma above, the only possibilities are those below.
case e1 = true and both transitions are instances of (if1).
case e1 = false and both transitions are instances of (if2).
52
case e1 is not a value and both transitions are instances of (if3).
The first two cases are immediate; the last uses Φ(e1).

(check we’ve done all the cases!)
(note that the level of written detail can vary, as here – if you and the reader agree – but you
must do all the steps in your head. If in any doubt, write it down, as an aid to thought...!)
53
Theorem 2 (Progress) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) then either e is a value or there
exist e ′, s ′ such that 〈e, s〉 −→ 〈e ′, s ′〉.
Proof Take
Φ(Γ, e,T )
def
= ∀ s.dom(Γ) ⊆ dom(s)⇒ value(e) ∨ (∃ e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉)
We show that for all Γ, e,T , if Γ ⊢ e:T then Φ(Γ, e,T ), by rule induction on the
definition of ⊢.
Case (int). Recall the rule scheme
(int) Γ ⊢ n:int for n ∈ Z
It has no premises, so we have to show that for all instances Γ, e,T of the con-
clusion we have Φ(Γ, e,T ).
For any such instance, there must be an n ∈ Z for which e = n.
Now Φ is of the form ∀ s.dom(Γ) ⊆ dom(s)⇒ ..., so consider an arbitrary s and
assume dom(Γ) ⊆ dom(s).
We have to show value(e) ∨ (∃ e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉). But the first disjunct is
true as integers are values (according to the definition).
Case (bool) similar.
Case (op+ ). Recall the rule
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
We have to show that for all Γ, e1, e2, if Φ(Γ, e1, int) and Φ(Γ, e2, int) then Φ(Γ, e1+
e2, int).
Suppose Φ(Γ, e1, int) (*), Φ(Γ, e2, int) (**), Γ ⊢ e1:int (***), and Γ ⊢ e2:int (****)
(note that we’re using the variant form of rule induction here).
Consider an arbitrary s. Assume dom(Γ) ⊆ dom(s).
We have to show value(e1 + e2) ∨ (∃ e ′, s ′.〈e1 + e2, s〉 −→ 〈e ′, s ′〉).
Now the first disjunct is false (e1 + e2 is not a value), so we have to show the
second, i.e.∃〈e ′, s ′〉.〈e1 + e2, s〉 −→ 〈e ′, s ′〉.
By (*) one of the following holds.
case ∃ e ′1, s ′.〈e1, s〉 −→ 〈e ′1, s ′〉.
Then by (op1) we have 〈e1 + e2, s〉 −→ 〈e ′1 + e2, s ′〉, so we are done.
case e1 is a value. By (**) one of the following holds.
case ∃ e ′2, s ′.〈e2, s〉 −→ 〈e ′2, s ′〉.
Then by (op2) 〈e1 + e2, s〉 −→ 〈e1 + e ′2, s ′〉, so we are done.
case e2 is a value.
(Now want to use (op+ ), but need to know that e1 and e2 are really
integers. )
Lemma 2 for all Γ, e,T, if Γ ⊢ e:T, e is a value and T = int then for
some n ∈ Z we have e = n.
54
Proof By rule induction. Take Φ′(Γ, e,T ) = ((value(e) ∧ T = int)⇒
∃ n ∈ Z.e = n).
Case (int). ok
Case (bool),(skip). In instances of these rules the conclusion is a
value but the type is not int, so ok.
Case otherwise. In instances of all other rules the conclusion is
not a value, so ok.
(a rather trivial use of rule induction – we never needed to use the
induction hypothesis, just to do case analysis of the last rule that
might have been used in a derivation of Γ ⊢ e:T ). 
Using the Lemma, (***) and (****) there exist n1 ∈ Z and n2 ∈ Z
such that e1 = n1 and e2 = n2. Then by (op+) 〈e1 + e2, s〉 −→ 〈n, s〉
where n = n1 + n2, so we are done.
Case (op ≥ ). Similar to (op + ).
Case (if). Recall the rule
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
Suppose Φ(Γ, e1, bool) (*1), Φ(Γ, e2,T ) (*2), Φ(Γ, e3,T ) (*3), Γ ⊢ e1:bool (*4),
Γ ⊢ e2:T (*5) and Γ ⊢ e3:T (*6).
Consider an arbitrary s. Assume dom(Γ) ⊆ dom(s). Write e for if e1 then e2 else e3.
This e is not a value, so we have to show 〈e, s〉 has a transition.
case ∃ e ′1, s ′.〈e1, s〉 −→ 〈e ′1, s ′〉.
Then by (if3) 〈e, s〉 −→ 〈if e ′1 then e2 else e3, s〉, so we are done.
case e1 is a value.
(Now want to use (if1) or (if2), but need to know that e1 ∈ {true, false}.
Realise should have proved a stronger Lemma above).
Lemma 3 For all Γ, e,T. if Γ ⊢ e:T and e is a value, then T = int ⇒
∃ n ∈ Z.e = n, T = bool ⇒ ∃ b ∈ {true, false}.e = b, and T = unit ⇒
e = skip.
Proof By rule induction – details omitted. 
Using the Lemma and (*4) we have ∃ b ∈ {true, false}.e1 = b.
case b = true. Use (if1).
case b = false. Use (if2).
Case (deref). Recall the rule
(deref)
Γ(ℓ) = intref
Γ ⊢!ℓ:int
(This is a leaf – it has no Γ ⊢ e:T premises - so no Φs to assume).
Consider an arbitrary s with dom(Γ) ⊆ dom(s).
By the condition Γ(ℓ) = intref we have ℓ ∈ dom(Γ), so ℓ ∈ dom(s), so there is
some n with s(ℓ) = n, so there is an instance of (deref) 〈!ℓ, s〉 −→ 〈n, s〉.
55
Cases (assign), (skip), (seq), (while). Left as an exercise.

56
Theorem 3 (Type Preservation)If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) and 〈e, s〉 −→ 〈e ′, s ′〉
then Γ ⊢ e ′:T and dom(Γ) ⊆ dom(s ′).
Proof First show the second part, using the following lemma.
Lemma 4 If 〈e, s〉 −→ 〈e ′, s ′〉 then dom(s ′) = dom(s).
Proof Rule induction on derivations of 〈e, s〉 −→ 〈e ′, s ′〉. Take Φ(e, s, e ′, s ′) =
(dom(s) = dom(s ′)).
All rules are immediate uses of the induction hypothesis except (assign1),
for which we note that if ℓ ∈ dom(s) then dom(s + (ℓ 7→ n)) = dom(s).

Now prove the first part, ie If Γ ⊢ e:T and dom(Γ) ⊇ dom(s) and 〈e, s〉 −→ 〈e ′, s ′〉
then Γ ⊢ e ′:T .
Prove by rule induction on derivations of 〈e, s〉 −→ 〈e ′, s ′〉.
Take Φ(e, s, e ′, s ′) = ∀ Γ,T .(Γ ⊢ e:T ∧ dom(Γ) ⊆ dom(s))⇒ Γ ⊢ e ′:T .
Case (op+). Recall
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
Take arbitrary Γ,T . Suppose Γ ⊢ n1 +n2:T (*) and dom(Γ) ⊆ dom(s). The last
rule in the derivation of (*) must have been (op+ ), so must have T = int. Then
can use (int) to derive Γ ⊢ n:T .
Case (op ≥). Similar.
Case (op1). Recall
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
Suppose Φ(e1, s, e
′
1, s
′) (*) and 〈e1, s〉 −→ 〈e ′1, s ′〉. Have to show Φ(e1 op e2, s, e ′1 op e2, s ′).
Take arbitrary Γ,T . Suppose Γ ⊢ e1 op e2:T and dom(Γ) ⊆ dom(Γ) (**).
case op = +. The last rule in the derivation of Γ ⊢ e1 + e2:T must have been
(op+), so must have T = int, Γ ⊢ e1:int (***) and Γ ⊢ e2:int (****). By the
induction hypothesis (*), (**), and (***) we have Γ ⊢ e ′1:int. By the (op+)
rule Γ ⊢ e ′1 + e2:T .
case op =≥. Similar.
Case s (op2) (deref), (assign1), (assign2), (seq1), (seq2), (if1), (if2), (if3), (while).
Left as exercises.

Theorem 4 (Safety) If Γ ⊢ e:T, dom(Γ) ⊆ dom(s), and 〈e, s〉 −→∗ 〈e ′, s ′〉 then either e ′
is a value or there exist e ′′, s ′′ such that 〈e ′, s ′〉 −→ 〈e ′′, s ′′〉.
Proof Hint: induction along −→∗ using the previous results. 
Theorem 7 (Uniqueness of typing) If Γ ⊢ e:T and Γ ⊢ e:T ′ then T = T ′. The proof
is left as Exercise 19.
Theorem 5 (Decidability of typeability) Given Γ, e, one can decide ∃ T .Γ ⊢ e:T.
Theorem 6 (Decidability of type checking) Given Γ, e,T, one can decide Γ ⊢ e:T.
57
Proof The implementation gives a type inference algorithm, which, if correct, and to-
gether with Uniqueness, implies both of these results. 
Proving Progress
Theorem 2 (Progress) If Γ ⊢ e:T and dom(Γ) ⊆ dom(s) then either e
is a value or there exist e ′, s ′ such that 〈e, s〉 −→ 〈e ′, s ′〉.
Proof Take
Φ(Γ, e,T )
def
= ∀ s . dom(Γ) ⊆ dom(s)⇒
value(e) ∨ (∃ e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉)
We show that for all Γ, e,T , if Γ ⊢ e:T then Φ(Γ, e,T ), by rule
induction on the definition of ⊢.
Principle of Rule Induction (variant form): to prove Φ(a) for all a in the set
SR defined by the rules, it’s enough to prove that for each rule instance
h1 .. hk
c
if Φ(h1) ∧ ... ∧ Φ(hk) ∧ h1 ∈ SR ∧ .. ∧ hk ∈ SR then Φ(c).
Instantiating to the L1 typing rules, have to show:
(int) ∀ Γ,n.Φ(Γ,n, int)
(deref) ∀ Γ, ℓ.Γ(ℓ) = intref ⇒ Φ(Γ, !ℓ, int)
(op +) ∀ Γ, e1, e2.(Φ(Γ, e1, int) ∧ Φ(Γ, e2, int) ∧ Γ ⊢ e1:int ∧ Γ ⊢ e2:int)
⇒ Φ(Γ, e1 + e2, int)
(seq) ∀ Γ, e1, e2,T .(Φ(Γ, e1, unit) ∧ Φ(Γ, e2,T ) ∧ Γ ⊢ e1:unit ∧ Γ ⊢ e2:T )
⇒ Φ(Γ, e1; e2,T )
etc.
Φ(Γ, e,T )
def
= ∀ s . dom(Γ) ⊆ dom(s)⇒
value(e) ∨ (∃ e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉)
Case (op+ ). Recall the rule
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
Suppose Φ(Γ, e1, int), Φ(Γ, e2, int), Γ ⊢ e1:int, and Γ ⊢ e2:int.
We have to show Φ(Γ, e1 + e2, int).
Consider an arbitrary s . Assume dom(Γ) ⊆ dom(s).
Now e1 + e2 is not a value, so we have to show
∃〈e ′, s ′〉.〈e1 + e2, s〉 −→ 〈e ′, s ′〉.
58
Using Φ(Γ, e1, int) and Φ(Γ, e2, int) we have:
case e1 reduces. Then e1 + e2 does, using (op1).
case e1 is a value but e2 reduces. Then e1 + e2 does, using (op2).
case Both e1 and e2 are values. Want to use:
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
Lemma 5 for all Γ, e,T , if Γ ⊢ e:T , e is a value and T = int then
for some n ∈ Z we have e = n .
We assumed (the variant rule induction principle) that Γ ⊢ e1:int and
Γ ⊢ e2:int, so using this Lemma have e1 = n1 and e2 = n2.
Then e1 + e2 reduces, using rule (op+).
All the other cases are in the notes.
Having proved those 10 things, consider an example
Γ ⊢ (!l + 2) + 3:int. To see why Φ(Γ, (!l + 2) + 3, int) holds:
Γ ⊢!l :int (deref) Γ ⊢ 2:int (int)
Γ ⊢ (!l + 2):int (op +) Γ ⊢ 3:int (int)
Γ ⊢ (!l + 2) + 3:int (op +)
Proving Determinacy
Theorem 1 (Determinacy)If 〈e, s〉 −→ 〈e1, s1〉 and
〈e, s〉 −→ 〈e2, s2〉 then 〈e1, s1〉 = 〈e2, s2〉 .
Take
Φ(e)
def
= ∀ s , e ′, s ′, e ′′, s ′′.
(〈e, s〉 −→ 〈e ′, s ′〉 ∧ 〈e, s〉 −→ 〈e ′′, s ′′〉)
⇒ 〈e ′, s ′〉 = 〈e ′′, s ′′〉
We show ∀ e ∈ L1.Φ(e) by structural induction.
Principle of Structural Induction: to prove Φ(e) for all expressions e of L1,
it’s enough to prove for each tree constructor c that if Φ holds for the
subtrees e1, .., ek then Φ holds for the tree c(e1, .., ek).
Instantiating to the L1 grammar, have to show:
nullary: Φ(skip)
∀ b ∈ {true, false}.Φ(b)
∀ n ∈ Z.Φ(n)
∀ ℓ ∈ L.Φ(!ℓ)
unary: ∀ ℓ ∈ L.∀ e.Φ(e) ⇒ Φ(ℓ := e)
binary: ∀ op .∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(e1 op e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(e1; e2)
∀ e1, e2.(Φ(e1) ∧ Φ(e2)) ⇒ Φ(while e1 do e2)
ternary: ∀ e1, e2, e3.(Φ(e1) ∧ Φ(e2) ∧ Φ(e3)) ⇒ Φ(if e1 then e2 else e3)
59
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e
′
1, s
′〉
〈e1 op e2, s〉 −→ 〈e
′
1 op e2, s
′〉
(op2)
〈e2, s〉 −→ 〈e
′
2, s
′〉
〈v op e2, s〉 −→ 〈v op e
′
2, s
′〉
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e′, s′〉
〈ℓ := e, s〉 −→ 〈ℓ := e′, s′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e
′
1, s
′〉
〈e1; e2, s〉 −→ 〈e
′
1; e2, s
′〉
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e
′
1, s
′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e
′
1 then e2 else e3, s
′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2; while e1 do e2) else skip, s〉
Φ(e)
def
= ∀ s , e ′, s ′, e ′′, s ′′.
(〈e, s〉 −→ 〈e ′, s ′〉 ∧ 〈e, s〉 −→ 〈e ′′, s ′′〉)
⇒ 〈e ′, s ′〉 = 〈e ′′, s ′′〉
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
Lemma: Values don’t reduce
It’s handy to have this lemma:
Lemma 6 For all e ∈ L1, if e is a value then
∀ s .¬ ∃e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉.
Proof By defn e is a value if it is of one of the forms n, b, skip. By
examination of the rules on slides ..., there is no rule with conclusion of
the form 〈e, s〉 −→ 〈e ′, s ′〉 for e one of n, b, skip. 
All the other cases are in the notes.
Having proved those 9 things, consider an example (!l + 2) + 3. To see
why Φ((!l + 2) + 3) holds:
+
+

3
111
!l

2
333
60
Summarising Proof Techniques
Determinacy structural induction for e
Progress rule induction for Γ ⊢ e:T
Type Preservation rule induction for 〈e, s〉 −→ 〈e ′, s ′〉
Safety mathematical induction on−→k
Uniqueness of typing ...
Decidability of typability exhibiting an algorithm
Decidability of checking corollary of other results
3.4 Inductive Definitions, More Formally (optional)
Here we will be more precise about inductive definitions and rule induction. Following this
may give you a sharper understanding, but it is not itself examinable. To make an inductive
definition of a particular subset of a set A, take a set R of some concrete rule instances,
each of which is a pair (H , c) where H is a finite subset of A (the hypotheses) and c is an
element of A (the conclusion).
Consider finite trees labelled by elements of A for which every step is in R, eg
a1
a3
a2
a0
where ({}, a1), ({}, a3), ({a3}, a2), and ({a1, a2}, a0) all elements of R.
The subset SR of A inductively defined by the rule intances R is the set of a ∈ A such that
there is such a proof with root node labelled by a.
For the definition of the transition relation:
• Start with A = expr ∗ store ∗ expr ∗ store
•We define −→⊆ A (write infix, e.g.〈e, s〉 −→ 〈e ′, s ′〉 instead of (e, s, e ′, s ′) ∈−→ ).
• The rule instances R are the concrete rule instances of the transition rules.
For the definition of the typing relation:
• Start with A = TypeEnv ∗ expr ∗ types.
•We define ⊢⊆ A (write mixfix, e.g.Γ ⊢ e:T instead of (Γ, e,T ) ∈⊢).
• The rule instances are the concrete rule instances of the typing rules.
Instead of talking informally about derivations as finite trees, we can regard SR as a least
fixed point. Given rules R, define FR:P A→ P A by
FR(S ) = {c | ∃ H .(H , c) ∈ R ∧H ⊆ S}
(FR(S ) is the set of all things you can derive in exactly one step from things in S )
S0R = {}
Sk+1R = FR(S
k
R)
SωR =
⋂
k ∈ N SR
k
Theorem 9 SR = S
ω
R.
Say a subset S ⊆ A is closed under rules R if ∀(H , c) ∈ R.(H ⊆ S ) ⇒ c ∈ S , ie, if
FR(S ) ⊆ S .
Theorem 10 SR =
⋂{S | S ⊆ A ∧ FR(S ) ⊆ S}
61
This says ‘the subset SR of A inductively defined by R is the smallest set closed under the
rules R’. It is the intersection of all of them, so smaller than (or equal to) any of them.
Now, to prove something about an inductively-defined set...
To see why rule induction is sound, using this definition: Saying {a | Φ(a)} closed under
the rules means exactly FR({a | Φ(a)}) ⊆ {a | Φ(a)}, so by Theorem 10 we have SR ⊆ {a |
Φ(a)}, i.e.∀ a ∈ SR.a ∈ {a ′ | Φ(a ′)}, i.e.∀ a ∈ SR.Φ(a).
3.5 Exercises
Exercise 14 ⋆Without looking at the proof in the notes, do the cases of the proof of The-
orem 1 (Determinacy) for e1 op e2, e1; e2, while e1 do e2, and if e1 then e2 else e3.
Exercise 15 ⋆Try proving Determinacy for the language with nondeterministic order of
evaluation for e1 op e2 (ie with both (op1) and (op1b) rules), which is not determinate.
Explain where exactly the proof can’t be carried through.
Exercise 16 ⋆Complete the proof of Theorem 2 (Progress).
Exercise 17 ⋆⋆Complete the proof of Theorem 3 (Type Preservation).
Exercise 18 ⋆⋆Give an alternate proof of Theorem 3 (Type Preservation) by rule induc-
tion over type derivations.
Exercise 19 ⋆⋆Prove Theorem 7 (Uniqueness of Typing).
62
4 Functions
Functions – L2
Functions, Methods, Procedures...
fun addone x = x+1
public int addone(int x) {
x+1
}
<script type="text/vbscript">
function addone(x)
addone = x+1
end function
</script>
Slide 6
C♯
delegate int IntThunk();
class M {
public static void Main() {
IntThunk[] funcs = new IntThunk[11];
for (int i = 0; i <= 10; i++)
{
funcs[i] = delegate() { return i; };
}
foreach (IntThunk f in funcs)
{
System.Console.WriteLine(f());
}
}
}
Most languages have some kind of function, method, or procedure – some way of abstracting
a piece of code on a formal parameter so that you can use the code multiple times with
different arguments, without having to duplicate the code in the source. The next two
lectures explore the design space for functions, adding them to L1.
63
Functions – Examples
Going to add expressions like these to L1.
(fn x:int⇒ x + 1)
(fn x:int⇒ x + 1) 7
(fn y:int⇒ (fn x:int⇒ x + y))
(fn y:int⇒ (fn x:int⇒ x + y)) 1
(fn x:int→ int⇒ (fn y:int⇒ x (x y)))
(fn x:int→ int⇒ (fn y:int⇒ x (x y))) (fn x:int⇒ x + 1)
(
(fn x:int→ int⇒ (fn y:int⇒ x (x y))) (fn x:int⇒ x + 1)
)
7
For simplicity, we’ll deal with anonymous functions only. Functions will always take a single
argument and return a single result — though either might itself be a function or a tuple.
Functions – Syntax
First, extend the L1 syntax:
Variables x ∈ X for a set X = {x, y, z, ...}
Expressions
e ::= ... | fn x :T ⇒ e | e1 e2 | x
Types
T ::= int | bool | unit | T1 → T2
Tloc ::= intref
• Concrete syntax: by convention, application associates to the left, so e1 e2 e3 denotes
(e1 e2) e3, and type arrows associate to the right, so T1 → T2 → T3 denotes T1 →
(T2 → T3). A fn extends to the right as far as parentheses permit, so fn x:unit⇒ x; x
denotes fn x:unit ⇒ (x; x), not (fn x:unit ⇒ x); x. These conventions work well for
functions that take several arguments, e.g.fn x:unit ⇒ fn y:int ⇒ x; y has type
unit → int → int, and we can fully apply it simply by juxtaposing it with its two
arguments (fn x:unit⇒ fn y:int⇒ x; y) skip 15.
• Variables are not locations ( L ∩ X = {} ), so x := 3 is not in the syntax.
• The (non-meta) variables x, y, z are not the same as metavariables x , y , z . In the notes
they are distinguished by font; in handwriting one just have to keep track in your head
– not often a problem.
• These expressions look like lambda terms ( fn x:int ⇒ x could be written λx:int.x
). But, (a) we’re adding them to a rich language, not working with the pure lambda
calculus (cf. Foundations of Functional Programming), and (b) we’re going to explore
several options for how they should behave.
• Returning to the idea of type-directed language design: this type grammar (and ex-
pression syntax) suggests the language will include higher-order functions – you can
abstract on a variable of any type, including function types. If you only wanted first-
order functions, you’d say
A ::= int | bool | unit
T ::= A | A→ T
Tloc ::= intref
Note that the first-order function types include types like int → (int → int) and
int→ (int→ (int→ int)), of functions that take an argument of base type and return
64
a (first-order) function, e.g.
(fn y:int⇒ (fn x:int⇒ x + y))
Some languages go further, forbidding partial application – and thereby avoiding the
need for heap-allocated closures in the implementation. We’ll come back to this.
4.1 Function Preliminaries: Abstract Syntax up to Alpha Conver-
sion, and Substitution
In order to express the semantics for functions, we need some auxiliary definitions.
Variable shadowing
(fn x:int⇒ (fn x:int⇒ x + 1))
class F {
void m() {
int y;
{int y; ... } // Static error
...
{int y; ... }
...
}
}
The second is not allowed in Java. For large systems that would be a problem, eg in a
language with nested function definitions, where you may wish to write a local function
parameter without being aware of what is in the surrounding namespace. There are other
issues to do with class namespaces.
Alpha conversion
In expressions fn x :T ⇒ e the x is a binder.
• inside e , any x ’s (that aren’t themselves binders and are not inside
another fn x :T ′ ⇒ ...) mean the same thing – the formal parameter
of this function.
• outside this fn x :T ⇒ e , it doesn’t matter which variable we used for
the formal parameter – in fact, we shouldn’t be able to tell. For
example, fn x:int⇒ x + 2 should be the same as
fn y:int⇒ y + 2.
cf
∫ 1
0
x + x2dx =
∫ 1
0
y + y2dy
65
Alpha conversion – free and bound occurrences
In a bit more detail (but still informally):
Say an occurrence of x in an expression e is free if it is not inside any
(fn x :T ⇒ ...). For example:
17
x + y
fn x:int⇒ x + 2
fn x:int⇒ x + z
if y then 2 + x else ((fn x:int⇒ x + 2)z)
All the other occurrences of x are bound by the closest enclosing
fn x :T ⇒ ....
Note that in fn x:int⇒ 2 the x is not an occurrence. Likewise, in fn x:int⇒ x + 2 the left
x is not an occurrence; here the right x is an occurrence that is bound by the left x.
Sometimes it is handy to draw in the binding:
Alpha conversion – Binding examples
fn x:int⇒x   + 2
fn x:int⇒x   + z
fn y:int⇒y   + z
fn z:int⇒z +z
fn x:int⇒ (fn x:int⇒x   + 2)
Alpha Conversion – The Convention
Convention: we will allow ourselves to any time at all, in any expression
...(fn x :T ⇒ e)..., replace the binding x and all occurrences of x that
are bound by that binder, by any other variable – so long as that doesn’t
change the binding graph.
For example:
fn x:int⇒x   + z = fn y:int⇒y   + z 6= fn z:int⇒z +z
This is called ‘working up to alpha conversion’. It amounts to regarding
the syntax not as abstract syntax trees, but as abstract syntax trees with
pointers...
66
Abstract Syntax up to Alpha Conversion
fn x:int⇒ x + z = fn y:int⇒ y + z 6= fn z:int⇒ z + z
Start with naive abstract syntax trees:
fn x:int⇒
+
x
tttttt
z
IIIIII
fn y:int⇒
+
y
uuuuuu
z
IIIIII
fn z:int⇒
+
z
uuuuuu
z
IIIIII
add pointers (from each x node to the closest enclosing fn x :T ⇒ node);
remove names of binders and the occurrences they bind
fn · :int⇒
+
•
tttttt
==
z
JJJJJJ
fn · :int⇒
+
•
tttttt
==
z
JJJJJJ
fn · :int⇒
+
•
tttttt
==
•
JJJJJJ
aa
fn x:int⇒ (fn x:int⇒ x + 2)
= fn y:int⇒ (fn z:int⇒ z + 2) 6= fn z:int⇒ (fn y:int⇒ z + 2)
fn · :int⇒
fn · :int⇒
+
•
uuuuuu
>>
2
IIIIII
fn · :int⇒
fn · :int⇒
+
•
uuuuuu
88
2
IIIIII
(fn x:int⇒ x) 7 fn z:int→ int→ int⇒ (fn y:int⇒ z y y)
@
fn · :int⇒
tttttt
7
222
•
DD
fn · :int→ int→ int⇒
fn · :int⇒
@
@
jjjjjjjjjjjj •
SSSSSSSSSSSS
kk
•

66
•
TTTTTTTTTTTTT
]]
67
De Bruijn Indices
Our implementation will use those pointers – known as De Bruijn Indices.
Each occurrence of a bound variable is represented by the number of
fn · :T ⇒ nodes you have to count out to to get to its binder.
fn · :int⇒ (fn · :int⇒ v0 + 2) 6= fn · :int⇒ (fn · :int⇒ v1 + 2)
fn · :int⇒
fn · :int⇒
+
•
uuuuuu
>>
2
IIIIII
fn · :int⇒
fn · :int⇒
+
•
uuuuuu
88
2
IIIIII
Free Variables
Say the free variables of an expression e are the set of variables x for
which there is an occurence of x free in e .
fv(x ) = {x}
fv(e1 op e2) = fv(e1) ∪ fv(e2)
fv(fn x :T ⇒ e) = fv(e)− {x}
Say e is closed if fv(e) = {}.
If E is a set of expressions, write fv(E ) for
⋃
e ∈ E fv(e).
(note this definition is alpha-invariant - all our definitions should be)
For example
fv(x + y) = {x, y}
fv(fn x:int⇒ x + y) = {y}
fv(x + (fn x:int⇒ x + y)7) = {x, y}
Full definition of fv(e):
fv(x ) = {x}
fv(fn x :T ⇒ e) = fv(e)− {x}
fv(e1 e2) = fv(e1) ∪ fv(e2)
fv(n) = {}
fv(e1 op e2) = fv(e1) ∪ fv(e2)
fv(if e1 then e2 else e3) = fv(e1) ∪ fv(e2) ∪ fv(e3)
fv(b) = {}
fv(skip) = {}
fv(ℓ := e) = fv(e)
fv(!ℓ) = {}
fv(e1; e2) = fv(e1) ∪ fv(e2)
fv(while e1 do e2) = fv(e1) ∪ fv(e2)
(for an example of a definition that is not alpha-invariant, consider
bv(x ) = {}
bv(fn x :T ⇒ e) = {x} ∪ bv(e)
bv(e1 e2) = bv(e1) ∪ bv(e2)
...
This is fine for concrete terms, but we’re working up to alpha conversion, so (fn x:int ⇒
2) = (fn y:int⇒ 2) but bv(fn x:int⇒ 2) = {x} 6= {y} = bv(fn y:int⇒ 2). Argh! Can see
68
from looking back at the abstract syntax trees up to alpha conversion that they just don’t
have this information in, anyway.)
The semantics for functions will involve substituting actual parameters for formal parame-
ters. That’s a bit delicate in a world with binding...
Substitution – Examples
The semantics for functions will involve substituting actual parameters for
formal parameters.
Write {e/x}e ′ for the result of substituting e for all free occurrences of x
in e ′. For example
{3/x}(x ≥ x) = (3 ≥ 3)
{3/x}((fn x:int⇒ x + y)x) = (fn x:int⇒ x + y)3
{y + 2/x}(fn y:int⇒ x + y) = fn z:int⇒ (y + 2) + z
Note that substitution is a meta-operation – it’s not part of the L2 expression grammar.
The notation used for substitution varies – people write {3/x}e, or [3/x ]e, or e[3/x ], or
{x ← 3}e, or...
Substitution – Definition
Defining that:
{e/z}x = e if x = z
= x otherwise
{e/z}(fn x :T ⇒ e1) = fn x :T ⇒ ({e/z}e1) if x 6= z (*)
and x /∈ fv(e) (*)
{e/z}(e1 e2) = ({e/z}e1)({e/z}e2)
...
if (*) is not true, we first have to pick an alpha-variant of fn x :T ⇒ e1 to
make it so (always can)
Substitution – Example Again
{y + 2/x}(fn y:int⇒ x + y)
= {y + 2/x}(fn y′:int⇒ x + y′) renaming
= fn y′:int⇒ {y + 2/x}(x + y′) as y′ 6= x and y′ /∈ fv(y + 2)
= fn y′:int⇒ {y + 2/x}x + {y + 2/x}y′
= fn y′:int⇒ (y + 2) + y′
(could have chosen any other z instead of y′, except y or x)
Substitution – Simultaneous
Generalising to simultaneous substitution: Say a substitution σ is a finite
partial function from variables to expressions.
Notation: write a σ as {e1/x1, .., ek/xk} instead of
{x1 7→ e1, ..., xk 7→ ek} (for the function mapping x1 to e1 etc.)
Define σ e in the notes.
69
Write dom(σ) for the set of variables in the domain of σ; ran(σ) for the set of expressions
in the range of σ, ie
dom({e1/x1, .., ek/xk}) = {x1, .., xk}
ran({e1/x1, .., ek/xk}) = {e1, .., ek}
Define the application of a substitution to a term by:
σ x = σ(x ) if x ∈ dom(σ)
= x otherwise
σ(fn x :T ⇒ e) = fn x :T ⇒ (σ e) if x /∈ dom(σ) and x /∈ fv(ran(σ)) (*)
σ(e1 e2) = (σ e1)(σ e2)
σ n = n
σ(e1 op e2) = σ(e1) op σ(e2)
σ(if e1 then e2 else e3) = if σ(e1) then σ(e2) else σ(e3)
σ(b) = b
σ(skip) = skip
σ(ℓ := e) = ℓ := σ(e)
σ(!ℓ) = !ℓ
σ(e1; e2) = σ(e1);σ(e2)
σ(while e1 do e2) = while σ(e1) do σ(e2)
4.2 Function Behaviour
Function Behaviour
Consider the expression
e = (fn x:unit⇒ (l := 1); x) (l := 2)
then
〈e, {l 7→ 0}〉 −→∗ 〈skip, {l 7→ ???}〉
Function Behaviour. Choice 1: Call-by-value
Informally: reduce left-hand-side of application to a fn-term; reduce
argument to a value; then replace all occurrences of the formal parameter
in the fn-term by that value.
e = (fn x:unit⇒ (l := 1); x)(l := 2)
〈e, {l = 0}〉 −→ 〈(fn x:unit⇒ (l := 1); x)skip, {l = 2}〉
−→ 〈(l := 1); skip , {l = 2}〉
−→ 〈skip; skip , {l = 1}〉
−→ 〈skip , {l = 1}〉
This is most common design choice - ML, Java,...
70
L2 Call-by-value
Values v ::= b | n | skip | fn x :T ⇒ e
(app1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(app2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v e2, s〉 −→ 〈v e ′2, s ′〉
(fn) 〈(fn x :T ⇒ e) v , s〉 −→ 〈{v/x}e, s〉
• This is a strict semantics – fully evaluating the argument to function before doing the
application.
• One could evaluate e1 e2 right-to-left instead or left-to-right. That would be perverse
– better design is to match the evaluation order for operators etc.
L2 Call-by-value – reduction examples
〈(fn x:int⇒ fn y:int⇒ x + y) (3 + 4) 5 , s〉
= 〈
(
(fn x:int⇒ fn y:int⇒ x + y) (3 + 4)
)
5 , s〉
−→ 〈
(
(fn x:int⇒ fn y:int⇒ x + y) 7
)
5 , s〉
−→ 〈
(
{7/x}(fn y:int⇒ x + y)
)
5 , s〉
= 〈
(
(fn y:int⇒ 7 + y)
)
5 , s〉
−→ 〈7 + 5 , s〉
−→ 〈12 , s〉
(fn f:int→ int⇒ f 3) (fn x:int⇒ (1 + 2) + x)
• The syntax has explicit types and the semantics involves syntax, so types appear in
semantics – but they are not used in any interesting way, so an implementation could
erase them before execution. Not all languages have this property.
• The rules for these constructs, and those in the next few lectures, don’t touch the store,
but we need to include it in the rules in order to get the sequencing of side-effects right.
In a pure functional language, configurations would just be expressions.
• A naive implementation of these rules would have to traverse e and copy v as many
times as there are free occurrences of x in e. Real implementations don’t do that,
using environments instead of doing substitution. Environments are more efficient;
substitutions are simpler to write down – so better for implementation and semantics
respectively.
71
Function Behaviour. Choice 2: Call-by-name
Informally: reduce left-hand-side of application to a fn-term; then replace
all occurrences of the formal parameter in the fn-term by the argument.
e = (fn x:unit⇒ (l := 1); x) (l := 2)
〈e, {l 7→ 0}〉 −→ 〈(l := 1); l := 2, {l 7→ 0}〉
−→ 〈skip ; l := 2, {l 7→ 1}〉
−→ 〈l := 2 , {l 7→ 1}〉
−→ 〈skip , {l 7→ 2}〉
This is the foundation of ‘lazy’ functional languages – e.g. Haskell
L2 Call-by-name
(same typing rules as before)
(CBN-app)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(CBN-fn) 〈(fn x :T ⇒ e)e2, s〉 −→ 〈{e2/x}e, s〉
Here, don’t evaluate the argument at all if it isn’t used
〈(fn x:unit⇒ skip)(l := 2), {l 7→ 0}〉
−→ 〈{l := 2/x}skip , {l 7→ 0}〉
= 〈skip , {l 7→ 0}〉
but if it is, end up evaluating it repeatedly.
Haskell uses a refined variant – call-by-need – in which the first time the argument evaluated
we ‘overwrite’ all other copies by that value.
That lets you do some very nice programming, e.g. with potentially-infinite datastructures.
Call-By-Need Example (Haskell)
let notdivby x y = y ‘mod‘ x /= 0
enumFrom n = n : (enumFrom (n+1))
sieve (x:xs) =
x : sieve (filter (notdivby x) xs)
in
sieve (enumFrom 2)
==>
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,
59,61,67,71,73,79,83,89,97,101,103,107,109,
113,127,131,137,139,149,151,157,163,167,173,
179,181,191,193,197,199,211,223,227,229,233,
,,Interrupted!
72
Function Behaviour. Choice 3: Full beta
Allow both left and right-hand sides of application to reduce. At any point
where the left-hand-side has reduced to a fn-term, replace all
occurrences of the formal parameter in the fn-term by the argument.
Allow reduction inside lambdas.
(fn x:int⇒ 2 + 2) −→ (fn x:int⇒ 4)
L2 Beta
(beta-app1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(beta-app2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈e1 e2, s〉 −→ 〈e1 e ′2, s ′〉
(beta-fn1) 〈(fn x :T ⇒ e)e2, s〉 −→ 〈{e2/x}e, s〉
(beta-fn2)
〈e, s〉 −→ 〈e ′, s ′〉
〈fn x :T ⇒ e, s〉 −→ 〈fn x :T ⇒ e ′, s ′〉
This reduction relation includes the CBV and CBN relations, and also reduction inside
lambdas.
L2 Beta: Example
(fn x:int⇒ x + x) (2 + 2)
}}zz
zz
++WWWW
WWWWW
WWWWW
W
(fn x:int⇒ x + x) 4
$$I
II
II
II
II
II
II
II
(2 + 2) + (2 + 2)
uukkkk
kkk
))SSS
SSS
S
4 + (2 + 2)

(2 + 2) + 4
rreeeeee
eeeeee
eeeeee
eeee
4 + 4

8
This ain’t much good for a programming language... why? (if you’ve got any non-terminating
computation Ω, then (λx .y) Ω might terminate or not, depending on the implementation)
(in pure lambda you do have confluence, which saves you – at least mathematically)
Function Behaviour. Choice 4: Normal-order reduction
Leftmost, outermost variant of full beta.
But, in full beta, or in CBN, it becomes rather hard to understand what order your code
is going to be run in! Hence, non-strict languages typically don’t allow unrestricted side
effects (our combination of store and CBN is pretty odd). Instead, Haskell encourages pure
programming, without effects (store operations, IO, etc.) except where really necessary.
Where they are necessary, it uses a fancy type system to give you some control of evaluation
order.
Purity
Note that Call-by-Value and Call-by-Name are distinguishable even if there is no store – con-
sider applying a function to a non-terminating argument, eg (fn x:unit⇒ skip) (while true do skip).
Call-by-Name and Call-by-Need are not distinguishable except by performance properties –
but those really matter.
73
Back to CBV (from now on).
4.3 Function Typing
Typing functions (1)
Before, Γ gave the types of store locations; it ranged over TypeEnv
which was the set of all finite partial functions from locations L to Tloc.
Now, it must also give assumptions on the types of variables: e.g.
l1:intref, x:int, y:bool→ int.
Take Γ ∈ TypeEnv2, the finite partial functions from L ∪ X to
Tloc ∪ T such that
∀ ℓ ∈ dom(Γ).Γ(ℓ) ∈ Tloc
∀ x ∈ dom(Γ).Γ(x ) ∈ T
Notation: if x /∈ dom(Γ), write Γ, x :T for the partial function which
maps x to T but otherwise is like Γ.
Typing functions (2)
(var) Γ ⊢ x :T if Γ(x ) = T
(fn) Γ, x :T ⊢ e:T
′
Γ ⊢ fn x :T ⇒ e : T → T ′
(app) Γ ⊢ e1:T → T ′ Γ ⊢ e2:T
Γ ⊢ e1 e2:T ′
Typing functions – Example
x:int ⊢ x:int (var) x:int ⊢ 2:int (int)
x:int ⊢ x + 2:int (op+)
{} ⊢ (fn x:int⇒ x + 2):int→ int (fn) {} ⊢ 2:int (int)
{} ⊢ (fn x:int⇒ x + 2) 2:int (app)
• The syntax is explicitly typed, so don’t need to ‘guess’ a T in the fn rule.
• Recall that variables of these types are quite different from locations – you can’t assign
to variables; you can’t abstract on locations. For example, (fn l :intref ⇒!l) is not in
the syntax.
• Note that sometimes you need the alpha convention, e.g. to type
fn x:int⇒ x + (fn x:bool⇒ if x then 3 else 4)true
It’s a good idea to start out with all binders different from each other and from all
free variables. It would be a bad idea to prohibit variable shadowing like this in source
programs.
• In ML you have parametrically polymorphic functions, but we won’t talk about them
here – that’s in Part II Types.
• Note that these functions are not recursive (as you can see in the syntax: there’s no
way in the body of fn x :T ⇒ e to refer to the function as a whole).
74
• With our notational convention for Γ, x :T , we could rewrite the (var) rule as Γ, x :T ⊢
x :T . By the convention, x is not in the domain of Γ, and Γ + {x 7→ T} is a perfectly
good partial function.
Another example:
l :intref, x:unit ⊢ 1:int (int)
l :intref, x:unit ⊢ (l := 1):unit (assign) l :intref, x:unit ⊢ x:unit (var)
l :intref, x:unit ⊢ (l := 1); x:unit (seq)
l :intref ⊢ (fn x:unit⇒ (l := 1); x):unit→ unit (fn)
l :intref ⊢ 2:int (int)
l :intref ⊢ (l := 2):unit (assign)
l :intref ⊢ (fn x:unit⇒ (l := 1); x) (l := 2):unit (app)
Properties of Typing
As before, but only interested in executing closed programs.
Theorem 11 (Progress) If e closed and Γ ⊢ e:T and
dom(Γ) ⊆ dom(s) then either e is a value or there exist e ′, s ′ such that
〈e, s〉 −→ 〈e ′, s ′〉.
Note there are now more stuck configurations, e.g.((3) (4))
Theorem 12 (Type Preservation) If e closed and Γ ⊢ e:T and
dom(Γ) ⊆ dom(s) and 〈e, s〉 −→ 〈e ′, s ′〉 then Γ ⊢ e ′:T and e ′
closed and dom(Γ) ⊆ dom(s ′).
Proving Type Preservation
Theorem 12 (Type Preservation) If e closed and Γ ⊢ e:T and
dom(Γ) ⊆ dom(s) and 〈e, s〉 −→ 〈e ′, s ′〉 then Γ ⊢ e ′:T and e ′
closed and dom(Γ) ⊆ dom(s ′).
Taking
Φ(e, s , e ′, s ′) =
∀ Γ,T .
Γ ⊢ e:T ∧ closed(e) ∧ dom(Γ) ⊆ dom(s)
⇒
Γ ⊢ e ′:T ∧ closed(e ′) ∧ dom(Γ) ⊆ dom(s ′)
we show ∀ e, s , e ′, s ′.〈e, s〉 −→ 〈e ′, s ′〉 ⇒ Φ(e, s , e ′, s ′) by rule
induction.
To prove this one uses:
Lemma 7 (Substitution) If Γ ⊢ e:T and Γ, x :T ⊢ e ′:T ′ with
x /∈ dom(Γ) then Γ ⊢ {e/x}e ′:T ′.
Determinacy and type inference properties also hold.
Normalisation
Theorem 13 (Normalisation) In the sublanguage without while loops or
store operations, if Γ ⊢ e:T and e closed then there does not exist an
infinite reduction sequence 〈e, {}〉 −→ 〈e1, {}〉 −→ 〈e2, {}〉 −→ ...
Proof ? can’t do a simple induction, as reduction can make terms grow.
See Pierce Ch.12 (the details are not in the scope of this course). 
75
4.4 Local Definitions and Recursive Functions
Local definitions
For readability, want to be able to name definitions, and to restrict their
scope, so add:
e ::= ... | let val x :T = e1 in e2 end
this x is a binder, binding any free occurrences of x in e2.
Can regard just as syntactic sugar :
let val x :T = e1 in e2 end  (fn x :T ⇒ e2)e1
Local definitions – derived typing and reduction rules (CBV)
let val x :T = e1 in e2 end  (fn x :T ⇒ e2)e1
(let) Γ ⊢ e1:T Γ, x :T ⊢ e2:T
′
Γ ⊢ let val x :T = e1 in e2 end:T ′
(let1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈let val x :T = e1 in e2 end, s〉 −→ 〈let val x :T = e ′1 in e2 end, s ′〉
(let2)
〈let val x :T = v in e2 end, s〉 −→ 〈{v/x}e2, s〉
Our alpha convention means this really is a local definition – there is no way to refer to the
locally-defined variable outside the let val .
x + let val x:int = x in (x + 2) end = x + let val y:int = x in (y + 2) end
Recursive definitions – first attempt
How about
x = (fn y:int⇒ if y ≥ 1 then y + (x (y +−1)) else 0)
where we use x within the definition of x? Think about evaluating x 3.
Could add something like this:
e ::= ... | let val rec x :T = e in e ′ end
(here the x binds in both e and e ′) then say
let val rec x:int→ int =
(fn y:int⇒ if y ≥ 1 then y + (x(y +−1)) else 0)
in x 3 end
76
But...
What about
let val rec x = (x, x) in x end ?
Have some rather weird things, eg
let val rec x:int list = 3 :: x in x end
does that terminate? if so, is it equal to
let val rec x:int list = 3 :: 3 :: x in x end ? does
let val rec x:int list = 3 :: (x + 1) in x end terminate?
In a CBN language, it is reasonable to allow this kind of thing, as will only
compute as much as needed. In a CBV language, would usually disallow,
allowing recursive definitions only of functions...
Recursive Functions
So, specialise the previous let val rec construct to
T = T1 → T2 recursion only at function types
e = fn y :T1 ⇒ e1 and only of function values
e ::= ... | let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
(here the y binds in e1; the x binds in (fn y :T ⇒ e1) and in e2)
(let rec fn) Γ, x :T1 → T2, y :T1 ⊢ e1:T2 Γ, x :T1 → T2 ⊢ e2:T
Γ ⊢ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end:T
Concrete syntax: In ML can write let fun f (x :T1):T2 = e1 in e2 end,
or even let fun f (x ) = e1 in e2 end, for
let val rec f :T1 → T2 = fn x :T1 ⇒ e1 in e2 end.
Recursive Functions – Semantics
(letrecfn) let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
−→
{(fn y :T1 ⇒ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e1 end)/x}e2
(sometimes use fix:((T1 → T2) → (T1 → T2)) → (T1 → T2) – cf. the Y combinator, in
Foundations of Functional Programming)
77
For example:
let val rec x:int→ int =
(fn y:int⇒ if y ≥ 1 then y + (x(y +−1)) else 0)
in
x 3
end
−→ (letrecfn)
(
fn y:int⇒
let val rec x:int→ int =
(fn y:int⇒ if y ≥ 1 then y + (x(y +−1)) else 0)
in
if y ≥ 1 then y + (x(y +−1)) else 0
end
)
3
−→ (app)
let val rec x:int→ int =
(fn y:int⇒ if y ≥ 1 then y + (x(y +−1)) else 0)
in
if 3 ≥ 1 then 3 + (x(3 +−1)) else 0)
end
−→ (letrecfn)
if 3 ≥ 1 then
3 + (
(
fn y:int⇒
let val rec x:int→ int =
(fn y:int⇒ if y ≥ 1 then y + (x(y +−1)) else 0)
in
if y ≥ 1 then y + (x(y +−1)) else 0
end
)
(3 +−1))
else
0
−→ ...
Recursive Functions – Minimisation Example
Below, in the context of the let val rec , x f n finds the smallest n ′ ≥ n
for which f n ′ evaluates to some m ′ ≤ 0.
let val rec x:(int→ int)→ int→ int
= fn f:int→ int⇒ fn z:int⇒ if (f z) ≥ 1 then x f (z + 1) else z
in
let val f:int→ int
= (fn z:int⇒ if z ≥ 3 then (if 3 ≥ z then 0 else 1) else 1)
in
x f 0
end
end
As a test case, we apply it to the function (fn z :int⇒ if z ≥ 3 then (if 3 ≥ z then 0 else 1) else 1),
which is 0 for argument 3 and 1 elsewhere.
78
More Syntactic Sugar
Do we need e1; e2?
No: Could encode by e1; e2  (fn y :unit⇒ e2)e1
Do we need while e1 do e2?
No: could encode by while e1 do e2  
let val rec w:unit→ unit =
fn y:unit⇒ if e1 then (e2; (w skip)) else skip
in
w skip
end
for fresh w and y not in fv(e1) ∪ fv(e2).
In each case typing is the same (more precisely?); reduction is ‘essentially’ the same. What
does that mean? More later, on contextual equivalence.
OTOH, Could we encode recursion in the language without?
We know at least that you can’t in the language without while or store, as
had normalisation theorem there and can write
let val rec x:int→ int = fn y:int⇒ x(y + 1) in x 0 end
here.
4.5 Implementation
Implementation
There is an implementation of L2 on the course web page.
See especially Syntax.sml and Semantics.sml. It uses a front
end written with mosmllex and mosmlyac.
Also, as before, L2 expressions can be executed directly in a Moscow ML
context.
The README file says:
(* 2002-11-08 -- Time-stamp: <2003-04-25 17:28:25 pes20> *)
(* Peter Sewell *)
This directory contains an interpreter, pretty-printer and
type-checker for the language L2.
To make it go, copy it into a working directory, ensure Moscow ML
is available (including mosmllex and mosmlyac), and type
make
mosml
load "Main";
It prompts you for an L2 expression (terminated by RETURN, no terminating
semicolons) and then for an initial store. For the latter, if you
just press RETURN you get a default store in which all the locations
mentioned in your expression are mapped to 0.
79
Watch out for the parsing - it is not quite the same as (eg) mosml, so
you need to parenthesise more.
The source files are:
Main.sml the top-level loop
Syntax.sml datatypes for raw and de-bruijn expressions
Lexer.lex the lexer (input to mosmllex)
Parser.grm the grammar (input to mosmlyac)
Semantics.sml scope resolution, the interpreter, and the typechecker
PrettyPrint.sml pretty-printing code
Examples.l2 some handy examples for cut-and-pasting into the
top-level loop
of these, you’re most likely to want to look at, and change, Semantics.sml.
You should first also look at Syntax.sml.
The implementation lets you type in L2 expressions and initial stores and watch them
resolve, type-check, and reduce.
Implementation – Scope Resolution
datatype expr raw = ...
| Var raw of string
| Fn raw of string * type expr * expr raw
| App raw of expr raw * expr raw
| ...
datatype expr = ...
| Var of int
| Fn of type expr * expr
| App of expr * expr
resolve scopes : expr raw -> expr
(it raises an exception if the expression has any free variables)
Implementation – Substitution
subst : expr -> int -> expr -> expr
subst e 0 e’ substitutes e for the outermost var in e’.
(the definition is only sensible if e is closed, but that’s ok – we only
evaluate whole programs. For a general definition, see [Pierce, Ch. 6])
fun subst e n (Var n1) = if n=n1 then e else Var n1
| subst e n (Fn(t,e1)) = Fn(t,subst e (n+1) e1)
| subst e n (App(e1,e2)) = App(subst e n e1,subst e n e2)
| subst e n (Let(t,e1,e2))
= Let (t,subst e n e1,subst e (n+1) e2)
| subst e n (Letrecfn (tx,ty,e1,e2))
= Letrecfn (tx,ty,subst e (n+2) e1,subst e (n+1) e2)
| ...
80
If e’ represents a closed term fn x :T ⇒ e ′1 then e’ = Fn(t,e1’) for t and e1’ representing
T and e ′1. If also e represents a closed term e then subst e 0 e1’ represents {e/x}e ′1.
Implementation – CBV reduction
reduce (App (e1,e2),s) = (case e1 of
Fn (t,e) =>
(if (is value e2) then
SOME (subst e2 0 e,s)
else
(case reduce (e2,s) of
SOME(e2’,s’) => SOME(App (e1,e2’),s’)
| NONE => NONE))
| => (case reduce (e1,s) of
SOME (e1’,s’)=>SOME(App(e1’,e2),s’)
| NONE => NONE ))
Implementation – Type Inference
type typeEnv
= (loc*type loc) list * type expr list
inftype gamma (Var n) = nth (#2 gamma) n
inftype gamma (Fn (t,e))
= (case inftype (#1 gamma, t::(#2 gamma)) e of
SOME t’ => SOME (func(t,t’) )
| NONE => NONE )
inftype gamma (App (e1,e2))
= (case (inftype gamma e1, inftype gamma e2) of
(SOME (func(t1,t1’)), SOME t2) =>
if t1=t2 then SOME t1’ else NONE
| => NONE )
Implementation – Closures
Naively implementing substitution is expensive. An efficient
implementation would use closures instead – cf. Compiler Construction.
We could give a more concrete semantics, closer to implementation, in
terms of closures, and then prove it corresponds to the original
semantics...
(if you get that wrong, you end up with dynamic scoping, as in original
LISP)
81
Aside: Small-step vs Big-step Semantics
Throughout this course we use small-step semantics, 〈e, s〉 −→ 〈e ′, s ′〉.
There is an alternative style, of big-step semantics 〈e, s〉 ⇓ 〈v , s ′〉, for
example
〈n, s〉 ⇓ 〈n, s〉
〈e1, s〉 ⇓ 〈n1, s ′〉 〈e2, s ′〉 ⇓ 〈n2, s ′′〉
〈e1 + e2, s〉 ⇓ 〈n, s ′′〉 n = n1 + n2
(see the notes from earlier courses by Andy Pitts).
For sequential languages, it doesn’t make a major difference. When we
come to add concurrency, small-step is more convenient.
4.6 L2: Collected Definition
Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Variables x ∈ X for a set X = {x, y, z, ...}
Operations op ::= + |≥
Types
T ::= int | bool | unit | T1 → T2
Tloc ::= intref
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2|
fn x :T ⇒ e | e1 e2 | x |
let val x :T = e1 in e2 end|
let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
In expressions fn x :T ⇒ e the x is a binder. In expressions let val x :T = e1 in e2 end
the x is a binder. In expressions let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end the
y binds in e1; the x binds in (fn y :T ⇒ e1) and in e2.
Operational Semantics
Say stores s are finite partial functions from L to Z. Values v ::= b | n | skip | fn x :T ⇒ e
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
82
(deref) 〈!ℓ, s〉 −→ 〈n, s〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s〉 −→ 〈skip, s + {ℓ 7→ n}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2;while e1 do e2) else skip, s〉
(app1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(app2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v e2, s〉 −→ 〈v e ′2, s ′〉
(fn) 〈(fn x :T ⇒ e) v , s〉 −→ 〈{v/x}e, s〉
(let1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈let val x :T = e1 in e2 end, s〉 −→ 〈let val x :T = e ′1 in e2 end, s ′〉
(let2)
〈let val x :T = v in e2 end, s〉 −→ 〈{v/x}e2, s〉
(letrecfn) let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
−→
{(fn y :T1 ⇒ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e1 end)/x}e2
Typing
Take Γ ∈ TypeEnv2, the finite partial functions from L ∪ X to Tloc ∪ T such that
∀ ℓ ∈ dom(Γ).Γ(ℓ) ∈ Tloc
83
∀ x ∈ dom(Γ).Γ(x ) ∈ T
(int) Γ ⊢ n:int for n ∈ Z
(bool) Γ ⊢ b:bool for b ∈ {true, false}
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
(op ≥)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 ≥ e2:bool
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
(assign)
Γ(ℓ) = intref
Γ ⊢ e:int
Γ ⊢ ℓ := e:unit
(deref)
Γ(ℓ) = intref
Γ ⊢!ℓ:int
(skip) Γ ⊢ skip:unit
(seq)
Γ ⊢ e1:unit
Γ ⊢ e2:T
Γ ⊢ e1; e2:T
(while)
Γ ⊢ e1:bool
Γ ⊢ e2:unit
Γ ⊢ while e1 do e2:unit
(var) Γ ⊢ x :T if Γ(x ) = T
(fn)
Γ, x :T ⊢ e:T ′
Γ ⊢ fn x :T ⇒ e : T → T ′
(app) Γ ⊢ e1:T → T
′ Γ ⊢ e2:T
Γ ⊢ e1 e2:T ′
(let)
Γ ⊢ e1:T Γ, x :T ⊢ e2:T ′
Γ ⊢ let val x :T = e1 in e2 end:T ′
(let rec fn)
Γ, x :T1 → T2, y :T1 ⊢ e1:T2 Γ, x :T1 → T2 ⊢ e2:T
Γ ⊢ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end:T
84
4.7 Exercises
Exercise 20 ⋆What are the free variables of the following?
1. x + ((fn y:int⇒ z) 2)
2. x + (fn y:int⇒ z)
3. fn y:int⇒ fn y:int⇒ fn y:int⇒ y
4. !l0
5. while !l0 ≥ y do l0 := x
Draw their abstract syntax trees (up to alpha equivalence).
Exercise 21 ⋆What are the following?
1. {fn x:int⇒ y/z}fn y:int⇒ z y
2. {fn x:int⇒ x/x}fn y:int⇒ x y
3. {fn x:int⇒ x/x}fn x:int⇒ x x
Exercise 22 ⋆Give typing derivations, or show why no derivation exists, for:
1. if 6 then 7 else 8
2. fn x:int⇒ x + (fn x:bool⇒ if x then 3 else 4)true
Exercise 23 ⋆⋆Give a grammar for types, and typing rules for functions and application,
that allow only first-order functions and prohibit partial applications.
Exercise 24 ⋆⋆Write a function of type unit → bool that, when applied to skip, returns
true in the CBV semantics and false in the CBN semantics. Can you do it without using
the store?
Exercise 25 ⋆⋆Prove Lemma 7 (Substitution).
Exercise 26 ⋆⋆Prove Theorem 12 (Type Preservation).
Exercise 27 ⋆⋆Adapt the L2 implementation to CBN functions. Think of a few good test
cases and check them in the new and old code.
Exercise 28 ⋆⋆⋆Re-implement the L2 interpreter to use closures instead of substitution.
85
5 Data
Data – L3
So far we have only looked at very simple basic data types – int, bool, and unit, and functions
over them. We now explore more structured data, in as simple a form as possible, and revisit
the semantics of mutable store.
5.1 Products, Sums, and Records
The two basic notions are the product and the sum type.
The product type T1 ∗T2 lets you tuple together values of types T1 and T2 – so for example
a function that takes an integer and returns a pair of an integer and a boolean has type
int→ (int ∗ bool). In C one has structs; in Java classes can have many fields.
The sum type T1 + T2 lets you form a disjoint union, with a value of the sum type either
being a value of type T1 or a value of type T2. In C one has unions; in Java one might
have many subclasses of a class (see the l1.java representation of the L1 abstract syntax,
for example).
In most languages these appear in richer forms, e.g. with labelled records rather than simple
products, or labelled variants, or ML datatypes with named constructors, rather than simple
sums. We’ll look at labelled records in detail, as a preliminary to the later lecture on
subtyping.
Many languages don’t allow structured data types to appear in arbitrary positions – e.g. the
old C lack of support for functions that return structured values, inherited from close-to-
the-metal early implementations. They might therefore have to have functions or methods
that take a list of arguments, rather than a single argument that could be of product (or
sum, or record) type.
Products
T ::= ... | T1 ∗ T2
e ::= ... | (e1, e2) | #1 e | #2 e
Design choices:
• pairs, not arbitrary tuples – have int ∗ (int ∗ int) and (int ∗ int) ∗ int, but (a) they’re
different, and (b) we don’t have (int ∗ int ∗ int). In a full language you’d likely allow
(b) (and still have it be a different type from the other two).
• have projections #1 and #2, not pattern matching fn (x , y) ⇒ e. A full language
should allow the latter, as it often makes for much more elegant code.
• don’t have #e e ′ (couldn’t typecheck!).
86
Products - typing
(pair) Γ ⊢ e1:T1 Γ ⊢ e2:T2
Γ ⊢ (e1, e2):T1 ∗ T2
(proj1) Γ ⊢ e:T1 ∗ T2
Γ ⊢ #1 e:T1
(proj2) Γ ⊢ e:T1 ∗ T2
Γ ⊢ #2 e:T2
Products - reduction
v ::= ... | (v1, v2)
(pair1)
〈e1, s〉 −→ 〈e
′
1, s
′〉
〈(e1, e2), s〉 −→ 〈(e
′
1, e2), s
′〉
(pair2)
〈e2, s〉 −→ 〈e
′
2, s
′〉
〈(v1, e2), s〉 −→ 〈(v1, e
′
2), s
′〉
(proj1) 〈#1(v1, v2), s〉 −→ 〈v1, s〉 (proj2) 〈#2(v1, v2), s〉 −→ 〈v2, s〉
(proj3)
〈e, s〉 −→ 〈e ′, s ′〉
〈#1 e, s〉 −→ 〈#1 e ′, s ′〉
(proj4)
〈e, s〉 −→ 〈e ′, s ′〉
〈#2 e, s〉 −→ 〈#2 e ′, s ′〉
Again, have to choose evaluation strategy (CBV) and evaluation order (left-to-right, for
consistency).
Sums (or Variants, or Tagged Unions)
T ::= ... | T1 + T2
e ::= ... | inl e:T | inr e:T |
case e of inl (x1:T1)⇒ e1 | inr (x2:T2)⇒ e2
Those xs are binders.
Here we diverge slightly from Moscow ML syntax - our T1 + T2
corresponds to the Moscow ML (T1,T2) Sum in the context of the
declaration
datatype (’a,’b) Sum = inl of ’a | inr of ’b;
Sums - typing
(inl) Γ ⊢ e:T1
Γ ⊢ inl e:T1 + T2:T1 + T2
(inr) Γ ⊢ e:T2
Γ ⊢ inr e:T1 + T2:T1 + T2
(case)
Γ ⊢ e:T1 + T2
Γ, x :T1 ⊢ e1:T
Γ, y :T2 ⊢ e2:T
Γ ⊢ case e of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2:T
87
Why do we have these irritating type annotations? To maintain the unique
typing property, as otherwise
inl 3:int + int
and
inl 3:int + bool
You might:
• have a compiler use a type inference algorithm that can infer them.
• require every sum type in a program to be declared, each with different
names for the constructors inl , inr (cf OCaml).
• ...
Sums - reduction
v ::= ... | inl v :T | inr v :T
(inl)
〈e, s〉 −→ 〈e ′, s ′〉
〈inl e:T , s〉 −→ 〈inl e ′:T , s ′〉
(case1)
〈e, s〉 −→ 〈e ′, s ′〉
〈case e of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈case e ′ of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s ′〉
(case2) 〈case inl v :T of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈{v/x}e1, s〉
(inr) and (case3) like (inl) and (case2)
(inr)
〈e, s〉 −→ 〈e ′, s ′〉
〈inr e:T , s〉 −→ 〈inr e ′:T , s ′〉
(case3) 〈case inr v :T of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈{v/y}e2, s〉
Constructors and Destructors
type constructors destructors
T → T fn x :T ⇒ e
T ∗ T ( , ) #1 #2
T + T inl ( ) inr ( ) case
bool true false if
88
The Curry-Howard Isomorphism
(var) Γ, x :T ⊢ x :T
(fn)
Γ, x :T ⊢ e:T ′
Γ ⊢ fn x :T ⇒ e : T → T ′
(app)
Γ ⊢ e1:T → T ′ Γ ⊢ e2:T
Γ ⊢ e1 e2:T ′
(pair)
Γ ⊢ e1:T1 Γ ⊢ e2:T2
Γ ⊢ (e1, e2):T1 ∗ T2
(proj1)
Γ ⊢ e:T1 ∗ T2
Γ ⊢ #1 e:T1
(proj2)
Γ ⊢ e:T1 ∗ T2
Γ ⊢ #2 e:T2
(inl)
Γ ⊢ e:T1
Γ ⊢ inl e:T1 + T2:T1 + T2
(inr), (case), (unit), (zero), etc.. – but not (letrec)
Γ,P ⊢ P
Γ,P ⊢ P ′
Γ ⊢ P → P ′
Γ ⊢ P → P ′ Γ ⊢ P
Γ ⊢ P ′
Γ ⊢ P1 Γ ⊢ P2
Γ ⊢ P1 ∧ P2
Γ ⊢ P1 ∧ P2
Γ ⊢ P1
Γ ⊢ P1 ∧ P2
Γ ⊢ P2
Γ ⊢ P1
Γ ⊢ P1 ∨ P2
ML Datatypes
Datatypes in ML generalise both sums and products, in a sense
datatype IntList = Null of unit
| Cons of Int * IntList
is (roughly!) like saying
IntList = unit + (Int * IntList)
Note (a) this involves recursion at the type level (e.g. types for binary trees), (b) it introduces
constructors (Null and Cons) for each summand, and (c) it’s generative - two different
declarations of IntList will make different types. Making all that precise is beyond the
scope of this course.
Records
A mild generalisation of products that’ll be handy later.
Take field labels
Labels lab ∈ LAB for a set LAB = {p, q, ...}
T ::= ... | {lab1:T1, .., labk:Tk}
e ::= ... | {lab1 = e1, .., labk = ek} | #lab e
(where in each record (type or expression) no lab occurs more than once)
Note:
• The condition on record formation means that our syntax is no longer ‘free’. Formally,
we should have a well-formedness judgment on types.
• Labels are not the same syntactic class as variables, so (fn x:T ⇒ {x = 3}) is not an
expression.
• Does the order of fields matter? Can you use reuse labels in different record types?
The typing rules will fix an answer.
• In ML a pair (true, fn x:int⇒ x) is actually syntactic sugar for a record {1 = true, 2 =
fn x:int⇒ x}.
• Note that #lab e is not an application, it just looks like one in the concrete syntax.
• Again we will choose a left-to-right evaluation order for consistency.
89
Records - typing
(record) Γ ⊢ e1:T1 .. Γ ⊢ ek:Tk
Γ ⊢ {lab1 = e1, .., labk = ek}:{lab1:T1, .., labk:Tk}
(recordproj) Γ ⊢ e:{lab1:T1, .., labk:Tk}
Γ ⊢ #labi e:Ti
• Here the field order matters, so (fn x:{foo:int, bar :bool} ⇒ x){bar = true, foo = 17}
does not typecheck. In ML, though, the order doesn’t matter – so Moscow ML will
accept strictly more programs in this syntax than this type system allows.
• Here and in Moscow ML can reuse labels, so {} ⊢ ({foo = 17}, {foo = true}):{foo:int}∗
{foo:bool} is legal, but in some languages (e.g. OCaml) you can’t.
Records - reduction
v ::= ... | {lab1 = v1, .., labk = vk}
(record1)
〈ei, s〉 −→ 〈e ′i, s ′〉
〈{lab1 = v1, .., labi = ei, .., labk = ek}, s〉
−→ 〈{lab1 = v1, .., labi = e ′i, .., labk = ek}, s ′〉
(record2) 〈#labi {lab1 = v1, .., labk = vk}, s〉 −→ 〈vi, s〉
(record3)
〈e, s〉 −→ 〈e ′, s ′〉
〈#labi e, s〉 −→ 〈#labi e ′, s ′〉
5.2 Mutable Store
Mutable Store
Most languages have some kind of mutable store. Two main choices:
1 What we’ve got in L1 and L2:
e ::= ... | ℓ := e |!ℓ | x
• locations store mutable values
• variables refer to a previously-calculated value, immutably
• explicit dereferencing and assignment operators for locations
fn x:int⇒ l := (!l) + x
90
2 The C-way (also Java etc).
• variables let you refer to a previously calculated value and let you
overwrite that value with another.
• implicit dereferencing and assignment,
void foo(x:int) {
l = l + x
...}
• have some limited type machinery (const qualifiers) to limit
mutability.
– pros and cons: ....
References
Staying with 1 here. But, those L1/L2 references are very limited:
• can only store ints - for uniformity, would like to store any value
• cannot create new locations (all must exist at beginning)
• cannot write functions that abstract on locations fn l :intref ⇒!l
So, generalise.
T ::= ... | T ref
Tloc ::= intref T ref
e ::= ... | ℓ := e | !ℓ
| e1 := e2 |!e | ref e | ℓ
Have locations in the expression syntax, but that is just so we can express the intermediate
states of computations – whole programs now should have no locations in at the start, but
can create them with ref. They can have variables of T ref type, e.g.fn x:int ref ⇒!x.
References - Typing
(ref) Γ ⊢ e:T
Γ ⊢ ref e : T ref
(assign)
Γ ⊢ e1:T ref
Γ ⊢ e2:T
Γ ⊢ e1 := e2:unit
(deref) Γ ⊢ e:T ref
Γ ⊢!e:T
(loc) Γ(ℓ) = T ref
Γ ⊢ ℓ:T ref
91
References – Reduction
A location is a value:
v ::= ... | ℓ
Stores s were finite partial maps from L to Z. From now on, take them to
be finite partial maps from L to the set of all values.
(ref1) 〈 ref v , s〉 −→ 〈ℓ, s + {ℓ 7→ v}〉 ℓ /∈ dom(s)
(ref2)
〈e, s〉 −→ 〈e ′, s ′〉
〈 ref e, s〉 −→ 〈 ref e ′, s ′〉
(deref1) 〈!ℓ, s〉 −→ 〈v , s〉 if ℓ ∈ dom(s) and s(ℓ) = v
(deref2)
〈e, s〉 −→ 〈e ′, s ′〉
〈!e, s〉 −→ 〈!e ′, s ′〉
(assign1) 〈ℓ := v , s〉 −→ 〈skip, s + {ℓ 7→ v}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(assign3)
〈e, s〉 −→ 〈e ′, s ′〉
〈e := e2, s〉 −→ 〈e ′ := e2, s ′〉
• A ref has to do something at runtime – ( ref 0, ref 0) should return a pair of two new
locations, each containing 0, not a pair of one location repeated.
• Note the typing and this dynamics permit locations to contain locations, e.g. ref( ref 3).
• This semantics no longer has determinacy, for a technical reason – new locations are
chosen arbitrarily. At the cost of some slight semantic complexity, we could regain
determinacy by working ’up to alpha for locations’.
• What is the store:
1. an array of bytes,
2. an array of values, or
3. a partial function from locations to values?
We take the third, most abstract option. Within the language one cannot do arithmetic
on locations (just as well!) (can in C, can’t in Java) or test whether one is bigger than
another (in presence of garbage collection, they may not stay that way). Might or
might not even be able to test them for equality (can in ML, cannot in L3).
• This store just grows during computation – an implementation can garbage collect (in
many fancy ways), but platonic memory is free.
We don’t have an explicit deallocation operation – if you do, you need a very baroque
type system to prevent dangling pointers being dereferenced. We don’t have unini-
tialised locations (cf. null pointers), so don’t have to worry about dereferencing null.
92
Type-checking the store
For L1, our type properties used dom(Γ) ⊆ dom(s) to express the
condition ‘all locations mentioned in Γ exist in the store s ’.
Now need more: for each ℓ ∈ dom(s) need that s(ℓ) is typable.
Moreover, s(ℓ) might contain some other locations...
Type-checking the store – Example
Consider
e = let val x:(int→ int) ref = ref(fn z:int⇒ z) in
(x := (fn z:int⇒ if z ≥ 1 then z + ((!x) (z +−1)) else 0);
(!x) 3) end
which has reductions
〈e, {}〉 −→∗
〈e1, {l1 7→ (fn z:int⇒ z)}〉 −→∗
〈e2, {l1 7→ (fn z:int⇒ if z ≥ 1 then z + ((!l1) (z +−1)) else 0)}〉
−→∗ 〈6, ...〉
For reference, e1 and e2 are
e1 = l1 := (fn z:int⇒ if z ≥ 1 then z + ((!l1) (z +−1)) else 0);
((!l1) 3)
e2 = skip; ((!l1) 3)
Have made a recursive function by ‘tying the knot by hand’, not using let val rec .
To do this we needed to store function values – couldn’t do this in L2, so this doesn’t
contradict the normalisation theorem we had there.
So, say Γ ⊢ s if ∀ ℓ ∈ dom(s).∃ T .Γ(ℓ) = T ref ∧ Γ ⊢ s(ℓ):T .
The statement of type preservation will then be:
Theorem 14 (Type Preservation) If e closed and Γ ⊢ e:T and Γ ⊢ s
and 〈e, s〉 −→ 〈e ′, s ′〉 then for some Γ′ with disjoint domain to Γ we
have Γ, Γ′ ⊢ e ′:T and Γ, Γ′ ⊢ s ′.
Implementation
The collected definition so far is in the notes, called L3.
It is again a Moscow ML fragment (modulo the syntax for T + T ), so you
can run programs. The Moscow ML record typing is more liberal that that
of L3, though.
93
5.3 Evaluation Contexts
We end this chapter by showing a slightly different style for defining operational semantics,
collecting together many of the context rules into a single (eval) rule that uses a definition
of a set of evaluation contexts to describe where in your program the next step of reduction
can take place. This style becomes much more convenient for large languages, though for
L1 and L2 there’s not much advantage either way.
Evaluation Contexts
Define evaluation contexts
E ::= op e | v op | if then e else e |
; e |
e | v |
let val x :T = in e2 end |
( , e) | (v , ) | #1 | #2 |
inl :T | inr :T |
case of inl (x :T )⇒ e | inr (x :T )⇒ e |
{lab1 = v1, .., labi = , .., labk = ek} | #lab |
:= e | v := |! | ref
and have the single context rule
(eval)
〈e, s〉 −→ 〈e ′, s ′〉
〈E [e], s〉 −→ 〈E [e ′], s ′〉
replacing the rules (all those with≥ 1 premise) (op1), (op2), (seq2), (if3),
(app1), (app2), (let1), (pair1), (pair2), (proj3), (proj4), (inl), (inr), (case1),
(record1), (record3), (ref2), (deref2), (assign2), (assign3).
To (eval) we add all the computation rules (all the rest) (op + ), (op≥ ),
(seq1), (if1), (if2), (while), (fn), (let2), (letrecfn), (proj1), (proj2), (case2),
(case3), (record2), (ref1), (deref1), (assign1).
Theorem 15 The two definitions of−→ define the same relation.
A Little (Oversimplified!) History
Formal logic 1880–
Untyped lambda calculus 1930s
Simply-typed lambda calculus 1940s
Fortran 1950s
Curry-Howard, Algol 60, Algol 68, SECD machine (64) 1960s
Pascal, Polymorphism, ML, PLC 1970s
Structured Operational Semantics 1981–
Standard ML definition 1985
Haskell 1987
Subtyping 1980s
Module systems 1980–
Object calculus 1990–
Typed assembly and intermediate languages 1990–
And now? module systems, distribution, mobility, reasoning about objects, security, typed compilation,
approximate analyses,.......
94
5.4 L3: Collected Definition
L3 Syntax
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Variables x ∈ X for a set X = {x, y, z, ...}
Labels lab ∈ LAB for a set LAB = {p, q, ...}
Operations op ::= + |≥
Types:
T ::= int | bool | unit | T1 → T2|T1 ∗ T2|T1 + T2|{lab1:T1, .., labk:Tk}|T ref
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
e1 := e2 |!e | ref e | ℓ |
skip | e1; e2 |
while e1 do e2|
fn x :T ⇒ e | e1 e2 | x |
let val x :T = e1 in e2 end|
let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end|
(e1, e2) | #1 e | #2 e|
inl e:T | inr e:T |
case e of inl (x1:T1)⇒ e1 | inr (x2:T2)⇒ e2|
{lab1 = e1, .., labk = ek} | #lab e
(where in each record (type or expression) no lab occurs more than once)
In expressions fn x :T ⇒ e the x is a binder. In expressions let val x :T = e1 in e2 end
the x is a binder. In expressions let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
the y binds in e1; the x binds in (fn y :T ⇒ e1) and in e2. In case e of inl (x1:T1)⇒ e1 |
inr (x2:T2)⇒ e2 the x1 binds in e1 and the x2 binds in e2.
L3 Semantics
Stores s were finite partial maps from L to Z. From now on, take them to be finite partial
maps from L to the set of all values.
Values v ::= b | n | skip | fn x :T ⇒ e|(v1, v2)|inl v :T | inr v :T |{lab1 = v1, .., labk = vk}|ℓ
(op +) 〈n1 + n2, s〉 −→ 〈n, s〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s〉 −→ 〈b, s〉 if b = (n1 ≥ n2)
(op1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 op e2, s〉 −→ 〈e ′1 op e2, s ′〉
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
(seq1) 〈skip; e2, s〉 −→ 〈e2, s〉
(seq2)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1; e2, s〉 −→ 〈e ′1; e2, s ′〉
95
(if1) 〈if true then e2 else e3, s〉 −→ 〈e2, s〉
(if2) 〈if false then e2 else e3, s〉 −→ 〈e3, s〉
(if3)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈if e1 then e2 else e3, s〉 −→ 〈if e ′1 then e2 else e3, s ′〉
(while)
〈while e1 do e2, s〉 −→ 〈if e1 then (e2;while e1 do e2) else skip, s〉
(app1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(app2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v e2, s〉 −→ 〈v e ′2, s ′〉
(fn) 〈(fn x :T ⇒ e) v , s〉 −→ 〈{v/x}e, s〉
(let1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈let val x :T = e1 in e2 end, s〉 −→ 〈let val x :T = e ′1 in e2 end, s ′〉
(let2)
〈let val x :T = v in e2 end, s〉 −→ 〈{v/x}e2, s〉
(letrecfn) let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end
−→
{(fn y :T1 ⇒ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e1 end)/x}e2
(pair1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈(e1, e2), s〉 −→ 〈(e ′1, e2), s ′〉
(pair2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈(v1, e2), s〉 −→ 〈(v1, e ′2), s ′〉
(proj1) 〈#1(v1, v2), s〉 −→ 〈v1, s〉 (proj2) 〈#2(v1, v2), s〉 −→ 〈v2, s〉
(proj3)
〈e, s〉 −→ 〈e ′, s ′〉
〈#1 e, s〉 −→ 〈#1 e ′, s ′〉
(proj4)
〈e, s〉 −→ 〈e ′, s ′〉
〈#2 e, s〉 −→ 〈#2 e ′, s ′〉
(inl)
〈e, s〉 −→ 〈e ′, s ′〉
〈inl e:T , s〉 −→ 〈inl e ′:T , s ′〉
(case1)
〈e, s〉 −→ 〈e ′, s ′〉
〈case e of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈case e ′ of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s ′〉
(case2) 〈case inl v :T of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈{v/x}e1, s〉
(inr) and (case3) like (inl) and (case2)
96
(inr)
〈e, s〉 −→ 〈e ′, s ′〉
〈inr e:T , s〉 −→ 〈inr e ′:T , s ′〉
(case3) 〈case inr v :T of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2, s〉
−→ 〈{v/y}e2, s〉
(record1)
〈ei, s〉 −→ 〈e ′i, s ′〉
〈{lab1 = v1, .., labi = ei, .., labk = ek}, s〉
−→ 〈{lab1 = v1, .., labi = e ′i, .., labk = ek}, s ′〉
(record2) 〈#labi {lab1 = v1, .., labk = vk}, s〉 −→ 〈vi, s〉
(record3)
〈e, s〉 −→ 〈e ′, s ′〉
〈#labi e, s〉 −→ 〈#labi e ′, s ′〉
(ref1) 〈 ref v , s〉 −→ 〈ℓ, s + {ℓ 7→ v}〉 ℓ /∈ dom(s)
(ref2)
〈e, s〉 −→ 〈e ′, s ′〉
〈 ref e, s〉 −→ 〈 ref e ′, s ′〉
(deref1) 〈!ℓ, s〉 −→ 〈v , s〉 if ℓ ∈ dom(s) and s(ℓ) = v
(deref2)
〈e, s〉 −→ 〈e ′, s ′〉
〈!e, s〉 −→ 〈!e ′, s ′〉
(assign1) 〈ℓ := v , s〉 −→ 〈skip, s + {ℓ 7→ v}〉 if ℓ ∈ dom(s)
(assign2)
〈e, s〉 −→ 〈e ′, s ′〉
〈ℓ := e, s〉 −→ 〈ℓ := e ′, s ′〉
(assign3)
〈e, s〉 −→ 〈e ′, s ′〉
〈e := e2, s〉 −→ 〈e ′ := e2, s ′〉
L3 Typing
Take Γ ∈ TypeEnv2, the finite partial functions from L ∪ X to Tloc ∪ T such that
∀ ℓ ∈ dom(Γ).Γ(ℓ) ∈ Tloc
∀ x ∈ dom(Γ).Γ(x ) ∈ T
(int) Γ ⊢ n:int for n ∈ Z
(bool) Γ ⊢ b:bool for b ∈ {true, false}
(op +)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 + e2:int
(op ≥)
Γ ⊢ e1:int
Γ ⊢ e2:int
Γ ⊢ e1 ≥ e2:bool
(if)
Γ ⊢ e1:bool
Γ ⊢ e2:T
Γ ⊢ e3:T
Γ ⊢ if e1 then e2 else e3:T
97
(skip) Γ ⊢ skip:unit
(seq)
Γ ⊢ e1:unit
Γ ⊢ e2:T
Γ ⊢ e1; e2:T
(while)
Γ ⊢ e1:bool
Γ ⊢ e2:unit
Γ ⊢ while e1 do e2:unit
(var) Γ ⊢ x :T if Γ(x ) = T
(fn)
Γ, x :T ⊢ e:T ′
Γ ⊢ fn x :T ⇒ e : T → T ′
(app) Γ ⊢ e1:T → T
′ Γ ⊢ e2:T
Γ ⊢ e1 e2:T ′
(let)
Γ ⊢ e1:T Γ, x :T ⊢ e2:T ′
Γ ⊢ let val x :T = e1 in e2 end:T ′
(let rec fn)
Γ, x :T1 → T2, y :T1 ⊢ e1:T2 Γ, x :T1 → T2 ⊢ e2:T
Γ ⊢ let val rec x :T1 → T2 = (fn y :T1 ⇒ e1) in e2 end:T
(pair) Γ ⊢ e1:T1 Γ ⊢ e2:T2
Γ ⊢ (e1, e2):T1 ∗ T2
(proj1) Γ ⊢ e:T1 ∗ T2
Γ ⊢ #1 e:T1
(proj2) Γ ⊢ e:T1 ∗ T2
Γ ⊢ #2 e:T2
(inl) Γ ⊢ e:T1
Γ ⊢ inl e:T1 + T2:T1 + T2
(inr) Γ ⊢ e:T2
Γ ⊢ inr e:T1 + T2:T1 + T2
(case)
Γ ⊢ e:T1 + T2
Γ, x :T1 ⊢ e1:T
Γ, y :T2 ⊢ e2:T
Γ ⊢ case e of inl (x :T1)⇒ e1 | inr (y :T2)⇒ e2:T
(record) Γ ⊢ e1:T1 .. Γ ⊢ ek:Tk
Γ ⊢ {lab1 = e1, .., labk = ek}:{lab1:T1, .., labk:Tk}
(recordproj)
Γ ⊢ e:{lab1:T1, .., labk:Tk}
Γ ⊢ #labi e:Ti
98
(ref) Γ ⊢ e:T
Γ ⊢ ref e : T ref
(assign)
Γ ⊢ e1:T ref
Γ ⊢ e2:T
Γ ⊢ e1 := e2:unit
(deref) Γ ⊢ e:T ref
Γ ⊢!e:T
(loc)
Γ(ℓ) = T ref
Γ ⊢ ℓ:T ref
5.5 Exercises
Exercise 29 ⋆⋆Design abstract syntax, type rules and evaluation rules for labelled vari-
ants, analogously to the way in which records generalise products.
Exercise 30 ⋆⋆Design type rules and evaluation rules for ML-style exceptions. Start
with exceptions that do not carry any values. Hint 1: take care with nested handlers within
recursive functions. Hint 2: you might want to express your semantics using evaluation
contexts.
Exercise 31 ⋆⋆⋆Extend the L2 implementation to cover all of L3.
(assignment and while ) L11,2,3,4
(functions and recursive definitions) L25,6
Operational semantics
Type systems
Implementations
Language design choices
Inductive definitions
Inductive proof – structural; rule
Abstract syntax up to alpha
(products, sums, records, references) L38
Subtyping
and Objects9
uuuuuuuuu
Semantic
Equivalence11
0000000000000000000000
TAL10 Concurrency12
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
99
6 Subtyping and Objects
Subtyping and Objects
Our type systems so far would all be annoying to use, as they’re quite rigid (Pascal-like).
There is no support for code reuse (except for functions), so you would have to have different
sorting code for, e.g., int lists and int ∗ int lists.
Polymorphism
Ability to use expressions at many different types.
• Ad-hoc polymorphism (overloading).
e.g. in Moscow ML the built-in + can be used to add two integers or to
add two reals. (see Haskell type classes)
• Parametric Polymorphism – as in ML. See the Part II Types course.
can write a function that for any type α takes an argument of type
α list and computes its length (parametric - uniform in whatever α is)
• Subtype polymorphism – as in various OO languages. See here.
Dating back to the 1960s (Simula etc); formalised in 1980,1984,...
Subtyping – Motivation
Recall
(app)
Γ ⊢ e1:T → T ′
Γ ⊢ e2:T
Γ ⊢ e1 e2:T ′
so can’t type
6⊢ (fn x:{p:int} ⇒ #p x) {p = 3, q = 4} : int
even though we’re giving the function a better argument, with more
structure, than it needs.
100
Subsumption
‘Better’? Any value of type {p:int, q:int} can be used wherever a value
of type {p:int} is expected. (*)
Introduce a subtyping relation between types, written T <: T ′, read as
T is a subtype of T ′ (a T is useful in more contexts than a T ′ ).
Will define it on the next slides, but it will include
{p:int, q:int} <: {p:int} <: {}
Introduce a subsumption rule
(sub) Γ ⊢ e:T T <: T ′
Γ ⊢ e:T ′
allowing subtyping to be used, capturing (*).
Can then deduce {p = 3, q = 4}:{p:int}, hence can type the example.
Example
x:{p:int} ⊢ x:{p:int} (var)
x:{p:int} ⊢ #p x:int (record-proj)
{} ⊢ (fn x:{p:int} ⇒ #p x):{p:int} → int (fn)
{} ⊢ 3:int (var) {} ⊢ 4:int (var)
{} ⊢ {p = 3, q = 4}:{p:int, q:int} (record) (⋆)
{} ⊢ {p = 3, q = 4}:{p:int} (sub)
{} ⊢ (fn x:{p:int} ⇒ #p x){p = 3, q = 4}:int (app)
where (⋆) is {p:int, q:int} <: {p:int}
Now, how do we define the subtype relation? First:
The Subtype Relation T <: T ′
(s-refl)
T <: T
(s-trans) T <: T
′ T ′ <: T ′′
T <: T ′′
Now have to look at each type
Subtyping – Records
Forgetting fields on the right:
{lab1:T1, .., labk:Tk, labk+1:Tk+1, .., labk+k′ :Tk+k′}
<: (s-record-width)
{lab1:T1, .., labk:Tk}
Allowing subtyping within fields:
(s-record-depth)
T1 <: T
′
1 .. Tk <: T
′
k
{lab1:T1, .., labk:Tk} <: {lab1:T ′1, .., labk:T ′k}
Combining these:
{p:int, q:int} <: {p:int}
(s-record-width)
{r:int} <: {}
(s-record-width)
{x:{p:int, q:int}, y:{r:int}} <: {x:{p:int}, y:{}}
(s-record-depth)
101
Another example:
{x:{p:int, q:int}, y:{r:int}} <: {x:{p:int, q:int}} (s-record-width)
{p:int, q:int} <: {p:int} (s-record-width)
{x:{p:int, q:int}} <: {x:{p:int}} (s-record-depth)
{x:{p:int, q:int}, y:{r:int}} <: {x:{p:int}} (s-trans)
Allowing reordering of fields:
(s-record-order)
π a permutation of 1, .., k
{lab1:T1, .., labk:Tk} <: {labπ(1):Tπ(1), .., labπ(k):Tπ(k)}
(the subtype order is not anti-symmetric – it is a preorder, not a partial
order)
Subtyping - Functions
(s-fn)
T ′1 <: T1 T2 <: T
′
2
T1 → T2 <: T ′1 → T ′2
contravariant on the left of→
covariant on the right of→ (like (s-record-depth))
If f :T1 → T2 then we can give f any argument which is a subtype of
T1; we can regard the result of f as any supertype of T2. e.g., for
f = fn x:{p:int} ⇒ {p = #p x, q = 28}
we have
{} ⊢ f :{p:int} → {p:int, q:int}
{} ⊢ f :{p:int} → {p:int}
{} ⊢ f :{p:int, q:int} → {p:int, q:int}
{} ⊢ f :{p:int, q:int} → {p:int}
as
{p:int, q:int} <: {p:int}
On the other hand, for
fn x:{p:int, q:int} ⇒ {p = (#p x) + (#q x)}
we have
{} ⊢ f :{p:int, q:int} → {p:int}
{} 6⊢ f :{p:int} → T for any T
{} 6⊢ f :T → {p:int, q:int} for any T
Subtyping – Products
Just like (s-record-depth)
(s-pair)
T1 <: T
′
1 T2 <: T
′
2
T1 ∗ T2 <: T ′1 ∗ T ′2
Subtyping – Sums
Exercise.
102
Subtyping – References
Are either of these any good?
T <: T ′
T ref <: T ′ ref
T ′ <: T
T ref <: T ′ ref
No...
Semantics
No change (note that we’ve not changed the expression grammar).
Properties
Have Type Preservation and Progress.
Implementation
Type inference is more subtle, as the rules are no longer syntax-directed.
Getting a good runtime implementation is also tricky, especially with field
re-ordering.
Subtyping – Down-casts
The subsumption rule (sub) permits up-casting at any point. How about
down-casting? We could add
e ::= ... | (T )e
with typing rule
Γ ⊢ e:T ′
Γ ⊢ (T )e:T
then you need a dynamic type-check...
This gives flexibility, but at the cost of many potential run-time errors.
Many uses might be better handled by Parametric Polymorphism, aka
Generics. (cf. work by Martin Odersky at EPFL, Lausanne, now in Java
1.5)
The following development is taken from [Pierce, Chapter 18], where you can find more
details (including a treatment of self and a direct semantics for a ‘featherweight’ fragment
of Java).
(Very Simple) Objects
let val c:{get:unit→ int, inc:unit→ unit} =
let val x:int ref = ref 0 in
{get = fn y:unit⇒!x,
inc = fn y:unit⇒ x := 1+!x}
end
in
(#inc c)(); (#get c)()
end
Counter = {get:unit→ int, inc:unit→ unit}.
103
Using Subtyping
let val c:{get:unit→ int, inc:unit→ unit, reset:unit→ unit} =
let val x:int ref = ref 0 in
{get = fn y:unit⇒!x,
inc = fn y:unit⇒ x := 1+!x,
reset = fn y:unit⇒ x := 0}
end
in
(#inc c)(); (#get c)()
end
ResetCounter = {get:unit → int, inc:unit → unit, reset:unit → unit}
<: Counter = {get:unit → int, inc:unit → unit}.
Object Generators
let val newCounter:unit→ {get:unit→ int, inc:unit→ unit} =
fn y:unit⇒
let val x:int ref = ref 0 in
{get = fn y:unit⇒!x,
inc = fn y:unit⇒ x := 1+!x}
end
in
(#inc (newCounter ())) ()
end
and onwards to simple classes...
Reusing Method Code (Simple Classes)
Recall Counter = {get:unit→ int, inc:unit→ unit}.
First, make the internal state into a record.
CounterRep = {p:int ref}.
let val counterClass:CounterRep → Counter =
fn x:CounterRep ⇒
{get = fn y:unit⇒!(#p x),
inc = fn y:unit⇒ (#p x) := 1+!(#p x)}
let val newCounter:unit→ Counter =
fn y:unit⇒
let val x:CounterRep = {p = ref 0} in
counterClass x
104
Reusing Method Code (Simple Classes)
let val resetCounterClass:CounterRep → ResetCounter =
fn x:CounterRep ⇒
let val super = counterClass x in
{get = #get super,
inc = #inc super,
reset = fn y:unit⇒ (#p x) := 0}
CounterRep = {p:int ref}.
Counter = {get:unit→ int, inc:unit→ unit}.
ResetCounter = {get:unit→ int, inc:unit→ unit, reset:unit→
unit}.
Reusing Method Code (Simple Classes)
class Counter
{ protected int p;
Counter() { this.p=0; }
int get () { return this.p; }
void inc () { this.p++ ; }
};
class ResetCounter
extends Counter
{ void reset () {this.p=0;}
};
Subtyping – Structural vs Named
A′ = {} with {p:int}
A′′ = A′ with {q:bool}
A′′′ = A′ with {r:int}
{}
{p:int}
{p:int, q:bool}
nnnnnn
{p:int, r:int}
OOOOOO
Object (ish!)
A′
A′′
qqqqqqq
A′′
MMMMMMM
6.1 Exercises
Exercise 32 ⋆For each of the following, either give a type derivation or explain why it is
untypable.
1. {} ⊢ {p = {p = {p = {p = 3}}}}:{p:{}}
2. {} ⊢ fn x:{p:bool, q:{p:int, q:bool}} ⇒ #q #p x : ?
3. {} ⊢ fn f:{p:int} → int⇒ (f {q = 3}) + (f {p = 4}) : ?
4. {} ⊢ fn f:{p:int} → int⇒ (f {q = 3,p = 2}) + (f {p = 4}) : ?
105
Exercise 33 ⋆For each of the two bogus T ref subtype rules on Page 6, give an example
program that is typable with that rule but gets stuck at runtime.
Exercise 34 ⋆⋆What should the subtype rules for sums T + T ′ be?
Exercise 35 ⋆⋆...and for let and let rec ?
106
7 Semantic Equivalence
Semantic Equivalence
2 + 2
?≃ 4
In what sense are these two expressions the same?
They have different abstract syntax trees.
They have different reduction sequences.
But, you’d hope that in any program you could replace one by the other
without affecting the result....
∫ 2+2
0
esin(x)dx =
∫ 4
0
esin(x)dx
How about (l := 0; 4)
?≃ (l := 1; 3+!l)
They will produce the same result (in any store), but you cannot replace
one by the other in an arbitrary program context. For example:
C [ ] = +!l
C [l := 0; 4] = (l := 0; 4)+!l
6≃
C [l := 1; 3+!l ] = (l := 1; 3+!l)+!l
On the other hand, consider
(l :=!l + 1); (l :=!l − 1) ?≃ (l :=!l)
Those were all particular expressions – may want to know that some
general laws are valid for all e1, e2, .... How about these:
e1; (e2; e3)
?≃ (e1; e2); e3
(if e1 then e2 else e3); e
?≃ if e1 then e2; e else e3; e
e; (if e1 then e2 else e3)
?≃ if e1 then e; e2 else e; e3
e; (if e1 then e2 else e3)
?≃ if e; e1 then e2 else e3
let val x = ref 0 in fn y:int⇒ (x :=!x + y); !x
?≃
let val x = ref 0 in fn y:int⇒ (x :=!x− y); (0−!x)
107
Temporarily extend L3 with pointer equality
op ::= ... |=
(op =)
Γ ⊢ e1:T ref
Γ ⊢ e2:T ref
Γ ⊢ e1 = e2:bool
(op =) 〈ℓ = ℓ′, s〉 −→ 〈b, s〉 if b = (ℓ = ℓ′)
f = let val x = ref 0 in
let val y = ref 0 in
fn z:int ref ⇒ if z = x then y else x
g = let val x = ref 0 in
let val y = ref 0 in
fn z:int ref ⇒ if z = y then y else x
f
?≃ g
The last two examples are taken from A.M. Pitts, Operational Semantics and Program
Equivalence. In: G. Barthe, P. Dybjer and J. Saraiva (Eds), Applied Semantics. Lecture
Notes in Computer Science, Tutorial, Volume 2395 (Springer-Verlag, 2002), pages 378-412.
(Revised version of lectures at the International Summer School On Applied Semantics,
APPSEM 2000, Caminha, Minho, Portugal, 9-15 September 2000.) ftp://ftp.cl.cam.
ac.uk/papers/amp12/opespe-lncs.pdf
With a ‘good’ notion of semantic equivalence, we might:
1. prove that some particular expression (say an efficient algorithm) is
equivalent to another (say a clear specification)
2. prove the soundness of general laws for equational reasoning about
programs
3. prove some compiler optimisations are sound (source/IL/TAL)
4. understand the differences between languages
108
What does it mean for≃ to be ‘good’?
1. programs that result in observably-different values (in some initial
store) must not be equivalent
(∃ s , s1, s2, v1, v2.〈e1, s〉 −→∗ 〈v1, s1〉 ∧ 〈e2, s〉 −→∗ 〈v2, s2〉
∧ v1 6= v2)⇒ e1 6≃ e2
2. programs that terminate must not be equivalent to programs that don’t
3. ≃ must be an equivalence relation
e ≃ e , e1 ≃ e2 ⇒ e2 ≃ e1, e1 ≃ e2 ≃ e3 =⇒ e1 ≃ e3
4. ≃ must be a congruence
if e1 ≃ e2 then for any context C we must have C [e1] ≃ C [e2]
5. ≃ should relate as many programs as possible subject to the above.
Semantic Equivalence for L1
Consider Typed L1 again.
Define e1 ≃TΓ e2 to hold iff forall s such that dom(Γ) ⊆ dom(s), we
have Γ ⊢ e1:T , Γ ⊢ e2:T , and either
(a) 〈e1, s〉 −→ω and 〈e2, s〉 −→ω, or
(b) for some v , s ′ we have 〈e1, s〉 −→∗ 〈v , s ′〉 and
〈e2, s〉 −→∗ 〈v , s ′〉.
If T = unit then C = ; !l .
If T = bool then C = if then !l else !l .
If T = int then C = l1 := ; !l .
Congruence for Typed L1
The L1 contexts are:
C ::= op e2 | e1 op |
if then e2 else e3 | if e1 then else e3 | if e1 then e2 else |
ℓ := |
; e2 | e1; |
while do e2 | while e1 do
Say≃TΓ has the congruence property if whenever e1 ≃TΓ e2 we have,
for all C and T ′, if Γ ⊢ C [e1]:T ′ and Γ ⊢ C [e2]:T ′ then
C [e1] ≃T ′Γ C [e2].
109
Theorem 16 (Congruence for L1) ≃TΓ has the congruence property.
Proof Outline By case analysis, looking at each L1 context C in turn.
For each C (and for arbitrary e and s ), consider the possible reduction
sequences
〈C [e], s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉 −→ ...
For each such reduction sequence, deduce what behaviour of e was
involved
〈e, s〉 −→ 〈ê1, ŝ1〉 −→ ...
Using e ≃TΓ e ′ find a similar reduction sequence of e ′.
Using the reduction rules construct a sequence of C [e ′].
Theorem 16 (Congruence for L1)≃TΓ has the congruence property.
By case analysis, looking at each L1 context in turn.
Case C = (ℓ := ). Suppose e ≃TΓ e ′, Γ ⊢ ℓ := e:T ′ and
Γ ⊢ ℓ := e ′:T ′. By examining the typing rules T = int and
T ′ = unit.
To show (ℓ := e) ≃T ′Γ (ℓ := e ′) we have to show for all s such that
dom(Γ) ⊆ dom(s), then Γ ⊢ ℓ := e:T ′ (√), Γ ⊢ ℓ := e ′:T ′ (√),
and either
1. 〈ℓ := e, s〉 −→ω and 〈ℓ := e ′, s〉 −→ω, or
2. for some v , s ′ we have 〈ℓ := e, s〉 −→∗ 〈v , s ′〉 and
〈ℓ := e ′, s〉 −→∗ 〈v , s ′〉.
Consider the possible reduction sequences of a state 〈ℓ := e, s〉. Either:
Case: 〈ℓ := e, s〉 −→ω, i.e.
〈ℓ := e, s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉 −→ ...
hence all these must be instances of (assign2), with
〈e, s〉 −→ 〈ê1, s1〉 −→ 〈ê2, s2〉 −→ ...
and e1 = (ℓ := ê1), e2 = (ℓ := ê2),...
Case: ¬(〈ℓ := e, s〉 −→ω), i.e.
〈ℓ := e, s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉... −→ 〈ek, sk〉 6−→
hence all these must be instances of (assign2) except the last, which
must be an instance of (assign1), with
〈e, s〉 −→ 〈ê1, s1〉 −→ 〈ê2, s2〉 −→ ... −→ 〈êk−1, sk−1〉
and e1 = (ℓ := ê1), e2 = (ℓ := ê2),..., ek−1 = (ℓ := êk−1) and for
some n we have êk−1 = n , ek = skip, and sk = sk−1 + {ℓ 7→ n}.
(the other possibility, of zero or more (assign1) reductions ending in a stuck state, is excluded
by Theorems 2 and 3 (type preservation and progress))
110
Now, if 〈ℓ := e, s〉 −→ω we have 〈e, s〉 −→ω, so by e ≃TΓ e ′ we
have 〈e ′, s〉 −→ω, so (using (assign2)) we have 〈ℓ := e ′, s〉 −→ω.
On the other hand, if ¬(〈ℓ := e, s〉 −→ω) then by the above there is
some n and sk−1 such that 〈e, s〉 −→∗ 〈n, sk−1〉 and
〈ℓ := e, s〉 −→ 〈skip, sk−1 + {ℓ 7→ n}〉.
By e ≃TΓ e ′ we have 〈e ′, s〉 −→∗ 〈n, sk−1〉.
Then using (assign1)
〈ℓ := e ′, s〉 −→∗ 〈ℓ := n, sk−1〉 −→ 〈skip, sk−1 + {ℓ 7→ n}〉 =
〈ek, sk〉 as required.
Theorem 16 (Congruence for L1) ≃TΓ has the congruence property.
Proof By case analysis, looking at each L1 context in turn. We give only one case here,
leaving the others for the reader.
Case C = (ℓ := ). Suppose e ≃TΓ e ′, Γ ⊢ ℓ := e:T ′ and Γ ⊢ ℓ := e ′:T ′. By
examining the typing rules we have T = int and T ′ = unit.
To show ℓ := e ≃T ′Γ ℓ := e ′ we have to show for all s such that dom(Γ) ⊆ dom(s),
then Γ ⊢ ℓ := e:T ′ (√), Γ ⊢ ℓ := e ′:T ′ (√), and either
1. 〈ℓ := e, s〉 −→ω and 〈ℓ := e ′, s〉 −→ω, or
2. for some v , s ′ we have 〈ℓ := e, s〉 −→∗ 〈v , s ′〉 and 〈ℓ := e ′, s〉 −→∗ 〈v , s ′〉.
Consider the possible reduction sequences of a state 〈ℓ := e, s〉. Recall that (by
examining the reduction rules), if 〈ℓ := e, s〉 −→ 〈e1, s1〉 then either that is an
instance of (assign1), with ∃ n.e = n ∧ ℓ ∈ dom(s)∧ e1 = skip∧ s ′ = s +{ℓ 7→ n},
or it is an instance of (assign2), with ∃ ê1.〈e, s〉 −→ 〈ê1, s1〉 ∧ e1 = (ℓ := ê1). We
know also that 〈skip, s〉 does not reduce.
Now (using Determinacy), for any e and s we have either
Case: 〈ℓ := e, s〉 −→ω, i.e.
〈ℓ := e, s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉 −→ ...
hence all these must be instances of (assign2), with
〈e, s〉 −→ 〈ê1, s1〉 −→ 〈ê2, s2〉 −→ ...
and e1 = (ℓ := ê1), e2 = (ℓ := ê2),...
Case: ¬(〈ℓ := e, s〉 −→ω), i.e.
〈ℓ := e, s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉... −→ 〈ek, sk〉 6−→
hence all these must be instances of (assign2) except the last, which must be
an instance of (assign1), with
〈e, s〉 −→ 〈ê1, s1〉 −→ 〈ê2, s2〉 −→ ... −→ 〈êk−1, sk−1〉
and e1 = (ℓ := ê1), e2 = (ℓ := ê2),..., ek−1 = (ℓ := êk−1) and for some n we
have êk−1 = n, ek = skip, and sk = sk−1 + {ℓ 7→ n}.
(the other possibility, of zero or more (assign1) reductions ending in a stuck
state, is excluded by Theorems 2 and 3 (type preservation and progress))
Now, if 〈ℓ := e, s〉 −→ω, by the above there is an infinite reduction sequence for
〈e, s〉, so by e ≃TΓ e ′ there is an infinite reduction sequence of 〈e ′, s〉, so (using
(assign2)) there is an infinite reduction sequence of 〈ℓ := e ′, s〉.
On the other hand, if ¬(〈ℓ := e, s〉 −→ω) then by the above there is some n and
sk−1 such that 〈e, s〉 −→∗ 〈n, sk−1〉 and 〈ℓ := e, s〉 −→ 〈skip, sk−1 + {ℓ 7→ n}〉.
111
By e ≃TΓ e ′ we have 〈e ′, s〉 −→∗ 〈n, sk−1〉. Then using (assign1) 〈ℓ := e ′, s〉 −→∗
〈ℓ := n, sk−1〉 −→ 〈skip, sk−1 + {ℓ 7→ n} = 〈ek, sk〉 as required.

Back to the Examples
We defined e1 ≃TΓ e2 iff forall s such that dom(Γ) ⊆ dom(s), we have
Γ ⊢ e1:T , Γ ⊢ e2:T , and either
1. 〈e1, s〉 −→ω and 〈e2, s〉 −→ω, or
2. for some v , s ′ we have 〈e1, s〉 −→∗ 〈v , s ′〉 and
〈e2, s〉 −→∗ 〈v , s ′〉.
So:
2 + 2 ≃intΓ 4 for any Γ
(l := 0; 4) 6≃intΓ (l := 1; 3+!l) for any Γ
(l :=!l + 1); (l :=!l − 1) ≃unitΓ (l :=!l) for any Γ including l :intref
And the general laws?
Conjecture 1 e1; (e2; e3) ≃TΓ (e1; e2); e3 for any Γ, T , e1, e2 and e3
such that Γ ⊢ e1:unit, Γ ⊢ e2:unit, and Γ ⊢ e3:T
Conjecture 2
((if e1 then e2 else e3); e) ≃TΓ (if e1 then e2; e else e3; e) for
any Γ, T , e , e1, e2 and e3 such that Γ ⊢ e1:bool, Γ ⊢ e2:unit,
Γ ⊢ e3:unit, and Γ ⊢ e:T
Conjecture 3
(e; (if e1 then e2 else e3)) ≃TΓ (if e1 then e; e2 else e; e3) for
any Γ, T , e , e1, e2 and e3 such that Γ ⊢ e:unit, Γ ⊢ e1:bool,
Γ ⊢ e2:T , and Γ ⊢ e3:T
Q: Is a typed expression Γ ⊢ e:T , e.g.
l :intref ⊢ if !l ≥ 0 then skip else (skip; l := 0):unit:
1. a list of characters [‘i’, ‘f’, ‘ ’, ‘!’, ‘l’, ..];
2. a list of tokens [ IF, DEREF, LOC "l", GTEQ, ..];
3. an abstract syntax tree if then else
≥
uuu
skip ;
KKK
!l

0 skip l :=
BB
0
;
4. the function taking store s to the reduction sequence
〈e, s〉 −→ 〈e1, s1〉 −→ 〈e2, s2〉 −→ ...; or
5. • the equivalence class {e ′ | e ≃TΓ e ′}
• the partial function [[e]]Γ that takes any store s with
dom(s) = dom(Γ) and either is undefined, if 〈e, s〉 −→ω, or is
〈v , s ′〉, if 〈e, s〉 −→∗ 〈v , s ′〉
(the Determinacy theorem tells us that this is a definition of a function).
Suppose Γ ⊢ e1:unit and Γ ⊢ e2:unit.
When is e1; e2 ≃unitΓ e2; e1 ?
A sufficient condition: they don’t mention any locations (but not necessary... e.g. if e1 does
but e2 doesn’t)
112
A weaker sufficient condition: they don’t mention any of the same locations. (but not
necessary... e.g. if they both just read l)
An even weaker sufficient condition: we can regard each expression as a partial function
over stores with domain dom(Γ). Say [[ei]]Γ is the function that takes a store s with
dom(s) = dom(Γ) and either is undefined, if 〈ei, s〉 −→ω, or is s ′, if 〈ei, s〉 −→∗ 〈(), s ′〉
(the Determinacy theorem tells us that this is a definition of a function).
For each location ℓ in dom(Γ), say ei semantically depends on ℓ if there exists s, n such that
[[ei]]Γ(s) 6= [[ei]]Γ(s + {ℓ 7→ n})). (note this is much weaker than “ei contains an dereference
of ℓ”)
Say ei semantically affects ℓ if there exists s such that s(ℓ) 6= [[ei]]Γ(s)(ℓ). (note this is much
weaker than “ei contains an assignment to ℓ”)
Now e1; e2 ≃unitΓ e2; e1 if there is no ℓ that is depended on by one ei and affected by the
other.
(sill not necessary...?)
7.1 Exercises
Exercise 36 ⋆⋆Prove some of the other cases of the Congruence theorem.
8 Concurrency
Concurrency
Our focus so far has been on semantics for sequential computation. But
the world is not sequential...
• hardware is intrinsically parallel (fine-grain, across words, to
coarse-grain, e.g. multiple execution units)
• multi-processor machines
• multi-threading (perhaps on a single processor)
• networked machines
113
Problems
• the state-spaces of our systems become large, with the combinatorial
explosion – with n threads, each of which can be in 2 states, the
system has 2n states.
• the state-spaces become complex
• computation becomes nondeterministic (unless synchrony is
imposed), as different threads/machines/... operate at different
speeds.
• parallel components competing for access to resources may deadlock
or suffer starvation. Need mutual exclusion between components
accessing a resource.
More Problems!
• partial failure (of some processes, of some machines in a network, of
some persistent storage devices). Need transactional mechanisms.
• communication between different environments (with different local
resources (e.g. different local stores, or libraries, or...)
• partial version change
• communication between administrative regions with partial trust (or,
indeed, no trust); protection against mailicious attack.
• dealing with contingent complexity (embedded historical accidents;
upwards-compatible deltas)
Theme: as for sequential languages, but much more so, it’s a complicated
world.
Aim of this lecture: just to give you a taste of how a little semantics can
be used to express some of the fine distinctions. Primarily (1) to boost
your intuition for informal reasoning, but also (2) this can support rigorous
proof about really hairy crypto protocols, cache-coherency protocols,
comms, database transactions,....
Going to define the simplest possible (well, almost) concurrent language,
call it L1, and explore a few issues. You’ve seen most of them informally
in CSAA.
114
Booleans b ∈ B = {true, false}
Integers n ∈ Z = {...,−1, 0, 1, ...}
Locations ℓ ∈ L = {l , l0, l1, l2, ...}
Operations op ::= + |≥
Expressions
e ::= n | b | e1 op e2 | if e1 then e2 else e3 |
ℓ := e |!ℓ |
skip | e1; e2 |
while e1 do e2|
e1 e2
T ::= int | bool | unit | proc
Tloc ::= intref
Parallel Composition: Typing and Reduction
(thread) Γ ⊢ e:unit
Γ ⊢ e:proc
(parallel) Γ ⊢ e1:proc Γ ⊢ e2:proc
Γ ⊢ e1 e2:proc
(parallel1)
〈e1, s〉 −→ 〈e ′1, s ′〉
〈e1 e2, s〉 −→ 〈e ′1 e2, s ′〉
(parallel2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈e1 e2, s〉 −→ 〈e1 e ′2, s ′〉
Parallel Composition: Design Choices
• threads don’t return a value
• threads don’t have an identity
• termination of a thread cannot be observed within the language
• threads aren’t partitioned into ‘processes’ or machines
• threads can’t be killed externally
Threads execute asynchronously – the semantics allows any interleaving
of the reductions of the threads.
All threads can read and write the shared memory.
〈() l := 2, {l 7→ 1}〉 // 〈() (), {l 7→ 2}〉
〈l := 1 l := 2, {l 7→ 0}〉
44jjjjjjjjjjjjjjj
**TTT
TTT
TTT
TTT
TTT
〈l := 1 (), {l 7→ 2}〉 // 〈() (), {l 7→ 1}〉
115
But, assignments and dereferencing are atomic. For example,
〈l := 3498734590879238429384 | l := 7, {l 7→ 0}〉
will reduce to a state with l either 3498734590879238429384 or 7, not
something with the first word of one and the second word of the other.
Implement?
But but, in (l := e) e ′, the steps of evaluating e and e ′ can be
interleaved.
Think of (l := 1+!l) (l := 7+!l) – there are races....
The behaviour of (l := 1+!l) (l := 7+!l) for the initial store {l 7→ 0}:
〈() (l := 7+!l), {l 7→ 1}〉
r // •
+ // • w // 〈() (), {l 7→ 8}〉
〈(l := 1) (l := 7+!l), {l 7→ 0}〉
r
))SSS
SSS
SSS
SSS
SS
w
55kkkkkkkkkkkkkk
〈() (l := 7 + 0), {l 7→ 1}〉
+
))RR
RRR
RRR
RRR
RR
〈(l := 1 + 0) (l := 7+!l), {l 7→ 0}〉
r
''OO
OOO
OOO
OOO
+
77ooooooooooo
〈(l := 1) (l := 7 + 0), {l 7→ 0}〉
+
))SSS
SSS
SSS
SSS
SS
w
55kkkkkkkkkkkkkk
〈() (l := 7), {l 7→ 1}〉
w // 〈() (), {l 7→ 7}〉
〈(l := 1+!l) (l := 7+!l), {l 7→ 0}〉
r
77ooooooooooo
r
''OO
OOO
OOO
OOO
〈(l := 1 + 0) (l := 7 + 0), {l 7→ 0}〉
+
55kkkkkkkkkkkkkk
+
))SSS
SSS
SSS
SSS
SS
〈(l := 1) (l := 7), {l 7→ 0}〉
w
55lllllllllllll
w
))RR
RRR
RRR
RRR
RR
〈(l := 1+!l) (l := 7 + 0), {l 7→ 0}〉
r
77ooooooooooo
+
''OO
OOO
OOO
OOO
〈(l := 1 + 0) (l := 7), {l 7→ 0}〉
+
55kkkkkkkkkkkkkk
w
))SSS
SSS
SSS
SSS
SS
〈l := 1 (), {l 7→ 7}〉
w // 〈() (), {l 7→ 1}〉
〈(l := 1+!l) (l := 7), {l 7→ 0}〉
r
55kkkkkkkkkkkkkk
w
))SSS
SSS
SSS
SSS
SS
〈l := 1 + 0 (), {l 7→ 7}〉
+
55lllllllllllll
〈l := 1+!l (), {l 7→ 7}〉
r // •
+ // • w // 〈() (), {l 7→ 8}〉
Note that the labels +, w and r in this picture are just informal hints as to how those
transitions were derived – they are not actually part of the reduction relation.
Some of the nondeterministic choices “don’t matter”, as you can get back to the same state.
Others do...
Morals
• There really is a combinatorial explosion – and you don’t want to be
standing next to it...
• Drawing state-space diagrams only works for really tiny examples – we
need better techniques for analysis.
• Almost certainly you (as the programmer) didn’t want all those 3
outcomes to be possible – need better idioms or constructs for
programming.
So, how do we get anything coherent done?
Need some way(s) to synchronise between threads, so can enforce
mutual exclusion for shared data.
cf. Lamport’s “Bakery” algorithm from Concurrent Systems and
Applications. Can you code that in L1? If not, what’s the smallest
extension required?
Usually, though, you can depend on built-in support from the scheduler,
e.g. for mutexes and condition variables (or, at a lower level, tas or
cas).
See this – in the library – for a good discussion of mutexes and condition variables: A. Birrell,
J. Guttag, J. Horning, and R. Levin. Thread synchronization: a Formal Specification. In G.
Nelson, editor, System Programming with Modula-3, chapter 5, pages 119-129. Prentice-
Hall, 1991.
See N. Lynch. Distributed Algorithms for other mutual exclusion algorithms (and much else
besides).
116
Consider simple mutexes, with commands to lock an unlocked mutex and to unlock a locked
mutex (and do nothing for an unlock of an unlocked mutex).
Adding Primitive Mutexes
Mutex names m ∈ M = {m, m1, ...}
Configurations 〈e, s ,M 〉 where M :M→ B is the mutex state
Expressions e ::= ... | lock m | unlock m
(lock)
Γ ⊢ lock m:unit
(unlock)
Γ ⊢ unlock m:unit
(lock) 〈lock m, s ,M 〉 −→ 〈(), s ,M + {m 7→ true}〉 if ¬M (m)
(unlock) 〈unlock m, s ,M 〉 −→ 〈(), s ,M + {m 7→ false}〉
Note that (lock) atomically (a) checks the mutex is currently false, (b) changes its state,
and (c) lets the thread proceed.
Also, there is no record of which thread is holding a locked mutex.
Need to adapt all the other semantic rules to carry the mutex state M
around. For example, replace
(op2)
〈e2, s〉 −→ 〈e ′2, s ′〉
〈v op e2, s〉 −→ 〈v op e ′2, s ′〉
by
(op2)
〈e2, s ,M 〉 −→ 〈e ′2, s ′,M ′〉
〈v op e2, s ,M 〉 −→ 〈v op e ′2, s ′,M ′〉
(note, the M and s must behave the same wrt evaluation order).
Using a Mutex
Consider
e = (lock m; l := 1+!l ; unlock m) (lock m; l := 7+!l ; unlock m)
The behaviour of 〈e, s ,M 〉, with the initial store s = {l 7→ 0} and initial
mutex state M0 = λm ∈ M.false, is:
〈(l := 1+!l ; unlock m) (lock m; l := 7+!l ; unlock m), s,M ′〉
12
**UUU
UUUU
UUUU
UUUU
UU
〈e, s,M0〉
lock m
55jjjjjjjjjjjjjjj
lock m
))TTT
TTT
TTT
TTT
TTT
〈() (), {l 7→ 8},M 〉
〈(lock m; l := 1+!l ; unlock m) (l := 7+!l ; unlock m), s,M ′〉
12
44iiiiiiiiiiiiiiiii
(where M ′ = M0 + {m 7→ true})
In all the intervening states (until the first unlock ) the second lock can’t proceed.
Look back to behaviour of the program without mutexes. We’ve essentially cut down to the
top and bottom paths (and also added some extra reductions for lock , unlock , and ;).
In this example, l := 1+!l and l := 7+!l commute, so we end up in the same final state
whichever got the lock first. In general, that won’t be the case.
On the downside, we’ve also lost any performance benefits of concurrency (for this program
that’s fine, but in general there’s some other computation that wouldn’t conflict and so
could be done in parallel).
117
Using Several Mutexes
lock m can block (that’s the point). Hence, you can deadlock.
e = (lock m1; lock m2; l1 :=!l2; unlock m1; unlock m2)
(lock m2; lock m1; l2 :=!l1; unlock m1; unlock m2)
Locking Disciplines
So, suppose we have several programs e1, ..., ek, all well-typed with
Γ ⊢ ei:unit, that we want to execute concurrently without ‘interference’
(whatever that is). Think of them as transaction bodies.
There are many possible locking disciplines. We’ll focus on one, to see
how it – and the properties it guarantees – can be made precise and
proved.
An Ordered 2PL Discipline, Informally
Fix an association between locations and mutexes. For simplicity, make it
1:1 – associate l with m, l1 with m1, etc.
Fix a lock acquisition order. For simplicity, make it m, m0, m1, m2, ....
Require that each ei
• acquires the lock mj for each location lj it uses, before it uses it
• acquires and releases each lock in a properly-bracketed way
• does not acquire any lock after it’s released any lock (two-phase)
• acquires locks in increasing order
Then, informally, (e1 ... ek) should (a) never deadlock, and (b) be
serialisable – any execution of it should be ‘equivalent’ to an execution of
eπ(1); ...; eπ(k) for some permutation π.
These are semantic properties again. In general, it won’t be computable whether they hold.
For simple ei, though, it’s often obvious. Further, one can construct syntactic disciplines
that are checkable and are sufficient to guarantee these.
See Transactional Information Systems, Gerhard Weikum and Gottfried Vossen, for much
more detail on locking disciplines etc. (albeit not from a programming-language semantics
perspective).
Problem: Need a Thread-Local Semantics
Our existing semantics defines the behaviour only of global configurations
〈e, s ,M 〉. To state properties of subexpressions, e.g.
• ei acquires the lock mj for each location lj it uses, before it uses it
which really means
• in any execution of 〈(e1 ... ei ... ek), s ,M 〉, ei acquires the lock
mj for each location lj it uses, before it uses it
we need some notion of the behaviour of the thread ei on its own
118
Solution: Write One Down
Instead of only defining the global 〈e, s ,M 〉 −→ 〈e ′, s ′,M ′〉, with rules
(assign1) 〈ℓ := n, s,M 〉 −→ 〈skip, s + {ℓ 7→ n},M 〉 if ℓ ∈ dom(s)
(parallel1)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1 e2, s,M 〉 −→ 〈e
′
1 e2, s
′,M ′〉
define a per-thread e
a−→ e ′ and use that to define
〈e, s ,M 〉 −→ 〈e ′, s ′,M ′〉, with rules like
(t-assign1) ℓ := n
ℓ:=n
−→ skip
(t-parallel1)
e1
a
−→ e ′1
e1 e2
a
−→ e ′1 e2
(c-assign)
e
ℓ:=n
−→ e ′ ℓ ∈ dom(s)
〈e, s,M 〉 −→ 〈e ′, s + {ℓ 7→ n},M 〉
Note the per-thread rules don’t mention s or M . Instead, we record in the
label a what interactions with the store or mutexes it has.
a ::= τ | ℓ := n |!ℓ = n | lock m | unlock m
Conventionally, τ (tau), stands for “no interactions”, so e
τ−→ e ′ if e does
an internal step, not involving the store or mutexes.
Theorem 17 (Coincidence of global and thread-local semantics) The
two definitions of−→ agree exactly.
Proof strategy: a couple of rule inductions.
Write A for the set of all actions (explicitly, A = {τ} ∪ {ℓ := n | ℓ ∈ L ∧ n ∈ N} ∪ {!ℓ =
n | ℓ ∈ L ∧ n ∈ N} ∪ {lock m | m ∈ M} ∪ {unlock m | m ∈ M }).
Global Semantics Thread-Local Semantics
(op +) 〈n1 + n2, s,M 〉 −→ 〈n, s,M 〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s,M 〉 −→ 〈b, s,M 〉 if b = (n1 ≥ n2)
(op1)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1 op e2, s,M 〉 −→ 〈e
′
1 op e2, s
′,M ′〉
(op2)
〈e2, s,M 〉 −→ 〈e
′
2, s
′,M ′〉
〈v op e2, s,M 〉 −→ 〈v op e
′
2, s
′,M ′〉
(deref) 〈!ℓ, s,M 〉 −→ 〈n, s,M 〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s,M 〉 −→ 〈skip, s + {ℓ 7→ n},M 〉 if ℓ ∈ dom(s)
(assign2)
〈e, s,M 〉 −→ 〈e ′, s ′,M ′〉
〈ℓ := e, s,M 〉 −→ 〈ℓ := e ′, s ′,M ′〉
(seq1) 〈skip; e2, s,M 〉 −→ 〈e2, s,M 〉
(seq2)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1; e2, s,M 〉 −→ 〈e
′
1; e2, s
′,M ′〉
(if1) 〈if true then e2 else e3, s,M 〉 −→ 〈e2, s,M 〉
(if2) 〈if false then e2 else e3, s,M 〉 −→ 〈e3, s,M 〉
(if3)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈if e1 then e2 else e3, s,M 〉 −→ 〈if e
′
1 then e2 else e3, s
′,M ′〉
(while)
〈while e1 do e2, s,M 〉 −→ 〈if e1 then (e2; while e1 do e2) else skip, s,M 〉
(parallel1)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1 e2, s,M 〉 −→ 〈e
′
1 e2, s
′,M ′〉
(parallel2)
〈e2, s,M 〉 −→ 〈e
′
2, s
′,M ′〉
〈e1 e2, s,M 〉 −→ 〈e1 e
′
2, s
′,M ′〉
(lock) 〈lock m, s,M 〉 −→ 〈(), s,M + {m 7→ true}〉 if ¬M (m)
(unlock) 〈unlock m, s,M 〉 −→ 〈(), s,M + {m 7→ false}〉
(t-op +) n1 + n2
τ
−→ n if n = n1 + n2
(t-op ≥) n1 ≥ n2
τ
−→ b if b = (n1 ≥ n2)
(t-op1)
e1
a
−→ e ′1
e1 op e2
a
−→ e ′1 op e2
(t-op2)
e2
a
−→ e ′2
v op e2
a
−→ v op e ′2
(t-deref) !ℓ
!ℓ=n
−→ n
(t-assign1) ℓ := n
ℓ:=n
−→ skip
(t-assign2)
e
a
−→ e ′
ℓ := e
a
−→ ℓ := e ′
(t-seq1) skip; e2
τ
−→ e2
(t-seq2)
e1
a
−→ e ′1
e1; e2
a
−→ e ′1; e2
(t-if1) if true then e2 else e3
τ
−→ e2
(t-if2) if false then e2 else e3
τ
−→ e3
(t-if3)
e1
a
−→ e ′1
if e1 then e2 else e3
a
−→ if e ′1 then e2 else e3
(t-while)
while e1 do e2
τ
−→ if e1 then (e2; while e1 do e2) else skip
(t-parallel1)
e1
a
−→ e ′1
e1 e2
a
−→ e ′1 e2
(t-parallel2)
e2
a
−→ e ′2
e1 e2
a
−→ e1 e
′
2
(t-lock) lock m
lock m
−→ ()
(t-unlock) unlock m
unlock m
−→ ()
(c-tau) e
τ
−→ e ′
〈e, s,M 〉 −→ 〈e ′, s,M 〉
(c-assign)
e
ℓ:=n
−→ e ′ ℓ ∈ dom(s)
〈e, s,M 〉 −→ 〈e ′, s + {ℓ 7→ n},M 〉
(c-lock)
e
lock m
−→ e ′ ¬ M (m)
〈e, s,M 〉 −→ 〈e ′, s,M + {m 7→ true}〉
(c-deref)
e
!ℓ=n
−→ e ′ ℓ ∈ dom(s) ∧ s(ℓ) = n
〈e, s,M 〉 −→ 〈e ′, s,M 〉
(c-unlock) e
unlock m
−→ e ′
〈e, s,M 〉 −→ 〈e ′, s,M + {m 7→ false}〉
119
Example of Thread-local transitions
For e = (lock m; (l := 1+!l ; unlock m)) we have
e
lock m−→ skip; (l := 1+!l ; unlock m)
τ−→ (l := 1+!l ; unlock m)
!l=n−→ (l := 1 + n; unlock m) for any n ∈ Z
τ−→ (l := n ′; unlock m) for n ′ = 1 + n
l :=n ′−→ skip; unlock m
τ−→ unlock m
unlock m−→ skip
Hence, using (t-parallel) and the (c-*) rules, for s ′ = s + {l 7→ 1+ s(l)},
〈e e ′, s ,M0〉 −→−→−→−→−→−→−→ 〈skip e ′, s ′,M0〉
(need l ∈ dom(s) also)
One often uses similar labelled transitions in defining communication between threads (or
machines), and also in working with observational equivalences for concurrent languages (cf.
bisimulation) – to come in Topics in Concurrency.
Now can make the Ordered 2PL Discipline precise
Say e obeys the discipline if for any (finite or infinite)
e
a1−→ e1 a2−→ e2 a3−→ ...
• if ai is (lj := n) or (!lj = n) then for some k < i we have
ak = lock mj without an intervening unlock mj .
• for each j , the subsequence of a1, a2, ... with labels lock mj and
unlock mj is a prefix of ((lock mj)(unlock mj))
∗. Moreover, if
¬(ek a−→ ) then the subsequence does not end in a lock mj .
• if ai = lock mj and ai′ = unlock mj′ then i < i′
• if ai = lock mj and ai′ = lock mj′ and i < i′ then j < j′
... and make the guaranteed properties precise
Say e1, ..., ek are serialisable if for any initial store s , if
〈(e1 ... ek), s ,M0〉 −→∗ 〈e, s ′,M ′〉 6−→ then for some permutation π
we have 〈eπ(1); ...; eπ(k), s ,M0〉 −→∗ 〈e, s ′,M ′〉.
Say they are deadlock-free if for any initial store s , if
〈(e1 ... ek), s ,M0〉 −→∗ 〈e, s ′,M 〉 6−→ then not e lock m−→ e ′,
i.e.e does not contain any blocked lock m subexpressions.
(Warning: there are many subtle variations of these properties!)
120
The Theorem
Conjecture 4 If each ei obeys the discipline, then e1, ...ek are
serialisable and deadlock-free.
(may be false!)
Proof strategy: Consider a (derivation of a) computation
〈(e1 ... ek), s ,M0〉 −→ 〈ê1, s1,M1〉 −→ 〈ê2, s2,M2〉 −→ ...
We know each êi is a corresponding parallel composition. Look at the
points at which each ei acquires its final lock. That defines a serialisation
order. In between times, consider commutativity of actions of the different
ei – the premises guarantee that many actions are semantically
independent, and so can be permuted.
We’ve not discussed fairness – the semantics allows any interleaving
between parallel components, not only fair ones.
Language Properties
(Obviously!) don’t have Determinacy.
Still have Type Preservation.
Have Progress, but it has to be modified – a well-typed expression of type
proc will reduce to some parallel composition of unit values.
Typing and type inference is scarcely changed.
(very fancy type systems can be used to enforce locking disciplines)
8.1 Exercises
Exercise 37 ⋆⋆Are the mutexes specified here similar to those described in CSAA?
Exercise 38 ⋆⋆Can you show all the conditions for O2PL are necessary, by giving for
each an example that satisfies all the others and either is not serialisable or deadlocks?
Exercise 39 ⋆⋆⋆⋆Prove the Conjecture about it.
Exercise 40 ⋆⋆⋆Write a semantics for an extension of L1 with threads that are more
like Unix threads (e.g. with thread ids, fork, etc..). Include some of the various ways Unix
threads can exchange information.
121
9 Low-level semantics
Low-level semantics
Can usefully apply semantics not just to high-level languages but to
• Intermediate Languages (e.g. Java Bytecode, MS IL, C−−)
• Assembly languages (esp. for use as a compilation target)
• C-like languages (cf. Cyclone)
By making these type-safe we can make more robust systems.
(see separate handout)
10 Epilogue
Epilogue
Lecture Feedback
Please do fill in the lecture feedback form – we need to know how the
course could be improved / what should stay the same.
My impression...
Good language design?
Need:
• precise definition of what the language is (so can communicate among
the designers)
• technical properties (determinacy, decidability of type checking, etc.)
• pragmatic properties (usability in-the-large, implementability)
122
What can you use semantics for?
1. to understand a particular language - what you can depend on as a
programmer; what you must provide as a compiler writer
2. as a tool for language design:
(a) for expressing design choices, understanding language features
and how they interact.
(b) for proving properties of a language, eg type safety, decidability of
type inference.
3. as a foundation for proving properties of particular programs
The End
123
Global Semantics Thread-Local Semantics
(op +) 〈n1 + n2, s,M 〉 −→ 〈n, s,M 〉 if n = n1 + n2
(op ≥) 〈n1 ≥ n2, s,M 〉 −→ 〈b, s,M 〉 if b = (n1 ≥ n2)
(op1)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1 op e2, s,M 〉 −→ 〈e
′
1 op e2, s
′,M ′〉
(op2)
〈e2, s,M 〉 −→ 〈e
′
2, s
′,M ′〉
〈v op e2, s,M 〉 −→ 〈v op e
′
2, s
′,M ′〉
(deref) 〈!ℓ, s,M 〉 −→ 〈n, s,M 〉 if ℓ ∈ dom(s) and s(ℓ) = n
(assign1) 〈ℓ := n, s,M 〉 −→ 〈skip, s + {ℓ 7→ n},M 〉 if ℓ ∈ dom(s)
(assign2)
〈e, s,M 〉 −→ 〈e ′, s ′,M ′〉
〈ℓ := e, s,M 〉 −→ 〈ℓ := e ′, s ′,M ′〉
(seq1) 〈skip; e2, s,M 〉 −→ 〈e2, s,M 〉
(seq2)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1; e2, s,M 〉 −→ 〈e
′
1; e2, s
′,M ′〉
(if1) 〈if true then e2 else e3, s,M 〉 −→ 〈e2, s,M 〉
(if2) 〈if false then e2 else e3, s,M 〉 −→ 〈e3, s,M 〉
(if3)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈if e1 then e2 else e3, s,M 〉 −→ 〈if e
′
1 then e2 else e3, s
′,M ′〉
(while)
〈while e1 do e2, s,M 〉 −→ 〈if e1 then (e2;while e1 do e2) else skip, s,M 〉
(parallel1)
〈e1, s,M 〉 −→ 〈e
′
1, s
′,M ′〉
〈e1 e2, s,M 〉 −→ 〈e
′
1 e2, s
′,M ′〉
(parallel2)
〈e2, s,M 〉 −→ 〈e
′
2, s
′,M ′〉
〈e1 e2, s,M 〉 −→ 〈e1 e
′
2, s
′,M ′〉
(lock) 〈lock m, s,M 〉 −→ 〈(), s,M + {m 7→ true}〉 if ¬M (m)
(unlock) 〈unlock m, s,M 〉 −→ 〈(), s,M + {m 7→ false}〉
(t-op +) n1 + n2
τ
−→ n if n = n1 + n2
(t-op ≥) n1 ≥ n2
τ
−→ b if b = (n1 ≥ n2)
(t-op1)
e1
a
−→ e ′1
e1 op e2
a
−→ e ′1 op e2
(t-op2)
e2
a
−→ e ′2
v op e2
a
−→ v op e ′2
(t-deref) !ℓ
!ℓ=n
−→ n
(t-assign1) ℓ := n
ℓ:=n
−→ skip
(t-assign2)
e
a
−→ e ′
ℓ := e
a
−→ ℓ := e ′
(t-seq1) skip; e2
τ
−→ e2
(t-seq2)
e1
a
−→ e ′1
e1; e2
a
−→ e ′1; e2
(t-if1) if true then e2 else e3
τ
−→ e2
(t-if2) if false then e2 else e3
τ
−→ e3
(t-if3)
e1
a
−→ e ′1
if e1 then e2 else e3
a
−→ if e ′1 then e2 else
(t-while)
while e1 do e2
τ
−→ if e1 then (e2;while e1 do e2) else
(t-parallel1)
e1
a
−→ e ′1
e1 e2
a
−→ e ′1 e2
(t-parallel2)
e2
a
−→ e ′2
e1 e2
a
−→ e1 e
′
2
(t-lock) lock m
lock m
−→ ()
(t-unlock) unlock m
unlock m
−→ ()
(c-tau) e
τ
−→ e ′
〈e, s,M 〉 −→ 〈e ′, s,M 〉
(c-assign)
e
ℓ:=n
−→ e ′ ℓ ∈ dom(s)
〈e, s,M 〉 −→ 〈e ′, s + {ℓ 7→ n},M 〉
(c-lock)
e
lock m
−→ e ′ ¬ M (m)
〈e, s,M 〉 −→ 〈e ′, s,M + {m 7→ true}〉
(c-deref)
e
!ℓ=n
−→ e ′ ℓ ∈ dom(s) ∧ s(ℓ) = n
〈e, s,M 〉 −→ 〈e ′, s,M 〉
(c-unlock) e
unlock m
−→ e ′
〈e, s,M 〉 −→ 〈e ′, s,M + {m 7→ false}〉
124
T
h
e
b
eh
av
iou
r
of
(l
:=
1+
!l)
(l
:=
7+
!l)
for
th
e
in
itial
store{l7→
0}:
〈() (l := 7+!l), {l 7→ 1}〉
r // •
+ // • w // 〈() (), {l 7→ 8}〉
〈(l := 1) (l := 7+!l), {l 7→ 0}〉
r
))SSS
SSS
SSS
SSS
SS
w
55kkkkkkkkkkkkkk
〈() (l := 7 + 0), {l 7→ 1}〉
+
))RR
RRR
RRR
RRR
RR
〈(l := 1 + 0) (l := 7+!l), {l 7→ 0}〉
r
''OO
OOO
OOO
OOO
+
77ooooooooooo
〈(l := 1) (l := 7 + 0), {l 7→ 0}〉
+
))SSS
SSS
SSS
SSS
SS
w
55kkkkkkkkkkkkkk
〈() (l := 7), {l 7→ 1}〉
w // 〈() (), {l 7→ 7}〉
〈(l := 1+!l) (l := 7+!l), {l 7→ 0}〉
r
77ooooooooooo
r
''OO
OOO
OOO
OOO
〈(l := 1 + 0) (l := 7 + 0), {l 7→ 0}〉
+
55kkkkkkkkkkkkkk
+
))SSS
SSS
SSS
SSS
SS
〈(l := 1) (l := 7), {l 7→ 0}〉
w
55lllllllllllll
w
))RR
RRR
RRR
RRR
RR
〈(l := 1+!l) (l := 7 + 0), {l 7→ 0}〉
r
77ooooooooooo
+
''OO
OOO
OOO
OOO
〈(l := 1 + 0) (l := 7), {l 7→ 0}〉
+
55kkkkkkkkkkkkkk
w
))SSS
SSS
SSS
SSS
SS
〈l := 1 (), {l 7→ 7}〉
w // 〈() (), {l 7→ 1}〉
〈(l := 1+!l) (l := 7), {l 7→ 0}〉
r
55kkkkkkkkkkkkkk
w
))SSS
SSS
SSS
SSS
SS
〈l := 1 + 0 (), {l 7→ 7}〉
+
55lllllllllllll
〈l := 1+!l (), {l 7→ 7}〉
r // •
+ // • w // 〈() (), {l 7→ 8}〉
125
A How To Do Proofs
The purpose of this handout is give a general guide as to how to prove theorems. This
should give you some help in answering questions that begin with “Show that the following
is true . . . ”. It is based on notes by Myra VanInwegen, with additional text added by Peter
Sewell in §A.1. Many thanks to Myra for making her original notes available.
The focus here is on doing informal but rigorous proofs. These are rather different from
the formal proofs, in Natural Deduction or Sequent Calculus, that were introduced in the
Logic and Proof course. Formal proofs are derivations in one of those proof systems – they
are in a completely well-defined form, but are often far too verbose to deal with by hand
(although they can be machine-checked). Informal proofs, on the other hand, are the usual
mathematical notion of proof: written arguments to persuade the reader that you could, if
pushed, write a fully formal proof.
This is important for two reasons. Most obviously, you should learn how to do these proofs.
More subtly, but more importantly, only by working with the mathematical definitions in
some way can you develop a good intuition for what they mean — trying to do some proofs
is the best way of understanding the definitions.
A.1 How to go about it
Proofs differ, but for many of those you meet the following steps should be helpful.
1. Make sure the statement of the conjecture is precisely defined. In particular, make
sure you understand any strange notation, and find the definitions of all the auxiliary
gadgets involved (e.g. definitions of any typing or reduction relations mentioned in the
statement, or any other predicates or functions).
2. Try to understand at an intuitive level what the conjecture is saying – verbalize out
loud the basic point. For example, for a Type Preservation conjecture, the basic
point might be something like “if a well-typed configuration reduces, the result is still
well-typed (with the same type)”.
3. Try to understand intuitively why it is true (or false...). Identify what the most
interesting cases might be — the cases that you think are most likely to be suspicious,
or hard to prove. Sometimes it’s good to start with the easy cases (if the setting
is unfamiliar to you); sometimes it’s good to start with the hard cases (to find any
interesting problems as soon as possible).
4. Think of a good basic strategy. This might be:
(a) simple logic manipulations;
(b) collecting together earlier results, again by simple logic; or
(c) some kind of induction.
5. Try it! (remembering you might have to backtrack if you discover you picked a strategy
that doesn’t work well for this conjecture). This might involve any of the following:
(a) Expanding definitions, inlining them. Sometimes you can just blindly expand all
definitions, but more often it’s important to expand only the definitions which
you want to work with the internal structure of — otherwise things just get too
verbose.
(b) Making abbreviations — defining a new variable to stand for some complex gadget
you’re working with, saying e.g.
where e = (let x:int = 7+2 in x+x)
Take care with choosing variable names.
126
(c) Doing equational reasoning, e.g.
e = e1 by ...
= e2 by ...
= e3 as ...
Here the e might be any mathematical object — arithmetic expressions, or ex-
pressions of some grammar, or formulae. Some handy equations over formulae
are given in §A.2.2.
(d) Proving a formula based on its structure. For example, to prove a formula ∀x ∈
S.P (x) you would often assume you have an arbitrary x and then try to prove
P (x).
Take an arbitrary x ∈ S.
We now have to show P (x):
This is covered in detail in §A.2.3. Much proof is of this form, automatically
driven by the structure of the formula.
(e) Using an assumption you’ve made above.
(f) Induction. As covered in the 1B Semantics notes, there are various kinds of induc-
tion you might want to use: mathematical induction over the natural numbers,
structural induction over the elements of some grammar, or rule induction over
the rules defining some relation (especially a reduction or typing relation). For
each, you should:
i. Decide (and state!) what kind of induction you’re using. This may need
some thought and experience, and you might have to backtrack.
ii. Remind yourself what the induction principle is exactly.
iii. Decide on the induction hypothesis you’re going to use, writing down a pred-
icate Φ which is such that the conclusion of the induction principle implies
the thing you’re trying to prove. Again, this might need some thought. Take
care with the quantifiers here — it’s suspicious if your definition of Φ has
any globally-free variables...
iv. Go through each of the premises of the induction principle and prove each one
(using any of these techniques as appropriate). Many of those premises will
be implications, e.g. ∀x ∈ N.Φ(x)⇒ Φ(x + 1), for which you can do a proof
based on the structure of the formula — taking an arbitrary x, assuming
Φ(x), and trying to prove Φ(x+1). Usually at some point in the latter you’d
make use of the assumption Φ(x).
6. In all of the above, remember: the point of doing a proof on paper is to use the
formalism to help you think — to help you cover all cases, precisely — and also to
communicate with the reader. For both, you need to write clearly:
(a) Use enough words! “Assume”, “We have to show”, “By such-and-such we know”,
“Hence”,...
(b) Don’t use random squiggles. It’s good to have formulae properly nested within
text, with and no “⇒” or “∴” between lines of text.
7. If it hasn’t worked yet... either
(a) you’ve make some local mistake, e.g. mis-instantiated something, or used the
same variable for two different things, or not noticed that you have a definition
you should have expanded or an assumption you should have used. Fix it and
continue.
127
(b) you’ve discovered that the conjecture is really false. Usually at this point it’s
a good idea to construct a counterexample that is as simple as possible, and to
check carefully that it really is a counterexample.
(c) you need to try a different strategy — often, to use a different induction principle
or to strengthen your induction hypothesis.
(d) you didn’t really understand intuitively what the conjecture is saying, or what
the definitions it uses mean. Go back to them again.
8. If it has worked: read through it, skeptically, and check. Maybe you’ll need to re-write
it to make it comprehensible: proof discovery is not the same as proof exposition. See
the example proofs in the Semantics notes.
9. Finally, give it to someone else, as skeptical and careful as you can find, to see if they
believe it — to see if they believe that what you’ve written down is a proof, not that
they believe that the conjecture is true.
128
A.2 And in More Detail...
First, I’ll explain informal proof intuitively, giving a couple of examples. Then I’ll explain
how this intuition is reflected in the sequent rules from Logic and Proof.
In the following, I’ll call any logic statement a formula. In general, what we’ll be trying to
do is prove a formula, using a collection of formulas that we know to be true or are assuming
to be true. There’s a big difference between using a formula and proving a formula. In fact,
what you do is in many ways opposite. So, I’ll start by explaining how to prove a formula.
A.2.1 Meet the Connectives
Here are the logical connectives and a very brief decription of what each means.
P ∧Q P and Q are both true
P ∨Q P is true, or Q is true, or both are true
¬P P is not true (P is false)
P ⇒ Q if P is true then Q is true
P ⇔ Q P is true exactly when Q is true
∀x ∈ S.P (x) for all x in S, P is true of x
∃x ∈ S.P (x) there exists an x in S such that P holds of x
A.2.2 Equivalences
These are formulas that mean the same thing, and this is indicated by a ≃ between them.
The fact that they are equivalent to each other is justified by the truth tables of the con-
nectives.
definition of ⇒ P ⇒ Q ≃ ¬P ∨Q
definition of ⇔ P ⇔ Q ≃ (P ⇒ Q) ∧ (Q⇒ P )
definition of ¬ ¬P ≃ P ⇒ false
de Morgan’s Laws ¬(P ∧Q) ≃ ¬P ∨ ¬Q
¬(P ∨Q) ≃ ¬P ∧ ¬Q
extension to quantifiers ¬(∀x.P (x)) ≃ ∃x.¬P (x)
¬(∃x.P (x)) ≃ ∀x.¬P (x)
distributive laws P ∨ (Q ∧R) ≃ (P ∨Q) ∧ (P ∨R)
P ∧ (Q ∨R) ≃ (P ∧Q) ∨ (P ∧R)
coalescing quantifiers (∀x.P (x)) ∧ (∀x.Q(x)) ≃ ∀x.(P (x) ∧Q(x))
(∃x.P (x)) ∨ (∃x.Q(x)) ≃ ∃x.(P (x) ∨Q(x))
these ones apply if (∀x.P (x)) ∧Q ≃ (∀x.P (x) ∧Q)
x is not free in Q (∀x.P (x)) ∨Q ≃ (∀x.P (x) ∨Q)
(∃x.P (x)) ∧Q ≃ (∃x.P (x) ∧Q)
(∃x.P (x)) ∨Q ≃ (∃x.P (x) ∨Q)
A.2.3 How to Prove a Formula
For each of the logical connectives, I’ll explain how to handle them.
∀x ∈ S.P (x) This means “For all x in S, P is true of x.” Such a formula is called a
universally quantified formula. The goal is to prove that the property P , which has some
xs somewhere in it, is true no matter what value in S x takes on. Often the “∈ S” is left
out. For example, in a discussion of lists, you might be asked to prove ∀l.length l > 0 ⇒
∃x. member(x, l). Obviously, l is a list, even if it isn’t explicitly stated as such.
There are several choices as to how to prove a formula beginning with ∀x. The standard
thing to do is to just prove P (x), not assuming anything about x. Thus, in doing the proof
129
you sort of just mentally strip off the ∀x. What you would write when doing this is “Let x be
any S”. However, there are some subtleties—if you’re already using an x for something else,
you can’t use the same x, because then you would be assuming something about x, namely
that it equals the x you’re already using. In this case, you need to use alpha-conversion1 to
change the formula you want to prove to ∀y ∈ S.P (y), where y is some variable you’re not
already using, and then prove P (y). What you could write in this case is “Since x is already
in use, we’ll prove the property of y”.
An alternative is induction, if S is a set that is defined with a structural definition. Many
objects you’re likely to be proving properties of are defined with a structural definition.
This includes natural numbers, lists, trees, and terms of a computer language. Sometimes
you can use induction over the natural numbers to prove things about other objects, such
as graphs, by inducting over the number of nodes (or edges) in a graph.
You use induction when you see that during the course of the proof you would need to use
the property P for the subparts of x in order to prove it for x. This usually ends up being
the case if P involves functions defined recursively (i.e., the return value for the function
depends on the function value on the subparts of the argument).
A special case of induction is case analysis. It’s basically induction where you don’t use the
inductive hypothesis: you just prove the property for each possible form that x could have.
Case analysis can be used to prove the theorem about lists above.
A final possibility (which you can use for all formulas, not just for universally quantified
ones) is to assume the contrary, and then derive a contradiction.
∃x ∈ S.P (x) This says “There exists an x in S such that P holds of x.” Such a formula is
called an existentially quantified formula. The main way to prove this is to figure out what
x has to be (that is, to find a concrete representation of it), and then prove that P holds of
that value. Sometimes you can’t give a completely specified value, since the value you pick
for x has to depend on the values of other things you have floating around. For example,
say you want to prove
∀x, y ∈ ℜ.x < y ∧ sin x < 0 ∧ sin y > 0⇒ ∃z.x < z ∧ z < y ∧ sin z = 0
where ℜ is the set of real numbers. By the time you get to dealing with the ∃z.x < z ∧ z <
y ∧ sin z = 0, you will have already assumed that x and y were any real numbers. Thus the
value you choose for z has to depend on whatever x and y are.
An alternative way to prove ∃x ∈ S.P (x) is, of course, to assume that no such x exists, and
derive a contradiction.
To summarize what I’ve gone over so far: to prove a universally quantified formula, you must
prove it for a generic variable, one that you haven’t used before. To prove an existentially
quantified formula, you get to choose a value that you want to prove the property of.
P ⇒ Q This says “If P is true, then Q is true”. Such a formula is called an implication,
and it is often pronounced “P implies Q”. The part before the ⇒ sign (here P ) is called
the antecedent, and the part after the ⇒ sign (here Q) is called the consequent. P ⇒ Q is
equivalent to ¬P ∨Q, and so if P is false, or if Q is true, then P ⇒ Q is true.
The standard way to prove this is to assume P , then use it to help you prove Q. Note that
I said that you will be using P . Thus you will need to follow the rules in Section A.2.4 to
deal with the logical connectives in P .
Other ways to prove P ⇒ Q involve the fact that it is equivalent to ¬P ∨Q. Thus, you can
prove ¬P without bothering with Q, or you can just prove Q without bothering with P .
1Alpha-equivalence says that the name of a bound variable doesn’t matter, so you can change it at will
(this is called alpha-conversion). You’ll get to know the exact meaning of this soon enough so I won’t explain
this here.
130
To reason by contradiction you assume that P is true and that Q is not true, and derive a
contradiction.
Another alternative is to prove the contrapositive: ¬Q⇒ ¬P , which is equivalent to it.
P ⇔ Q This says “P is true if and only if Q is true”. The phrase “if and only if” is usually
abbreviated “iff”. Basically, this means that P and Q are either both true, or both false.
Iff is usually used in two main ways: one is where the equivalence is due to one formula
being a definition of another. For example, A ⊆ B ⇔ (∀x. x ∈ A⇒ x ∈ B) is the standard
definition of subset. For these iff statements, you don’t have to prove them. The other use
of iff is to state the equivalence of two different things. For example, you could define an
SML function fact:
fun fact 0 = 1
| fact n = n * fact (n - 1)
Since in SML whole numbers are integers (both positive and negative) you may be asked
to prove: fact x terminates ⇔ x ≥ 0. The standard way to do this is us the equivalence
P ⇔ Q is equivalent to P ⇒ Q ∧ Q ⇒ P . And so you’d prove that (fact x terminates ⇒
x ≥ 0) ∧ (x ≥ 0⇒ fact x terminates).
¬P This says “P is not true”. It is equivalent to P ⇒ false, thus this is one of the ways
you prove it: you assume that P is true, and derive a contradiction (that is, you prove
false). Here’s an example of this, which you’ll run into later this year: the undecidability
of the halting problem can be rephrased as ¬∃x ∈ RM. x solves the halting problem, where
RM is the set of register machines. The proof of this in your Computation Theory notes
follows exactly the pattern I described—it assumes there is such a machine and derives a
contradiction.
The other major way to prove ¬P is to figure out what the negation of P is, using equiva-
lences like De Morgan’s Law, and then prove that. For example, to prove ¬∀x ∈ N . ∃y ∈
N . x = y2, where N is the set of natural numbers, you could push in the negation to get:
∃x ∈ N . ∀y ∈ N . x 6= y2, and then you could prove that.
P ∧Q This says “P is true and Q is true”. Such a formula is called a conjunction. To
prove this, you have to prove P , and you have to prove Q.
P ∨Q This says “P is true or Q is true”. This is inclusive or: if P and Q are both true,
then P ∨Q is still true. Such a formula is called a disjunction. To prove this, you can prove
P or you can prove Q. You have to choose which one to prove. For example, if you need to
prove (5 mod 2 = 0) ∨ (5 mod 2 = 1), then you’ll choose the second one and prove that.
However, as with existentials, the choice of which one to prove will often depend on the
values of other things, like universally quantified variables. For example, when you are
studying the theory of programming languages (you will get a bit of this in Semantics), you
might be asked to prove
∀P ∈ ML. P is properly typed⇒
(the evaluation of P runs forever) ∨ (P evaluates to a value)
where ML is the set of all ML programs. You don’t know in advance which of these will be
the case, since some programs do run forever, and some do evaluate to a value. Generally,
the best way to prove the disjunction in this case (when you don’t know in advance which
will hold) is to use the equivalence with implication. For example, you can use the fact
that P ∨ Q is equivalent to ¬P ⇒ Q, then assume ¬P , then use this to prove Q. For
example, your best bet to proving this programming languages theorem is to assume that
the evaluation of P doesn’t run forever, and use this to prove that P evaluates to a value.
131
A.2.4 How to Use a Formula
You often end up using a formula to prove other formulas. You can use a formula if someone
has already proved that it’s true, or you are assuming it because it was in an implication,
namely, the A in A⇒ B. For each logical connective, I’ll tell you how to use it.
∀x ∈ S.P (x) This formula says that something is true of all elements of S. Thus, when
you use it, you can pick any value at all to use instead of x (call it v), and then you can use
P (v).
∃x ∈ S.P (x) This formula says that there is some x that satisfies P . However, you do not
know what it is, so you can not assume anything about it. The usual approach it to just
say that the thing that is being said to exist is just x, and use the fact that P holds of x to
prove something else. However, if you’re already using an x for something else, you have to
pick another variable to represent the thing that exists.
To summarize this: to use a universally quantified formula, you can choose any value, and
use that the formula holds for that variable. To use an existentially quantified formula, you
must not assume anything about the value that is said to exists, so you just use a variable
(one that you haven’t used before) to represent it. Note that this is more or less opposite
of what you do when you prove a universally or existentially quantified formula.
¬P Usually, the main use of this formula is to prove the negation of something else.
An example is the use of reduction to prove the unsolvability of various problems in the
Computation Theory (you’ll learn all about this in Lent term). You want to prove ¬Q,
where Q states that a certain problem (Problem 1) is decidable (in other words, you want
to prove that Problem 1 is not decidable). You know ¬P , where P states that another
problem (Problem 2) is decidable (i.e. ¬P says that Problem 2 is not decidable). What you
do basically is this. You first prove Q⇒ P , which says that if Problem 1 is decidable, then
so is Problem 2. Since Q⇒ P ≃ ¬P ⇒ ¬Q, you have now proved ¬P ⇒ ¬Q. You already
know ¬P , so you use modus ponens2 to get that ¬Q.
P ⇒ Q The main way to use this is that you prove P , and then you use modus ponens to
get Q, which you can then use.
P ⇔ Q The main use of this is to replace an occurrence of P in a formula with Q, and
vise versa.
P ∧Q Here you can use both P and Q. Note, you’re not required to use both of them, but
they are both true and are waiting to be used by you if you need them.
P ∨Q Here, you know that one of P or Q is true, but you do not know which one. To use
this to prove something else, you have to do a split: first you prove the thing using P , then
you prove it using Q.
Note that in each of the above, there is again a difference in the way you use a formula,
verses the way you prove it. They are in a way almost opposites. For example, in proving
P ∧ Q, you have to prove both P and Q, but when you are using the formula, you don’t
have to use both of them.
A.3 An Example
There are several exercises in the Semantics notes that ask you to prove something. Here,
we’ll go back to Regular Languages and Finite Automata. (If they’ve faded, it’s time
2Modus ponens says that if A ⇒ B and A are both true, then B is true.
132
to remind yourself of them.) The Pumping Lemma for regular sets (PL for short) is an
astonishingly good example of the use of quantifiers. We’ll go over the proof and use of the
PL, paying special attention to the logic of what’s happening.
A.3.1 Proving the PL
My favorite book on regular languages, finite automata, and their friends is the Hopcroft
and Ullman book Introduction to Automata Theory, Languages, and Computation. You
should locate this book in your college library, and if it isn’t there, insist that your DoS
order it for you.
In the Automata Theory book, the Pumping Lemma is stated as: “Let L be a regular set.
Then there is a constant n such that if z is any word in L, and |z| ≥ n, we may write z = uvw
in such a way that |uv| ≤ n, |v| ≥ 1, and for all i ≥ 0, uviw is in L.” The Pumping Lemma
is, in my experience, one of the most difficult things about learning automata theory. It
is difficult because people don’t know what to do with all those logical connectives. Let’s
write it as a logical formula.
∀L ∈ RegularLanguages.
∃n. ∀z ∈ L. |z| ≥ n⇒
∃u v w. z = uvw ∧ |uv| ≤ n ∧ |v| ≥ 1 ∧
∀i ≥ 0. uviw ∈ L
Complicated, eh? Well, let’s prove it, using the facts that Hopcroft and Ullman have
established in the chapters previous to the one wih the PL. I’ll give the proof and put in
square brackets comments about what I’m doing.
Let L be any regular language. [Here I’m dealing with the ∀L ∈ RegularLanguages by
stating that I’m not assuming anything about L.] Let M be a minimal-state deterministic
finite state machine accepting L. [Here I’m using a fact that Hopcroft and Ullman have
already proved about the equivalence of regular languages and finite automata.] Let n be
the number of states in this finite state machine. [I’m dealing with the ∃n by giving a very
specific value of what it will be, based on the arbitrary L.] Let z be any word in L. [Thus
I deal with ∀z ∈ L.] Assume that |z| ≥ n. [Thus I’m taking care of the ⇒ by assuming the
antecedent.]
Say z is written a1a2 . . . am, where m ≥ n. Consider the states that M is in during the
processing of the first n symbols of z, a1a2 . . . an. There are n + 1 of these states. Since
there are only n states in M , there must be a duplicate. Say that after symbols aj and ak
we are in the same state, state s (i.e. there’s a loop from this state that the machine goes
through as it accepts z), and say that j < k. Now, let u = a1a2 . . . aj . This represents the
part of the string that gets you to state s the first time. Let v = aj+1 . . . ak. This represents
the loop that takes you from s and back to it again. Let w = ak+1 . . . am, the rest of word
z. [We have chosen definite values for u, v, and w.] Then clearly z = uvw, since u, v, and
w are just different sections of z. |uv| ≤ n since u and v occur within the first n symbols
of z. |v| ≥ 1 since j < k. [Note that we’re dealing with the formulas connected with ∧ by
proving each of them.]
Now, let i be a natural number (i.e. ≥ 0). [This deals with ∀i ≥ 0.] Then uviw ∈ L. [Finally
our conclusion, but we have to explain why this is true.] This is because we can repeat the
loop from s to s (represented by v) as many times as we like, and the resulting word will
still be accepted by M .
A.3.2 Using the PL
Now we use the PL to prove that a language is not regular. This is a rewording of Example
3.1 from Hopcroft and Ullman. I’ll show that L = {0i2 |i is an integer, i ≥ 1} is not regular.
Note that L consists of all strings of 0’s whose length is a perfect square. I will use the PL.
133
I want to prove that L is not regular. I’ll assume the negation (i.e., that L is regular) and
derive a contradiction. So here we go. Remember that what I’m emphasizing here is not
the finite automata stuff itself, but how to use a complicated theorem to prove something
else.
Assume L is regular. We will use the PL to get a contradiction. Since L is regular, the PL
applies to it. [We note that we’re using the ∀ part of the PL for this particular L.] Let n
be as described in the PL. [This takes care of using the ∃n. Note that we are not assuming
anything about its actual value, just that it’s a natural number.] Let z = 0n
2
. [Since the PL
says that something is true of all zs, we can choose the one we want to use it for.] So by the
PL there exist u, v, and w such that z = uvw, |uv| ≤ n, |v| ≥ 1. [Note that we don’t assume
anything about what the u, v, and w actually are; the only thing we know about them is
what the PL tells us about them. This is where people trying to use the PL usually screw
up.] The PL then says that for any i, then uviw ∈ L. Well, then uv2w ∈ L. [This is using
the ∀i ≥ 0 bit.] However, n2 < |uv2w| ≤ n2 + n, since 1 ≤ |v| ≤ n. But n2 + n < (n + 1)2.
Thus |uv2w| lies properly between n2 and (n + 1)2 and is thus not a perfect square. Thus
uv2w is not in L. This is a contradiction. Thus our assumption (that L was regular) was
incorrect. Thus L is not a regular language.
A.4 Sequent Calculus Rules
In this section, I will show how the intuitive approach to things that I’ve described above
is reflected in the sequent calculus rules. A sequent is Γ ⊢ ∆, where Γ and ∆ are sets of
formulas.3 Technically, this means that
A1 ∧A2 ∧ . . . An ⇒ B1 ∨B2 ∨ . . . Bm (1)
where A1, A2, . . . An are the formulas in Γ , and B1, B2, . . . Bn are the formulas in ∆. Less
formally, this means “using the formulas in Γ we can prove that one of the formula in ∆ is
true.” This is just the intuition I described above about using vs proving formulas, except
that I only talked about proving that one formula is true, rather than proving that one of
several formulas is true. In order to handle the ∨ connective, there can be any number of
formulas on the right hand side of the ⊢.
For each logic connective,4 I’ll give the rules for it, and explain how it relates to the intuitive
way of using or proving formulas. For each connective there are at least two rules for it: one
for the left side of the ⊢, and one for the right side. This corresponds to having different
ways to treat a formula depending on whether you’re using it (for formulas on the left hand
side of the ⊢) or proving it (for formulas on the right side of the ⊢).
It’s easiest to understand these rules from the bottom up. The conclusion of the rule (the
sequent below the horizontal line) is what we want to prove. The hypotheses of the rule
(the sequents above the horizontal line) are how we go about proving it. We’ll have to use
more rules, adding to the top, to build up the proof of the hypothesis, but this at least tells
us how to get going.
You can stop when the formula you have on the top is a basic sequent. This is Γ ⊢ ∆ where
there’s at least one formula (say P ) that’s in both Γ and ∆. You can see why this is the
basic true formula: it says that if P and the other formulas in Γ are true, then P or one of
the other formula in ∆ is true.
In building proofs from these rules, there are several ways that you end up with formulas
to the left of the ⊢, where you can use them rather than proving them. One is that you’ve
3In your Logic and Proof notes, the symbol that divides Γ from ∆ is ⇒. However, that conflicts with the
use of ⇒ as implication. Thus I will use ⊢. You will see something similar in Semantics, where it separates
assumptions (of the types of variables) from something that they allow you to prove.
4I won’t mention iff here: as P ⇔ Q is equivalent to P ⇒ Q ∧ Q ⇒ P , we don’t need separate rules for
it.
134
already proved it before. This is shown with the cut rule:
Γ ⊢ ∆, P P,Γ ⊢ ∆
Γ ⊢ ∆ (cut)
The ∆, P in the first sequent in the hypotheses means that to the right of the ⊢ we have
the set consisting of the formula P plus all the formulas in ∆, i.e., if all formulas in Γ are
true, then P or one of the formulas in ∆ is true. Similarly P,Γ to the left of the ⊢ in the
second sequent means the set consisting of the formula P plus all the formulas in Γ.
We read this rule from the bottom up to make sense of it. Say we want to prove one of the
formulas in ∆ from the formulas in Γ, and we want to make use of a formula P that we’ve
already proved. The fact that we’ve proved P is shown by the left hypothesis (of course,
unless the left hypothesis is itself a basic sequent, then in a completed proof there will be
more lines on top of the left hypothesis, showing the actual proof of the sequent). The fact
that we are allowed to use P in the proof of ∆ is shown in the right hand hypothesis. We
continue to build the proof up from there, using P .
Some other ways of getting formulas to the left of the ⊢ are shown in the rules (¬r) and
(⇒ r) below.
∀x ∈ S.P (x) The two rules for universally quantified formulas are:
P (v),Γ ⊢ ∆
∀x.P (x),Γ ⊢ ∆ (∀l)
Γ ⊢ ∆, P (x)
Γ ⊢ ∆,∀x.P (x) (∀r)
In the (∀r) rule, x must not be free in the conclusion.
Now, what’s going on here? In the (∀l) rule, the ∀x.P (x) is on the left side of the ⊢. Thus, we
are using it (along with some other formula, those in Γ) to prove something (∆). According
to the intuition above, in order to use ∀x.P (x), you can use it with any value, where v is
used to represent that value. In the hypothesis, you see the formula P (v) to the left of the
⊢. This is just P with v substituted for x. The use of this corresponds exactly to using the
fact that P is true of any value whatsoever, since we are using it with v, which is any value
of our choice.
In the (∀r) rule, the ∀x.P (x) is on the right side of the ⊢. Thus, we are proving it. Thus,
we need to prove it for a generic x. This is why the ∀x is gone in the hypothesis. The x
is still sitting somewhere in the P , but we’re just using it as a plain variable, not assuming
anything about it. And this explains the side condition too: “In the (∀r) rule, x must not
be free in the conclusion.” If x is not free in the conclusion, this means that x is not free in
the formulas in Γ or ∆. That means the only place the x occurs free in the hypothesis is in
P itself. This corresponds exactly with the requirement that we’re proving that P is true
of a generic x: if x were free in Γ or ∆, we would be assuming something about x, namely
that value of x is the same as the x used in those formulas.
Note that induction is not mentioned in the rules. This is because the sequent calculus used
here just deals with pure logic. In more complicated presentations of logic, it is explained
how to define new types via structural induction, and from there you get mechanisms to
allow you to do induction.
∃x ∈ S.P (x) The two rules for existentially quantified formulas are:
P (x),Γ ⊢ ∆
∃x.P (x),Γ ⊢ ∆ (∃l)
Γ ⊢ ∆, P (v)
Γ ⊢ ∆,∃x.P (x) (∃r)
In the (∃l) rule, x must not be free in the conclusion.
In (∃l), we are using ∃x.P (x). Thus we cannot assume anything about the value that the
formula says exists, so we just use it as x in the hypothesis. The side condition about x not
135
being free in the conclusions comes from the requirement not to assume anything about x
(since we don’t know what it is). If x isn’t free in the conclusion, then it’s not free in Γ or
∆. If it were free in Γ or ∆, then we would be assuming that the x used there is the same
as the x we’re assuming exists, and this isn’t allowed.
In (∃r), we are proving ∃x.P (x). Thus we must pick a particular value (call it v) and prove
P for that value. The value v is allowed to contain variables that are free in Γ or ∆, since
you can set it to anything you want.
¬P The rules for negation are:
Γ ⊢ ∆, P
¬P,Γ ⊢ ∆ (¬l)
P,Γ ⊢ ∆
Γ ⊢ ∆,¬P (¬r)
Let’s start with the right rule first. I said that the way to prove ¬P is to assume P and
derive a contradiction. If ∆ is the empty set, then this is exactly what this rule says: If
there are no formulas to the right hand side of the ⊢, then this means that the formulas in
Γ are inconsistent (that means, they cannot all be true at the same time). This means that
you have derived a contradiction. So if ∆ is the empty set, the hypothesis of the rule says
that, assuming P , you have obtained a contradiction. Thus, if you are absolutely certain
about all your other hypotheses, then you can be sure that P is not true. The best way to
understand the rule if ∆ is not empty is to write out the meaning of the sequents in terms
of the meaning of the sequent given by Equation 1 and work out the equivalence of the top
and bottom of the rule using the equivalences in your Logic and Proof notes.
The easiest way to understand (¬l) is again by using equivalences.
P ⇒ Q The two rules for implication are:
Γ ⊢ ∆, P Q,Γ ⊢ ∆
P ⇒ Q,Γ ⊢ ∆ (⇒ l)
P,Γ ⊢ ∆, Q
Γ ⊢ ∆, P ⇒ Q (⇒ r)
The rule (⇒ l) easily understood using the intuitive explanation of how to use P ⇒ Q given
above. First, we have to prove P . This is the left hypothesis. Then we can use Q, which is
what the right hypothesis says.
The right rule (⇒ r) is also easily understood. In order to prove P ⇒ Q, we assume P ,
then use this to prove Q. This is exactly what the hypothesis says.
P ∧Q The rules for conjunction are:
P,Q,Γ ⊢ ∆
P ∧Q,Γ ⊢ ∆ (∧l)
Γ ⊢ ∆, P Γ ⊢ ∆, Q
Γ ⊢ ∆, P ∧Q (∧r)
Both of these rules are easily explained by the intuition above. The left rule (∧l) says that
when you use P ∧Q, you can use P and Q. The right rule says that to prove P ∧Q you must
prove P , and you must prove Q. You may wonder why we need separate hypotheses for
the two different proofs. We can’t just put P,Q to the right of the ⊢ in a single hypothesis,
because that would mean that we’re proving one of the other of them (see the meaning of
the sequent given in Equation 1). So we need separate hypotheses to make sure that each
of P and Q has actually been proved.
P ∨Q The rules for disjunction are:
P,Γ ⊢ ∆ Q,Γ ⊢ ∆
P ∨Q,Γ ⊢ ∆ (∨l)
Γ ⊢ ∆, P,Q
Γ ⊢ ∆, P ∨Q (∨r)
136
These are also easily understood by the intuitive explanations above. The left rule says that
to prove something (namely, one of the formulas in ∆) using P ∨ Q, you need to prove it
using P , then prove it using Q. The right rule says that in order to prove P ∨ Q, you can
prove one or the other. The hypothesis says that you can prove one or the other, because
in order to show a sequent Γ ⊢ ∆ true, you only need to show that one of the formulas in
∆ is true.
137

