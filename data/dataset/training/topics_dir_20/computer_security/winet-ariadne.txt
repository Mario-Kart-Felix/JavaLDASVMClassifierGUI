Wireless Networks 11, 21–38, 2005
 2005 Springer Science + Business Media, Inc. Manufactured in The Netherlands.
Ariadne: A Secure On-Demand Routing Protocol for Ad Hoc
Networks
YIH-CHUN HU ∗ and ADRIAN PERRIG
Carnegie Mellon University, USA
DAVID B. JOHNSON
Rice University, USA
Abstract. An ad hoc network is a group of wireless mobile computers (or nodes), in which individual nodes cooperate by forwarding
packets for each other to allow nodes to communicate beyond direct wireless transmission range. Prior research in ad hoc networking
has generally studied the routing problem in a non-adversarial setting, assuming a trusted environment. In this paper, we present attacks
against routing in ad hoc networks, and we present the design and performance evaluation of a new secure on-demand ad hoc network
routing protocol, called Ariadne. Ariadne prevents attackers or compromised nodes from tampering with uncompromised routes consisting
of uncompromised nodes, and also prevents many types of Denial-of-Service attacks. In addition, Ariadne is efficient, using only highly
efficient symmetric cryptographic primitives.
Keywords: mobile ad hoc network, ad hoc network routing, secure routing, secure ad hoc network routing, Ariadne
1. Introduction
An ad hoc network is a group of wireless mobile computers
(or nodes), in which nodes cooperate by forwarding packets
for each other to allow them to communicate beyond direct
wireless transmission range. Ad hoc networks require no cen-
tralized administration or fixed network infrastructure such as
base stations or access points, and can be quickly and inex-
pensively set up as needed. They can be used in scenarios
in which no infrastructure exists, or in which the existing in-
frastructure does not meet application requirements for rea-
sons such as security or cost. Applications such as military
exercises, disaster relief, and mine site operation, for exam-
ple, may benefit from ad hoc networking, but secure and re-
liable communication is a necessary prerequisite for such ap-
plications.
Ad hoc network routing protocols are challenging to de-
sign, and secure ones are even more so. Wired network rout-
ing protocols such as BGP [54] do not handle well the type of
rapid node mobility and network topology changes that occur
in ad hoc networks; such protocols also have high communi-
cation overhead because they send periodic routing messages
even when the network is not changing. So far, researchers
in ad hoc networking have generally studied the routing prob-
lem in a non-adversarial network setting, assuming a trusted
environment; relatively little research has been done in a more
realistic setting in which an adversary may attempt to disrupt
the communication.
We focus here on on-demand (or reactive) routing proto-
cols for ad hoc networks, in which a node attempts to dis-
cover a route to some destination only when it has a packet to
∗ Corresponding author.
E-mail: yihchun@cs.cmu.edu
send to that destination. On-demand routing protocols have
been demonstrated to perform better with significantly lower
overheads than periodic (or proactive) routing protocols in
many situations [8,28,38,46], since the protocol is able to re-
act quickly to the many changes that may occur in node con-
nectivity, yet is able to reduce (or eliminate) routing overhead
in periods or areas of the network in which changes are less
frequent.
In this paper, we make two contributions to the area of
secure routing protocols for ad hoc networks. First, we give a
model for the types of attacks possible in such a system, and
we describe several new attacks on ad hoc network routing
protocols. Second, we present the design and performance
evaluation of a new on-demand secure ad hoc network routing
protocol, called Ariadne, that withstands node compromise
and relies only on highly efficient symmetric cryptography.
Relative to previous work in securing ad hoc network routing
protocols, Ariadne is more secure, more efficient, or more
general (e.g., Ariadne does not require trusted hardware and
does not require powerful processors).
Ariadne can authenticate routing messages using one of
three schemes: shared secret keys between all pairs of nodes,
shared secret keys between communicating nodes combined
with broadcast authentication, or digital signatures. We pri-
marily discuss here the use of Ariadne with TESLA [48,49],
an efficient broadcast authentication scheme that requires
loose time synchronization. Using pairwise shared keys
avoids the need for synchronization, but at the cost of higher
key setup overhead; broadcast authentication such as TESLA
also allows some additional protocol optimizations.
In section 2 of this paper, we summarize the basic opera-
tion of the Dynamic Source Routing protocol (DSR) [29–31],
on which we base the design of our new secure routing proto-
22 HU, PERRIG AND JOHNSON
col, Ariadne, and in section 3, we review the TESLA broad-
cast authentication protocol that we use in Ariadne. In sec-
tion 4, we describe our assumptions about the network, the
nodes, and security and key setup. We present an attacker
model and describe types of attacks in section 5. In section 6,
we present the design of Ariadne, and in section 7, we give
an initial simulation-based performance evaluation of a basic
form of Ariadne. In section 8, we discuss related work, and
in section 9, we present our conclusions.
2. Basic operation of DSR
We base the design of our secure on-demand ad hoc net-
work routing protocol, Ariadne, on the basic operation of
the Dynamic Source Routing protocol (DSR) [29–31], since
DSR operates entirely on-demand and has been well stud-
ied through both simulation and real testbed implementa-
tion [8,28,38,39]. Unlike periodic protocols (e.g., [4,45,52]),
which exchange routing information between nodes period-
ically in an attempt to always maintain routes to all desti-
nations, on-demand protocols exchange routing information
only when a new route is needed to deliver a packet to some
destination. On-demand approaches to routing in ad hoc net-
works often have lower overhead than periodic protocols,
since they transmit routing information only in response to
actual packets to be sent or in response to topology changes
affecting routes actively in use. Lower routing overhead al-
lows more of the available bandwidth and battery power to be
used towards delivery of application data. In a secure routing
protocol, reduced overhead has the added benefit of reducing
the number of routing packets that need to be authenticated,
thereby reducing the computational overhead needed for se-
curity. The operation of DSR is divided into two activities:
Route Discovery and Route Maintenance. In this section, we
describe the basic form of Route Discovery and Route Main-
tenance in DSR.
In DSR, when a node has a packet to send to some destina-
tion and does not currently have a route to that destination in
its Route Cache, the node initiates Route Discovery to find a
route; this node is known as the initiator of the Route Discov-
ery, and the destination of the packet is known as the Discov-
ery’s target, as illustrated in figure 1. The initiator (node A)
transmits a ROUTE REQUEST packet as a local broadcast,
specifying the target (node D) and a unique identifier from
the initiator A. Each node receiving the ROUTE REQUEST,
if it has recently seen this request identifier from the initia-
tor or if its own address is already present in an address list
in the REQUEST, discards the REQUEST. Otherwise, the ap-
pends its own node address to the address list in the REQUEST
and rebroadcasts the REQUEST. When the ROUTE REQUEST
reaches its target node, the target sends a ROUTE REPLY back
to the initiator of the REQUEST, including a copy of the ac-
cumulated list of addresses from the REQUEST. When the
REPLY reaches the initiator of the REQUEST, it caches the
new route in its Route Cache.
Route Maintenance is the mechanism by which a node
sending a packet along a specified route to some destina-
Figure 1. Example of DSR Route Discovery, in which initiator node A is
attempting to discover a route to target node D.
Figure 2. Example of DSR Route Maintenance, in which intermedi-
ate node C detects a broken link to D when forwarding a packet from
source node A.
tion detects if that route has broken, for example because
two nodes in it have moved too far apart; an example of
Route Maintenance is shown in figure 2. DSR is based on
source routing: when sending a packet, the originator lists
in the header of the packet the complete sequence of nodes
through which the packet is to be forwarded. Each node along
the route forwards the packet to the next hop indicated in
the packet’s header, and attempts to confirm that the packet
was received by that next node; a node may confirm this by
means of a link-layer acknowledgment, passive acknowledg-
ment [32], or network-layer acknowledgment. If, after a lim-
ited number of local retransmissions of the packet, a node in
the route is unable to make this confirmation (such as node C
in figure 2), it returns a ROUTE ERROR to the original source
of the packet (node A), identifying the link from itself to the
next node (node D) as broken. The sender then removes this
broken link from its Route Cache; for subsequent packets to
this destination, the sender may use any other route to that
destination in its Cache, or it may attempt a new Route Dis-
covery for that target if necessary.
The DSR protocol also defines a number of optimiza-
tions to these mechanisms (e.g., [19,20,29–31,35]). Some
of these optimizations, such as flow state [20], are relatively
easy to secure (flow state requires only broadcast authentica-
tion of control messages), whereas others, such as link-state
caching [19], are more difficult (link-state caching requires
some mechanism to authenticate links, but Ariadne only at-
tempts to authenticate nodes). The use of these DSR opti-
mizations is beyond the scope of this paper; we secure here
only a basic version of DSR, with a limited path cache and
without these optimizations.
3. Overview of TESLA
In this paper, we describe Ariadne primarily using the TESLA
[48,49] broadcast authentication protocol for authenticating
routing messages, since TESLA is efficient and adds only a
single message authentication code (MAC) to a message for
broadcast authentication. Adding a MAC (computed with a
shared key) to a message can provide secure authentication
in point-to-point communication; for broadcast communica-
ARIADNE 23
tion, however, multiple receivers need to know the MAC key
for verification, which would also allow any receiver to forge
packets and impersonate the sender. Secure broadcast au-
thentication thus requires an asymmetric primitive, such that
the sender can generate valid authentication information, but
the receivers can only verify the authentication information.
TESLA differs from traditional asymmetric protocols such as
RSA [55] in that TESLA achieves this asymmetry from clock
synchronization and delayed key disclosure, rather than from
computationally expensive one-way trapdoor functions.
To use TESLA for authentication, each sender chooses a
random initial key KN and generates a one-way key chain
by repeatedly computing a one-way hash function H on this
starting value: KN−1 = H [KN ], KN−2 = H [KN−1], . . . . In
general, Ki = H [Ki+1] = HN−i[KN ]. To compute any pre-
vious key Kj from a key Ki , j < i, a node uses the equation
Kj = Hi−j [Ki]. To authenticate any received value on the
one-way chain, a node applies this equation to the received
value to determine if the computed value matches a previous
known authentic key on the chain. Coppersmith and Jakob-
sson present efficient mechanisms for storing and generating
values of hash chains [13].
Each sender pre-determines a schedule of the time at which
it publishes (or discloses) each key of its one-way key chain,
in the reverse order from generation; that is, a sender pub-
lishes its keys in the order K0,K1, . . . ,KN . A simple key
disclosure schedule, for example, would be to publish key Ki
at time T0+i ·I , where T0 is the time at which K0 is published,
and I is the key publication interval.
TESLA relies on a receiver’s ability to determine which
keys a sender may have already published, based on loose
time synchronization between nodes. Let  be the maxi-
mum time synchronization error between any two nodes; the
value  must be known by all nodes. To send a packet, the
sender uses a pessimistic upper bound τ on the end-to-end
network delay between nodes and picks a key Ki from its one-
way key chain which, at the time any receiver is expected to
receive the packet, the receiver will believe has not yet been
published. For example, the sender could choose a key Ki
that it will not publish until a time at least τ + 2 in the fu-
ture; the value 2 is used here because the receiver’s clock
may be ahead of the sender’s clock by , so at time ts at the
sender, it is ts +  at the receiver. In sending the packet, the
sender adds a message authentication code (MAC), computed
using key Ki , to the packet. When the packet reaches the re-
ceiver, it will be ts + τ + , and the receiver will discard the
packet if the key might have been published already. Since
the receiver knows the sender’s clock may be faster by , the
receiver will reject the packet unless it is received at least 
before the scheduled key release time, so the receiver must be
able to verify that the key is released at time ts + τ + 2 or
later.
When a receiver receives a packet authenticated with
TESLA, it first verifies the TESLA security condition that the
key Ki used to authenticate the packet cannot yet have been
published. For example, if the local packet arrival time is
tr, and the receiver knows that the earliest time at which the
sender will disclose the key Ki is T0 + i · I , the receiver needs
to verify only that tr  (T0 + i · I − ), implying that Ki
has not yet been published. Otherwise, the sender may have
already published Ki and an attacker may have forged the
packet contents; the receiver thus discards the packet. How-
ever, if this check is successful, the receiver buffers the packet
and waits for the sender to publish key Ki . When the receiver
then receives Ki , it authenticates Ki as described above, and
then authenticates stored packets that were authenticated with
any key Kj , where j  i. TESLA remains secure even if
the end-to-end delay is larger than τ , although some receivers
may be required to discard the packet.
4. Assumptions
4.1. Notation
We use the following notation to describe security protocols
and cryptographic operations:
• A, B are principals, such as communicating nodes.
• KAB and KBA denote the secret MAC keys shared be-
tween A and B (one key for each direction of commu-
nication).
• MACKAB (M) denotes the computation of the message au-
thentication code (MAC) of message M with the MAC key
KAB , for example, using the HMAC algorithm [3].
For notational convenience we assume hash and MAC
functions that take a variable number of arguments, simply
concatenating them in computing the function.
4.2. Network assumptions
The physical layer of a wireless network is often vulnerable
to denial of service attacks such as jamming. Mechanisms
such as spread spectrum [51] have been extensively studied
as means of providing resistance to physical jamming, and
we thus disregard such physical layer attacks here.
We assume that network links are bidirectional; that is, if
a node A is able to receive packets transmitted directly by
some node B, then B is able to receive packets transmitted
directly by A. It is possible to use a network with unidirec-
tional links if such links are detected and avoided; such de-
tection may also otherwise be necessary, since many wireless
Medium Access Control protocols require bidirectional links,
as they make use of bidirectional exchange of several link-
layer frames between a source and destination to help avoid
collisions and improve reliability [6,27].
Medium Access Control protocols are also often vulner-
able to attack. For example, in IEEE 802.11, an attacker
can paralyze nodes in its neighborhood by sending Clear-To-
Send (CTS) frames periodically, setting the “Duration” field
of each frame to at least the interval between such frames.
Less sophisticated Medium Access Control protocols, such
as ALOHA and Slotted ALOHA [1], are not vulnerable to
such attacks but have lower efficiency, and the development
24 HU, PERRIG AND JOHNSON
of secure Medium Access Control protocols is an active area
of research. In this paper, we disregard attacks on Medium
Access Control protocols.
We assume that the network may drop, corrupt, reorder, or
duplicate packets in transmission.
When Ariadne is used with a broadcast authentication pro-
tocol, we naturally inherit all of that protocol’s assumptions.
For example, when TESLA is used, each node in the network
must be able to estimate the end-to-end transmission time to
any other node in the network; TESLA permits this value to
be chosen adaptively and pessimistically. When this time is
chosen to be too large, authentication delay increases, reduc-
ing protocol responsiveness; when it is chosen to be too small,
authentic packets may be rejected, but security is not compro-
mised.
4.3. Node assumptions
The resources of different ad hoc network nodes may vary
greatly, from nodes with very little computational resources,
to resource-rich nodes equivalent in functionality to high-
performance workstations. To make our results as gen-
eral as possible, we have designed Ariadne to support
nodes with few resources, such as Palm PDAs or RIM
pagers.
Most previous work on secure ad hoc network routing re-
lies on asymmetric cryptography such as digital signatures
[64,66]. However, computing such signatures on resource-
constrained nodes is expensive, and we assume that nodes
in the ad hoc network may be so constrained. For exam-
ple, Brown et al. analyze the computation time of digital sig-
nature algorithms on various platforms [9]; on a Palm Pilot
PDA (16 MHz Motorola 68000 “Dragonball” processor) or
RIM pager (10 MHz custom Intel 386 processor), a 512-bit
RSA [55] signature generation takes 2.4–5.8 seconds, and sig-
nature verification takes 0.1–0.6 seconds, depending on the
public exponent.
When Ariadne is used with TESLA for broadcast au-
thentication, we assume that all nodes have loosely syn-
chronized clocks, such that the difference between any two
nodes’ clocks does not exceed ; the value of  must
be known by all nodes in the network. Accurate time syn-
chronization can be maintained, for example, with off-the-
shelf hardware based on GPS [12,61], although the time
synchronization signal itself may be subject to attack [15].
We assume that nodes compensate clock drift with peri-
odic re-synchronization. Microcomputer-compensated crys-
tal oscillators [5] can provide sub-second accuracy for sev-
eral months; if normal crystal oscillators are used, the value
of  can be chosen to be as large as necessary, though a
corresponding reduction in protocol responsiveness will re-
sult.
We do not assume trusted hardware such as tamperproof
modules. Secure routing with trusted hardware is much sim-
pler, since node compromise is assumed to be impossible
(section 6.1).
4.4. Security assumptions and key setup
The security of Ariadne relies on the secrecy and authenticity
of keys stored in nodes. Ariadne relies on the following keys
to be set up, depending on which authentication mechanism
is used:
• If pairwise shared secret keys are used, we assume a mech-
anism to set up the necessary n(n + 1)/2 keys, if n is the
number of nodes in the network.
• If TESLA is used, we assume a mechanism to set up shared
secret keys between pairs of nodes that communicate, and
to distribute one authentic public TESLA key for each
node.
• If digital signatures are used, we assume a mechanism to
distribute one authentic public key for each node.
To set up shared secret keys, we can use a variety of
mechanisms. For example, a key distribution center may
be used, which shares a secret key with each node and
sets up shared secret keys with communicating nodes, such
as in Kerberos [36] or SPINS [50]; shared secret keys
can be bootstrapped from a Public Key Infrastructure (PKI)
using protocols such as TLS [14]; or shared secret keys
can be pre-loaded at initialization, possibly through physi-
cal contact [60]. Menezes et al. discuss several key setup
protocols [42].
To set up authentic public keys, we can either embed all
public keys at initialization in each node, or assume a PKI
and embed the trusted Certification Authority’s public key in
each node and then use that key to authenticate the public
keys of other nodes. Another approach proposed by Hubaux
et al. [26] bootstraps trust relationships based on PGP-like
certificates.
Ariadne also requires that each node have an authentic el-
ement from the Route Discovery chain (section 6.5) of every
node initiating Route Discoveries. These keys can be set up
in the same way as a public key.
Key setup is an expensive operation. Setting up shared
secret keys requires authenticity and confidentiality, whereas
setting up public keys only requires authenticity. Further-
more, fewer public keys are generally needed, because in a
network with n nodes, only n public keys are needed and can
potentially be broadcast, whereas n(n+1)/2 secret keys need
to be set up in the case of pairwise shared secret keys. In sec-
tion 4.5, we describe a mechanism to set up these keys with-
out relying on Ariadne, thus avoiding the circular dependency
between key setup and the routing protocol.
4.5. Establishing authenticated keys using a trusted KDC
Although Ariadne does not require a trusted Key Distribution
Center (KDC) node in the ad hoc network, some ad hoc net-
works may contain a KDC as a mechanism for authenticated
key setup between pairs of nodes as need, as mentioned in
section 4.4. A challenge to this type of key setup is the need
for routing to be established before conventional KDC proto-
cols can be used. We describe here how this type of key setup
ARIADNE 25
can be done, if desired, with no established routing within
Ariadne.
As described in section 4.1, we assume that each node A
shares secret MAC keys KAT and KT A between itself and the
trusted KDC T for use with a message authentication code
(MAC) algorithm such as HMAC [3] (one key for each di-
rection of communication). For use with this method of es-
tablishing authenticated keys using a trusted KDC, we further
assume that each node A similarly shares secret encryption
keys K ′AT and K ′T A between itself and the KDC T . These
shared keys KAT , K ′AT , KT A, and K ′T A for node A could, for
example, all be derived by A and the KDC T using a single
shared a master secret key XAT = XT A (no direction infor-
mation is associated with this key) using a Pseudo-Random
Function (PRF) [16]: if F is a PRF, then let KAT = FXAT (1),
K ′AT = FXAT (2), KT A = FXAT (3), and K ′T A = FXAT (4).
We also assume here that each node can obtain an authen-
tic TESLA key of the KDC; that the KDC has an authentic
TESLA key for each other node; and if MW-Chains [24] are
used to thwart ROUTE REQUEST floods as described in sec-
tion 6.3, that each node can obtain an authentic MW-Chain
head for the KDC.
To bootstrap authenticated keys between pairs of nodes,
the KDC node initiates a Route Discovery with a special, re-
served address (not the address of any actual node) as the tar-
get of the Discovery. The Route Discovery is processed by
each node as in Ariadne, except that each node receiving this
special REQUEST for the first time also returns a ROUTE RE-
PLY. The KDC can then use each returned route to send au-
thenticated keys to each node in the network. Alternatively,
this special Route Discovery procedure can be repeated pe-
riodically; when a node needs a shared key with some other
node, it waits until the next such special Discovery is initi-
ated by the KDC node, and at that time includes as part of
its ROUTE REPLY to the KDC the list of nodes for which it
needs authenticated keys.
5. Ad hoc network routing security
In this section, we define a taxonomy of types of attackers and
discuss specific attacks against ad hoc network routing. This
approach allows us to categorize the security of an ad hoc
network routing protocol based on the strongest attacker it
withstands.
5.1. Attacker model
We consider two main attacker classes, passive and active.
The passive attacker does not send messages; it only eaves-
drops on the network. Passive attackers are mainly threats
against the privacy or anonymity of communication, rather
than against the functioning of the network or its routing pro-
tocol, and thus we do not discuss them further here.
An active attacker injects packets into the network and
generally also eavesdrops. We characterize the attacker based
on the number of nodes it owns in the network, and based on
the number of those that are good nodes it has compromised.
We assume that the attacker owns all the cryptographic key
information of compromised nodes and distributes it among
all its nodes. We denote such an attacker Active-n-m, where n
is the number of nodes it has compromised and m is the num-
ber of nodes it owns. We propose the following attacker hier-
archy (with increasing strength) to measure routing protocol
security: Active-0-1 (the attacker owns one node), Active-0-x
(the attacker owns x nodes), Active-1-x (the attacker owns
one compromised node and distributes the cryptographic keys
to its x − 1 other nodes), and Active-y-x. In addition, we
call an attacker that has compromised nodes an Active-VC
attacker if it owns all nodes on a vertex cut through the net-
work that partitions the good nodes into multiple sets, forc-
ing good nodes in different partitions to communicate only
through an attacker node. This attacker is particularly pow-
erful, as it controls all traffic between nodes of the disjoint
partitions.
Our protocol does not require a trusted Key Distribution
Center (KDC) in the network, but some ad hoc networks may
use one for key setup, as mentioned in section 4.4. We do not
consider the case in which an attacker compromises the KDC,
since the KDC is a central trust entity, and a compromised
KDC compromises the entire network.
5.2. General attacks on ad hoc network routing protocols
Attacks on ad hoc network routing protocols generally fall
into one of two categories: routing disruption attacks and
resource consumption attacks. In a routing disruption at-
tack, the attacker attempts to cause legitimate data packets
to be routed in dysfunctional ways. In a resource consump-
tion attack, the attacker injects packets into the network in
an attempt to consume valuable network resources such as
bandwidth, or to consume node resources such as memory
(storage) or computation power. From an application-layer
perspective, both attacks are instances of a Denial-of-Service
(DoS) attack.
An example of a routing disruption attack is for an attacker
to send forged routing packets to create a routing loop, caus-
ing packets to traverse nodes in a cycle without reaching their
destinations, consuming energy and available bandwidth. An
attacker may similarly create a routing black hole, in which
all packets are dropped: by sending forged routing packets,
the attacker could cause all packets for some destination to be
routed to itself and could then discard them, or the attacker
could cause the route at all nodes in an area of the network to
point “into” that area when in fact the destination is outside
the area. As a special case of a black hole, an attacker could
create a gray hole, in which it selectively drops some pack-
ets but not others, for example, forwarding routing packets
but not data packets. An attacker may also attempt to cause
a node to use detours (suboptimal routes) or may attempt to
partition the network by injecting forged routing packets to
prevent one set of nodes from reaching another. An attacker
may attempt to make a route through itself appear longer by
26 HU, PERRIG AND JOHNSON
adding virtual nodes to the route; we call this attack gratuitous
detour, as a shorter route exists and would otherwise have
been used. In ad hoc network routing protocols that attempt
to keep track of perceived malicious nodes in a “blacklist” at
each node, such as is done in watchdog and pathrater [40], an
attacker may malign a good node, causing other good nodes
to add that node to their blacklists, thus avoiding that node in
routes.
A more subtle type of routing disruption attack is the cre-
ation of a wormhole in the network [25], using a pair of at-
tacker nodes A and B linked via a private network connec-
tion. Every packet (or selected packets) that A receives from
the ad hoc network, A forwards through the wormhole to B,
to then be rebroadcast by B; similarly, B may send all packets
to A. Such an attack potentially disrupts routing by short cir-
cuiting the normal flow of routing packets, and the attackers
may also create a virtual vertex cut that they control.
The rushing attack is a malicious attack that is targeted
against on-demand routing protocols that find routes through
a Route Discovery protocol and use duplicate suppression
of the ROUTE REQUEST messages in that protocol at each
node [23]. An attacker disseminates ROUTE REQUESTs
quickly throughout the network, suppressing any later legit-
imate ROUTE REQUESTs when nodes drop them due to the
duplicate suppression.
An example of a resource consumption attack is for an at-
tacker to inject extra data packets into the network, which
will consume bandwidth resources when forwarded, espe-
cially over detours or routing loops. Similarly, an attacker
can inject extra control packets into the network, which may
consume even more bandwidth or computational resources
as other nodes process and forward such packets. With ei-
ther of these attacks, an Active-VC attacker can try to ex-
tract maximum resources from the nodes on both sides of
the vertex cut; for example, it might forward only routing
packets and not data packets, such that the nodes waste en-
ergy forwarding packets to the vertex cut, only to have them
dropped.
If a routing protocol can prevent an attacker from inserting
routing loops, and if a maximum route length can be enforced,
then an attacker that can inject extra data packets has limited
attack power. In particular, if routes are limited to ν hops,
then each data packet transmitted by the attacker causes only
at most a fixed number of additional transmissions; more gen-
erally, if at most one control packet can be sent in response to
each data packet (e.g., a ROUTE ERROR), and that control
packet is limited to ν hops, then an individual data packet
can cause only 2ν individual transmissions. We consider an
attack a DoS attack only if the ratio between the total work
performed by nodes in the network and the work performed
by the attacker is on the order of the number of nodes in the
network. An example of a DoS attack is for the attacker to
send a single packet that results in a packet flood throughout
the network.
6. Ariadne
6.1. Design goals
We aim for resilience against Active-1-x and Active-y-x at-
tackers. Ideally, the probability that the routing protocol de-
livers messages degrades gracefully when nodes fail or are
compromised. Our goal is to design simple and efficient
mechanisms achieving high attack robustness. These mecha-
nisms should be sufficiently general to allow application to a
wide range of routing protocols.
Defending against an Active-0-x attacker is relatively easy.
A network-wide shared secret key limits the attacker to re-
playing messages. Thus the main attacks remaining are
the wormhole and rushing attacks (section 5.2). Packet
leashes [25] can prevent both attacks because they prevent
an Active-0-x attacker from retransmitting packets. These
approaches also trivially secure a network routing protocol
that uses tamperproof hardware, since the strongest attacker
in such an environment is an Active-0-x attacker, assuming all
routing and security functionality (including packet leashes)
is implemented in the secure hardware.
Most routing disruption attacks we present in section 5.2
are caused by malicious injection or altering of routing data.
To prevent these attacks, each node that interprets routing in-
formation must verify the origin and integrity of that data;
that is, it must authenticate the data. Ideally, the initiator of
the Route Discovery can verify the origin of each individual
data field in the ROUTE REPLY.
We need an authentication mechanism with low computa-
tion and communication overhead. An inefficient authentica-
tion mechanism could be exploited by an attacker to perform
a Denial-of-Service (DoS) attack by flooding nodes with ma-
licious messages, overwhelming them with the cost of veri-
fying authentication. Thus, for point-to-point authentication
of a message, we use a message authentication code (MAC)
(e.g., HMAC [3]) and a shared key between the two parties.
However, setting up the shared keys between the initiator and
all the nodes on the path to the target may be expensive. We
thus also propose using the TESLA broadcast authentication
protocol (section 3) for authentication of nodes on the rout-
ing path. However, we also discuss MAC authentication with
pairwise shared keys, for networks capable of inexpensive key
setup, and we discuss digital signatures for authentication, for
networks with extremely powerful nodes.
As a general design principle, a node trusts only itself
for acquiring information about which nodes in the network
are malicious. This approach helps avoid blackmail attacks,
where an attacker constructs information to make a legitimate
node appear malicious. In our design, we assume that a sender
trusts the destination with which it communicates, for authen-
ticating nodes on the path between them. This assumption is
straightforward, as the destination node can control all com-
munication with the sender anyway. However, the destina-
tion node can potentially blackmail nodes on the path to the
sender. The sender thus needs to keep a separate blacklist for
each destination.
ARIADNE 27
In general, ad hoc network routing protocols do not need
secrecy or confidentiality. These properties are required to
achieve privacy or anonymity for the sender of messages.
Even in the Internet, it is challenging to achieve sender
anonymity, and this area is still the subject of active research.
Our protocol does not prevent an attacker from injecting
data packets. As we described in section 5.2, injecting a
packet results in a DoS attack only if it floods the network.
Since data packets cannot flood the network, we do not ex-
plicitly protect against packet injection. However, malicious
ROUTE REQUEST messages that flood the network do clas-
sify as a DoS attack, and we thus prevent this attack with a
separate mechanism that we describe in section 6.5.
6.2. Basic Ariadne Route Discovery
In this section, we describe the basic operation of Route Dis-
covery in Ariadne. We first overview the features of the
protocol in three stages: we present a mechanism that en-
ables the target of a Route Discovery to verify the authentic-
ity of the ROUTE REQUEST; we then present three alternative
mechanisms for authenticating data in ROUTE REQUESTs and
ROUTE REPLYs; and we present an efficient per-hop hashing
technique to verify that no node is missing from the node list
in the REQUEST. After this overview, we present in detail
the operation of Route Discovery in Ariadne when TESLA
is used as the authentication mechanism. In the following
discussion, we assume that some initiator node S performs a
Route Discovery for a target node D, and that they share the
secret keys KSD and KDS , respectively, for message authen-
tication in each direction.
Target authenticates ROUTE REQUESTs. To convince the
target of the legitimacy of each field in a ROUTE RE-
QUEST, the initiator simply includes in the REQUEST a MAC
computed with key KSD over unique data, for example a
timestamp. The target can easily verify the authenticity and
freshness of the ROUTE REQUEST using the shared key KSD .
Three techniques for route data authentication. In a Route
Discovery, the initiator wants to authenticate each individual
node in the node list of the ROUTE REPLY. A secondary
requirement is that the target can authenticate each node in
the node list of the ROUTE REQUEST, so that it will return a
ROUTE REPLY only along paths that contain only legitimate
nodes. In this section, we present three alternative techniques
to achieve node list authentication: the TESLA protocol, dig-
ital signatures, and standard MACs.
When Ariadne Route Discovery is used with TESLA, each
hop authenticates the new information in the REQUEST. The
target buffers and does not send the REPLY until intermedi-
ate nodes can release the corresponding TESLA keys. The
TESLA security condition is verified at the target, and the tar-
get includes a MAC in the REPLY to certify that the security
condition was met. TESLA requires each packet sender to
choose a a pessimistic upper bound τ on the end-to-end net-
work delay between nodes for sending this packet, in order to
select the TESLA key it will use to authenticate it. Choices
of τ do not affect the security of the protocol, although val-
ues that are too small may cause the Route Discovery to fail.
Ariadne can choose τ adaptively, by increasing τ when a Dis-
covery fails. In addition, the target of the Discovery could
provide feedback in the ROUTE REPLY when τ was chosen
too large.
If Ariadne Route Discovery is used with digital signa-
tures, instead, the authentication differs in that no Route Dis-
covery chain element is required (section 6.5). In addition,
the MAC list in the ROUTE REQUEST (described below) be-
comes a signature list, where the data used to compute the
MAC is instead used to compute a signature. Rather than
computing the target MAC using a Message Authentication
Code, a signature is used. Finally, no key list (also described
below) is required in the REPLY.
Ariadne Route Discovery using MACs is the most efficient
of the three alternative authentication mechanisms, but it re-
quires pairwise shared keys between all nodes. When Ariadne
is used in this way, the MAC list in the ROUTE REQUEST is
computed using a key shared between the target and the cur-
rent node, rather than using the TESLA key of the current
node. The MACs are verified at the target and are not re-
turned in the ROUTE REPLY. As a result, the target MAC is
not computed over the MAC list in the REQUEST. In addition,
no key list is required in the REPLY.
Per-hop hashing. Authentication of data in routing mes-
sages is not sufficient, as an attacker could remove a node
from the node list in a ROUTE REQUEST. We use one-way
hash functions to verify that no hop was omitted, and we call
this approach per-hop hashing. To change or remove a pre-
vious hop, an attacker must either hear a ROUTE REQUEST
without that node listed, or it must be able to invert the one-
way hash function.
Ariadne Route Discovery with TESLA. We now describe in
detail the version of Ariadne Route Discovery using TESLA
broadcast authentication. We assume that every end-to-end
communicating source–destination pair of nodes A and B
share the MAC keys KAB and KBA. We also assume that
every node has a TESLA one-way key chain, and that all
nodes know an authentic key of the TESLA one-way key
chain of each other node (for authentication of subsequent
keys, as described in section 3). Route Discovery has two
stages: the initiator floods the network with a ROUTE RE-
QUEST, and the target returns a ROUTE REPLY. To secure
the ROUTE REQUEST packet, Ariadne provides the following
properties: (1) the target node can authenticate the initiator
(using a MAC with a key shared between the initiator and
the target); (2) the initiator can authenticate each entry of the
path in the ROUTE REPLY (each intermediate node appends
a MAC with its TESLA key); and (3) no intermediate node
can remove a previous node in the node list in the REQUEST
or REPLY (a one-way function prevents a compromised node
from removing a node from the node list).
A ROUTE REQUEST packet in Ariadne contains eight
fields: 〈ROUTE REQUEST, initiator, target, id, time interval,
28 HU, PERRIG AND JOHNSON
S: h0 = MACKSD(REQUEST, S,D, id, ti)
S → ∗: 〈REQUEST, S,D, id, ti, h0, (), ()〉
A: h1 = H [A,h0]
MA = MACKAti (REQUEST, S,D, id, ti, h1, (A), ())
A → ∗: 〈REQUEST, S,D, id, ti,h1, (A), (MA)〉
B: h2 = H [B, h1]
MB = MACKBti (REQUEST, S,D, id, ti, h2, (A,B), (MA))
B → ∗: 〈REQUEST, S,D, id, ti,h2, (A,B), (MA,MB)〉
C: h3 = H [C, h2]
MC = MACKCti (REQUEST, S,D, id, ti, h3, (A,B,C), (MA,MB))
C → ∗: 〈REQUEST, S,D, id, ti,h3, (A,B,C), (MA,MB,MC)〉
D: MD = MACKDS (REPLY,D, S, ti, (A,B,C), (MA,MB,MC))
D → C: 〈REPLY,D, S, ti, (A,B,C), (MA,MB,MC),MD, ()〉
C → B: 〈REPLY,D, S, ti, (A,B,C), (MA,MB,MC),MD, (KCti)〉
B → A: 〈REPLY,D, S, ti, (A,B,C), (MA,MB,MC),MD, (KCti,KBti)〉
A → S: 〈REPLY,D, S, ti, (A,B,C), (MA,MB,MC),MD, (KCti,KBti,KAti)〉
Figure 3. Route Discovery example in Ariadne. The initiator node S is attempting to discover a route to the target node D. The bold underlined font indicates
changed message fields, relative to the previous message of that type.
hash chain, node list, MAC list〉. The initiator and target are
set to the address of the initiator and target nodes, respec-
tively. As in DSR, the initiator sets the id to an identifier that
it has not recently used in initiating a Route Discovery. The
time interval is the TESLA time interval at the pessimistic
expected arrival time of the REQUEST at the target, account-
ing for clock skew; specifically, given τ , a pessimistic transit
time, the time interval could be set to any time interval for
which the key is not released within the next τ + 2 time.
The initiator of the REQUEST then initializes the hash chain
to MACKSD(initiator, target, id, time interval) and the node
list and MAC list to empty lists.
When any node A receives a ROUTE REQUEST for which
it is not the target, the node checks its local table of
〈initiator, id〉 values from recent REQUESTs it has received,
to determine if it has already seen a REQUEST from this same
Route Discovery. If it has, the node discards the packet, as in
DSR. The node also checks whether the time interval in the
REQUEST is valid: that time interval must not be too far in the
future, and the key corresponding to it must not have been dis-
closed yet. If the time interval is not valid, the node discards
the packet. Otherwise, the node modifies the REQUEST by ap-
pending its own address, A, to the node list in the REQUEST,
replacing the hash chain field with H [A, hash chain], and ap-
pending a MAC of the entire REQUEST to the MAC list. The
node uses the TESLA key KAi to compute the MAC, where
i is the index for the time interval specified in the REQUEST.
Finally, the node rebroadcasts the modified REQUEST, as in
DSR.
When the target node receives the ROUTE REQUEST, it
checks the validity of the REQUEST by determining that the
keys from the time interval specified have not been disclosed
yet, and that the hash chain field is equal to
H
[
ηn,H
[
ηn−1,H
[
. . . , H
[
η1, MACKSD(initiator, target, id,
time interval)
]
. . .
]]]
,
where ηi is the node address at position i of the node list in
the REQUEST, and where n is the number of nodes in the
node list. If the target node determines that the REQUEST is
valid, it returns a ROUTE REPLY to the initiator, containing
eight fields: 〈ROUTE REPLY, target, initiator, time interval,
node list, MAC list, target MAC, key list〉. The target, initia-
tor, time interval, node list, and MAC list fields are set to
the corresponding values from the ROUTE REQUEST, the tar-
get MAC is set to a MAC computed on the preceding fields in
the REPLY with the key KDS , and the key list is initialized to
the empty list. The ROUTE REPLY is then returned to the ini-
tiator of the REQUEST along the source route obtained by re-
versing the sequence of hops in the node list of the REQUEST.
A node forwarding a ROUTE REPLY waits until it is able
to disclose its key from the time interval specified; it then
appends its key from that time interval to the key list field in
the REPLY and forwards the packet according to the source
route indicated in the packet. Waiting delays the return of
the ROUTE REPLY but does not consume extra computational
power.
When the initiator receives a ROUTE REPLY, it verifies that
each key in the key list is valid, that the target MAC is valid,
and that each MAC in the MAC list is valid. If all of these
tests succeed, the node accepts the ROUTE REPLY; otherwise,
it discards it. Figure 3 shows an example of Route Discovery
in Ariadne.
6.3. Basic Ariadne Route Maintenance
Route Maintenance in Ariadne is based on DSR as described
in section 2. A node forwarding a packet to the next hop
along the source route returns a ROUTE ERROR to the orig-
inal sender of the packet if it is unable to deliver the packet
to the next hop after a limited number of retransmission at-
tempts. In this section, we discuss mechanisms for securing
ROUTE ERRORs, but we do not consider the case of attackers
not sending ERRORs (section 6.4).
ARIADNE 29
To prevent unauthorized nodes from sending ERRORs, we
require that an ERROR be authenticated by the sender. Each
node on the return path to the source forwards the ERROR. If
the authentication is delayed, for example, when TESLA is
used, each node that will be able to authenticate the ERROR
buffers it until it can be authenticated.
When using broadcast authentication, such as TESLA,
a ROUTE ERROR packet in Ariadne contains six fields:
〈ROUTE ERROR, sending address, receiving address, time
interval, error MAC, recent TESLA key〉. The sending address
is set to the address of the intermediate node encountering the
error, and the receiving address is set to the intended next hop
destination of the packet it was attempting to forward. For
example, if node B is attempting to forward a packet to the
next hop node C, if B is unable to deliver the packet to C,
node B sends a ROUTE ERROR to the original sender of the
packet; the the sending address in this example is set to B,
and the receiving address is set to C. The time interval in
the ROUTE ERROR is set to the TESLA time interval at the
pessimistic expected arrival time of the ERROR at the des-
tination, and the error MAC field is set to the MAC of the
preceding fields of the ROUTE ERROR, computed using the
sender of the ROUTE ERROR’s TESLA key for the time inter-
val specified in the ERROR. The recent TESLA key field in the
ROUTE ERROR is set to the most recent TESLA key that can
be disclosed for the sender of the ERROR. We use TESLA for
authenticating ROUTE ERRORs so that forwarding nodes can
also authenticate and process the ROUTE ERROR.
When sending a ROUTE ERROR, the destination of the
packet is set to the source address of the original packet trig-
gering the ERROR, and the ROUTE ERROR is forwarded to-
ward this node in the same way as a normal data packet;
the source route used in sending the ROUTE ERROR packet
is obtained by reversing the source route from the header
of the packet triggering the ERROR. Each node that is ei-
ther the destination of the ERROR or forwards the ERROR
searches its Route Cache for all routes it has stored that use
the 〈sending address, receiving address〉 link indicated by the
ERROR. If the node has no such routes in its Cache, it does
not process the ROUTE ERROR further (other than forwarding
the packet, if it is not the destination of the ERROR). Other-
wise, the node checks whether the time interval in the ERROR
is valid: that time interval must not be too far into the future,
and the key corresponding to it must not have been disclosed
yet; if the time interval is not valid, the node similarly does
not process the ROUTE ERROR further.
If all of the tests above for the ROUTE ERROR succeed, the
node checks the authentication on the ERROR, based on the
sending node’s TESLA key for the time interval indicated in
the ERROR. To do so, the node saves the information from the
ERROR in memory until it receives a disclosed TESLA key
from the sender that allows this. During this time, the node
continues to use the routes in its Route Cache without modifi-
cation from this ERROR. If the sender stops using that route,
there will be no need to complete the authentication of the
ERROR. Otherwise, each subsequent packet sent along this
route by this node will trigger an additional ROUTE ERROR,
and once the TESLA time interval used in the first ERROR
ends, the recent TESLA key field in the next ERROR returned
will allow authentication of this first ERROR; alternatively,
the node could also explicitly request the needed TESLA key
from the sender once the interval ends. Once the ROUTE ER-
ROR has been authenticated, the node removes from its Route
Cache all routes using the indicated link, and also discards
any saved information for other ERRORs for which, as a re-
sult of removing these routes, it then has no corresponding
routes in its Route Cache.
To handle the possible memory consumption attack of
needing to save information from many pending ROUTE ER-
RORs, the following technique is quite effective: each node
keeps in memory a table containing the information from each
ROUTE ERROR awaiting authentication. We manage this ta-
ble such that the probability that the information from an ER-
ROR is in the table is independent of the time that this node
received that ROUTE ERROR.
When the wireless link capacity is finite, an attacker can in-
ject only a finite number of ROUTE ERRORs within a TESLA
time interval plus 2 + τ . As a result, the probability of
success for our defense against memory consumption attacks
for received ROUTE ERRORs in any time interval is given by
ps = 1 − (y/(x + y))N , where N is the number of ROUTE
ERRORs that can be held in the node’s table, x is the number
of authentic ROUTE ERRORs received, and y is the number of
ERRORs sent by the attacker. The maintenance of a link there-
fore follows a geometric distribution, and the expected num-
ber of time intervals before success is (1 − (y/(x + y))N)−1.
For example, in a network using a 1-second TESLA time in-
terval and an 11 Mbps wireless link, if the size of a ROUTE
ERROR packet is 60 bytes, then a node with a 5000-element
table receiving just one authentic ROUTE ERROR per second
can successfully authenticate and process one of the authen-
tic ROUTE ERRORs within 5.1 seconds on the average, even
when an attacker is otherwise flooding the node with mali-
cious ROUTE ERRORs. This 5.1 second recovery time rep-
resents a worst-case scenario, and minimal node resources
are consumed while the node waits to validate one of these
ROUTE REQUESTs.
When digital signatures or pairwise shared keys are used,
this memory consumption attack is not possible, and the au-
thentication is more straightforward. A ROUTE ERROR need
not include a time interval or recent TESLA key. Furthermore,
the error MAC is changed to a digital signature when digital
signatures are used. When pairwise shared keys are used, the
error MAC is computed based on the key shared between the
original sender of the packet and the sender of the ROUTE
ERROR, rather than on the TESLA key of the sender of the
ERROR.
6.4. Thwarting the effects of routing misbehavior
The protocol described so far is vulnerable to an Active-1-1
attacker that happens to be along the discovered route. In
particular, we have not presented a means of determining
whether intermediate nodes are, in fact, forwarding packets
30 HU, PERRIG AND JOHNSON
that they have been requested to forward. Watchdog and
pathrater [40] attempt to solve this problem by identifying
the attacking nodes and avoiding them in the routes used.
Instead, we choose routes based on their prior performance
in packet delivery. Introducing mechanisms that penalize
specific nodes for routing misbehavior (such as is done in
watchdog and pathrater) is subject to a blackmail attack (sec-
tion 5.1), where a sufficient number of attackers may be able
to penalize a well-behaved node.
Our scheme relies on feedback about which packets were
successfully delivered. The feedback can be received either
through an extra end-to-end network layer message, or by
exploiting properties of transport layers, such as TCP with
SACK [41]; this feedback approach is somewhat similar that
used in IPv6 for Neighbor Unreachability Detection [43].
Stronger properties are obtained when the routing protocol
sends such feedback packets along a route equal to the re-
versed route of the triggering packet; otherwise, a malicious
node along one route may drop the acknowledgment for a
packet transmitted along a functioning route.
A node with multiple routes to a single destination can as-
sign a fraction of packets that it originates to be sent along
each route. When a substantially smaller fraction of packets
sent along any particular route are successfully delivered, the
node can begin sending a smaller fraction of its overall pack-
ets to that destination along that route. However, if the frac-
tion of packets chosen to be sent along a route that appears
to be misbehaving were to reach zero, a short-lived jamming
attack that is now over could still prevent the future use of
that route. To avoid this possible DoS attack, we choose the
fraction of packets sent along such a route to be some small
but nonzero amount, to allow the occasional monitoring of
the route. A packet sent for this purpose can be a normal data
packet, or, if all packets are secured using end-to-end encryp-
tion, a padded “probe” packet can be used.
Because DSR often returns multiple ROUTE REPLY pack-
ets in response to a Route Discovery, the presence of multiple
routes to some destination in a node’s Route Cache is quite
common. Tsirigos and Haas [62] also discuss the use of mul-
tiple routes for increasing reliability, although they do not dis-
cuss this technique with respect to secure routing protocols.
Malicious nodes can also be avoided during Route Dis-
covery. Each ROUTE REQUEST can include a list of nodes to
avoid, and the MAC that forms the initial hash chain element
(h0) is then also computed over that list of nodes. Malicious
nodes cannot add or remove nodes from this list without be-
ing detected by the target. Choosing which nodes to avoid in
this way is beyond the scope of this paper.
6.5. Thwarting malicious route request floods
An active attacker can attempt to degrade the performance
of DSR or other on-demand routing protocols by repeat-
edly initiating Route Discovery. In this attack, an attacker
sends ROUTE REQUEST packets, which the routing proto-
col floods throughout the network. In basic Ariadne (sec-
tions 6.2 and 6.3), a ROUTE REQUEST is not authenticated
until it reaches its target, thus allowing an Active-1-1 attacker
to cause such network-wide floods. (An Active-0-1 can be
thwarted by using a network-wide authentication key, as de-
scribed in section 7.2.)
To protect Ariadne from a flood of ROUTE REQUEST
packets, we need a mechanism that enables nodes to instantly
authenticate ROUTE REQUESTs, so nodes can filter out forged
or excessive REQUEST packets. We introduce Route Discov-
ery chains, a mechanism for authenticating Route Discover-
ies, allowing each node to rate-limit Discoveries initiated by
any node.
Route Discovery chains are one-way chains generated,
as in TESLA (section 3), by choosing a random KN , and
repeatedly computing a one-way hash function H to give
Ki = HN−i [KN ]. These chains can be used in one of two
ways. One approach is to release one key for each Route Dis-
covery. Each ROUTE REQUEST from that Discovery would
carry a key from this Route Discovery chain, and duplicates
could be suppressed using this value. Because of the flood-
ing nature of Route Discovery, a node that is not partitioned
from the network will generally hear each chain element that
is used, preventing an attacker from reusing that value in the
future. An alternative approach, similar to TESLA, is to dic-
tate a schedule at which Route Discovery chain elements can
be used, and to use loosely synchronized clocks to prevent
even partitioned nodes from propagating an old ROUTE RE-
QUEST. The latter approach is computationally slightly more
expensive, but it is secure against an attacker replaying an
old chain element to a formerly partitioned node, causing that
node to ignore REQUESTs from the spoofed source for some
period of time.
Route Discovery chains can also be constructed from a
chain-based one-time signature, such as the Merkle–Winter-
nitz construction [24,56,65]. The chain can then be used
to sign any set of immutable fields in the initial ROUTE
REQUEST, and the signature distributed with the REQUEST.
In our design, the only immutable field is the target address,
since the identifier is the chain element used for the current
Route Discovery, and the time interval can also be derived
from that chain element. As a result, the one-time signature
scheme needs to sign very few bits, and steps in the Route
Discovery chain can be very inexpensive. For example, in
a network with 50 nodes, it suffices to represent 49 possible
targets (since the initiator is never the target). If the Merkle–
Winternitz construction is used with two signature chains of
length 7 and a checksum chain of length 13, each ROUTE
REQUEST is just 20 bytes longer, and one step in the hash
chain costs just 27 hash operations. If each node is permit-
ted to initiate one Route Discovery per second, the amortized
cost of using Merkle–Winternitz chains in this network is just
1350 hash operations per second.
6.6. Optimizations for Ariadne
Caching improvements. When Ariadne is used with broad-
cast authentication such as TESLA, additional route caching
is possible. In the basic Route Discovery mechanism de-
ARIADNE 31
scribed in section 6.2, only the initiator of the Discovery can
use the route in the ROUTE REPLY, since the target MAC field
of the REPLY can only be verified by the initiator. However, if
the appropriate data is also broadcast authenticated, any node
along a path returned in a REPLY can use that route to reach
the target. For example, if TESLA is used as the broadcast
authentication protocol, a target authenticator is placed the
packet in addition to the target MAC, and is computed using a
TESLA key that is not expected to be disclosed until  after
the last REPLY reaches the initiator (where  is the maximum
time difference between two nodes). That TESLA key is then
disclosed, after appropriate delay, by sending it to the initiator
along each path traversed by a REPLY.
Reduced overhead. When Ariadne is used with symmet-
ric authentication (such as TESLA or pairwise shared keys),
some fields can be calculated by the receiver rather than in-
cluded in the packet [24]. In particular, the MAC list in both
the ROUTE REQUEST and ROUTE REPLY can be eliminated,
and hi can be computed using
MACKAi
(
REQUEST, S,D, id, ti, hi−1, (A1, . . . , Ai)
)
.
The verifier (initiator with delayed broadcast authentication,
and target with pairwise shared keys) can then recompute
each hi given the disclosed (or known) symmetric keys.
7. Ariadne evaluation
7.1. Simulation-based performance evaluation
To evaluate the Ariadne without attackers, we used the ns-2
simulator, with our mobility extensions [8]. The ns-2 simula-
tor has been used extensively in evaluating the performance of
ad hoc network routing protocols. These simulations model
radio propagation using the realistic two-ray ground reflec-
tion model [53] and account for physical phenomena such as
signal strength, propagation delay, capture effect, and inter-
ference. The Medium Access Control protocol used is the
IEEE 802.11 Distributed Coordination Function (DCF) [27].
The parameters used for our simulation are given in table 1.
We evaluated the version of Ariadne that uses TESLA for
broadcast authentication and shared keys only between com-
municating pairs of nodes. We also simulate the effect of
adding the Reduced Overhead optimization in Ariadne de-
scribed in section 6.6; we refer to the unoptimized version
of Ariadne as “Ariadne-HiOvd” and the optimized version as
“Ariadne-LoOvd”.
We modeled these versions of Ariadne by modifying our
ns-2 DSR model in several ways: we increased the packet
sizes to reflect the additional fields necessary for authen-
ticating the packets, and modified the handling of Route
Discovery and Route Maintenance for the additional authen-
tication processing defined in Ariadne; we adjusted retrans-
mission timeouts for ROUTE REQUESTs to compensate for
the delay necessary for the disclosure of TESLA keys; and
we treated routes learned from Route Discovery in an atomic
Table 1
Parameters for Ariadne simulations.
Scenario parameters
Number of nodes 50
Maximum velocity (vmax) 20 m/s
Dimensions of space 1500 m × 300 m
Nominal radio range 250 m
Source–destination pairs 20
Source data pattern (each) 4 packets/second
Application data payload size 512 bytes/packet
Total application data load 327 kbps
Raw physical link bandwidth 2 Mbps
DSR parameters
Initial ROUTE REQUEST timeout 2 seconds
Maximum ROUTE REQUEST timeout 40 seconds
Cache size 32 routes
Cache replacement policy FIFO
TESLA parameters
TESLA time interval 1 second
Pessimistic end-to-end propagation time (τ ) 0.2 seconds
Maximum time synchronization error () 0.1 seconds
Hash length (ρ) 80 bits
fashion that did not allow the use of prefixes of routes in the
Route Cache. We compare Ariadne with the current version
of DSR [19], which we call simply “DSR”, and with an un-
optimized version of DSR, which we call “DSR-NoOpt”. In
DSR-NoOpt, we disabled all DSR protocol optimizations not
present in Ariadne. By comparing Ariadne with this unopti-
mized version of DSR, we can examine the performance im-
pact of adding security, independent of the performance im-
pact of the DSR optimizations removed to allow the security
functionality.
Each node in our simulation moves according to the ran-
dom waypoint mobility model [30]. In the random waypoint
model, each node starts at a random position, waits for a du-
ration called the pause time, and then independently chooses
a new random location and moves there with a velocity uni-
formly chosen between 0 and vmax. When it arrives, it waits
for the pause time and repeats the process. Like much previ-
ous work in evaluating ad hoc network routing protocols (e.g.,
[8,19,28]), we use a rectangular space of size 1500 m×300 m
to increase the average number of hops in routes used relative
to a square space of equal area, creating a more challenging
environment for the routing protocol in this respect. All pro-
tocols were run on identical movement and communication
scenarios. We computed six metrics for each simulation run:
• Packet Delivery Ratio (PDR). The fraction of application-
level data packets sent that are actually received at the re-
spective destination node.
• Packet Overhead. The number of transmissions of rout-
ing packets; for example, a ROUTE REPLY sent over three
hops would count as three overhead packets in this metric.
• Byte Overhead. The number of transmissions of overhead
(non-data) bytes, counting each hop as above.
32 HU, PERRIG AND JOHNSON
• Mean Latency. The average time elapsed from when a
data packet is first sent to when it is first received at its
destination.
• 99.99th Percentile Latency. Computed as the 99.99th per-
centile of the packet delivery latency.
• Path Optimality. Compares the length of routes used to
the optimal (minimum possible) hop length as determined
by an off-line omniscient algorithm, based on the nominal
wireless transmission range of 250 m per hop.
Figure 4(a) shows the Packet Delivery Ratio (PDR) for
each protocol. Removing the optimizations from DSR to pro-
duce DSR-NoOpt reduces the PDR by an average of 12.7%;
adding Ariadne-HiOvd security further reduces the PDR by
just an additional 1.12% on average, and does not reduce
PDR by more than an additional 2.8% at any pause time. Ari-
adne with reduced overhead (Ariadne-LoOvd) recovers most
of this PDR loss; it has PDR just 0.015% lower (on aver-
age) than DSR-NoOpt. Ariadne with reduced overhead out-
performs DSR-NoOpt at low mobility, but has lower PDR at
high mobility.
Surprisingly, Ariadne outperforms DSR-NoOpt at lower
levels of mobility. This improved performance results from
the average half-second delay (one half the TESLA time in-
terval) that Ariadne introduces between the target receiving
a ROUTE REQUEST and sending a ROUTE REPLY. Specifi-
cally, when a ROUTE REQUEST traverses a short-lived link,
DSR-NoOpt immediately returns the ROUTE REPLY, but the
new route can be used for only its brief lifetime, contributing
additional overhead for forwarding the REPLY and for send-
ing and forwarding the resulting ROUTE ERROR. In Ariadne,
links are in effect tested twice: once when the ROUTE RE-
QUEST traverses the network, and once when the ROUTE RE-
PLY is sent along the reverse path. If one of the links along
this path breaks between these tests, the REPLY with this route
is not received by the initiator. It is this additional route con-
firmation that allows Ariadne to find more stable routes than
DSR-NoOpt.
From examining the PDR achieved by the different proto-
cols, we draw three conclusions. First, Ariadne’s Route Dis-
covery operates more slowly but also finds better routes, since
those routes must exist for long enough to successfully return
a ROUTE REPLY. Second, these better routes offset the dis-
advantage that Ariadne ROUTE ERRORs cannot be processed
until the TESLA key used is disclosed, causing additional
data packets to continue to be sent along the broken route for
on average half of the TESLA time interval after the ERROR is
received. Finally, the increased overhead of Ariadne-HiOvd
is almost fully responsible for its lower PDR relative to DSR-
NoOpt.
Figure 4(b) shows the path optimality results for each pro-
tocol. In DSR, the average number of hops along a route used
by a packet is 0.700 hops more than the minimum possible,
based on the nominal wireless transmission range of 250 m
per hop. In DSR-NoOpt, routes used are on average 0.264
hops longer than in DSR, and in both versions of Ariadne,
routes used average 0.011 hops longer than in DSR-NoOpt.
DSR-NoOpt performs slightly better than Ariadne because
it initiates more Route Discoveries and thus tends to more
quickly find shorter routes when they become available than
does Ariadne.
Figures 4(c) and 4(d) show the the results for packet over-
head and byte overhead, respectively. Ariadne has consis-
tently lower packet overhead than does DSR-NoOpt, because
Ariadne tends to find more stable routes than DSR-NoOpt,
reducing the number of Route Discoveries as well as the
number of ROUTE ERRORs that are sent. This advantage
is somewhat reduced since ROUTE ERROR processing is de-
layed in Ariadne, causing more redundant ERRORs to be sent
for each broken route. Byte overhead in Ariadne-HiOvd is
significantly worse than in either DSR or DSR-NoOpt, due
to the authentication overhead in ROUTE REQUEST, REPLY,
and ERROR packets. Surprisingly, Ariadne-LoOvd has lower
overhead than DSR-NoOpt, because the extra packets sent by
DSR-NoOpt outweigh the additional authentication informa-
tion in each Ariadne-LoOvd routing control packet.
Figures 4(e) and 4(f) show the results for average latency
and 99.99th percentile latency, respectively. Because of the
reduced number of broken links that Ariadne uses relative
to DSR-NoOpt, Ariadne generally has better latency than
does DSR-NoOpt. Ariadne-LoOvd shows significantly lower
mean latency than Ariadne-HiOvd, because it has lower byte
overhead and thus creates less congestion in the network. The
difference is also present in the 99.99th percentile latency, but
there, channel contention is a smaller fraction of the overall
latency.
7.2. Security analysis
In this section, we discuss how Ariadne resists attacks by cer-
tain attacker types, according to the taxonomy we presented
in section 5.1.
Intuitively, Ariadne Route Discovery is successful when at
least one of the REPLYs returned by the target is a working
route. Since the target of a Route Discovery returns a route
for each of its neighbors, if the first REQUEST from a partic-
ular Discovery to reach any neighbor of the target has passed
through no malicious nodes, that Discovery will succeed.
To more formally characterize the security offered by Ari-
adne, we define a minimum broadcast latency path between a
source and a destination to be any path that forwards a Route
Discovery most quickly from the source to the destination.
We call a route that only consists of uncompromised nodes an
uncompromised route. Ariadne prevents compromised nodes
from disturbing uncompromised routes. In particular, Ari-
adne provides two properties assuming reliable broadcast:
• If there exists an uncompromised neighbor of a destination
such that the minimum latency path between the initia-
tor of the Discovery and that neighbor is uncompromised,
then an uncompromised route from the initiator to the tar-
get will be returned in a ROUTE REPLY.
• If at least one REPLY returned as a result of the first prop-
erty represents a shortest route from the initiator to the tar-
ARIADNE 33
Figure 4. Performance results comparing Ariadne with the standard DSR protocol and with a version of DSR with all DSR optimizations not present in
Ariadne disabled. Results are based on simulation over 50 runs, and the error bars represent the 95% confidence interval of the mean.
34 HU, PERRIG AND JOHNSON
get, Ariadne may route packets along one such uncompro-
mised route.
To argue for the correctness of the first property, we note
that if the minimum latency path between the initiator and a
neighbor of the destination is uncompromised, then the first
REQUEST to reach that neighbor comes over an uncompro-
mised route. Since it is the first REQUEST, it will not be fil-
tered by duplicate REQUEST detection, so it will be rebroad-
cast, and heard by the target. Since the target returns a REPLY
for each REQUEST it receives, without performing duplicate
detection, a REPLY will be returned. The second property
trivially follows from the use of shortest paths and the first
property.
Although it may not be possible to achieve reliable broad-
cast securely or efficiently, we assume that most broadcast
packets are received, and hence the properties listed above
generally hold.
We now consider Ariadne using our taxonomy of attacker
types from section 5.1. We list different attacker configura-
tions in increasing strength, and discuss how Ariadne resists
some possible attacks. Ariadne resists many more attacks, but
only a representative sample are discussed here.
Since Ariadne does not attempt to provide anonymous
routing, passive attackers can eavesdrop on all routing traf-
fic sent by nodes within range of those attackers. They can
also perform traffic analysis on any packets sent or forwarded
by nodes within range of the attackers.
When replay protection and a global MAC key are used, an
Active-0-x attacker (for x  1) can at most perform worm-
hole and rushing attacks. Packet leashes can prevent these
attacks [25].
An Active-1-1 attacker may attempt the following attacks:
• Create a gray hole or black hole by removing nodes in a
ROUTE REQUEST; however, the per-hop hash mechanism
in each REQUEST prevents such tampering. An attacker
may fabricate nodes to insert in the accumulated route list
of a REQUEST packet, such fabricated nodes would not
have known keys at the source, and the REPLY would thus
not be authenticated. If the attacker tries to replace the
MAC and keys in the reply, such tampering will be de-
tected as a result of the target MAC field in the REPLY.
• Create routing loops. Intuitively, the use of source routes
prevents loops, since a packet passing through only legiti-
mate nodes will not be forwarded into a loop. An attacker
can create a routing loop by modifying the source route
each time around the loop; this behavior, however, is no
worse than if the attacker were to source packets with pe-
riod equal to the propagation time around the loop. In par-
ticular, if there are n nodes in the routing loop, and a single
packet is forwarded around the loop m times, the attacker
participates in m forwards, and the total expended effort
is mn forwards. Had the attacker instead sourced m pack-
ets along n-hop routes, the total attacker effort is m trans-
missions, and the total network effort is mn forwards, an
identical result.
• Flood network with many ROUTE REQUESTs. Since the
source address of each REQUEST is authenticated, and
since each new Route Discovery needs to carry a new one-
way Route Discovery chain value, the compromised node
can only produce ROUTE REQUESTs with its own source
address. An upper bound on the sending rate can be en-
forced either by rate limiting of REQUESTs at each node or
synchronizing Route Discovery chain elements with time
(section 6.5).
• Perform a rushing attack (section 5.2). Rushing attacks
can be probabilistically prevented by slightly modifying
the Route Discovery protocol [23].
Multiple attackers that have compromised one node (Act-
ive-1-x, for x > 1) may attempt to construct a wormhole, but
append the address and key of the compromised node in each
REQUEST forwarded across this wormhole. Packet leashes
alone cannot prevent this attack, but packet leashes and GPS
can be used in conjunction to ensure that an Active-1-x worm-
hole attack can be no worse than an Active-1-1 attacker po-
sitioned correctly. In particular, if each node forwarding a
ROUTE REQUEST includes its alleged GPS coordinates in
that REQUEST, then a node can detect if it should be reach-
able from the previous hop, and if the hop before the previous
hop should be able to reach the previous hop. If both of these
checks succeed, then the attacker could have placed the com-
promised node at the position it specified in the packet, and
that node would have been able to hear the original REQUEST,
append its address, and forward it to the next hop.
Multiple attackers that know all the keys of multiple nodes
(an Active-y-x attacker configuration, where 1 < y  x) may
perform the following attacks:
• Lengthen the route in the REQUEST by adding other com-
promised nodes to the route. If the source finds a shorter
route, it will likely prefer that route, so the protocol be-
haves as if the attacker were not there.
• Attempt to force the initiator to repeatedly initiate Route
Discoveries. Suppose an Active-y-x attacker had the keys
of multiple compromised nodes, and that one such attacker
were on the shortest path from the source to the destina-
tion. When the attacker receives its first ROUTE REQUEST
packet as part of some Discovery, it adds its address and
MAC, as normal, but also adds the address of another node
it has compromised. When data packets are sent along that
route, the attacker replies with a ROUTE ERROR from its
first hop to its second hop. In subsequent Route Discov-
eries, the attacker can use different addresses for the addi-
tional address. Since other routes may have been returned
as part of any of these Route Discoveries, this attack is not
guaranteed to be successful.
To prevent such starvation, the initiator may include data
in the ROUTE REQUEST. To be part of the path, the at-
tacker must forward routing messages, so the initiator can
send data to the target. If the attacker alters the data in
the ROUTE REQUEST, the destination will detect the al-
teration (using the shared key and a MAC on the data) and
reject that route.
ARIADNE 35
A set of attackers that control a vertex cut of the net-
work (an Active-VC attacker) may perform the following ad-
ditional attacks:
• Make nodes on one side of the vertex cut believe that any
node on the other side is attempting to flood the network.
By holding and not propagating ROUTE REQUESTs from
a certain node for some time, then initiating many Route
Discoveries with the chain values from the old Discover-
ies, an Active-VC attacker can make that node appear to
be flooding the network. When the use of individual ele-
ments of a Route Discovery chain are time-synchronized,
this attack simply causes the REQUESTs associated with
the stale chain elements to be discarded.
• Only forward ROUTE REQUEST and ROUTE REPLY pack-
ets. A sender is then unable to successfully deliver pack-
ets. This attack is only marginally different from not par-
ticipating in the protocol at all, differing only in that the
sender and some intermediate nodes continue to spend
power to send packets, but none of those packets are suc-
cessfully received.
8. Related work
Several researchers have proposed secure routing protocols.
For example, Perlman [47] proposed flooding NPBR, an on-
demand protocol designed for wired networks that floods each
packet through the network. Flooding NPBR allocates a frac-
tion of the bandwidth along each link to each node, and uses
digital signatures to authenticate all packets. Unfortunately,
this protocol has high overhead in terms of the computational
resources necessary for digital signature verification and in
terms of its bandwidth requirements. Furthermore, estimating
and guaranteeing available bandwidth in a wireless environ-
ment is difficult [34].
Other wired network protocols have secured periodic rout-
ing protocols with asymmetric cryptography, such as Kent
et al. [33], Perlman’s link-state NPBR, Kumar’s secure link-
state protocol [37], and Smith et al. [58,59]. However, nodes
in an ad hoc network may not have sufficient resources to ver-
ify an asymmetric signature; in particular, an attacker can triv-
ially flood a victim with packets containing invalid signatures,
but verification can be prohibitively expensive for the victim.
In addition, these protocols may suffer in some scenarios be-
cause periodic protocols may not be able to cope with high
rates of mobility in an ad hoc network. Kumar also discusses
threats to both distance-vector protocols and link-state pro-
tocols, and describes techniques for securing distance-vector
protocols. However, these techniques are vulnerable to the
compromise of a single node.
Zhou and Haas [66], Zapata [64], and Sanzgiri et al. [57]
propose the use of asymmetric cryptography to secure on-
demand ad hoc network routing protocols. However, as
above, when the nodes in an ad hoc network are generally un-
able to verify asymmetric signatures quickly enough, or when
network bandwidth is insufficient, these protocols may not be
suitable.
Cheung [10], Hauser et al. [17], and Zhang [65] describe
symmetric-key approaches to the authentication of link-state
updates, but they do not discuss mechanisms for detecting
the status of these links. In wired networks, a common tech-
nique for authenticating HELLO packets is to verify that the
the incoming network interface is the expected interface and
that the IP TTL of the packet is 255. In a wireless ad hoc
network, this technique cannot be used. Furthermore, these
protocols assume the use of periodic routing protocols, which
are not always suitable in ad hoc networks. Cheung [10] uses
cryptographic mechanisms similar to those used in Ariadne
with TESLA, but optimistically integrates routing data before
it is authenticated, adversely affecting security.
A number of other researchers have also proposed the
use of symmetric schemes for authenticating routing con-
trol packets. Heffernan [18] proposes a mechanism requiring
shared keys between all communicating routers. This scheme
may not scale to large ad hoc networks, and may be vulnera-
ble to single-node compromise. Perrig et al. [50] use symmet-
ric primitives to secure routing between nodes and a trusted
base station. Basagni et al. [2] use a network-wide symmetric
key to secure routing communication, which is vulnerable to a
single node compromise, although they specify the use of se-
cure hardware to limit the damage that can be done by a com-
promised node. Papadimitratos and Haas [44] present work
that secures against non-colluding adversaries, and they do
not authenticate intermediate nodes that forward ROUTE RE-
QUESTs, and thus do not handle authorization. Yi et al. [63]
discuss authorization issues. Our previous work, SEAD [21],
uses hash chains to authenticate routing updates sent by a
distance-vector protocol; however, that approach builds on
a periodic protocol, and such protocols tend to have higher
overhead than on-demand protocols and may not be suitable
in highly mobile networks. An earlier version of the Ariadne
protocol was presented in [22].
Routing protocol intrusion detection has also been studied
as a mechanism for detecting misbehaving routers [7,11,40].
9. Conclusions
This paper has presented the design and evaluation of Ari-
adne, a new secure ad hoc network routing protocol. Ariadne
provides security against one compromised node and arbi-
trary active attackers, and relies only on efficient symmetric
cryptographic operations. Ariadne operates on-demand, dy-
namically discovering routes between nodes only as needed;
the design is based on the basic operation of the DSR pro-
tocol. Rather than generously applying cryptography to an
existing protocol to achieve security, however, we carefully
re-designed each protocol message and its processing. The
security mechanisms we designed are highly efficient and
general, so that they should be applicable to securing a wide
variety of routing protocols.
Because we did not secure the optimizations of DSR in
Ariadne, the resulting protocol is less efficient than the highly
optimized version of DSR that runs in a trusted environment.
36 HU, PERRIG AND JOHNSON
However, we also compared Ariadne to a version of DSR in
which we disabled all protocol optimizations not present in
Ariadne, allowing us to evaluate and analyze the effect of the
optimizations and the security separately. As explained in our
results, however, Ariadne actually performs better on some
metrics (e.g., 41.7% lower packet overhead) than for unop-
timized DSR, and about the same on all other metrics, even
though Ariadne must bear the added costs for security not
present in unoptimized DSR.
We found that source-routing facilitates securing ad hoc
network routing protocols. Source routing empowers the
sender to circumvent potentially malicious nodes, and enables
the sender to authenticate every node in a ROUTE REPLY.
Such fine-grained path control is absent in most distance-
vector routing protocols, which makes such protocols more
challenging to fully secure.
Acknowledgements
This work was supported in part by NSF under grant CCR-
0209204, by NASA under grant NAG3-2534, by the United
States Postal Service under contract USPS 102592-01-Z-
0236, by DARPA under contract N66001-99-2-8913, and by
gifts from Schlumberger and Bosch. The views and conclu-
sions contained here are those of the authors and should not
be interpreted as necessarily representing the official poli-
cies or endorsements, either express or implied, of NSF,
NASA, USPS, DARPA, Schlumberger, Bosch, Rice Univer-
sity, Carnegie Mellon University, or the U.S. Government or
any of its agencies.
References
[1] N. Abramson, The ALOHA system – another alternative for computer
communications, in: Proceedings of the Fall 1970 AFIPS Computer
Conference (November 1970) pp. 281–285.
[2] S. Basagni, K. Herrin, E. Rosti and D. Bruschi, Secure pebblenets, in:
Proceedings of the 2nd Symposium on Mobile Ad Hoc Networking and
Computing (MobiHoc 2001) (October 2001) pp. 156–163.
[3] M. Bellare, R. Canetti and H. Krawczyk, Keying hash functions for
message authentication, in: Advances in Cryptology – Crypto’96, Lec-
ture Notes in Computer Science, Vol. 1109, ed. N. Koblitz (Springer,
1996) pp. 1–15.
[4] B. Bellur and R.G. Ogier, A reliable, efficient topology broadcast pro-
tocol for dynamic networks, in: Proceedings of the 18th Annual Joint
Conference of the IEEE Computer and Communications Societies (IN-
FOCOM’99) (March 1999) pp. 178–186.
[5] A. Benjaminson and S.C. Stallings, A microcomputer-compensated
crystal oscillator using a dual-mode resonator, in: Proceedings of the
43rd Annual Symposium on Frequency Control (May 1989) pp. 20–26.
[6] V. Bharghavan, A. Demers, S. Shenker and L. Zhang, MACAW: A Me-
dia Access Protocol for Wireless LANs, in: Proceedings of the SIG-
COMM’94 Conference on Communications Architectures, Protocols
and Applications (August 1994) pp. 212–225.
[7] K.A. Bradley, S. Cheung, N. Puketza, B. Mukherjee and R.A. Ols-
son, Detecting disruptive routers: a distributed network monitoring ap-
proach, in: Proceedings of the IEEE Symposium on Research in Secu-
rity and Privacy (May 1998) pp. 115–124.
[8] J. Broch, D.A. Maltz, D.B. Johnson, Y.-C. Hu and J.G. Jetcheva, A per-
formance comparison of multi-hop wireless ad hoc network routing
protocols, in: Proceedings of the 4th ACM/IEEE International Confer-
ence on Mobile Computing and Networking (MobiCom’98) (October
1998) pp. 85–97.
[9] M. Brown, D. Cheung, D. Hankerson, J.L. Hernandez, M. Kirkup and
A. Menezes, PGP in constrained wireless devices, in: Proceedings of
the 9th USENIX Security Symposium (August 2000) pp. 247–261.
[10] S. Cheung, An efficient message authentication scheme for link state
routing, in: Proceedings of the 13th Annual Computer Security Appli-
cations Conference (1997) pp. 90–98.
[11] S. Cheung and K. Levitt, Protecting routing infrastructures from denial
of service using cooperative intrusion detection, in: Proceedings of the
1997 New Security Paradigms Workshop (September 1998) pp. 94–106.
[12] T. Clark, Tom Clark’s totally accurate clock FTP site, Greenbelt, MA,
available at ftp://aleph.gsfc.nasa.gov/GPS/totally.
accurate.clock/
[13] D. Coppersmith and M. Jakobsson, Almost optimal hash sequence tra-
versal, in: Proceedings of the 4th Conference on Financial Cryptogra-
phy (FC’02), Lecture Notes in Computer Science (2002) pp. 102–119.
[14] T. Dierks and C. Allen, The TLS protocol, version 1.0, RFC 2246 (Jan-
uary 1999).
[15] E. Gabber and A. Wool, How to prove where you are: tracking the
location of customer equipment, in: Proceedings of the 5th ACM Con-
ference on Computer and Communications Security (November 1998)
pp. 142–149.
[16] O. Goldreich, S. Goldwasser and S. Micali, How to construct random
functions, Journal of the ACM 33(4) (1986) 792–807.
[17] R. Hauser, A. Przygienda and G. Tsudik, Reducing the cost of secu-
rity in link state routing, in: Proceedings of the Symposium on Net-
work and Distributed Systems Security (NDSS’97) (February 1997)
pp. 93–99.
[18] A. Heffernan, Protection of BGP sessions via the TCP MD5 signature
option, RFC 2385 (August 1998).
[19] Y.-C. Hu and D.B. Johnson, Caching strategies in on-demand routing
protocols for wireless ad hoc networks, in: Proceedings of the 6th
Annual IEEE/ACM International Conference on Mobile Computing
and Networking (MobiCom 2000) (August 2000) pp. 231–242.
[20] Y.-C. Hu and D.B. Johnson, Implicit source routing in on-demand ad
hoc network routing, in: Proceedings of the 2nd Symposium on Mobile
Ad Hoc Networking and Computing (MobiHoc 2001) (October 2001)
pp. 1–10.
[21] Y.-C. Hu, D.B. Johnson and A. Perrig, Secure efficient distance vector
routing in mobile wireless ad hoc networks, in: Proceedings of the
4th IEEE Workshop on Mobile Computing Systems and Applications
(WMCSA’02) (June 2002) pp. 3–13.
[22] Y.-C. Hu, A. Perrig and D.B. Johnson, Ariadne: A secure on-demand
routing protocol for wireless ad hoc networks, in: Proceedings of
the 8th Annual International Conference on Mobile Computing and
Networking (MobiCom 2002) (September 2002) pp. 12–23.
[23] Y.-C. Hu, A. Perrig and D.B. Johnson, Rushing attacks and defense in
wireless ad hoc network routing protocols, in: Proceedings of the 2003
ACM Workshop on Wireless Security (WiSe 2003) (September 2003)
pp. 30–40.
[24] Y.-C. Hu, A. Perrig and D.B. Johnson, Efficient security mechanisms
for routing protocols, in: Proceedings of the 10th Annual Network and
Distributed System Security Symposium (NDSS 2003) (February 2003)
pp. 57–73.
[25] Y.-C. Hu, A. Perrig and D.B. Johnson, Packet leashes: a defense
against wormhole attacks in wireless ad hoc networks, in: Proceedings
of the 22nd Annual Joint Conference of the IEEE Computer and Com-
munications Societies (INFOCOM 2003) (April 2003) pp. 1976–1986.
[26] J.-P. Hubaux, L. Buttyán and S. Čapkun, The quest for security in
mobile ad hoc networks, in: Proceedings of the 2nd Symposium on
Mobile Ad Hoc Networking and Computing (MobiHoc 2001) (October
2001) pp. 146–155.
[27] IEEE Computer Society LAN MAN Standards Committee, Wireless
LAN Medium Access Control (MAC) and Physical Layer (PHY)
specifications, IEEE Std 802.11-1997, The Institute of Electrical and
Electronics Engineers (1997).
ARIADNE 37
[28] P. Johansson, T. Larsson, N. Hedman, B. Mielczarek and M.
Degermark, Scenario-based performance analysis of routing protocols
for mobile ad-hoc networks, in: Proceedings of the 5th Annual
ACM/IEEE International Conference on Mobile Computing and
Networking (MobiCom’99) (August 1999) pp. 195–206.
[29] D.B. Johnson, Routing in ad hoc networks of mobile hosts, in:
Proceedings of the IEEE Workshop on Mobile Computing Systems and
Applications (WMCSA’94) (December 1994) pp. 158–163.
[30] D.B. Johnson and D.A. Maltz, Dynamic source routing in ad hoc
wireless networks, in: Mobile Computing, eds. T. Imielinski and
H. Korth (Kluwer Academic, 1996) chapter 5, pp. 153–181.
[31] D.B. Johnson, D.A. Maltz, Y.-C. Hu and J.G. Jetcheva, The dynamic
source routing protocol for mobile ad hoc networks, Internet-draft,
draft-ietf-manet-dsr-07.txt (February 2002), work in
progress.
[32] J. Jubin and J.D. Tornow, The DARPA packet radio network protocols,
Proceedings of the IEEE 75(1) (1987) 21–32.
[33] S. Kent, C. Lynn, J. Mikkelson and K. Seo, Secure Border Gateway
Protocol (S-BGP) – real world performance and deployment issues, in:
Proceedings of the Symposium on Network and Distributed Systems
Security (NDSS’00) (February 2000) pp. 103–116.
[34] M. Kim and B. Noble, Mobile network estimation, in: Proceedings
of the 7th Annual International Conference on Mobile Computing and
Networking (MobiCom 2001) (July 2001) pp. 298–309.
[35] Y.-B. Ko and N. Vaidya, Location-Aided Routing (LAR) in mobile
ad hoc networks, in: Proceedings of the 4th ACM/IEEE International
Conference on Mobile Computing and Networking (MobiCom’98)
(October 1998) pp. 66–75.
[36] J. Kohl and B.C. Neuman, The Kerberos Network Authentication
Service (V. 5), RFC 1510 (September 1993).
[37] B. Kumar, Integration of security in network routing protocols,
SIGSAC Review 11(2) (1993) 18–25.
[38] D.A. Maltz, J. Broch, J. Jetcheva and D.B. Johnson, The effects of
on-demand behavior in routing protocols for multi-hop wireless ad hoc
networks, IEEE Journal on Selected Areas in Communications 17(8)
(1999) 1439–1453.
[39] D.A. Maltz, J. Broch and D.B. Johnson, Quantitative lessons from a
full-scale multi-hop wireless ad hoc network testbed, in: Proceedings
of the IEEE Wireless Communications and Networking Conference
(September 2000) pp. 992–997.
[40] S. Marti, T.J. Giuli, K. Lai and M. Baker, Mitigating routing mis-
behaviour in mobile ad hoc networks, in: Proceedings of the 6th
Annual IEEE/ACM International Conference on Mobile Computing
and Networking (MobiCom 2000) (August 2000) pp. 255–265.
[41] M. Mathis, J. Mahdavi, S. Floyd and A. Romanow, TCP selective
acknowledgment options, RFC 2018 (October 1996).
[42] A.J. Menezes, P.C. van Oorschot and S.A. Vanstone, Handbook of
Applied Cryptography, CRC Press Series on Discrete Mathematics and
Its Applications (CRC Press, 1997).
[43] T. Narten, E. Nordmark and W.A. Simpson, Neighbor discovery for IP,
Version 6 (IPv6), RFC 2461 (December 1998).
[44] P. Papadimitratos and Z.J. Haas, Secure routing for mobile ad hoc
networks, in: Proceedings of the SCS Communication Networks and
Distributed Systems Modeling and Simulation Conference (CNDS
2002) (January 2002).
[45] C.E. Perkins and P. Bhagwat, Highly dynamic Destination-Sequenced
Distance-Vector routing (DSDV) for mobile computers, in: Pro-
ceedings of the SIGCOMM’94 Conference on Communications
Architectures, Protocols and Applications (August 1994) pp. 234–244.
[46] C.E. Perkins and E.M. Royer, Ad-hoc on-demand distance vector rout-
ing, in: Proceedings of the 2nd IEEE Workshop on Mobile Computing
Systems and Applications (WMCSA’99) (February 1999) pp. 90–100.
[47] R. Perlman, Interconnections: Bridges and Routers (Addison-Wesley,
1992).
[48] A. Perrig, R. Canetti, D. Song and J.D. Tygar, Efficient and secure
source authentication for multicast, in: Proceedings of the Network and
Distributed System Security Symposium, NDSS’01 (February 2001)
pp. 35–46.
[49] A. Perrig, R. Canetti, J.D. Tygar and D. Song, Efficient authentication
and signing of multicast streams over lossy channels, in: Proceedings
of the IEEE Symposium on Security and Privacy (May 2000) pp. 56–73.
[50] A. Perrig, R. Szewczyk, V. Wen, D. Culler and J.D. Tygar, SPINS:
Security Protocols for Sensor Networks, in: Proceedings of the 7th An-
nual International Conference on Mobile Computing and Networking
(MobiCom 2001) (July 2001) pp. 189–199.
[51] R.L. Pickholtz, D.L. Schilling and L.B. Milstein, Theory of spread
spectrum communications – a tutorial, IEEE Transactions on Commu-
nications 30(5) (1982) 855–884.
[52] A. Qayyum, L. Viennot and A. Laouiti, Multipoint relaying: An
efficient technique for flooding in mobile wireless networks, Technical
Report, RR-3898, INRIA (February 2000).
[53] T.S. Rappaport, Wireless Communications: Principles and Practice
(Prentice Hall, 1996).
[54] Y. Rekhter and T. Li, A Border Gateway Protocol 4 (BGP-4), RFC
1771 (March 1995).
[55] R.L. Rivest, A. Shamir and L.M. Adleman, A method for obtaining
digital signatures and public-key cryptosystems, Communications of
the ACM 21(2) (1978) 120–126.
[56] P. Rohatgi, A compact and fast hybrid signature scheme for multicast
packet authentication, in: Proceedings of the 6th ACM Conference on
Computer and Communications Security (November 1999) pp. 93–100.
[57] K. Sanzgiri, B. Dahill, B.N. Levine, C. Shields and E. Belding-Royer,
A secure routing protocol for ad hoc networks, in: Proceedings of the
10th IEEE International Conference on Network Protocols (ICNP’02)
(November 2002) pp. 78–87.
[58] B.R. Smith and J.J. Garcia-Luna-Aceves, Securing the border gateway
routing protocol, in: Proceedings of the Global Internet’96 (November
1996) pp. 81–85.
[59] B.R. Smith, S. Murthy and J.J. Garcia-Luna-Aceves, Securing distance
vector routing protocols, in: Proceedings of the Symposium on Net-
work and Distributed Systems Security (NDSS’97) (February 1997)
pp. 85–92.
[60] F. Stajano and R. Anderson, The resurrecting duckling: security
issues for ad-hoc wireless networks, in: Proceedings of the Security
Protocols, 7th International Workshop, Lecture Notes in Computer
Science, Vol. 1796 (Springer, 1999) pp. 172–194.
[61] Trimble Navigation Ltd., Data sheet and specifications for Trimble
Thunderbolt GPS disciplined clock, Sunnyvale, CA, available at
http://www.trimble.com/thunderbolt.html
[62] A. Tsirigos and Z.J. Haas, Multipath routing in mobile ad hoc networks
or how to route in the presence of topological changes, in: Proceedings
of the IEEE MILCOM 2001 (October 2001) pp. 878–883.
[63] S. Yi, P. Naldurg and R. Kravets, Security-aware ad hoc routing for
wireless networks, Technical Report UIUCDCS-R-2001-2241, Depart-
ment of Computer Science, University of Illinois at Urbana-Champaign
(August 2001).
[64] M.G. Zapata and N. Asokan, Securing ad hoc routing protocols, in:
Proceedings of the ACM Workshop on Wireless Security (WiSe 2002)
(September 2002) pp. 1–10.
[65] K. Zhang, Efficient protocols for signing routing messages, in:
Proceedings of the Symposium on Network and Distributed Systems
Security (NDSS’98) (March 1998).
[66] L. Zhou and Z.J. Haas, Securing ad hoc networks, IEEE Network
Magazine 13(6) (1999) 24–30.
38 HU, PERRIG AND JOHNSON
Yih-Chun Hu received his B.S. from the University
of Washington in 1997 and his Ph.D. from Carnegie
Mellon University in 2003. In his thesis work at
Carnegie Mellon, he focused on security and per-
formance in wireless ad hoc networks. Yih-Chun’s
research interests include mobility and security in
wired and wireless networks. He is currently a post-
doctoral research fellow at Rice University and is a
member of the ACM.
E-mail: yihchun@cs.cmu.edu
Adrian Perrig is an Assistant Professor in Electri-
cal and Computer Engineering, and Engineering and
Public Policy at Carnegie Mellon University. He
earned his Ph.D. in computer science from Carnegie
Mellon University in 2001, and spent three years dur-
ing his Ph.D. with his advisor Doug Tygar at the Uni-
versity of California at Berkeley. He received his
B.S. in computer engineering from the Swiss Federal
Institute of Technology in Lausanne (EPFL) in 1997.
Adrian’s research interests revolve around building
secure systems and include network security, security for sensor networks
and mobile applications.
E-mail: adrian+@cs.cmu.edu
David B. Johnson is an Associate Professor of Com-
puter Science and Electrical and Computer Engineer-
ing at Rice University. Prior to joining the faculty at
Rice in 2000, he was an Associate Professor of Com-
puter Science at Carnegie Mellon University, where
he had been on the faculty for eight years. Profes-
sor Johnson is leading the Monarch Project, develop-
ing adaptive networking protocols and architectures
to allow truly seamless wireless and mobile network-
ing. He has also been very active in the Internet En-
gineering Task Force (IETF), the principal protocol standards development
body for the Internet, were he was one of the main designers of the IETF
Mobile IP protocol for IPv4 and is the primary designer of Mobile IP for
IPv6. He is currently serving as the General Chair for MobiCom 2003; he
has been a member of the Technical Program Committee for over 30 interna-
tional conferences and workshops and has been an editor for several journals.
He is an Executive Committee member and the Treasurer for SIGMOBILE,
the ACM Special Interest Group on Mobility of Systems, Users, Data, and
Computing, and is a member of the ACM, IEEE, IEEE Computer Society,
IEEE Communications Society, USENIX, and Sigma Xi.
E-mail: dbj@cs.rice.edu

