1 
Real-Time Systems 
Insup Lee 
Department of Computer and Information Science 
School of Engineering and Applied Science 
University of Pennsylvania 
www.cis.upenn.edu/~lee/ 
CIS 480, Spring 2009 
Acknowledgement 
Slides are borrowed and/or adapted from the  
following people: 
o Doron Peled 
o P.S. Thiagaranjan 
o Jane Liu 
o Sebastian Fischmeister 
Spring ‘09 CIS 480 2 
2 
Spring ‘09 CIS 480 3 
What are Real-Time  Computer 
Systems? 
Real-Time Computer System 
o  Correct functioning depends on: 
 the values of the results produced. 
AND 
 the physical times at which the results are produced. 
Real-Time Computer System is  embedded in a 
larger physical system.  
Spring ‘09 CIS 480 4 
What are real-time systems? 
The state of the system evolves with time. 
o Position, velocity, acceleration 
o Pressure, temperature, level, concentration 
The state needs to be sensed and controlled by the 
computer system. 
3 
Spring ‘09 CIS 480 5 
Control Function 
Computing system 
Plant  
Sense 
Actuate 
Spring ‘09 CIS 480 6 
Real time 
System time and external physical time are the same! 
At least must have a predictable relationship 
o bounded skew, bounded clock rates, etc. 
4 
Spring ‘09 CIS 480 7 
Timing Constraints on computation 
The computing system must sense, compute and 
actuate in a timely fashion. 
Many sensors and many actuators. 
Many control functions! 
Must schedule computational tasks for different 
control functions in a timely fashion. 
Computations must finish on time. 
o QoS 
o End-to-end timing constraints 
Spring ‘09 CIS 480 8 
Hard and Soft Real-Time Tasks 
Task: a unit of work - a granule of computation, a unit of transmission 
Hard real-time tasks –  
o Critical tasks, deterministic tasks: failure of a task to complete in time  a 
fatal error 
o Timing constraints must meet always 
o Reactor control, automotive electronics 
Soft real-time tasks: 
o Essential tasks, statistical tasks: such a task is completed always even when 
it requires more than available time. 
Examples: display updates, interpretation of operator commands 
o Non-essential tasks: such a task may be aborted if it cannot be completed 
in time. 
Examples: connection establishment, monitoring non-critical changes 
o Transaction Processing system, Multi-media streaming applications. 
Soft vs. hard real-time systems 
o Hard real-time systems are typical embedded systems. 
o Determined externally 
5 
Spring ‘09 CIS 480 9 
Desired Characteristics of Hard 
Real Time Computing Systems 
Timeliness 
Peak Load Handling 
o  The system should not fail at peak load conditions 
Predictability (not speed, fairness, etc.) 
Fault Tolerance 
Maintainability 
Spring ‘09 CIS 480 10 
Impact on System Architecture 
Must avoid non-determinism (why?) 
Sources of non-determinism: 
o Direct Memory Access (DMA) by peripheral devices 
 Contention for system bus 
o Cache 
o Interrupts generated by I/O devices 
o Memory Management (paging) 
o Dynamic data structures, recursion, unbounded loops 
(language level) 
6 
Spring ‘09 CIS 480 11 
Examples of real-time applications 
On-line transaction systems and interaction systems 
Real-time monitoring and signal processing systems 
o Typical computations 
o Timing requirements 
o Typical architectures 
o E.g., Railway Switching Systems 
Control systems 
o Computational and timing requirements of direct computer control 
o Hierarchical structure 
o Intelligent control 
o E.g., Chemical and Nuclear Plant Control, flight control 
Embedded systems 
o Resource limitation 
o E.g., Automotive applications 
Spring ‘09 CIS 480 12 
Current State 
Ad hoc techniques, heuristic approaches. 
Code written in C, assembly language 
Programmed timers 
Low level device handling 
Direct manipulation of task and interrupt priorities. 
Goal:  Optimized predictable execution on simple 
architectures. 
7 
Spring ‘09 CIS 480 13 
Drawbacks 
Tedious programming 
o Code quality depends on the programmer 
Difficult to understand, maintain, and reuse 
Verification/testing of timing constraints is practically 
impossible 
System could collapse in rare and unforeseen 
circumstances leading to disasters 
Spring ‘09 CIS 480 14 
Laws of Real Time Systems [Buttazzo] 
If something can go wrong, it will go wrong. 
(Murphy’s law) 
Any software bug will tend to maximize damage 
The worst software bug will be discovered 6 months 
after the field test 
A system will stop working at the worst possible 
time 
Sooner or later the worst possible combinations of 
circumstances will occur 
8 
Concepts, methods, and Techniques 
Formal methods 
Time triggered architecture 
Real-time scheduling 
Feedback in computer systems 
Assurance cases 
Etc. 
Spring ‘09 CIS 480 15 
Spring ‘09 CIS 480 16 
Formal Methods (The Ideal!) 
Model real time systems precisely 
o  External events 
o  System events 
Verify timing properties 
Propagate timing constraints down to the system 
level 
Verify implementation meets the specification at 
each level 
9 
What are formal methods? 
Techniques for analyzing systems, based on some 
mathematics. 
This does not mean that the user must be a 
mathematician. 
Some of the work is done in an informal way, due to 
complexity. 
Spring ‘09 17 CIS 480 
Examples for FM 
Deductive verification: 
Using some logical formalism, prove formally that the software satisfies its 
specification. 
Model checking: 
Use some software to automatically check that the software satisfies its 
specification. 
Testing: 
Check executions of the software according to some coverage scheme. 
Spring ‘09 18 CIS 480 
10 
Typical situation: 
Boss: Mark, I want that the new robot software will 
be flawless. OK? 
Mark: Hmmm. Well. Oh! Ah??? Where do I start? 
Bob: I have just the solution for you. It would solve 
everything. 
Spring ‘09 19 CIS 480 
Some concerns 
Which technique? 
Which tool? 
Which experts? 
What limitations? 
What methodology? 
At which points? 
How expensive? 
How many people? 
Needed expertise 
Kind of training 
Size limitations 
Exhaustiveness 
Reliability 
Evidence 
Expressiveness 
Support 
Spring ‘09 20 CIS 480 
11 
Seven Myths of Formal Methods 
Myth 1: Formal methods can guarantee that software is perfect 
Myth 2: Formal methods are about program proving 
Myth 3: Formal methods are only useful for safety-critical systems 
Myth 4: Formal methods require highly trained mathematicians 
Myth 5: Formal methods increases the cost of development 
Myth 6: Formal methods are unacceptable to users 
Myth 7: Formal methods are not used on real, large-scale software 
[Anthony Hall, IEEE Computer, Sep 1990] 
Spring ‘09 CIS 480 21 
Some exaggerations 
Automatic verification can always find errors. 
Deductive verification can show that the software is 
completely safe. 
Testing is the only industrial practical method. 
Spring ‘09 22 CIS 480 
12 
10/1/98 23 
Advantages of Formal Methods 
Formal methods treat system components as 
mathematical objects and provide mathematical 
models to describe and predict the observable 
properties and behaviors of these objects. 
There are several advantages to using formal 
methods for the specification and analysis of real-
time systems. 
o the early discovery of ambiguities, inconsistencies and 
incompleteness in informal requirements 
o the automatic or machine-assisted analysis of the 
correctness of specifications with respect to requirements 
o the evaluation of design alternatives without expensive 
prototyping 
Our approach 
Learn several methods (deductive verification, 
model checking, testing process algebra). 
Learn advantages and limitations, in order to choose 
the right methods and tools. 
Learn how to combine existing methods. 
Spring ‘09 24 CIS 480 
13 
Things to do 
Check the kind of 
software to analyze. 
Choose methods and 
tools. 
Express system 
properties. 
Model the software. 
Apply methods. 
Obtain verification results. 
Analyze results. 
Identify errors. 
Suggest correction. 
Spring ‘09 25 CIS 480 
Different types of software 
Sequential. 
Concurrent. 
Distributed. 
Reactive. 
Real-time. 
Protocols. 
Abstract algorithms. 
Finite state. 
Spring ‘09 26 CIS 480 
14 
27 
Formal Specification Methods 
Logic 
o Z, VDM, First order logic, temporal logic 
State Machines 
o Finite state machines, communicating state machines, 
extended state machines 
o State Chart, Objectime, Automata, Timed Automat 
Petri Nets 
Process Algebra  
o CSP , CCS, ATP, ACSR 
o CWB, PARAGON 
28 
Verification Methods 
Verification is to show 
Behavior(Design)   Behavior(Requirement) 
Verification Methods 
o Proof System : SP  f   
o Model Checking : Pd           f  
o Behavioral Specification : Pd  sat  f 
    E.g. 0 <=(# of coins in t) - (# of candies in t) <= 1 
o Algebraic(bisimulation, process containment):  
Pr ~ Pd,, Pr    Pd,  

