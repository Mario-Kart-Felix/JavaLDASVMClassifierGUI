A Model for Attribute Based Role-Role
Assignment (ARRA)
aJiwan L. Ninglekhu and bRam Krishnan
Department of Electrical and Computer Engineering
The University of Texas at San Antonio
San Antonio, Texas 78249
Email: ajiwan.ninglekhu@gmail.com and bram.krishnan@utsa.edu
Abstract—Administrative Role Based Access Control
(ARBAC) models specify how to manage user-role as-
signments (URA), permission-role assignments (PRA), and
role-role assignments (RRA). Many approaches have been
proposed in the literature for URA, PRA and RRA. In
this paper, we propose a model for attribute-based role-
role assignment (ARRA), a novel way to unify prior RRA
approaches. We leverage the idea that attributes of various
RBAC entities such as admin users and regular roles can
be used to administer RRA in a highly-flexible manner. We
demonstrate that ARRA can express and unify prior RRA
models.
Index Terms—Roles, Role Hierarchy, RBAC, ARBAC,
Access Control, Administration.
I. INTRODUCTION
Role-based access control (RBAC) [1], [2] model
is well studied in academia [3] and well adopted in
the industry [4]. In RBAC, assignment of users and
permissions to roles allows users to execute permissions
by activating roles.
Administrative RBAC (ARBAC), which involves in
user-role assignment and revocation (URA), permission-
role assignment and revocation (PRA), and role-role
assignment and revocation (RRA), is a challenging
task [5]. ARBAC has been well explored [5]–[9]. All
of these works explore URA and PRA. However, only
few cover RRA [5], [8]. Each of these models use few
fixed set of properties of RBAC in making assignment
decisions. For example, In RRA97 [5], an admin role is
given admin authority over set of roles, called role range,
where admin role can perform role assignment.
Recently, Attribute-Based Access Control (ABAC) has
gained popularity because of its flexibility [10]–[14].
ABAC has also proven its ability to represent different
access control models [12]. However, it has rarely been
used in administration of RBAC.
Among three main aspects of ARBAC, we have ex-
plored models for attribute-based user-role assignment
(AURA) and attribute-based permission-role assignment
(ARPA) models [15].
In this paper we present our model for attribute-
based role-role assignment (ARRA), a follow-up work
on AARBAC [15]. ARRA is driven by our objective to
design attribute-based model that allows us to express
features from previous RRA models and more. For ex-
ample, it allows us to express features as a combination
of two prior models and in addition, allows us to add
new features. Thus, this work is motivated largely by
two critical factors: (a) an objective to build a coherent
model, which can be configured to express prior models
and more (b) build a unified model that can be analyzed
for various desirable security features, which can provide
a single codebase to express prior models and beyond.
The contributions of this paper are as follows:
• We develop an attribute-based administrative model
for role-role assignment (ARRA).
• We demonstrate that ARRA is capable of express-
ing prior approaches to RRA such as RRA97 [5]
and UARBAC’s RRA [8].
The remainder of this paper is organized as follows.
In Section II, we discuss related work. In Section III,
ARRA model is presented. Section IV presents algo-
rithms that translate prior RRA instances into equivalent
ARRA instances. Section V concludes the paper.
II. RELATED WORK
Among many prominent works done for ARBAC [5]–
[9], ARBAC97 [5] and UARBAC [8] present role-role
assignment (RRA) as part of their model.
In RRA97, a set of roles in the hierarchy called au-
thority range is given to an admin role for decentralized
administration. A user with admin role can perform
operations like inserting an edge or creating a role,
on roles in her authority range. To confirm autonomy
RRA97 requires role range to be encapsulated [5].
ar
X
iv
:1
70
6.
10
27
4v
1 
 [
cs
.C
R
] 
 3
0 
Ju
n 
20
17
UARBAC [8] redefines RBAC model with class ob-
jects. It treats each entity in the RBAC system such as
files, roles and users as objects. UARBAC’s RRA deals
with assigning/revoking role-role on the basis of admin
user’s authority over individual roles specified by access
modes. Class permissions in UARBAC allows an admin
user to conduct an operation over every object of a class.
In both of these models, the policy for assigning a
role to a role is based on a fixed set of properties of
the entities such as admin role, admin user and regular
roles, involved in assigning/revoking roles.
Crampton et. al [16] present models for RRA with
administrative scopes. Admin scopes are plausible ap-
proach for role hierarchy operations in RBAC. However,
admin scopes may not be intuitive to express as a role
attribute. Many literature [10], [17], [18] present benefits
of integrating attributes into an RBAC operational model.
An operational model deals with making decisions on
user’s access request for objects. There are many works
on operational aspects of ABAC [11], [12], [19], [20].
In contrast, ARRA is an administrative model that uses
attributes of RBAC entities for assigning/revoking roles.
III. ARRA MODEL
In this section, we present our approach for attribute-
based role-role assignment (ARRA). Inspired by prior
RRA models we have included attributes for admin
users, admin roles and regular roles. Based on these
attributes role assignment and revocation decisions on
are made.
Table I presents formal ARRA model. The entities in-
volved in ARRA comprise of admin users (AU), regular
roles (ROLES) and their hierarchy (RH), admin roles
(AR) and their hierarchy (ARH), admin user to admin
role relation (AUA) and admin operations (AOP).
In ARRA, admin user in AU wants to perform admin
operation such as assign or revoke from AOP using
attributes of entities in the model. We have developed
admin users attribute functions (AATT) and admin roles
attribute functions (ARATT). We have also introduced
regular roles attribute functions (RATT) based on the
need we have observed. Attributes from other RBAC
entities can also be developed if needed. We will later
see that we need attributes from different entities in
representing properties of RRA97 and UARBAC’s RRA
in ARRA.
The attribute functions or simply attributes are defined
as mapping from its domain such as AU or AR to
its range. Range of an attribute att can be atomic or
set valued, which is specified by function attType. It
is derived from set of scope or atomic values denoted
by Scope(att). Furthermore, the scope of an attribute
can be either ordered or unordered, which is given by
a function called is_ordered(att). If it is ordered, we
must specify that attribute’s hierarchy denoted by Hatt
on its scope Scope(att). Hatt is a partial ordering on
Scope(att). Note that even in the case of a set valued
attribute att, the hierarchy Hatt is specified on Scope(att)
instead of 2Scope(att). We infer the ordering between two
set values given an ordering on atomic values. H*att in
Table I denotes the reflexive transitive closure of Hatt.
In ARRA, there are two ways by which an admin user
can select a set of regular roles for assignment to a target
regular role. The first way allows an admin user to select
a single role and a target role, and perform an admin
operation like assign or revoke. The second way allows
an admin user to select a set of regular roles, the target
role and perform similar operation on those roles. In the
latter case, the selection criteria for the set of regular
roles can be expressed using a set-builder notation whose
rule is based on the regular role attributes. For example,
is_authorizedRassign(au, {r1 | r1 ∈ ROLES ∧ Lead ∈
roleTitle(r1)}, r2) would specify a policy for an admin
user au that selects the set of all the roles with role
title Lead in order to assign those roles to a role r2.
Assigning a role r1 to role r2 makes role r1 junior to r2.
In other words, it adds an entry <r2, r1> in RH. It is also
referred to as edge insetion.
Authorization rule is specified as a logical expression
on the attributes of admin users, admin roles, and that
of regular roles considered for assignment.
IV. MAPPING PRIOR RRA MODELS IN ARRA
In this section, we demonstrate that ARRA can intu-
itively simulate the features of prior RRA models. In par-
ticular, we have developed concrete algorithms that can
convert any instance of RRA97 and UARBAC’s RRA
into an equivalent ARRA instance. For each of these
models, we first present an example instance followed
by that instance’s corresponding ARRA equivalent. Then
finally, we present algorithms for each to show a pro-
grammable mapping procedure.
A. Mapping RRA97 to AARA
In this section, we present RRA97 example instance
and manually convert it into its equivalent ARRA in-
stance. We then present a mapping algorithm for the
same, which demostrates a programmable procedure for
translation of any RRA97 instance to its equivalent
ARRA instance.
2
TABLE I
ARRA MODEL
– AU, AOP, ROLES, AR are finite sets of administrative users, administrative operations such as assign and
revoke, regular roles and administrative roles, respectively.
– AUA ⊆ AU × AR, administrative user to administrative role assignment relation.
– RH ⊆ ROLES × ROLES, a partial ordering on the set ROLES.
– ARH ⊆ AR × AR, a partial ordering on the set AR.
– AATT, ARATT, and RATT are finite sets of administrative user attribute functions, administrative role
attribute functions, and regular role attribute functions, respectively.
– For each att in AATT ∪ ARATT ∪ RATT, Scope(att) is a finite set of atomic values from which the range
of the attribute function att is derived.
– attType : AATT ∪ ARATT ∪ RATT → {set, atomic}, which specifies whether the range of a given attribute
is atomic or set valued.
– Each attribute function maps elements in AU, AR and ROLES to atomic or set values.
∀aatt ∈ AATT. aatt : AU→
 Scope(aatt) if attType(aatt) = atomic2Scope(aatt) if attType(aatt) = set
∀aratt ∈ ARATT. aratt : AR→
 Scope(aratt) if attType(aratt) = atomic2Scope(aratt) if attType(aratt) = set
∀ratt ∈ RATT. ratt : ROLES→
 Scope(ratt) if attType(ratt) = atomic2Scope(ratt) if attType(ratt) = set
– is_ordered : AATT ∪ ARATT ∪ RATT → {True, False}, specifies if the scope is ordered for each of the
attributes.
– For each att ∈ AATT ∪ ARATT ∪ RATT,
if is_ordered(att) = True, Hatt ⊆ Scope(att) × Scope(att), a partially ordered attribute hierarchy, and Hatt 6= φ,
else, if is_ordered(att) = False, Hatt = φ
(For some att ∈ AATT ∪ ARATT ∪ RATT for which attType(att) = set and is_ordered(att) = True, if {a, b},
{c, d} ∈ 2Scope(att) (where a, b, c, d ∈ Scope(att)), we infer {a, b} ≥ {c, d} if (a, c), (a, d), (b, c), (b, d)
∈ H*att.)
ARRA model allows an administrator to perform an operation on a single role or a set of roles at a time. The
authorization rule for performing an operation on a single role is as follows:
For each op in AOP, is_authorizedRop(au: AU, r1 : ROLES, r2 : ROLES) specifies if the admin user au is
allowed to perform the operation op (e.g. assign, revoke, etc.) between the regular roles r1 and the role r2.
Assigning a role r1 to r2 makes r1 junior to r2. This rule is written as a logical expression using attributes of
admin user au, admin role, ar, and regular role, r.
The authorization rule for performing an operation on a set of users is as follows:
For each op in AOP, is_authorizedRop(au: AU, χ : 2ROLES, r : ROLES) specifies if the admin user au is
allowed to perform the operation op (e.g. assign, revoke, etc.) between the roles in the set χ and the role r.
Here χ is a set of roles that can be specified using a set-builder notation, whose rule is written using role
attributes.
3
DIR	
E
PL2	PL1	
ED	
E1	 E2	
PE1	 PE2	QE1	 QE2	 SSO	
DSO	
PSO1	 PSO2	
(a)	Roles	 (b)	Administra<ve	Roles	
Fig. 1. Role and Administrative Role Hierarchies in RRA97
1) An RRA97 Example Instance: RRA97 [5] assumes
an existing regular role hierarchy and an administrative
role hierarchy as depicted in Figure 1. An example
instance for RRA97 model is presented as follows:
Sets and Functions:
• USERS = {u1, u2, u3, u4}
• ROLES = {ED, E1, PE1, QE1, PL1, E2, PE2,
QE2, PL2, DIR}
• AR = {DSO, PSO1}
• AUA = {(u3, DSO), (u4, PSO1)}
• RH = {<ED, E1>, <E1, QE1>, <E1, PE1>,
<PE1, PL1>, <QE1, PL1>, <ED, E2>,
<E2, PE2>, <E2, QE2>, <PE2, PL2>,
<QE2, PL2>, <PL1, DIR>, <PL2, DIR>}
• ARH = {<SSO, DSO>, <DSO, PSO1>,
<DSO, PSO2>}
• can-modify = {(DSO, (ED, DIR)),
(PSO1, (E1, PL1)), (PSO1, (E2, PL2))}
Where, (ED, DIR) = {E1, E2, PE1, PE2, QE1,
QE2, PL1, PL2},
(E1, PL1) = {PE1, QE1} and,
(E2, PL2) = {PE2, QE2}
USERS, ROLES, and AR are sets of users, regular
roles and admin roles, respectively. User u3 is given
admin role DSO and PSO1 is given to role u4. RH and
ARH represent regular role and admin role hierarchies as
depicted in Figure 1. We have taken original can-modify
example from RRA97 paper [5] where each admin role is
mapped with authority ranges. The can-modify set in our
instance depicts the same scenario with three elements:
(DSO, (ED, DIR)), (PSO1, (E1, PL1)) and (PSO1, (E2,
PL2)). It shows that role DSO is given an authority
range (ED, DIR) while role PSO1 is given two authority
ranges (E1, PL1) and (E2, PL2).
In RRA97, an authority range, (x, y) = {r : ROLES |
x < r < y}, where x and y are end points of the range.
For every (ar, (x, y)) in can-modify, the range denoted
by (x, y) must be an encapsulated authority range. A
range (x, y) is said to be encapsulated if,
∀r1 ∈ (x, y) ∧ ∀r2 /∈ (x, y). [r2 > r1 ↔ r2 > y ∧
r2 < r1 ↔ r2 < x]
A new edge AB can be inserted between two incompa-
rable roles A and B under following two conditions:
• ARimmediate(A) = ARimmediate(B). An immediate au-
thority range of a role r, ARimmediate(r) is the au-
thority range (x,y) such that r ∈ (x, y) and for all
authority ranges (x', y') junior to (x, y) we have r
/∈ (x', y'). or,
• if (x, y) is an authority range such that (A = y ∧ B
> x) ∨ (B = x ∧ A < y) then insertion of AB must
preserve encapsulation of (x, y).
2) ARRA Instance Equivalent to RRA97 Instance: In
this section, we show a manual translation of RRA97
example instance presented in previous segment into an
equivalent ARRA instance. Equivalent ARRA instance
is as follows:
Map RRA97 sets to ARRA sets
• AU = {u1, u2, u3, u4}
• AOP = {insertEdge, deleteEdge}
• ROLES = {ED, DIR, E1, PE1, QE1, PL1, E2,
PE2, QE2, PL2, DIR}
• AUA = {(u3, DSO), (u4, PSO1)}
• RH = {<ED, E1>, <E1, QE1>, <E1, PE1>,
<PE1, PL1>, <QE1, PL1>, <ED, E2>,
<E2, PE2>, <E2, QE2>, <PE2, PL2>,
<QE2, PL2>, <PL1, DIR>, <PL2, DIR>}
Define attributes
• AATT = {}, RATT = {}
• ARATT= {authRange}
• Scope(authRange) = RH+,
attType(authRange) = set,
is_ordered(authRange) = False, HauthRange = φ
• authRange(DSO) = {ED, DIR},
authRange(PSO1) = {(E1, PL1), (E2, PL2)}
Construct authorization rule for insertEdge
To assign role r1 to role r2 (or to insert an edge r1r2 and
hence add <r2, r1> to RH),
– is_authorizedRinsertEdge(au : AU, r1 : ROLES, r2 :
ROLES) ≡
(∃(au, ar1) ∈ AUA, ∃(s, t) ∈ authRange(ar1). r1, r2 ∈
ds, te) ∧ ((∃(m, n), (m', n') ∈
⋃
ar2∈ AR
authRange(ar2).
r1, r2 dm, ne ∧ (dm', n'e ⊂ dm, ne → r1, r2 /∈ (m', n')))
4
∨ (∃(x,y) ∈
⋃
ar3∈ AR
authRange(ar3). ((r1 = y ∧ r2 > x)
∨ (r2 = x ∧ r1 < y)) ∧ (∀p ∈ dx, ye ∧ ∀q /∈ dx, ye. (<q,
p> ∈ (RH ∪ <r2, r1>)* ↔ <q, y> ∈ (RH ∪ <r2, r1>)*)
∧ (<p, q> ∈ (RH ∪ <r2, r1>)* ↔ <x, q> ∈ (RH ∪ <r2,
r1>)*))))
Construct authorization rule for deleteEdge
– is_authorizedRdeleteEdge(au : AU, r1 : ROLES, r2 :
ROLES) ≡
∃(au, ar) ∈ AUA, ∃(x, y) ∈ authRange(ar). r1, r2
∈ dx, ye ∧ ∀(u, v) ∈
⋃
ar4∈ AR
authRange(ar4), ∃<r2, r1>
∈ RH. (r1 6= u ∧ r2 6= v)
As we can observe, the process of translation involves
four main steps. First, we map given sets from RRA97
to equivalent sets in ARRA. Second, required attribute
functions are defined. We have designed admin role
attribute authRange that maps authority ranges given
to admin roles. Attribute authRange is set valued and
unordered. Scope of authRange is a transitive clousure
of regular role hierarchy, RH+. That is, if <a, b>, <b, c>,
<c, d> ∈ RH+, then <a, d> is also true.
We know that authority range represents a set of roles
over which an admin role have authority to conduct
operations such as assign and revoke. In ARRA, we
use symbolic representation of authority range with end
points a and b as (a, b). However, whenever we need
to work with roles present in the set represented by
authority range (a, b), we denote the set of roles with
da, be. That is, da, be = {r | r ∈ ROLES ∧ a < r < b}.
Next, we construct authorization rule for the admin
operation insertEdge. There are fundamentally three
requirements that an admin user must consider to assign
role r1 to role r2. Firstly, both the roles r1 and r2 must
be within the authority range of an admin role assigned
to a given admin user. Secondly, both the roles taken
for edge insertion must have same immediate authority
range, or (thirdly) if the edge is to be inserted between
a role on the top end point of an authority range and
a role senior to the lower end point of authority range,
or if the edge is to be inserted between a role on the
bottom end of an authority range and a role junior to the
top end of the authority range, then that edge insertion
must preserve encapsulation of an authority range with
those (top and bottom) end points. Finally, we construct
an authorization formula for operation deleteEdge. An
admin user with an admin role can delete an edge
between any two roles in an authority range except that
any edge between the end points of an authority range
can not be deleted.
Algorithm 1. MapRRA97
Input: RRA97 instance
Output: ARRA instance
Step 1: /* Map basic sets and functions in AURA */
a. AU ← USERS97
b. AOPA ← {insertEdge, deleteEdge}
c. ROLESA ← ROLES97 ; AUAA ← AUAU
b. RHA ← RH97
Step 2: /* Map attribute functions in AURA */
a. AATTA ← {} ; RATTA ← {}
b. ARATTA ← {authRange}
c. ScopeA(authRange) = RH+A
d. attTypeA(authRange) = set
e. is_orderedA(authRange) = False ; HAauthRange = φ
f. For each ar ∈ ARA, authRange(ar) = φ
g. For each (ar, (ri, rj)) ∈ can-modify97,
authRange(ar) = authRange(ar) ∪ (ri, rj)
Step 3: /* Construct assign rule in AURA */
a. assign_formula = φ
b. For each (ar, (ri, rj)) ∈ can-modify97,
assign_formula' = assign_formula ∨
(∃(au, ar1) ∈ AUA, ∃(s, t) ∈ authRange(ar1). r1,
r2 ∈ ds, te) ∧ ((∃(m, n), (m', n') ∈
⋃
ar2∈ AR
au-
thRange(ar2). r1, r2 dm, ne ∧ (dm', n'e ⊂ dm,
ne → r1, r2 /∈ (m', n'))) ∨ (∃(x,y) ∈
⋃
ar3∈ AR
authRange(ar3). ((r1 = y ∧ r2 > x) ∨ (r2 = x ∧
r1 < y)) ∧ (∀p ∈ dx, ye ∧ ∀q /∈ dx, ye. (<q, p> ∈
(RH ∪ <r2, r1>)* ↔ <q, y> ∈ (RH ∪ <r2, r1>)*)
∧ (<p, q> ∈ (RH ∪ <r2, r1>)* ↔ <x, q> ∈ (RH ∪
<r2, r1>)*))))
c. auth_assign = is_authorizedRinsertEdge(au : AUA,
r1 : ROLESA, r2 : ROLESA) ≡ assign_formula'
Step 4: /* Construct revoke rule for AURA */
a. revoke_formula = φ
b. For each (ar1, (r1, r2)) ∈ can-modify97,
revoke_formula' = revoke_formula ∨
∃(au, ar) ∈ AUA, ∃(x, y) ∈ authRange(ar). r1, r2
∈ dx, ye ∧ ∀(u, v) ∈
⋃
ar4∈ AR
authRange(ar4),
∃<r2, r1> ∈ RH. (r1 6= u ∧ r2 6= v)
c. auth_revoke = is_authorizedRdeleteEdge(au : AUA,
r1 : ROLESA, r2 : ROLESA) ≡ revoke_formula'
5
B. MapRRA97
Algorithm 1 presents MapRRA97, a translation algo-
rithm for any RRA97 instance into an equivalent ARRA
instance. Superscript labels 97 and A in the algorithm
represent sets and functions from RRA97 and ARRA, re-
spectively. MapRRA97 takes an instance of RRA97 as in-
put. In particular, input consists of USERS97, ROLES97,
AR97, AUA97, RH97, ARH97, and can-modify97. The
can-modify instruction covers operations for inserting an
edge, deleting an edge, creating a role and deleting a
role. ARRA can simulate inserting edge and deleting an
edge. However, creating and deleting roles are beyond
the scope of current ARRA model.
Output from MapRRA97 algorithm is an equiva-
lent ARRA instance, with following sets and func-
tions. AUA, AOPA, ROLESA, AUAA, RHA, ARHA,
AATTA, ARATTA, For each attribute att ∈ ARATTA,
ScopeA(att), attTypeA(att), is_orderedA(att) and HAatt,
For each admin role ar ∈ ARA and for each
att ∈ ARATTA, att(ar), Authorization rule for as-
sign (auth_assign), and Authorization rule for revoke
(auth_revoke).
Steps indicated in MapRRA97 correspond to the steps
described in equivalent ARRA instance for RRA97 in
section IV-A2. We explain it here briefly. Step 1 maps
sets from RRA97 to ARRA sets and functions. In Step
2, admin user attributes and admin role attributes are
expressed. AATT and RATT are left empty as there is
no use case for these attributes in translating RRA97.
Admin role attribute authRange captures the mapping
between an authority range as defined in RRA97, and an
admin role. For each (ar, (ri, rj)) in set can-modifySS97,
authRange(ar) populates set of authority ranges for ar.
In Step 3, we construct assign_formula rule for ARRA
that is equivalent to inserting an edge in can_modify97.
For each (ar, (ri, rj)) in set can-modifySS97, logical
expression that checks the assignment conditions is
constructed. Equivalent translation in ARRA is given
by is_authorizedRinsertEdge(au : AUA, rß1 : ROLESA,
rß2 : ROLESA). This formula must checks if roles rß1
and rß2 belong in an authority range of an admin role,
which is mapped to admin user au. It further checks if
rß1 and rß2 have same immediate authority range, or
checks if any other assignment action doesn’t violate
encapsulation of admin role’s authority range. Similarly,
In Step 4, revoke_formula equivalent to deleting an edge
from can_modify97 is expressed. It checks if admin role
mapped to admin role au has authority range where
rß1 and rß2 belong and restricts from deleting an edge
between end points of any authority range.
C. Mapping UARBAC’s RRA to ARRA
In this section, we present an example instance for
UARBAC’s RRA and its equivalent ARRA instance. We
then present an algorithm that outlines the translation
procedure.
1) An Example UARBAC’s RRA Instance:
RBAC schema
• C = {role}
• OBJS(user) = USERS, OBJS(role) = ROLES
• AM(role) = {grant, empower, admin}
RBAC state
• USERS = OBJ(user) = {u1, u2, u3, u4}
• ROLES = OBJ(role)= {r1, r2, r3}
• P = [role, r1, grant], [role, r1, empower], [role,
r1, admin], [role, r2, grant], [role, r2, empower],
[role, r2, admin], [role, r3, grant], [role, r3, em-
power], [role, r3, admin], [role, grant], [role,
empower], [role, admin]}
• RH = {<r2, r3>}
Administrative permissions of UARBAC’s RRA
Following is the list of administrative permissions each
user has for role-role assignment:
• authorized_perms[u1] = {[role, r1, grant],
[role, r2, admin], [role, r2, empower],
[role, r3, admin]}
• authorized_perms[u2] = {[role, r1, admin],
[role, r1, empower], [role, r2, empower],
[role, r3, grant]}
• authorized_perms[u3] = {[role, admin]}
• authorized_perms[u4] = {[role, grant],
[role, empower], [role, admin]}
Role-role assignment condition
One can perform following operation to assign a role r1
to another role r2.
• grantRoleToRole(r1, r2)
To perform this operation one needs one of the following
two permissions:
• [role, r1, grant] and [role, r2, empower] or,
• [role, grant] and [role, r2, empower] or,
• [role, r1, grant] and [role, empower] or,
• [role, grant] and [role, empower]
Condition for revoking a role from another role
To revoke a role r2 from a role r3, admin user performs
following operation.
• revokeRoleFromUser(r2, r3)
To conduct this operation one needs one of the following
options:
• [role, r2, grant] and [role, r3, empower]
6
• [role, r2, admin]
• [role, r3, admin]
• [role, admin]
D. ARRA instance equivalent to UARBAC’s RRA in-
stance
This segment presents equivalent instance for UAR-
BAC’s RRA example instance presented in previous
segment.
Map UARBAC’s RRA sets to ARRA sets
• AU = {u1, u2, u3, u4}
• AOP = {assign, revoke}
• ROLES = {r1, r2, r3},
• AUA = {}
• RH = {<r2, r3>}
Define Attributes
• AATT = {grantAuth, empowerAuth, adminAuth,
roleClassAuth}, ARATT = {}, RATT = {}
• Scope(grantAuth) = {r1, r2, r3}
attType(grantAuth) = set,
is_ordered(grantAuth) = ROLES, HgrantAuth = RH
• grantAuth(u1) = {r1}, grantAuth(u2) = {r3},
grantAuth(u3) = {}, grantAuth(u4) = {}
• Scope(empowerAuth) = {r1, r2, r3}
attType(empowerAuth) = set,
is_ordered(empowerAuth) = ROLES
HempowerAuth = RH
• empowerAuth(u1) = {r2},
empowerAuth(u2) = {r1, r2},
empowerAuth(u3) = {}, empowerAuth(u4) = {}
• Scope(adminAuth) = {r1, r2, r3}
attType(adminAuth) = set,
is_ordered(adminAuth) = ROLES,
HadminAuth = RH
• adminAuth(u1) = {r2, r3},
adminAuth(u2) = {r1},
adminAuth(u3) = {}, adminAuth(u4) = {}
• Scope(roleClassAuth) = AM(role)
attType(roleClassAuth) = set,
is_ordered(roleClassAuth) = False,
HroleClassAuth = φ
• roleClassAuth(u1) = {}, roleClassAuth(u2) = {},
roleClassAuth(u3) = {admin},
roleClassAuth(u4) = {grant, empower, admin}
Construct authorization rule for role-role assignment
For each op in AOP, authorization rule to assign/revoke
role-role can be expressed as follows:
To assign any regular role r1 ∈ ROLES to regular role
r2 ∈ ROLES,
– is_authorizedUassign(au : AU, r1 : ROLES,
r2 : ROLES) ≡
(r1 ∈ grantAuth(au) ∧ r2 ∈ empowerAuth(au)) ∨
(r1 ∈ grantAuth(au) ∧ empower
∈ roleClassAuth(au)) ∨ (grant ∈ roleClassAuth(au) ∧
r2 ∈ empowerAuth(au)) ∨ (grant ∈ roleClassAuth(au)
∧ empower ∈ roleClassAuth(au))
Construct authorization rule for revoking role-role
To revoke any regular role r1 ∈ ROLES from another
regular role r2 ∈ ROLES,
– is_authorizedUrevoke(au1 : AU, r1 : ROLES,
r2 : ROLES) ≡
(r1 ∈ grantAuth(au) ∧ r2 ∈ empowerAuth(au)) ∨
r1 ∈ adminAuth(au) ∨ r2 ∈ adminAuth(au) ∨
admin ∈ roleClassAuth(au)
There are four main stages in this translation process.
First, we map main sets from UARBAC’s RRA to
ARRA model. Set of admin users consists of set of
users from UARBAC’s RRA, namely u1, u2, u3, and
u4. There are two admin operations, assign and revoke.
Sets ROLES and RH map set of roles and role hierarchy
from UARBAC’s RRA, respectively. AUA is left empty
as there is no notion of admin roles in UARBAC.
Next, we define required attribute functions. We used
admin user attributes to express ARRA for UARBAC’s
RRA. Among four admin user attributes, grantAuth,
empowerAuth and adminAuth are object level attributes.
Each of these attributes express the nature of authority
an admin user has over different roles. For example,
empowerAuth over a role rx, allows admin user to assign
any object such as a user and/or another role to role rx.
Class level attribtue roleClassAuth captures the nature
of access mode an admin user has towards role class.
The scope of this attribute is AM(role), which has
three different types of access modes, namely grant,
empower and admin. For example, an admin user with
roleClassAuth of grant allows that admin user to grant
(assign) any role to other object such as a user and/or
role. Translation of UARBAC’s RRA doesn’t require
admin role and regular role attributes, hence left empty.
After attributes have been defined we construct the
assignment formula (assign_formula), using usual logi-
cal expression. As mentioned in the UARBAC’s RRA
instance, there are four different combination of permis-
sions an admin user can use to make role-role assign-
ment. An equivalent logical expression is captured as
is_authorizedUassign(au : AU, r1 : ROLES, r2 : ROLES).
Finally, we construct a logical expression which captures
four different permission options that an admin user can
7
use for revoking a role from another role. The logical
expression is equivalent to is_authorizedUrevoke(au1 :
AU, r1 : ROLES, r2 : ROLES).
E. MapRRA-UARBAC
We presented example instances for UARBAC’s RRA
and its equivalent AARA instance in previous seg-
ments. Algorithm 2 presents MapRRA-UARBAC, a pro-
cedure to map any instance of UARBAC’s RRA [8]
to its equivalent ARRA instance. It take instance of
UARBAC’s RRA as its input and yields an equivalent
AARA instance as its output. Sets and functions from
UARBAC and ARRA are labeled with superscripts U
and A, respectively. Input consists of CU, USERSU,
ROLESU, PU, RHU, AMU(role), For each u ∈ USERSU,
authorized_permsU[u], and For every r1, r2 ∈ ROLESU.
Grant operation grantRoleToRole(r1, r2) will be true if
the granter has either [role, r2, empower] and [role,
r1, grant] or, [role, r2, empower] and [role, grant]
or, [role, empower] and [role, r1, grant] or, [user,
empower] and [role, grant] permissions towards roles.
For each r1, r2 ∈ ROLESU, revokeRoleFromUser(r1,
r2) is true if the granter has either [role, r2, empower]
and [role, r1, grant] or, [role, r1, admin] or, [role, r2,
admin] or, [role, admin] permission on roles.
MapRRA-UARBAC yields an ARRA instance consisting
of AUA, AOPA, ROLESA, ARA, AUAA, RHA, ARHA,
AATTA, For each attribute att ∈ AATTA, ScopeA(att),
attTypeA(att), is_orderedA(att) and HAatt, For each user
au ∈ AUA, and for each att ∈ AATTA, att(au), Autho-
rization rule for assign (auth_assign), and Authorization
rule for revoke (auth_revoke).
In Step 1 primary sets from UARBAC’s RRA are
mapped to AURA equivalent sets. In Step 2, admin
user attributes are defined. In UARBAC model, role-
role assignment decisions are based on the admin user’s
access modes such as grant, empower and admin
towards regular roles. For example, for each permission
[role, r, grant] in authorized_permsU[u], grantAuth(au)
attribute extracts set of roles towards which an admin
user au has grant authority. In other words, admin user
can grant those roles to any other object such as user
and role. Similarly, empowerAuth yields set of roles to
which an admin user has empower access mode and
adminAuth yields sets of roles about which admin user
has admin access mode. The meaning of each access
mode is preserved by UARBAC model. For each class
level attribute [c, am] in authorized_permsU[u], where
c is a type of class and am is type of access mode,
roleClassAuth(au) specifies the nature of class level
Algorithm 2. MapRRA-UARBAC
Input: Instance of RRA in UARBAC
Output: ARRA instance
Step 1: /* Map basic sets and functions in AURA */
a. AUA ← USERSU ; AOPA ← {assign, revoke}
b. ROLESA ← ROLESU ; AUAA = φ
c. RHA ← RHU
Step 2: /* Map attribute functions in AURA */
a. AATTA ← {grantAuth, empowerAuth, adminAuth,
roleClassAuth}, ARATT = {}, RATT = {}
b. ScopeA(grantAuth) = ROLESA,
c. attTypeA(grantAuth) = set
d. is_orderedA(grantAuth) = True, HAgrantAuth = RHA
e. For each u in AUU, grantAuth(u) = φ
f. For each u in USERSU and
for each [role, r, grant] ∈ authorized_permsU[u],
grantAuth(u)' = grantAuth(u) ∪ (r)
g. ScopeA(empowerAuth) = ROLESA,
h. attTypeA(empowerAuth) = set
i. is_orderedA(empowerAuth) = True,
j. HAempowerAuth = RHA
k. For each u in AUU, empowerAuth(u) = φ
l. For each u in USERSU and
for each [role, r, empower]
∈ authorized_permsU[u],
empowerAuth(u)' = empowerAuth(u) ∪ r
m. ScopeA(adminAuth) = ROLESA
n. attTypeA(adminAuth) = set
o. is_orderedA(adminAuth) = True,
p. HAadminAuth = RHA
q. For each u in USERSA, adminAuth(u) = φ
r. For each u in USERSU and
for each [role, r, admin] ∈ authorized_permsU[u],
adminAuth(u)' = adminAuth(u) ∪ r
s. ScopeA(roleClassAuth) = AMU(role)
t. attTypeA(roleClassAuth) = set
u. is_orderedA(roleClassAuth) = False
v. HAroleClassAuth = φ
w. For each u in USERSA, roleClassAuth(u) = φ
x. For each u in USERSU
for each [c, am] ∈ authorized_permsU[u],
roleClassAuth(u)'= roleClassAuth(u) ∪ am
Step 3: /* Construct assign rule in AURA */
a. assign_formula = (r1 ∈ grantAuth(au) ∧
r2 ∈ empowerAuth(au)) ∨ (r1 ∈ grantAuth(au) ∧
empower ∈ roleClassAuth(au)) ∨
(grant ∈ roleClassAuth(au) ∧
r2 ∈ empowerAuth(au)) ∨
(grant ∈ roleClassAuth(au) ∧
empower ∈ roleClassAuth(au))
8
Continuation of Algorithm 1. MapRRA-UARBAC
b. auth_assign =
is_authorizedUassign(au : AU, r1 : ROLES, r2 :
ROLES) ≡ assign_formula
Step 4: /* Construct revoke rule for AURA */
a. revoke_formula = r1 ∈ grantAuth(au) ∧
r2 ∈ empowerAuth(au)) ∨ r1 ∈ adminAuth(au) ∨
r2 ∈ adminAuth(au) ∨ admin ∈ roleClassAuth(au)
b. auth_revoke =
is_authorizedUrevoke(au1 : AU, r1 : ROLES, r2 :
ROLES) ≡ revoke_formula
access mode such as grant or admin admin user au has
on role class.
In Step 3, an authorization formula equivalent to
grantRoleToRole(r1, r2) in UARBAC is expressed.
Equivalent expression is_authorizedRassign(au : AUA, r1
: ROLESA, r2 : ROLESA) checks if an admin user au
grant authority over role r1 and empower authority over
role r2. Similarly, in Step 4 revoke_formula equivalent to
revokeRoleFromRole(r1, r2) is constructed using revoke
permissions given to admin user. It checks whether an
admin user au has an authority to revoke roles r1 and r2.
F. An Example Instance for ARRA with role attributes
Previous ARRA model simulation examples did not
include regular role attribute. In this section, we present
a simple yet plausible example that demonstrates a use
case for role attributes in assigning role to role.
There are two admin users, Sam and Tom, and regular
roles IT Director, Development Manager, Quality
Manager, Marketing Mganager, Finance Manager,
Support Engineer and System Analyst. There can be
many other roles in an organization. We have considered
few roles, enough to illustrate our case. Admin user
attribute dept maps each admin user to set of departments
they have admin authority over. Although, it is likely
that departments have hierarchy in practice, we have
not included hierarchy for departments for simplicity.
There are three departments in the organization, namely
Operations, Account and IT departments. Sam has
admin authority over all the departments while Tom has
authority over IT department only. There is a regular
role attribute dept for mapping regular roles to their
departments.
Authorization condition is that if an admin user
au with admin role ar was given authority over a
department d and if roles r1 and r2 belonged to the
same department d then r1 can be assigned to r2.
Sets
– AU = {Sam, Tom}, AOP = {assign, revoke}
– ROLES = {IT Director, Devlopment Mgr., Quality
Mgr., Marketing Mgr., Finance Mgr., Support
Engineer, System Analyst}
– AR = {}
– AUA = {}
– RH = {}, ARH = {}
Attributes definition
– AATT = {dept},
– Scope(dept) = {Operations, Account, IT},
attType(dept) = set, is_ordered(dept) = False,
Hdept = φ
– dept(Sam) = {Operations, Account, IT},
dept(Tom) = {IT}
– ARATT = {}, RATT = {dept, level}
– Scope(dept) = {Operations, Account, IT},
attType(dept) = atomic,
is_ordered(dept) = False, Hdept = φ
– dept(IT Director) = IT, dept(Dev. Manager) = IT,
dept(Marketing Mgr.) = Operations,
dept(QA Mgr.) = IT,
Authorization functions
– is_authorizedRassign(au : AU, r1 : ROLES, r2 :
ROLES) ≡ ∃d ∈ Scope(dept). dept(au) = dept(r1) =
dept(r2)
– is_authorizedRrevoke(au : AU, r1 : ROLES, r2 :
ROLES) ≡ is_authorizedRassign(au : AU, r1 : ROLES,
r2 : ROLES)
V. CONCLUSION
In this paper, we presented ARRA, a model for
attribute based role-role assignment. A design motivation
behind ARRA model was to make it enough to express
prior RRA models. In particular, we took RRA97 and
UARBAC’s RRA model as foundation. For these mod-
els, we have presented MapRRA97 and MapRRA-UARBAC
algorithms, which map any instances of these models to
ARRA model, respectively.
ARRA model can not only express existing RRA
models but also has a capability to do more. For instance,
prior models included in our research did not fit the no-
tion of regular role attributes. However, we acknowledge
that it is an essential attribute in making role assignment
decisions to say the least. Motivated by this notion, we
presented a simple example scenario where we made use
of regular role attributes for role-role assignment.
9
ACKNOWLEDGMENT
This work is partially supported by NSF grants CNS-
1423481 and CNS-1553696.
REFERENCES
[1] D. F. Ferraiolo, R. Sandhu, S. Gavrila, D. R. Kuhn, and
R. Chandramouli, “Proposed NIST standard for role-based access
control,” ACM Transactions Inf. Syst. Secur., vol. 4, pp. 224–274,
Aug. 2001.
[2] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman,
“Role-based access control models,” Computer, vol. 29, pp. 38–
47, Feb 1996.
[3] L. Fuchs, G. Pernul, and R. Sandhu, “Roles in information
security - A survey and classification of the research area,”
Computers & Security, vol. 30, pp. 748 – 769, 2011.
[4] A. C. OConnor and R. J. Loomis, “2010 economic analysis of
role-based access control,” NIST, Gaithersburg, MD, 2010.
[5] R. Sandhu, V. Bhamidipati, and Q. Munawer, “The ARBAC97
model for role-based administration of roles,” ACM Transactions
on Information and System Security (TISSEC), vol. 2, pp. 105–
135, 1999.
[6] R. Sandhu and Q. Munawer, “The ARBAC99 model for adminis-
tration of roles,” in Proc. of the 15th Annual Computer Security
Applications Conference (ACSAC’99). IEEE, 1999, pp. 229–
238.
[7] S. Oh and R. Sandhu, “A model for role administration using
organization structure,” in Proc. of the seventh ACM symposium
on Access control models and technologies. ACM, 2002, pp.
155–162.
[8] N. Li and Z. Mao, “Administration in role-based access control,”
in Proc. of the 2nd ACM symposium on Information, computer
and communications security, 2007, pp. 127–138.
[9] P. Biswas, R. Sandhu, and R. Krishnan, “Uni-ARBAC: A unified
administrative model for role-based access control,” in Interna-
tional Conference on Information Security. Springer, 2016, pp.
218–230.
[10] D. R. Kuhn, E. J. Coyne, and T. R. Weil, “Adding attributes to
role-based access control,” Computer, vol. 43, pp. 79–81, 2010.
[11] V. C. Hu, D. Ferraiolo, R. Kuhn, A. Schnitzer, K. Sandlin,
R. Miller, K. Scarfone et al., “Guide to attribute based access
control (ABAC) definition and considerations,” NIST special
publication, vol. 800, no. 162, 2014.
[12] X. Jin, R. Krishnan, and R. Sandhu, “A unified attribute-based
access control model covering DAC, MAC and RBAC,” in
IFIP Annual Conference on Data and Applications Security and
Privacy. Springer, 2012, pp. 41–55.
[13] S. Bhatt, F. Patwa, and R. Sandhu, “ABAC with group attributes
and attribute hierarchies utilizing the policy machine,” in Proc.
of the 2nd ACM Workshop on Attribute-Based Access Control.
ACM, 2017, pp. 17–28.
[14] P. Biswas, R. Sandhu, and R. Krishnan, “Attribute transformation
for attribute-based access control,” in Proc. of the 2nd ACM
Workshop on Attribute-Based Access Control. ACM, 2017, pp.
1–8.
[15] J. Ninglekhu and R. Krishnan, “Attribute based administration of
role based access control: A detail description,” arXiv preprint
arXiv:1706.03171, 2017.
[16] J. Crampton, “Administrative scope and role hierarchy opera-
tions,” in Proceedings of the seventh ACM symposium on Access
control models and technologies. ACM, 2002, pp. 145–154.
[17] X. Jin, R. Sandhu, and R. Krishnan, “RABAC: role-centric
attribute-based access control,” in International Conference on
Mathematical Methods, Models, and Architectures for Computer
Network Security. Springer, 2012, pp. 84–96.
[18] Q. M. Rajpoot, C. D. Jensen, and R. Krishnan, “Attributes
enhanced role-based access control model,” in International
Conference on Trust and Privacy in Digital Business. Springer,
2015, pp. 3–17.
[19] E. Yuan and J. Tong, “Attributed based access control (ABAC)
for web services,” in Proc. of the IEEE International Conference
on Web Services (ICWS’05). IEEE, 2005.
[20] D. Servos and S. L. Osborn, “HGABAC: Towards a formal model
of hierarchical attribute-based access control,” in International
Symposium on Foundations and Practice of Security (FPS 2014).
Springer, 2014, pp. 187–204.
10

