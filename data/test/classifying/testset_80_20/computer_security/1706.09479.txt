Practical Differential Privacy for SQL Queries
Using Elastic Sensitivity
Noah Johnson
University of California,
Berkeley
noahj@berkeley.edu
Joseph P. Near
University of California,
Berkeley
jnear@berkeley.edu
Dawn Song
University of California,
Berkeley
dawnsong@cs.berkeley.edu
ABSTRACT
Differential privacy promises to enable general data analytics while
protecting individual privacy, but existing differential privacy mech-
anisms do not support the wide variety of features and databases
used in real-world SQL-based analytics systems.
This paper presents the first practical approach for differential
privacy of SQL queries. Using 8.1 million real-world queries, we
conduct an empirical study to determine the requirements for prac-
tical differential privacy, and discuss limitations of previous ap-
proaches in light of these requirements. To meet these requirements
we propose elastic sensitivity, a novel method for approximating
the local sensitivity of queries with general equijoins. We prove
that elastic sensitivity is an upper bound on local sensitivity and
can therefore be used to enforce differential privacy using any local
sensitivity-based mechanism.
We build FLEX, a practical end-to-end system to enforce differ-
ential privacy for SQL queries using elastic sensitivity. We demon-
strate that FLEX is compatible with any existing database, can en-
force differential privacy for real-world SQL queries, and incurs
negligible (0.03%) performance overhead.
1. INTRODUCTION
As organizations increasingly collect sensitive information about
individuals, these organizations are ethically and legally obligated
to safeguard against privacy leaks. Data analysts within these orga-
nizations, however, have come to depend on unrestricted access to
data for maximum productivity. This access is frequently provided
in the form of a relational database that supports SQL queries. Cur-
rent approaches for data security and privacy cannot guarantee pri-
vacy for individuals while providing general-purpose access for the
analyst.
As demonstrated by recent insider attacks [4, 5, 7, 8], allowing
members of an organization unrestricted access to data is a major
cause of privacy breaches. Access control policies can limit ac-
cess to a particular database, but once an analyst has access, these
policies cannot control how the data is used. Data anonymization
attempts to provide privacy while allowing general-purpose anal-
ysis, but cannot be relied upon, as demonstrated by a number of
re-identification attacks [13, 30, 32, 37].
Differential privacy [14, 17, 18] is a promising technique for ad-
dressing these issues. Differential privacy allows general statisti-
cal analysis of data while protecting data about individuals with a
strong formal guarantee of privacy.
Because of its desirable formal guarantees, differential privacy
has received growing attention from organizations including Google
and Apple. However, research on practical techniques for differen-
tial privacy has focused on special-purpose use cases, such as col-
lecting statistics about web browsing behaviors [19] and keyboard
and emoji use [1], while differential privacy for general-purpose
data analytics remains an open challenge.
Various mechanisms [10, 27–29, 31, 33] provide differential pri-
vacy for some subsets of SQL-like queries, but none support the
majority of queries in practice. These mechanisms also require
modifications to the database engine, complicating adoption in prac-
tice.
Furthermore, although the theoretical aspects of differential pri-
vacy have been studied extensively, little is known about the quan-
titative impact of differential privacy on real-world queries. Recent
work has evaluated differential privacy mechanisms on real-world
data [11,23,24], however this work uses a limited set of queries rep-
resenting a single, special-purpose analytics task such as histogram
analysis [11] or range queries [23]. To the best of our knowledge,
no existing work has explored the design and evaluation of differ-
ential privacy techniques for general, real-world queries.
This paper proposes the first practical approach for differential
privacy of general-purpose SQL queries. In contrast to existing
work, our approach provides practical security and privacy protec-
tions for real database systems without requiring major changes in
the way data analytics are accomplished. We develop and evaluate
our approach using a dataset of more than 8.1 million real-world
queries.
Contributions. We make four primary contributions toward prac-
tical differential privacy:
1. We conduct the largest known empirical study of real-world
SQL queries—8.1 million queries in total. From these results
we show that the queries used in prior work to evaluate differ-
ential privacy mechanisms are not representative of real-world
queries. We propose a new set of requirements for practical dif-
ferential privacy on SQL queries based on these results.
2. To meet these requirements, we propose elastic sensitivity, a
sound approximation of local sensitivity [16, 31] that supports
general equijoins and can be calculated efficiently using only
the query itself and a set of precomputed database metrics. We
prove that elastic sensitivity is an upper bound on local sensi-
tivity and can therefore be used to enforce differential privacy
using any local sensitivity-based mechanism.
1
ar
X
iv
:1
70
6.
09
47
9v
1 
 [
cs
.C
R
] 
 2
8 
Ju
n 
20
17
3. We design and implement FLEX, an end-to-end differential pri-
vacy system for SQL queries based on elastic sensitivity. We
demonstrate that FLEX is compatible with any existing data-
base, can enforce differential privacy for the majority of real-
world SQL queries, and incurs negligible (0.03%) performance
overhead.
4. In the first experimental evaluation of its kind, we use FLEX to
evaluate the impact of differential privacy on 9862 real-world
statistical queries in our dataset. In contrast to previous em-
pirical evaluations of differential privacy, our experimental set
contains a diverse variety of real-world queries executed on real
data. We show that FLEX introduces low error for a majority of
these queries.
The rest of the paper is organized as follows. Section 2 contains
our empirical study and defines the requirements for a practical dif-
ferential privacy mechanism. In Section 3, we define elastic sensi-
tivity and prove that it is an upper bound on local sensitivity. In
Section 4 we describe FLEX, our system for enforcing differential
privacy using elastic sensitivity. Section 5 contains our experimen-
tal evaluation of FLEX and Section 6 surveys related work.
2. A LARGE-SCALE EMPIRICAL STUDY
OF SQL USAGE
We use a dataset consisting of millions of SQL queries to es-
tablish requirements for a practical differential privacy system that
supports the majority of real-world queries. We investigate the
limitations of existing general-purpose differential mechanisms in
light of these requirements, and introduce elastic sensitivity, our
new approach that meets these requirements.
We investigate the following properties of queries in our dataset:
• How many different database backends are used? A practi-
cal differential privacy system must integrate with existing da-
tabase infrastructure.
• Which relational operators are used most frequently? A
practical differential privacy system must at a minimum support
the most common relational operators.
• What types of joins are used most frequently and many are
used by a typical query? Making joins differentially private is
challenging because the output of a join may contain duplicates
of sensitive rows. This duplication is difficult to bound as it de-
pends on the join type, join condition, and the underlying data.
Understanding the different types of joins and their relative fre-
quencies is therefore critical for supporting differential privacy
on these queries.
• What fraction of queries use aggregations and which ag-
gregation functions are used most frequently? Aggregation
functions in SQL return statistics about populations in the data.
Aggregation and non-aggregation queries represent fundamen-
tally different privacy problems, as will be shown. A practical
system must at minimum support the most common aggrega-
tions.
• How complex are typical queries and how large are typical
query results? To be practical, a differential privacy mecha-
nism must support real-world queries without imposing restric-
tions on query syntax, and it must scale to typical result sizes.
Dataset. We use a dataset of SQL queries written by employees at
Uber. The dataset contains 8.1 million queries executed between
March 2013 and August 2016 on a broad range of sensitive data
including rider and driver information, trip logs, and customer sup-
port data.
Data analysts at Uber query this information in support of many
business interests such as improving service, detecting fraud, and
understanding trends in the business. The majority of these use-
cases require flexible, general-purpose analytics. Given the size
and diversity of our dataset, we believe it is representative of SQL
queries in other real-world situations.
2.1 Study Results
We first summarize the study results, then define requirements
of a practical differential privacy technique for real-world queries
based on these results.
Question 1: How many different database backends are used?
# 
qu
er
ie
s
1
1000
1000000
Vertica Postgres MySQL Hive Presto Other
29,38739,52181,66094,206
1,494,680
6,362,631
Results. The queries in our dataset use more than 6 database back-
ends, including Vertica, Postgres, MySQL, Hive, and Presto.
Question 2: Which relational operators are used most frequently?
Operator Frequency
Select 100%
Join 62.1%
Union 0.57%
Minus/Except 0.06%
Intersect 0.03%
Results. All queries in our dataset
use the Select operator, more than
half of the queries use the Join
operator, and fewer than 1 percent
use other operators such as Union,
Minus, and Intersect.
Question 3: How many joins are used by a typical query?
Jo
in
s 
in
 q
ue
ry
95
53
33
16
0
# queries
1 1000 1000000
100
0
50
75
25
Results. A significant number of queries use multiple joins, with
queries using as many as 95 joins.
Question 4: What types of joins are used most frequently?
Left join 
29%
Cross join 
1% Inner join 69%
Other 
1%
Equijoin 
76%
Literal Comparison 
2%
Compound Expr. 
19%
Col. Comparison 
3%
Non self-join 
72%
Self-join 
28%
Many-to-many 
10%
One-to-one 
26% One-to-many 
64%
Join condition Join relationship Self join Join type
 1
Join condition. The vast majority (76%) of joins are equijoins:
joins that are conditioned on value equality of one column from
both relations. A separate experiment (not shown) reveals that
65.9% of all join queries use exclusively equijoins.
Compound expressions, defined as join conditions using func-
tion applications and conjunctions and disjunctions of primitive op-
erators, account for 19% of join conditions. Column comparisons,
defined as conditions that compare two columns using non-equality
operators such as greater than, comprise 3% of join conditions.
2
Literal comparisons, defined as join conditions comparing a single
column to a string or integer literal, comprise 2% of join conditions.
Join relationship. A majority of joins (64%) are conditioned on
one-to-many relationships, over one-quarter of joins (26%) are con-
ditioned on one-to-one relationships, and 10% of joins are condi-
tioned on many-to-many relationships.
Self join. 28% of queries include at least one self join, defined
as a join in which the same database table appears in both joined
relations. The remaining queries (72%) contain no self joins.
Join type. Inner join is the most common join type (69%), followed
by left join (29%) and cross join (1%). The remaining types (right
join and full join) together account for less than 1%.
Question 5: What fraction of queries use aggregations?
Statistical 34%
Raw data 66%
Raw data 
66%
Statistical 
34%
Statistical Raw data
 1
Results. Approximately one-third of
queries are statistical, meaning they re-
turn only aggregations (count, average,
etc.). The remaining queries return non-
aggregated results (i.e., raw data) in at
least one output column.
Question 6: Which aggregation functions are used most fre-
quently?
Sum 29
Avg 8.4
Max 5.9
Min 4.9
Median 0.3
Stddev 0.1
Count 51
0
15
30
45
60
Sum Avg Max Min Median Stddev Count
Count 
51%
Min 
5%
Max 
6%
Avg 
8%
Sum 
29%
Sum Avg Max Min Median Stddev Count
Median 0.3%Stddev. 0.1%
 1
Results. Count is the most common ag-
gregation function (51%), followed by
Sum (29%), Avg (8%), Max (6%) and
Min (5%). The remaining functions ac-
count for fewer than 1% of all aggrega-
tion functions.
Question 7: How complex are typical queries?
Q
ue
ry
 s
iz
e 
5000
1000
350
150
70
30
4
# queries
0 175000 350000 525000 700000
Results. The majority of queries are fewer than 100 clauses but a
significant number of queries are much larger, with some queries
containing as many as thousands of clauses.
Question 8: How large are typical query results?
Result size (rows)
O
ut
pu
t r
ow
s
10000000
10000
500
200
60
5
# queries
0 250,000 500,000 750,000 1,000,000
Result size (columns)
O
ut
pu
t c
ol
um
ns
500
300
100
60
20
3
# queries
1 1,000 1,000,000
Results. The output sizes of queries varies dramatically with re-
spect to both rows and columns, and queries commonly return hun-
dreds of columns and hundreds of thousands of rows.
2.2 Requirements for Practical Differential
Privacy
Our study reveals that real-world queries are executed on many
different database engines—in our dataset there are over 6. We
believe this is typical; a variety of databases are commonly used
within a company to match specific performance and scalability
requirements. A practical mechanism for differential privacy will
therefore allow the use of any of these existing databases, requir-
ing neither a specific database distribution nor a custom execution
engine in lieu of a standard database.
The study shows that 62.1% of all queries use SQL Join, and
specifically equijoins which are by far the most common. Addi-
tionally, a majority of queries use multiple joins, more than one-
quarter use self joins, and joins are conditioned on one-to-one, one-
to-many, and many-to-many relationships. These results suggest
that a practical differential privacy approach must at a minimum
provide robust support for equijoins, including the full spectrum of
join relationships and an arbitrary number of nested joins.
One-third (34%) of all queries return aggregate statistics. Differ-
ential privacy is principally designed for such queries, and in the
remainder of this paper we focus on these queries. Enforcing dif-
ferential privacy for raw data queries is beyond the scope of this
work, as differential privacy is generally not intended to address
this problem.
For statistical queries, Count is by far the most common aggre-
gation. This validates the focus on counting and histogram queries
by the majority of previous general-purpose differential privacy
mechanisms [10, 27, 29, 33]. Our work similarly focuses on this
class of queries. In Section 3.6.2 we discuss possible extensions to
support other aggregation functions.
We summarize our requirements for practical differential privacy
of real-world SQL queries:
• Requirement 1: Compatibility with existing databases. A
practical differential privacy approach must support heteroge-
neous database environments by not requiring a specific data-
base distribution or replacement of the database with a custom
runtime.
• Requirement 2: Robust support for equijoin. A practical dif-
ferential privacy approach must provide robust support for equi-
join, including both self joins and non-self joins, all join rela-
tionship types, and queries with an arbitrary number of nested
joins.
Our study shows that a differential privacy system satisfying
these requirements is likely to have broad impact, supporting a ma-
jority of real-world statistical queries.
2.3 Existing Differential Privacy Mechanisms
Several existing general-purpose differential privacy mechanisms
support queries with join. Table 1 summarizes these mechanisms
and their supported features in comparison to our proposed mech-
anism (last row). In Section 6 we discuss additional mechanisms
which are not considered here either because they are not general-
purpose or they cannot support joins.
PINQ. Privacy Integrated Queries (PINQ) [27] is a mechanism that
provides differential privacy for counting queries written in an aug-
mented SQL dialect. PINQ supports a restricted join operator that
groups together results with the same key. For one-to-one joins,
3
Requirement 1
︷︸︸︷
Requirement 2
︷ ︸︸ ︷
Database One-to-one One-to-many Many-to-many
compatibility equijoin equijoin equijoin
PINQ [27] X
wPINQ [33] X X X
Restricted sensitivity [10] X X
DJoin [29] X
Elastic sensitivity (this work) X X X X
Table 1: Comparison of general-purpose differential privacy mechanisms with support for join.
this operator is equivalent to the standard semantics. For one-to-
many and many-to-many joins, on the other hand, a PINQ query
can count the number of unique join keys but not the number of
joined results. Additionally, PINQ introduces new operators that
do not exist in standard SQL, so the approach is not compatible
with standard databases.
wPINQ. Weighted PINQ (wPINQ) [33] extends PINQ with sup-
port for general equijoins and works by assigning a weight to each
row in the database, then scaling down the weights of rows in a
join to ensure an overall sensitivity of 1. In wPINQ, the result of
a counting query is the sum of weights for records being counted
plus noise drawn from the Laplace distribution. This approach al-
lows wPINQ to support all three types of joins, but the utility of this
approach for general queries is unknown due to evaluation only on
graph triangle counting queries. wPINQ additionally does not sat-
isfy our database compatibility requirement. The system described
by Proserpio et al. [33] uses a custom runtime; applying wPINQ
in an existing database would require modifying the database to
propagate weights during execution.
Restricted sensitivity. Restricted sensitivity [10] is designed to
bound the global sensitivity of counting queries with joins, by us-
ing properties of an auxiliary data model. The approach requires
bounding the frequency of each join key globally (i.e. for all pos-
sible future databases). This works well for one-to-one and one-
to-many joins, because the unique key on the “one” side of the
join has a global bound. However, it cannot handle many-to-many
joins, because the frequency of keys on both sides of the join may
be unbounded. Blocki et al. [10] formalize the restricted sensitivity
approach but do not describe how it could be used in a system com-
patible with existing databases, and no implementation is available.
DJoin. DJoin [29] is a mechanism designed for differentially pri-
vate queries over datasets distributed over multiple parties. Due to
the additional restrictions associated with this setting, DJoin sup-
ports only one-to-one joins, because it rewrites join queries as rela-
tional intersections. For example, consider the following query:
SELECT COUNT (∗) FROM X JOIN Y ON X.A = Y.B
DJoin rewrites this query to the following (in relational algebra),
which is semantically equivalent to the original query only if the
join is one-to-one.:
|πA(X) ∩ πB(Y )|
Additionally, the approach requires the use of special cryptographic
functions during query execution, so it is not compatible with ex-
isting databases.
To address the limitations of existing mechanisms we propose
elastic sensitivity, discussed next. Elastic sensitivity is compatible
with any existing database and supports general equijoins with the
full spectrum of join relationships. This combination allows use of
elastic sensitivity in real-world settings.
3. Elastic Sensitivity
Elastic sensitivity is a novel approach for calculating an upper
bound on a query’s local sensitivity. After motivating the approach,
we provide background on necessary concepts in Section 3.2, for-
mally define elastic sensitivity in Section 3.3, prove its correctness
in Section 3.4, and discuss two optimizations in Section 3.5.
3.1 Motivation
Many previous differential privacy mechanisms [10,27] are based
on global sensitivity. These approaches do not generalize to queries
with joins; the global sensitivity of queries with general joins may
be unbounded because “a join has the ability to multiply input
records, so that a single input record can influence an arbitrarily
large number of output records.” [27]
Techniques based on local sensitivity [16, 31] generally provide
greater utility than global sensitivity-based approaches because they
consider the actual database. Indeed, local sensitivity is finite for
general queries with joins. However, directly computing local sen-
sitivity is computationally infeasible, as it requires running the query
on every possible neighbor of the true database—in our environ-
ment this would require running more than 1 billion queries for
each original query. Previous work [31] describes efficient meth-
ods to calculate local sensitivity for a limited set of fixed queries
(e.g., the median of all values in the database) but these techniques
do not apply to general-purpose queries or queries with join.
These challenges are reflected in the design of previous mech-
anisms listed in Table 1. PINQ and restricted sensitivity support
only joins for which global sensitivity can be bounded, and wPINQ
scales weights attached to the data during joins to ensure a global
sensitivity of 1. DJoin uses a measure of sensitivity unique to its
distributed setting. None of these techniques are based on local
sensitivity.
Elastic sensitivity is the first tractable approach to leverage local
sensitivity for queries with general equijoins. The key insight of
our approach is to model the impact of each join in the query using
precomputed metrics about the frequency of join keys in the true
database. This novel approach allows elastic sensitivity to compute
a conservative approximation of local sensitivity without requiring
any additional interactions with the database. In Section 3.4, we
prove elastic sensitivity is an upper bound on local sensitivity and
can therefore be used with any local sensitivity-based differential
privacy mechanism. In Section 4, we describe how to use elastic
sensitivity to enforce differential privacy.
3.2 Background
We briefly summarize existing differential privacy concepts nec-
essary for describing our approach. For a more thorough overview
of differential privacy, we refer the reader to Dwork and Roth’s ex-
cellent reference [18].
Differential privacy provides a formal guarantee of indistinguisha-
bility: a differentially private result does not yield very much infor-
4
mation about which of two neighboring databases was used in cal-
culating the result. The formal definition of differential privacy is
written in terms of the distance d(x, y) between two databases (the
number of entries on which they differ: d(x, y) = |{i : xi 6= yi}|).
Definition 1 (Differential privacy). A randomized mechanism K :
Dn → Rd preserves (, δ)-differential privacy if for any pair of
databases x, y ∈ Dn such that d(x, y) = 1, and for all sets S of
possible outputs:
Pr[K(x) ∈ S] ≤ ePr[K(y) ∈ S] + δ
One measure of sensitivity is global sensitivity, which is the
maximum difference between the query’s result on any two pos-
sible databases with distance 1:
Definition 2 (Global Sensitivity). For f : Dn → Rd and all x, y ∈
Dn, the global sensitivity of f is
GSf = max
x,y:d(x,y)=1
||f(x)− f(y)||
Another definition of sensitivity is local sensitivity [16,31], which
is the maximum difference between the query’s results on the true
database and any neighbor of it:
Definition 3 (Local Sensitivity). For f : Dn → Rd and x ∈ Dn,
the local sensitivity of f at x is
LSf (x) = max
y:d(x,y)=1
||f(x)− f(y)||
Local sensitivity is often much lower than global sensitivity since
it is a property of the single true database rather than the set of all
possible databases.
Smoothing functions. Because local sensitivity is based on the
true database, it must be used carefully to avoid leaking informa-
tion about the data. Prior work [16, 31] describes techniques for
using local sensitivity to enforce differential privacy. Henceforth
we use the term smoothing functions to refer to these techniques.
Smoothing functions are independent of the method used to com-
pute local sensitivity, but generally require that local sensitivity can
be computed an arbitrary distance k from the true database (i.e.
when at most k entries are changed):
Definition 4 (Local Sensitivity at Distance). The local sensitivity
of f at distance k is:
A
(k)
f (x) = max
y∈Dn:d(x,y)≤k
LSf (y)
3.3 Definition of Elastic Sensitivity
We define the elastic sensitivity of a query recursively on the
query’s structure. To allow the use of smoothing functions, our
definition describes how to calculate elastic sensitivity at arbitrary
distance k from the true database (under this definition, the local
sensitivity of the query is defined at k = 0).
Figure 1 contains the complete definition, which is in four parts:
(a) Core relational algebra, (b) Definition of Elastic sensitivity, (c)
Max frequency at distance k, and (d) Ancestors of a relation. We
describe each part next.
Core relational algebra. We present the formal definition of elas-
tic sensitivity in terms of a subset of the standard relational algebra,
defined in Figure 1(a). This subset includes selection (σ), projec-
tion (π), join (./), counting (Count), and counting with grouping
(CountG1..Gn ). It admits arbitrary equijoins, including self joins,
and all join relationships (one-to-one, one-to-many, and many-to-
many).
Our notation admits subqueries with aggregation. For example,
the query “how many cities have had more than 10 trips” can be
written:
Count(σcount>10(Count(trips)))
To simplify the presentation our notation assumes the query per-
forms a count as the outermost operation, however the approach
naturally extends to aggregations nested anywhere in the query
as long as the query does not perform arithmetic or other modi-
fications to aggregation result. For example, the following query
counts the total number of trips and projects the “count” attribute:
πcountCount(trips)
Our approach can support this query by treating the inner relation
as the query root.
Elastic sensitivity. Figure 1(b) contains the recursive definition of
elastic sensitivity at distance k. We denote the elastic sensitivity of
query q at distance k from the true database x as Ŝ(k)(q, x). The
Ŝ function is defined in terms of the elastic stability of relational
transformations (denoted ŜR).
Ŝ
(k)
R (r, x) bounds the local stability of relation r at distance k
from the true database x. Stability is defined [27] as the maximum
change in the cardinality of a relation achievable by changing one
row in the database. Ŝ(k)R (r, x) is defined in terms of mfk(a, r, x),
the maximum frequency of attribute a in relation r at distance k
from database x.
Max frequency at distance k. The maximum frequency metric
is used to bound the sensitivity of joins. We define the maximum
frequency mf(a, r, x) as the frequency of the most frequent value of
attribute a in relation r in the database instance x. In Section 4 we
describe how the values of mf can be obtained from the database.
To bound the local sensitivity of a query at distance k from the
true database, we must also bound the max frequency of each join
key at distance k from the true database. For attribute a of relation r
in the true database x, we denote this value mfk(a, r, x), and define
it (in terms of mf) in Figure 1(c).
Ancestors of a relation. The definition in Figure 1(d) is a for-
malization to identify self joins. Self joins have a much greater
effect on sensitivity than joins of non-overlapping relations. In a
self join, changing one row of the underlying database may cause
changes in both joined relations, rather than just one or the other.
The join case of elastic sensitivity is therefore defined in two cases:
one for self joins, and one for joins of non-overlapping relations.
To distinguish the two cases, we useA(r) (defined in Figure 1(d)),
which denotes the set of tables possibly contributing rows to r. A
join of two relations r1 and r2 is a self join when r1 and r2 over-
lap, which occurs when some table t in the underlying database
contributes rows to both r1 and r2. r1 and r2 are non-overlapping
when |A(r1) ∩ A(r2)| = 0.
Unsupported queries. We discuss several cases of queries that are
not supported by our definition in Section 3.6.1.
3.4 Elastic Sensitivity is an Upper Bound on
Local Sensitivity
In this section, we prove that elastic sensitivity is an upper bound
on the local sensitivity of a query. This fundamental result affirms
the soundness of using elastic sensitivity in any local sensitivity-
based differential privacy mechanism. First, we prove two impor-
tant lemmas: one showing the correctness of the max frequency at
distance k, and the other showing the correctness of elastic stability
ŜR.
Lemma 1. For database x, at distance k, r has at most mfk(a, r, x)
occurrences of the most popular join key in attribute a:
5
Core relational algebra:
Attribute names
a
Value constants
v
Relational transformations
R ::= t | R1 ./
x=y
R2
| Πa1,...,anR | σϕR
| Count(R)
| CountG1..Gn (R)
Selection predicates
ϕ ::= a1θa2 | aθv
θ ::= < | ≤ | =
| 6= | ≥ | >
Counting queries
Q ::= Count(R)
| Count
G1..Gn
(R)
Definition of elastic sensitivity:
Ŝ
(k)
R :: R→ Dn→ elastic stability
Ŝ
(k)
R (t, x) = 1
Ŝ
(k)
R (r1 ./a=b
r2, x) =



max(mfk(a, r1, x)Ŝ
(k)
R (r2, x),
mfk(b, r2, x)Ŝ
(k)
R (r1, x)) |A(r1) ∩ A(r2)| = 0
mfk(a, r1, x)Ŝ
(k)
R (r2, x)+
mfk(b, r2, x)Ŝ
(k)
R (r1, x)+
Ŝ
(k)
R (r1, x)Ŝ
(k)
R (r2, x) |A(r1) ∩ A(r2)| > 0
Ŝ
(k)
R (Πa1,...,anr, x) = Ŝ
(k)
R (r, x)
Ŝ
(k)
R (σϕr, x) = Ŝ
(k)
R (r, x)
Ŝ
(k)
R (Count(r)) = 1
Ŝ
(k)
R (CountG1..Gn (r)) = 2Ŝ
(k)
R (r, x)
Ŝ(k) :: Q→ Dn→ elastic sensitivity
Ŝ(k)(Count(r), x) = Ŝ(k)R (r, x)
Ŝ(k)( Count
G1..Gn
(r), x) = Ŝ
(k)
R (r, x)
Maximum frequency at distance k:
mfk :: a→ R→ Dn→ N
mfk(a, t, x) = mf(a, t, x) + k
mfk(a, r1 ./
a=b
r2) = mfk(a, r1, x)mfk(b, r2, x)
mfk(b, r1 ./
a=b
r2) = mfk(a, r1 ./
a=b
r2)
mfk(a,Πa1,...,anr, x) = mfk(a, r, x)
mfk(a, σϕr, x) = mfk(a, r, x)
(c)
Ancestors of a relation:
A :: R→ {R}
A(t) = {t}
A(r1 ./
a=b
r2) = A(r1) ∪ A(r2)
A(Πa1,...,anr) = A(r)
A(σϕr) = A(r)
(a) (b) (d)
Figure 1: (a) syntax of core relational algebra; (b) definition of elastic sensitivity at distance k; (c) definition of maximum frequency
at distance k; (d) definition of ancestors of a relation.
mfk(a, r, x) ≥ max
y:d(x,y)≤k
mf(a, r, y)
Proof. By induction on the structure of r.
Case t. To obtain the largest possible number of occurrences of the
most popular join key in a table t by changing k rows, we change
k rows with a different join key to contain the most popular one.
Thus, maxy:d(x,y)≤k mf(a, r, y) = mf(a, r, x) + k.
Case r1 ./
a=b
r2. We need to show that:
mfk(a, r1 ./
a=b
r2, x) ≥ max
y:d(x,y)≤k
mf(a, r1 ./
a=b
r2, y) (1)
In the worst case, each row from r1 matches each row from r2 (i.e.
a cartesian product). So we can rewrite equation 1:
mfk(a, r1 ./
a=b
r2, x) ≥ max
y:d(x,y)≤k
mf(a, r1, y)mf(b, r2, y) (2)
Then, we rewrite the left-hand size to be equal to the right, based
on the definition of mfk and the inductive hypothesis. Each step
may make the left-hand side smaller, but never larger, preserving
the original inequality:
mfk(a, r1 ./
a=b
r2, x)
= mfk(a, r1, x)mfk(b, r2, x)
≥ max
y:d(x,y)≤k
mf(a, r1, y) max
y:d(x,y)≤k
mf(b, r2, y)
≥ max
y:d(x,y)≤k
mf(a, r1, y)mf(b, r2, y)
Which is equal to the right-hand side of equation 2.
Case Πa1,...,anr. Projection does not change the number of rows,
so the conclusion follows directly from the inductive hypothesis.
Case σϕr. Selection might filter out some rows, but does not mod-
ify attribute values. In the worst case, no rows are filtered out, so
σϕr has the same number of occurrences of the most popular join
key as r. The conclusion thus follows directly from the inductive
hypothesis.
Lemma 2. Ŝ(k)R (r) is an upper bound on the local stability of re-
lation expression r at distance k from database x:
A
(k)
count(r)(x) ≤ Ŝ
(k)
R (r, x)
Proof. By induction on the structure of r.
Case t. The stability of a table is 1, no matter its contents.
Case r1 ./
a=b
r2. We want to bound the number of changed rows in
the joined relation. There are two cases, depending on whether or
not the join is a self join.
Subcase 1: no self join. When the ancestors of r1 and r2 are non-
overlapping (i.e. |A(r1) ∩ A(r2)| = 0), then the join is not a self
join. This means that either r1 may change or r2 may change, but
not both. As a result, either Ŝ(k)R (r1, x) = 0 or Ŝ
(k)
R (r2, x) = 0.
We therefore have two cases:
1. When Ŝ(k)R (r1, x) = 0, r2 may contain at most Ŝ
(k)
R (r2, x)
changed rows, producing at most mfk(a, r1, x)Ŝ
(k)
R (r2, x) changed
rows in the joined relation.
2. In the symmetric case, when Ŝ(k)R (r2, x) = 0, the joined rela-
tion contains at most mfk(b, r2, x)Ŝ
(k)
R (r1, x) changed rows.
We choose to modify the relation resulting in the largest number of
changed rows, which is exactly the definition.
Subcase 2: self join. When the set of ancestor tables of r1 overlaps
with the set of ancestor tables of r2, i.e. |A(r1)∩A(r2)| > 0, then
changing a single row in the database could result in changed rows
in both r1 and r2.
In the self join case, there are three sources of changed rows:
1. The join key of an original row from r1 could match the join
key of a changed row in r2.
2. The join key of an original row from r2 could match the join
key of a changed row in r1.
3. The join key of a changed row from r1 could match the join key
of a changed row in r2.
Now consider how many changed rows could exist in each class.
1. In class 1, r2 could have at most Ŝ
(k)
R (r2, x) changed rows
(by the inductive hypothesis). In the worst case, each of these
changed rows matches the most popular join key in r1, which
occurs at most mfk(a, r1, x) times (by Lemma 1), so class 1
contains at most mfk(a, r1, x)Ŝ
(k)
R (r2, x) changed rows.
6
2. Class 2 is the symmetric case of class 1, and thus contains at
most mfk(b, r2, x)Ŝ
(k)
R (r1, x) changed rows.
3. In class 3, we know that r1 contains at most Ŝ
(k)
R (r1, x) changed
rows and r2 contains at most Ŝ
(k)
R (r2, x) changed rows. In
the worst case, all of these changed rows contain the same join
key, and so the joined relation contains Ŝ(k)R (r1, x)Ŝ
(k)
R (r2, x)
changed rows.
The total number of changed rows is therefore bounded by the sum
of the bounds on the three classes:
mfk(a, r1, x)Ŝ
(k)
R (r2, x)+mfk(b, r2, x)Ŝ
(k)
R (r1, x)+
Ŝ
(k)
R (r1, x)Ŝ
(k)
R (r2, x)
Which is exactly the definition.
Case Πa1,...,anr. Projection does not change rows. The conclusion
therefore follows from the inductive hypothesis.
Case σϕr. Selection does not change rows. The conclusion there-
fore follows from the inductive hypothesis.
Case Count(r). Count without grouping produces a relation with
a single row. The stability of such a relation is 1, at any distance.
Case CountG1..Gn(r). The relational Count with grouping pro-
duces a relation representing a histogram, with one count per group.
Changing one row in the underlying relation r can move one ele-
ment from a group g to another g′ in the histogram, for a total
change of 2 changed rows.
Since each changed row in r can change the count in two groups,
by the inductive hypothesis, the total number of changed rows is
bounded by:
2Ŝ
(k)
R (r, x)
Which is exactly the definition.
In order to prove the connection between A(k)f (x) (local sensi-
tivity) and Ŝ(k)(q, x) (elastic sensitivity), we must connect f and
q. Local sensitivity is defined for functions f : Dn → R mapping
databases directly to query results. Local sensitivity is not defined
for relational queries.
We define the local sensitivity of a query by executing it using a
database engineM : Q → Dn → R. To extend the notation to
histogram queries, we can defineM so that the analyst provides a
set of desired histogram bin labels ` (without loss of generality—`
can be empty for non-histogram queries). It is important that M
be defined for all values of `, returning 0 for histogram bins that do
not exist, or else the analyst can use the presence or absence of a
histogram bin to violate differential privacy. Then, we can useM
to define the local sensitivity of a query:
Definition 5. The local sensitivity of a query q is:
A(k)q (x) = A
(k)
M(q,`)(x)
Now, we are prepared to prove the main theorem.
Theorem 1. The elastic sensitivity of a query q at distance k from
the true database x is an upper bound on its local sensitivity:
A(k)q (x) ≤ Ŝ(k)(q, x)
Proof. There are two cases: histogram queries and non-histogram
queries.
Case Count(r) (non-histogram). The local sensitivity of a non-
histogram counting query over r is equal to the stability of r, so the
result follows directly from Lemma 2.
Case Count
G1..Gn
(r) (histogram). For a histogram query, the analyst
provides a set ` of histogram bin labels, which partitions the rows
of r into disjoint sets (the groups). By McSherry [27] Theorem 4,
the sensitivity of such a histogram query is equal to the maximum
of the individual sensitivities for each group. In the worst case, all
of the rows in r end up in the same group, and the sensitivity of the
query is equal to the stability of r. Once again, the result follows
from Lemma 2.
3.5 Using Data Models for Tighter Bounds on
Local Sensitivity
Local sensitivity is defined over neighboring databases of the
true database. Our definition of elastic sensitivity considers all
neighboring databases to be valid. However, certain neighboring
databases are infeasible and therefore need not be considered: in
our dataset, for example, city data is publicly known and does not
change, and user IDs are never duplicated for multiple users. Both
kinds of information can be used to prune the set of neighboring
databases considered, and thereby tighten our bound on local sen-
sitivity, without compromising our privacy guarantees.
Public tables. For joins on public tables, our implementation of
elastic sensitivity considers only the effects on the private table
when calculating sensitivity. For example, because city data is pub-
licly available, joining trips with cities poses no additional privacy
threat compared to querying trips directly.
More precisely, in a join expression T1 JOIN T2 ON T1.A = T2.B, if
T2 is publicly known, the sensitivity of the join is the maximum fre-
quency of T2.B (the frequency of the join key in T1 is ignored). Note
this formulation correctly prevents the use of a publicly-known ta-
ble with repeated join keys from revealing information about a pri-
vate table.
Unique join keys in private tables. Many private tables have pri-
mary key columns that will never contain duplicates, making many
neighboring databases impossible. For example, in the users table,
each user corresponds to a unique ID. In the trips table, however, a
user ID may appear multiple times—once for each trip.
A naive (but correct) sensitivity bound for a relation joining these
two tables considers a neighboring database in which the users ta-
ble contains a duplicate user, resulting in duplication of each of
that user’s trips in the output of the join. Our data model opti-
mization recognizes that this neighboring database violates data in-
tegrity conditions and therefore cannot occur.
More precisely, in a join expression R1 JOIN R2 ON R1.A = R2.B, if
the data model asserts that R1.A is a unique key, then the sensitivity
of the join is equal to the sensitivity of R2.
The set of public tables is domain-specific and will vary in each
data environment. The unique key columns can be obtained directly
from the database schema.
3.6 Discussion of Limitations and Extensions
This section discusses limitations of elastic sensitivity and po-
tential extensions to support other common aggregation functions.
3.6.1 Unsupported Queries
Elastic sensitivity does not support non-equijoins, and adding
support for these is not straightforward. Consider the query:
SELECT count (∗) FROM A JOIN B ON A.x > B.y
This query compares join keys using the greater-than operator, and
bounding the number of matches for this comparison would require
knowledge about all the data for A.x and B.y.
Fortunately, as demonstrated in our empirical study, more than
three-quarters of joins are equijoins. Elastic sensitivity could be
extended to support other join types by querying the database for
7
necessary data-dependent bounds, but this modification would re-
quire interactions with the database for each original query.
Elastic sensitivity can also fail when requisite max-frequency
metrics are not available due to the query structure. Consider the
query:
WITH A AS ( SELECT count (∗) FROM T1),
B AS ( SELECT count (∗) FROM T2)
SELECT count (∗) FROM A JOIN B ON A. count = B. count
This query uses counts computed in subqueries as join keys. Be-
cause the mf metric covers only the attributes available in the orig-
inal tables of the database, our approach cannot bound the sensi-
tivity of this query and must reject it. In general, elastic sensitivity
applies only when join keys are drawn directly from original tables.
Fortunately, this criterion holds for 98.5% of joins in our dataset,
so this limitation has very little consequence in practice.
3.6.2 Supporting Other Aggregation Functions
In this section we outline possible extensions of our approach
to support non-count aggregation functions listed in Section 2.1
(Question 6), and characterize the expected utility for each. These
extensions, which provide a roadmap for potential future research,
would expand the set of queries supported by an elastic sensitivity-
based system.
Value range metric. To describe these extensions we define a new
metric, value range vr(a, r), defined as the maximum value mi-
nus the minimum value allowed by the data model of column a in
relation r.
This metric can be derived in a few ways. First, it can be ex-
tracted automatically from the database’s column constraint defini-
tions [2], if they exist. Second, a SQL query can extract the current
value range, which can provide a guideline for selecting the permis-
sible value range based on records already in the database; finally,
a domain expert can define the metric using knowledge about the
data’s semantics.
Once the metric is defined, it must be enforced in order for dif-
ferential privacy to be guaranteed. The metric could be enforced
as a data integrity check, for example using column check con-
straints [2].
Sum and Average. For sum and average, we note that the local
sensitivity of these functions is affected both by the stability of the
underlying relation, because each row of the relation potentially
contributes to the computed sum or average, and by the range of
possible values of the attributes involved.
Given our definition of vr above, the elastic sensitivity of both
Sum and Average on relation r at distance k from database x is
defined by vr(a, r)S(k)R (r, x). This expression captures the largest
possible change in local sensitivity, in which each changed row in
r is switched from the minimum value of a to its maximum value,
for a total change of vr(a, r) per row.
For Sum queries on relations with stability 1 (i.e. relations with-
out joins), this definition of elastic sensitivity is exactly equal to
the query’s local sensitivity, so the approach will provide optimal
utility. As the relation’s stability grows, so does the gap between
elastic sensitivity and local sensitivity, and utility degrades, since
elastic sensitivity makes the worst-case assumption that each row
duplicated by a join contains the maximum value allowed by the
data model.
For the average function, this definition is exactly equal to local
sensitivity only for the degenerate case of averages of a single row.
As more input rows are added, local sensitivity shrinks, since the
impact of a single row change is amortized over the number of aver-
aged records, while elastic sensitivity remains constant. Therefore
Original database
Database metrics
Differentially 
private 
results
Elastic Sensitivity
Analysis
SQL
query
Smooth 
Sensitivity
Laplace 
Noise
Query results (sensitive)
Privacy budget (ε, )
FLEX
Histogram bin 
enumeration
Figure 2: Architecture of FLEX
utility degradation is proportional to both the stability of the rela-
tion as well as the number of records being averaged.
This could be mitigated with a separate analysis to compute a
lower bound on the number of records being averaged, in which
case the sensitivity could be scaled down by this factor. Such an
analysis would require inspection of filter conditions in the query
and an expanded set of database metrics.
Max and min. We observe that the stability of the underlying re-
lation has no effect on the local sensitivity of max and min. Conse-
quently, for such queries the data model vr(a, r) directly provides
the global sensitivity, which is an upper bound of local sensitiv-
ity. However, the max and min functions are inherently sensitive,
because they are strongly affected by outliers in the database [16],
and therefore any differential privacy technique will provide poor
utility in the general case.
Due to this fundamental limitation, previous work [16, 31, 36]
has focused on the robust counterparts of these functions, such as
the interquartile range, which are less sensitive to changes in the
database. This strategy is not viable in our setting since functions
like interquartile range are not supported by standard SQL.
4. FLEX: PRACTICAL DIFFERENTIAL
PRIVACY FOR SQL QUERIES
This section describes FLEX, our system to enforce differential
privacy for SQL queries using elastic sensitivity. Figure 2 sum-
marizes the architecture of our system. For a given SQL query,
FLEX uses an analysis of the query to calculate its elastic sensitiv-
ity, as described in Section 3. FLEX then applies smooth sensitiv-
ity [31] to the elastic sensitivity and finally adds noise drawn from
the Laplace distribution to the original query results. In Section 4.1
we prove this approach provides (, δ)-differential privacy.
Importantly, our approach allows the query to execute on any ex-
isting database. FLEX requires only static analysis of the query and
post-processing of the query results, and requires no interactions
with the database to enforce differential privacy. As we demon-
strate in Section 5, this design allows the approach to scale to big
data while incurring minimal performance overhead.
Collecting max frequency metrics. The definition of elastic sen-
sitivity requires a set of precomputed metrics mf from the database,
defined as the frequency of the most frequent attribute for each join
key. The values of mf can be easily obtained with a SQL query. For
example, this query retrieves the metric for column a of table T :
SELECT COUNT (a) FROM T GROUP BY a
ORDER BY count DESC LIMIT 1;
Obtaining these metrics is a separate step from enforcing differ-
ential privacy for a query; the metrics can be obtained once and
re-used for all queries.
Note the metric must be recomputed when the most frequent join
attribute changes, otherwise differential privacy is no longer guar-
anteed. For this reason, the architecture in Figure 2 is ideal for
8
environments where database updates are far less frequent than da-
tabase queries. Most databases can be configured using triggers [3]
to automatically recompute the metrics (if necessary) on database
updates; this approach could support environments with frequent
data updates.
Elastic Sensitivity analysis. To compute elastic sensitivity we
built an analysis framework for SQL queries based on the Presto
parser [6], with additional logic to resolve aliases and a frame-
work to perform abstract interpretation-based dataflow analyses on
the query tree. FLEX’s elastic sensitivity analysis is built on this
dataflow analysis engine, and propagates information about ances-
tor relations and max-frequency metrics for each joined column in
order to compute the overall elastic sensitivity of the query, per the
recursive definition in Section 3. We evaluate the runtime and suc-
cess rate of this analysis in Section 5.
Privacy budget. The privacy budget is used to tune the strength
of the privacy guarantee—the smaller the budget, the stronger the
guarantee. Strategies for managing the budget are beyond the scope
of this work and have been treated extensively elsewhere [18]. Our
approach is independent of the method used to select  and δ.
Histogram bin enumeration. When a query uses SQL’s GROUP BY
construct, the output is a histogram containing a set of bin labels
and an aggregation result (e.g., count) for each bin. To simplify
presentation, our definition of elastic sensitivity in Section 3.3 as-
sumes that the analyst provides the desired histogram bins labels `.
This requirement, also adopted by previous work [27], is necessary
to prevent leaking information via the presence or absence of a bin.
In practice, however, analysts do not expect to provide histogram
bin labels manually.
In some cases, FLEX can automatically build the set of histogram
bin labels ` for a given query. In our dataset, many histogram
queries use non-protected bin labels drawn from finite domains
(e.g. city names or product types). For each possible value of the
histogram bin label (e.g. each city name in the set of cities), FLEX
can automatically build ` and obtain the corresponding differen-
tially private count for that histogram bin. Then, FLEX adds a row
to the output containing the bin label and its differentially private
count, where results for missing bins are assigned value 0 and noise
added as usual.
This process returns a histogram of the expected form which
does not reveal anything new through the presence or absence of
a bin. Additionally, since this process requires the bin labels to be
non-protected, the original bin labels can be returned. The process
can generalize to any aggregation function.
This process requires a finite, enumerable, and non-protected set
of values for each histogram bin label. When the requirement
cannot be met, for example because the histogram bin labels are
protected or cannot be enumerated, FLEX can still return the differ-
entially private count for each bin, but it must rely on the analyst to
specify the bin labels.
Implementation. FLEX is implemented in 6038 lines of Java code,
with 5114 LoC for the analysis framework, 403 LoC for the elas-
tic sensitivity analysis, and 86 LoC for the smooth sensitivity and
Laplace noise components.
4.1 Proof of Correctness
In this section we formally define the FLEX mechanism and prove
that it provides (, δ)-differential privacy.
FLEX implements the following differential privacy mechanism
derived from the Laplace-based smooth sensitivity mechanism de-
fined by Nissim et al. [31]:
Definition 6 (FLEX mechanism). For input query q and histogram
Error Type
Unsupported Query 14.14%
Parsing Error 6.58%
Analysis Error 3.21%
Table 2: Categorized Errors of FLEX’s Elastic Sensitivity Anal-
ysis
bin labels ` on true database x of size n, executed by the database
engineM with privacy parameters (, δ):
1. Set β = 
2 ln(2/δ)
.
2. Calculate S = maxk=0,1,...,n e−βkŜ(k)(q, x).
3. ReleaseM(q, `, x) + Lap(2S/).
This mechanism leverages smooth sensitivity [31], using elastic
sensitivity as an upper bound on local sensitivity.
Theorem 2. The FLEX mechanism provides (, δ)-differential pri-
vacy.
Proof. By Theorem 1 and Nissim et al. [31] Lemma 2.3, S is a β-
smooth upper bound on the local sensitivity of q. By Nissim et al.
Lemma 2.9, when the Laplace mechanism is used, a setting of β =

2 ln(2/δ)
suffices to provide (, δ)-differential privacy. By Nissim
et al. Corollary 2.4, the value released by the FLEX mechanism is
(, δ)-differentially private.
5. EXPERIMENTAL EVALUATION
We evaluate our approach with the following experiments:
• We measure the performance overhead and success rate of FLEX
on real-world queries (Section 5.1).
• We investigate the utility of FLEX-based differential privacy for
real-world queries with and without joins (Section 5.2).
• We evaluate the effect of the privacy budget  on the utility of
FLEX-based differential privacy (Section 5.3).
• We measure the utility impact of the data model optimizations
described in Section 3.5 (Section 5.4).
• We compare FLEX and wPINQ on a set of representative count-
ing queries using join (Section 5.5).
Experimental setup & dataset. We ran all of our experiments us-
ing our implementation of FLEX with Java 8 on Mac OSX. Our
test machine was equipped with a 2.2 GHz Intel Core i7 and 8GB
of memory. Our experiment dataset includes 9862 real queries ex-
ecuted during October 2016. To build this dataset, we identified
all counting queries (including histogram queries) submitted dur-
ing this time which examined sensitive trip data. Our dataset also
includes original results for each of these queries.
5.1 Success Rate and Performance of FLEX
To investigate FLEX’s support for the wide range of SQL features
in real-world queries, we ran FLEX’s elastic sensitivity analysis on
the queries in our experiment dataset. We recorded the number of
errors and classified each error according to its type. The results
are reported in Table 3(a).
In total, FLEX successfully calculated elastic sensitivity for 76%
of the queries. The largest group of errors is due to unsupported
queries (14.14%). These queries use features for which our ap-
proach cannot compute an elastic sensitivity, as described in Sec-
tion 3.6.1. Parsing errors occurred for 6.58% of queries. These er-
rors result from incomplete grammar definitions for the full set of
SQL dialects used by the queries, and could be fixed by expanding
Presto parser’s grammar definitions. The remaining errors (3.21%)
are due to other causes.
9
Avg (s) Max (s)
Original query 42.4 3,452
FLEX: Elastic Sensitivity Analysis 0.007 1.2
FLEX: Output Perturbation 0.005 2.4
Table 3: Performance of FLEX-based differential privacy
=== 
rewriting.Coverag
eResults ===
Trips Considered Number of Results Count(%)
  <100 158251 46.73%
100-1K 41605 12.28%
1K-10K 53197 15.71%
>10K 85620 25.28%
N
um
be
r o
f 
R
es
ul
ts
0K
80K
160K
Trip Sample Size
  <100 100-1K 1K-10K >10K
Table 2
Trips Considered Results
<100 158251
1000 41605
More 138817
0
40000
80000
120000
160000
<100 1000 More
Results
 1
Figure 3: Distribution of sample sizes for queries in our dataset
To investigate the performance of FLEX-based differential pri-
vacy, we measured the total execution time of the architecture de-
scribed in Figure 2 compared with the original query execution
time. We report the results in Table 3. Parsing and analysis of
the query to calculate elastic sensitivity took an average of 7.03
milliseconds per query. The output perturbation step added an ad-
ditional 4.86 milliseconds per query. By contrast, the average data-
base execution time was 42.4 seconds per query, implying an aver-
age performance overhead of 0.03%.
5.2 Utility of FLEX on Real-World Queries
Our work is the first to evaluate differential privacy on a set of
real-world queries executed on real data. In contrast with previous
evaluations of differential privacy [11, 23, 24], our dataset includes
a wide variety of real queries executed on real data.
We evaluate the behavior of FLEX for this broad range of queries.
Specifically, we measure the noise introduced to query results based
on whether or not the query uses join and what percentage of the
data is accessed by the query.
Query sample size. To evaluate the ability of FLEX to handle both
small and large populations, we define a metric called sample size.
The sample size of a query is the number of unique trips in the
database used to calculate the query results. The sample size metric
quantifies the extent to which a query targets specific users or trips:
a low sample size indicates the query is highly targeted, while a
higher sample size means the query returns statistics over a larger
population.
Figure 3 summarizes the distribution of sample sizes of the queries
in our dataset. Our dataset contains queries with a wide variety of
sample sizes, reflecting the diversity of queries in the dataset.
Utility of FLEX-based differential privacy. We evaluate the utility
of FLEX by comparing the error introduced by differential privacy
on each query against the sample size of that query. For small sam-
ple sizes, we expect our approach to protect privacy by producing
high error; for large sample sizes, we expect our approach to pro-
vide high utility by producing low error.
We used FLEX to produce differentially private results for each
query in our dataset. We report separately the results for queries
with no joins and those with joins. For each cell in the results,
we calculated the relative (percent) error introduced by FLEX, as
compared to the true (non-private) results. Then, we calculated the
median error of the query by taking the median of the error values
of all cells. For this experiment, we set  = 0.1 and δ = n− lnn
(where n is the size of the database), following Dwork and Lei [16].
Figure 4 shows the median error of each query against the sam-
ple size of that query for queries with no joins (a) and with joins
(b). The results indicate that FLEX achieves its primary goal of sup-
porting joins. Figure 4 shows similar trends with and without joins.
In both cases the median error generally decreases with increasing
sample size; furthermore, the magnitude of the error is comparable
for both. Overall, FLEX provides high utility (less than 10% error)
for a majority of queries both with and without joins.
Figure 4(b) shows a cluster of queries with higher errors but ex-
hibiting the same error-sample size correlation as the main group.
The queries in this cluster perform many-to-many joins on private
tables and do not benefit from the data model optimizations de-
scribed in Section 3.5. Even with this upward shift, a high utility is
predicted for sufficiently large sample size: at sample sizes larger
than 5 million the median error drops below 10%.
Hay et al. [23] define the term scale- exchangeability to describe
the trend of decreasing error with increasing sample size. The prac-
tical implication of this property is that a desired utility can always
be obtained by using a sufficiently large sample size. For counting
queries, a local sensitivity-based mechanism using Laplace noise
is expected to exhibit scale- exchangeability. Our results provide
empirical confirmation that FLEX preserves this property, for both
queries with and without joins, while calculating an approximation
of local sensitivity.
Inherently sensitive queries. Differential privacy is designed to
provide good utility for statistics about large populations in the
data. Queries with low sample size, by definition, pose an inherent
privacy risk to individuals; differential privacy requires poor util-
ity for their results in order to protect privacy. As pointed out by
Dwork and Roth [18] , “Questions about specific individuals can-
not be safely answered with accuracy, and indeed one might wish
to reject them out of hand.”
Since queries with low sample size are inherently sensitive and
therefore not representative of the general class of queries of high
interest for differential privacy, we exclude queries with sample
size smaller than 100 in the remaining experiments. This ensures
the results reflect the behavior of FLEX on queries for which high
utility may be expected.
5.3 Effect of Privacy Budget
In this section we evaluate the effect of the privacy budget on
utility of FLEX-based differential privacy. For each value of  in
the set {0.1, 1, 10} (keeping δ fixed at n− lnn), we computed the
median error of each query using FLEX, as in the previous experi-
ment.
We report the results in Figure 5, as a histogram grouping queries
by median error. As expected, larger values of  result in lower
median error. When  = 0.1, FLEX produces less than 1% median
error for fully half of the less sensitive queries in our dataset.
High-error queries. The previous two experiments demonstrate
that FLEX produces good utility for queries with high sample size,
but as demonstrated by the number of queries in the “More” bin in
Figure 5, FLEX also produces high error for some queries.
To understand the root causes of this high error, we manually
examined a random sample of 50 of these queries and categorized
them according to the primary reason for the high error.
We summarize the results in Figure 6. The category filter on
individual’s data (8% of high error queries) includes queries that
use a piece of data specific to an individual—either to filter the
sample with a Where clause, or as a histogram bin. For example,
the query might filter the set of trips by comparing the trip’s driver
ID against a string literal containing a particular driver’s ID, or it
might construct a histogram grouped by the driver ID, producing a
separate bin for each individual driver. These queries are designed
to return information specific to individuals.
The category low-population statistics (72% of high error queries)
contains queries with a Where clause or histogram bin label that
shrinks the set of rows considered. A query to determine the suc-
10
0.0001
  0.001
    0.01
      0.1
      1
    10
   100
1,000
10,000
1 100 10,000 1,000,000 100,000,000
COUNT
1 100 10,000 1,000,000 100,000,000
Coverage Error PermalinkId ColIndex IsHistogram NumJoins AggregationFuncti
on
UniqueOptimized PublicTableOptimi
zed
COUNT-NOJOIN SUM-NOJOIN MIN-NOJOIN MAX-NOJOIN COUNT-JOIN SUM-JOIN MIN-JOIN MAX-JOIN
6.0269182E+07 0.0001 jlhw6tUJev 0 FALSE 1 COUNT TRUE TRUE 0.0001
6.0269182E+07 0.0059 jlhw6tUJev 1 FALSE 1 COUNT TRUE TRUE 0.0059
60269182 0.0003 jlhw6tUJev 2 FALSE 1 COUNT TRUE TRUE 0.0003
60269182 5723230633627626
0000.0000
jlhw6tUJev 3 FALSE 1 SUM TRUE TRUE 5723230633627626
0000.0000
1192.5 1490008725784863
40000000000.0000
EDtaZmiyv8 2 TRUE 0 MAX FALSE FALSE 1490008725784863
40000000000.0000
91229.5 0.0107 EwbGajv7BT 2 TRUE 0 COUNT FALSE FALSE 0.0107
60269182 0.0001 uY85jAG7bi 0 FALSE 1 COUNT TRUE TRUE 0.0001
60269182 0.0052 uY85jAG7bi 1 FALSE 1 COUNT TRUE TRUE 0.0052
60269182 0.0003 uY85jAG7bi 2 FALSE 1 COUNT TRUE TRUE 0.0003
60269182 5677288097488345
5000.0000
uY85jAG7bi 3 FALSE 1 SUM TRUE TRUE 5677288097488345
5000.0000
1 1020.2653 bdlkeWPyrz 2 TRUE 0 COUNT FALSE FALSE 1020.2653
166 6.2513 rcDLPNq0bH 2 TRUE 0 COUNT FALSE FALSE 6.2513
1 1003.2892 oRv3AVlgSc 1 TRUE 0 COUNT FALSE FALSE 1003.2892
4420816 0.6245 Ddg5T7lKRQ 1 TRUE 2 COUNT TRUE TRUE 0.6245
4420816 0.0139 Ddg5T7lKRQ 2 TRUE 2 COUNT TRUE TRUE 0.0139
8779775 0.0001 p5hMlIlncW 1 TRUE 0 COUNT FALSE FALSE 0.0001
2472529 0.0017 Ms53mXnWMr 1 TRUE 1 COUNT TRUE TRUE 0.0017
4157.5 13104864.7476 I0bgnLLWZC 3 TRUE 4 COUNT TRUE TRUE 13104864.7476
429026 0.0100 NjwSfZIAVY 2 TRUE 1 COUNT TRUE TRUE 0.0100
429026 1372486049775348
8000000.0000
NjwSfZIAVY 3 TRUE 1 SUM TRUE TRUE 1372486049775348
8000000.0000
429026 0.0470 NjwSfZIAVY 4 TRUE 1 COUNT TRUE TRUE 0.0470
429026 0.8066 NjwSfZIAVY 5 TRUE 1 COUNT TRUE TRUE 0.8066
659961 0.0069 f5z3TjSuyR 1 TRUE 1 COUNT TRUE TRUE 0.0069
20017.5 0.2038 jCsmXPzBkZ 6 TRUE 1 COUNT TRUE TRUE 0.2038
15 419201938.6011 MdKfYtC5zQ 4 TRUE 3 COUNT TRUE TRUE 419201938.6011
15 1330783515760.43
02
MdKfYtC5zQ 5 TRUE 3 SUM TRUE TRUE 1330783515760.43
02
15 6154886933.1507 MdKfYtC5zQ 6 TRUE 3 COUNT TRUE TRUE 6154886933.1507
2766650 0.0017 GfxIuVSapn 1 TRUE 1 COUNT TRUE TRUE 0.0017
2766650 0.1543 GfxIuVSapn 2 TRUE 1 COUNT TRUE TRUE 0.1543
2766650 0.0053 GfxIuVSapn 3 TRUE 1 COUNT TRUE TRUE 0.0053
2766650 1017248254988797
600000.0000
GfxIuVSapn 4 TRUE 1 SUM TRUE TRUE 1017248254988797
600000.0000
23519891 0.0000 Lu80BoKdGf 2 TRUE 0 COUNT FALSE FALSE 0.0000
2723.5 0.3712 aq3UqakodG 1 TRUE 0 COUNT FALSE FALSE 0.3712
2723.5 0.3561 g6ma9KXD9d 1 TRUE 0 COUNT FALSE FALSE 0.3561
617125 0.0070 mCjuBlqRwB 0 FALSE 1 COUNT TRUE TRUE 0.0070
5305717 0.0008 bkuiVfOx5x 2 TRUE 1 COUNT TRUE TRUE 0.0008
5305717 1199677437052645
000000.0000
bkuiVfOx5x 3 TRUE 1 SUM TRUE TRUE 1199677437052645
000000.0000
29125952 0.0000 vyLLMUjjnn 2 TRUE 0 COUNT FALSE FALSE 0.0000
298321874 0.0000 A3E8oFKQlv 0 FALSE 0 COUNT FALSE FALSE 0.0000
1117258 0.0014 9dXqqOS9KP 1 TRUE 0 COUNT FALSE FALSE 0.0014
16292 0.2308 teDwNB3sxL 7 TRUE 1 COUNT TRUE TRUE 0.2308
16292 7985666004678790
0000000.0000
teDwNB3sxL 8 TRUE 1 SUM TRUE TRUE 7985666004678790
0000000.0000
2735 1.3158 8yhnQ6fP59 0 TRUE 0 COUNT FALSE FALSE 1.3158
407843.5 0.0025 OsVOYhxmWf 1 TRUE 0 COUNT FALSE FALSE 0.0025
407843.5 0.0030 OsVOYhxmWf 2 TRUE 0 COUNT FALSE FALSE 0.0030
420605 0.0097 8nPXaxQjwC 3 TRUE 1 COUNT TRUE TRUE 0.0097
5881310 0.0007 mGodxXoMF2 3 TRUE 1 COUNT TRUE TRUE 0.0007
1 953.2379 iStp74uBc4 1 TRUE 0 COUNT FALSE FALSE 953.2379
35350130 5887.5633 tPyfD5QWBp 0 FALSE 0 MAX FALSE FALSE 5887.5633
35350130 1159.5075 tPyfD5QWBp 1 FALSE 0 COUNT FALSE FALSE 1159.5075
79064 0.0899 DakmksDN1e 5 TRUE 1 COUNT TRUE TRUE 0.0899
79064 1553733002053208
70000000.0000
DakmksDN1e 8 TRUE 1 SUM TRUE TRUE 1553733002053208
70000000.0000
273331 0.0037 uaCtbl4IcR 0 FALSE 0 COUNT FALSE FALSE 0.0037
83 1614055.7738 gQF0lPqGMp 2 TRUE 2 COUNT TRUE FALSE 1614055.7738
51858 0.0198 PH65rODROE 1 TRUE 0 COUNT FALSE FALSE 0.0198
51858 0.0248 PH65rODROE 2 TRUE 0 COUNT FALSE FALSE 0.0248
51858 0.5462 PH65rODROE 3 TRUE 0 COUNT FALSE FALSE 0.5462
51858 0.1410 PH65rODROE 4 TRUE 0 COUNT FALSE FALSE 0.1410
51858 0.4736 PH65rODROE 5 TRUE 0 COUNT FALSE FALSE 0.4736
51858 0.0256 PH65rODROE 6 TRUE 0 COUNT FALSE FALSE 0.0256
51858 0.1152 PH65rODROE 7 TRUE 0 COUNT FALSE FALSE 0.1152
51858 0.7160 PH65rODROE 8 TRUE 0 COUNT FALSE FALSE 0.7160
51858 0.0279 PH65rODROE 9 TRUE 0 COUNT FALSE FALSE 0.0279
51858 0.3387 PH65rODROE 10 TRUE 0 COUNT FALSE FALSE 0.3387
9998425 0.0001 87FzwcOzpJ 1 TRUE 0 COUNT FALSE FALSE 0.0001
95081 0.2655 hlL67e8mNk 3 TRUE 1 COUNT TRUE TRUE 0.2655
127686 0.0339 9HRGLftJwF 1 TRUE 1 COUNT TRUE TRUE 0.0339
140145 0.0301 qzr4erANXO 1 TRUE 1 COUNT TRUE TRUE 0.0301
60445 0.1343 ofTJX24hc2 3 TRUE 1 COUNT TRUE FALSE 0.1343
1259 1.6316 BuuYhcsm8T 0 FALSE 0 COUNT FALSE FALSE 1.6316
870600 0.0013 pNltQ0lT8m 0 FALSE 0 COUNT FALSE FALSE 0.0013
5881310 0.0007 bzMJvmL2cR 3 TRUE 1 COUNT TRUE TRUE 0.0007
6929 0.1443 dMuXuPR7WW 1 TRUE 0 COUNT FALSE FALSE 0.1443
7347 0.1318 omm7MqKtmx 0 TRUE 0 COUNT FALSE FALSE 0.1318
41.5 24.4195 jpDho0cEeQ 1 TRUE 0 COUNT FALSE FALSE 24.4195
25744 0.1758 siSMF5XHwD 2 TRUE 1 COUNT TRUE TRUE 0.1758
2238 0.4349 uv5M48ZjNs 2 TRUE 0 COUNT FALSE FALSE 0.4349
5664 33117.9618 Ma7VApeKNG 2 TRUE 2 COUNT TRUE TRUE 33117.9618
30414 0.0338 y1MTzMTBc3 1 TRUE 0 COUNT FALSE FALSE 0.0338
30414 0.0336 y1MTzMTBc3 2 TRUE 0 COUNT FALSE FALSE 0.0336
307260 0.0033 wp7rlM8D53 0 FALSE 0 COUNT FALSE FALSE 0.0033
513 1.7897 Ou7EoAizaF 0 FALSE 0 COUNT FALSE FALSE 1.7897
1 8443811099658800
0000.0000
pil4bUK38a 2 TRUE 4 COUNT FALSE FALSE 8443811099658800
0000.0000
6885924 0.0001 btsRPi5oz9 0 FALSE 0 COUNT FALSE FALSE 0.0001
2398543 0.0005 aovmwHokBV 0 FALSE 0 COUNT FALSE FALSE 0.0005
20447 0.0517 HqeaL1GxKr 0 FALSE 0 COUNT FALSE FALSE 0.0517
415610304 5.5601 bu9sEeQ8jf 0 FALSE 3 COUNT TRUE TRUE 5.5601
76646 0.0153 ousJCsAOm9 3 TRUE 0 COUNT FALSE FALSE 0.0153
2963 0.4490 ctlaWOrZp4 0 FALSE 0 COUNT FALSE FALSE 0.4490
6 4686878.0240 tN4UD1wdSF 3 TRUE 1 COUNT TRUE FALSE 4686878.0240
6 152.7872 wqxt4FNg0c 1 TRUE 0 COUNT FALSE FALSE 152.7872
1 3903.7444 81iRN9sqg4 2 TRUE 1 COUNT TRUE FALSE 3903.7444
1 3938.6088 81iRN9sqg4 3 TRUE 1 COUNT TRUE FALSE 3938.6088
2467 0.4814 Dc4grrPFtW 1 TRUE 0 COUNT FALSE FALSE 0.4814
2467 7.1582 Dc4grrPFtW 3 TRUE 0 COUNT FALSE FALSE 7.1582
1 1.8360 Mp0NFqtduX 1 FALSE 1 COUNT TRUE FALSE 1.8360
70 13.9398 a6UXbeK5Wa 0 FALSE 0 COUNT FALSE FALSE 13.9398
61 0.0000 PcebYtRrI9 1 TRUE 4 MAX TRUE FALSE 0.0000
3 313.5397 aeC0wmijzA 2 TRUE 0 COUNT FALSE FALSE 313.5397
2866.5 9100.5287 hihhTo6XwB 2 TRUE 1 COUNT TRUE FALSE 9100.5287
5 327192.2567 9I8J5vGOmT 1 TRUE 3 COUNT TRUE TRUE 327192.2567
34087 0.4191 AeANFKfHVq 1 TRUE 0 COUNT FALSE FALSE 0.4191
34087 0.0330 AeANFKfHVq 2 TRUE 0 COUNT FALSE FALSE 0.0330
34087 66.5482 AeANFKfHVq 3 TRUE 0 NONE FALSE FALSE
27794 0.0405 yzdOaB7YmN 1 TRUE 0 COUNT FALSE FALSE 0.0405
27794 0.5984 yzdOaB7YmN 3 TRUE 0 COUNT FALSE FALSE 0.5984
779 7.9674 yVfEW4tcEL 2 TRUE 0 COUNT FALSE FALSE 7.9674
779 11.4866 yVfEW4tcEL 3 TRUE 0 COUNT FALSE FALSE 11.4866
779 Infinity yVfEW4tcEL 4 TRUE 0 COUNT FALSE FALSE Infinity
779 82.0329 yVfEW4tcEL 5 TRUE 0 COUNT FALSE FALSE 82.0329
779 68.6358 yVfEW4tcEL 6 TRUE 0 COUNT FALSE FALSE 68.6358
779 176.7366 yVfEW4tcEL 7 TRUE 0 COUNT FALSE FALSE 176.7366
239.5 6147.2025 vNKjZ5R6Sc 1 TRUE 3 COUNT TRUE TRUE 6147.2025
3275 0.3593 w6ThdjTNPi 1 TRUE 0 COUNT FALSE FALSE 0.3593
3275 3.2953 w6ThdjTNPi 2 TRUE 0 COUNT FALSE FALSE 3.2953
3275 2821917063740462
60000000.0000
w6ThdjTNPi 6 TRUE 0 SUM FALSE FALSE 2821917063740462
60000000.0000
39511 0.0279 N4XSBoD9LX 0 FALSE 0 COUNT FALSE FALSE 0.0279
24028142 0.0002 8C2eoF5qJf 1 TRUE 1 COUNT TRUE TRUE 0.0002
24028142 1642642947180909
40000.0000
8C2eoF5qJf 2 TRUE 1 SUM TRUE TRUE 1642642947180909
40000.0000
6 23477714.3228 LBpvqUioja 3 TRUE 2 COUNT TRUE TRUE 23477714.3228
9464 20555.7885 CYY8yy7DY8 1 TRUE 2 COUNT TRUE TRUE 20555.7885
75943 0.0119 CiSxs7sYXg 1 TRUE 0 COUNT FALSE FALSE 0.0119
75943 0.0169 CiSxs7sYXg 2 TRUE 0 COUNT FALSE FALSE 0.0169
75943 0.0684 CiSxs7sYXg 3 TRUE 0 COUNT FALSE FALSE 0.0684
75943 0.0995 CiSxs7sYXg 4 TRUE 0 COUNT FALSE FALSE 0.0995
35521 0.0229 I3imaRXqSP 1 TRUE 0 COUNT FALSE FALSE 0.0229
307260 0.0031 syv5DkZPgk 0 FALSE 0 COUNT FALSE FALSE 0.0031
31571 2.8929 qattVAsbDx 0 FALSE 2 COUNT TRUE TRUE 2.8929
31571 3.3087 qattVAsbDx 1 FALSE 2 COUNT TRUE TRUE 3.3087
1 6026.3193 AO2EJH8dw1 2 TRUE 1 COUNT TRUE FALSE 6026.3193
207.5 4.9187 rSAQLL8OTP 2 TRUE 0 COUNT FALSE FALSE 4.9187
37390.5 32.6289 BKTybvYWZm 10 TRUE 3 COUNT TRUE TRUE 32.6289
432008.5 0.0140 Gc9Ano49Rb 1 TRUE 1 COUNT TRUE TRUE 0.0140
432008.5 4366003134096468
00000000000.0000
Gc9Ano49Rb 2 TRUE 1 AVG TRUE TRUE
877000 0.0045 cE3DYg461q 1 TRUE 1 COUNT TRUE TRUE 0.0045
1768 142612.7375 y7qar0qgsv 1 TRUE 1 COUNT FALSE FALSE 142612.7375
1768 38203.6045 y7qar0qgsv 2 TRUE 1 COUNT FALSE FALSE 38203.6045
4618 28.7404 chwyC0zcz2 2 TRUE 2 COUNT TRUE TRUE 28.7404
3.1571E+04 0.0378 tOs6isCPHL 0 FALSE 0 COUNT FALSE FALSE 0.0378
4.4885E+03 1.2521 9UJCnH86lb 3 TRUE 1 COUNT TRUE TRUE 1.2521
654044 0.0063 9zWr8VqKrO 2 TRUE 1 COUNT TRUE TRUE 0.0063
35570 0.0237 rffCZ97L6M 1 TRUE 0 COUNT FALSE FALSE 0.0237
35570 0.0321 rffCZ97L6M 2 TRUE 0 COUNT FALSE FALSE 0.0321
1.503243E+06 0.0008 ma6ilDgdYK 1 TRUE 0 COUNT FALSE FALSE 0.0008
1503243 0.0021 ma6ilDgdYK 2 TRUE 0 COUNT FALSE FALSE 0.0021
1503243 0.0013 ma6ilDgdYK 3 TRUE 0 COUNT FALSE FALSE 0.0013
1503243 3061.3767 ma6ilDgdYK 4 TRUE 0 NONE FALSE FALSE
15052.5 2178.0999 npMgFmVymB 2 TRUE 1 COUNT FALSE FALSE 2178.0999
78528 0.0127 NjIeuxEved 1 TRUE 0 COUNT FALSE FALSE 0.0127
293246 0.2258 yQasKQopeC 1 TRUE 2 COUNT TRUE FALSE 0.2258
293246 0.3035 yQasKQopeC 2 TRUE 2 COUNT TRUE FALSE 0.3035
293246 2.5738 yQasKQopeC 3 TRUE 2 COUNT TRUE FALSE 2.5738
293246 1.8481 yQasKQopeC 4 TRUE 2 COUNT TRUE FALSE 1.8481
293246 470527.8350 yQasKQopeC 5 TRUE 2 NONE TRUE FALSE
9 3352169.9478 h0n0atrzH8 3 TRUE 1 COUNT FALSE FALSE 3352169.9478
54 3445988612260853
80.0000
JmgMtE9zuh 2 TRUE 5 COUNT TRUE TRUE 3445988612260853
80.0000
54 1286106966916641
44.0000
JmgMtE9zuh 5 TRUE 5 COUNT FALSE FALSE 1286106966916641
44.0000
35570 0.0254 AOsddyKAYe 1 TRUE 0 COUNT FALSE FALSE 0.0254
35570 0.0253 AOsddyKAYe 2 TRUE 0 COUNT FALSE FALSE 0.0253
2278 0.4419 qEtqlN4pEn 1 TRUE 0 COUNT FALSE FALSE 0.4419
8 122.9408 Nt9bWLjt99 1 TRUE 0 COUNT FALSE FALSE 122.9408
181109 0.0056 rVKMBDijNr 2 TRUE 0 COUNT FALSE FALSE 0.0056
282231 0.0035 BXWQ2xSoG7 1 TRUE 0 COUNT FALSE FALSE 0.0035
282231 Infinity BXWQ2xSoG7 2 TRUE 0 COUNT FALSE FALSE Infinity
282231 0.0041 BXWQ2xSoG7 3 TRUE 0 COUNT FALSE FALSE 0.0041
282231 0.1996 BXWQ2xSoG7 4 TRUE 0 COUNT FALSE FALSE 0.1996
282231 0.1356 BXWQ2xSoG7 5 TRUE 0 COUNT FALSE FALSE 0.1356
67961 0.0197 im2XLphpJH 1 TRUE 0 SUM FALSE FALSE 0.0197
67961 0.0148 im2XLphpJH 2 TRUE 0 COUNT FALSE FALSE 0.0148
3434.5 8543.5570 Jasaa1i6rA 1 TRUE 1 COUNT TRUE FALSE 8543.5570
3434.5 49460901.3582 Jasaa1i6rA 2 TRUE 1 NONE TRUE FALSE
294690 1.1204 sbhpsvej0X 1 FALSE 1 COUNT TRUE FALSE 1.1204
524 10.5091 boqvIrGf0L 3 TRUE 1 COUNT TRUE TRUE 10.5091
23 132493.0477 87oxckzdxT 1 TRUE 3 COUNT TRUE FALSE 132493.0477
10 102.2219 sKmy3qH3al 4 TRUE 0 COUNT FALSE FALSE 102.2219
10 146.0265 sKmy3qH3al 5 TRUE 0 COUNT FALSE FALSE 146.0265
M
ed
ia
n 
Er
ro
r
0
0
0.001
0.01
0.1
1
10
100
1000
10000
Trip Sample Size
1 100 10,000 1,000,000 100,000,000
No Joins With JoinsHigh utility (< 10% error)
M
ed
ia
n 
Er
ro
r (
%
)
(b)(a)
Trip Sample Size Trip Sample Size
0.0001
  0.001
    0.01
      0.1
      1
    10
   100
1,000
10,000
M
ed
ia
n 
Er
ro
r (
%
)
 1
Figure 4: Median error for FLEX-based differential privacy compared to sample size for queries with no joins (a) and with joins (b).
Queries with high utility (less than 10% median error) are shaded gray.
Error ε = 0.1 ε = 1 ε = 10
<1% 51.61% 61.73% 75.39%
1-5% 7.54% 3.35% 2.92%
5-10% 2.40% 0.90% 1.27%
10-25% 2.47% 2.03% 3.79%
25-100% 2.69% 3.61% 4.81%
More 35.28% 28.40% 11.81%
Pe
rc
en
t o
f R
es
ul
ts
0%
25%
50%
75%
100%
Median Error
<1% 1-5% 5-10% 10-25% 25-100% More
ε = 0.1 ε = 1 ε = 10
 1
Figure 5: Effect of  on median error for FLEX-based differen-
tial privacy.
Category Percent
Filters on individual’s data 8%
Low-population statistics 72%
Many-to-many Join causes high elastic sensitivity 20%
Figure 6: Manual categorization of queries with high error
cess rate of a promotion might restrict the trips considered to those
within a small city, during the past week, paid for using a particular
type of credit card, and using the promotion. The analyst in this
case may not intend to examine the information of any individual,
but since the query is highly dependent on a small set of rows, the
results may nevertheless reveal an individual’s information.
These two categories suggest that even queries with a sample
size larger than 100 can carry inherent privacy risks. Differential
privacy requires high error in these cases for the reasons motivated
earlier.
The third category (20% of high error queries) contains queries
that have many-to-many joins with large maximum frequency met-
rics and which do not benefit from any of the optimizations de-
scribed in Section 3.5. These queries are not necessarily inherently
sensitive; the high error may be due to a loose bound on local sen-
sitivity arising from elastic sensitivity’s design.
Error With optimization Without 
optimizati n
<1% 52.04% 30.03%
1-5% 11.75% 7.16%
5-10% 3.87% 2.97%
10-25% 5.00% 2.87%
25-100% 4.55% 3.04%
More 22.79% 53.93%
Pe
rc
en
t o
f R
es
ul
ts
0%
15%
30%
45%
60%
Median Error
<1% 1-5% 5-10% 10-25% 25-100% More
With optimization Without optimization
 1
Figure 7: Impact of data model optimization for tighter bounds
on sensitivity.
5.4 Impact of Data Model Optimization
Section 3.5 describes an optimization for elastic sensitivity that
uses data models to achieve a tighter bound on sensitivity. We mea-
sure the impact of this optimization on query utility by calculating
median error introduced by FLEX for each query in our dataset with
the optimization enabled and disabled. We use the same experi-
mental setup described in the previous section, with  = 0.1 and
δ = n− lnn. As before, we exclude queries with sample size less
than 100.
The optimization is applied to 50.3% of queries in our dataset.
Over half (52.3%) of these queries join private tables on unique
keys; the remaining queries join private tables with public tables.
All queries in the latter category benefit from the unique key opti-
mization. This is due to the two public tables in our environment
(cities and promotions) being used exclusively in joins on unique
keys (e.g., city id).
Figure 7 shows the utility impact of the optimization across all
queries. The optimization increases the percentage of queries with
greatest utility (error less than 1.0%) from 30% to 52%. The ma-
jority of the increase in high-utility queries come from the lowest-
utility bin (error greater than 100%) while little change is seen in
the mid-range error bins. This suggests our optimization is most
effective on queries which would otherwise produce high error, op-
timizing more than half of these queries into the 1% error bin.
5.5 Comparison with wPINQ
We aim to compare our approach to alternative differential pri-
vacy mechanisms with equivalent support for real-world queries.
Of the mechanisms listed in Section 2.3, only wPINQ supports
counting queries with the full spectrum of join types.
Since wPINQ programs are implemented in C#, we are unable to
run wPINQ directly on our SQL query dataset. Instead we compare
the utility between the two mechanisms for a selected set of repre-
sentative queries. The precise behavior of each mechanism may
differ for every query, however this experiment provides a relative
comparison of the mechanisms for the most common cases.
Experiment Setup. We selected a set of representative queries
based on the most common equijoin patterns (joined tables and join
condition) across all counting queries in our dataset. We identify
the three most common join patterns for both histogram and non-
histogram queries and select a random query representing each.
Our six selected queries collectively represent 8.6% of all join pat-
terns in our dataset.
For each selected query we manually transcribe the query into
11
Program Joined tables
Median Median Error (%)
Sample wPINQ ElasticSize Sensitivity
1. Count distinct drivers who have completed a trip in San Francisco yet enrolled as a driver in a different city. trips, drivers 663 45.9 22.6
2. Count driver accounts that are active and were tagged after June 6 as duplicate accounts. users, user tags 734 71.5 1.3
3. Count motorbike drivers in Hanoi who are currently active and have completed 10 or more trips. drivers, analytics 212 51.4 4.72
4. Histogram: Count daily trips by city (for all cities) on Oct. 24, 2016. trips, cities 87 11.5 11.5
5. Histogram: Count total trips per driver in Hong Kong between Sept. 9 and Oct. 3, 2016. trips, drivers 1 974 1501
6. Histogram: Count drivers by different thresholds of total completed trips for drivers registered in Syndey,
AUS who have completed a trip within the past 28 days.
drivers, analytics 72 51.5 13.9
Table 4: Utility comparison of wPINQ and FLEX for selected set of representative counting queries using join.
a wPINQ program. To ensure a fair comparison, we use wPINQ’s
select operator rather than the join operator for joins on a pub-
lic table. This ensures that no noise is added to protect records in
public tables, equivalent to elastic sensitivity’s public table opti-
mization.
Our input data for these programs includes all records from the
cities table, which is public, and a random sample of 1.5 million
records from each private table (it was not feasible to download the
full tables, which contain over 2 billion records). We execute each
program 100 times with the wPINQ runtime [9].
To obtain baseline (non-differentially private) results we run each
SQL query on a database populated with only the sampled records.
For elastic sensitivity we use max-frequency metrics calculated from
this sampled data. We compute the median error for each query
using the methodology described in the previous section, setting
 = 0.1 for both mechanisms.
Table 4 summarizes the queries and median error results. FLEX
provides lower median error than wPINQ for programs 1, 2, 3 and
6—more than 90% lower for 2 and 3 and 73% lower for program
5. FLEX and wPINQ provide identical error for program 3 due to
equivalent effects of elastic sensitivity’s public table optimization
and wPINQ’s select operator.
FLEX provides higher error for program 5 although both mecha-
nisms produce errors above 900%. The median sample size of 1 for
this program indicates that our experiment data includes very few
trips per driver that satisfy the filter conditions. Elastic sensitiv-
ity provides looser bounds on local sensitivity for queries that filter
more records, resulting in a comparably higher error for queries
such as this one. Given that such queries are inherently sensitive, a
high error (low utility) is required for any differential privacy mech-
anism, therefore the comparably higher error of FLEX is likely in-
significant in practice.
Proserpio et al. [33] describe a post-processing step for generat-
ing synthetic data by using wPINQ results to guide a Markov-Chain
Monte Carlo simulation. The authors show that this step improves
utility for graph triangle counting queries when the original query
is executed on the synthetic dataset. However, the authors achieve
this improved utility via an alternative query carefully crafted for
the MCMC process. As the behavior of MCMC is highly depen-
dent on the alternate query, and the authors do not describe how to
construct this query for general analytics programs, we are unable
to evaluate wPINQ with this additional step.
6. RELATED WORK
Differential privacy was originally proposed by Dwork [14, 15,
17], and the reference by Dwork and Roth [18] provides an excel-
lent general overview of work on differential privacy. Much of this
work focuses on mechanisms for releasing the results of specific
algorithms. Our focus, in contrast, is on a general-purpose mech-
anism for SQL queries that supports general equijoins. We survey
the existing general mechanisms that support join in Section 2.3.
Airavat [34] enforces differential privacy for arbitrary MapReduce
programs, but requires the analyst to bound the range of possible
outputs of the program, and clamps output values to lie within that
range. Fuzz [20,21] enforces differential privacy for functional pro-
grams, but does not support one-to-many or many-to-many joins.
Propose-test-release [16] (PTR) is a framework for leveraging
local sensitivity that works for arbitrary real-valued functions. PTR
requires (but does not define) a way to calculate the local sensitivity
of a function. Our work on elastic sensitivity is complementary,
since it can enable the use of PTR by providing a bound on local
sensitivity.
Sample & aggregate [31] is a data-dependent framework that ap-
plies to all statistical estimators. It works by splitting the database
into chunks, running the query on each chunk, and aggregating the
results using a differentially private algorithm. Sample & aggre-
gate cannot support joins, since splitting the database breaks join
semantics, nor does it support queries that are not statistical esti-
mators, such as counting queries. GUPT [28] is a practical system
that leverages the sample & aggregate framework to enforce differ-
ential privacy for general-purpose analytics.
A number of less-general mechanisms for performing specific
graph analysis tasks have been proposed [22, 25, 26, 35]. These
tasks often involve joins, but the mechanisms used to handle them
are specific to the task and are not applicable for general-purpose
analytics. For example, the recursive mechanism [12] supports
general equijoins in the context of graph analyses, but is restricted
to monotonic queries and in the worst case, runs in time exponential
in the number of participants in the database.
7. CONCLUSION
This paper proposes a practical approach for differential privacy
of general-purpose SQL queries. We conducted the largest known
empirical study of real-world SQL queries—8.1 million queries in
total. From these results we proposed a new set of requirements
for practical differential privacy on SQL queries. To meet these
requirements, we proposed elastic sensitivity, the first efficiently-
computed approximation of local sensitivity that supports joins,
and used it to build FLEX, a system for enforcing differential pri-
vacy for SQL queries. We evaluated FLEX on a wide variety of
real-world queries, demonstrating that FLEX can provide high util-
ity on a majority of queries with large sample sizes.
Acknowledgments
The authors would like to thank Abhradeep Guha Thakurta for his
helpful comments on an earlier version of this paper. This ma-
terial is in part based upon work supported by DARPA contract
#N66001-15-C-4066 and by the Center for Long-Term Cybersecu-
rity. Any opinions, findings, and conclusions or recommendations
expressed in this material are those of the author(s) and do not nec-
essarily reflect the views of the sponsors.
12
8. REFERENCES
[1] Apple previews iOS 10, the biggest iOS release ever.
http://www.apple.com/newsroom/2016/06/apple-
previews-ios-10-biggest-ios-release-ever.html.
Accessed: 2016-08-14.
[2] Check Constraint. https://msdn.microsoft.com/en-
us/library/ms190377.aspx.
[3] Database Triggers. https://docs.oracle.com/cd/
A57673_01/DOC/server/doc/SCN73/ch15.htm.
[4] Morgan Stanley Breach a Reminder of Insider Risks.
https://securityintelligence.com/news/morgan-
stanley-breach-reminder-insider-risks/.
Accessed: 2016-02-21.
[5] Nearly 5,000 patients affected by UC Irvine medical data
breach. http://www.latimes.com/business/la-fi-
uc-irvine-data-breach-20150618-story.html.
Accessed: 2016-08-16.
[6] Presto: Distributed SQL Query Engine for Big Data.
https://prestodb.io/. Accessed: 2016-08-11.
[7] Sutter Health California Pacific Medical Center audit
uncovers data breach.
http://www.csoonline.com/article/2876324/data-
breach/sutter-health-california-pacific-
medical-center-audit-uncovers-data-
breach.html. Accessed: 2016-08-16.
[8] Swiss spy agency warns U.S., Britain about huge data leak.
http://www.reuters.com/article/us-usa-
switzerland-datatheft-idUSBRE8B30ID20121204.
Accessed: 2016-02-21.
[9] Weighted Privacy Integrated Queries.
http://cs-people.bu.edu/dproserp/wPINQ.html.
Accessed: 2017-02-10.
[10] J. Blocki, A. Blum, A. Datta, and O. Sheffet. Differentially
private data analysis of social networks via restricted
sensitivity. In Proceedings of the 4th Conference on
Innovations in Theoretical Computer Science, ITCS ’13,
pages 87–96, New York, NY, USA, 2013. ACM.
[11] J. Blocki, A. Datta, and J. Bonneau. Differentially private
password frequency lists. In 23nd Annual Network and
Distributed System Security Symposium, NDSS 2016, San
Diego, California, USA, February 21-24, 2016. The Internet
Society, 2016.
[12] S. Chen and S. Zhou. Recursive mechanism: Towards node
differential privacy and unrestricted joins. In Proceedings of
the 2013 ACM SIGMOD International Conference on
Management of Data, SIGMOD ’13, pages 653–664, New
York, NY, USA, 2013. ACM.
[13] Y.-A. de Montjoye, C. A. Hidalgo, M. Verleysen, and V. D.
Blondel. Unique in the crowd: The privacy bounds of human
mobility. Scientific reports, 3, 2013.
[14] C. Dwork. Differential privacy. In M. Bugliesi, B. Preneel,
V. Sassone, and I. Wegener, editors, Automata, Languages
and Programming, volume 4052 of Lecture Notes in
Computer Science, pages 1–12. Springer Berlin Heidelberg,
2006.
[15] C. Dwork. Differential privacy: A survey of results. In
Theory and applications of models of computation, pages
1–19. Springer, 2008.
[16] C. Dwork and J. Lei. Differential privacy and robust
statistics. In Proceedings of the forty-first annual ACM
symposium on Theory of computing, pages 371–380. ACM,
2009.
[17] C. Dwork, F. McSherry, K. Nissim, and A. Smith.
Calibrating noise to sensitivity in private data analysis. In
Theory of Cryptography Conference, pages 265–284.
Springer, 2006.
[18] C. Dwork, A. Roth, et al. The algorithmic foundations of
differential privacy. Foundations and Trends in Theoretical
Computer Science, 9(3-4):211–407, 2014.
[19] Ú. Erlingsson, V. Pihur, and A. Korolova. Rappor:
Randomized aggregatable privacy-preserving ordinal
response. In Proceedings of the 2014 ACM SIGSAC
conference on computer and communications security, pages
1054–1067. ACM, 2014.
[20] M. Gaboardi, A. Haeberlen, J. Hsu, A. Narayan, and B. C.
Pierce. Linear dependent types for differential privacy. In
ACM SIGPLAN Notices, volume 48, pages 357–370. ACM,
2013.
[21] A. Haeberlen, B. C. Pierce, and A. Narayan. Differential
privacy under fire. In USENIX Security Symposium, 2011.
[22] M. Hay, C. Li, G. Miklau, and D. Jensen. Accurate
estimation of the degree distribution of private networks. In
Data Mining, 2009. ICDM’09. Ninth IEEE International
Conference on, pages 169–178. IEEE, 2009.
[23] M. Hay, A. Machanavajjhala, G. Miklau, Y. Chen, and
D. Zhang. Principled evaluation of differentially private
algorithms using dpbench. In F. Özcan, G. Koutrika, and
S. Madden, editors, Proceedings of the 2016 International
Conference on Management of Data, SIGMOD Conference
2016, San Francisco, CA, USA, June 26 - July 01, 2016,
pages 139–154. ACM, 2016.
[24] X. Hu, M. Yuan, J. Yao, Y. Deng, L. Chen, Q. Yang,
H. Guan, and J. Zeng. Differential privacy in telco big data
platform. PVLDB, 8(12):1692–1703, 2015.
[25] V. Karwa, S. Raskhodnikova, A. Smith, and G. Yaroslavtsev.
Private analysis of graph structure. Proceedings of the VLDB
Endowment, 4(11):1146–1157, 2011.
[26] S. P. Kasiviswanathan, K. Nissim, S. Raskhodnikova, and
A. Smith. Analyzing graphs with node differential privacy. In
Theory of Cryptography, pages 457–476. Springer, 2013.
[27] F. D. McSherry. Privacy integrated queries: an extensible
platform for privacy-preserving data analysis. In Proceedings
of the 2009 ACM SIGMOD International Conference on
Management of data, pages 19–30. ACM, 2009.
[28] P. Mohan, A. Thakurta, E. Shi, D. Song, and D. Culler. Gupt:
privacy preserving data analysis made easy. In Proceedings
of the 2012 ACM SIGMOD International Conference on
Management of Data, pages 349–360. ACM, 2012.
[29] A. Narayan and A. Haeberlen. Djoin: differentially private
join queries over distributed databases. In Presented as part
of the 10th USENIX Symposium on Operating Systems
Design and Implementation (OSDI 12), pages 149–162,
2012.
[30] A. Narayanan and V. Shmatikov. How to break anonymity of
the Netflix prize dataset. CoRR, abs/cs/0610105, 2006.
[31] K. Nissim, S. Raskhodnikova, and A. Smith. Smooth
sensitivity and sampling in private data analysis. In
Proceedings of the thirty-ninth annual ACM symposium on
Theory of computing, pages 75–84. ACM, 2007.
[32] V. Pandurangan. On taxis and rainbows: Lessons from
NYC’s improperly anonymized taxi logs.
https://medium.com/@vijayp/of-taxis-and-rainbows-
f6bc289679a1. Accessed:
2015-11-09.
13
[33] D. Proserpio, S. Goldberg, and F. McSherry. Calibrating data
to sensitivity in private data analysis: A platform for
differentially-private analysis of weighted datasets.
Proceedings of the VLDB Endowment, 7(8):637–648, 2014.
[34] I. Roy, S. T. Setty, A. Kilzer, V. Shmatikov, and E. Witchel.
Airavat: Security and privacy for mapreduce. In NSDI,
volume 10, pages 297–312, 2010.
[35] A. Sala, X. Zhao, C. Wilson, H. Zheng, and B. Y. Zhao.
Sharing graphs using differentially private graph models. In
Proceedings of the 2011 ACM SIGCOMM conference on
Internet measurement conference, pages 81–98. ACM, 2011.
[36] A. Smith. Privacy-preserving statistical estimation with
optimal convergence rates. In Proceedings of the forty-third
annual ACM symposium on Theory of computing, pages
813–822. ACM, 2011.
[37] L. Sweeney. Weaving technology and policy together to
maintain confidentiality. The Journal of Law, Medicine &
Ethics, 25(2-3):98–110, 1997.
14

