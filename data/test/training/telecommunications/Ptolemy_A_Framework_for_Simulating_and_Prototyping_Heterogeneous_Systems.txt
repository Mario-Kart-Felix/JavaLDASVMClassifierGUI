August 31, 19921 of 34ATHEUNIVERS IT Y  O F  CALI FORNIA1868LET THE R E BELI G HTDepartment of Electrical Engineeringand Computer ScienceUniversity of CaliforniaBerkeley, California 94720Ptolemy A Framework for Simulating andPrototyping Heterogeneous SystemsJoseph BuckSoonhoi HaEdward A. LeeDavid G. Messerschmitt1.0 ABSTRACTPtolemy is an environment for simulation and prototyping of heterogeneous systems. It uses modern objectoriented software technology C to model each subsystem in a natural and efficientmanner, and to integrate these subsystems into a whole. Ptolemy encompasses practically allaspects of designing signal processing and communications systems, ranging from algorithms andcommunication strategies, simulation, hardware and software design, parallel computing, andgenerating realtime prototypes. To accommodate this breadth, Ptolemy must support a plethoraof widelydiffering design styles. The core of Ptolemy is a set of objectoriented class definitionsthat makes few assumptions about the system to be modeled rather, standard interfaces are provided for generic objects and more specialized, applicationspecific objects are derived fromthese. A basic abstraction in Ptolemy is the Domain, which realizes a computational model appropriate for a particular type of subsystem. Current examples of domains include synchronous anddynamic dataflow, discreteevent, and others appropriate for control software and embeddedmicrocontrollers. Domains can be mixed as appropriate to realize an overall system simulation.Some current applications of Ptolemy include networking and transport, callprocessing and signaling software, embedded microcontrollers, signal processing including implementation in realtime realtime, scheduling of parallel digital signal processors, boardlevel hardware timing simulation, and combinations of these.Key words Heterogeneity, mixedmode, simulation, prototyping, objectoriented programmingInvited paper in the International Journal of Computer Simulationspecial issue on Simulation Software Development.INTRODUCTION2 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systems2.0 INTRODUCTIONPtolemy is a simulation and rapid prototyping framework for heterogeneous systems. It isideal for applications in which heterogeneity is a key characteristic. such as Design of multimedia networks Realtime embedded software HardwareSoftware codesign Control and callprocessing in telecommunications networks Rapid prototyping of new telecommunications services Mixedmode hardware simulation Mapping applications onto heterogeneous multiprocessor systems and Mixed signal processing and realtime control.For example, in the design of multimedia networks, we are interested in studying the interactionbetween transport, compression or compositing signal processing, and control software in voiceor video services over cellrelay networks. In telecommunication systems we are interested instudying the interaction between callprocessing software and hardware switch elements. Todevelop new telecommunication services, we must jointly design control software, signal processing, transport, and hardware elements.In hardware design we are interested in modeling components with varying detail, such asbehavioral, logic, timing, and circuit. In systemlevel design, we may wish to jointly design thecommunications infrastructure and the processing elements. We may also wish to synthesize incombination microcode for specialized processors, C code for generic processors, routing tablesfor fieldprogrammable gate arrays, and custom VLSI. We may wish to automate mappings ontoparallel processors by mixing specialized schedulers, such as those that target systolic arrays 11,or those that address only applications with predictable control flow 28.INTRODUCTIONPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 3 of 34Simulation and system specification environments that support heterogeneity have beendeveloped before. For example, mixedmode circuit simulation is now the standard way to dealwith complex VLSI circuits. At a higher level, the STATEMATE system by iLogix 11 combines activity charts, which describe dataflow, with statecharts 10, which describe control. Avery different flavor of heterogeneous system is a coordination language, like Granular Lucid14, which combines standard procedural languages with an indexical model a sort of multidimensional declarative model. Another example of a coordination language is Linda 5. All ofthese heterogeneous systems, however, assume a small number of predefined sets of semanticsthat prove central to the system design. We avoid predefining the semantics we can accommodate.An alternative to heterogeneity is generality. For example, VHDL is a relatively large language with considerable semantic richness, so that it can accommodate different styles of systemdescription 13. Petri nets can model parallelism and timing relationships in a huge variety ofapplications 26. In addition, specialized models can be combined into more general models withunified semantics. For example, dataflow and discreteevent semantics have been combined forhardware design 33 and graphical programming 31. However, such generality has a price.Analysis of systems using such general descriptions is difficult, and efficient compilers are difficult to implement. In the case of VHDL, for example, all effective VLSI synthesis tools restricttheir domain to a subset of the language. Unfortunately, each tool chooses a different subset, nullifying the benefits of a standardized language. Similarly, effective parallel schedulers restricttheir domain to special cases of Petri nets. Furthermore, the complexity and diversity in systemlevel design is only going to increase. Although any Turingequivalent model can, in principle,handle any computational design, clearly there are benefits from specializing the specification language. We believe we cannot anticipate all the languages and models of computation that willprove effective. Our approach, therefore, is to embrace heterogeneity by allowing the user to mixdifferent subsystem modeling descriptions, without restricting those descriptions.The key innovation in Ptolemy is a nondogmatic kernel that does not presuppose a dataflow or functional model, finitestate machines, statecharts, communicating sequential processes,or Petri nets. Rather, Ptolemy can accommodate all of these. Most importantly, the objective is toINTRODUCTION4 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemscombine descriptions so that complex systems can be designed heterogeneously. Ptolemy can beviewed as a coordination language, but since it is not a language in any conventional sense, weprefer to describe it as a coordination framework.Of course, our limited resources have made it impossible to explore combinations of allthe models of computation described above. Hence, we cannot yet claim to have fully proven ourconcept. Furthermore, our experience indicates that combining highly dissimilar models of computation is not trivial. Our hope is that by providing an open architecture with welldefined interfaces, a community of users with very different design approaches can test our ideas.A typical large system is structured as shown in Figure 1. It consists of heterogenous subsystems some implemented in hardware, some in software together with a software control subsystem and a communications infrastructure. Ptolemy models such systems well. Consider forexample a portion of a multimedia connection through a broadband packet network as shown inFigure 2. In this heterogenous system, the video compression signal processing, transport networking and control software subsystems are most conveniently modeled in much differentways, and yet there is a desire to study the interaction of these subsystems. Another example thatrequires similar heterogeneity is shown in Figure 3. A computing resource perhaps a futuristicworkstation consists of a familiar UNIX1 processor, a separate processor running a specializedrealtime operating system, a third processor for hardrealtime signal processing running nooperating system, and programmable hardware for truly intensive tasks such as protocol implementations and IO interfaces to custom devices. A unified environment for programming such a1.  UNIX is a trademark of ATT.ControlSubsystemsCommunications Figure 1. Typical structure of a large system.ExternalEventsExternalEventsINTRODUCTIONPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 5 of 34heterogeneous combination of computing resources must support the different design styles thatwould be used for each resource.Ptolemy uses objectoriented software principles to achieve the following goals Agility Support distinct computational models, so that each subsystem can be simulated andprototyped in a manner that is appropriate and natural to that subsystem. Heterogeneity Allow distinct computational models to coexist seamlessly for the purpose ofstudying interactions among subsystems. Figure 2. A packet video connection through an ATM broadband packetnetwork.CellAssemblyCellTransportCellDisassemblyControl setup, routing, flow controlCompressionVideoSourceDecompressionDummyTrafficDisplayUNIX1processorrealtimeprocessorsignalprocessorprogrammablegate arrayinterconnectuserinteractionsoftwarerealtime OSand processeshardrealtimesignal processingcustomized IOinterfaces Figure 3. A heterogeneous hardware and software platform.softwareINTRODUCTION6 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systems Extensibility Support seamless integration of new computational models and allow them tointeroperate with existing models with no changes to Ptolemy or to existing models. Friendliness Use a modern graphical interface with a hierarchical blockdiagram style of representation.In Figure 4, we show a simplified but complete example that combines signal processingwith network simulation, and hence demonstrates the heterogeneity in Ptolemy. In this example,the lower block diagram models a highly simplified packetswitched communication network, inwhich packets randomly traverse one of two paths. The upper path has no delay, while the lower Figure 4. Simulation of the effect of a very simple model of a packet switched network on asinusoid, illustrating a mixture of signal processing and networking in one simulation.Internal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 7 of 34path has random delay. At the receiving end, a queue stores incoming packets until they areneeded by the destination. In the upper left window is a highly simplified signal processing system making use of the network. A sinusoid is generated and packetized, one sample per packet,and launched into the network. At the receiving end, packets are used to reconstruct the sinusoidat the same sample rate. The packets are used in the order of arrival, so the samples of the sinusoidget randomly scrambled, as shown in the lower plot. Realtime constraints are modeled, so ifpackets do not arrive in time, earlier packets are reused. The effect on the spectrum is shown inthe middle plot, and the size of the queue is monitored in the upper plot.In practical applications with similar structure, both the network model and the signal processing will be much more elaborate. For instance, Ptolemy is currently being used to evaluatevideo encoding algorithms for transmission over ATM asynchronous transfer mode networks.3.0 Internal Structure of PtolemyPtolemy relies heavily on the methodology of objectoriented programming OOP. In thissection we describe the essentials of the class hierarchy that defines the Ptolemy kernel.3.1 Blocks and ParticlesThe basic unit of modularity in Ptolemy is the Block1, illustrated in Figure 5. A Blockcontains a module of code the go method that is invoked at runtime, typically examiningdata present at its input Portholes and generating data on its output Portholes. Depending on themodel of computation, however, the functionality of the go method can be very different it mayspawn processes, for example, or synthesize assembly code for a target processor. Its invocation isdirected by a Scheduler another modular object. A Scheduler determines the operational semantics of a network of Blocks. Blocks and Schedulers can be designed by end users, lending generality while encouraging modularity. The hope is that Blocks will be well documented and stored instandard libraries, rendering them modular, reusable software components.1.  When we capitalize a modular element, then it represents an object type. In objectoriented programming, objects encapsulateboth data, the state of the object, and functions operating on that state, called methods.Internal Structure of Ptolemy8 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous SystemsPortHoles provide the standard interface through which Blocks communicate. Some of thekey PortHole methods are shown in Figure 5, such as grabData and sendData, which canbe invoked within the go method. A Scheduler interacts with Blocks through a standard set ofpolymorphic1 methods such as start to initialize the state of the Block, go for runtime execution, and wrapup to conclude the execution. Ptolemy also defines methods for building andediting a network of Blocks, such as the clone for creating another instance of the Block.The userinterface view of the system is an interconnected block diagram. Blocks cancommunicate using streams of Particles. A Particle is a base type for all messages. Simple examples of classes derived from Particle are FloatSample, FixSample, and ComplexSample, all usedin streamoriented domains such as dataflow and discreteevent. A user can derive other messagetypes from the Particle, such as onedimensional and twodimensional data structures, data packets, and control tokens, invisibly to Ptolemy. This use of OOP inheritance2 allows Ptolemy to dealtransparently with many system modeling problems, such as speech, video, and packet data net1.  Polymorphic methods is a term from objectoriented programming that refers to methods applied uniformly across a group ofsimilar objects. Each object substitutes the correct functionality for that object. Polymorphism is a powerful abstraction tool usedextensively in Ptolemy.2.  In objectoriented programming, inheritance refers to the derivation of a new, more functional and specialized, object type byincluding an existing inherited type and adding or replacing states and methods. Figure 5. Block objects in Ptolemy send and receive data encapsulated inParticles to the outside world through Portholes. Buffering andtransport is handled by the Geodesic and garbage collection by thePlasma.PortHole PortHoleBlock  initialize  start  go  wrapup  clonePortHole  initialize  grabData  sendDataPortHole PortHoleGeodesicPlasmaGeodesic  initialize  numInit  setSourcePort  setDestPortParticle  readType  print  operator    cloneParticleBlock BlockInternal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 9 of 34works. The Geodesic class establishes the connection between PortHoles. The Plasma class manages the reclamation of the used Particles so that elaborate garbage collection is not required.Type conversions are performed automatically for the basic types provided with Ptolemy,so that a block that produces integers can be connected with a block that expects real values, forexample. Type conversions may also be defined for userdefined Particles. Blocks can also bedefined to accept ANYTYPE such blocks can route or duplicate Particles without regard to theirtypes. These Blocks manipulate Particles using only methods defined in the base class.3.2 Stars, Galaxies, and the UniverseA conventional way to manage the complexity of a large system is to introduce a hierarchyin the description, as shown in Figure 6. The lowest level atomic objects in Ptolemy are of typeStar, derived from Block. A Star that performs some computation belongs to a domain, asexplained below. The Stars in domain named XXX are of type XXXStar, derived from Star. AGalaxy, also derived from Block, contains other Blocks internally. A Galaxy may contain internally both Galaxies and Stars. A Galaxy may exist only as a descriptive tool, in that a Schedulermay ignore the hierarchy, viewing the entire network of blocks as flat. All our dataflow schedulersdo this to maximize the visible concurrency, getting the effect of nonstrict function invocation.Alternatively, a Scheduler may make use of the hierarchy to minimize scheduling complexity or Figure 6. A complete Ptolemy application a Universe consists of a network ofBlocks. Blocks may be Stars atomic or Galaxies composite. TheXXX prefix symbolizes a particular domain or model of computation.Examples of Derived Classes  class Star Block  class XXXStar Star  class Galaxy Block  class Universe Galaxy, Runnable  class XXXUniverse UniverseXXXStar Galaxy XXXStar XXXStarXXXStarGalaxy XXXStarXXXStarXXXUniverseInternal Structure of Ptolemy10 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsto structure synthesized code in a readable way. A Universe, which contains a complete Ptolemyapplication, is a type of Galaxy. It is multiply derived from Galaxy and class Runnable. The latterclass contains methods for execution of simulation or synthesis of code.3.3 Targets and SchedulersA Target, also derived from Block, controls the execution of an application. In a simulationoriented application, it will typically invoke a Scheduler to manage the order in which Starmethods are invoked. For a synthesisoriented application, it can do much more. It can, for example, synthesize assembly code for a programmable DSP, invoke an assembler, download the codeinto attached hardware, execute the code, and manage the communication between the host andthe attached processor. It can also partition a heterogeneous application among subtargets byinvoking a Scheduler and then invoke Schedulers in the subtargets to handle the detailed synthesis. This is illustrated in Figure 7, where some of the representative methods and members of theTarget class are shown. Targets can have parameters that may be set by the end user.The toplevel Universe object contains a pointer to a dynamically allocated Target. Formost simulation applications, the default Target simply passes its messages on to a Schedulerappropriate for the model of computation being used.Target Block  initialize  setup  run  wrapup  galaxy  scheduler  childrenSchedulerTargetTarget TargetScheduler Scheduler Figure 7. A Target, derived from Block, manages a simulation or synthesisexecution. It can invoke its own Scheduler on a Galaxy, which can inturn invoke Schedulers in subTargets.Internal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 11 of 343.4 Heterogeneity The DomainA Domain in Ptolemy consists of a set of Blocks, Targets, and associated Schedulers thatconform to a common computational model. By computational model we mean the operationalsemantics governing how Blocks interact with one another. A Scheduler will exploit knowledgeof these semantics to order the execution of the Blocks. Two domains are illustrated in Figure 8.Stars and Targets are shown within each domain. The inner Domain designated YYY in Figure8 is an illustration of a subDomain, which implements a more specialized model of computationthan the outer Domain XXX. Hence all its Stars and Targets can also be used with the outerDomain. Schedulers can be associated with more than one Domain, but a Scheduler for a subDomain is not necessarily valid within the outer Domain. The Domain and the mechanism for coexistence of Domains are the primary abstractions that distinguished Ptolemy from otherwisecomparable systems.Some examples of Domains that are currently available or being designed are listedbelow Dynamic dataflow DDF is a datadriven model of computation originally proposed by Dennis 7. Although frequently applied to design parallel architectures, it is also suitable as a programming model 6, and is particularly wellsuited to signal processing that includesasynchronous operations. An equivalent model is embodied in the predecessor system Blosim Figure 8. A Domain XXX consists of a set of Stars, Targets andSchedulers that support a particular model of computation. AsubDomain YYY may support a more specialized model ofcomputation.SchedulerYYYDomainSchedulerSchedulerYYYStarXXXStarYYYStarTargetTargetTargetXXXDomainXXXStarYYYStarInternal Structure of Ptolemy12 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systems2324. In DDF, Stars are enabled by data at their input PortHoles. That data may or may notbe consumed by the Star when it fires, and the Star may or may not produce data on its outputs. More than one Star may be fired at one time if the Target supports this parallelism. Wehave used this domain to experiment with static scheduling of programs with runtime dynamics 9. The DDF Domain does not attempt to model the relative timing relationship of Blockinvocations. Synchronous dataflow SDF 1718 is a subDomain of DDF. SDF Stars consume and generate a static and known number of data tokens on each invocation. Since this is clearly a special case of DDF, any Star or Target that works under the SDF model will also work under theDDF model. However, an SDF Scheduler can take advantage of this static information to construct a schedule that can be used repeatedly. Such a Scheduler will not always work withDDF Stars. SDF is an appropriate model for multirate signal processing systems with rationallyrelated sampling rates throughout 3, and is the model used exclusively in Ptolemyspredecessor system Gabriel 192. The advantages of SDF are ease of programming sincethe availability of data tokens is static and doesnt need to be checked, a greater degree ofsetuptime syntax checking since samplerate inconsistencies are easily detected by the system, runtime efficiency since the ordering of Block invocation is statically determined atsetuptime rather dynamically at runtime, and automatic parallel scheduling 293020. Boolean dataflow BDF is a model intermediate between SDF and DDF, in which a limitedbut practically important set of asynchronous operations analogous to the ifthenelse or casestatement in C is supported, with many if not most of the advantages of SDF 421. This isan experimental domain currently being developed, and will be described in detail in a futurepaper. Discrete event DE is a model in which only changes in system state called events are modeled. This is an asynchronous model like DDF, but unlike DDF incorporates the concept ofglobal time in the system and orders Block invocations properly in time. A completely generalsimulation system could be developed in the DE domain, at the expense of runtime efficiencyand ease and naturalness of programming for many applications like signal processing.Internal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 13 of 34 Message queue MQ is a model similar to DDF but with many more capabilities for dynamically creating and destroying Blocks. The MQ domain is another experimental domain underdevelopment targeted at software control applications, such as telephone switching callprocessing software. An interesting distinction between MQ and many other domains is thatgraphical representations of the applications is probably neither reasonable nor appropriate.In addition to these domains, it is possible to create domains out of previouslyexistingsimulation systems, as has been demonstrated with the Capsim 8 domain incorporating theCapsim signal processing system that is based on Blosim and the Thor domain incorporating theThor hardware timing simulator 32. We are also beginning to design a domain with finitestatemachine semantics.The Domain class by itself makes Ptolemy agile enabling modeling of different types ofsystems in a natural and efficient manner, but we need to be able to mix those descriptions at thesystem level. To accomplish this, Ptolemy allows different Domains to coexist at different levelsof the hierarchy. Within a domain, it is permissible to have Blocks containing foreign domains.At the user interface, a foreign Domain appears to be a property of an internal Galaxy.However, at runtime it is a much different entity. A Galaxy does not have a Scheduler, and may bedestroyed by flattening prior to runtime, while a foreign Domain does have a Scheduler and mustnot be flattened its internal structure does not conform to the external model of computation. Agiven simulation can therefore contain a number of Schedulers, which must be coordinated.3.5 The WormholeThe manner in which different domains coexist is a critical design element of Ptolemy,and will therefore be further elaborated. As illustrated in Figure 9, the toplevel view of a simulation consists of a Universe. This Universe has an associated domain, say XXX, and is a Block oftype XXXUniverse as shown in Figure 6. Internal to that Block is an XXXScheduler and a set ofXXXStars. The description of the Universe may also include Galaxies, but we omit thembecause they may be destroyed by flattening at runtime. The introduction of a subsystem from aforeign domain, say domain YYY, is illustrated in Figure 10. This is accomplished by adding aBlock which appears in the XXXDomain to be an XXXStar, but which is actually a much differInternal Structure of Ptolemy14 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsent object internally because it contains a YYYScheduler and a set of YYYStars. We call this special object an XXXWormhole. One way to think of a Wormhole is as a Block which appearsexternally to be a Star it obeys the operational semantics of the external domain and appears to beatomic to the external domain, but internally consists of an entire foreign Universe Scheduler fora foreign domain and Stars for that domain. A Wormhole can be introduced into the XXXdomain without any need for the XXXScheduler or other XXXStars to have knowledge of thesemantics of domain YYY.It should be clarified that although most existing domains in Ptolemy have the internalstructure of Scheduler plus Stars, and are viewed at the user interface as an interconnected blockXXXStarsXXXUniverseXXXScheduler Figure 9. The Universe consists of a domain, and at runtime internal Starswhich conform to the operational semantics of that domainsScheduler.XXXSchedulerYYYSchedulerYYYStarsXXXStarsXXXWormholeXXXUniverse Figure 10. A new domain YYY is introduced by adding a Wormhole to theUniverse.Internal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 15 of 34diagram, this assumption is not built into Ptolemy. For purposes of interoperability, the only relevant view of a domain is the external interface of a Wormhole, and as long as it conforms to thisexternal view it can have any internal structure whatsoever just as a Star can have any internalcode. For example, one could have domains where every object talks to every other object, andan interconnected block diagram makes no sense.Wormhole objects also contain Target pointers the Target by default may be the same asthat for the parent Universe, but can be different. This facility can be used to execute part of asimulation on a workstation, while running another part of the simulation on a DSP board withcode generated and downloaded by Ptolemy. In this case, the Target object in the Wormholeknows how to download and execute code on the DSP board.3.6 The EventHorizonThe key to the support of heterogeneity in Ptolemy is the interoperability of differentdomains at runtime. In turn, the key to this interoperability is the interface between the internalstructure of a Wormhole and its external environment. This interface is called the EventHorizon,and is illustrated in Figure 11. A universal EventHorizon is shared by all domains, so that eachdomain only needs to provide an interface to this EventHorizon. Hence we avoid having  interfaces for  Domains. Figure 11. The universal EventHorizon provides an interface between theexternal and internal domains.XXXUniverseXXXWormholeXXXDomainYYYDomainYYYtoUniversalXXXfromUniversalYYYfromUniversalXXXtoUniversalEventHorizonSchedulerSchedulerParticlesParticlesN2NInternal Structure of Ptolemy16 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous SystemsThere are two types of interactions that occur at the EventHorizon as illustrated in Figure11. The first is the conversion of Particles passing through the EventHorizon. For example, insome domains each Particle has an associated timestamp, and in other domains it does not, andhence there is the function of adding or deleting timestamps. The second interaction is the coordination of the Schedulers associated with the inside and outside domains. We will now describeboth interactions in more detail.3.6.1 Particle Conversion at the EventHorizonConversion between domainspecific representations of a Particle is accomplished byobjects of class ToEventHorizon and FromEventHorizon, derived from EventHorizon, derived inturn from Porthole. For each specific Domain XXX, we define XXXtoUniversal and XXXfromUniversal. Since these are ultimately derived from class XXXPorthole, the XXXWormhole looksjust like a XXXStar to XXX Domain. Particles are read from the XXXtoUniversal, transferred tothe YYYfromUniversal, and sent to the inside YYY domain.Some Domains have a notion of simulated time, and some do not. In order for the eventhorizon to work with both, when a Particle passes through the EventHorizon, it is always associated with a time stamp. A domain therefore need not know with which domain it is interacting.See the next subsection for the detailed discussion of timing relationship between domains.EventHorizons may have other domainspecific responsibilities. One example can befound in SDFfromUniversal class. Suppose that the inner domain is SDF, the outer domain is DE,and the DEWormhole has more than one input. The DEWormhole is executed when any input hasnew data an event. However, the inner SDF domain requires that all input data be availablebefore execution. To resolve this conflict, the DEWormhole checks all SDFfromUniversal EventHorizons to see if they have enough data before turning control over to the inner SDFScheduler.Thus, the SDFfromUniversal synchronizes the input data, enforcing the model of computationassumed in the inside domain.In some domains, Particle types are very restricted. For example, the Thor domain usedfor timing simulations of hardware allows only bits. Particle type conversion, however, is not thetask of the EventHorizon. The Particle type of an EventHorizon is inherited from that of the PortInternal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 17 of 34Hole connected to it. Particle type conversion between two different types of Particles is performed automatically by the type conversion methods defined in the Particle class if both arebuiltin types such as integer, float, and complex. Otherwise, the type conversion should be managed explicitly by inserting special Stars Packetize star, IntToBits Star, etc..3.6.2 Scheduler Coordination Across the EventHorizonViewed from the EventHorizon, every Wormhole contains a Target which in turn containsa Scheduler, and every Scheduler has a set of polymorphic methods for the purposes of executionof the domain and the coordination of Schedulers on both sides of an EventHorizon. Some ofthese methods are illustrated in Figure 12. For purposes of executing a domain, the setupmethod does whatever is appropriate before execution of Blocks in the domain, for example thestatic scheduling of Blocks in the SDF domain based on the interconnection topology and relativesampling rates. The run method then executes the Blocks by calling their run methods in turn.For purposes of coordinating two or more Schedulers, each Ptolemy Scheduler has anadditional concept of a StopTime. That is, run is allowed to execute the Blocks in the domainonly up to the StopTime. One method of a Scheduler, setStopTime, allows the StopTime to beset externally.Using these methods, multiple Schedulers can be made to behave logically as a singleScheduler. Coordination of multiple DE Schedulers has been addressed in the area of distributedsimulation of discrete event systems, for example in conservative scheduling 2528, but mayintroduce artificial deadlocks because a notion of global time is not available to all processors. InPtolemy, Schedulers are hierarchically nested, making it easy to maintain a global time. MultipleSchedulers behave logically as a single Scheduler and there is no artificial deadlock. To see howthis is achieved, assume for the moment that both the inside and outside Schedulers are possiblySchedulerScheduler setuprunsetStopTimeresetStopTime Figure 12. An illustration of some of the polymorphic messages of typeScheduler that support the coordination of two Schedulers.Internal Structure of Ptolemy18 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsdifferent DE Schedulers. The basic structure of a DE Scheduler is shown in Figure 13. It incorporates the concept of a CurrentTime, and is parameterized by a StopTime, which is the maximumallowed value of CurrentTime before execution is suspended. The EventQueue stores the unprocessed events, each corresponding to an action typically arrival of a particular Particle at a particular PortHole of a particular Block with a TimeStamp specifying the time of that action. TheEventQueue sorts the set of events by TimeStamp. In this and subsequent figures we assume thatthe earliest event is on the left and the latest event is on the right.The coordination of Schedulers across the EventHorizon is illustrated in Figure 14. Suppose the oldest earliest event in the EventQueue of the outer domain is an event at a WormholeEventHorizon. The outerdomain Scheduler calls the go method of the WormHole it treats itlike an ordinary star. The WormHole obtains the CurrentTime of the outer domain which isavailable to any Star and sets the StopTime of its Scheduler to equal that time. It then invokes therun method of its Target, which in turn invokes the run method of its Scheduler. By setting theinner StopTime equal to the outer CurrentTime, the WormHole ensures that the inner domain cannot get ahead of the outer domain in time. The CurrentTime of the outer domain can safely getahead of the CurrentTime of the inner domain, because the outer domain supplies all events to theinner domain. Figure 13. A discreteevent style of Scheduler keeps a sortedEventQueue and is parameterized by a StopTime.DESchedulerDEDomainTimeStampActionearliesteventEventQueueStopTime CurrentTimeInternal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 19 of 34Typically, the innerdomain Scheduler suspends execution at the StopTime, leavingunprocessed the next event on its EventQueue. To ensure that it has an opportunity to execute thatevent at the proper time, before it returns control to the outerdomain Scheduler, the innerdomainadds an event to the outerdomain EventQueue. Again, this is an action available to any Star. Thisselfscheduling event asks the outer domain to invoke the go method of the Wormhole at thespecified future time, and is the critical feature distinguishing Ptolemy from conservative scheduling.The above interaction works for any pair of DE Schedulers that are based on event queues.Distinct DE Schedulers are of interest in Ptolemy. For one thing, we want to import preexistingsimulation environments to Ptolemy as domains without the need to replace their Schedulers. Foranother, different specializations of DE scheduling are of interest for example, those that associate delay with blocks enabling data dependency and those that associate delay with arcs a simpler model appropriate for hardware timing simulation. In addition, many Ptolemy Schedulersare not recognizable as DE, although they are required to present the same interface at the EventHorizon. Generally we can divide Schedulers into two categories timed and untimed. TimedSchedulers keep track of time for each action in the domain, either explicitly as in the DE exam Figure 14. An illustration of conservative scheduling for coordinatingtwo discreteevent Schedulers.DEWormholeearliesteventEventQueueStopTimeCurrentTimeDEWormholeselfschedulingeventInternal Structure of Ptolemy20 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsple or implicitly as in the SDF Scheduler, where Particles do not have associated TimeStamps,but nevertheless the Scheduler can associate a time with each new Particle implicitly because ithas the sampling rates or equivalent information. Untimed Schedulers do not keep track of time.A Wormhole encapsulating an untimed domain must still model time from an external perspectivein case the external domain is timed. However, such a Wormhole is considered to be instantaneous that is, it executes in zero time by associating the same TimeStamp with each outgoingParticle as the TimeStamp of the most recent input. If this is too coarse a model for any particularsubsystem, then a timeddomain model can be substituted.3.6.3 Inheritance Structure of BlocksWe are now in a position to understand the internal design of Blocks in Ptolemy. A multiple inheritance diagram1 is shown in Figure 15.A Block is a base class that includes the data structures of all Blocks, such as a list ofStates data structure elements observable from outside a Block and PortHoles. It also has threekey methods invoked by the Scheduler initialize, start, and wrapup, invoked before executing the Block, at the start of an execution, and at the end of an execution. Runnable is a class thatcontains a Target, which in turn contains a Scheduler and provides an interface to that Schedulersuch as run and setStopTime.1. Multiple inheritance simply means that a class assumes the characteristics of two or more baseclasses.Block RunnableGalaxyUniverseStarWormholeXXXStarXXXWormholeXXXUniverse Figure 15. Inheritance diagram for Blocks within domain XXX.Internal Structure of PtolemyPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 21 of 34From these base types, we define the particular types of Blocks. A Galaxy does notinclude a Scheduler, but simply includes a list of internal Blocks with both internal and externalconnections to those Blocks PortHoles. A Star is a Block that includes the additional method goexecute the internal code. A Universe is a Block that has all the characteristics of a Galaxyinternally composed of interconnected Blocks but also includes a Target and hence is a Runnable. A Wormhole is simply a Runnable has an internal Target that includes an internal Galaxy aswell in this sense it is very similar to a Universe1.For a specific domain XXX, there is an XXXUniverse which is a Universe with a compatible Target that contains an XXXScheduler. An XXXStar is a Star that obeys the particular operational semantics of domain XXX that is, it obeys specific rules on how it generates and consumesParticles at its PortHoles. Finally, the domain has an XXXWormhole derived from XXXStar.Thus the XXXWormhole provides all the methods of an XXXStar, but internally it is has a Galaxyand a Scheduler, unlike XXXStars. Any type of Scheduler and Blocks can be inside the Wormhole. Neither the XXX domain nor the implementation of the XXXWormhole needs to knowabout the inner domain.An XXXWormhole is externally indistinguishable from an XXXStar, and hence can beinserted into any XXX domain. How this exploits polymorphism is shown in Figure 16. The Figure shows two methods, start, which is characteristic of all Blocks including Stars, and go,1.  The XXXWormhole is not derived from Galaxy, but rather contains a Galaxy because it does not have the external interface ofa Galaxy while it does have the external interface of an XXXStar.Starstart go  XXXStarstart initializego processXXXWormholestart make schedulego targetsetCurrentTimearrivalTime run Figure 16. An illustration of how polymorhphism allows the XXXStar andXXXWormhole to have the same external interface, even though theyare implemented quite differently internally.Internal Structure of Ptolemy22 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemswhich is characteristic of all Stars. The method start is called each time a simulation is started orrestarted, and in the case of an XXXStar this method typically initializes the internal data structures of the XXXStar as defined by the programmer of that XXXStar. In the case of an XXXWormhole, this method does something quite different namely, it calls a polymorphic Schedulermethod that initializes the schedule. Similarly, the method go executes userprovided code in thecase of any XXXStar, but for an XXXWormhole calls the run method provided by any Runnable, which executes the schedule and in turn executes the Stars inside the Wormhole in the properorder through their respective go methods.In this manner, polymorphism allows us to achieve extensibility. Any new domain can beadded without any modifications to existing domains or to the kernel of Ptolemy itself, and thatnew domain will be interoperable with the old domains.3.7 Code GenerationThe basic idea of code generation in Ptolemy is simple. The go method of a code generation Star adds ASCII text to a data structure in the Target. The Scheduler, therefore, controls thesequence of generated code. The Target collects the code and supervises the compilation and execution, if any. Any generic optimization capabilities can be put into the base class of the Target orthe code generation stars.While a domain is specific to the computational model used, for code synthesis it is alsospecific to the type of language generated. Hence, a C code generation domain following SDFsemantics is different from an assembly code generation domain following SDF semantics. Thisis because the libraries of Stars and Targets for the two are quite distinct. The Target is specific tothe hardware that will run the code. A given language, particularly a generic language such as C,may run on many targets code generation functions are therefore cleanly divided between theDomain and the Target.Practical DetailsPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 23 of 344.0 Practical DetailsPtolemy has been coded in C, and successfully compiled using both commercialCfrontbased and freely redistributable GNU compilers. The development used Sun3 andSun4 Sparc platforms, and Ptolemy has been ported to the DECstation. Efforts are underway toport it to an HP platform as well. The documentation for Ptolemy is extensive 1.4.1 The Graphical User InterfaceThe Ptolemy interactive graphical interface pigi is a design editor based on tools fromthe Berkeley CAD framework the Oct database and the Vem graphical editor 12. Using pigi,Ptolemy applications are constructed graphically, by interconnecting icons. A special Ptolemyclass, InterpGalaxy a derived type of Galaxy, is used to dynamically construct simulations basedon commands from the graphical interface. Incremental linking is supported, permitting additional stars to be defined, linked into the running pigi executable, and instantiated in the simulation.The graphical interface runs as two processes one process is the Vem graphic editor thesecond, called pigiRpc, contains the Ptolemy kernel and the portion of the graphical interface thatknows about Ptolemy. The Unix RPC protocol is used for communication between the two processes.The graphical interface is by no means integral to Ptolemy. Indeed, we do not believe thatany single, homogeneous graphical interface will manage all Domains. Two separate textual interfaces, one with a Lisplike syntax, and a second based on an embedded interpreter, Tcl 26, havebeen developed. As with the graphical interface, the textbased interfaces also communicate withthe InterpGalaxy class to build and run simulations.4.2 StatesPtolemy provides a State class, together with typespecific subclasses IntState, FloatState,StringState, IntArrayState, etc. for use as parameters, observable variables, and as memory forSome Representative Applications24 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemscode generation applications. Because State objects are visible from the user interface, they canbe used to monitor and control the simulation, or to collect statistics.Every State type has an initialvalue string, which may be an expression that refers toother states defined at higher levels initializers for states in a star may refer to states in the parentgalaxy. Initial values of states are referred to as parameters by the user interface. The hierarchicalnature of states, and the fairly general expressions permitted, make it easy to define parameterizable Galaxy objects.4.3 Star Preprocessor LanguageThe Ptolemy preprocessor a schema compiler has been developed to make it easier towrite and document Star and Galaxy class definitions for use with Ptolemy. Instead of writing allthe initialization code required for a Ptolemy star which contains quite a bit of standard boilerplate, the user can concentrate on writing the action code for a star and let the preprocessor generate the standard initialization code for PortHoles, States, etc. The preprocessor also generatesdocumentation in a standard format for inclusion in the manual.5.0 Some Representative ApplicationsSeveral applications of Ptolemy that have been pursued will now be described. One purpose of this will be to illustrate how the heterogenous aspect of Ptolemy manifests itself to theuser, and another purpose will be to illustrate how the use of OOP at the usermodeling level canresult in much more flexible models.5.1 Broadband NetworkingIn the introduction, the use of Ptolemy for simulation of a broadband packet network withassociated signal processing is mentioned. Here we give a bit more detail. A block diagram ofsuch a simulation is shown in Figure 17. At the top Universe level, the cellrelay network connects a set of terminals. The DE domain is used to model only nonempty cells travelling betweenterminal and network, each cell marked with a TimeStamp. Internally the terminals have a comSome Representative ApplicationsPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 25 of 34plicated structure control, signal processing for video compression, etc., but let us concentrateon the network. Internally it consists of a signalling entity programmed in the MQ domain and aset of interconnected ATM switches. The internal simulation of each ATM switch is in the SDFdomain so that all cells are modelled, including empty cells because the most convenient modelis as a synchronous digital machine especially if we anticipate moving down to logic and timinghardwaremodeling levels. Within the switch there is another callprocessing entity in the MQdomain for control of this switch, and a shuffleexchange type of interconnected 2x2 switches.Finally, those switches consist of a 2x2 switching matrix plus associated routing tables.Most interesting is the interconnection of foreign domains. Internal to Ptolemy this is handled by the Wormhole, but it is also an issue at the level of user modeling. For example, cells thatarrive from the DE domain at a switch must be augmented with empty cells internal to the switchCellRelayNetworkTerminalsSignalingATMCallprocessing MQTables2x2 SwitchSDFSDFDEDEMQATMATMATM Figure 17. An ATM cellrelay simulation in Ptolemy, illustrating the hierarchicaldescription and mixture of domains. In each case the shaded blockis shown in internal detail.Some Representative Applications26 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsto fill out an isochronous constant rate stream of cells, because the switch is modeled in the SDFdomain. This requires a cell interpolator driven by an isochronous clock at the interfaces to theswitch within the DE domain, so that cells passing the EventHorizon into the SDF domain haveuniformly spaced TimeStamps. Similarly, the communication between the callprocessing in theMQ domain within the switch and the routing tables within the switch in the SDF domain requiresan interpolator. In this case the MQ domain is untimed, and operates instantaneously from a timeddomains perspective. When a messages arrives from the networklevel call processing, it passesthrough the DE domain and therefore has appended TimeStamps. The switchlevel call processingthen generates messages in response to update the routing tables, and these messages have thesame TimeStamp since the MQ domain is untimed, the callprocessing operates instantaneously.Before these messages can be sent, however, they must be interpolated to an isochronous messagestream, because the routine tables are in the SDF domain.This example illustrates that Ptolemy does not automatically solve all problems related tointerconnecting domains rather, there is often work to be done at the user modeling level. Often,however, this work is not an artifact of the modeling technique, but is a functional requirement inthe system being simulated. For example, the interpolation of messages from the call processingarriving at the routing tables, a synchronous digital system, is a functional requirement of the system being modeled.5.2 Signal ProcessingA wide variety of signal processing applications have been developed using Ptolemy,including several adaptive filtering applications, power spectrum estimation, several parametricand waveform coding techniques based on linear prediction, communication channel modeling,digital communication receivers, beamforming, digital filter design, chaos simulations, phaselocked loops, image coding, and music synthesis. Many of these applications are distributed withthe Ptolemy code as demonstrations.Most signal processing algorithms are conveniently defined within the synchronous dataflow model of computation. Hence, for algorithm development and simulation, there is little needfor heterogeneity. However, turning an algorithm into a product involves both realtime prototypSome Representative ApplicationsPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 27 of 34ing and realtime control. For the former, we have been concentrating on synthesis of code forparallel programmable DSP processors.Ptolemy is capable of automatically partitioning, scheduling, and generating DSP assembly language for a multiprocessor DSP system 2930. Currently, it is required that the problemfit the synchronous dataflow model a future version will exploit heterogeneity to remove thatrestriction by mixing Schedulers that operate at codegeneration time with Schedulers that synthesize runtime code 9. For realtime control, using the Wormhole concept, part of an applicationcan be run on a DSP board while the remainder of an application is executed on a host microprocessor.At present, Ptolemy can generate C code, Motorola 56000 and 96000 assembly code, andassembly code for the Sproc multiprocessor DSP from Star Semiconductor. Code generation forother processors is planned.5.3 HardwareSoftware CodesignMost electronic systems mix custom circuit designs with programmable commodity parts.Ptolemy supports such designs as a unit, since using the various domains described above, allparts of the system can be modeled. For example, the Thor domain can be combined with a codegeneration domain to design boards that mix custom hardware with programmable DSPs. Sincethe hardware and software are both modeled within the same software framework, a designer caneasily explore tradeoffs between hardware and software implementations of various functions.An example of such a design is shown in Figure 18 15. The top window shows the toplevel of an algorithm that simulates the impairments of a telephone channel. This algorithm isfairly complicated, including linear and nonlinear distortion, frequency offset, phase jitter, andadditive Gaussian noise. The design is built in a code generation domain compatible with the SDFmodel of computation. The bottom window shows a hardware design in the Thor domain containing two programmable DSPs communicating through a dual ported shared memory. This hardware might be used to implement the telephone channel simulator for productionline testing ofvoiceband data modems.Some Representative Applications28 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous SystemsAlgorithm DescriptionTarget HardwarePartition, Schedule and Generate DSP Assembly CodeThorDSP 56001 CODE GENERATOR Figure 18. A hardware design bottom containing programmable DSPs can be developedtogether with the software top that will run on the DSPs. This Figure shows the toplevel only of a telephone channel simulation algorithm top window being mappedonto a board design with two Motorola DSP56001 DSPs.Some Representative ApplicationsPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 29 of 34The design shown in Figure 18 is one of many that could accomplish the stated objectives.Using Ptolemy, the entire design, ranging from algorithm development to circuit design, can becarried out within a unified environment. This enables exploration of many design alternativesbefore resources are committed to hardware prototyping.The hardwaresoftware codesign problem is becoming increasingly important in largeand even small system design. One of the key advantages of Ptolemy is the ability to freely mixbehavioral, hardware, and software entities, modeling each in a natural way. In fact, in manyinstances the actual production software can be developed in an appropriate Ptolemy domain, andfunctionally tested in combination with its associated hardware subsystems.5.4 Source and Link ModelingA final example will illustrate the value of OOP abstractions in obtaining flexible modelsin Ptolemy, using the simple example of the modeling of sources and links in the communicationsnetwork. Consider the simple situation modeled in Figure 19. We would like to be able to freelyintermix source and link models, regardless of the nature of the source or link. For example, thesource could generate data packets or speech samples or video frames, and the link could consistof a simple biterror model or a full physicallayer simulation. Using polymorphism in the Particlecan achieve this goal by defining in the Particle class methods convertToBits and convertFromBits which generate a bitstring representation of any Particle. The link model then accepts Particles, and employs convertToBits to generate a bit string, apply the link model to that bit string,and use Particle convertFromBits to convert back to Particles at the output. There are a numberof issues in actually implementing this, but this oversimplification does illustrate the value ofOOP at the usermodeling level.Source LinkParticles Particles Figure 19. A simple network modeling problem.CONCLUSIONS30 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systems6.0 CONCLUSIONSPtolemy has been used internally in Berkeley for approximately two years for a growingnumber of simulation efforts, such as signal processing, electric power network simulation, andwireless and broadband network simulation. It has also been used successfully for instructionalpurposes in one graduate and one undergraduate course. It has been distributed externally forabout one year, and is now used in a growing community of academic and industrial organizations. Aside from the usual problems of installation and environment compatibility, these effortscan generally be characterized as very successful. The ability of Ptolemy to simulate, and to alesser extent rapidly prototype heterogeneous systems has been demonstrated by a number ofapplications.In terms of useful user models Stars and Galaxies, the most fullydeveloped domain isSDF, with many models for signal processing and data communications. Currently a similar set ofmodels is being developed in the DE domain for networking packet, multiple access, and wireless simulations. New domains are also under development. For example, a highlevel circuitsynthesis domain based on synthesis work at Berkeley is planned.There are also recognized deficiencies in the kernel of Ptolemy, and enhancements areplanned. One deficiency is the relatively simplistic manner in which a simulation is controlledfrom the GUI at runtime. Another deficiency is the GUI itself, which unlike the remainder ofPtolemy is not objectoriented. An OOP GUI design would encapsulate the interface to eachdomain within that domain itself, allowing graphical interfaces to be customized for a domain.Some of the extended capabilities of Ptolemy can be achieved in other ways, and it is useful to compare them. For example, the generality of Ptolemy could be achieved by a single discreteevent domain, which is itself completely general as a modelling tool. There are twodisadvantages The discreteevent modeling of certain subsystems is unnatural, and will likely be resisted bydesigners. Examples include multirate signal processing where associating a time stamp withACKNOWLEDGEMENTSPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 31 of 34each sample is unnecessary and awkward and control software domains where not only is itunnatural, but could not be considered for production software. Discreteevent modeling is significantly less efficient at runtime for some subsystems theaforementioned included. This needs, however, to be balanced by the additional overhead ofEventHorizon conversion in Ptolemy.CAD frameworks allow design databases to be transferred from one tool to another.Unlike Ptolemy they are focused on applying different toolkits simulation, routing, logic minimization, etc. to a common design. Such frameworks do not address the heterogeneous subsystemproblem directly for example do not address control software. Further, frameworks typicallywork through interprocess communication or file formats, whereas Ptolemy performs the simulation in a common virtual address space advantageous for efficiency in large simulations. Withrespect to CAD frameworks, Ptolemy can be considered to be one tool.The appropriate use of Ptolemy is as a basic framework for simulations as well as prototyping tools. It can be used is a diversity of design groups focused on different aspects of a largesystem design, where each group can tailor a domain or small set of domains to their need and liking. The major advantage is that the efforts of the different groups can readily be merged for thepurpose of checking interoperability. Also, different details of modeling can be used for each subsystem another form of heterogeneity a high level and rapidly executing model for routine usein simulation of other subsystems, down to a very detailed model of every subsystem and veryslow execution for final verification of the design. This is typically not done today.With the increasing complexity of systems, the goal should be a design that is right fromthe start. Ptolemy is a tool that can support that rigorous design style.7.0 ACKNOWLEDGEMENTSWhile this paper emphasizes the internal design of the Ptolemy kernel, a number of ourcolleagues have contributed to Ptolemy and to the modeling in Ptolemy. The broader Ptolemyproject currently includes more than twenty students and three fulltimeequivalent staff memREFERENCES32 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systemsbers. Many of these people have made significant contributions to the ideas described in thispaper. Ichiro Kuroda contributed extensively to the early design of the State processor and interpreter. Edwin Goei is the principle architect of the GUI, with WanTeh Chang contributing somerefinements. The OCTVEM group at Berkeley has been most cooperative in responding to ourrequests for enhancements to that system.The applications mentioned here have been pursued by other colleagues. Alan Lao, WanTeh Chang, John Loh, and Philip Bitar have worked on networking models. Asawaree Kalavadeis working on hardwaresoftware codesign and Tom Parks is working on embedded microcontrollers. Jose Pino is working on assembly code generation. A number of other colleagues areworking on other applications.The Ptolemy project has been supported by the Defense Advanced Projects ResearchAgency, the Semiconductor Research Corporation through its Berkeley Center of Excellence inCADIC Grant 92DC008, the National Science Foundation, the State of California MICROprogram, Bell Northern Research, Comdisco Systems, Dolby Labs, Hitachi, Hughes NetworkSystems, Motorola, NEC, Philips, Rockwell, Sony, Star Semiconductor, and US West.8.0 REFERENCES1 The Almagest Manual for Ptolemy Version 0.3.1, Department of EECS, University of California, Berkeley, CA94720, USA, January, 1992.2 J. Bier, E. Goei, W. Ho, P. Lapsley, M. OReilly, G. Sih and E.A. Lee, Gabriel A Design Environment forDSP, IEEE Micro Magazine, October 1990, Vol. 10, No. 5, pp. 2845.3 J. Buck, S. Ha, E. A. Lee, and D. G. Messerschmitt, Multirate Signal Processing in Ptolemy, Proc. of the Int.Conf. on Acoustics, Speech, and Signal Processing, Toronto, Canada, April, 1991.4 J. Buck and E. A. Lee, The Token Flow Model, presented at Data Flow Workshop, Hamilton Island, Australia,May, 1992.5 N. Carriero and D. Gelernter, Linda in Context, Comm. of the ACM, Vol. 32, No. 4, pp. 444458, April 1989.6 A. L. Davis and R. M. Keller, Data Flow Program Graphs, IEEE Computer, Vol 15, No. 2, February 1982.7 J. B. Dennis, Data Flow Supercomputers, IEEE Computer, Vol 13, No. 11, November, 1980.8 L. James Faber, Capsim, ECE Dept. North Carolina State University, Raleigh, NC 276959 Soonhoi Ha and E.A. Lee, CompileTime Scheduling and Assignment of Dataflow Program Graphs with DataDependent Iteration, IEEE Transactions on Computers, November, 1991.REFERENCESPtolemy A Framework for Simulating and Prototyping Heterogeneous Systems 33 of 3410 D. Harel, Statecharts A Visual Formalism for Complex Systems, Sci. Comput. Program., vol 8, pp. 231274,1987.11 D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. ShtullTrauring, M. Trakhtenbrot,STATEMATE A Working Environment for the Development of Complex Reactive Systems, IEEE Tr. onSoftware Engineering, Vol. 16, No. 4, April 1990.12 D. S. Harrison, P. Moore, R. Spickelmier, A. R. Newton, Data Management and Graphics Editing in the Berkeley Design Environment, Proc. of the IEEE Int. Conf. on ComputerAided Design, November 1986.13 IEEE Standard VHDL Language Reference Manual, IEEE STD 10761987, The IEEE, Inc., 345 East 47th St.,New York, NY, USA, 1987.14 R. Jagannathan and A.A. Faustini, The GLU Programming Language, Technical Report SRICSL9011,Computer Science Laboratory, SRI International, Menlo Park, California 94025, USA, November, 1990.15 A. Kalavade, HardwareSoftware Codesign Using Ptolemy, MS Report, Electronics Research Laboratory,University of California, Berkeley, CA 94720, December, 1991.16 S. Y. Kung, VLSI Array Processors, PrenticeHall, Englewood Cliffs, New Jersey, 1988.17 E. A. Lee and D. G. Messerschmitt, Static Scheduling of Synchronous Data Flow Programs for Digital SignalProcessing IEEE Transactions on Computers, January, 1987.18 E. A. Lee and D. G. Messerschmitt, Synchronous Data Flow IEEE Proceedings, September, 1987.19 E. A. Lee, W.H. Ho, E. Goei, J. Bier, and S. Bhattacharyya, Gabriel A Design Environment for DSP, IEEETrans. on ASSP, November, 1989.20 E. A. Lee and J. C. Bier, Architectures for Statically Scheduled Dataflow, reprinted in Parallel Algorithmsand Architectures for DSP Applications, ed. M. A. Bayoumi, Kluwer Academic Pub., 1991.21 E. A. Lee, Consistency in Dataflow Graphs, IEEE Transactions on Parallel and Distributed Systems, Vol. 2,No. 2, April 1991.22 E. A. Lee, A Design Lab for Statistical Signal Processing, Proceedings of ICASSP, San Francisco, March,1992.23 D. G. Messerschmitt, A Tool for Structured Functional Simulation, IEEE J. on Selected Areas in Communications, Vol. SAC2, No. 1, January 1984.24 D. G. Messerschmitt, Structured Interconnection of Signal Processing Programs, Proc. of Globecom, Atlanta,Georgia, 1984.25 J.Misra, Distributed DiscreteEvent Simulation, Computing Surveys, Vol. 18, No. 1, Nov. 1985.26 J. K. Ousterhout, Tcl An Embeddable Command Language, 1990 Winter USENIX Proceedings, 1990.27 J. L. Peterson, Petri Net Theory and the Modeling of Systems, PrenticeHall, Englewood Cliffs, New Jersey,1981.28 R. Righter, J. C. Walrand, Distributed Simulation of Discrete Event Systems, IEEE Proceedings, Vol. 77, No.1, pp. 99113, January 1989.29 G.C. Sih, E.A. Lee, A CompileTime Scheduling Heuristic for InterconnectionConstrained HeterogeneousProcessor Architectures, to appear, IEEE Trans. on Parallel and Distributed Systems, 1992.30 G. C. Sih and E. A. Lee, Declustering A New Multiprocessor Scheduling Technique, to appear in IEEETrans. on Parallel and Distributed Systems, 1992.REFERENCES34 of 34 Ptolemy A Framework for Simulating and Prototyping Heterogeneous Systems31 P. D. Stotts, The PFG Language Visual Programming for Concurrent Computing, Proc. Int. Conf. on ParallelProgramming, Vol. 2, pp. 7279, 1988.32 Thor Tutorial, VLSICAD Group, Stanford University, 1986.33 G. S. Whitcomb and A. R. Newton, DataFlowEvent Graphs, Memorandum No. UCBERL M9224, Electronics Research Lab, University of California, Berkeley, CA 94720, USA, March 4, 1992.
