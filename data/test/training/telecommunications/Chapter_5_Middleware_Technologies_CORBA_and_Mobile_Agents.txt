Chapter 5Middleware Technologies CORBA and Mobile AgentsPaolo BellavistaDip. Elettronica, Informatica e Sistemistica, Universit di BolognaViale Risorgimento, 2  40136 Bologna  ITALYEmail pbellavistadeis.unibo.itThomas MagedanzIKV GmbHBernburger Str. 2425  D10963 Berlin  GermanyEmail magedanzikv.deAbstractThe design, implementation and provision of services in the Internet scenario are forcing both thetraditional area of clientserver distributed systems and the emerging sector of agent technologytowards the definition of a common distributed middleware, i.e., a set of basic facilities that can beubiquitously accessed by any distributed component as an integrated part of the enhancedcommunication infrastructure. This middleware should not only be the basis where designers startfor the realization and deployment of their services, but also be flexible enough to permit the easyand rapid extension of the common infrastructure to accommodate evolving systemservicerequirements and expectations of final users.Among the technologies for middleware implementation, the chapter describes the stateoftheartof two approaches the Common Object Request Broker Architecture CORBA technology and theMobile Agent MA one, which are different from several points of view interoperability andlocation transparency vs. mobility and location awareness. However, in contrast to using themseparately, the chapter claims that an integration of both middleware technologies represents themost promising solution to achieve the maximum flexibility in the implementation of an openservice infrastructure. In this context CORBAbased MA platforms demarcate an importantevolution step into the direction of mobile and interoperable object systems, on which Internetservices could be realized through dynamically distributed and reusable objectbased components.1 Middleware Technologies for Open and Global Distributed SystemsIn the last years, the widespread diffusion of Internet technologies has changed the way of thinkingabout service provision. The availability of a global communication infrastructure and its ubiquitousaccessibility suggest to implement services as the result of interworking resources and servicecomponents that are geographically distributed and intrinsically heterogeneous due to the opennessof the Internet scenario. Whereas the standardization of communication protocols has made possibleto consider the Internet as a global distributed system, its extensive usage for the implementationand provision of distributed services demands the additional availability of basic common facilities,provided at the infrastructure level, to simplify the interworking and coordination betweendistributed components citeBolliger. For instance, any Internet service implemented in terms ofcooperating components needs a naming infrastructure to simplify the dynamic identification andlocation of required entities, even based on a partial knowledge of searched resources e.g., byknowing their functionality but not their interface. Naming is probably the most evident example ofa generalinterest facility for distributed systems single applications that implement their proper ad2hoc naming service not only force their designers to a considerable implementation effort but, mostimportant of all, lead to competing and incompatible solutions that are in contrast with the reuse andinteroperability principles emerging in the Internet environment.At the same time, the diffusion of agent technologies has further stimulated the rethinking ofsoftware implementation in terms of coordinated groups of autonomous components. While firstresearch activities obviously aimed at the definition of models, design principles and methodologiesfor agents, as the focus has moved to the implementation of agent systems and agentbased complexapplications, one of the main objectives is becoming the identification and provision of a commoninfrastructure of basic services. This infrastructure should provide application designers with a wideset of horizontal generalpurpose facilities, possibly designed according to a layered architecture,to simplify the rapid prototyping of agentbased distributed services and to support theirdeployment and execution at runtime citeBell00.In short, the Internet is forcing both the traditional area of ClientServer CS distributedsystems and the emerging sector of agent technology towards the definition of a common set ofbasic facilities that can be ubiquitously accessed by any distributed component as an integrated partof the communication infrastructure. These facilities should not only be the basis where designersleave from when realizing and deploying their applications, but also should be flexible enough topermit to easily extend the infrastructure in order to accommodate evolving systemservicerequirements and expectations of final users. This kind of infrastructure is the current vision of whatis traditionally known as middleware.While there is a general agreement on the necessity of providing middleware solutions forInternet services, researchers hardly agree when they have to define exactly what middleware is,which facilities and services are part of it, and which ones have to be considered either at a lowerlayer as components of the network infrastructure or at a higher one as applicationspecificcomponents. In fact, the concept of middleware tends to depend on the subjective perspective ofthose trying to define it. It is even dependent on when the question is asked, since the middleware ofyesterday e.g., Domain Name Service, Public Key Infrastructure and Event Services may becomethe fundamental network infrastructure of tomorrow. Final users and programmers usually seeeverything below the Application Programming Interfaces API as middleware. Networking gurussee anything above IP as middleware. Researchers and practitioners who work between these twoextremes consider it as somewhere between TCP and the API, with some even further classifyingmiddleware into applicationspecific upper middleware, generic middleware, and resourcespecificlower middleware citeAikenciteNGI.To briefly present a historical evolution of the middleware definition, some of its earliestconceptualizations originated with the distributed operating research of the late 1970s and early1980s and were further advanced by the IWAY project citeFoster. The IWAY linked highperformance computers nationwide over highperformance networks such that the resultingenvironment functioned as a single highperformance system. As a consequence of that experiment,the involved researchers reemphasized the fact that effective highperformance distributedcomputing required distributed common resources and facilities, including libraries and utilities forresource discovery, scheduling and monitoring, process creation, communication and data transport.In May 1997, the members of the Next Generation Internet NGI consortium extended thetraditional definition of middleware by stressing requirements such as reusability and expandabilityciteNGI. Their definition includes persistent services, such as those found within traditionaloperating systems, distributed operating environments e.g., the Java framework, networkinfrastructure services e.g., the Domain Name Service, and transient capabilities e.g., runtimesupport and libraries.The chapter has neither the presumption nor the objective of presenting a conclusive and totallyaccepted definition of middleware. Its aim is, instead, to give some details about widely diffusedand recently emerging middleware technologies and to describe which coordination models are atthe basis of the presented distributed infrastructures. So, to fully understand the following, it is3sufficient to adopt a popular definition of middleware as the intersection of the stuff that networkengineers do not want to do with the stuff that application developers do not want to dociteInternet2. By accepting this informal definition, the largest part of both research andindustrial work in distributed systems in the last years can be classified as middleware, from thearea of distributed operating systems citeGalli to the one of distributed objectsciteOMG98citeSessions, from the area of distributed multiagent societies citeWobckeciteJennings to the one of tuplebased distributed coordination citeArnold.Among the middleware supports for distributed objects, the Object Management Group OMGCommon Object Request Broker Architecture CORBA is certainly the most widespread, complexand mature infrastructure, also because the major competing support, Microsoft DistributedCommon Object Model DCOM, has started later and with different aims in terms of openness andgenerality citeOMG98 citeSessions citeChung. Since 1989, the OMG consortium, whichincludes the quasitotality of companies except for Microsoft has been defining CORBA. CORBAis a middleware that permits a very rich variety of coordination modalities between its components.The architecture is based on the concept of a common software bus allowing for distributed objectinteroperability and providing a wide set of busrelated services to interacting objects. The mainaim is to release application developers from all the duties that stem from the possible heterogeneityand distribution of CS components CORBA client objects have no visibility of the location of theCORBA server objects they collaborate with, and their interaction is completely independent ofboth their implementation language and the platform where they are running. The most notableconsideration in this context is that CORBA, apart from the variety of available policies forcommunication and coordination between components, has been designed from the beginning as acomplex and layered architecture of facilities and services to support the implementation ofdistributed CS applications.A significant novelty in the distributed systems of the last years is the introduction of the MobileAgent MA programming paradigm that is contributing with new energies and differentperspectives to the definition and implementation of a distributed middleware of common facilitiesand services. The crucial point of the MA technology is to give to locationaware computing entitiesthe possibility of migrating with their code and the reached execution state from one network hostto another one while in execution citeFuggetta. The property of mobility makes the MAprogramming paradigm significantly more flexible than the traditional CS one, by permitting toexploit locality in agent access to distributed resources and to perform distributed operations in acompletely asynchronous way with respect to the commanding users and the originating hostsciteFuggetta citeRothermel citeASAMA. Several heterogeneous MA platforms haverecently emerged citeAglets citeAjanta citeGrasshopper citeSOMA, and coming from acompletely different direction with respect to CORBA, they are also trying to identify a middlewareof basic services to provide to mobile agents, in order to simplify and stimulate the implementationof industryscale MAbased applications for the Internet.Both CORBA and mobile agents propose middleware approaches to support the implementationof Internet services, but the properties of their solutions are very different due to the fact thatCORBA mainly focuses on interoperability and location transparency while mobile agentsconcentrate on mobility and location awareness. As previously cited, they are not evenrepresentative of any possible middleware approach. For instance, Jini has recently emerged as avery interesting technology for the coordination of Javabased distributed components, with asolution that is certainly more lightweight and perhaps less general than the CORBA oneciteArnold. However, in this chapter we have decided to present and compare CORBA and MAtechnologies because they have achieved the same goal of providing a distributed middleware forInternet services, even if their approaches originate from very different directions and perspectives,being the CORBA middleware a basic element of its initial design, the MA one a necessity emergedduring the realization of first MA platforms and MAbased services. Most important of all, weclaim that CORBA and MA should not be considered alternative one to the other on the contrary,4several properties exhibited by the two technologies are complementary and motivate theirintegration to provide application designers with a very flexible middleware infrastructure that isable to cover different levels of abstraction.The remainder of the chapter is structured as follows. Section 2 and 3 are devoted to a briefdescription of the middleware frameworks and the coordination possibilities offered by,respectively, CORBA and MA. Section 4 tries to demonstrate the suitability of the integration ofCORBA distributed objects with mobile agents due to the partial complementation of the twoapproaches. Section 5 exemplifies the claim of the previous section by presenting the architecture oftwo MA systems integrated with CORBA Grasshopper and SOMA and their application to thedomains, respectively, of enhanced Intelligent Networks IN services and of management ofdistributed Video on Demand VoD applications. Concluding remarks and emerging directions incurrent and future work follow.2 Common Object Request Broker Architecture CORBAThe OMG CORBA technology has gained wide acceptance in the late 1990s and has become thestandard defacto for the integration and support of possibly heterogeneous distributed objects inlargescale industrial applications. Born with the main aim to facilitate interoperability between CSdistributed components including the integration with legacy systems and services, CORBA hasbeen designed from scratch as a very articulated and layered architecture of services, at differentlevels of abstraction, that should cover all aspects and duties of designing and implementingdistributed applications, from basic communication between objects to the provision of morecomplex and dynamic modalities of coordination, from generalpurpose lowlevel services that canhelp in the implementation of any kind of distributed application to higherlevel common anddomainspecific facilities.The independence of both the implementation language and the execution platform is guaranteedin CORBA by the specification of a standard language to define object interfaces, the InterfaceDefinition Language IDL. CORBA server objects that publish their IDL interfaces can be invokedby any CORBA client object that has an apriori knowledge of server interfaces, by exploiting staticmechanisms of interaction based on precompiled proxies both on the client side stubs and on theserver one skeletons. It is also possible to have more flexible and sophisticated modalities ofcoordination between CORBA objects, based on the availability of dynamic invocation mechanismsthat permit to defer the knowledge of the IDL interfaces of the involved objects. A CORBA clientcan dynamically build an invocation request from scratch by exploiting the Dynamic InvocationInterface DII. A CORBA server can analogously be unaware at compiletime of its skeleton byexploiting the Dynamic Skeleton Interface DSI functionality. Any possible combination ofstaticdynamic clients invoking staticdynamic servers is supported. In any case, object interactionsin CORBA are mediated by runtime services for object activation on the server sideBasicPortable Object Adapter  BOAPOA and for dynamic retrieval of information on currentlyavailable CORBA interfaces Interface Repository  IntR and CORBA object implementationsImplementation Repository  ImpR.All the above mechanisms are components of the CORBA core, i.e., the software bus thatrealizes the transparency of allocation and implementation between CORBA objects and that iscalled Object Request Broker ORB. They are mandatory in any vendor implementation of theCORBA specifications. Upon the ORB core, the OMG specifies the possibility to implement alayered architecture of additional modules to help in the design and deployment of distributedapplications. These facilities are organized into a structured architecture called Object ManagementArchitecture OMA and classified as CORBA services, horizontalvertical facilities and applicationobjects.In the following, we try to give some insights about the OMG architecture model and about themechanisms available in the ORB for object communication and coordination. The objective is toillustrate the variety of interactions that are possible between CORBA objects, in order to acquire5the elements required to compare it with the corresponding modalities available in common MAplatforms and presented in Section 3.2.1 Object Management ArchitectureThe OMA has been defined by OMG in 1991 with the goal of providing a high level specificationof the functionality needed for an objectoriented CS distributed processing, that is how distributedobjects should be defined and created, what communication mechanisms are required and howmethods should be invoked on remote objects.The architecture includes an Object Model and a Reference Model. The Object Model showshow objects must be described in the context of a heterogeneous distributed environment, while theReference Model describes the possible interactions between distributed objects.In the Object Model, an object is an encapsulated entity, characterized by a specific identity. Anyobject is supposed to provide external objects with services, which are accessible only throughwelldefined interfaces without requiring the knowledge of the object specific implementation.The Reference Model identifies and characterizes the components, interfaces and protocols thatcompose the OMA. It includes the ORB also referred to as CORBA object bus, which representsthe core of the OMA architecture by providing the support to object location transparency, serverobject activation and interobject communication, and four categories of object interfaces asdepicted in Figure 1 Object Services citeOMGServ are a collection of domainindependent lowlevel services thatextend the ORB functionality with basic functions that are likely to be used in any programbased on distributed objects such as lifecycle management, naming, persistence, transactions,.... These components provide the generic environment where single objects can perform theirtasks. Adopted OMG Object Services are collectively called CORBA Services Horizontal Common Facilities citeOMGFacil are interfaces for horizontal facilities that areoriented to final users and applicable to most application domains such as user interfaces,information management, system management, task management, . They may be based onobject services Vertical Domain Interfaces citeOMGFacil are application interfaces tailored to specificdomains and areas such as electronic commerce, telecommunications, telemedicine, ,which may be based on object services, common facilities and application interfaces Application Interfaces are nonstandardized applicationspecific interfaces, which also allow towrap existing interfaces into the CORBA framework such as legacy switch control andmanagement interfaces. Since the OMG is interested in the specification of middlewarecomponents and not of final applications, these interfaces are not subject to standardization.A peculiarity of the OMA architecture is that the same object can alternatively play the client andthe server roles in different times.6Nonstandardizedapplicationspecific  interfacesFrameworks  Verticaldomainspecific interfacesVertical Market FacilitiesGeneral service interfacesCORBA servicesHorizontal Commonfacility  interfacesHorizontal FacilitiesApplication ObjectsObject Request BrokerCommon FacilitiesFigure 1 OMG Object Management Architecture Defining Different Interface Categories.A second part of the Reference Model introduces the notion of domainspecific ObjectFrameworks. An Object Framework component is a collection of cooperating objects that providean integrated solution within an application or technology domain and which is intended forcustomization by either service developers or final users. They are vertical slices down the OMGinterface stack. This means that Object Frameworks are collections of cooperating objectscategorized into Application, Domain, Facility, and Service Objects. Each object in a frameworksupports through interface inheritance or makes use of via client requests some combination ofApplication, CORBA Facilities, and CORBA Services interfaces.Through a series of Requests for specification Proposals RFPs, the OMG is populating theOMA with detailed specifications for each component and interface category in the ReferenceModel. Adopted specifications include the Common Object Request Broker ArchitectureCORBA, CORBA Services, and CORBA Facilities. The following section focuses on thespecifications and functionality of the CORBA components that represent the core of anyimplementation of the OMA.2.2 Common Object Request Broker ArchitectureCORBA defines the programming interfaces to the OMA ORB. The ORB is the basic mechanismby which objects transparently make requests to and receive responses from each other, either onthe same host or across a network. A CORBA client object need not to be aware of the mechanismsused to either communicate with or activate a server object, how it is implemented, and where it islocated. So, the ORB forms the foundation for building applications constructed from distributedobjects and for interoperability between applications in both homogeneous and heterogeneousenvironments.The CORBA specification citeOMG98 provides the description of the interfaces and servicesthat an OMAcompliant ORB must implement to be aligned with the OMG standards. In addition, itdefines a software infrastructure to facilitate the development of reusable and portable applicationsin distributed environments. Figure 2 shows its architecture consisting of various structuralcomponents, each responsible for a specialized functionality the ORB, the IDL Stubs andSkeletons, the Dynamic Invocation Interface DII, the Dynamic Skeleton Interface DSI, theInterface Repository IntR, the Implementation Repository ImpR, and the Object Adapter OA.7DynamicInvoc.InterfaceStaticIDLstubsORBInterfaceDynamicSkeletonInterfaceStaticSkeletonObjectAdapterObject Request Broker coreClientObject implementationImplem.repositoryInterfacerepositoryFigure 2 Common Object Request Broker Architecture.The ORB is responsible for establishing the communication relationships between client and serverobjects in the distributed environment. It is in charge of identifying the server object that mustsatisfy the client request, activating it if necessary, passing the input parameters and the operationtype, and returning the result and the output parameters. The ORB implements a mechanism similarto remote procedure calls applied to objects. The CORBA specification requires that the ORBmediates the communications between distributed objects since the client must be aware neither ofthe server location nor of the server programming language. Clients need only to care about objectinterfaces.Before invoking an operation on a target object, the client must obtain its object reference, forexample by interacting with the naming service that will return the needed object reference asoutput parameter. The ORB creates a new object reference once the target object has been activated,but the object itself is responsible for the distribution of its reference via the registration with thenaming service or by other distribution mechanism, if it wants to be reachable. An object referencecan be stored and used later since the ORB guarantees that the associated target object will beavailable to satisfy client requests as long as it is active. The object reference can be exchangedbetween interacting objects in a string format, but its usage requires to preventively reconvert thestring into an object. In summary, the ORB offers to client objects the following services Object localization. The client does not need to know if the target object is active either withina process running on a remote machine or in a process within the same machine or even withinthe same process of the client. Object implementation. The client must not be aware of the programming language used toimplement the target object, of the operating system or the hardware platform on which theserver program is executed. Object execution state. The client does not need to know if the target object is already activewithin the corresponding server process and ready for accepting the incoming request. TheORB is responsible for transparently activating the target object before forwarding the clientrequest. Object communication mechanism. The client can ignore the communication mechanism usedby the ORB to send the incoming request to the target object and to return the response to theclient.2.2.1 Interface Definition LanguageThe OMG IDL provides a standardized way to define the interfaces to CORBA objects. The IDLdefinition is the contract between the implementer of an object and the client. IDL is a stronglytyped declarative language that is independent of the programming language chosen to implementeither the server object or the client one. IDLtoanyLanguage mappings enable objects to be8implemented and to send requests in the developer programming language of choice, in a style thatis natural to that language.A client can determine the services offered by an object on the basis of its IDL interface. In fact,an interface describes the attributes and the operations that a server object makes available to anypossible client. The IDL permits to define modules, interfaces, attributes, operations and data types.A module is a namespace where interface names must be unique. An interface defines a set ofobject attributes and operations. Attributes are object values, which can be directly accessed forreading and writing or only for reading, by using the standard get and set operations. Operations aremethods whose signature is described in terms of operation name, parameter modes in, inout, out,names and types, result type and exceptions. Finally, data types describe the types of values eitherbasic or constructed used for parameters, attributes, exceptions and return values.One of the key characteristics of IDL is the abstraction of object implementation details, beingfocused only on the interfaces and on the public attributes of an object, which are the only relevantfor object interaction scenarios. The concept is that, in a distributed environment, clients shouldnever be interested in implementation issues but only on offered services.2.2.2 Static Invocation InterfaceOnce the IDL definition of the object interface is available, it is used to generate automatically theproxies needed to link CORBA clients to the implementation of CORBA server objects. The IDLspecification must be mapped onto a target implementation language using the IDL precompiler.Once applied, this precompiler will generate the necessary stub and skeleton files, required for thecommunication between client and server.The skeleton files contain the serverside code that implements the communication between theORB and the server object. Anytime the skeleton receives a service invocation from the ORB, itforwards the request to the object implementing the corresponding operation. To realize a serverobject, the programmer must only write the code implementing its interface operations, i.e., themethods present in its skeleton. The stub files contain the clientside code that implements thecommunication between the client object and the ORB. When the client invokes an operation on aremote object, the stub resulting from the precompilation of the server IDL in the clientprogramming language is responsible for forwarding the service invocations to the ORB.Stubs and skeletons interact with the ORB for the marshalling and unmarshalling of theoperation parameters in order to map them from the local programming language e.g., Java, Cformat to a common format, i.e., the General InterORB Protocol  GIOP. When either stubs orskeletons mediate the interactions between the objects and the ORB, this is referred to as StaticInvocation Interface. The term static indicates that stubs and skeletons are respectively part of theclient application and of the server object implementation and therefore the server object IDLinterface must be known at compiletime to both the client and the server.2.2.3 Dynamic Invocation and Dynamic Skeleton InterfacesIn addition to the Static Invocation Interface based on stubs and skeletons, CORBA provides othertwo mechanisms the Dynamic Invocation Interface DII and the Dynamic Skeleton InterfaceDSI, allowing modalities of CS coordination that are more flexible and changeable at runtime. Inparticular, the DII mechanism makes a client object independent of the knowledge of the targetobject stub at compiletime. This means that it is not necessary to have an apriori knowledge of theserver object the client will interact with. Analogously, the DSI mechanism allows the server objectto be unaware of its object skeletons at compiletime, i.e., it does not force a server object to knowits own IDL interface and, therefore, the specific object it is implementing. In short, DII and DSImake possible to provide new services by defining at executiontime the operations that have to beinvoked and the parameters to be returned.9The DII and DSI mechanisms exploit a set of ORB interfaces that are independent of the IDLinterfaces of the implemented objects. To support these features CORBA has introduced standardAPIs that enable runtime binding mechanisms.2.2.4 Repositories and Object AdaptersThe knowledge of the IDL interfaces implemented by target objects can not only be fixed in stubsand skeletons, but can also be stored in a middleware database component that is called InterfaceRepository IntR. Whenever a distributed application uses the DSI mechanism, the knowledge ofobject IDL interfaces is embedded in the application code. Therefore, if the IDL interfacesreferenced by the application change during the application lifetime, the application needs to berecompiled. The IntR is the response of the CORBA middleware to avoid this rigidity. The IntR isa CORBA object that manages an online database containing the description of the interfacesdefined via the IDL. The stored information is used by the ORB to check the method signaturecorrectness, to provide metadata information to CORBA clients and to dynamically get thedescription of the interfaces implemented by any registered CORBA object.The Object Adapter OA is the glue between the implementations of CORBA objects and thesoftware bus. The OA provides object implementations with a set of services, such as objectinstantiation, server class registration in the Implementation Repository ImpR, object referencegeneration, forwarding of incoming service invocations to interface stubsskeletons, and dispatchingof incoming requests to target objects. Similarly to the IntR, the ImpR is a runtime databasecontaining object references, types and classes of the instantiated objects of all registered serverprocesses. The ORB exploits this information to locate active objects and to request the activationof new objects within a server.Since an OA defines how an object must be activated, different OAs could be implemented tosupport different object activation policies, possibly required by different applications. For instance,the serverpermethod activation policy specifies that a new server process is activated for eachmethod invocation the ORB does not need to know if the object is already active. The persistentserver policy, instead, imposes that the server process is not activated automatically by the OA atthe first client invocation, but it has to be started manually by invoking an explicit operation ofconnection to the ORB.2.3 Integration with Internet TechnologiesThe emergency of widely diffused Internet services and the increasing relevance of a fullintegration with the Web are probably the major driving force behind the evolution of CORBAspecifications. With the publication of the first CORBA 1.0, a number of commercial ORBimplementations appeared, thus emphasizing the problem of ORB interoperability when objectsreside on different ORBs and need to communicate, as it is in an open and global distributed systemsuch as the Internet. This problem has been overcome by the CORBA 2.0 specification that facedthe interoperability issues by defining an interoperable format for object references InteroperableObject Reference and the mandatory Internet InterORB Protocol IIOP that specifies how GIOPmessages have to be transported over a TCPIP network. Even if GIOP messages can also bemapped into other connectionoriented transport protocols, an ORB must always support IIOP to beCORBA 2.0 compatible. In addition, Environment Specific InterORB Protocols ESIOPs havebeen defined for handling interoperability also with distributed platforms that are not compliantwith CORBA e.g., the Open Software Foundation Distributed Computing Environment  OSFDCE citeOSF.The primary goal of the current CORBA 3.0 specification is to simplify the use of the CORBAtechnology for the development of Internetoriented distributed object applications, by providing aCORBA version with full integration with the Internet. To increase the acceptance of CORBA alsoby other technology providers, a rich support for legacy environments was included10 CORBA Java to IDL Mapping. The mapping allows Java application developers to builddistributed application purely in Java and then to generate the CORBA IDL from compiled Javaclass files. This permits an easy integration with CORBA without writing IDL interfaces andallows other CORBAcompliant services to access Java applications over IIOP CORBA Firewall. Many Internet applications and legacy systems are behind a firewall forsecurity reasons. The specification defines a set of interfaces for passing IIOP requests andreplies through a firewall. It encompasses configuration mechanism for allowing the firewall toperform filtering and proxying on both the client side and the server one. This enables acontrolled and secure use of CORBAbased applications from the Internet CORBA Interoperable Naming Service. Until recently, pure CORBA clients could accessCORBA object interfaces only via CORBA object references. There was no other mechanism toreach a server object, even if the client knows the server location. This naming service defines anInternetlike format for object references based on URLs, that can be used to reach definedservices at a remote location.Finally, it is important to notice that the most diffused Web browsers e.g., Netscape Communicator4.x and Microsoft Internet Explorer 5.x currently support full integration with CORBA bypermitting to encapsulate Javabased CORBA clients in standard Web documents.3 Mobile AgentsThe appearance of the Mobile Agent MA concept can be derived mainly by a new technologycalled TeleScript developed by General Magic in 1994 citeWhite. It was the period whenscripting languages, such as the Tool Command Language TCL and its derivative SafeTCLciteBorenstein gained much attention, since they enabled rapid prototyping and the generation ofportable code. The concept of smart messaging citeKisielius, based on the encapsulation ofSafeTCL scripts within emails citeBorenstein, made new mailenabled applications possible. Inthe same years, the concept of mobile computing, intended as the possibility of moving users andterminals in the Internet with no need to suspend service provision, has gained increasingimportance and has further stimulated the research on mobile code technologies citeChess95.Last but not least, it was the beginning of the Java age, and Java is the basis for the largest part ofcurrent MA systems.Nowadays there has been a lot of development and general excitement in the area of the MAtechnology, much of which has evolved from the platform independence of the Java language withits object serialization and network communications support. We can summarize that, based on thiscoincidence of the appearance of various agent concepts, agents become a fashion technology forthe research and development communities. However, this also created confusion, since there was alack of common definitions and standards, resulting in various concepts, languages, architectures,technologies and terminology. This situation is now going to change thanks to the workaccomplished for the definition of the first standard proposals in the MA area see Section 4.1 fordetails about the current status of MA standard specifications.Mobile agents, also referred to as transportable agents or itinerant agents, are based on theprinciple of code mobility. In the CS paradigm the server is defined as a computational entity thatprovides some services the client requests the execution of these services by interacting with theserver after the service is executed, the result is delivered back to the client. Therefore, the serverprovides the knowledge of how to handle the request as well as the necessary resources. Mobilecode enhances the traditional CS paradigm by performing changes along two orthogonal axes Where is the knowhow of the service located Who provides the computational resourcesThree main programming paradigms based on the possibility of dynamic code migration have beenidentified citeFuggetta Remote Evaluation REV, Code on Demand CoD, and Mobile Agents.These paradigms differ in how the knowhow, the processor and the resources are distributedamong the components SA and SB of a distributed system see Table 1. The knowhow represents11the code necessary to accomplish the computation. The resources i.e., the file system whereapplicationspecific data are stored are located at the machine that will execute the specificcomputation.In the REV paradigm citeStamos, a component A sends instructions specifying how toperform a service to a component B. For instance, the instructions can be expressed in the Javabytecode. B then executes the request on its local resources. Java Servlets are an example of REVciteGosling. In the CoD paradigm, the same interactions take place as in REV. The difference isthat component A has resources located in its execution environment but lacks the knowledge ofhow to access and process these resources. It gets this information from component B. As soon as Ahas the necessary knowhow, it can start executing. Java applets fall under this paradigm.The MA paradigm is an extension of the REV one citeFuggetta. Whereas the latter primarilyfocuses on the transfer of code, the MA paradigm involves the mobility of an entire computationalentity, along with its code and the reached execution state. In other words, if component A is amobile agent, it has the knowhow capabilities and a processor, but it lacks the resources where toperform its operations. The computation associated with the interaction takes place on component Bthat has a processor and the required resources. For instance, a client owns the code to perform aservice, but does not own the resources necessary to provide the service. Therefore, the clientdelegates the knowhow to the server where the knowhow will gain access to the requiredresources and the service will be provided. An entity encompassing the knowhow is a mobileagent. It has the ability to migrate autonomously to a different computing node where the requiredresources are available. Furthermore, it is capable of resuming its execution seamlessly, because itpreserves its execution state.Before AfterParadigmSA SB SA SBClientServer AKnowhowResourceBAKnowhowResourceBRemote EvaluationKnowhowAResourceB AKnowhowResourceBCode on DemandResourceAKnowhowBResourceKnowhowABMobile AgentKnowhowA Resource KnowhowResourceATable 1 Classification of Programming Paradigms based on Code Mobility citeFuggetta.This means that a mobile agent is not bound to the network host where it begins execution. Theability to travel permits a mobile agent to move to a destination agent system that contains theresources with which the agent wants to interact. Moreover, the agent may be interested inexploiting the services offered by the destination agent system. When an agent travels, its state andcode are transported with it. The agent state can be either its execution state or agent attribute valuesthat determine what to do when execution is resumed at the destination agent system. The agentattribute values can include the agent system state associated with the agent e.g., time to live.The MA paradigm is important for networkcentric systems because it represents an alternate, orat least complementary, solution to traditional CS models of interaction citeChess95. MAsolutions may contribute to a reduction of the overall communication traffic in network. Forexample, mobile code has the ability to engage with a server locally for searching large databasesthe proximity to the server ensures high communication bandwidth.The adoption of the MA technology is encouraged by many researchers in the distributed systemarea, by citing the following deriving benefits citeChess9812 Asynchronousautonomous task execution  After the injection of an agent into the networkenvironment, both the commanding user and the originating network host have no control dutieson the launched agent and can perform other tasks. Reduction of network traffic and client processing power  Massive data exchanges are handledlocally at the nodes hosting the data, and client computers could concentrate on performing onlylimited local tasks. Increased robustness  The reduction of dependence between interworking components allowsMAbased applications to overcome temporary unavailability of both the network and theneeded CS resources. Once the agent arrived at a target system, the originating host may crashor the network may become unavailable without any drawbacks on the task processing. Automation of distributed task processing  Agents can exhibit an autonomous behavior and canhave builtin itineraries which determine which tasks they have to perform and where, withoutthe need of any user interaction. Decentralized control and management  Dynamic agent migration and their possible cloningsignificantly simplify the automated distribution of formerly centralized programs for the controland management of network resources and distributed applications. Flexibility  Software can be distributed at runtime and only when needed ondemand softwaredistribution. Service software can be encapsulated within mobile agents, instantly downloadedto both client and server nodes, and installed by transporting mobile agents even when possiblycomplex installation operations have to be performed on target hosts.This means that mobile agents provide flexibility in dynamically redistributing intelligence insidea distributed network environment, in particular to reduce network load and to optimize serviceperformance. The MA benefits listed above permit to overcome various problems and inefficienciesof traditional CS architectures. The possible drawback of the MA technology is represented by thesecurity risks introduced, since from some points of view a computer virus is some kind of mobileagent, too. Furthermore, an agent may be attacked, modified or deleted by a hostile agent platformon a malicious network host. Another typically stated and obvious concern related to mobile agentsis the question if agent migration is always of advantage if compared with message passing. Forexample, it is probably better to interact by message passing in case the agent code is bigger thanthe expected data volume to be exchanged.In summary, it has to be stated that agent technologies have a lot of appealing advantagescompared to traditional technologies for solving specific requirements that are emerging in theprovision of distributed services in the Internet environment. But the agent support imply theintroduction of middleware components in the target environment in order to enable mobility, localagent execution and advanced facilities for interagent communication and coordination. Inaddition, to be effectively usable in the short term, mobile agents require mechanisms and tools tointeract with existing services and legacy systems designed according to the traditional CSprogramming paradigm.3.1 Mobile Agent PlatformsThe boom of research activities related to MA platforms started in the mid nineties, motivated bythe several advantages promised by this new technology and presented in the previous section.Many research labs and manufacturers were involved in the development of various platforms, builton top of different operating systems, and based on different programming languages andtechnologies. Even new languages have been realized, exclusively designed for the support ofmobile agents e.g., TeleScript.However, what is more relevant for the middleware perspective we are trying to present in thischapter, is that common trends in MA platforms have started to emerge evidently within the lastfew years. Interpreterbased programming languages, particularly Java, are forming the basis formost of todays agent platforms, mainly due to their easy portability over heterogeneous platforms.In addition, Java is frequently chosen for the available support, directly at the language level, of13finegrained security policies and transport facilities via object serialization citeGosling.Moreover, even if coming from different experiences and domainspecific design constraints, theimplementers of MA platforms are achieving a general agreement on the architecture of middlewareservices that are necessary for supporting mobile agents in open and global environments and forleveraging the diffusion of MAbased services in the Internet. Finally, several approaches haverecently explored the possibility of integrating mobile agents and RPCbased middleware likeCORBA, possibly stimulated by the research work accomplished for the definition of agentinteroperability standards citeZhang.MA platforms typically realize a distributed processing environment, consisting of severalmiddleware components, and usually referred to as Distributed Agent Environment DAE. In thefollowing of the section, we will look closer to the structure of stateoftheart MA platforms and totheir middleware capabilities citeBreugst, while Section 4 will be completely devoted to adetailed presentation of why and how to integrate the CORBA and MA middleware technologies.Good examples for existing stateoftheart MA systems are Aglets Workbench from IBM Japanciteaglets, Concordia from Mitsubishi citeconcordia, Odyssey from General MagicciteOdyssey, Voyager from ObjectSpace citeVoyager, Ajanta from the University ofMinnesota citeajanta, TACOMA from Universities of Cornell and Tromso citeTACOMA,Grasshopper from IKV  GmbH citegrasshopper, and SOMA from University of BolognaciteSOMA. An extensive description and comparison of MA platforms is out of the scope of thischapter and can be found in citePerdikeas.3.1.1 Structure of Mobile Agent PlatformsDAEs usually support a hierarchy of locality abstractions regions, places and agent systems tomodel network physical resources, and two different types of agents mobile and stationary. Thesame terms are standardized by the OMG MASIF standard that will be presented in Section 4.1.1.Figure 3 depicts an abstract view of these entities.Agent System BPlace 1 Place 2Agent System CPlace 1CommunicationMigrationRegion AAgent System APlace 1RegionRegistryMobile agentstationary agentFigure 3 Structure of a Distributed Agent Environment DAE.The actual runtime environment for agents is called agent system on each network host, at least oneagent system has to run to support the execution of agents. Agent systems are structured by meansof places, i.e., isolated execution contexts that are able to offer specific additional services. Forexample, there may exist a communication place offering sophisticated communication features, orthere may be a trading place where agents offerbuy information and service access. Agent systemscan be grouped into domains, called regions, that usually model a physical local area network each14region has an associated region registry that maintains information about all registered agentsystems, places and agents.The region concept facilitates the management of the distributed components agent systems,places and agents in the DAE. Agent systems, as well as their places, can be associated with aspecific region by registering them within the accompanying region registry. All agents that arecurrently hosted by those agent systems will also be automatically registered by the region registry.If an agent moves to another location, the corresponding registry information is automaticallyupdated. A region can be used also to comprehend in a unique logical entity all agent systemsbelonging to a specific company or organization.The region registry maintains information about all components that are associated to a specificregion. When a new component is created, it is automatically registered within the correspondingregion registry. While agent systems and their places are associated to a single region for theirentire life time, mobile agents are able to move between different agent systems of possiblydifferent regions. The current location of mobile agents is updated in the corresponding regionregistry after each migration. By contacting the region registry, other entities e.g., agents or humanusers are able to locate agents, places, and agent systems residing in a region. Besides, a regionregistry facilitates the connection establishment between agent systems or agents.Two types of agents are distinguished mobile agents are able to move from one physicalnetwork location agent system A in Figure 3 to another one agent system B stationary agents,instead, are bound to the agent system where they have been installed and where they remain fortheir whole life time to provide a place persistent service according to the CS model of interaction.3.1.2 Common Capabilities emerging in MA PlatformsIn course of time, several fundamental requirements have been identified due to the experiencesmade during research and development activities in the MA area. These requirements are fulfilledby any stateoftheart MA platform, and their identification is the first fundamental step towardsthe definition of a common and interoperable distributed middleware to support mobile agents inthe Internet scenario. The implementation of a modern MA system requires middlewarecomponents to support Agent Execution  An MA platform must provide the basic capability to put incoming mobileagents into execution, taking into account possible agentspecific requirements regarding theruntime environment e.g., binding to specified local resources. The platform has to retrieve theagent code that may be either delivered with the migration request or downloaded separatelyfrom an external code base Transport  A special mobility support must be provided by the platform, not only to facilitatethe network transport of agent code and execution state, but also to permit MA systemadministrators to command remote execution and migration. Note that both agent execution andtransport cannot be sufficiently handled without a strict interworking with the security supportmentioned in the following Unique Identification  Mobile agents as well as agent systems have to be uniquely identifiablein the scope of the entire Internet environment. Thus, special support is required for thegeneration of unique agent and agent system identifiers Communication  Agents should be able to communicate with each other as well as withplatform services. Several mechanisms are possible, such as messages, method invocation,object sharing and tuplespaces, with different levels of expressive power and oftemporalspatial coupling between coordinating entities. Communication through messages maybe done pointtopoint, by multicasting, or by broadcasting. In addition, several MAcommunication modules include support for semantic analysis Security  Basic issues are authentication i.e., the determination of the identity of an agent oran agent system, and access control of resourcesservices depending on the authenticatedidentity of the requesting entity. To guarantee privacy and integrity, crucial information such as15code and state of a migrating agent should exploit publickey cryptographic encryption beforetransfer over an untrusted network Management  It is necessary for agent administrators to be able to monitor and control theiragents, also remotely. Control functions include temporary interruption of the execution of anagent task, agent premature termination, and modification of its task list. The monitoring of anagent is associated with its localization in the scope of the whole distributed environment.Regarding an agent system, all hosted agents as well as the occupied system resources have tobe monitored and controlled, possibly to notice and avoid denialofservice attacks.Figure 4 shows the structure of a core agent system that includes several services in order to fulfilthe basic functional requirements identified above. Note that some of the services provide remoteinterfaces in order to be accessible by external actors, such as other agent systems, agents, or humanusers.Apart from the basic capabilities shown in the Figure, additional ones have been taken intoconsideration in some of the most recent and evolved MA platformsciteGrasshopperciteSOMA. The most relevant one in the context of this chapter is certainlythe interoperability module, offered to permit the integration of heterogeneous agents and agentsystems with already existing services and legacy components. This interoperability is obtained viacompliance with emerging standards in the MA area, all based upon the CORBA middleware, andis the object of the whole Section 4. Other capabilities have started to be accepted as fundamentaland tend to be integrated in MA platforms. For instance, a persistency service can permit totemporarily suspend executing agents and to store them on a persistent medium. Persistency allowsagents not to waste system resources while they are waiting for external events such as thereconnection of one user or terminal where they have to yield back the results of their operations. Inaddition, a module for the support of mobile computing is provided in some MA systems toaccommodate the nomadicity of users, terminals and service components, which can move with noneed to suspend offeredaccessed services it is the MA distributed middleware that maintainstraceability of the mobile entities and reorganizes accordingly the service provision citeBell00a.These additional features usually benefit from the modular organization of MA platforms andshould be handled as addons that can be plugged into a core MA system to dynamically extendits basic functionality.AgentManagementServiceAgentTransportServiceEnhancedServicesAgent SystemHeterogeneous Network ComponentsIDGeneratorInformationBaseAgentCommunicationServiceSecurityServiceAgentExecutionFigure 4 Architecture of Basic Capabilities in Mobile Agent Platforms.4 Middleware Technologies the Integration of MA and CORBAThe two previous sections should have put into evidence the several differences between MA andCORBA as enabling technologies to implement distributed middleware for Internet service16provision. The most evident one is that CORBA tends to suggest a model where objects areallocated once and for all at a fixed location before their registration at the CORBA ORB, whilemobile agents can dynamically and autonomously migrate during execution depending on timedependent system conditions. It is possible in CORBA to mimic a certain kind of object mobility byreplicating different instances of the same object at different locations and by tailoring the objectadapter to forward different client requests for the same object to the different locations hosting oneof its replicas. This replication with the consequent issues of maintaining consistency in case ofwritable replicas can be motivated by objectives of faulttolerance, scalability and load balancing.However, the single instance of the CORBA object is thought to be at a fixed location for its wholelifetime, possibly activateddeactivated  automatically by the CORBA object adapter.Another relevant point of difference is the fact that mobile agents are entities aware of theircurrent locations and of the locations of needed resources e.g., other agents, execution places,service components, since this awareness is basic to permit dynamic decisions about agentmigration. On the contrary, CORBA tends to hide the physical location of a server object whenanswering to a client invocation. Obviously, the ORB has visibility of the allocation of registeredobjects, but this information is typically not visible to client objects and application designers. Thisis coherent with the principles that inspired the CORBA specification and design, that is to simplifyas much as possible the programmer duties while implementing services in distributed systems, bygiving the impression of the availability of a local concentrated computing environment. Inaddition, due to its origins in the traditional area of distributed computing, CORBA suggests a CSmodel of interaction between its objects while mobile agents, also because of the influence of themultiagent research community, typically adopt a peertopeer model of interaction. However, thedistinction is not so rigid either in CORBA, since CORBA objects can play the role of both clientsand servers during their lifetime.All above differences between CORBA and MA technologies stem from their different vision ofthe role and objectives that a distributed middleware must have in the support of application design,implementation and deployment. CORBA has been thought mainly to simplify the duties ofdistributed service implementers, by providing a transparent middleware that is in charge of solvingthe largest part of the issues related to the integration of distributed and heterogeneous components.From a certain point of view, the CORBA middleware tends to take some decisions in place ofprogrammers, by leaving them the specification of even articulated and complex policies e.g., forobject activation, security, replication and persistency. On the contrary, the MAbased distributedsupports have generally grown from the bottom, by first providing the mobility capacity to objects,and then trying to organize common capabilities into a layered architecture. This architecture aimsat simplifying the work of application designers by supporting most common functionality, in orderto avoid useless duplications of design work and implementation code. In MAbased infrastructures,application programmers usually have complete visibility of the operational environment whereagents execute, and have the opportunity whether to exploit or not the provided mechanisms andservices.Finally, the last relevant distinction between CORBA and MAbased middleware infrastructuresis that, at the moment, CORBA has reached a widely accepted standardization and has a very largeinstalled base of compliant resources, systems and service components. On the contrary, mainly dueto the novelty of the MA technology, the research on mobile agents has produced a great variety ofdifferent and noninteroperable MA platforms, where the common facilities provided at themiddleware layer are strictly dependent of the specific platform used.All these considerations suggest that the two presented middleware solutions have not to beconsidered alternative the one to the other, but they can integrate and complement very well. In fact,a flexible middleware for the realization of Internet services can significantly benefit from theexpressive power of agent mobility at runtime together with the possibility of transparent remoteagent coordination, from the availability of different degrees of visibility of resources in the globalsystem together with the capacity of simply integrating legacy service components via standard17interfaces. System and applicationspecific considerations typically guide the selection of the mostsuitable characteristics to exploit for this reason, we claim that a generalpurpose middlewaresolution for the Internet scenario should give service designers the possibility to dynamicallychoose the proper solution among a wide variety of available ones.To show the opportunity of the integration of CORBA and MA, the following of the sectionreports two notable examples. On the one hand, in the area of the extension of MA platforms toachieve interoperability, we present the two most relevant research activities that have led to thespecification of the MASIF citeMASIF and FIPA citeFIPA standards. It is not a case thatboth the proposals, even if coming from different research communities and different scientificbackgrounds, adopt CORBA as the standard bridge to overcome heterogeneity. On the other hand,in the area of the extension of the CORBA distributed middleware, we shortly describe the workundergoing in the OMG towards the definition of a CORBA migration service citeOMGMigr.We will show, in particular, how the migration service calls for a set of basic middleware facilitiesthat are very similar to the ones identified and implemented in the most diffused MA platforms.4.1 MA Integration with CORBAbased StandardsThe international standardization of agents started relatively late in 1997. Two main forums have tobe considered in the context of agent standardization today, namely the OMG, which has initiallyinvestigated MA system interoperability aspects and is currently looking at the integration ofdistributed object and agent technologies, including both intelligent and mobile agents, and theFoundation for Intelligent Physical Agents FIPA citeFIPA, which mainly focuses on intelligentcooperative agents. In the following, we look in more detail at the OMG and FIPA agentstandards and to describe how they exploit the underlying CORBA distributed middleware topermit the interworking of heterogeneous Internet agents.4.1.1 OMG Mobile Agent Systems Interoperability FacilityInteroperability among different MA systems is, in our opinion, a key issue for widening thediffusion of MAbased commercial Internet services. At the same time the goal of interoperabilityrequires the identification of the aspects in the MA technology subject to standardization.Recognizing the emergence of different MA systems, which are based on different approachesregarding implementation languages, protocols, platform architectures and functionality, the OMGaimed for a standard to ensure the interoperability between heterogeneous MA platforms and thereusability of legacy CORBA services by means of agentbased components. Therefore OMGORB and Object Services ORBOS Group issued a Request for Proposal for an MA facility inNovember 1995 that resulted in a corresponding Mobile Agent System Interoperability FacilityMASIF specification adopted in 1997 citeMASIF. MASIF is built within the CORBAframework and shows the interest in integration between CORBA distributed objects and mobileagents.The idea behind the MASIF standard is to achieve a certain degree of interoperability betweenMA platforms of different manufacturers without enforcing radical platform modifications. MASIFis not intended to build the basis for any new MA system. Instead, the provided specifications shallbe used as an addon module to plugin to already existing systems. The standard includesCORBA IDL specifications supporting agent transport and management, including localizationcapabilities. It has to be stated that the target of agent transport between different agent systems isnot fully enabled through the given specifications. This transport capability would only becomepossible through mutual agreements on a common agent exchange format of MA system vendors.As shown in Figure 5, MASIF has adopted the concepts of places and regions that are used byvarious existing agent platforms see Grasshopper and SOMA in Section 5. A place groups thefunctionality within an agent system, encapsulating certain capabilities and restrictions for visitingagents. A region facilitates the platform management by specifying sets of agent systems that18belong to a single authority and possibly are mapped to a physical network locality e.g., a LocalArea Network.BasicAgencyServicesMAFAgentSystemMAFFinderEnhancedAgencyServicesAgentSystemCommunication Channel ORBSystemspecific MASIFcompliantAgentscreatesuspendresumeterminate agentreceive agent,list agentsplaces,get MAFFinder,get agent system type,get agent status, .....register agentplacesystemderegister agentplacesystemlookup agentplacesystemPlaceRegionFigure 5 OMG MASIF Interfaces.MASIF does not suggest standardization of local agent operations such as agent interpretation,serialization, execution and deserialization, because these actions are application specific, and thereis no reason to limit MA system implementations. Instead, MASIF only proposes standardizationfor agent and agent system names, for agent system types and for location syntax. It specifies twointerfaces the MAFAgentSystem interface provides operations for the management and transfer ofagents, whereas the MAFFinder interface supports the localization of agents and MA systems in thescope of an administered locality. A MAFAgentSystem object should interact internally with MAsystemspecific services, and provides the associated CORBA interface to external users.Any external system can control agents of a MASIFcompliant MA system via theMAFAgentSystem interface MASIF defines methods for suspendingresumingterminating agentsand for moving agents from one MA platform to another one. The interoperation is significant onlywhen the two interworking systems present a compatibility base, that is the same implementationlanguage, or compatible externalization mechanisms. Agent tracking functions permit the tracing ofagents registered with MAFFinder, introduced to provide an MA name service, because theCORBA Naming Service is not suitable for entities that are intrinsically and frequently mobile.Agent communication is outside the scope of MASIF while it is the focus of other MAstandardization proposals, such as FIPA, described in the following SOMA agents communicatevia proprietary mechanisms, but they may also decide to use the CORBA middleware for objectcommunication.As part of any MASIFcompliant agent system, the MAFAgentSystem object interacts internallywith platformspecific services while it provides the associated CORBA interface to external users.In this way, it is possible to communicate with an agent system either in a MASIFcompliant wayusing the MAFAgentSystem interface and the CORBA ORB or in a platformspecific way usingplatformspecific interfaces that may provide additional functionality, not handled by MASIF.Apart from the agentspecific CORBA interfaces MAFAgentSystem and MAFFinder, theMASIF standard explains in detail how existing CORBA services, e.g., the Naming, Life Cycle,Externalization, and Security Service, can be used by agentbased components to enhance theprovided functionality. For instance, interoperability also means opening MA systems to newsecurity threats coming from the interaction with external components. The MASIF standardrecognizes the need for security and for its management all MASIF implementations are requiredto introduce security mechanisms, policies and tools, built upon the CORBA Security Services inorder to overcome the possible heterogeneity in  the security solutions adopted by the interworkingcomponents.19Note that the current MASIF specification only represents the first approach for an MA standard.It is believed that the work of the OMG Agent Platform Special Interest Group will result in furtherspecifications. For more details on MASIF, see citeMASIF.4.1.2 Foundation for Intelligent Physical AgentsFIPA is a nonprofit association whose purpose is to promote agent technology through thedevelopment of specifications that maximize interoperability across agentbased applications,services and equipment citeFIPA. FIPA specifies the interfaces of the different components inthe environment with which an agent can interact, i.e., humans, other agents, nonagent softwareand the physical world. Being mainly composed by researchers with background in the intelligentagent area, FIPA puts main emphasis on the standardization of agent communication, and adedicated Agent Communication Language ACL is proposed for all communication betweenFIPA agents.FIPA specifications are developed in a yearly manner. In October 1997, FIPA released its firstset of specifications FIPA97, Version 1.0 citeFIPA. The three main specifications parts 13focus on agent management in particular, defining a FIPA agent platform, define an agentcommunication language, and deal with agentsoftware interaction.The Agent Management System specification provides the normative framework within whichFIPA Agents exist and operate. It establishes the logical reference model for the creation,registration, location, communication, migration and retirement of agents and thus is very muchrelated to capabilities of a FIPA agent platform. Figure 6 depicts the agent management referencemodel. FIPA proposes the concept of an Agent Platform AP offering three basic services. Theseservices are namely the Agent Management System AMS, the Directory Facilitator DF and theAgent Communication Channel ACC. Agents may offer their services to other agents and maketheir services searchable in a yellow pages manner by the DF. Registration on a DF is optionallywhile registering on the AMS is mandatory on any agent platform. Finally, the ACC is enablingagent communication between agents on a platform and between possibly heterogeneous platforms,by offering a message forwarding service. Reachability between platforms is gained by making theforward service available over the CORBA ORB whose integration is considered mandatory for anyFIPAcompliant MA platform. Agent messages are transferred via CORBA IIOP.The AMS is the core of any agent platform. It is responsible for registering agents on their homeagent platform. Registering on an AMS is done by calling the AMS message method with a requestto register encoded in the FIPA ACL. Other functionality offered by the AMS is deregistering ofagents, modification of the agent description and modifying the agents life cycle state. The DFoffers services similar to those of the AMS, but with an additional search functionality. Thus, theDF acts as a yellow pages directory where agents may register to offer their services in a dynamicmanner to other agents. The registration is done in the same way as with the AMS. Agents canderegister with the DF by calling the deregister service.20WrapperAgentCommunicationChannelDirectoryFacilitatorAgent Platform ACommunication Channel ORBAgentsDomainAgentManagementSystemInternal Platform Message TransportACLInterfacesFigure 6 FIPA Agent Management Reference Model.If the AMS and DF services provide functionality that are similar to the MASIF MAFAgentSystemand MAFFinder, a peculiar characteristic of the FIPA standardization proposal is the concept ofagent communication by means of a special ACL. Agents have predictable behavior by commonsemantics defined in common interpretation of a common language. This is achieved by the conceptof communication acts. The registering of an agent with an AMS is realized as a communication actof the action registration. In this communication act the roles of the agent and the AMS are clearlydefined and the reactions of each party are determined by the state of the agent platform. Forinstance, if the agent is already registered, it is clearly defined that it can not be registered again,and an answer message denoting exactly this must be sent to the agent.FIPA proposes the implementation of a communication channel ACC per agent system that isresponsible for forwarding the ACL messages between agents. As platform local communication isfree to the implementor of an MA system, it is clear that the simplest solution for localcommunication between agents is realized by the platform native communication protocol. Interplatform communication, that means communication between agents on different and possiblyheterogeneous platforms, is mandatory to be realized by offering the forward service over CORBAIIOP.4.1.3 Integration of OMG MASIF and FIPA ConceptsAs can be observed from the above presentations, the OMG MASIF architecture puts moreemphasis on the physical migrationoperation support for mobile agents and on their physical objectview, while FIPA has more emphasis on the logical and service view. This difference reflects thedifferent focal points and constitutions of the two organizations. It is interesting to note that,notwithstanding their different perspectives and research background, both have decided to specifytheir middleware proposals on top of the CORBA standard.Both MASIF mobile agent and FIPA intelligent agent approaches aim at adaptive and flexibleinteroperability and coordination among dynamic autonomous systems. Some correspondencesbetween concepts in the MASIF and FIPA frameworks are particularly significant because theycome from different research communities, and can play an important role in the future evolutionsand in the convergence of the agent standardization efforts. In this context, it is worth to observethat a mobile agent in the MASIF framework specifies a kind of message which migrates betweensoftware systems and has the similar functionality as an intelligent agent communicationmessage in FIPA framework. The current MASIF middleware does not support MAcommunications, but a flexible and rich communication capability should be integrated in anyMA platform for the provision of Internet services. With such communication capability, amobile agent will also have the features of an intelligent agent in FIPA21 a place in the MASIF framework provides the operation environment for the mobile agents, withits capabilities local services and restrictions. Examples of such capabilities and restrictions canbe database services, network resource management functions, security monitoring andmanagement. All these capabilities are supported by special intelligent agents within the FIPAagent platform The MASIF agent system is the group of places that provides the platform for mobile agentmigrations and operations. Therefore a MASIFcompliant agent system corresponds to a FIPAagent platform. More specifically, the DF and AMS in FIPA framework corresponds,respectively, to the MAFFinder and MAFAgentSystem functions in MASIF, while the otherMASIF agent system componentservices offered to mobile agents via places become specificintelligent agent services within a FIPA agent platform e.g., wrapper, resource broker, and otherintelligent agents for specific applications.It is obvious that both intelligent agent and mobile agent religions have their strength and weaknessin the versatile application fields for the agent technology. Therefore it is very likely that bothparadigms will converge in the near future. A more detailed discussion of these aspects can befound in citeZhang98. Nevertheless we have briefly tried to show in this section that bothintelligent and mobile agents have a lot of commonalties in regard to the capabilities required to thedistributed middleware for their support in an open and global scenario. These similarities suggestthe realization of a common and flexible CORBAbased middleware for the provision of Internetservices designed according to the agent programming paradigm.4.2 Mobile CORBA Objects  Towards a CORBA Migration ServiceAs a further sign of the importance of code mobility in the provision of modern distributedmiddleware for Internet services, the OMG ORBOS Task Force has recently started to work on thepossibility to integrate object mobility into a CORBA environment, by extending the OMA with adedicated CORBA service for migration citeOMGMigr. The objective is to design a flexible andunified CORBA environment, supporting both remote interactions and object migration, byconsidering already existing CORBA services as a basis, determining missing functionality, andspecifying a minimal set of new functionality in order to fill the gap.The proposed service model is composed by the Life Cycle and Externalization services and usesthe Naming Service for identification and resolving matters citeCORBAServ. The Life Cyclespecification provides conventions for creating, deleting, copying, and moving objects, while theExternalization service is used for the serializationdeserialization marshallingunmarshallingprocedure of objects needed for the transfer operation.A mobile CORBA object  in short, mobile object  is a set of traditional CORBA objects,forming a unit of computational community. Such a mobile object provides multiple CORBAinterface implementations. An instance of it has the ability to migrate from one physical networklocation to another one, without loosing its internal state. By definition, a mobile object istransformed into a package, which includes the object code and possibly a serialized version of itsstate. The state consists of the contents of the instance variables, socalled data state, and theexecution state. Nevertheless, since the execution state is rather physical, this state should bemanually coded into the data state which will make the implementation of the migration easier. Themobile object package can then be delivered to another location or be preserved within a databasefor persistency purposes. By transforming back this package, a new mobile object is created andreinstated with the preserved state. The creation and reinstatement of a mobile object can be eitherdone from templates classes or by cloning an existing instance. In the connection with mobility, itshould be noted that migrating an object means to freeze its execution at one location and tocontinue it at a different location. It is not a copy, since only one instance is running at a time.The basic structure of a mobile object is relatively simple. There are two kinds of object types, acore containing the state object type, also referred to as object implementation, and a bridgestateless object type, which represents a CORBA object, i.e., it is visible through an IDL interface.22Figure 7 shows the proposed structure for a mobile object. A core object type contains the state of amobile object and a set of local interfaces, and its implementation must be completely local. Thisobject has no identity and is not registered with the ORB. The realization of the provided service iscontained within this object that supports local interfaces API and can be composed by nativeimplementation objects.Native InterfaceCORE ObjectCORBA ViewNative Programming ViewCORBA InterfaceObject ImplementationBridgeObjectFigure 7 The Structure of a Mobile Object According to the OMG Migration Service RFP.The OMG ORBOS claims that mobile objects need a runtime environment that supports theirentire life cycle, including their creation, termination, and migration. Besides, users must be able tomonitor and control their objects. The basic procedures of the distributed middleware for mobileobjects that have started to be identified by the ORBOS are exactly the same ones we havepresented in Section 3.1.2 as basic capabilities emerging in MA platforms. In particular, themigration of mobile objects can be split into the following procedures Externalizing marshalling the object execution and data state Packing the externalized state and the code into a stream and transfer it to the receiving side Creating and reinstating the serialized state by internalizing unmarshalling the stream into anew object instance at the receiving side Finally, removing the instance at the sending side.The new instance at the receiving side is not identical with the one at the sending side. After theremoval of the instance at the sending side, in fact, the CORBA objects associated with the newmobile object instance at the receiving side have to register themselves to the ORB and thus, willreceive new InterOrb References IORs associated to them. In the specification of the GIOP, anapproach for handling this IOR modification is given an ORB must provide socalled agents whichare responsible for handling client incoming requests. Such an agent has the following possibilitiesto handle client requests if the IOR specified by the client is not associated with an active objecte.g., object has moved to another destination, with different degrees of migration transparency forthe final CORBA client It knows the new IOR of the object and forwards the request to the new address. The result ofthe request is sent from the object back to the agent which forwards it back to the client. This isachieved transparently to the client which means that the client is not aware of the forwardingprocedure and of the new server side location It knows the new location of the object, but is not able to forward the request to the object.Instead, the agent delivers the new IOR to the client which is then able to establish a newconnection to the object at the new location It is not aware of the new IOR and returns an exception to the client, indicating that the object isnot any more reachable. In this case, the client may retrieve the current IOR of the object bycontacting either the Naming Service or a trader. For this purpose, it is necessary that the objectmust have its entries modified in either the Naming Service or the trader, respectively.235 CORBAMA Integrated Supports Grasshopper and SOMAOur claim about the suitability of the integration of CORBA and MA technologies is exemplifiedby two emerging MA platforms that have been developed in the last years with different featuresand objectives.Grasshopper is a commercial MA platform realized jointly by TUB OKS, GMD FOKUS andIKV GmbH citeGrasshopper. Grasshopper is a development platform and runtime support,built on top of a DAE that integrates mobile agents with the traditional CS paradigm by exploitingCORBA as a standard bridge for interoperability. Grasshopper is based on the Java 2 programmingenvironment and its newest version is compliant with the MASIF and FIPA specifications.Secure and Open Mobile Agents SOMA is an MA platform, resulting from a research project atthe University of Bologna citeSOMA. SOMA has not been realized for commercial purposes,but mainly to explore and propose innovative solutions to still open issues in the MA technologye.g., the protection of the state of mobile agents against malicious executing environmentsciteCorradi, and the integration of differentiated naming services for mobile computing in theInternet scenario citeBell00a. SOMA is implemented in the Java 2 programming framework, isdesigned according to the architecture principles of the Telecommunications InformationNetworking Architecture, and specifically focuses on the provision of a wide set of facilities forsecurity and interoperability.Thanks to the deep integration of both Grasshopper and SOMA with CORBA, the two platformsare extensively used in application domains that are characterized by a high degree of resourceheterogeneity and the frequent presence of legacy systems and services. In the following, we willbriefly describe the distributed middleware architecture implemented by the Grasshopper andSOMA platforms and we will present how the integration of MA and CORBA is strategic for theimplementation of Grasshopperbased enhanced Intelligent Networks IN services and of SOMAbased Quality of Service QoS management of multimedia flows.5.1  Grasshopper and the Telecommunication DomainGrasshopper realizes a DAE composed by regions, places, agent systems called agencies anddifferent types of agents, as described in Section 3. A Grasshopper agency consists of two parts thecore agency and one or more places. Core agencies represent the minimal functionality required byan agency in order to support the execution of agents. The following basic capabilities are providedby a Grasshopper core agency see Figure 8 Communication and Transport Service. This service is responsible for all remote interactionsthat take place between the distributed components of Grasshopper, such as locationtransparentinteragent communication, agent transport, and the localization of agents by means of theregion registry. All interactions can be performed via IIOP, Java Remote Method InvocationRMI citeGosling, or plain socket connections. Optionally, RMI and plain socketconnections can be protected by means of the Secure Socket Layer SSL citeThomas that isnowadays a widely diffused Internet security protocol. The communication service supportssynchronous and asynchronous communication, multicast communication, as well as dynamicmethod invocation. As an alternative to the communication service, Grasshopper can use itsOMG MASIFcompliant CORBA interfaces for remote interactions. For this purpose, eachagency provides the interface MAFAgentSystem, and the region registries provide the interfaceMAFFinder Registration Service. Each agency is able to know about all agents and places currently hosted,both for external management purposes and for delivering information about registered entitiesto hosted agents. Furthermore, the registration service of each agency is connected to the regionregistry which maintains information of agents, agencies and places in the scope of a wholeregion Security Service. It supports mechanisms for external and internal security. External securityprotects remote interactions between the distributed components of the Grasshopper24middleware, i.e., between agencies and region registries. For this purpose, SSL and X.509certificates are used citeFeghhi. By using SSL, confidentiality, data integrity, and mutualauthentication of both communication partners can be achieved. Internal security protectsagency resources from unauthorized access by agents. Besides, it is used to protect agents fromeach other. This is achieved by authenticating and authorizing the user on whose behalf an agentis executed. Due to the authenticationauthorization results, access control policies are activated.The internal security capabilities are mainly based on Java 2 security mechanisms Persistency Service. It enables the storage of agents and places the internal informationmaintained inside these components on a persistent medium. This way, it is possible to recoveragents or places when needed, e.g., when an agency is restarted after a system crash Management Service. It allows the monitoring and control of agents and places of an agency byGrasshopper system administrators. It is possible, among others, to create, remove, suspend andresume agents, services, and places in addition, the management middleware componentpermits to get information about specific agents and services, to list all agents residing in aspecific place, and to list all places of an agency.INAPTelecommunication Netw orkNodesAgent CreationEnvironmentAgentManagementToolAgent Manageme ntAgent TestingEnvironmentGrasshopper AgencyTelecommunicationPlace PluginINBridgeEnhancedServicesTMNBridgeRegistration SecurityCommunic.  TransportCore ServicesAccountingServiceManagementMAFAgentSystemMASIFRealizationMAFFinderCMIPCORBAPersistencyFIPARealizationFigure 8 The Grasshopper Architecture and the Telecommunication Place Plugin.Apart from these core services, any Grasshopper agency implements two modules for compliancewith MASIF the MAFagentSystem component is present in any agency, while there is only oneMAFFinder for any region and FIPA, both based on an underlying CORBA ORB. A peculiarity ofthe Grasshopper MA platform with respect to other CORBAintegrated MA systems, such asSOMA presented in Section 5.2, is that Grasshopper realizes some forms of location transparencyfor its mobile agents. It is as if the Grasshopper focus on interoperability and its tight integrationwith CORBA have superimposed the location transparency of the CORBA standard on the locationawareness typical of the MA programming paradigm. The result is that not only that Grasshopperagents do not care about the location of a desired communication peer, but also that there is nodifference between remote method invocations and local method invocations within the agent code.The last feature is achieved by means of proxy objects that are directly accessed by a client agent.The proxy object forwards the call via the ORB to the remote target object. In this way, these proxyobjects are equivalent to the client stubs used by CORBA implementations.25This kind of location transparency certainly simplifies the programming work in theimplementation of MAbased services, but it may significantly limit the visibility of designers whenrealizing applications that must have a high degree of knowledge about the hosting environment,such as in the domains of performance monitoring and distributed management citeBell00. Forthis reason, other MA platforms pursue integration with CORBA without exploiting its ORB foragent operations in homogeneous environments, i.e., within their proprietary agent systems, evenif, however, they usually provide location transparency for peer communications citeSOMA.Grasshopper is a very complete MA programming environment also for the rich variety ofsupport tools offered to MA application designers see Figure 8. An agent creation environmentenables the plug and play composition of mobile agents out of reusable functional buildingblocks. An agent testing environment allows for the simulation of the whole distributedenvironment by means of a single agency, so that the entire execution of an agent can be simulatedlocally, without endangering the real resources. Finally, a graphical agent management tool enablesthe monitoring and control of agents and agencies in the scope of one or more regions.Special emphasis lies on the opportunity to easily enhance the platform capabilities in order tofulfil individual needs, depending on concrete application scenarios. To achieve this goal, aGrasshopper core agency comprises only those capabilities that are inevitably necessary for thesupport of mobile agents. Additional, applicationdependent functionality is realized by modularand reusable building blocks. Examples of such building blocks are adapter services for the accessto telecommunication hardware for IN service provision, based on either proprietaryprotocolstechnologies or compliance with CORBA.In fact, one emerging application area of the MA technology is the telecommunications sector.The following section tries to outline how the current IN architecture can be enhanced significantlyand flexibly by means of mobile agents, in particular if they are integrated with interoperabilitystandards. For information about the basics of  INs, please refer to citeMagedanz96.5.1.1 MAbased IN Service ProvisionThe current IN architecture is CSbased. The Service Switching Points SSPs act as clients,requesting the execution of service logic from the Service Control Points SCPs, acting as servers.This architecture provides several important advantages, e.g., the opportunity to create or modifynetwork capabilities without any changes at the switches. However, due to the rising number ofservice users and the increasing number of provided IN services, the centralized SCPs are likely tobecome the bottleneck of the whole system. Even now the SCP capacity is temporarily overdrawn.Besides, the deployment and subscription of services by the Service Management System SMS isnot efficient and open enough to handle the demands of the emerging open service market. Finally,due to the centralized architecture, an SCP server failure would cause immense costs for serviceproviders.Because of these limitations, the adoption of standard distributed object technology, such asCORBA, has been considered in the IN world in the last 1990s. Also taking this into account, someresearch projects have proposed the introduction of the MA technology, when integrated with theCORBA middleware, into the IN environment in order to achieve ultimate flexibilityciteMagedanz99. This means that enhanced IN services can be implemented by either CORBAobjects andor by mobile agents on top of CORBA.Focusing specifically on the last issue, the realization of IN services in terms of mobile agentscan extend the traditional IN model in several ways. Services can be provided timedependently,i.e., installed for a limited time duration. Distributed provision of services and service componentscan enable load balancing in the network. Finally, the service management can be facilitated bydynamically installing, maintaining and extending adhoc management agents only on thosenetwork nodes where they are currently needed.Figure 9 depicts the proposed approach. The main idea is to introduce services on demand andultimately distribute service logic and data from the centralized SCP to switches and final user26devices by means of mobile agents. To support agent technology, the different network nodesshould contain Grasshopper agencies. In this way, agents representing IN service logic and data canbe sent dynamically to those network locations where the functionality is currently required. Anagentenhanced Service Creation Environment SCE allows to develop appropriate IN servicelogic and data, including the envisaged itinerary of the agent. The outlined integrated approach,combining both agent and CS technology, allows to enhance the current IN architecture instead ofcompletely removing it citeMagedanz99. Note that the agent transport shown in Figure 8 is notperformed via the IN standard signaling system no.7 SS7, but instead via a CORBAbased datanetwork that interconnects the agencies.AgencyAgencyAgencyBearer NetworkSSP SSPService DataService LogicSCEACESMSIPSS7AgencyService DataService LogicAgencyAgencySCPFigure 9 MAbased IN Architecture.The Grasshopper agents implemented for IN service provision consist of two parts. The first partcore component is devoted to the agent nature of being an autonomous mobile entity it includesall functionality required for agent lifecycle management and mobility support, and these functionsare realized by strongly interworking with Grasshopper agency services.The second part application component is related to the provision of the specific IN service,e.g., the control and management of  telecommunications switches. Therefore, the agent applicationpart contains appropriate IN logic and data, and makes use of either external interfaces e.g., INAPinterface at the switch and SCP or adapted interfaces already offered within the agency e.g., aCORBA object mapping INAP operations into CORBA object invocations, as depicted in Figure 8.In the first case traditional IN logic may be used, whereas in the second case advanced logic basedon objectoriented programming may be used. Note that the availability of the second choice alsopermits the fast prototyping and deployment of functionality for service subscription,customization, and service logic maintenance including appropriate GUIs.Three kinds of actors are involved in the Grasshopper solution a Webaccessible agent provider,a customer representing a company or organization, and various final users. Each actor requiresaccess to an agency. Additional agencies are connected to the different network elements, i.e. SCPand switches. Figure 10 presents the scenario, which is initiated by the customer accessing theprovider via the Internet and requesting an IN service agent 0. The provider sends the requestedagent to the customer 1 who is now able to preconfigure it 2. The preconfiguration comprisesthe selection of desired final users and the specification of their various access restrictions.Afterwards, the service agent is sent to the final users 3 where it is supplied with individualservice logic configurations 4. Before the agent executes its designed task, it automaticallymigrates back to the provider 5 to allow security checks, e.g., the determination of codemodifications 6. Only if the security checks have been successful, the agent moves to a specific27network node. Three possibilities are taken into account agents representing global services e.g.,free phone migrate to the agency connected to the centralized SCP 7a agents realizing calledparty services e.g., call forwarding move to the agency at the called party switch 7b agentsrepresenting calling party services e.g., abbreviated dialing move to the agency at the calling partyswitch 7c. After reaching their destination agency, the agents connect themselves to specific INservice adapters that can either be realized by enhanced agency services or in turn by specialstationary agents. Finally, the service execution starts 8a8c.ProviderAgencyCustomerAgencyEnd UserAgency1354207a7b7cSCPSCPAgencyCalled PartyCalling PartySwitchAgencySwitchAgencySMS8c68b8aProvider DomainCustomer DomainFigure 10 A Provision Scenario of MAbased IN Enhanced Services.5.2 SOMA and the Management DomainSOMA is an MAbased programming framework designed to support the easy definition,deployment and tailoring of generalpurpose networkcentric services. In the following, however,apart from briefly presenting the architecture of the SOMA DAE, we will concentrate specificallyon its application to the management of distributed and heterogeneous network resources, systemsand services. In this domain, SOMA has already achieved interesting results citeBell99citeBell00, also due to its full integration with the standard CORBA technology.The main idea in applying SOMA agents to the management domain is that mobile agents canfulfil administration needs by moving and executing on different nodes. Automation of control isobtained through the possibility of delegating management actions to agents, that act autonomouslyand in a completely asynchronous fashion with respect to the administrator, thus relieving her dutyfor instance, one agent can automatically take care of software upgrading on dynamically selectednodes of a managed network. Mobile agents permit to adapt to system modifications by tuning thebehavior of network resources and services at runtime for instance, any administrator can modifyand propagate security policies at any time, with no need to shutdown the whole system, bydynamically instantiating new mobile agents to propagate the new policies in the administereddomains.Also SOMA realizes a DAE consisting of regions called domains, places and different types ofagents, as described in Section 3. The SOMA DAE offers a distributed middleware with a rich setof interacting and coordinated facilities for the design and development of complex networkcentricapplications. In addition, the openness property of the SOMA infrastructure citeBell00b permitsto extend the programming framework by dynamically adding new services, even built on thealready provided functionality.28SOMA DAE facilities are split in two levels, the lower one that groups the basic and primarymechanisms, the upper one that comprehends more evolved tools and services, as depicted in Figure11. The SOMA Upper Layer Facilities ULF represent advanced operations and support directlythe development of applications and services see citeBell00b for details Agent Interoperability Facility AIF  The AIF offers interfaces to simplify the calls fromSOMA components included either in the DPE layer or in the service one to external CORBAcomponents or services. In addition, it supports the registration of SOMAbased services asCORBA servers and, finally, it provides interoperability with different MA systems byimplementing the MASIF standard interface Agent Security Facility ASF  The ASF provides all the mechanisms for authentication,authorization, integrity and privacy. SOMA integrates a security framework based on standardsecurity providers and certificate infrastructures citeIAIK citeEntrust. The current ASFimplementation is based on agents but can also interoperate with CORBA Security ServicesciteCORBAServ Agent QoS Facility AQoSF  The AQoSF provides both QoS monitoring and adaptationfunctionality. It is in charge of observing resource properties, from disk free space to effectivelyavailable network bandwidth, from CPU usage to allocated space in heap memory for anythread, thanks to the integration with the Java Virtual Machine Profiler Interface JVMPIciteJVMPI and with platformdependent monitoring modules via the Java Native InterfaceJNI citeGordon. Any authorized mobile service can access the monitored properties, and,depending on this information, can decide a strategy suitable for adapting to the currentenvironment conditions, without suspending service provision see also Section 5.2.1 about thedynamic adaptation of multimedia streams.The AIF, ASF and AQoSF can make use of the lower facilities in their implementation forinstance, the QoS facility exploits the underlying coordination facility to command collaborativeoperations to try to restore the requested quality after the degradation of a network link. The SOMALower Layer Facilities LLF include Agent Coordination Facility ACF  The ACF provides mechanisms and tools to simplifycoordination and communication between entities. Agents in the same place interact by meansof shared objects, such as blackboards and reactive tuple spaces citeCabri. Any place hosts aLocal Resource Manager module that regulates agent access to the node resources. This modulecontrols the authorization of agents and enforces the place security policy. Whenever one agentneeds to share one resource with another agent that resides in a remote place, it is forced tomigrate to that place. Outside the scope of the place, agents can perform coordinated tasks byexchanging messages delivered to agents even in case of migration Agent Migration Facility AMF  The AMF gives service designers the possibility to simplyreallocate network resources and service components at runtime. Entities capable ofreallocation are represented by agents, that can move in the network either via MA nativemigration methods or via standard interfaces such as MASIF over CORBA IIOP Agent Naming Facility ANF  A basic identification mechanism permits to dynamically assigntags to any entity in the system. Globally unique identifiers are the basis for the realization ofthe multiple naming systems provided by the ANF that puts together a set of different namingsystems, possibly characterized by different policies. For example, it realizes a Domain NameService and a Directory Service functionality. The ANF dynamically maintains and permits toaccess the information about the current state of any possibly mobile entity in the SOMAdistributed middleware.29Other DPE CORBA DPESOMA DAE LLFCoordination   ACF Migration  AMFNaming  ANFSOMA DAE ULFInteroperability    AIFSecurity   ASF QoS  AQoSFHeterogeneousNetwork ComponentsServiceLayerDPELayerSOMAbased Management ServicesRemoteDiagnosisRemoteMaintenanceVideo onDemandFigure 11 SOMA Distributed Middleware for Management Applications.The above facilities are available in different flavors, depending on system and service needs. Forinstance, the ANF, currently permits the coexistence of the SOMA proprietary naming servicederiving from DNS with the CORBA Naming Service. Other LDAPcompliant naming anddirectory services are under integration to let users and designers choose among multiple namespaces citeHowes. System and applicationspecific considerations typically guide the selectionof the available facilities to use for this reason, a flexible management environment has to giveservice designers the possibility to choose the proper solution among a wide variety of availableones.5.2.1 SOMAbased Resource and Service ManagementSOMA provides a wide range of management tools, from the monitoring of the state of thedistributed system to the possibility to control and coordinate replicated resources, from thedynamic installation and configuration of new network resources to the optimization of access toreplicated information by considering both current traffic level and query locality. The fullintegration with CORBA and the implementation of the MASIF interface gives to SOMAmanagement agents the capacity of interworking in different contexts see Figure 12 any SOMA service can perform management operations on legacy systems via thirdpartyCORBA gateways to either the IETF Simple Network Management Protocol SNMPciteHein or the ISO Common Management Information Protocol CMIP citeCMIP any SOMA service may call external CORBA objects, included either in CORBAServicesFacilities or in other systems management frameworks that offer a CORBA interfaceSOMA agents as CORBA clients any SOMA service may register its interface to an ORB and offer the implemented services toany recognized external CORBA client SOMA agents as CORBA servers any external entity, whether MAbased or not, may ask SOMA agents for agent managementand tracing services defined by the MASIF standard mobile agents can be moved between different typecompatible MAbased managementenvironments compliant with MASIF.30CORBA ORBCMIPlegacysystemsSNMPlegacysystemsCMIP gateway SNMP gatewayCORBAbasedManagementSystemSystems ManagementCommon FacilitiesPlaceMAbasedMASIFMan. SystemMASIF PlacePlaceSOMA PlaceMASIFPlacePlacePlacePlaceSecurity ServicesFigure 12 Different Contexts of Interoperability for SOMA Management Agents.SOMA has demonstrated its suitability in the implementation of several monitoring and controllingtools citeBell99. In addition, a main goal of SOMA is also to manage complex Internet services,even obtained by tailoring and composing existing ones, and to dynamically introduce new servicesin the existing infrastructure with no need to suspend operations.In the area of the management of multimedia streaming over besteffort standard networks suchas the Internet, we have implemented a Video on Demand VoD SOMAbased serviceciteBell00. It is based on a set of lowerlevel services, implemented in terms of mobile agentsdynamically distributed over the paths between the source and the targets of the video stream.SOMA VoD permits users to require a QoS level for any multimedia stream, and allows to manageand adjust the requested quality during service provision, to respond to dynamic modifications ofnetwork resource availability. The VoD service is realized by coordinating two different types ofSOMA management agents the QoS Negotiators QoSNs that define and grant a specific level ofquality for the service, and the Admission Controllers ACs that manage the resources to beengaged by local intermediate nodes see Figure 13.ACs are present on every node of the network this assumption is not severe because they areimplemented by mobile agents that can move and be installed whenever they are needed. Each ACmanages local resources and keeps track of their current commitment to already accepted streams.The flow specifications of streams are recorded in a local table of receivinghost,bandwidth, delay, loss tuples. Any tuple represents the statistics of VoD traffic betweenthe local and the receiving host the first time, it contains values calculated upon a short sample ofcommunication then, it is updated by monitoring real traffic of current VoD sessions. ACs are incharge of answering to reservation requests from QoSNs.The VoD service requires the coordination of a set of QoSN agents located at the source, at thetarget and at some intermediate nodes. QoSNs maintain session state they record user preferencesand flow specifications for a video stream. QoSNs evaluate the feasibility of meeting theserequirements against the local AC database and exploit the SOMA coordination facility to performthe negotiation phase for the definition of the achievable QoS. After the negotiation phase, duringmultimedia streaming, any QoSN is in charge of receiving packets from the previous QoSN and offorwarding them to the next QoSN.Let us first consider the case of a video stream addressed to one target only. The path betweenthe source and the target is automatically determined at runtime, by tracing the route via onedummy packet sent from source to target. QoSNs move to the chosen hosts on the path andinterrogate the AC database if available resources are not enough for the desired QoS, QoSNs cancoordinate and reduce their requests by scaling the stream at the moment, by dropping frames in31Motion JPEG streams or by reducing resolution in MPEG2 ones citeGibbs. Only if thesediminished reservation requests cannot be satisfied, the VoD service is denied. After a successfulnegotiation phase, the possibly scaled multimedia stream starts to flow. During the videodistribution, a link can fail or its quality can deteriorate, thus making impossible to a particularQoSN to maintain the negotiated quality. In that case, the interested QoSN can enhance thethroughput of its link via stream striping on noncorouted paths citeTraw. In this case, it sendsback a message to temporarily stop the stream, and forwards a message to suspend updates in ACtables on the path. Then, it sends its clones to handle new noncorouted paths and starts thenegotiation phase with the clones. When negotiation completes, the QoSN sends back a messagethat restarts the stream apart from a delay in receiving the stream, the VoD target goes ontransparently.In the case of multicast distribution of the same video stream for  N targets, the generatednetwork traffic can be limited by exploiting location awareness of agents. While in traditional VoDsystems the source generates N packet streams, one for each target, SOMA QoSNs can ascertainwhether there are several targets within the same domain locality, and can split packets only when itis necessary, in general only at the last hop.DomainLocalitysourceACQoSNACQoSNACQoSNACACQoSNACQoSNtarget1ACQoSNtarget2ACQoSNtarget3ACQoSN        tunneling corouting123332221 32 multicastFigure 13 Tunneling, Corouting and Multicast in the SOMAbased VoD Service.6 Concluding RemarksBased on the findings of sections two and three, namely that each of the presented middlewaretechnologies has some drawbacks or limitations for its exclusive use to realize a very flexibleplatform for the realization of Internet services, this chapter has presented an emerging approach forthe integration of MA and CORBA technologies in order to take advantage of both when needed.This means that service components could be dynamically deployed in a distributed serviceprovisioning environment and moved during runtime to more appropriate network hosts if requirede.g., for system recovery, upgrading, extending and load balancing. Nevertheless, remote interobject coordination and communication between distributed service components is maintained as afundamental paradigm of the proposed service middleware for open and global systems.We have described how it is possible to extend MA systems via the CORBA CS middlewaretechnology that is today the most accepted and diffused standard for interoperability betweenheterogeneous distributed objects. This approach currently enables a pragmatic shortterm way toenhance CORBAbased distributed processing environments with object mobility through the32provision of an addon middleware layer, i.e., the distributed agent environment. In addition, wehave illustrated how two stateoftheart MA platforms Grasshopper and SOMA exploit thisintegrated and flexible middleware respectively for the provision of enhanced IN services and forthe management of Internet multimedia streams with QoS requirements.The resulting integrated technology suggest to imagine and provide new and flexible servicecreation environments, which require an evolution of the current ones in order to reflect thecapability of object mobility. Mobility could be made visible at a high level of applications designfor developing specific applications that can benefit from the explicit notion of locality, or more inline with the overall CORBA principles can be exploited at a lower level of applicationengineering, where object mobility is employed by the middleware support in response to specificruntime requirements, such as potential interconnectivity of ORBs, performance, replication, andso on.Much research work is still to be done, as some mobility aspects have not reached yet a widelyaccepted and standardized solution. All of them have to be analyzed and considered in the future inorder to provide a consistent model which is inline with the latest developments within the CORBAcommunity. For instance, still an open point is the dynamic detection of object relationships, whichis required when the middleware is requested to freeze i.e., to serialize on a transportable formatthe state of a mobile object. The CORBA Relationship Service may be a starting point, but does notprovide a complete solution at the stateoftheart of its specification citeCORBAServ. Finally,also as a proof of the heat of the subject and of the interest raised in the OMG itself, interestedreaders are referred to the recent activities of the OMG Agent Special Interest Group, which hasissued a Request for Information on Agent Technology in OMA addressing the need for objectmobility citeOMGMigr. It is likely that a corresponding Request for Proposal for thestandardization of a CORBA Migration Service will be issued at the time of publication of thisbook.
