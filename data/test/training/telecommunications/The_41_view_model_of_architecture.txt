The 41 View The 41 Vew Model addresses a speczj set of concerns. organizes a description of a sojimare architecture usingjive concurrent views, each of which Model of Architecture PHILIPPE B . KRUCHTEN, Rational Software many books and articles in which a e all have single diagram attempts to capture the seen gist of a system architecture. But when you look carefully at the diagrams boxes and arrows, it becomes clear that the authors are struggling to represent overemphasizing one aspect of devel opment like data engineering or run turely partitioning the software or time efficiency, development strategy, or team organization. Other software architectures fail to address the con cerns of all customers. Architects capture their design decisions in four views and use thefiJZh view to illustrate and validate them. more in one diagram than is practical. Do the boxes revpresent running pro grams Chunks of source code Physical computers Or merely logical groupings of functionality Do the arrows represent compilation depen dencies Control flows Dataflows Usually the answer is that they repre sent a bit of everything. Does an architecture need a single architectural style Sometimes the software architecture suffers from sys tem designers who go too far, prema Several authors have noted the problem of architectural representa tion, including David Garlan and Mary Shaw, Gregory Abowd and Robert Allen, and Paul C1ements.j The 4  I View Model was devel oped to remedy the problem. The 4  1 model describes software architec ture using five concurrent views. As Figure 1 shows, each addresses a spe cific set of concerns of interest to dif ferent stakeholders in the system.  The logical view describes the 42 O4074599404 00 0 1994 WE NOVEMBER 1995 designs object model when an object oriented design method is used. To design an application that is very data driven, you can use an alternative approach to develop some other form of logical view, such as an entity relationship diagram.  The process view describes the designs concurrency and synchroniza tion aspects.  The physical view describes the mapping of the software onto the hardware and reflects its distributed aspect.  The development view describes the softwares static organization in its development environment. Software designers can organize the description of their architectural deci sions around these four views, and then illustrate them with a few selected use cases, or scenarios, which constitute a fifth view. The architecture is partial ly evolved from these scenarios. At Rational, we apply Dewayne Perry and Alexander Wolfs formula Software architecture  Elements, Forms, RationaleConstraints independently on each view. For each view we define the set of elements to use components, containers, and con nectors, capture the forms and pat terns that work, and capture the ratio nale and constraints, connecting the architecture to some of the require ments. Each view is described by what we call a blueprint that uses its own par ticular notation. The architects can also pick a certain ahitectural style for each view, thus allowing the coexis tence of multiple styles in one system. The 41 View Model is rather generic You can use notations and tools other than those we describe, as well as other design methods, especial ly for the logical and process decom positions. 4tl VIEW MODEL Software architecture deals with abstraction, decomposition and com position, and style and aesthetics. It also deals with the design and imple mentation of softwares highlevel structure. Designers build architectures using several architectural elements in well chosen forms. These elements satisfy I  End users Programmers l functionality l software management Logical view . Development ,ew .I. . .  Scenarios  hb.e   Process view  Physical view . IIexe ,sl . .   .wi  System integrators System engineers l performance l system topology l scolobility l delivery l throughput l installation l telecommunication Figure 1. The 41 View Model is used to organize the description of the architecture of a softwareintensive system. the major functionality and perfor mance requirements of the system as well as other, nonfunctional require ments such as reliability, scalability, portability, and system availability. Logical view. The logical view pri marily supports the functional require ments  the services the system should provide to its end users. Designers decompose the system into Simulation and Class  Class utility  Assotiotion Containment, oggregotion Usage  Inheritance formal orguments porometerized  , kiStontiOtiOn class Class category Display nnd user olerfote External Interfores Conversolion  Translation  troining services . xwA1 . Terminal Controller Connection i, services r .J Flight Air troific manogement monogement  9 Y  L . .a, Aeronautical mformotion Figure 2. A Notation jh the logical blueprint B logical blueprint for the Ttlic PBX C bluepht for an ailtraj control system. Best Copy Available IEEE SOFTWARE   43 a set of key abstractions, taken mainly from the problem domain. These abstractions are objects or object classes that exploit the principles of abstrac tion, encapsulation, and inheritance. In addition to aiding functional analysis, decomposition identifies mechanisms and design elements that are common across the system. We use the RationaUBooch approach to represent the logical view through class diagrams and templates. A class diagram shows a set of classes and their logical relationships associa tion, usage, composition, inheritance, and so on. Designers can group sets of related classes into class categories. Class templates focus on each individual class they emphasize the main class opera tions and identify key object character istics. If an objects internal behavior must be defined, we use statetransi tion diagrams or state charts. Class util ities define common mechanisms or services. NOMOII. We derived the logicalview notation in Figure 2a from the Booth notation, which we simplified consid erably to account for only those items that are architecturally significant. The numerous adornments are not very useful at this level of design. We use Rational Rose to support the logical view design. Style. For the logical view, we use an objectoriented style. The main design guideline we follow is to keep a single, coherent object model across the entire system, avoiding the premature specialization of classes and mecha nisms for each site or processor. Examples. Figure 2b shows the main classes involved in a sample PBX archi tecture we developed at Alcatel. A PBX establishes communication among ter minals. A terminal might be a tele phone, a trunk line a line to the cen tral ofe, a tie line a private PBXto PBX line, or a feature phone line. Different lines are supported by dif ferent lineinterface cards. The Controller object decodes and injects all the signals on the lineinterface card, translating cardspecific signals to and from a small, uniform set of events, such as a start, stop, or digit. The controller also bears all the hard realtime constraints. This class has many subclasses that cater to different interfaces. The Terminal object maintains the state of a terminal and negotiates ser vices on behalf of that line. For exam ple, it uses the services of the Numbering Plan object to interpret dialing. The Conversation object represents a set of terminals engaged in a conver sation. It uses the Translation Services object for accessing a directory, map ping a logical address to a physical one, and routing and the Connection Services object to establish a voice path among the terminals. Larger systems contain dozens of architecturally significant classes, such as the toplevel class diagram of an air traffic control system in Figure 2c. The system, developed by Hughes Aircraft of Canada, contains eight class categories. Process view. The process view takes into account some nonfunctional Component Connectors  Unspecified Controller process Process Terminal process  . Best Copy Available NOVEMBER 1995 tontroller tosk low rote wA.r . ontroller task ...S high rate . YS.  we 3. A Notation for the process view B partial process blueprint for the Ttlic PBX. requirements, such as performance and system availability. It addresses con currency and distribution, system integrity, and faulttolerance. The process view also specifies which thread of control executes each opera tion of each class identified in the logi cal view. Designers describe the process view at several levels of abstraction, each one addressing a different concern. At the highest level, the process view can be seen as a set of independently exe cuting logical networks of communi cating programs processes that are distributed across a set of hardware resources, which in turn are connected by a bus or local area network or wide area network. Multiple logical net works may exist simultaneously, shar ing the same physical resources. For example, you can use independent log ical networks to separate on and off line operational systems and to repre sent the coexistence of simulation or test versions of the software. A process is a group of tasks that form an executable unit. Processes rep resent the level at which the process view can be tactically controlled start ed, recovered, reconfigured, shut down, and so on. In addition, process es can be replicated to distribute pro cessing load or improve system avail ability. fortifioning. To develop the process view, designers partition the software into a set of independent tasks separate threads of control that can be individu ally scheduled on separate processing nodes. We separate tasks into two groups  Major tasks are the architectural elements that can be uniquely addressed designated from another task. They communicate through a set of welldefined intertaskcommu nication mechanisms synchronous and asynchronous messagebased communication services, remote pro cedure calls, event broadcasts, and so on. Major tasks should not make assumptions about their collocation in the same process or processing node.  Minor tasks are additional tasks introduced locally for implementation reasons such as cyclical activities, buffering, and timeouts. They can be implemented as Ada tasks or light weight threads, for example, and com municate bv rendezvous or shared Example. Figure 3b shows a partial process view for the PBX introduced in Figure 2b. All terminals are handled by a single terminal process that is dri ven by messages in its input queues. The Controller objects are executed on one of three tasks that comprise the controller mocess a low cvclerate We use the process blueprint to estimate message flow and process loads. It is also TO DEVELOP THE PROCESS VIEW , possible to implement THE DESIGNER a hollow process view with dummy PARTITIONS THE process loads and mea sure its performance on a target system. SOFTWARE INTO SEPARATE TASKS. i memorv.  task, which scans all inactive terminals 200 ms and puts any termi nal becoming active in the scan list of the high cyclerate task 10 ms, which detects any signif icant changes of state and passes them to the main controller task, which interprets the changes and communi Ivofufion. Our processview notation is cates them by message to the corre expanded from Booths original nota sponding terminal. Message passing tion for Ada tasking and focuses on within the controller nrocess is done 1 architecturally significant elements, as through shared memory. Figure 3a shows. We have used TRWs Universal Development view. The develonment Network Architecture Services to view foces on the organizationLof the build and implement the processes and actual software modules in the soft tasks and their redundancies into net waredevelopment environment. The works of mocesses. UNAS contains a 1 software is nackaged in small chunks I  tool  the Software Architects Lifecycle Environment  that sup ports our notation. SALE lets us depict the process view graphically, including specifications of the possible intertask communication paths. It can then automatically generate the correspond ing Ada or C source code. Because it account internal requirements related supports automatic code generation, to ease of development, software man SALE makes it easier to change the agement, reuse or commonality, and nrocess view. constraints imnosed bv the toolset or  program librahes or subsystems  that can be developed by one or more developers. The subsystems are orga nized in a hierarchy of layers, each layer providing a narrow and well defined interface to the layers above it. The development view takes into I  , the programning language. The Style. Several styles would fit the development view supports the alloca process view. For example, picking from Garlan and Shaws taxonomy 1 tion of requirements and work to teams, and supports cost evaluation, you can use pipes and filters or planning, monitoring of project clientserver, with variants of multi progress, and reasoning about software pleclientsingleserver and multiple reuse, portability, and security. It is the clientsmultipleservers. For more basis for establishing a line of product. complex systems, you can use a style The development view is represent similar to the ISIS systems process ed by module and subsystem diagrams groups, as described by Kenneth that show the systems export and Birman using another notation and import relationships. You can describe toolset. the complete development view only IEEE SOFTWARE 45 Components connector . Module Reference lomplation dependency include, with Layer Figure 4. Notation for a developmen blueprint. Humancomputer interface Layer  Externol rvrtemr ATC fuonal areas flight manage Layer 4 ment, sector monogement, ond IO on. Aeronouticol closles Oyer 3 ATt classes Support mechanisms Layer 2 communication, time, storoge, resource management, and so on Layer 1 Bindings Common utilities ,ow,eve, rerviter Figure fi. The five layers of Hughes Air Trafic System. after you have identified all the soft ware elements. However, you can list the rules that govern the development view  partitioning, grouping, and visibility  before you know every ele ment. Ivotahr. As Figure 4 shows, we again use a variation of the Booth notation, limited to architecturally significant items. Rationals Apex development environment supports the definition and implementation of the develop ment view, the layering strategy described above, and designrule enforcement. Rational Rose can draw the development blueprints for Ada and C at the module and subsystem level, in forward engineering, and by reverse engineering from the develop ment source code. Style. We recommend you define four to six layers of subsystems in the development view. One design rule we follow here is that a subsystem can only depend on subsystems in the same or lower layers. This minimizes the development of very complex networks of dependencies between modules in Components mm, . .v Processor ,a Other device Al Communicafion line Communication nonpermanent   Unidirectional communication  Highbondwidth communication, BUS . . K Bl favor of a simpler, layerbylayer release strategy. Examples. As Figure 5 shows, the Hughes Air Traffic System has five development layers. Layers 1 and 2  utilities and support mechanisms  constitute a domainindependent, dis tributed infrastructure that is common across the line of products. These lay ers shield the application from varia tions in hardware platforms, operating systems, or offtheshelf products such as databasemanagement systems. To this infrastructure, layer 3 adds an air traffic control framework to form a domainspecific software architecture. Layer 4 adds a palette of functionality, and layer 5 contains most of the user interface and the interfaces to external systems. This top layer is customer and productdependent. Spread across the five layers are some 72 subsystems, each containing from 10 to 50 mod ules. We represent these subsystems on additional, more detailed blue prints. Physical view. The physical view takes into account the systems non A .A F F primary   backup SW V,S  .C 4. K K , . . . PC .C .I K K K K . K igure 6. A Notation fey a physical blueprint  a PBX physical blueprint. 46 Best Copy Available  NOVEMBER 1995 functional requirements such as system availability, reliability faulttolerance, performance throughput, and scala bility. The software executes on a net work of computers the processing nodes. The various elements identi fied in the logical, process, and devel opment views  networks, processes, tasks, and objects  must be mapped onto the various nodes. Several differ ent physical configurations will be used  some for development and testing, others for system deployment at vari ous sites or for different customers. The mapping of the software to the nodes must therefore be highly flexible and have a minimal impact on the source code itself. F hverralion  process prorerr w q  vw v Termlnol F  proteir Pseudotentrol F  keudocenrrol . I  prOtW potS   r A K  . . Controller onveriotion hrerrotion prorerr prow prow5 Al b,i  A   I  . 7 Terminal Terminal process prow  c p . A process proterr prcters   L  x , tw  . . tine tardr he turds he cords Notation. Because physical blueprints can become very messy in large sys   Fipe 7. A A terns, we organize them in several small PBX physical view with process allocation B a physical forms, with or without the mapping blueprint for a larger PBX C, F, and K are three types of computers that have from the process view, as Figures 6 and different capacities azd support three different executables. 7 show. UNAS provides us with a datadri ers discover architectural elements ven means of mapping the process 5. When a valid sequence of digits view onto the physical view. This lets during the architecture design, and has been entered, the terminal opens a  it validates and illustrates the conversation. us make many changes to the mapping without modifying the source code. architecture design, both on paper and as the starting point for the tests of an Figure 6b shows a possible hard architectural prototype. CORRESPONDENCE AMONG VIEWS ware configuration for a large PBX Figures 7a and 7b show mappings of Nototion. The scenario notation is the process view on two different phys The various views are not fully ical views, a small and a large PBX. very similar to that used for the logical independent. Elements of one view are view, except that it uses the connectors connected to elements in other views, from the process view to indicate Scenarios. We use a small subset of following certain design rules and object interactions. As for the logical heuristics. important scenarios  instances of use view, we manage objectscenario dia cases  to show that the elements of the four views work together seamless grams using Rational Rose. Figure 8 From logical view to process view. We shows a fragment of a scenario for the ly. For each scenario, we describe the identify several important characteris corresponding scripts sequences of small PBX. The corresponding script tics of the logical view classes autono reads interactions between objects and my, persistence, subordination and dis 1. The controller of Joes phone tribution. between processes as described by detects and validates the transition Ken Rubin and Adele Goldberg. The Autonomy identifies whether objects from onhook to offhook and sends a are active, passive, or protected. An scenarios are in some sense an abstrac tion of the most important require message to wake the corresponding active object invokes other objects terminal object. ments. Their design is expressed using operations or its own operations, and 2. The terminal allocates some objectscenario and objectinteraction has full control over other objects resources and tells the controller to diagrams. invoking its operations. Apassive object emit a dial tone. This view is redundant with the never spontaneously invokes any oper ations, and has no control over other other ones hence the l, but it 3. The controller receives digits and transmits them to the terminal. plays two critical roles objects invoking its operations. A pro 4. The terminal uses the number tected object never invokes sponta  it acts as a driver to help design ing plan to analyze the digit flow. neously any operations but arbitrates IEEE SOFTWARE Best Copy Available  47  1 offhook  loetonlroller .  diol One c 1oeterminol 4 digit  3 digit Numbering plan 5 open tonverrotion . tonverrotion Figure 8. A scenario example from a localcall selectiolz phase. the invocation of its own operations. Persistence identifies whether objects are transient or permanent. Do they survive the failure of a process or processor Subordination determines if the existence or persistence of an object depends upon another object. Distribution determines if the objects state or operations are accessible from many nodes in the physical view and from several processes in the process view. In the logical view of the architec ture, we could consider each object as active and potentially concurrent that is, behaving in parallel with other objects and paying no more attention to the exact degree of concurrency than it needs to achieve this effect. Hence the logical view takes into account only the requirements functional aspects. However, when we define the process view, it is not practical to implement each object with its own thread of control such as its own Unix process or Ada task because of the huge overhead this imposes. More over, if objects are concurrent, there must be some form of arbitration for invoking their operations. On the other hand, multiple threads of control are needed to  react rapidly to certain classes of external stimuli, including timerelat ed events  take advantage of multiple CPUs in a node or multiple nodes in a dis tributed system  increase CPU utilization by allo cating CPUs to other activities when a thread of control is suspended during another activity such as access to some external device or access to some other active object  prioritize activities and thus potentially improve responsiveness  support system scalability by hav ing additional processes sharing the load  separate concerns between differ ent areas of the software and  achieve a higher system availabili ty with backup processes. Determining concurrency. We use two strategies simultaneously to determine the right amount of concurrency and define the set of necessary processes. Keeping in mind the set of potential physical target views, we can proceed either from the inside out or the out side in.  Inside out. Starting from the logi cal view, we define agent tasks that multiplex a single thread of control across multiple active objects of a given class. We execute subordinate objects on the same agent as their parent. Classes that must be executed in mutu al exclusion, or that require a minimal amount of processing share a single agent. This clustering proceeds until we have reduced the processes to a small number that still allows distribu tion and use of the physical resources.  Outside in. Starting with the physi cal view, we identify external stimuli requests to the system, and then define client processes to handle the stimuli and server processes that pro vide rather than initiate services. We use the problems data integrity and serialization constraints to define the right set of servers and allocate objects to the client and servers agents. We then identify which objects must be distributed. The result is a mapping of classes and their objects onto a set of tasks and processes of the process view. Typically, there is an agent task for an active class, with some variations, such as several agents for a given class to increase throughput or several classes mapped onto a single agent either to assure sequential execution or because the class operations are infrequently invoked. Finally, this is not a linear, deter ministic process leading to an optimal process view it requires a few itera tions to reach an acceptable compro mise. There are numerous other ways to proceed., Exumple. The exact method used to construct the mapping is complex. However, a brief example from a hypo thetical airtraffic control system can illustrate it. Figure 9 shows how a small set of classes from the system can be mapped onto processes. The flight class is mapped onto a set of flight agents that must quickly process many flights and spread the load across multiple CPUs while con tending with large numbers of external stimuli. The persistence and distribu tion aspects of the flight processing are deferred to a flight serve, which is duplicated to assure system availability. Flight profile or jhgbt clearance is always subordinate to a flight, and although there are complex classes, they share the processes of the flight class. Flights are distributed to several other processes, notably for display and external interfaces. A sectorization class establishes a par titioning of airspace to assign con troller jurisdiction over flights. Because of its integrity constraints, this class must be handled by a single agent, but it can share the server process with the flight, as updates are infrequent. Locations, airspace, and other static aeronautical information are protected objects, shared among several classes. These are rarely updated and mapped on their own server and distributed to other processes. From logical view to development view. A class is usually implemented as a mod ule, and large classes are decomposed into multiple packages. Collections of closely related classes  class cate gories  are grouped into subsystems. 48 Best Copy Available NOVEMBER 1995 flight ierlorizotion 0 l 0 rleoronce profile l  To define subsystems, we must consid er additional constraints, such as team organization, expected magnitude of code typically 5,000 to 20,000 lines of code per subsystem, degree of expect ed reuse and commonality, as well as strict layering principles visibility issues, release policy, and configura tion management. Thus, we usually end up with a view that does not have a onetoone correspondence with the logical view. General issues. The logical and devel opment views are very close, but address very different concerns. We have found that the larger the project, the greater the distance between these views. This also holds for the process and physical views. For example, com paring Figure 2c with Figure 5, there is no onetoone mapping from the class categories to the layers. The External InterfaceGateway category is spread across several layers communications protocols are in subsystems in or below layer 1, general gateway mechanisms are in subsystems in layer 2, and the actual specific gateways are in layer 5 subsystems. Processes and process groups are mapped onto the available physical hardware in various configurations for testing or deployment. Birman describes some very elaborate schemes for this mapping in the ISIS project. In terms of which classes are used, scenarios relate mainly to the logical view, or to the process view when interactions between objects involve more than one thread of control. ITERATIVE PROCESS Bernard Witt and his colleagues describe four phases for architectural design  k t h s e c mg, organizing, speci fying, and optimizing  and subdivide them into 12 steps. lo Although they do indicate that some backtracking may be needed, we think their approach is too linear for ambitious or unprece dented projects, because too little is orotlon girspote Al flight proflle . . v Sotkup clearonte Multiple flight ogents Flight server I jettorlzotlon . Single sectorizotion agent lototion riirrpote Aeronouwi info server Figure 9. Mappingfiom the A logical to the B process view. known at the end of the phases to vali date the architecture. We advocate a more iterative development, in which the architecture is actually prototyped, tested, measured, and analyzed, and then refined in subsequent iterations. Our approach not only mitigates the risks associated with the architec ture, it also helps build teams and improves training, architecture famil iarity, tool acquisition, the initial run in period for procedures and tools, and so on. This holds for evolutionary, rather than throwaway prototypes. An iterative approach also helps you refine and better understand the require ments. Scenariodriven approach. Scenarios capture the systems critical functional ity  functions that are the most important, are used most frequently, or present significant technical risk. To begin, select a few scenarios on the basis of risk and criticality. You may synthesize a scenario by abstract ing several user requirements. Then create a strawman architecture and script the scenarios, identifying major abstractions such as classes, mecha nisms, processes, subsystems and decomposing them into sequences of pairs object, operation. Next, organize the architectural elements into the four views, imple ment the architecture, test it, and measure it. This analysis helps you detect flaws or potential enhance ments. Finally, capture lessons learned. Begin the next iteration by reassess ing the risks, extending the scenarios to consider, and selecting a few addi tional scenarios on the basis of risk or extending architecture coverage. Then try to script those scenarios in the pre liminary architecture and discover additional architectural elements  or significant architectural changes  that must occur to accommodate these scenarios. Update the four views and revise the existing scenarios on the basis of these changes. Next, upgrade the implementation the architectural IEEE SOFTWARE Best Copy Available  49 prototype to support the new extend ed set of scenarios. At this point, you should test the architecture by measuring under load in the target environment, if possible and review all five views to detect potential simplifications, commonali ties, and opportunities for reuse. Then update the design guidelines and ratio nale and capture lessons learned. And then loop again. Finally, the initial architectural pro totype evolves to become the real sys tem. After two or three iterations, the architecture itself should become sta ble, and you should find no new major abstractions, subsystems, processes, or interfaces. The rest is in the realm of software design  where you can con tinue development using very similar methods and process. Timetable. The duration of these iter ations varies considerably, depending on the size of the project, the number of people involved, and their expertise in the domain and the development method. It also varies relative to the development organization. Hence the iteration may last two to three weeks for a small project 10,000 lines of code, or from six to nine months for a large commandandcontrol system 700,000 lines of code or larger. Tailoring the model. Not all software architectures need every view in the 41 View Model. Views that are use less can be omitted. For example, you could eliminate the physical view if there is only one processor or the process view if there is only one process or program. For very small systems, logical and development views are sometimes so similar that they can be described together. The scenarios are useful in all circumstances. Documentation. The documentation produced during the architectural design is captured in two documents  a software architecture document, organized by the 4 1 views, and 6 a software design guideline, which captures among other things impor tant design decisions that must be ACKNOWLEDGMENTS For their help in shaping or experimenting with the 41 View Model I thank my many colleagues at Rational, Hughes Aircraft of Canada, CelsiusTech AB, Alcatel, and elsewhere, and in particular, Chris Thompson, Alex Bell, Mike Devlin, Grady Booth, Walker Royce, Joe Marasco, Rich Reitman, Viktor Ohnjec, Ulf Olson, and Ed Schonberg. REFERENCES 1. D. Garlan and M. Shaw, An Introduction to Software Architecture, Awnce.r in SgFunre Engineering and f iwmledge Engnzeeling, Vol. 1, World Scientific Publishing Co., Singapore, 1993. 2. G. Abowd, R. Allen, and D. Garlan, Using Style tu Understand Descriptions of Software Architecture, ACM Sofnuwe Eng. Notes, Dec. 1993, pp. 920. 3. Paul Clements, From Domain Model to Architectures, A. AbdAllah et al., eds., Focused Workshop on Sofinre Architemwe, 1994, pp. 404420. 4. D.E. Perry and A.L. Wolf, Foundations for the Study of Software Architecture, ACM Sojhwe Eng. Xm, Oct. 1992, pp. 40.52. 5. G. Booth, ObjecrOrrentedAnal and Design with ,4pplications, 2nd. ed., BenjaminCummings, Redwood City, Calif., 1993. 6. P. Kruchten and C. Thompson, An ObjectOriented, Distributed Architecture for Large Scale Ada Systems, Pnx. TRLAdu 94, ACM Press, New York, 1994, pp. 26227 1. 7. A. Filarey et al., Software First Applying Ada Megaprogramming Technology to Target Platform Selection Trades, Proc. TNAda 91, ACM Press, New York, 1993. 8. K.P. Birman and R. Van Renesse, Reliable Distributed Computmg with the Isn Toolkit, IEEE CS Press, Los Alamitos, Calif. 1994. 9. K. Rubin and A. Goldberg, Object Behavior Analysis, Comnz. AClI, Sept. 1992, pp. 4862. 10. B. I. Witt, F. T. Baker, and E.W. Merritt, Sojiware Architectwe and Design Pmzciples. .2iodel.r, and Methods, Van Nostrand Reinholt, New York, 1994. respected to maintain the architectural integrity of the system. W  e have used the 41 View Model on several large projects, cus tomizing it and adjusting the termi nology somewhat.5 We have found that the model actually allows the vari ous stakeholders to find what they need in the software architecture. System engineers approach it first from the physical view, then the process view end users, customers, and data specialists approach it from the logical view and project managers and softwareconfiguration staff mem bers approach it from the develop ment view. Other sets of views have been pro posed and discussed at our company and elsewhere, but we have found that proposed views can usually be folded into one of the four existing views. A cost and schedule view, for example, folds into the development view, a data view into the logical view, and an exe cution view into a combination of the process and physical view.  Philippe Kmchten is a senior technical consultant at Rational Software, where he is in charge of the Software Architecture Practice area. Kruchten has 20 years experience in software development. He has been associated with several largescale soft wareintensive projects around the world, including the Alcatel2505 and Alcatel 2600 private telephone exchanges in France, the Ship System 2000 commandandcontrol sys tem in Sweden, and several other projects in avion ics, defense, transportation, and compilation. Since August 1992, he has been the lead software archi tect for the Canadian Automated Air Traffic System, developed by Hughes Aircraft of Canada in VXKOUVeI.  Kruchten received an M.Sc. in mechanical engi neering from Ecole Centrale de Lyon, France, and a PhD in information technology from the French National Institute of Telecommunications, Paris. IIe is a member of the IEEE Computer Society and the ACM. Address questions about this article to Kruchten at Rational Software Corp., 24010711 Cambie Rd., Richmond BC V6X 3GS pkruchten9rational.com 50 NOVEMBER 1995
