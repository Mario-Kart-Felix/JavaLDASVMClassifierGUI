DomainSpecific LanguagesAn Annotated BibliographyArie van Deursen Paul Klint Joost VisserCWI, P.O. Box 94079, 1090 GB Amsterdam, The Netherlandshttpwww.cwi.nlarie,paulk,jvisserAbstract We survey the literature available on the topic ofdomainspecific languages as used for the construction andmaintenance of software systems. We list a selection of 75key publications in the area, and provide a summary for eachof the papers. Moreover, we discuss terminology, risks andbenefits, example domainspecific languages, design methodologies, and implementation techniques.1 IntroductionIn all branches of science and engineering one can distinguishbetween approaches that are generic and those that are specific. A generic approach provides a general solution for manyproblems in a certain area, but such a solution may be suboptimal. A specific approach provides a much better solutionfor a smaller set of problems. One of the incarnations of thisdichotomy in computer science is the topic of this annotatedbibliography domainspecific languages versus generic programming languages.Of course, this is not a new topic. The older programminglanguages Cobol, Fortran, Lisp all came into existence asdedicated languages for solving problems in a certain arearespectively business processing, numeric computation andsymbolic processing. Gradually they have evolved into general purpose languages and over and over again the need formore specialized language support to solve problems in welldefined application domains has resurfaced. Over time, thefollowing solutions have been tried Subroutine libraries contain subroutines that performrelated tasks in welldefined domains like, for instance, differential equations, graphics, userinterfacesand databases. The subroutine library is the classicalmethod for packaging reusable domainknowledge. Objectoriented frameworks and component frameworkscontinue the idea of subroutine libraries. Classical libraries have a flat structure, and the application invokesthe library. In objectoriented frameworks it is often theThis research was sponsored by the Dutch Telematica Instituut, projectDSL see also httpwww.cwi.nlprojectsdsl.case that the framework is in control, and invokes methods provided by the applicationspecific code 42, 32. A domainspecific language DSL is a small, usuallydeclarative, language that offers expressive power focused on a particular problem domain. In many cases,DSL programs are translated to calls to a common subroutine library and the DSL can be viewed as a means tohide the details of that library.Although many domainspecific languages have been designed and used over the years, the systematic study ofdomainspecific languages has only started more recently.This bibliography has grown out of our own research needs tomake an inventory of the field and provides references to research that deals with the following topics terminology Section 2, risks and opportunities Section 3, example DSLsSection 4, DSL design methodology Section 5, and DSLimplementation strategies Section 6. The papers listed areannotated with summaries, which in turn are crossreferencedto related papers.Although these topics are the subject of current researchand progress is being made in addressing them, we expectthat they will remain important for several years to come.2 TerminologyThe question what exactly is a domainspecific language issubject to debate. We propose the following definitionA domainspecific language DSL is a programming language or executable specification languagethat offers, through appropriate notations and abstractions, expressive power focused on, and usually restricted to, a particular problem domain.The key characteristic of DSLs according to this definition istheir focussed expressive power.Our definition inherits the vagueness of one of its definingterms problem domain. Rather than attempting to define thisvolatile notion as well, we list and categorize a number of domains for which DSLs have actually been built in Section 4.Moreover, we refer to 70, which contains an interesting discussion contrasting a domain as the real world point of viewas adopted in the artificial intelligence community, with a domain as a set of systems approach, as used in the systematicsoftware reuse research community.DSLs are usually small, offering only a restricted suite ofnotations and abstractions. In the literature they are also calledmicrolanguages and little languages 7. Sometimes, however, they contain an entire generalpurpose language GPLas a sublanguage, thus offering domainspecific expressivepower in addition to the expressive power of the GPL. Thissituation occurs when DSLs are implemented as embeddedlanguages see Section 6. Languages such as Cobol or Fortran, which could be viewed as languages tailored towards thedomain of business and scientific programming, respectively,are generally not regarded as DSLs, because they are not smalland because their expressive power is not restricted to thesedomains.Domainspecific languages are usually declarative. Consequently, they can be viewed as specification languages, aswell as programming languages. Many DSLs are supportedby a DSL compiler which generates applications from DSLprograms. In this case, the DSL compiler is referred to asapplication generator in the literature 17, and the DSL asapplicationspecific language. Other DSLs, such as YACC 7or ASDL 77, are not aimed at programming specifyingcomplete applications, but rather at generating libraries orcomponents. Also, DSLs exist for which execution consistsin generating documents TEX, or pictures PIC 7. A common term for DSLs geared towards building business dataprocessing systems is 4th Generation Language 4GL.Related to domainspecific programming is enduser programming, which happens when endusers perform simpleprogramming tasks using a macro or scripting language. Atypical example is spreadsheet programming using the Excelmacrolanguage.3 Risks and OpportunitiesAdopting a DSL approach to software engineering involvesboth risks and opportunities. The welldesigned DSL manages to find the proper balance between these two. The benefits of DSLs include DSLs allow solutions to be expressed in the idiom and atthe level of abstraction of the problem domain. Consequently, domain experts themselves can understand, validate, modify, and often even develop DSL programs. DSL programs are concise, selfdocumenting to a largeextent, and can be reused for different purposes 50. DSLs enhance productivity, reliability, maintainability24, 47, and portability 38. DSLs embody domain knowledge, and thus enable theconservation and reuse of this knowledge. DSLs allow validation and optimization at the domainlevel 6, 13, 55. DSLs improve testability following approaches suchas 71.The disadvantages of the use of a DSL are The costs of designing, implementing and maintaining aDSL. The costs of education for DSL users. The limited availability of DSLs 49. The difficulty of finding the proper scope for a DSL. The difficulty of balancing between domainspecificityand generalpurpose programming language constructs. The potential loss of efficiency when compared withhandcoded software.Comparisons of the DSL approach to other approaches tosoftware generation are made in 20, 22, 47. In 24 the costsand benefits of DSLs are analyzed from the perspective ofsoftware maintenance. In 49, DSLs are categorized as oneof the main approaches to software reuse, and a detailed comparison is made to other reuse techniques.4 Example DSLsLiterally hundreds of DSLs are in existence today. Of these,only a subset is actually described in the software engineeringor programming language literature. Bestknown are classical examples like PIC, SCATTER, CHEM, LEX, YACC, andMake, which are described in 7. Other wellknown examples are SQL, BNF, and HTML. We have included referencesto various example domainspecific languages. Their domainscan be grouped into the following areasSoftware Engineering Financial products 12, 22, 24, behavior control and coordination 9, 10, software architectures 54, and databases 39.Systems Software Description and analysis of abstract syntax trees 77, 19, 51, video device driver specifications76, cache coherence protocols 15, data structures inC 72, and operating system specialization 63.MultiMedia Web computing 14, 35, 4, 33, image manipulation 73, 3D animation 29, and drawing 44.Telecommunications String and tree languages for modelchecking 48, communication protocols 6, telecommunication switches 50, and signature computing 11.Miscellaneous Simulation 2, 13, mobile agents 36, robotcontrol 61, solving partial differential equations 26,and digital hardware design 41.A collection of several papers on DSLs can be foundin 67.5 DSL Design MethodologyThe development of a domainspecific language typically involves the following steps see 17, 24Analysis 1 Identify the problem domain. 2 Gather all relevant knowledge in this domain. 3 Cluster this knowledge in a handful of semantic notions and operations onthem. 4 Design a DSL that concisely describes applications in the domain.Implementation 5 Construct a library that implements thesemantic notions. 6 Design and implement a compilerthat translates DSL programs to a sequence of librarycalls.Use 7 Write DSL programs for all desired applications andcompile them.The aim of the analysis steps 1 through 4 is to build up athorough understanding of the underlying application domain.Guidelines for acquiring such an understanding are providedby the research area of domain analysis which investigatesways of modeling domains. Following 58, a domain analystis a person who examines the needs and requirements of a collection of systems which seem similar. Neighbors emphasizes that this is work that only can be done by a person whohas built many systems for different customers in the sameproblem area. The domain analyst is like a systems analyst,except that the goal is to support the development of familiesof related systems, not just oneofakind productions 75.Domain engineering 3 refers to the activity of systematically modeling domains. Domain engineering originates fromresearch in the area of software reuse, and can be used whenconstructing domainspecific reusable libraries, frameworksor languages. A recent domain engineering survey is providedby 20, Chapter 3. Several domain engineering methodologies exists, of which ODM Organizational Domain Modeling69, 70, FODA FeatureOriented Domain Analysis 45,and DSSA DomainSpecific Software Architectures 75 arebest known.Strongly related to domain engineering is the notion of program families which are sets of similar programs 52, 18. AtLucent, a systematic approach to the development of familiesis in use, the FamilyOriented Abstraction, Specification andTranslation FAST approach, which has been successfullyapplied to over 25 different domains 18. Program familiesare in turn related to software product lines. These emphasizefeatures shared by all products, and are focused on the needsof a selected market 21, 53, 78.A prerequisite to developing a DSL is mature domainknowledge. For that reason, a DSL is viewed as the final andmost mature phase of the evolution of an objectoriented application framework 66, 22. For the same reason, the existence of legacy systems implementing domain concepts willbe of use when developing a DSL for that domain 70. Reverse engineering techniques may be used to distill domainknowledge from such legacy systems  an overview of suchtechniques is provided by 16, 25.6 DSL ImplementationThe implementation steps 5 and 6 of the previous sectioncan be carried out using several approachesInterpretation or compilation This is the classical approach to implementing a new language. Standard compilertools 1, 7 can be used, or tools dedicated to the implementation of DSLs like Draco 58, ASFSDF 23, Kephera 31,Kodiyak 38, design by selection 62, or InfoWiz 56.The main advantage of building a compiler or interpreteris that the implementation is completely tailored towards theDSL and no concessions are necessary regarding notation,primitives and the like. Also, error detection, static analysis, and optimizations can be done at the domain level, forexample using an effect system as in 13.Clearly, an important problem is the cost of building sucha compiler or interpreter from scratch, and the lack of reusefrom other DSL implementations, although some DSL toolsets for example InfoWiz 56 are particularly designed toovercome such problems.As an alternative to implementing a DSL from scratch,a DSL can be implemented by extending a given base language. For instance, 6 describes an extension of a restrictedversion of a generalpurpose language with domainspecificconstructs. The main advantage of this approach is that allfeatures of the base language remain available and need notbe reimplemented.When implementing domainspecific extensions of a baselanguage, the implementation of the base language can bereused in three different waysEmbedded languages  domainspecific libraries In thisapproach, existing mechanisms such as definitions for functions or operators with userdefined syntax are used to builda library of domainspecific operations. The syntactic mechanisms of the base language are used to express the idiom ofthe domain.An advantage of this approach is that the compiler or interpreter of the base language is reused as is for the DSL.The main limitation is in the expressiveness of the syntacticmechanisms in the base language. In many cases, the optimal domainspecific notation has to be compromised to fitthe limitations of the base language. Typical examples ofthis approach are 61 a robot control language embeddedin Haskell and 44 a PIClike drawing language embeddedin ML. The concept of domainspecific embedded languagewas coined by Hudak 40.Preprocessing or macro processing In this approach thenew constructs are translated to statements in the base language by a preprocessor. The main advantage of this approachis simplicity. Its main disadvantage is that static checking andoptimization are not done at the domain level. Consequently,generated code is error prone, and the user is provided withfeedback on these errors at the level of the base language, oronly at runtime.Extensible compiler or interpreter This approach is similar to the previous one, but the preprocessing phase is nowintegrated in the compiler. The advantage is that more typechecking and better optimization is possible. This approachis taken by 30, 74. The Tcl 59 interpreter is also a primeexample it has been extended for dozens of domains.Apart from building a dedicated DSL compiler or interpreter, or reusing the implementation of an underlying baselanguage, other implementation techniques may be used. Forinstance, in aspectoriented programming 46 a DSL is usedto describe an aspect of a systems behavior that is orthogonal to its main functionality. An aspect weaver is then usedto generate domainspecific code and merge it with the maincode.7 Concluding RemarksIn this paper, we have given a survey of the literature ondomainspecific languages. We covered terminology, risksand opportunities, example DSLs, and design and implementation issues, listing relevant references for each of these topics. The references themselves are annotated with a summaryof the most important results discussed in each paper.For up to date information on the topic of domainspecificlanguages, we refer to the series of DSL conferences organized by USENIX 64, 27, which most likely will have successors in the years to come.Another valuable source of up to date informationmay be the web. A searchable domain engineeringbibliography, with abstracts, is available at httpwww.iese.fhg.depubsandlinkssplbibliography. An online bibliography on the topic of generative programmingcan be found at httphome.tonline.dehomeUlrich.Eiseneckergpref.htm. Finally, httpwww.irisa.frcomposedsl provides a survey of domainspecific languages in general.Acknowledgments We would like to thank Jan Heeringfrom CWI for many useful remarks.References1 A.V. Aho, R. Sethi, and J.D. Ullman. Compiler Principles, Techniques and Tools. AddisonWesley, 1986.Standard text on compiler construction.2 M. Antoniotti and A. Gollu. SHIFT and SMARTAHSA language for hybrid system engineering modeling andsimulation. In Ramming 64, pages 171182.Describes the language SHIFT for hybrid system simulation. Main application area is traffic simulation. Implemented by translation to C and a runtime librarywith solvers for various kinds of differential equations.3 G. Arango. Domain analysis From art form to engineering discipline. In Fifth International Workshop onSoftware Specification and Design, pages 152159, May1989. Appeared as ACM SIGSOFT Engineering Notes143.Outlines a framework to synthesize domain analysismethods, and to compare between different methods. Thepaper advocates an incremental, evolving approach towards developing domain models.4 D. Atkins, T. Ball, G. Bruns, and K. Cox. Mawl Adomainspecific language for formbased services. InDSLIEEE 28, pages 334346. An earlier version appeared in 64.Describes the language Mawl that is intended for implementing formbased information services for different devices web browser, interactive voice response service. The main contributions of this language are 1separation of userinterface code and service logic, 2static type checking, 3 deviceindependence, 4 automatic generation of lowlevel CGI code, 5 automaticgeneration of HTML templates, and 6 automatic generation of usage statistics.5 D. R. Barstow. Domainspecific automatic programming. IEEE Transactions on Software Engineering, SE1111132136, November 1985.Envisions a framework for stepwise synthesis of domainspecific applications from informal specifications. Theframework applies search techniques to explore possiblerefinements of an initial specification, given a base ofdomain and programming knowledge facts and heuristics.6 A. Basu, M. Hayden, G. Morrisett, and T. von Eicken.A languagebased approach to protocol construction. InKamin 43, pages 115.Reports on the design and implementation ofPromela, a DSL for protocol construction andvalidation. Promela adds domainspecific constructsto restricted C, and supports validation and optimizationon the domainlevel.7 J. L. Bentley. Programming pearls Little languages.Communications of the ACM, 298711721, August1986.Demonstrates and advocates the use of little languages. Takes PIC as an example, as well as a numberof little languages from which PIC input is generatedSCATTER, CHEM, and little languages that were usedto implement PIC LEX, YACC, Make. Contrasts threeapproaches interactive systems, subroutine libraries,and little languages. Discusses DSL design principles.8 J. A. Bergstra, J. Heering, and P. Klint, editors. Algebraic Specification. ACM PressAddisonWesley, 1989.Introduces the Syntax Definition Formalism SDF, the Algebraic Specification Formalism ASF, and their combination, ASFSDF, which can be used to describe thesyntax and semantics of domainspecific languages.Contains several language definition case studies. Seealso 12, 23.9 J.A. Bergstra and P. Klint. The discrete time TOOLBUSa software coordination architecture. Science ofComputer Programming, 31205229, 1998.Describes how a language based on process algebrais used in the TOOLBUS coordination architecture forbuilding heterogeneous, distributed software systems.See also 10.10 F. Bertrand and M. Augeraud. BDL A specialized language for perobject reactive control. In DSLIEEE 28,pages 347362. An earlier version appeared in 64.Many objectoriented languages contain only implicitconstraints on the order of application of the methods ina class. This paper introduces the Behaviour Description Language BDL which uses a processoriented notation to describe this ordering. BDL is translated to C,with ESTEREL as intermediary. The resulting C code islinked with a C program and acts as controller forthe execution of C classes. See also 9.11 D. Bonachea, K. Fisher, A. Rogers, and F. Smith. Hancock A language for processing very largescale data.In DSL99 27, pages 163176.Describes the language Hancock that is intended forsignature computations on the data collected from telephone calls. A signature is a user profile with applications ranging from fraude detection to marketing. Typical issues are the large volume of data, the complextraversal patterns of these data and the different levels of precision for signatures. Hancock is translated toC combined with several runtime libraries. The majorbenefit of this DSL is a separation of concerns traversalpatterns, efficiency, signature computations. As a resultprogrammers can concentrate on the signature computation, since the other concerns are taken care of by theDSL compiler. The major reason to design a DSL as opposed to using a library were the traversal patterns thatcannot be captured in a library. The paper concludeswith a description of the design process used.12 M. van den Brand, A. van Deursen, P. Klint, S. Klusener,and E. van der Meulen. Industrial applications ofASFSDF. In M. Wirsing and M. Nivat, editors, Algebraic Methodology and Software Technology AMAST96, volume 1101 of Lecture Notes in Computer Science, pages 918. SpringerVerlag, 1996.Provides an overview of some industrial applications ofthe language prototyping environment ASFSDF. TheRISLA case study, involving a language for describingfinancial products, is discussed in considerable detail,covering pure RISLA, modular RISLA, and RISQUEST,a language for generating questionnaires used whencomposing new products. From a modular RISLA product description, COBOL code is generated for accessing a library of COBOL functions providing operationson cash flows, balances, intervals, and the like. Seealso 22, 24.13 D. Bruce. What makes a good domainspecific language APOSTLE, and its approach to parallel discreteevent simulation. In Kamin 43, pages 1735.Discusses the design of a DSL for parallel discrete eventsimulation. On the basis of this experience a number ofobservations are made regarding DSL design principles.Most notably, the use of a strong effect system is advocated to do static checking on the domain level, and todetermine applicability of optimizations.14 L. Cardelli and R. Davies. Service combinators for webcomputing. In DSLIEEE 28, pages 309316. An earlier version appeared in 64.Access to the resources of the WorldWide Web is usually obtained though manual browsers. Service combinators are intended for writing programs that reproducehuman browsing behaviour, including reactions to slowtransmission rates and various kinds of failure. Based ona concurrent programming model, the paper gives bothan informal and formal treatment of a DSL for Web computing.15 S. Chandra, , B. Richards, and J. R. Larus. Teapot Adomainspecific language for writing cache coherenceprotocols. In DSLIEEE 28, pages 317333. An earlierversion appeared in 64.The problem of cache coherence occurs when localreplica of shared data are made in a distributed system in order to improve its scalability and performance.Writing the code to support coherence protocols is errorprone. This paper describes experience with the language Teapot for describing these protocols. Teapot programs can be translated to 1 C code that implementsthe protocol, or 2 input for an automatic verifier. Twocase studies and overall experience with this approachare discussed.16 E.J. Chikofsky and J.H. Cross. Reverse engineering anddesign recovery A taxonomy. IEEE Software, 711317, 1990.Overview of reverse engineering techniques, which alsocan be used to distill domain knowledge from legacy system. See also 25, 70.17 J. C. Cleaveland. Building application generators. IEEESoftware, pages 2533, July 1988.Uses the term application generators to refer to DSLcompilers. Gives a compiler generator architecture diagram. Describes relationships between roles of customers, domain engineers and system engineers. Listspros and cons of application generators. DescribesStage, an applicationgenerator development tool.Describes a methodology for building an applicationgenerator.18 J. Coplien, D. Hoffman, and D. Weiss. Commonalityand variability in software engineering. IEEE Software,pages 3745, NovemberDecember 1998.A software family is a set of similar systems with possibly many different variations. Scope, commonality, andvariability SCV analysis gives software engineers asystematic way of thinking about and identifying theproduct family they are creating. The paper describes theFamilyOriented Abstraction, Specification, and Translation FAST approach, which has been used with immediate payoff in over 25 domains at Lucent Technologies.19 R. F. Crew. ASTLOG A language for examining abstract syntax trees. In Ramming 64, pages 229242.Introduces a Prologbased query language for analyzingabstract syntax trees of CC programs.20 K. Czarnecki and U. Eisenecker. Generative Programming Methods, Techniques and Applications. AddisonWesley, 1999. To appear.Gives a comprehensive discussion of a range of programming techniques that involve some sort of code generation step, such as aspectoriented, subjectoriented,and adaptive programming, composition filters, anddomainspecific languages. Chapter 3 of this book provides a survey of domainengineering methods.21 J.M. DeBaud and K. Schmid. A systematic approach toderive the scope of software product lines. In 21st International Conference on Software Engineering, ICSE99,pages 3443. ACM, 1999.Argues that economic motives should be used for scoping software product lines, rather than more traditional domain engineering methods. The paper proposesPuLSE, which iteratively refines business objectives towards more operational evaluation criteria.22 A. van Deursen. Domainspecific languages versusobjectoriented frameworks A financial engineeringcase study. In Smalltalk and Java in Industry andAcademia, STJA97, pages 3539. Ilmenau TechnicalUniversity, 1997.Contrasts domainspecific languages with objectoriented frameworks by comparing two projects in thefinancial engineering domain RISLA DSL and theETSwapsManager OO framework. See also 12.23 A. van Deursen, J. Heering, and P. Klint, editors. Language Prototyping An Algebraic Specification Approach, volume 5 of AMAST Series in Computing.World Scientific Publishing Co., 1996.Describes the use of ASFSDF as a metalanguage forthe specification of syntax and semantics. After introducing ASFSDF, a number of language specification casestudies are presented, and various styles for writing language specifications are illustrated. Moreover, differenttechniques for generating tools from these are presented.See also 8.24 A. van Deursen and P. Klint. Little languages Littlemaintenance Journal of Software Maintenance, 107592, 1998.Domainspecific languages DSLs have the potentialto make software maintenance simpler domainexpertscan directly use the DSL to make required routine modifications. At the negative side, however, more substantial changes may become more difficult such changesmay involve altering the domainspecific language. Thiswill require compiler technology knowledge, which notevery commercial enterprise has easily available. Thepaper describes and uses the experience of the RISLAlanguage for interest rate products to discuss the role ofDSLs in software maintenance, the opportunities introduced by using them, and techniques for controlling therisks involved. See also 12.25 A. van Deursen, P. Klint, and C. Verhoef. Researchissues in software renovation. In J.P. Finance, editor, Fundamental Approaches to Software Engineering,FASE99, volume 1577 of Lecture Notes in ComputerScience, pages 123. SpringerVerlag, 1999.Overview of parsing, transformation, and program understanding techniques that can be used when searchingfor domain knowledge in legacy systems. See also 16,70.26 T. B. Dinesh, M. Haveraaen, and J. Heering. An algebraic programming style for numerical software andits optimization. Technical Report SENR9844, CWI,1998. ACM CoRR Preprint Server cs.SE9903002March 1999. Submitted to Scientific Programming.Discusses a domainspecific programming style for thedomain of partial differential equations, using an expression style directly obtained from the underlying algebraic theory. The use of this style permits optimizations beyond the scope of current compiler optimizations.27 Proceedings of the second USENIX Conference onDomainSpecific Languages. USENIX Association, October 35 1999.28 Special issue on domainspecific languages. IEEETransactions on Software Engineering, 253, MayJune1999.29 C. Elliott. An embedded modeling language approachto interactive 3D and multimedia animation. In DSLIEEE 28, pages 291308. An earlier version appearedin 64.Describes a multimedia extension for Haskell and discusses the merits of Haskell as basis for domainspecificextensions.30 D. R. Engler. Interface compilation Steps towardcompiling program interfaces as languages. In DSLIEEE 28, pages 387400. An earlier version appearedin 64.Describes the extensible ANSI C compiler frameworkMAGIK, which allows the dynamic incorporation ofuserdefined compiler extensions. The extensions cantransform, optimize or inspect the generated intermediate representation. The approach gives safe accessto compiler internals and supports full optimization ofapplicationspecific language extensions. Implementedon top of lcc. See also 74.31 R. E. Faith, L. S. Nyland, and J. F. Prins. Khepera Asystem for rapid implementation of domain specific languages. In Ramming 64, pages 24355.Presents Khepera, a tool kit for rapid implementation and longterm maintenance of DSLs via sourcetosource transformation separated into three phasesparsing, AST transformation, and prettyprinting.32 M. E. Fayad and D. C. Schmidt. Objectoriented application frameworks. Communications of the ACM,40103238, 1997.Introduction to a special issue on domainspecificobjectoriented frameworks, which are defined asreusable, semicomplete applications that can be specialized to produce custom applications. Covers classification, strengths and weaknesses, and future trends. Seealso 66.33 M. Fernandez, D. Suciu, and I. Tatarinov. Declarativespecification of dataintensive web sites. In DSL9927, pages 135148.Covers a query language to describe dataintensiveweb sites. Three programming tasks are distinguishedto build such sites accessing and integrating thedata available in the site, building the sites structure,and generating the HTML representation of the site.The solution proposed is a declarative query languageStruQL to define the sites content and structure, a template language to define the HTML representation andan extension of the query language with functions to describe dynamic behaviour and to promote reusability ofqueries. Reengineering an existing ATT web site usingthis approach has resulted in less, more maintainable,code with more functionality. The initial learning curveof the new language is more than compensated for by theadvantages gained.34 M. Fromherz, V. Gupta, and V. Saraswat. cc  Ageneric framework for domainspecific languages. InKamin 43, pages 8996.Proposes cc, a family of languages for concurrent constraint programming, as a framework for DSL construction. Two approaches are explained by example building a DSL on top of cc, and extending cc with domainspecific constructs.35 M. Fuchs. Domain specific languages for ad hoc distributed applications. In Ramming 64, pages 2736.The current architecture of the Web is based on aclientserver model in which most of the computation isdone at the server side, while the client side is a browserthat only displays the results of server computations.SGMLXML is used as metalanguage for describing theinteractions between heterogeneous agents on the Web.Essentially, a grammar is defined of all possible interactions and this grammar steers the behaviour of eachagent. See 9 for a fully processbased approach to thisproblem.36 R. Gray. Agent Tcl A transportable agent system.In J. Mayfield and T. Finnin, editors, Proceedings ofthe CIKM Workshop on Intelligent Information Agents,Fourth International Conference on Information andKnowledge Management CIKM95, December 1995.Describes an extension of Tcl 59 for mobile agents.37 S. Z. Guyer and C. Lin. An annotation language foroptimizing software libraries. In DSL99 27, pages3952.A language is presented for annotating C libraries withinformation that is exploited by an optimizing compiler.Domainspecific information is conveyed by annotationsthat in effect define i a dataflow analysis problem onthe various library procedures, and ii procedure specializations that are to be triggered by the outcome ofthe analysis. The approach aims at giving libraries someof the compiler support enjoyed by DSLs.38 R. M. Herndon and V. A. Berzins. The realizable benefits of a language prototyping language. IEEE Transactions on Software Engineering, SE14803809, 1988.Discusses language prototyping tools LPT in general,as well as the specific LPT Kodiyak. Lists applicationareas of LPTs and benefits of applying them. Gives abrief description of Kodiyak and reports on experiencewith it.39 E. Horowitz, A. Kemper, and B. Narasimhan. A surveyof application generators. IEEE Software, pages 4054,January 1985.Surveys a number of database query and update languages, as prime examples of application generatorsDSL compilers, and hypothesizes a generic databaselanguage. Discusses the possibilities of combining sucha language with a general purpose language. OutlinesAdaRel, an extension of Ada with relational databaseprogramming constructs.40 P. Hudak. Building domainspecific embedded languages. ACM Computing Surveys, 284es, December1996.Argues that a DSL is the ultimate abstraction, capturing precisely the semantics of the application domain,but also that designing and implementing languages isdifficult and resists evolution. Proposes the notion ofembedded DSLs, which inherit the infrastructructurefrom some other language, and discusses the importanceof modular monadic interpreters, instrumentation, andpartial evaluation.41 J. Jennings and E. Beuscher. Verischemelog Verilogembedded in Scheme. In DSL99 27, pages 123134.Verilog, a digital hardware design language, is extendedwith facilities for generating and manipulating hardware descriptions by embedding it into the general purpose language Scheme. The extended language featuresearly error detection and high customizability.42 R. E. Johnson and B. Foote. Designing reusable classes.Journal of ObjectOriented Programming, 122235,1988.Introduced the notion of objectoriented frameworks. Aframework is defined as a set of classes that embodies anabstract design for solutions to a family of related problems, and supports reuse at a larger granularity thanclasses. In a whitebox framework, applicationspecificbehavior is obtained via method overriding or by addingnew methods to the frameworks classes. In a blackbox,support for extensibility is provided by defining interfaces for components that can be plugged into the framework via object composition, thus better hiding the implementation details of the framework. See also 32, 6643 S. Kamin, editor. DSL 97  First ACM SIGPLANWorkshop on DomainSpecific Languages, in Association with POPL 97, Paris, France, January 1997. University of Illinois Computer Science Report.44 S. Kamin and D. Hyatt. A specialpurpose language forpicturedrawing. In Ramming 64, pages 297310.Describes FPIC, a reconstruction of the original PICembedded in ML.45 K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak,and A. S. Peterson. Featureoriented domain analysisFODA feasibility study. Technical Report CMUSEI90TR21, Software Engineering Institute, CarnegieMellon University, 1990.FODA is a domain engineering approach emphasizingfeature analysis. A feature is defined as a prominent,uservisible characteristic of a software system. FODAaims at building up a feature model, consisting of a features diagram hierarchical decomposition of mandatory, alternative, or optional features, feature definitions, composition rules for features, and a rationale forfeatures indicating the tradeoffs. See also 20, 7046 G. Kiczales, J. Irwin, J. Lamping, J.M. Loingtier,C. Lopes, C. Maeda, and A. Mendhekar. Aspect oriented programming. In Kamin 43, pages 7588.Presents a novel programming technique, called aspectoriented programming AOP. This technique consists indescribing each aspect e.g. basic functionality, communication, coordination of a systems behaviour ina little language that allows it to be expressed in itsmost natural form. An aspect weaver merges these separate aspect descriptions into a single, efficient program.An important benefit of AOP is that it allows highleveldomainspecific programming for performancecriticaldomains. See also 2047 R. B. Kieburtz, L. McKinney, J. M. Bell, J. Hook,A. Kotov, J. Lewis, D. P. Oliva, T. Sheard, I. Smith,and L. Walton. A software engineering experiment insoftware component generation. In Proceedings of the18th International Conference on Software EngineeringICSE18, pages 542553. IEEE, 1996.Reports the results of an experiment in which a templatebased approach and a DSL approach to software generation were compared. Several subjects were monitoredwhile performing a number of development and maintenance tasks using alternatively template technology andDSL technology. Flexibility, productivity, reliability, andusability were measured. The DSL approach scored better on all counts.48 N. Klarlund and M. I. Schwartzbach. A domainspecificlanguage for regular sets of strings and trees. In DSLIEEE 28, pages 378386. An earlier version appearedin 64.Describes design and implementation of FIDO, a language to express large finitestate automata on large alphabets. Typical application is in verification and modelchecking.49 C. W. Krueger. Software reuse. ACM Computing Surveys, 242131183, June 1992.Categorizes, describes and compares existing approaches to software reuse, among which DSLs orapplication generators. Compared to the other approaches DSLs reduce the intellectual effort required toobtain an executable system from its specification. Limited availability and difficulty of building DSLs of optimal specificitygenerality are listed as disadvantages ofDSLs.50 D. A. Ladd and J. C. Ramming. Two application languages in software production. In USENIX Very HighLevel Languages Symposium Proceedings, pages 169178, October 1994.Describes how PRL5, an applicationoriented, declarative language used to maintain the integrity of databasesin the ATT 5ESS telecommunications switch, evolvedfrom an earlier, imperative domainspecific language,PRL, which in turn replaced a combination of Englishand C. The constraint descriptions expressed in PRL5can be used in more than one way, whereas a program tocheck constraints is useful only for performing that particular computation. A key lesson is that domainspecificlanguages should not be designed to describe computation, but to express useful facts from which one or morecomputations can be derived.51 D. Leijen and E. Meijer. Domain specific embeddedcompilers. In DSL99 27, pages 109122.Explains how a DSL SQL is taken as example can beembedded in Haskell by i coding an abstract syntax ofthe DSL as a Haskell datatype ii writing a code generator in Haskell that maps the abstract syntax to theconcrete syntax, and iii making Haskell call an external server which compiles and executes the generatedDSL code.52 F. van der Linden, editor. Development and Evolutionof Software Architectures for Product Families, volume1429 of Lecture Notes in Computer Science. SpringerVerlag, 1998.Proceedings of a workshop originating from the ESPRITARES project, which investigates software architecturesfor families of embedded systems.53 R. R. Macala, L. D. Sutckey, and D. C. Gross. Managing domainspecific productline development. IEEESoftware, 13, May 1996.Describes recommendations and lessons learned frommanaging a reusability project at Boeing in the area ofrealtime training systems for flight crews. Productlinedevelopment separates the softwaredevelopment process into two separate life cycles domain engineering, which aims to create reusable assets, and application engineering, which fields systems using those assets.Lessons learned include that productline developmentdemands careful strategic planning, a mature development process, and the ability to overcome organizationalresistance.54 N. Medvidovic and D. S. Rosenblum. Domains of concern in software architectures and architecture description languages. In Ramming 64, pages 199212.Gives a categorization of DSLs for describing softwarearchitectures.55 V. Menon and K. Pingali. A case for sourcelevel transformations in MATLAB. In DSL99 27, pages 5366.Three kinds of sourcetosource transformations for optimizing MATLAB programs are proposed and shown tobe effective. The transformations yield performance benefits additional to those obtained by optimizing compilation, and may be useful for other DSLs that are highlevel, untyped, and interpreted.56 L. Nakatani and M. Jones. Jargons and infocentrism. InKamin 43, pages 5974.Describes and advocates the development of DSLs asjargons domainspecific extensions of a tiny common base language. According to a new programmingparadigm infocentrism the application semantics forthese jargons can be programmed by providing actionsfor the constructs specific to the jargon only the traversal semantics is inherited from the base language. Because all jargons share the base syntax and semantics, itis easy to combine and reuse their definitions as well astheir tools. The InfoWiz technology which supports thedevelopment of jargons is discussed.57 L. H. Nakatani, M. A. Ardis, R. G. Olsen, and P. M.Pontrelli. Jargons for domain engineering. In DSL9927, pages 1524.Discusses the use of jargons see 56 in the domain ofconfiguration control.58 J. M. Neighbors. The Draco approach to constructingsoftware from reusable components. IEEE Transactionson Software Engineering, SE10556474, September1984.The Draco approach starts by capturing domain analysis information in a DSL. The objects and operationsof this DSL are refined into various DSLs of lower levels of abstraction, and finally into executable languages.These refinements capture design information implementation decisions. The Draco system supports thedevelopment and reuse of constellations of DSLs andrefinements. It offers tactics for refinement selection aswell as automatic consistency checking of the resultingsystem specification.59 J. K. Ousterhout. Scripting Higher level programmingfor the 21st century. IEEE Computer, March 1998.Discusses scripting languages, such as Perl, Tcl, and Visual Basic, which are designed for gluing applications,assuming the existence of a set of components that justneed to be connected together. Emphasizes that scriptinglanguages should be typeless and interpreted.60 J. Peterson and G. Hager. Monadic robotics. In DSL9927, pages 95108.Discusses the importance of monads in the implementation of tasks in Frob see 61, which help to achievemodularity and reusability.61 J. Peterson, P. Hudak, and C. Elliott. Lambda in motionControlling robots with Haskell. In PADL99, volume1551 of LNCS, pages 91105, 1999.Describes two domainspecific extensions of HaskellFrob a language for robot control and Fran a languagefor reactive animations.62 P. Pfahler and U. Kastens. Language design and implementation by selection. In Kamin 43, pages 97108.A language design system is presented which allows auser to design a DSL by selecting language features frommenus. After selection, an implementation of the DSLcan be generated. The system relies on domain designers to provide a definition of the design space, as well asspecification components for all possible language features.63 C. Pu, A. Black, C. Cowan, J. Walpole, and C. Consel.Microlanguages for operating system specialization. InKamin 43, pages 4957.Discusses the use of DSLs in the domain of operatingsystem specialization. A highlevel DSL is envisioned todescribe application behavior, which will be compiledinto a lowlevel DSL describing customized operatingsystem behavior.64 J. C. Ramming, editor. Proceedings of the USENIX Conference on DomainSpecific Languages, Berkeley, CA,October 1517 1997. USENIX Association.65 J. Reichwein, G. Rothermel, and M. Burnett. Slicingspreadsheets An integrated methodology for spreadsheet testing and debugging. In DSL99 27, pages 2538.Building on techniques for dynamic program slicing andprogram dicing, a fault localization technique for incremental spreadsheet debugging is developed. Using various kinds of visual clues, the technique is integrated intoa spreadsheet environment.66 D. Roberts and R. Johnson. Evolve frameworks intodomainspecific languages. In 3rd International Conference on Pattern Languages, Allerton Park, Ill., September 1996.Discusses 9 stages of framework development. Anobjectoriented framework evolves gradually, startingfrom three examples, moving via a whitebox framework,component library, pluggable objects, to a blackboxframework. The final, and most mature, stage is whenthe domain knowledge is sufficiently stable to merit thedevelopment of a domainspecific language or visualbuilder to access the framework.67 P.H. Salus, editor. Little Languages, volume III of Handbook of Programming Languages. MacMillan, 1998.This book contains a collection of mostly reprints andonly a few original papers describing DSLs. It contains, for instance, papers like Little Languages Bentley 7, A system for typesettting mathematics EQNKernighan and Cherry, and an overview of the Documenters Workbench Akkerhuis covering TROFF andseveral DSLs for describing graphics, chemical formulae, and the like. Other chapters cover AWK, SED, SQL,TCLTK, PERL and PYTHON. The most original papersare a survey of DSLs and domainspecific extension languages by Hudak and an elaborate description of LittleMusic Languages by Langston.68 T. Sheard, Z. Benaissa, and E. Pasalic. DSL implementation using staging and monads. In DSL99 27, pages8194.Discusses how the use of staging separating compiletime computations from run time ones and monads forcapturing effects and actions of the target code lead to asimple, reusable, controlable, and correct DSL methodology.69 M. Simos. Organization domain modeling ODMFormalizing the core domain modeling life cycle. InM. Samadzeh and M. Zand, editors, Proceedings of theSymposium on Software Reusability SSR95, pages 196205, August 1995. ACM Software Engineering Notes.Summarizes the key elements of the ODM domain engineering methodology. The full description is given in70.70 M. Simos, D. Creps, C. Klinger, L. Levine, andD. Allemang. Organization domain modelling ODMguidebook version 2.0. Technical Report STARSVCA02500100, Synquiry Technologies, Inc, 1996.A comprehensive description of the ODM approach todomain engineering. The three main ODM steps are1 plan the domain, selecting objectives, stakeholders, and a set of boundary decisions to scope the domain. 2 model the domain, building a domain lexicon, and describing the concepts and features, as wellas their commonalities and variabilities. 3 optionalengineer an asset base of components by combining features and customers in novel ways. ODM emphasizes existing legacy software systems as valuable sources ofdomain knowledge. It takes the domain as a set of systems point of view, rather than the domain as the realworld viewpoint.71 E. G. Sirer and B. N. Bershad. Using production grammars in software testing. In DSL99 27, pages 114.Describes lava, a DSL for specifying production grammars. These are used to generate sentences over a language, for the purpose of testing tools implementingthat language. Experience with lava demonstrates thata special purpose language for production grammarscan bring high coverage, simplicity, manageability, andstructure to the testing effort. Observe that the production grammar approach can also be used to for testingDSLtools.72 Y. Smaragdakis and D. Batory. DiSTiL A transformation library for data structures. In Ramming 64, pages257270.Describes DiSTiL, a DSL for describing container datastructures in C, implemented on top of MicroSofts Intentional Programming IP system.73 D. E. Stevenson and M. M. Fleck. Programming language support for digitized images or, the monsters inthe closet. In Ramming 64, pages 271284.Describes the image manipulation language Envision,implemented as an extension of Scheme.74 J. M. Stichnoth and T. Gross. Code composition as animplementation language for compilers. In Ramming64, pages 119132.Describes the ANSI C compiler framework Catacombthat supports code composition. By providing userdefined code templates describing new language constructs such as parallel array assignment and a fixedcode composition mechanism inside the compiler, newconstructs can be implemented in the same way as standard ones. See also 30.75 R. N. Taylor, W. Tracz, and L. Coglianese. Software development using domainspecific software architectures.ACM SIGSOFT Software Engineering Notes, 2052737, 1995.Provides the material used for a course on DSSA,DomainSpecific Software Architectures, which aims atthe reduction in time and cost of producing specific application systems within a supported domain. The paper covers key examples, architecture representation formalisms, domain engineering, and the DSSA process.See also 20, 7076 S. A. Thibault, R. Marlet, and C. Consel. Domainspecific languages From design to implementation application to video device drivers generation. In DSLIEEE 28, pages 363377. An earlier version appearedin 64.A video card stores and displays images on a computerdisplay. Each card is programmed by similar, but highlyvendorspecific, instructions. The authors exploit thissimilarity by designing a DSL for specifying drivers forvideo cards in the context of the XFree86 implementation of X windows. This Graphic Adaptor Language isimplemented in two stages a C library provides a lowlevel abstract machine that is used by an interpreter forthe DSL. The Tempo partial evaluator for C is used toeliminate the overhead of interpretation and of the generality of the abstract machine. Includes a discussion ofthe merits of the DSL approach in this domain.77 D. C. Wang, A. W. Appel, J. L. Korn, and C. S. Serra.The Zephyr abstract syntax description language. InRamming 64, pages 21328.Presents the Abstract Syntax Description LanguageASDL. Reports the implementation of a tool that converts ASDL descriptions into C, C, Java, or ML code.The generated code defines datastructures corresponding to this abstract syntax as well as functions for reading and writing abstract terms to a standard flattenedrepresentation. ASDL has been used to respecify thecompiler intermediate format SUIF.78 J. Withey. Investment analysis of software assets forproduct lines. Technical Report CMUSEI96TR010,Software Engineering Institute, 1996.Presents a model for analyzing the expected benefitsfrom investing in domainspecific software product lines.One of the key concepts is economy of scope, which isa condition where fewer inputs such as effort and timeare needed to produce a greater variety of outputs. Bycontrast, economy of scale is achieved where fewer inputs are needed to produce greater quantities of a singleoutput.
