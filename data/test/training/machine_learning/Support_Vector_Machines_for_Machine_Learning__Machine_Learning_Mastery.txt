Support Vector Machines for Machine Learning - Machine Learning Mastery Navigation Machine Learning Mastery Making developers awesome at machine learning Start Here       Blog       Products       About       Contact Want help with algorithms? Take the FREE Mini-Course . Home Empty Menu Return to Content Support Vector Machines for Machine Learning By Jason Brownlee on April 20, 2016 in Machine Learning Algorithms Facebook 0 Twitter 0 Google+ 5 LinkedIn 32 Support Vector Machines are perhaps one of the most popular and talked about machine learning algorithms. They were extremely popular around the time they were developed in the 1990s and continue to be the go-to method for a high-performing algorithm with little tuning. In this post you will discover the Support Vector Machine (SVM) machine learning algorithm. After reading this post you will know: How to disentangle the many names used to refer to support vector machines. The representation used by SVM when the model is actually stored on disk. How a learned SVM model representation can be used to make predictions for new data. How to learn an SVM model from training data. How to best prepare your data for the SVM algorithm. Where you might look to get more information on SVM. SVM is an exciting algorithm and the concepts are relatively simple. This post was written for developers with little or no background in statistics and linear algebra. As such we will stay high-level in this description and focus on the specific implementation concerns. The question around why specific equations are used or how they were derived are not covered and you may want to dive deeper in the further reading section. Let’s get started. Support Vector Machines for Machine Learning Photo by Francisco Barberis , some rights reserved. Maximal-Margin Classifier The Maximal-Margin Classifier is a hypothetical classifier that best explains how SVM works in practice. The numeric input variables (x) in your data (the columns) form an n-dimensional space. For example, if you had two input variables, this would form a two-dimensional space. A hyperplane is a line that splits the input variable space. In SVM, a hyperplane is selected to best separate the points in the input variable space by their class, either class 0 or class 1. In two-dimensions you can visualize this as a line and let’s assume that all of our input points can be completely separated by this line. For example: B0 + (B1 * X1) + (B2 * X2) = 0 Where the coefficients (B1 and B2) that determine the slope of the line and the intercept (B0) are found by the learning algorithm, and X1 and X2 are the two input variables. You can make classifications using this line. By plugging in input values into the line equation, you can calculate whether a new point is above or below the line. Above the line, the equation returns a value greater than 0 and the point belongs to the first class (class 0). Below the line, the equation returns a value less than 0 and the point belongs to the second class (class 1). A value close to the line returns a value close to zero and the point may be difficult to classify. If the magnitude of the value is large, the model may have more confidence in the prediction. The distance between the line and the closest data points is referred to as the margin. The best or optimal line that can separate the two classes is the line that as the largest margin. This is called the Maximal-Margin hyperplane. The margin is calculated as the perpendicular distance from the line to only the closest points. Only these points are relevant in defining the line and in the construction of the classifier. These points are called the support vectors. They support or define the hyperplane. The hyperplane is learned from training data using an optimization procedure that maximizes the margin. Get your FREE Algorithms Mind Map Sample of the handy machine learning algorithms mind map. I've created a handy mind map of 60+ algorithms organized by type. Download it, print it and use it.  Download For Free Also get exclusive access to the machine learning algorithms email mini-course.     Soft Margin Classifier In practice, real data is messy and cannot be separated perfectly with a hyperplane. The constraint of maximizing the margin of the line that separates the classes must be relaxed. This is often called the soft margin classifier. This change allows some points in the training data to violate the separating line. An additional set of coefficients are introduced that give the margin wiggle room in each dimension. These coefficients are sometimes called slack variables. This increases the complexity of the model as there are more parameters for the model to fit to the data to provide this complexity. A tuning parameter is introduced called simply C that defines the magnitude of the wiggle allowed across all dimensions. The C parameters defines the amount of violation of the margin allowed. A C=0 is no violation and we are back to the inflexible Maximal-Margin Classifier described above. The larger the value of C the more violations of the hyperplane are permitted. During the learning of the hyperplane from data, all training instances that lie within the distance of the margin will affect the placement of the hyperplane and are referred to as support vectors. And as C affects the number of instances that are allowed to fall within the margin, C influences the number of support vectors used by the model. The smaller the value of C, the more sensitive the algorithm is to the training data (higher variance and lower bias). The larger the value of C, the less sensitive the algorithm is to the training data (lower variance and higher bias). Support Vector Machines (Kernels) The SVM algorithm is implemented in practice using a kernel. The learning of the hyperplane in linear SVM is done by transforming the problem using some linear algebra, which is out of the scope of this introduction to SVM. A powerful insight is that the linear SVM can be rephrased using the inner product of any two given observations, rather than the observations themselves. The inner product between two vectors is the sum of the multiplication of each pair of input values. For example, the inner product of the vectors [2, 3] and [5, 6] is 2*5 + 3*6 or 28. The equation for making a prediction for a new input using the dot product between the input (x) and each support vector (xi) is calculated as follows: f(x) = B0 + sum(ai * (x,xi)) This is an equation that involves calculating the inner products of a new input vector (x) with all support vectors in training data. The coefficients B0 and ai (for each input) must be estimated from the training data by the learning algorithm. Linear Kernel SVM The dot-product is called the kernel and can be re-written as: K(x, xi) = sum(x * xi) The kernel defines the similarity or a distance measure between new data and the support vectors. The dot product is the similarity measure used for linear SVM or a linear kernel because the distance is a linear combination of the inputs. Other kernels can be used that transform the input space into higher dimensions such as a Polynomial Kernel and a Radial Kernel. This is called the Kernel Trick . It is desirable to use more complex kernels as it allows lines to separate the classes that are curved or even more complex. This in turn can lead to more accurate classifiers. Polynomial Kernel SVM Instead of the dot-product, we can use a polynomial kernel, for example: K(x,xi) = 1 + sum(x * xi)^d Where the degree of the polynomial must be specified by hand to the learning algorithm. When d=1 this is the same as the linear kernel. The polynomial kernel allows for curved lines in the input space. Radial Kernel SVM Finally, we can also have a more complex radial kernel. For example: K(x,xi) = exp(-gamma * sum((x – xi^2)) Where gamma is a parameter that must be specified to the learning algorithm. A good default value for gamma is 0.1, where gamma is often 0 < gamma < 1. The radial kernel is very local and can create complex regions within the feature space, like closed polygons in two-dimensional space. How to Learn a SVM Model The SVM model needs to be solved using an optimization procedure. You can use a numerical optimization procedure to search for the coefficients of the hyperplane. This is inefficient and is not the approach used in widely used SVM implementations like LIBSVM . If implementing the algorithm as an exercise, you could use stochastic gradient descent . There are specialized optimization procedures that re-formulate the optimization problem to be a Quadratic Programming problem. The most popular method for fitting SVM is the Sequential Minimal Optimization (SMO) method that is very efficient. It breaks the problem down into sub-problems that can be solved analytically (by calculating) rather than numerically (by searching or optimizing). Data Preparation for SVM This section lists some suggestions for how to best prepare your training data when learning an SVM model. Numerical Inputs : SVM assumes that your inputs are numeric. If you have categorical inputs you may need to covert them to binary dummy variables (one variable for each category). Binary Classification : Basic SVM as described in this post is intended for binary (two-class) classification problems. Although, extensions have been developed for regression and multi-class classification. Further Reading Support Vector Machines are a huge area of study. There are numerous books and papers on the topic. This section lists some of the seminal and most useful results if you are looking to dive deeper into the background and theory of the technique. Vladimir Vapnik , one of the inventors of the technique has two books that are considered seminal on the topic. They are very mathematical and also rigorous. The Nature of Statistical Learning Theory , Vapnik, 1995 Statistical Learning Theory , Vapnik, 1998 Any good book on machine learning will cover SVM, below are some of my favorites. An Introduction to Statistical Learning: with Applications in R , Chapter 8 Applied Predictive Modeling , Chapter 13 The Elements of Statistical Learning: Data Mining, Inference, and Prediction  Chapter 12 There are countless tutorials and journal articles on SVM. Below is a link to a seminal paper on SVM by Cortes and Vapnik and another to an excellent introductory tutorial. Support-Vector Networks  [PDF] by Cortes and Vapnik 1995 A Tutorial on Support Vector Machines for Pattern Recognition [PDF] 1998 Wikipedia provides some good (although dense) information on the topic: Support Vector Machine on Wikipedia Wikibook on Support Vector Machines Finally, there are a lot of posts on Q&A sites asking for simple explanations of SVM, below are two picks that you might find useful. What does support vector machine (SVM) mean in layman’s terms? Please explain Support Vector Machines (SVM) like I am a 5 year old Summary In this post you discovered the Support Vector Machine Algorithm for machine learning.  You learned about: The Maximal-Margin Classifier that provides a simple theoretical model for understanding SVM. The Soft Margin Classifier which is a modification of the Maximal-Margin Classifier to relax the margin to handle noisy class boundaries in real data. Support Vector Machines and how the learning algorithm can be reformulated as a dot-product kernel and how other kernels like Polynomial and Radial can be used. How you can use numerical optimization to learn the hyperplane and that efficient implementations use an alternate optimization scheme called Sequential Minimal Optimization. Do you have any questions about SVM or this post? Ask in the comments and I will do my best to answer. Frustrated With Machine Learning Math? See How Algorithms Work in Minutes ...with just arithmetic and simple examples Discover how in my new Ebook: Master Machine Learning Algorithms It covers explanations and examples of 10 top algorithms , including: Linear Regression , k-Nearest Neighbors , Support Vector Machines and much more... Finally, Pull Back the Curtain on Machine Learning Algorithms Skip the Academics. Just Results. Click to learn more . About Jason Brownlee Dr. Jason Brownlee is a husband, proud father, academic researcher, author, professional developer and a machine learning practitioner. He is dedicated to helping developers get started and get good at applied machine learning. Learn more . View all posts by Jason Brownlee → Learning Vector Quantization for Machine Learning Bagging and Random Forest Ensemble Algorithms for Machine Learning 5 Responses to Support Vector Machines for Machine Learning Qichang September 28, 2016 at 12:54 pm # Hi Jason, As always thanks for your great tutorials. I have a question regarding the parameter C. You mention that lower C makes more sensitive to training data. My understanding is the hyperplane will be wiggling with small value of C. However, in sci-kit learn, it states “A low C makes the decision surface smooth, while a high C aims at classifying all training examples correctly.” ( http://scikit-learn.org/stable/modules/svm.html#parameters-of-the-rbf-kernel ) I am confused which one is correct. Can you please shed some light on it? Thanks in advance. Reply Jason Brownlee September 29, 2016 at 8:31 am # Thanks Qichang. I too find the scikit-learn description confusing. Perhaps it is a modified implementation. Reply Qichang September 30, 2016 at 11:33 am # Hi Jason, I found the notes of SVM in Andrew Ng’s machine learning class ( http://www.holehouse.org/mlclass/12_Support_Vector_Machines.html ) It states that: Large C gives a hypothesis of low bias high variance –> overfitting Small C gives a hypothesis of high bias low variance –> underfitting And it is in line with the description of sci-kit learn. The definition of C is the inverse of lambda which makes sense in this way. Reply Jason Brownlee October 1, 2016 at 7:59 am # Great find, thanks Qichang. I’ll investigate and fix up my explanation. Reply Jason Brownlee October 3, 2016 at 7:53 am # I base my understanding from “An Introduction to Statistical Learning”, page 347 that states: When C is small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance. On the other hand, when C is larger, the margin is wider and we allow more violations to it; this amounts to fitting the data less hard and obtaining a classifier that is potentially more biased but may have lower variance. This matches what I have written above. Reply Leave a Reply Click here to cancel reply. Comment Name (required) Email (will not be published) (required) Website Understand Machine Learning Algorithms! Sick of all the advanced math? Need step-by-step explainations for top algorithms? Want worked examples in spreadsheets? Finally Understand Machine Learning Algorithms! Popular
