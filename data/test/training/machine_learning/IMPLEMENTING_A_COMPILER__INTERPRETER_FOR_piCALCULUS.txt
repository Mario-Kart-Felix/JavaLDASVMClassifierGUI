IMPLEMENTING ACOMPILER  INTERPRETER FOR CALCULUSbyChristian TaboneSupervisor Dr. Adrian FrancalanzaDEPARTMENT OF COMPUTER SCIENCE ANDARTIFICIAL INTELLIGENCEUNIVERSITY OF MALTAMay 2006Submitted in partial fulfillment of the requirements for the degree of B.Sc. I.T. Hons.To my loving parents who have always supported methrough the past years and have always been there for me.DeclarationI, the undersigned, declare that the Final Year Project report submitted is my work, exceptwhere acknowledged and referenced.AcknowledgementsI would like to express my appreciation to Adrian Francalanza, my supervisor, for hisencouragement and exceptional guidance.I would also like show my gratitude to my family and to all my friends, for their supportthroughout my studies.AbstractWe consider Calculus as the foundation of our study, by analyzing the syntax and semantics that this notation offers. We then describe a simple typing convention that willbe used to typecheck Calculus programs. This is followed by the description of anintermediate representation of the Calculus, and we suggest how serval machine implementations can use this representation to simulate Calculus programs. A parser andcompiler are constructed. These will translate Calculus program into this intermediaterepresentation. Subsequently, we concentrate on David N. Turners Abstract Machine,to develop a StandAlone Virtual Machine capable of interpreting Calculus, and simulating a correct execution on the semantic meaning of the given program. We tackle anumber of optimizations that are incorporated with the architecture of the StandAlonemachine, to produce a more efficient simulation. We present the architecture for an Interactive Virtual Machine to allow a user to communicate with the program during execution,and we give an illustration on the differences between a StandAlone virtual machine andan Interactive virtual machine. We then verify the correctness of the virtual machinesimplementations, by presenting a number of examples. We conclude by examining thecapability of the Interactive virtual machine, in creating an abstract layer between theimplementation details of Calculus programs and the user. We illustrate how a typical user is unable to distinguish between two Calculus programs, that offer the samefunctionalities, but have a different internal implementation.Contents1 Introduction 11.1 Aims and Objectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21.2 Chapter Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Background 52.1 The Polyadic Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . 52.1.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62.1.2 Reduction Semantics . . . . . . . . . . . . . . . . . . . . . . . . 92.1.3 Simplifications and Assumptions . . . . . . . . . . . . . . . . . . 162.2 Channel Typing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172.3 Related Studies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222.3.1 A PICTtoC Compiler . . . . . . . . . . . . . . . . . . . . . . . 232.3.2 NomadicPICT . . . . . . . . . . . . . . . . . . . . . . . . . . . 242.3.3 The Fusion Machine . . . . . . . . . . . . . . . . . . . . . . . . 253 Compiler Design 273.1 The Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283.1.1 The Include Section . . . . . . . . . . . . . . . . . . . . . . . . 283.1.2 Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . 303.1.3 Calculus Definitions . . . . . . . . . . . . . . . . . . . . . . . 313.1.4 The Main Body . . . . . . . . . . . . . . . . . . . . . . . . . . . 323.2 The Parser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32iCONTENTS3.2.1 Visitor Nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343.3 The TypeChecker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353.4 The Compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363.4.1 Intermediate Code Representation . . . . . . . . . . . . . . . . . 373.4.2 Intermediate Code to String Translator . . . . . . . . . . . . . . . 413.5 A Minor Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . 424 A StandAlone Virtual Machine 434.1 Correctness Of The Virtual Machine . . . . . . . . . . . . . . . . . . . . 444.2 StandAlone Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . 474.3 Handling Process Communication . . . . . . . . . . . . . . . . . . . . . 484.3.1 Optimizing The Service Heap . . . . . . . . . . . . . . . . . . . 524.4 Handling NonCommunication Tasks . . . . . . . . . . . . . . . . . . . 534.4.1 Optimizing The Management Of Tasks . . . . . . . . . . . . . . 564.5 Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575 An Interactive Virtual Machine 595.1 StandAlone vs Interactive . . . . . . . . . . . . . . . . . . . . . . . . . 605.2 Correctness Of The Virtual Machine . . . . . . . . . . . . . . . . . . . . 635.3 Interactive Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . 645.3.1 Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 665.4 Handling Process Communication . . . . . . . . . . . . . . . . . . . . . 675.4.1 Internal Reduction . . . . . . . . . . . . . . . . . . . . . . . . . 685.5 Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 695.6 Graphical User Interface Design . . . . . . . . . . . . . . . . . . . . . . 706 Evaluation 726.1 Testing the StandAlone Virtual Machine . . . . . . . . . . . . . . . . . 736.1.1 Test case  Memory cell . . . . . . . . . . . . . . . . . . . . . . 736.1.2 Test case  Changing the network of communication . . . . . . . 74iiCONTENTS6.1.3 Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 766.2 Testing the Interactive Virtual Machine . . . . . . . . . . . . . . . . . . . 766.2.1 Test case  Stack A . . . . . . . . . . . . . . . . . . . . . . . . . 766.2.2 Test case  Program Details Abstraction . . . . . . . . . . . . . . 796.2.3 Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806.3 Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817 Conclusions and Future Work 82Appendix AExamples of Calculus Programs 84A.1 Memory cell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85A.2 Changing the network of communication . . . . . . . . . . . . . . . . . . 85A.3 Stack A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86A.4 Stack B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87Appendix BEBNF for the Language 88Appendix CClass Diagrams 90Appendix DUser Manual 95Appendix EContents of the CDRom 100Bibliography 101iiiList of Tables2.1 Syntax for the Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . 72.2 Structural equivalence rules for Calculus . . . . . . . . . . . . . . . . 102.3 Reduction rules for the Calculus . . . . . . . . . . . . . . . . . . . . . 122.4 Runtime errors for Calculus . . . . . . . . . . . . . . . . . . . . . . . 192.5 Typing syntax for Calculus . . . . . . . . . . . . . . . . . . . . . . . . 202.6 Typechecking rules for Calculus . . . . . . . . . . . . . . . . . . . . 22ivList of Figures1.1 Overview of the objectives . . . . . . . . . . . . . . . . . . . . . . . . . 33.1 Compiler Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . 283.2 A typical Calculus program written in Language . . . . . . . . . . . 293.3 Abstract Syntax Tree example . . . . . . . . . . . . . . . . . . . . . . . 333.4 The compiler translates an AST into Intermediate Code . . . . . . . . . . 363.5 Intermediate representation of a process . . . . . . . . . . . . . . . . . . 373.6 Class diagram  Task class and subclasses . . . . . . . . . . . . . . . . . 384.1 Converting Calculus terms to machine terms, and viceversa . . . . . . 454.2 Correctness of machine . . . . . . . . . . . . . . . . . . . . . . . . . . . 464.3 Correctness of machine . . . . . . . . . . . . . . . . . . . . . . . . . . . 474.4 Simple design for the StandAlone Virtual Machine . . . . . . . . . . . . 484.5 StandAlone Machine algorithm . . . . . . . . . . . . . . . . . . . . . . 494.6 StandAlone machine with optimized service heap . . . . . . . . . . . . . 524.7 StandAlone machine applying all the discussed optimizations . . . . . . 575.1 User interacting with machine . . . . . . . . . . . . . . . . . . . . . . . 605.2 Abstraction layer provided by the Interactive Virtual Machine . . . . . . . 625.3 Correctness of the Interactive Machine . . . . . . . . . . . . . . . . . . . 645.4 Interactive Virtual Machine Architecture . . . . . . . . . . . . . . . . . . 655.5 Channel Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . 675.6 Environment Mappings between the user and the virtual machine . . . . . 70vLIST OF FIGURES5.7 Proposed table showing the current state of the machine . . . . . . . . . . 716.1 Evaluating the correctness of the virtual machines . . . . . . . . . . . . . 736.2 Trace of stack program . . . . . . . . . . . . . . . . . . . . . . . . . . . 786.3 Program details are abstracted away from the user . . . . . . . . . . . . . 80C.1 PiParserVisitor Class Diagram Visitor interface generated by JavaCC . . 91C.2 TaskManager Class Diagram . . . . . . . . . . . . . . . . . . . . . . . . 92C.3 Channel Class Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . 93C.4 Machine Class Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . 94D.1 The editors toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95D.2 Application running in editing mode . . . . . . . . . . . . . . . . . . . . 96D.3 MDI support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96D.4 The editors sidebar . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97D.5 Showing the Syntax Tree for the program . . . . . . . . . . . . . . . . . 97D.6 Running the StandAlone virtual machine . . . . . . . . . . . . . . . . . 98D.7 Running the Interactive virtual machine . . . . . . . . . . . . . . . . . . 99viChapter 1IntroductionThe Calculus is part of the family of Process Calculi, which are all formal mathematicalparadigms, used to model concurrent systems. The notation of Process Calculi describe aframework based on processes which execute concurrently, during which a pair of theseprocesses can synchronize by communicating. The Calculus was developed with exclusive interest on the mobility of process communication, in concurrent systems. It wasoriginally developed by Robin Milner, but many others contributed to this growing research. Throughout this dissertation we will be dealing with the Polyadic Calculus,which is a variant to the original Calculus.The descriptive ability that Calculus offers, emerges from the concept of naming, wherecommunication links, known as channels, are referenced using a naming convention.Hence, mobility arises by having processes communicating the channel names. This is aremarkable primitive perception, however, it gives the Calculus a practical expressivepower, which, as a result, can provide building blocks for other complex concurrent languages. It would serve as a flexible intermediate language for compilers of concurrentlanguages  David N. Turner.1CHAPTER 1. INTRODUCTIONOur aim throughout this dissertation will be that of developing a machine capable of understanding Calculus notation, and which gives an interpretation to the meaning behindthe given description. This leads us to the development of a compiler for the Calculusnotation, which will understand the notation and translate it to a more manageable form.Hence, an interpreting machine would apply rules to the Calculus notation, to give aninterpretation.1.1 Aims and ObjectivesThe following is a list of the main objectives we shall be trying to achieve through thisstudy. The order in which these are given, reflects the order in which they should becarried out, since these goals build up on each other. Figure 1.1 gives a depictive outlineof what we shall try to achieve, showing how the goals depend on each other. Learn what Calculus is about, comprehend its notation and variations to it, andbe aware of the logical programming that can be constructed by Calculus. Reflect on other studies that have been completed, in order to picture where thisdissertation stands next to these studies, and to gather ideas on what has alreadybeen achieved by others, and how this was achieved. Design a Parser and Compiler, which serves to translate Calculus programs intoan intermediate code representation, where this representation is to be used by various Virtual Machines, each of which can be developed to accomplish differenttasks. Develop a Virtual Machine capable of interpreting the intermediate code of Calculus programs, and perform an isolated execution of this code.2CHAPTER 1. INTRODUCTION Develop another Virtual Machine, which extends the functionality of the previousmachine, by allowing external sources to interact during the execution of the program.Figure 1.1 Overview of the objectives1.2 Chapter OverviewFollowing this introductory chapter, the structure of this document almost follows theaims given in Section 1.1. Chapter 2 of this dissertation gives the background and theliterature review on the critical points about the Calculus that are required to be understood for the rest of the study. We target the syntax and semantics of Calculus, wediscuss a simple typing system and we look at related work.In Chapter 3 we go on to the design of the translation modules, which involves the parsing of the Calculus source code, typechecking the program, and compiling it into anintermediate representation. We outline the components that make up the intermediaterepresentation.Chapter 4 gives the development of a StandAlone Virtual Machine, which is mostly basedon Turners Abstract MachineTur95. We give a framework on which Calculus programs are correctly executed, followed by a number of optimizations to aid the performance of the Virtual Machine.3CHAPTER 1. INTRODUCTIONWe then move on the Chapter 5, where we suggest the development of an InteractiveVirtual Machine, and what benefits we acquire. We discuss a different design from that ofthe StandAlone Virtual Machine. However, we will give an analysis of the optimizationsincluded in the StandAlone Virtual Machine and investigate if these optimizations willstill be valid, when adopted by the Interactive Virtual Machine.In Chapter 6 we give an evaluation analysis of the modules that have been developedthroughout this dissertation. We give special interest to the Interactive Virtual Machinewhere we investigate this level of abstraction that this machine offers to the user. Wedevelop two Calculus programs, with the same functionalities but different implementation details, and we discuss how the user is unable to distinguish one from the other.We give our concluding remarks in Chapter 7, where we investigate what benefits havebeen acquired from this dissertation. We even give the limitation of the final application,and some ideas about the vision for possible future works.4Chapter 2BackgroundThis chapter consists of the literature review regarding the Calculus. We introduce ThePolyadic Calculus by defining the Syntax Rules, Structural Rules and Reduction Rules,which we will use to build the compiler in Chapter 3 and the virtual machines in Chapters4 and 5. We then give an overview of a simple typing system, such that we ensure thatthe communication between channels is done accurately. Finally we take a look at otherstudies, which are tightly related to this dissertation. These studies have developed variousmachines and architectures for Calculus, all of which, give us a motivation for the restof this project.2.1 The Polyadic CalculusThe Calculus notation models parallel processes, which can perform input or output actions through channels, thus allowing the processes to communicate. The message whichis sent from one process to the other is a name, which gives a reference to a channel.5CHAPTER 2. BACKGROUNDThe communication of the channels names themselves allow the processes to dynamically change the network of relations between them, through which communication isestablished.Here we will be dealing with the Polyadic Calculus, which differs slightly from theoriginal Calculus the Monadic Calculus. The difference between the two is that, inMonadic Calculus, a single channel name is allowed to be exchanged during communication, while in the Polyadic Calculus, a list of channel names, known as a tuple, canbe exchanged during a single interaction, where this tuple can possibly be empty.In the Polyadic Calculus, a typing system for the channels is required to prevent aritymismatch between the input action and the output action. Arity mismatch happens whenthe number of sent channels does not match the number of arguments of the receivingaction.Interested readers should refer to the book Communicating and Mobile Systems TheCalculus, by Robin Miler Mil99. In his book, Milner gathers most of his work, andintroduces Calculus, as the new way of modeling communication. This book andother technical reports Mil89a, Mil89b, again by Milner, were very useful during thestudy of this project.2.1.1 SyntaxThe syntax of the Calculus langauge that will be used throughout this dissertation isgiven in Table 2.1. In the Calculus the simplest form of entity is a name. A nameis regarded as the referencing convention for a channel, through which processes cancommunicate.6CHAPTER 2. BACKGROUNDP,Q,R, S  P  Q Concurrency if x  y then P elseQ Conditional Statement zP Channel Scoping cv1, . . . , vn.P Output Action cx1, . . . , xn.P Input Action  cx1, . . . , xn.P Replicated Input Action .P Internal Action 0 Null ProcessTable 2.1 Syntax for the CalculusExample 2.1 Using names The action ca in this system has the potential to outputsend the channel named a. This channel must be known since the action is trying tocommunicate it, hence it is using the channel name a.ca.QThe Calculus notation makes use of channel variables. A variable represents a placeholder for a channel which is currently unknown, but has the potential to become known.Example 2.2 Using variables In this example, the action cx has the potential toinput receive a channel, and since it is not yet known which channel it will receive, thenthe variable x is used.cx.PThe following is a description of the meanings behind the syntax given in Table 2.1.Further indepth analysis can be found in SW03a.Concurrency means that process P runs independent of process Q. Both processescan communicate channel names between them by performing inputoutput actions on7CHAPTER 2. BACKGROUNDa common channel. When multiple processes are running concurrently, we have nondeterministic communication.A Conditional Statement will check for the equality of the two channels x and y, x  y.If these channels are found to be equal, then the computation continues as P . Otherwise,if the channels are not equal, the computation continues as Q.Channel Scoping1 restricts the scope of the given name z, reducing its usage only to theprocess P . For instance, in example 2.3, the name z is private or bound to the systemzx.P . Channel names which are not bound to any process are said to be free names.Example 2.3 Channel scoping The process zx.P is unable to interact with theprocess za.Q through channel z, since these are actually different channels.za.Q  zzx.PAn Output Action will communicate with another process, by sending the tuple of channelnames y1, ...yn, through the channel c. When this is completed, the execution of theprocess continues as P .An Input Action communicates with another process through channel c, where it receivesa tuple of channel names. As we have already described, we have a tuple of variables,y1, ...yn, awaiting to receive the channel names from another process during communication. Thus these variables are substituted to channel names throughout the process, oncethese names are received.This brings us to another channel scoping concept. Since occurrences of the variables in aprocess will be substituted by the channel names, these variables are bound to the processby the input action.1Note that this is not the only operator for channel scoping, but this is indirectly obtained through theInput Action8CHAPTER 2. BACKGROUNDExample 2.4 Channel scoping by input actions Note how in this system, the processescx.xb.Q and xy.R give the impression that these processes have potential to communicate through x. However, note how x is bound to the process, cx.xb.Q, becauseof the preceding input.ca.P  cx.xb.Q  xy.R  P  ab.Q  xy.RA Replicated Input Action has the same behavior as an input action. The difference is thatupon communication, it produces a copy of itself before proceeding with the execution,thus leaving an intact copy within the system.Example 2.5 Replicated input action The action cx releases a copy of the wholeprocess that executes this action, upon communicating with another process.ca.Q  cx.P  cx.P  Q  PAn Internal Action is regarded as an unobservable action which will simply continue asP , without affecting any surrounding processes.A Null Process is an inactive process which cannot proceed to any further computations,and hence, it would simply terminate.2.1.2 Reduction SemanticsThe semantics of a language, is the meaning behind the expressions or the arrangementof terms, which are composed from the syntax of the language. In Calculus we dealwith Reduction Semantics, which is the meaning behind the reduction of processes whenthese communicate. These semantics will be defined using a relation, , between twoprocesses, showing how a process reduces its state, after that this has performed a single9CHAPTER 2. BACKGROUNDsassoc P1  P2  P3  P1  P2  P3scomm P  Q  Q  Psnull P  0  Psscope zP  Q  zP  Q if z  fnQsscopecomm zwP  wzPsscopenull z0  0Table 2.2 Structural equivalence rules for Calculusaction. For instance the process P is reduced to a different state as Q.P  QWe will use the closure of the relation, , to denote the reduction of a process P to Q inan arbitrary number of steps.P  QWe start familiarizing with the semantic meaning of our langauge by defining a set ofaxioms for the structure of the langauge. These Structural Equivalence Rules are given inTable 2.2. Such equivalences between different process states, permit us to manipulate thearrangement of the terms of a Calculus program, without affecting the semantics of theprogram. Hence, these equivalences give us control over the sequence of the terms, suchthat, Reduction Semantics can be applied to processes whenever applicable, regardless ofthe structure of the program.sassoc means that the concurrency operator, , is associative between processes, meaningthat the order in which parallel processes are executed does not affect the end result.Parentheses are used to denote operator precedence, however, it is important to note thatthe system will still execute nondeterministically.Example 2.6 Associativity Note how the process, cx.P , can still reduce nondeter10CHAPTER 2. BACKGROUNDministically with one of the other processes.ca.Q  cx.P  cb.R  ca.Q  cx.P   cb.Rscomm denotes that, any two processes executing in parallel are commutative, meaningthat the two can be interchanged between the concurrency operator, , and still producethe same result.Example 2.7 Commutativity Note how the position of the following two processeswithin this system, does not affect the communication.ca.Q  cx.P  ca.Q  cx.Psnull implies that a process P executing in parallel with a null process, 0, is not affectedwith the presence of the null process, and neither is it affected if this null process isdiscarded.sscope implies that channel scoping applied on a process, P , can be applied to processQ, for a channel z, if the channel name z is part of the set of free names of Q. This meansthat the name z is not used within the process Q. Hence if its scope had to be expandedfrom P to P  Q, it will not affect the execution.Example 2.8 Structural equivalence in channel scoping In the following system thescoping of the channel name z is expandedreduced without affecting the end result, sincethe process cx.0 is unaware of the channel name z.zza.0  cx.0  zza.0  cx.0sscopecomm denotes that the sequence of two scoping operators is commutative, meaning that the two can be interchanged without changing the end result.11CHAPTER 2. BACKGROUNDrcommunicationcx1, ..., xn.P  cy1, ..., yn.Q  Py1,...,ynx1,...,xn  Qrreplicatedcommunicationcx1, ..., xn.P  cy1, ..., yn.Q  cx1, ..., xn.P  Py1,...,ynx1,...,xn  Qrtau rstruct.P  PP  P1 P1  Q1 Q1  QP  Qrconcurrent rscopeP  QP  R  Q  RP  QzP  zQrconditiontrue rconditionfalsex  yif x  y then P else Q  Px 6 yif x  y then P else Q  QTable 2.3 Reduction rules for the Calculussscopenull means that a scoping operator does not have any effect on the null process,since this does not include any names.To describe the reductions of the processes, we define a set of Reduction Rules, which formalize how processes communicate between themselves during their execution. Table 2.3gives these Reduction Rules for the Calculus.rcommunication is the communication rule stating how two processes communicatethrough a common channel c. One of the processes has to output send a tuple of namesthrough this channel , while the other process has to input receive these names, whichare defined as a tuple of variables up to communication. Once that the names are received,the input variables are substituted by the received channel names throughout the process.We use the notation Pnewold to denote that the name old is substituted by the namenew throughout process P .12CHAPTER 2. BACKGROUNDExample 2.9 Process communication Consider the system of processes S. Whenthese processes communicate, the tuple a, b is sent from the process on the right side, tothe process on the left side. This would result in having the variables x, y replaced bythe received values a, b respectively throughout the process xc.P .S  cx, y.xc.P  ca, bQ ac.Pa,bx,y  Qrreplicatedcommunication is similar to rcommunication, only that the replication action is performed. Upon communication, the process with the replicated input action willpersist with a copy of itself.Example 2.10 Replicated communication Consider the system S. When the processescommunicate, the process cx, y.xc.P is retained, and a new process is launchedcx, y.xc.P . This process will receive the tuple of channel names and continue reducing, as illustrated in example 2.9.S  cx, y.xc.P  ca, bQ cx, y.xc.P  ac.Pa,bx,y  Qrtau gives the rule for tau   reductions, or internal reductions, where an unobservableaction is processed, reducing the process, independent of surrounding processes.rconcurrent rule states that a reduction is possible for processes in a concurrent environment.rscope rule states that a reduction is possible for processes containing bound names, andthe scoping of these channels remains unchanged.rstruct infers that a reduction is possible from P to Q if there is a reduction from P1 toQ1, and if P and Q are equivalent to P1 and Q1 respectively.13CHAPTER 2. BACKGROUNDrconditiontrue states that if x is found to be equal to y, then the conditional statementwould reduce to the process P .Example 2.11 Conditional statement evaluating to True Consider the system S,where the conditional statement is evaluated to true. Hence the process P follows theexecution.S  ca, a.R  cx, y.if x  y then P else Q R  Pa,ax,yrconditionfalse states that if x is not equal to y, then the conditional statement wouldreduce to the process Q.Example 2.12 Conditional statement evaluating to False Consider the system S,where the conditional statement is evaluated to false. Then the process Q follows theexecution.S  ca, b.R  cx, y.if x  y then P else Q R  Qa,bx,ySo far, we have only witnessed examples which illustrate the Calculus notation andsematic rules. The following example offers a more useful concept that Calculus canbe used for.Example 2.13 Memory cells Consider a process using the channel named cell to output a value that have been received earlier in the execution. For instance,cellvalue.cellvalue.PNote how, this process is temporary storing the name received as the variable value.14CHAPTER 2. BACKGROUNDNow, let us used the replicated input action to allow us to get hold of a cell for an unlimitednumber of times, and use the scoping operator to give each of the created cells a uniquename. For example,createcellvalue, getcell.cellcellvalue.0  getcellcell.0Observe how this process would communicate with another process, in the followingsystem.createcellvalue, getcell.cellcellvalue.0  getcellcell.0 createcellhelloworld, listener.listenermyfirstcell.myfirstcellmessage.QThe replicated process communicates with our process through the channel createcell.Our process passes the name helloworld that will be stored, and the name listener. Thechannel listener will thus communicate back the cell holding the channel helloworld.createcellvalue, getcell.cellcellvalue.0  getcellcell.0 cellcellvalue.0  getcellcell.0helloworld, listenervalue, getcell listenermyfirstcell.myfirstcellmessage.QWhat follows is the scoping operator that executes on the channel cell. Since the scopingoperator restrict the channel cell, by creating a unique channel cell0 and substituting cellby cell0 throughout the concerned processes. Hence, we will end up with a unique cellwaiting to output the name helloworld and our channel listener waiting to output thename just created channel cell0.createcellvalue, getcell.cellcellvalue.0  getcellcell.0 cell0helloworld.0cell0cell listenercell0.0cell0cell listenermyfirstcell.myfirstcellmessage.Q15CHAPTER 2. BACKGROUNDNext our process will communicate through the channel listener, to input the channelrepresenting the cell.createcellvalue, getcell.cellcellvalue.0  getcellcell.0 cell0helloworld.0 cell0message.Pcell0myfirstcellFinally our process will retrieve back the name helloworld that was stored earlier.createcellvalue, getcell.cellcellvalue.0  getcellcell.0 Phelloworldmessage2.1.3 Simplifications and AssumptionsIn the syntax that we defined, two key simplifications were made to the original PolyadicCalculus. We omitted completely the Summation operator, and we restricted Replication to Input actions only. This will simplify the virtual machines development and theirperformance drastically.The Summation operator gives a choice for communication to multiple processes, wherethese processes cannot communicate among themselves. For instance, in the example below processes P , Q and R cannot communicate among themselves, and only one of thesecan perform communication with process M  this is the choice. When communicationoccurs, the chosen process follows the execution, while the others are discarded.P QR  MThe main reason for removing the summation operator, is because it requires huge amountsof memory usage when compared to the other Calculus operators, and it is not very use16CHAPTER 2. BACKGROUNDful and is rarely used. Turner in his thesis Tur95, states how the experiment with PICTPT00 has shown this.2The second simplification that we undertook discussed in detail by Turner Tur95, isthe restriction of replication to processes with input actions, which we called ReplicatedInput. Full replication of a process is when a process copies itself upon performing anaction, regardless of what that action is. The structural equivalence that was omitted,which defined replication is given below.P  P  PIf we had to allow this axiom to be observed, then there will be no control over how thisoperator would replicate the processes. This would result in having the process replicateitself to infinity.P  P  P  P  . . .  P  PBy restricting replication to input action, we avoid having this situation, since a processwill only be replicated when this communicates through a replicated input action. Inaddition to this, full replication can be easily encoded by just using replicated input.P  cc .P  c   c 2.2 Channel TypingIn this section we define a simple typing system, so that we will be able to control ArityMismatch during communication. We shall not go into great detail since this is beyond thescope of this work, however one can find further explanations in SW03b, Kob. We willuse typing in both of the virtual machines that we shall develop throughout this project.2Please note that minor choices can be encoded using the conditional statement instead of the summationoperator.17CHAPTER 2. BACKGROUNDSpecific details on how typing is used within the various virtual machines, are given inthe forthcoming chapters.Arity mismatch is triggered when a process P communicates with another process Q, andthe number of channel names that process P is outputting differs from the number expected by process Q while inputting. This will result in a runtime failure, which is highlyundesirable. Examples 2.14 and 2.15 presents simple situations where arity mismatchwill result in a runtime error.Example 2.14 Arity Mismatch Consider the following two processes running withina system.cb1, b2.P  cx1, x2, x3.QThe process cb1, b2.P is unaware of the number of variables the other process has. Thuscommunication will commence. However, after that the second name is sent and received,process cb1, b2.P continues as P , but process cx1, x2, x3.Q is still waiting for an inputon the variable x3. This input will never happen. Hence this process locks up and it cannotproceed with its execution. It is this situation that triggers a runtime error.Example 2.15 Arity Mismatch Now consider the following system of processes.cb.ba.P  cx.xy1, y2.QAt a first glance, these two processes look promising, and it seems that both will communicate through channel c, and continue running without triggering any runtime errors.However, after these perform the communication, the situation changes completely, sincethe process cx.xy1, y2.Q has received the channel name b, and once the variable xis substituted by this channel name, we get the following situation,ba.P  by1, y2.QbxNote how now, the system will perform a runtime failure, as explained in example 2.14.18CHAPTER 2. BACKGROUNDerrcommunication errtauaV .P  aX.Q  ERRORif V 6 XP ERROR.P ERRORerrscope errconcurrentP  ERRORzP  ERRORP ERROR or Q ERRORP  Q ERRORerrstruct errconditionP  P1 P1 ERRORP ERRORP ERROR or Q ERRORif x  y then P else Q ERRORTable 2.4 Runtime errors for CalculusWe define the formal notation for when a system will produce a runtime error in Table2.4. This table gives all the possible states of a how a system handles a runtime error.Most important is to note the rule errcommunication, which triggers the error. Note theerrors trail through the different states of the system.To avoid our machines running into such a runtime error, we attach a type to the channelsused within a Calculus program. The syntax for the typing of channels is given inTable 2.5. A channel c is attached to a type T , such that, this type T gives a mould forthe tuple of names, that can be communicated through the channel c. By using types,before execution starts, the number of names that can be communicated inputoutput isretrieved from the type. If this number differs from the number of names for outputs, orthe number of variables for inputs, execution is withheld.As one can note, the structure of a Channel Type definition T , is a tree like structure,where the nodes represent a channel, and its children represent the tuple that is allowedthrough the channel. Therefore, the number of children nodes of a type, symbolizes thenumber of names allowed through the channel. This means that the leave nodes symbolizean empty tuple or list of names.We are also defining Type Variables, denoted by V , which can be declared just like chan19CHAPTER 2. BACKGROUNDc, b, a, T   T, T, . . . , T   V Channel TypeV   T, T, . . . , T   XV Type VariableXV   XV  Recursive TypesTable 2.5 Typing syntax for Calculusnel types, which can then be assigned to channels. This simplifies the notation for complex types, where the tree symbolizing these types is of a considerable depth.Example 2.16 Using channel types and type variables The following is a declarationfor the type of the channel c, which is using the variable type V .c     , V V     ,   A quick analysis shows that the channel c is being used correctly in the forthcomingprocess. Note how the variables x and y are not declared, but these use the types whichare symbolized as the children of the declared channel c.cx, y.x .yx, x.QNote that c could have been declared asc     ,    ,    Recursive types are more complex then the simple types, however, these allow us toproduce more useful Calculus programs. This is why recursive typing is included inthis study, but it is important to note, that this is a variant to proper recursive typing whichis beyond our target. A channel declared as a recursive type must be done through a typevariable, where this type must contain the same channel type within the declaration. Thenotation XV means that the variable X must be declared within the declaration.Example 2.17 Recursive Typing Here, the channel c is assigned to the type variableX . This type variable X is then defined as a recursive type with a single child, where this20CHAPTER 2. BACKGROUNDchild is again the type variable X .c  XX  X For instance the following processes are correctly typed, according to the declarations thatwere made earlier. This example illustrates how the name for channel c is communicatedthrough channel c itself.cc.P  cx.xc.QTo control these type declarations, we assign a set of environments to each process, whichwill store all the type declarations that are required throughout the process. We denote theset of type environments, which are mappings from channel names to types, of a processP by  PTo add a mapping from a channel name c to its declared type T , to the set of type environments, we use the notation,c 7T  PTo retrieve the type T of the channel c, from the set of type environments we use thenotation,c  c  T, PFinally, to check the equality of types we use the notation,  if T  V, PTable 2.6 gives the formal notation of the TypeChecking rules that should be followed21CHAPTER 2. BACKGROUNDtcoutputa  a   T , P tcinput tcreplicatedinput  if V  T, P a  a   T , P a  a   T , PV 7T  P X 7T  P X 7T  P  aV .P   aX.P   aX.Ptcconcurrent  P tcscope tctau tcnull  Q V  P   P  P  Q   V P   .P   0tccondition  P  Q  if x  y then P else QTable 2.6 Typechecking rules for Calculusbefore the start of a program execution. Note that these rules are observed on the staticnotation of the Calculus program, before any Reduction Semantics are undertaken.The most vital rules are tcoutput, tcinput and tcreplicatedinput. These rules showhow output actions check for type equality, before the rest of the process is typechecked.On the other hand input actions do not check for type equality, because these use variables,but add the variable value to the set of type environments to be typechecked later, if thisis used by an output action.2.3 Related StudiesIn the following section we take a look at some of the most important and influentialworks, which contributed to the field of Calculus. These technical reports were useful22CHAPTER 2. BACKGROUNDduring the research of this study. Hence, this section will help the reader to understandand grasp a more solid idea on the Calculus and its uses. This section should give thereader a clear picture of where this dissertation stands, in comparison to other studies.We want to point out that the work in this dissertation is not completely original, butrather ideas were adopted from the reports in the coming section. Please note that mostof the work achieved by Turner, Sewell and Wischik is beyond the scope of our workhere. Thus, the discussion targets only the objectives, and gives briefings to the ideasthese people developed, and no complex explanations will be tackled.2.3.1 A PICTtoC CompilerIn his Ph.D thesis Tur95, David N. Turner aims at developing a PICTtoC Compiler.PICT PT00 is a concurrent programming language built on the Calculus constructs,and was developed by Benjamin C. Pierce and David N. Turner himself. Turner investigates the Calculus by examining whether it is able to have a stronglytyped concurrentprogramming language based on the foundations of the Calculus. This is much beyondour target, but by reading through Turners work we capture important explanations on theCalculus and on Channel Typing. In his chapter An Abstract Machine for Calculus,he describes useful applications which are suitable for our implementation. What reallyinterests us, is how Turner considers implementing a Calculus machine, and making itas efficient as possible by introducing certain optimizations.Turner builds his abstract machine on a uniprocessor platform. This means that, theprocesses are actually being simulated to work in parallel, since the underlying machineis utilizing a single processor. Turner states that a distributed implementation poses muchfurther challenges. This kind of implementation was later handled by Sewell, and lateragain by Wischik.23CHAPTER 2. BACKGROUNDIt is important to mention that David Turner eliminates the Summation operator in hisdescription of the abstract machine. He suggests that the Summation operator affects theimplementation by imposing complex issues, and that this is not feasible, since it is rarelyused within a system.Another essential point to note here, is how Turner tackles a fair execution of Calculus,which is being handled on a uniprocessor. Take into account that a single processor imposes a deterministic environment when the Calculus is a nondeterministic modal.After facing and discussing these design issues, Turners objective turns to refine theabstract machine, by making critical changes, in order to allow a more efficient execution.One of these optimizations, which we will be considering in our implementation, is theusage of Environments instead of substitution. Substitution is considered to be highly costeffective in terms of processing power, but this will be discussed in detail later.2.3.2 NomadicPICTPeter Sewell, in contrast to Turner, tries to solve the problem of having a Calculusmachine, which will handle distributed programming, which works for a real distributed environment. In his works, Sewell tries to advance on Turners work concerningPICT, from a simulation, to the actual concurrent infrastructure. Sewell handles this byintroducing what he calls an Agent Programming Language the NomadicPICT. TheNomadicPICT is actually an extension to Pierces and Turners PICT.Solid ideas about the background of Sewells works is given by Sewell himself in a tutorial Sew00, where he starts by introducing how Calculus can be applied to a distributedsystem. He uses the PICT programming and typing fashion to discuss certain issues.24CHAPTER 2. BACKGROUNDIn PSP98, PSP99, Sewell, together with Wojciechowski and Pierce, proposes a simplecalculus for mobile agents, such that these will be able to be transported between differentlocations within a distributed system, and regardless of this, they will still be able tocommunicate by message passing.The description of the NomadicPICT implementation is given in SW, where Sewellstates that to have a high level programming framework for such distributed systems, thecurrent infrastructure will face three main problems. The first problem is that programming distributed algorithms are very complex and fragile. The second problem is that theunderlying structure of the present distributed systems, is not flexible enough to supporta clean execution of distributed programming using Calculus. Finally, the underlyinginfrastructure of distributed systems is not application specific as it is required.These problems are addressed directly in PSP98, PSP99, where a small calculus is usedand is closely related to real network communication protocols. This work then evolves tothe Two Level Architecture that is adopted in implementing the NomadicPICT. In brief,the idea is to have the top level working closely to the programmer, where development isabstracted away from the lower levels of distributed systems. Hence, the second level isused to translate the program into a lower programming framework specifically to the underlying distributed system. This lower level will work closely to the present networkinginfrastructure and communication protocols.2.3.3 The Fusion MachineLucian Wischik introduces Explicit Fusion Calculus in his Ph.D. dissertation Wis01.Explicit Fusion Calculus is an extension to Robin Milners Calculus. This variant defines the details of how two processes communicate and exchange names. Lucian Wischikexplains this calculus by segmenting the communication procedure into three main steps.25CHAPTER 2. BACKGROUNDFirst, when two process are aware that the two can synchronize, these become fused,meaning that both processes are bound to each other until they complete the communication. Next, these two processes assume that the variable of the input action is equal tothe name being sent by the output action. Finally, the variable is discarded, resulting inhaving a clean substitution.Wischik uses this Explicit Fusion Calculus to implement a concurrent and distributed machine for Calculus. Wischiks work differs from that of Sewell, since the developmentis actually that of an abstract machine based on Calculus, which will work at a lowlevel of abstraction and on a real distributed system. On the other hand, Sewell achievesa distributed environment, by extending Turners work, by applying an extra upper layerto operate on top of the already constructed abstract machine.Wischik calls his abstract machine The Fusion Machine. He manages to accomplish hisgoals by using a technique which he names Fragmentation, where Calculus programsare fragmented into multiple simpler programs, in order to make them more transportable.These programs are fragmented using theories found in the Explicit Fusion Calculus. After, fragmenting the programs accordingly, at specific actions, these new programs can bedistributed over multiple machines. Therefore, these programs can execute concurrentlyover a distributed system, and would communicate to each other by using Explicit FusionCalculus. For communication, a common shared memory location is used. This acts asthe name repository during Explicit fusion.This is a brief idea on what Lucian Wischik managed to achieve. Its purpose is to motivateattracted readers, however at this stage this is beyond the scope of this project.26Chapter 3Compiler DesignIn this chapter we discuss the design and the implementation of a compiler. The purposeof the compiler is to translate the syntax of a Calculus program into an intermediatecode representation, which can then be executed on several Virtual Machines. In Chapters4 and 5 we develop these virtual machines, on which we can simulate this intermediaterepresentation.We shall be dealing with the highlighted section given in Figure 3.1. The development of acompiler requires other elements and modules to be developed before the actual compiler.App02 offers indepth detail regarding compiling theories. We will start by constructinga Calculus language based on the given syntax in Table 2.1. We generate a Parser usinga compiler generating tool, which will check a given program for syntactical errors, andoutput an Abstract Syntax Tree of the program. We then develop a TypeChecker module,which implements the rules given in Table 2.6, on the Abstract Syntax Tree. Finally wedesign a compiler that will convert an Abstract Syntax Tree Typechecked or not, intoan intermediate code representation.27CHAPTER 3. COMPILER DESIGNFigure 3.1 Compiler Architecture3.1 The LanguageThe language that is constructed is an extension to the syntax given in Table 2.1. Forreference and explanation purposes, we shall call this language Language. The extensions that were introduced to the Language are mostly programming constructs makingthe Calculus more programmable. Figure 3.2 shows a typical Calculus program asit would be constructed using the Language. The implementation details found withinthe various sections of a  program, are written using the syntax given in Table 2.1, whichhas already been explained. Hence, in this section, we will discuss the constructs that havebeen added. The grammar describing our language is given in EBNF format ExtendedBackusNaur Form, and can be found in Appendix B3.1.1 The Include SectionAs an option, the programmer can use the include keyword to import other compiled Calculus files. Compiled files are Calculus programs, written in the Language, whichhave been processed by the compiler, and saved as intermediate code. For example, inFigure 3.2, both send and receive are compiled programs, which are being imported, andincorporated with this particular program. These programs will not be compiled againhere, but the intermediate code is simply added to the rest of the program. Such files can28CHAPTER 3. COMPILER DESIGNinclude sendinclude receiveInclude Section...ch a     ,   ch c     , V ,   VAR V     VAR REC Y   Y Type Declarations...def listx, ybeginImplementation...endDefinitions...beginImplementation...endMain BodyFigure 3.2 A typical Calculus program written in Language29CHAPTER 3. COMPILER DESIGNbe used as libraries for Calculus definitions as we shall see later.3.1.2 Type DeclarationsChannel types are declared in this section, and the syntax used is very similar to the typingsyntax given in Table 2.5. The same principles explained in Section 2.2 apply for the Language. Note that the convention for channel name is to use small caps while, variablenames are given in capitals.1. Channel types The syntax for channel types is as followsch name  structurevariable The keyword ch declares the a channel and is given the name name. The assignment  symbol, allocates the structure or variable to the channel. The semicolonsignifies the termination of the declaration. The structure for the declaration followsthe same principle of the typing syntax in Table 2.5. For instance in Figure 3.2, weare declaring two channels, a and c.2. Type Variables are very similar to Channel type declarations. The difference isthat the keyword var is used to declare a variable, and the name of the variable hasto be given in capitals. The semicolon signifies the termination of the declaration.var NAME  structurevariable In our example given in Figure 3.2, a type variable V is being declared. It is critical to understand that type variables are only used for other type declarations andcannot be used outside the declarations section.3. Recursive Types are declared means of a recursive variable. The procedure is tofirst declare the recursive type as a variable, then use this variable to declare a30CHAPTER 3. COMPILER DESIGNchannel. This gives us more control over recursive typing. The syntax for recursivetypes is as followsvar rec NAME  structureNAME These types are similar to type variables, only that the keyword rec is used afterthe var keyword to indicate the presence of recursion. The structure for this typehas to include the name of the type itself. The semicolon signifies the terminationof the declaration. In Figure 3.2 the recursive variable Y is being declared.3.1.3 Calculus DefinitionsA definition is like a program function, where a piece of Calculus program can bemodularized, in order to be reused whenever it is required. For a programmer to define adefinition, the def keyword has to be used, followed by a number of variable parametersenclosed in parentheses, like the example given in Figure 3.2.The implementation section within the definitions is constructed using the Calculussyntax given in Table 2.1. This implementation must be enclosed in between begin andend keywords. Any number of definitions can be constructed within a single program.A definition can be called by simply calling the given name, and passing the requiredchannel names as the arguments. For instance, to call the definition in Figure 3.2,lista,b.P31CHAPTER 3. COMPILER DESIGN3.1.4 The Main BodyThe main body of a program is the starting point of the execution. In this section theprogrammer will construct Calculus code using the syntax in Table 2.1. The main bodyis an optional section, so that the programmer has the choice of omitting the main bodyand implementing only a number of definitions, hence composing a library of definitions.The implementation of the main body has to be enclosed in between the begin and theend keywords.The main body should be the last piece of code that is defined, meaning that any typedeclarations and Calculus definitions should precede this section.3.2 The ParserThe grammar specification given in Appendix B, for the Language, was used to generate parser modules by using the JavaCC tools. JavaCC Java Compiler Compiler provides a set of tools JavaCC, JJTree and JJDoc, which are able to understand a scriptinglanguage based on ENBF, and generates parser and compiler classes for the language thatwas specified in the EBNF specifications. These tools construct essential modules, for theParser section, and interface modules on which the TypeChecker and the Compiler canbe implemented.At this stage, it is important to understand the task of the Parser, even though this will begenerated by the JavaCC tools. This is necessary, since the development of the compilerwill utilize many of the Parser features.The Parsers job is to scan through a stream of characters, where the sequence of these32CHAPTER 3. COMPILER DESIGNcharacters make up the current Calculus program, written in the Language definedin Appendix B. This raw text is fed to a component known as the Lexer or the Tokenizer,where Lexical Analysis is performed. This filters out the code by removing unwantedtext, such as comments and trailing white characters spaces, carriage returns, tabs, etc..The Tokenizer outputs a stream of tokens, where each token represents an entity of thelangauge. For example, the keyword begin, the channel c and the action , would all betokens.These tokens are then passed to the main Parser module, where its job is to check thatthe sequence of the tokens matches the grammar, as defined in Appendix B, or morespecifically it checks for syntax errors. The Parser will output a data structure knownas an Abstract Syntax Tree, which is built from the tokens depicting the structure of theprogram. The Syntax Tree gives the program its structure and a more sematic meaning.Example 3.1 Parsing a Calculus implementation section For the followingCalculusimplementation, the parser will generate the Abstract Syntax Tree in Figure 3.3.ca.0  cx.0Figure 3.3 Abstract Syntax Tree example33CHAPTER 3. COMPILER DESIGN3.2.1 Visitor NodesThe JavaCC tools give the possibility of using Visitor classes, which, when implemented,they will visit the nodes of a parse tree sequentially, and interpret the tree structure. TheParser outputs a syntax tree built with visitor nodes, while JavaCC will have alreadygenerated a Visitor interface. Each visitor node will call a method when this is visitedduring the tree traversal, and the implementation of this visiting method is done withinthe visitor class that implements the Visitor interface. This means that more than onevisitor class can be developed, and each of these can be specifically implemented to therequirements.During our implementation a number of visitors were implemented to meet the specifications that were required. The following modules implement the visitor interface generatedby JavaCC. This is given in Appendix C, Figure C.1.TypeChecker traverses the syntax tree checking the channel types for arity mismatch.It implements the typing rules given in Table 2.6. Development details given insection 3.3.Compiler will construct a machine representation based on the traversal of the syntaxtree, but without enforcing checking on types. See section 3.4 for more detail.GraphicTree Translator interprets and translates tree nodes into graphic nodes whichcan be drawn on a graphic context, thus, depicting the visual idea of a syntax tree.This graphic context can then be drawn onto a windows form to be viewed onscreen.34CHAPTER 3. COMPILER DESIGN3.3 The TypeCheckerThe TypeChecker is a module which implements the Visitor interface, and its job isto typecheck the channels. The TypeChecker implementation follows the typing rulesgiven in Table 2.6. The Abstract Syntax Tree is given to the TypeChecker module, whichwill apply the syntax rules to the syntax tree. The TypeChecker module will then output amessage indicating that the tree is correctly typed, or an error message, which will indicatewhere a typing mismatch occurred. The module does not alter the Abstract Syntax treein any way. In fact, the TypeChecker can be skipped through the process, and allow thecompiler to translate the syntax tree, regardless of its unstable state. This will allow theuser to experience a runtime failure, if this is desired.This module starts by interpreting the type declarations, and adding each declared type toan environment table. For every process that will be type checked, a copy of the currentenvironment table is attached with the process. The environment table is implementedas a Hash Table where, the channel name, or the variable, will be the key element, whilethe referenced object will be the tree representation of the type see page 19. The wholeprocess will make use of a Stack, where the Hash Tables are stored before these areattached to type check a process.Example 3.2 Controlling environments Consider the following system, with a HashTable for the type declarations . These declarations are left unchanged before typechecking each of the other processes by means of a stack. P  Q  RThe TypeChecker will first place the Hash Table on the stack, then it will take a copyand use it to typecheck process P . During the checking of P , the TypeChecker willmanipulate the entries as required. When the checking on process P ends, the table isdiscarded and a fresh copy of the original Hash Table is used for the typechecking of35CHAPTER 3. COMPILER DESIGNprocess Q. The same procedure is used for all concurrent processes.The stack will be really required when a process contains parenthesis, which will dividea single process into a number of other processes. P.M  N  Q  RIn this case the Hash Table that is used by process P is not discarded, but it is pushed ontop of the stack, with all the changes that it had undertaken. This table will then be usedby all the processes that have emerged from P ie. M and N, using the same procedure.Upon the completion of P , the Hash Table will be popped from the stack and discarded,therefore the processes Q and R will have access to the original Hash Table that P hadstarted off with.3.4 The CompilerThe Compiler module translates an Abstract Syntax Tree into intermediate code. Thecompiler implements the Visitor interface constructed by the JavaCC tools, and it traversesthe syntax tree using visiting nodes. During the traversal of the tree, the compiler willbuild data structures according to what the nodes of the syntax tree represent.Figure 3.4 The compiler translates an AST into Intermediate Code36CHAPTER 3. COMPILER DESIGN3.4.1 Intermediate Code RepresentationAt this stage, we shall define how the intermediate code representation is designed. Thisrepresentation is developed such that, it can be saved or serialized to a file, making it thecompiled version of the program.A Calculus program is represented as an unordered list of processes, meaning thatP  Q  R will be represented as  P  Q  R . An unordered list signifiesthat the processes of this list are randomly ordered, making sure that there will be asmuch fairness as possible during execution.Figure 3.5 Intermediate representation of a processOn the other hand, the processes will be represented as an ordered list of Calculustasks. In Calculus, a process is a sequence of actions. Hence in our machine we shallnot define an entity to represent a process, but rather, we will build up the process byusing a linked list of actions which we shall call tasks. We shall define a number of tasks,where each of these will correspond to the Calculus actions. Figure 3.6 gives the classdiagram for the classes representing these tasks, each of which inherit from an abstractclass Task.37CHAPTER 3. COMPILER DESIGNFigure 3.6 Class diagram  Task class and subclasses38CHAPTER 3. COMPILER DESIGNOutput TaskAn Output task represents an output action, for example cx1, ..., xn.P . This task willcontain a string value for the channel c, and a list of strings for the channels x1, ..., xnbeing outputted. This task must be part of a continuation or sequence of other actions,and therefore it must be followed by another task. The next task P will be represented asa task.Input TaskAn Input task represents an input action such as cx1, ..., xn.P . Hence, this task willcontain a string value for the channel c, and a list of strings for the names x1, ..., xn. Thefollowing process P will be represented as a next task.Replicated Input TaskA Replicated Input task is very similar to an input task, but it represents a replicated inputaction such as cx1, ..., xn.P . This task will contain a string value for the channel c,and a list of strings for the names x1, ..., xn. The following process P will be representedas a next task.Tau TaskThe Tau Task corresponds to an internal action, or an unobserved action, .P . Hence thistask will hold no information, other then the next task to be followed.39CHAPTER 3. COMPILER DESIGNIf TaskAn If Task will stand for an IfThenElse action. Let us consider the example if x y then P else Q. This task will define two strings to hold the two channels,x and y,used for the equality. This task will store two pointers to two different tasks. One task ispointing to P , which is the task to be followed if the equality is true, and the other task ispointing to Q, the task to be followed if the equality is false.Binding TaskA Binding Task is defined to correspond to the binding action of a channel. In order toaccurately handle the binding and scoping of channels, a binding action or task had to bematerialized to a specific point in time within the execution. This means that the syntaxnP will be represented by a single binding task. This task will contain a string tostore the channel that is being bound, followed be the process with the bound channel,which is represented as a task.Brackets TaskThe Brackets Task is defined to be used for structural purposes only. During the firstphases of the research it was noted that parentheses are used frequently to structure theCalculus syntax. For example, the system P.Q  R is allowed, where the process Pis followed by two unordered processes Q and R. Therefore, this will be represented as aBrackets Task which will contain an unordered list of unordered tasks.40CHAPTER 3. COMPILER DESIGNNull TaskThe Null Task is defined to represent the end of the link list of tasks. It is used for internalprocessing, but it can be compared to the null process 0.3.4.2 Intermediate Code to String TranslatorA translator module was developed to allow us to convert a compiled version of a Calculus program into a string representation. This module can be closely related to adecompiler. This module, is a necessity for the Virtual Machines that will be developedsince, the machines will have to output the resulting state, after performing a numberof reduction steps. Therefore, this module will be called from the virtual machine, totranslate the current machine representation into a readable format.This translator will traverse a list of processes, and for each of the processes, the translator will traverse the tasks sequentially, and the corresponding string representation iscomposed.41CHAPTER 3. COMPILER DESIGN3.5 A Minor OptimizationAn optimization was adopted at this stage for the IfThenElse operation. The idea is totypecheck the channels involved in the condition expression. If these are not of the sametype, then it can be deduced that the channels will never be equal. Therefore, the Thenprocess will never be followed and thus, it can be removed. The following pseudocodeis adopted.1. Retrieve type declaration for both channels, and check for the type equality.2. If both channels are of the same type then construct the If Task normally.3. If the two channels are not of the same type, then discard the Then section, andconstruct the Else process as a continuation to the preceding process.42Chapter 4A StandAlone Virtual MachineIn Chapter 3 we have dealt with the design of the compiler, which is able to translateCalculus notation into machine data structures, such that this format is easier to manipulate and work with. The aim of this chapter is to develop a virtual machine basedon the abstract machine given by Turner in his dissertation Tur95. The virtual machineperforms reduction operations on the intermediate code, in the same way that Calculusnotation is reduced using the reduction rules in Table 2.3. More specifically, we shalldevelop a set of reduction procedures, which will be applied to this intermediate coderepresentation, allowing the processes to communicate.This machine implementation is a StandAlone Virtual Machine, meaning that the wholeexecution will be done internally. This implies that the virtual machine will accept theinput system as intermediate code, and will only output the results once that the computation has been terminated. The computation will be contained within the StandAloneVirtual Machine until the processes can no longer reduce among them, and it is then thatthe results are outputted. This brings us to an important objective, which involves the accuracy of the virtual machine. We want our standalone virtual machine to output correct43CHAPTER 4. A STANDALONE VIRTUAL MACHINEresults when it terminates the execution. This means that the machine has to process thereduction rules consistently, and always produce the expected results. We shall tackle thecorrectness of our virtual machine in more detail in section 4.1.A StandAlone Virtual machine gives us the advantage of focusing on the performanceof the machine. Since all of the commutation will be under the control of the virtualmachine, this allows us to develop an efficient architecture and expand on optimizations,which will perform rapid process reductions.It is important to mention that the machine will be simulating the concurrent environment of the Calculus parallel processes, since it will be working on a uniprocessor oneprocessor. When mentioning a simulation, an essential point is brought forward thefairness of the simulated execution. As we know, Calculus offers a nondeterministicexecution, but, since our machine will run on a single processor, our machine will performa deterministic execution. Hence, throughout the designing stages, it is extremely important to keep the handling and the execution of the processes as fair as possible. This involves having every process being given an equal chance for communication. This mightturn out to be more difficult to accomplish than the actual correctness and accuracy of themachine, since it is easy to produce a correct result without achieving the correct amountof fairness between the processes. To summarize, our main objective will be develop astandalone virtual machine capable of executing the communication between processesand reducing these processes with a hundred percent correctness, while achieving this asfairly as possible.4.1 Correctness Of The Virtual MachineWhen talking about the correctness of a machine, we mean to say whether or not the machine matches reality or its realistic counterpart. To prove the correctness of our machine,44CHAPTER 4. A STANDALONE VIRTUAL MACHINEwe shall compare the virtual machine results with the actual real results of Calculus,and make sure that the machine results are accurate. Since our Virtual Machine will bedeveloped on algorithms, we can positively state that our machine is correct, if the algorithms that make up the machine are correct with respect to a number of specifications,where our specifications are the Calculus reduction rules given in Table 2.3.In Chapter 3 we have seen how to translate Calculus terms into intermediate code representations, by means of the Compiler modules. We have to our availability, an Intermediate Code to String Translator see section 3.4.2, which translates the machinerepresentation into a string which is readable. Therefore, we affirm that, if we are able totranslate Calculus terms into intermediate code and viceversa, then the two forms canbe regarded as equivalent.Figure 4.1 Converting Calculus terms to machine terms, and viceversaConsider the example P  Q given in Figure 4.1. By using the Compiler, we translate oursystem into Intermediate Code Representation format, and by using the String Translatorwe convert the Intermediate Code into its original state.Now,we can move a step further and define a function fVMS within our Virtual Machine implementation, which will accept a Calculus system S in intermediate codeformat, and outputs the resulting system in intermediate code. Internally this functionwill consist of all the rules discussed in Table 2.3.45CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.2 Correctness of machineNext, we utilize our function Virtual Machine as shown in Figure 4.2, which will reducethe intermediate code representation in a number of steps as followsfVM P  Q    R Now we need to translate the results back into Calculus terms, and for this, we use ourIntermediate Code to String translator, as depicted in Figure 4.2.So far we have achieved a result using the Virtual Machine. Consequently, we now haveto determine the correctness of the Virtual Machine. In order to determine this, we haveto show that the acquired result is equivalent to its realistic counterpart result. By therealistic result we refer to the result achieved if the starting system had to be reduced byusing the reduction rules in Table 2.3.This is clearly pictured in Figure 4.3. Please note that the results of the reduction transitions of the Calculus terms and the results of reduction transitions of the IntermediateCode, can be achieved differently.46CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.3 Correctness of machine4.2 StandAlone ArchitectureThe design for the StandAlone Virtual Machine is based on the machine described byDavid Turner in his thesis Tur95.The machine consists of a Process Manager, which will contain instructions for processreduction or Reduction Procedures. This module will work in between two First In FirstOut FIFO queues, the Run Queue and the Service Heap. As seen in Figure 4.4, theprocesses1 will circulate around the two queues and are handled by the Process Manager.When the virtual machine commences its execution, it will have available an unorder listof processes, as described in Section 3.4.1. These processes will be randomly enqueuedonto the Run Queue, thus giving the simulation a higher level of fairness. Once that allthe processes are enqueued, the simulation can commence.At this stage, it is important to make a distinction between the nature of the tasks involvedin the processes. We classify Output Tasks, Input Tasks and Replicated Input Tasks ascommunication tasks, since these tasks represent the actions that are always handled inpairs, because communication must be between two processes. The rest of the tasks theTau Tasks, the Binding Tasks, the Brackets Tasks, the If Tasks and the Null Tasks arenoncommunication tasks, meaning that these represent procedures that do not require1A single process is actually a linked list of tasks. See Section 3.4.1.47CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.4 Simple design for the StandAlone Virtual Machineanother process to be executed.The process manager will, retrieve the process at the head of the queue, and it will handlethe first task of the process, according to the classification of this task. The differencein handling, is that, communication tasks make use of the Service Heap, while noncommunication tasks do not. The account for communication tasks is given in Section4.3, and the account for noncommunication tasks is given in Section 4.4.4.3 Handling Process CommunicationIf the Process Manager dequeues a communication task, such as Input, Output or a Replicated Input from the Run Queue, the Process Manager will follow the flowchart depictedin Figure 4.5.The Process Manager will have a single process at a time to handle. Thus, only one task48CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.5 StandAlone Machine algorithm49CHAPTER 4. A STANDALONE VIRTUAL MACHINEneeds to be handled. Communication tasks will always request a channel to communicatethrough,Example 4.1 For instance, all of the following processes are requesting the channel c.ca, b, d.P   cb, d, e.Qcx, y, z.RThe Process Manager will search for a task along the Service Heap, which had requestedthe same channel. This is known as channel blocking, since the search to match the pairis only done on the heap, and thus having the effect of the channels being blocked by therequiting task.If a task is not found in the heap, the requested channel is not blocked, and no otherprocess has requested this channel. Hence, the Process Manager will enqueue the processon the Service Heap, and thus blocking the channel which is being requested.On the other hand, if a process is found blocking a channel on the Service Heap, theProcess Manager will check the polarity of the two tasks. This means that the ProcessManager will compare the task being serviced with the one found on the heap, and willmatch up a pair only if the two tasks can communicate as specified in Section 2.1.2. Forinstance, an output is matched with either an input or a replicated input. If the other halfof the communication pair is not available, then the task being serviced is enqueued onthe Service Heap.Nonetheless, if a match is found, then the two processes can communicate and reduce.Hence the Process Manager will retrieve the names from the output action and substitutethe variables of the input action, with the retrieved channel names. If typechecking hasbeen performed during compilation, then the number of names being passed will matchup with the number of variables. However, if the TypeChecker module has been overpassed, then the Process Manager will halt and trigger a runtime failure.50CHAPTER 4. A STANDALONE VIRTUAL MACHINEFollowing the communication, the two processes are reduced, by discarding the first taskof each process, since these tasks have been performed. Afterwards, these processes areenqueued to the end of the Run Queue, and subsequently, the Process Manager commences this procedure once again.In this whole procedure, the processes are being circulated around as much as possible sothat we try to account for fairness as mush as possible. The Service Heap acts as a meetingpoint for the processes, avoiding the situation of having two processes which never pairup to communicate.Example 4.2 The following example shows how two processes are enqueued on the RunQueue, and how the Process Manager handles these processes, by using the Service Heapto establish communication.Process Manager Run Queue Service HeapP    R   H  P    R ca, b.Q  H  P    R ca, b.Q  cx, y.R  H  P  ca, b.Q  R cx, y.R  H  P    R cx, y.R  H ca, b.Q P  cx, y.R  R   H ca, b.Q P  cx, y.R  ca, b.Q  R   H  P  Ra,bx,y  Q  R   H  P  Q  R Ra,bx,y  H  P    R Ra,bx,y  Q  H  51CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.6 StandAlone machine with optimized service heap4.3.1 Optimizing The Service HeapAn important optimization that is implemented to this mechanism, is the division of theService Heap into two sections, one for output tasks and another for input tasks. Thisoptimization is a variation to the optimization implemented by Turner. The idea is to havetwo Service Heaps, rather then a single one, where input tasks and replicated input tasksare separated from output tasks, reducing the search space by half2. So now, the algorithmwill work similar to the one described in Section 4.3, with the only difference that, if anoutput is being serviced, then, the search is done only on the Input Service Heap, andviceversa for inputs. If the process needs to be enqueued to the Service Heap, then thisis enqueued to the Input Service Heap, whether its task is an Input or a Replicated Input.If the task is an Output then this is enqueued to the Output Service Heap.2This is the worst case scenario where 12of the tasks are outputs and the other 12are a mixture of inputsand replicated inputs52CHAPTER 4. A STANDALONE VIRTUAL MACHINEReplicated Input tasks are treated in the same manner as Input tasks, throughout the handling of processes. Some researchers suggest that Replicated Inputs should be allocatedon a separate heap, which will be a permanent storage for these processes. This wouldbe a good optimization, but it was not implemented here. The reason for this is that if aReplicated Input had to be stored on a permanent Service Heap, then this will permanentlyblock a channel. Thus, it will have priority over other processes Input Tasks, having afairness breach during the execution of the simulation. Hence, it was decided, that, inour implementation, the machine will have to absorb the cost of enqueuesdequeues ofReplicated Input tasks, but gaining the fairness of the execution.4.4 Handling NonCommunication TasksThe rest of the tasks, such as Tau Task, If Task, Binding Task, Brackets Task and NullTask, are processed differently, since these can reduce a process independently and without using the Service Heap.The Tau Task serves only as an internal operation that is performed within the process.Hence, the Processor does not need to perform any additional handling of this task. Theprocedure is that the next task is simply enqueued at the end of the Run Queue.Example 4.3 Handling Tau TasksProcess Manager Run Queue Service HeapP    R   H  P    R .P  H  P  .P  R   H  P  P  R   H  P    R P  H  53CHAPTER 4. A STANDALONE VIRTUAL MACHINEAn If Task is handled by the Processor by evaluating the conditional equality that itcontains. If the equality is evaluated to a true value, then the process for the then part isenqueued, while if the equality is calculated to a false value, then the process for the elsepart is enqueued.Example 4.4 Handling If TasksProcess Manager Run Queue Service HeapP    R   H  P    R x  yP Q  H  P  x  y  trueP Q  R   H  P  P  R   H  P    R P  H  The Binding Task purpose is to bind the given name to the process. In order to accomplish this, the Processor will issue a fresh name, which is unique throughout the wholesystem, and it will substitute the channel name that was to be bound, with this new freshname. This ensures that the name is unique to the process, which has the same effect asbeing bound. The Processor will then enqueue the process at the end of the Run Queue.Example 4.5 Handling Binding TasksProcess Manager Run Queue Service HeapP    R   H  P    R nP  H  P  nP  R   H  P  Pn0n  R   H  P    R Pn0n  H  54CHAPTER 4. A STANDALONE VIRTUAL MACHINEBrackets Tasks contain a list of processes, hence the Processors job is to enqueue eachof these processes to the Run Queue. The idea is to open up the brackets and release theprocesses that were enclosed as new processes.Example 4.6 Handling Brackets TasksProcess Manager Run Queue Service HeapP    R   H  P    R M  N  H  P  M  N  R   H  P M  N  R   H  P  N  RM  H  P    R M  N  H  The Null Task indicates to the Processor the end of a process, or a Null process. Hence,the Processor will simply discard the instance, and returns to servicing other processes.Example 4.7 Handling Null TasksProcess Manager Run Queue Service HeapP    R   H  P    R 0  H  P  0  R   H  P    R   H  55CHAPTER 4. A STANDALONE VIRTUAL MACHINE4.4.1 Optimizing The Management Of TasksWe employ a small change while handling the processes. The optimization concerns thenoncommunication tasks which are discussed in Section 4.4. As one can notice, thesetasks can avoid being queued up on the Run Queue.Example 4.8 Consider the following process as the simplest of examples. It would begood practice if our processor will execute all of the internal actions and enqueue theprocess P at once, instead of queuing the process after each continuation....PIn our implementation of the machine we shall allow only the queuing of Input tasks,Output tasks and Replicated Input tasks, Communication Tasks, while all of the othertasks have to be processed by a filtering module, before being queued. The Filter willperform this processing until a communication task is available, after which this will beenqueued to the Run Queue.By introducing this policy, we are making the execution more fair between processes.Example 4.9 For instance, note the following state on the Run Queue. ca.P  zcx.zx.Q  cy.R If we do not apply the optimization that is being suggested, then the third process has anadvantage over the second process, because the second process is still waiting to processthe binding action, which does not affect, in any way, the following action. Therefore, byprocessing a noncommunication task, we make sure that all processes have a more justchance of execution.56CHAPTER 4. A STANDALONE VIRTUAL MACHINEFigure 4.7 StandAlone machine applying all the discussed optimizations4.5 EnvironmentsPerforming substitutions within processes during communication, is a very expensive procedure. Apart from being costly, we are never sure if a process will survive through itswhole lifetime. Therefore, if a process had to be stopped for some reason, then all of thesubstitutions that were performed, will be useless and waisted. We improve this situationby introducing Environments. Environments permit us to avoid substitutions completely,meaning that the variable terms are never modified within the processes.An environment E is the mapping from a variable x to a channel name c.E  x 7 cThese mappings are stored using a Hash Table. Note that environments are bound to theusage of a single process Hence we modify our virtual machine, such that we can store57CHAPTER 4. A STANDALONE VIRTUAL MACHINEan environment table Hash Table for each of the processes that the machine will behandling.Therefore, when a substitution is required, instead of performing a direct substitutionnewold, a new entry is added to the process environment table old 7 new. Thus,whenever it is required to use the old variable as a channel, this is looked up in the hashtable and the correct channel name is retrieved.58Chapter 5An Interactive Virtual MachineIn this chapter we discuss the development of a virtual machine which will allow a userto interact with the machine itself, while this performs the same functionalities as thosewithin the StandAlone Virtual Machine. By this we understand that the Interactive Virtual Machine will first have to reduce a given Calculus program, after which the resultsare shown to the user. Based on these results the user will input Calculus commands,which these will trigger the virtual machine to reduce the program even further, thus continuing with the execution. After that the program is again reduced, the machine willdisplay to the user the next results, with which the user can again interact.The idea is to have a user inputting a Calculus program, and while the virtual machineis executing this program, the user can communicate with the program using Calculusnotation. The user will be allowed to compose Input Tasks and Output Tasks, and usethese to communicate with the internal program. This means that, in Calculus terms theuser, together with these actions that are being used, can be regarded as a process. The useris an external process, working concurrently with the virtual machine, and communicatingwith it. We see this in Figure 5.1 where process U is the user and process M is the virtual59CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEFigure 5.1 User interacting with machinemachine. Note how the machine is not a single process, but rather it is composed of theinternal process which make up the Calculus program.This machine focuses mostly with the communication between the user and the machine,however we will allow communication between the internal processes of the programwhich is being executed. In other words we have to provide two modes of operation forthis virtual machine.Stepped Into  when the machine stops for user interaction at every single reduction.The machine outputs its current state to the user, at every step of the execution,even if this is performed internally between the program processes.Stepped Over  the machine will only halt when no more internal reductions are available. This allows the internal program to process logical work that is to be performed, before interacting with the user.5.1 StandAlone vs InteractiveLet us investigate on what an Interactive Machine will serve for, and why it is an importanttool to be developed and analyzed. Note how an Interactive environment, offers manymore interesting uses than the StandAlone environment. But what are the advantages ofdeveloping an Interactive Virtual Machine over a StandAlone Virtual Machine60CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINENote that the StandAlone Virtual Machine developed in Chapter 4 offers limited functionalities. Programs running within the StandAlone machine are restricted only to theenvironment offered by the machine. This makes it hard for the user to assess the programs behavior. In fact, the StandAlone Virtual Machine does not give the user thedesired perspective and thus the user cannot analyze the program internal reductions.The most straightforward use of having an Interactive Virtual Machine is to give the userthe possibility to understand and learn the Calculus notation. The machine can serveas a learning tool for those who wish to learn the Calculus, since the reductions canbe visualized more then when giving examples on paper. The idea is to aid the learningprocess since the user can feel part of the Calculus system.Another useful job that an Interactive Virtual Machine can accomplish, is to debug Calculus programs. The interaction feature can also act as a tracing functionality to theprogram that is being executed. During interaction, the developer can learn of mistakes,or bugs, within the program. This will be possible since the user will have a clear pictureof the current state of the machine.A more interesting observation is that by developing such a virtual machine, we are creating a level of abstraction on top of the Calculus program. Similar to what Sewell accomplished in the development of the NomadicPICT PSP99, SW. Indirectly, the frameworknow has a layer of abstraction where the execution of the internal Calculus program isabstracted away from the user, by means of the interactive virtual machine. The user willstill be communicating with the program using Calculus notation, however the communication is done through the virtual machine, thus the details of the internal program isunobservable from the user. The interesting point is that, both layers are using the sameCalculus notation. As we shall see in Chapter 6, when we test the implementation ofthis machine, is that, if we position a user in front of two Calculus programs whichimplement the same interface inputoutput relations and functionality, then the user will61CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEFigure 5.2 Abstraction layer provided by the Interactive Virtual Machinenot be able to distinguish one from the other despite that these are internally implementeddifferently.At this point we have started to deviate beyond the scope of this study. However, it isextremely motivating, how such an interactive machine when correctly developed, willtransform the environment to a more realistic distributed system. This is so, since aninteractive machine will not only work on a single processor but it is now communicatingwith an external source, in this case the user. An interesting question will be, what if theinteraction had to be performed between two or more interactive machinesIn this kind of machine we see that our priorities change, since at this point, the machinedoes not only have to perform efficiently with its inner processing, but also in retrievinginformation about the current state of the machine. The machine state has to be retrievedand showed to the user as efficient as possible. In this machine the main processing powerhas to tackle the crossing point between the User and the Machine. We need to assumethat the user will be a slow process, so we have to bargain with the internal structure ofthe machine, to make the UserMachine interface more efficient. By applying this changein performance priority we need to apply changes to the internal design of the machine.Fairness is another vital point in this machine implementation, since now, we have theuser acting as an external process, which will have priority at certain times. For this we62CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEhave to examine the two modes of interaction. If we take the Stepped Into1 mode thenthe fairness of the overall machine will be reduced, since the user will have priority overall the other processes. However, note that when the user chooses an internal action to beprocessed, then this choice has to be randomly selected from the set of internal actions.Therefore, it is interesting to note that in this respect we have to take into account thefairness of the execution.On the other hand, when the machine will be operating in Stepped Over2 mode, the fairness of the machine will have to be accounted for in a similar way as within the standalone machine. This means that the user will actually not be given any preference whenoperating in this mode. This is an important point to emphasis on, since the machine willallow interaction when no additional reductions are possible to be processed. Hence, aswe have already discussed in Chapter 4, all the internal processing of the machine willexecute on a rational framework.5.2 Correctness Of The Virtual MachineFor this machine we still need to take into account the correctness of the virtual machine.The objective is very similar to the correctness of the standalone machine see Section4.1. In fact the underlying intentions do not change, meaning that, when a system is givento the machine, the result that is produced has to be equivalent to its realistic counterpart.The only difference here, is that, the correctness has to be monitored iteratively, each timethe user interacts with the machine. It is very important to have the correctness of theinteractive machine stable throughout the whole execution since, the results produced bythe machine will reflect the input that is to follow. Therefore, the interactive machine wewill keep up with our previous objective regarding correctness.1The machine stops and waits for user interaction at every step, even at internal tasks.2The machine will stop and wait for user interaction when no further internal reductions will be possible.63CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEFigure 5.3 Correctness of the Interactive MachineFigure 5.3 shows us the correctness of the virtual machine. Note how the execution of thisvirtual machine, is engaged into an iterative process and the internal processing is triggedupon user interaction. Therefore, the virtual machine will have to produce accurate resultsat each iteration. It is important to understand that the results, depend on the previous userinput, hence the machine has to produce correct results with respect to the inputs that theuser has done.As we shall see, in order to have control over what the user inputs into the machine, wewill use channel typing. Channel types will allow the machine to typecheck the actionsthat are given to the machine by the user. If the action is not correctly typed, then themachine will complain to the user, thus avoiding arity mismatch at runtime.5.3 Interactive ArchitectureThe development of an Interactive Virtual Machine, will mostly involve, an efficientmechanism which allows us to read the current machine status. This machine will bedisplaying the current state of the internal program, at every step during the simulated64CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEexecution. Hence, it is crucial to have optimal performance, in the linkage between theuser and the machine.We start by reorganizing the architecture of how processes are handled. Note that, thestructure of the processes is the same as in the StandAlone Virtual Machine. This meansthat we will be operating on the same intermediate code representation, as discussed inSection 3.4.1.The architecture design for the Interactive Virtual Machine is given in Figure 5.4. We havea Process Manager, which will be handling all process communication. By observing thisdesign, one can note that, some of the strategies are similar to the StandAlone VirtualMachine.We make a distinction between Communication Tasks and NonCommunication Tasks,after which we employ a further step to make another distinction between the channelrequests of the communication tasks. This means that now, we are categorizing the communication tasks, by the channel name that is being requested.Figure 5.4 Interactive Virtual Machine Architecture65CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINETo accomplish this, we define an object Channel, which represents the actual channel ofcommunication, consisting mainly of an input queue and an output queue. The ProcessManager which will enqueue processes on the respective queue. Several of these channelswill be stored using a Hash Table, which allows easy and efficient access. Thus, wenow have a design which will allow us to retrieve the current state of the machine veryeffectively and with the least amount of processing costs. For example, if we had to listthe key elements of the Hash Table we immediately have all the channel names that arebeing used by the machine.5.3.1 ChannelsA Channel is composed of a name, identifying the channel, and a channel type objectclassifying the channel to a particular type definition. A channel will contain two processqueues one will queue input task and replicated input tasks, while the other will queueoutput tasks. These queues are dedicated queues, meaning that they will only enqueueprocesses that are requesting the same channel.Note that the queues with this channel object, are similar to the Service Heap of the StandAlone Virtual Machine. In fact, we employed the first optimization, by distinguishing theinput queue from the output queue, from the very start.Criteria are defined for processes requesting to queue up for the use of a channel object.The first is that only processes with a communication task3 can be enqueued. Anothercriteria is that, the channel being requested and the channel used by the task, have to bethe same one, meaning that both the name and the channel type have to be equivalent.This ensures that runtime errors are not introduced by the user during interaction.3A communication task can be either an Input Task, a Replicated Input Task or an Output Task.66CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEFigure 5.5 Channel ArchitectureThe most important function that a channel object can perform, is that a channel objectcan output its current state. The state of the channel is what is displayed to the user, and itshould give an overview of how the user can interact with this particular channel. Therefore, the state of a channel is simply two boolean values, representing the two queues forinputs and outputs. These values will indicate if a channel has available processes awaiting in the input and output queues, hence, a true value means that at least one process iswaiting in that queue, while a false value means that the queue is empty. This allows themachine to communicate to the user, the different combinations of a channel state.5.4 Handling Process CommunicationThe communication between the processes is handled by the Process Manager. At thisstage it is important to mention that in this virtual machine we will be dealing with twosituation of process communication. Either a machine process communicates with theuser during interaction, or two machine processes communicate internally. For the userto communicate with the machine, the user will have to create a task, which this will be67CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEhandled as the process which is to be serviced, meaning that communication will have tobe done with this process if possible. On the other hand, if two of the machine processeswill communicate internally between them, then from the users point of view this will beregarded as an internal reduction.When a user launches a task into the machine, the Process Manager selects the channelthat is being requested. The channel retrieved is first checked for type equivalence. Oncethat the channel is identified as correct, the Process Manager will retrieve the first processawaiting to communicate from the channel. Now, if the users task is an input task or areplicated input task, then the first process on the output queue is retrieved. On the otherhand, if the users task is an output task, then the first process from the input queue isretrieved. The Process Manager will then reduce the two processes in the same manneras in the StandAlone Virtual Machine, thus following the rules in Table 2.3.For internal communication, the Process Manager will randomly select a channel whichhas nonempty queues input and output. By having a channel with at least one taskenqueued on each of the queues, then this signifies that the channel can communicateinternally. Hence, the process manager will retrieve these processes and communicationis accomplished.5.4.1 Internal ReductionWhen discussing internal reductions within the Interactive machine, we mean that themachine will either reduce a noncommunication task, or that the machine will allow twoprocesses having a matching pair of communication tasks, to communicate internally.Therefore, it is important to note that, from the users point of view both of these situationsare regarded as internal reductions.68CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINERecall that we are dealing with two modes of interactivity within this virtual machine.When executing a Stepped Into simulation, then we need to allow the user to experienceeven internal reduction happening within the machines program. Hence, the optimization employed for the StandAlone machine, is not applicable in this case. However, ifa Stepped Over simulation is being run, then it is important to ensure that all internalreductions are performed.To handle the Stepped Into simulation, we enforce that only one reduction is performedat every user interaction. This means that the NonCommunication Queue seen in Figure5.4 will enqueue processes awaiting for a noncommunication task to be performed. Achannel which can perform an internal communication will be suppressed from reducing.Therefore, we then give the user the option to either interact with the machine by introducing a task, or by instructing the machine to perform internal tasks. When performinginternal reductions within the machine, the user will still be able to notice the changesoccurring in the program.During Stepped Over execution, the interactive machine will check for both types of internal reductions and keep reducing until no further are available. This means that for everysingle user interaction, the virtual machine can possibly perform a number of reductions.Please note, that during this mode of operation, the virtual machine will not be utilizingthe NonCommunication Queue since, these will not be allow to stand idle within thesystem.5.5 EnvironmentsIn the implementation of the Interactive Virtual Machine, we make use of channel nameenvironments just as these are used in the StandAlone machine. Therefore, we extendour channel object representation, and allow it to hold a set of name mappings for each of69CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEthe processes that are enqueued.Figure 5.6 Environment Mappings between the user and the virtual machineThe difference that is required for the Interactive machine is that we have to keep a setof name environments for the user. Remember that the user is regarded as an externalprocess, hence the machine will have an environment table, which will map the channelnames which the user is using to the real channel names within the machine. As Figure5.6 shows, the environments mappings, are used to link the users channel names to theappropriate channel name within the virtual machine.5.6 Graphical User Interface DesignThroughout this project the GUI Graphical User Interface of the application was notpart of the main objectives. However, since we have discussed the development of anInteractive Virtual Machine, we now realize that for an interactive machine to be easilyunderstandable by the user, we require a userfriendly presentation.Most important of all is how the GUI will present the virtual machine status. The mostsuitable solution was to design a table as depicted in Figure 5.7. This will list all of thefree channels that the machine currently has available. The list will also give the typeof the channel, thus the user will know how to handle communication with every listedchannel. The channel rows have two columns representing the two queues for the channel.Checkboxes can be used to indicate whether processes are awaiting or not, within thechannel queues.70CHAPTER 5. AN INTERACTIVE VIRTUAL MACHINEFigure 5.7 Proposed table showing the current state of the machineA panel will allow the user to create a task, and process this task within the virtual machine. Thus, on doing so, the status table will change the values showing how the systemstate has changed with the effect of the given task.All of the other modules that we discussed will be incorporated within a simple application, which will serve as an Integrated Development Environment for Calculus. TheIDE will offer an editor where Calculus programs can be written using the Language,and options will be available to simulate the program on the two virtual machines that wediscussed.71Chapter 6EvaluationThis chapter mostly consist of testing analysis on the virtual machines that have beendeveloped. As one can note, we emphasized on the correctness of our virtual machines.Now we get to evaluate the correctness of both machines. In Chapters 4 and 5, we mentioncorrectness before the development, so that throughout the implementation our mind wasfocused on the construction of correct virtual machines, which produces accurate results.In this chapter we tackle the final part of machine correctness. Therefore, we have toverify, that both of our machines are indeed simulating how processes communicate, asdefined in Table 2.3.Figure 6.1 shows clearly our task in this chapter. Note that we will be focusing on theequivalence of the results. This means that we will compose Calculus examples, andsimulate the execution of these examples on our virtual machines, thus obtain the firstresult. Hence, we will follow through the same examples on paper, to obtain a secondresult, we check for the equality of these results and if these are equivalent then thisshows that the virtual machine is correct. To prove the correctness of the virtual machineswe would have to test each of the different situations that the machines can end up in.72CHAPTER 6. EVALUATIONFigure 6.1 Evaluating the correctness of the virtual machinesThe plan for the testing stages, is to, first test our StandAlone Virtual Machine implementation, followed by, testing the Interactive Virtual Machine using the same examples.This will allow us to verify that both machines are correct as well as consistent with eachother. We then move on to, test the abstract layer of the Interactive Virtual Machine bycomposing examples, with different implementations, and investigate whether the user isable to distinguish between the examples.6.1 Testing the StandAlone Virtual MachineThe StandAlone virtual machine was first tested for the basics of the Calculus actions,after which more complex examples where used for the testing. Note that the simpletests where omitted from this chapter, but we will be dealing with a number of elaboratedexamples. These examples offer all of the required test cases for our StandAlone virtualmachine.6.1.1 Test case  Memory cellThe first example is the same one given in Example 2.13 of Chapter 2. This exampleconsists of a process capable of generating memory cells, and an other process that is73CHAPTER 6. EVALUATIONutilizing one of these memory cells. This test will verify the correctness of the virtualmachine for several of reduction rules given in Table 2.3.SetupThe memory cell example was coded as a Calculus program and used for this test. Thisprogram is illustrated in Section A.1 of the appendices. The program when given to theStandAlone machine should reduce to the following two processes, where helloworld isthe value that was temporary stored at the cell.createcellvalue, getcell.cellcellvalue  getcellcell helloworld ResultsAt the end of the development, the results obtained where satisfying. The expected resultswhere obtained. This test served for the verification of the rules rcommunication andrreplicatedcommunication of Table 2.3. We also tested the scoping principle, andverified that bound names and free names are handled correctly.6.1.2 Test case  Changing the network of communicationWe next test the machine using the Calculus program given in Section A.2. This program illustrates how the Calculus capabilities of how the communication network between processes change dynamically. Let us first examine the logical meaning behind thisprogram. Take the following system of processes.P  Q  R74CHAPTER 6. EVALUATIONwhere P  onechannel.if channel  change then nonen.nmessageQ  onechange.onenew.twonewR  twonew.newhelloworldAs one can note process P is unaware of process R and these cannot communicate. However, process Q will communicate with process P the channel change. Hence, the processP will check for the condition channel  change. If this is so, then the process P communicates a fresh channel name to the process Q which will in turn communicate withprocess R. Therefore, at this stage, process R is aware of process P by means of the newchannel.SetupThe StandAlone virtual machine is given the program as illustrated in Section A.2. Themachine will perform a correct simulation if the end results consists of inactive processes,meaning that communication has been achieved correctly throughout.ResultsAt this stage some problems where identified, since the virtual machine was not producingcorrect results as expected. However, these problems where tackled and the tests whereperformed once again. Variations to this test where used to help in the debugging of theproblem. Finally we have satisfying results on the outcome.75CHAPTER 6. EVALUATION6.1.3 RemarksThroughout the evaluation stages of the StandAlone virtual machine, we note a numberof faults. The most involving problems that we needed to solve where the ones related tothe rule rreplicatedcommunication and the handling of bound names. The utmost ofefforts have been done to find a solution to these problems, and which was finally found.It is important to mention that, the testing during this stage served as an important phaseto fully understand the concepts of the Calculus notation.6.2 Testing the Interactive Virtual MachineThe Interactive Virtual Machine will be mainly tested for its interactive features. Notethat the reduction procedures that are implemented within the Interactive virtual machine,are identical to the reduction procedures within the StandAlone virtual machine. Thus,the Interactive machine was tested using, similar tests as the ones performed on the StandAlone machine. This ensured us that the internal operations are consistent between thetwo virtual machines. Therefore, the testing that is performed here, is to verify that theusertomachine interaction is achieving accurate results. We then test the machine forthe feature of abstraction that it offers, by constructing a Calculus program with similarfunctions as the one used during the first test, and investigate on whether the user cannotice the difference between the two programs.6.2.1 Test case  Stack AA stack implementation was constructed using Calculus notation, and this was thenimported to a Language program as illustrated in Section A.3. The Stack program76CHAPTER 6. EVALUATIONprovides a Calculus declaration, which when invoked, this will return a unique channelto a stack, b. This channel b representing a stack, will then return two channels, onfor pushing channel names on top of the stack push, and another to pop channel namesfrom the top of the stack pop. When channel names are outputted using the push, thenthis represents the push feature. On the other hand, to pop channel name, we first have tooutput a listener channel, and then we pop the channel name to the top of the stack, byinputting from this listener channel.SetupFigure 6.2 gives a trace through the steps involved during the test. We load the stackprogram to the Interactive machine at Step 1. This gives us the channel stack, indicatingthat an input is available, hence in Step 2 we output on the channel stack a channel namemystack. The channel mystack will then indicate the availability of output. Note as wellthat the types of the channels are changing accordingly. These types are the same asdeclared in the program and these can be viewed by the user during interaction. At Step3, we input from the channel mystack two values, and we use the variables mypush andmypop. Notice how these variables are given the corresponding channel names, and howthese channel names are added to our table. At this stage we can start pushing data on tothe stack. At Step 4 we push the channel names one, two and threeWe now test that the stack is performing the expected job, by performing a pop. Thus,at Step 5 we output the channel listener on the channel pop0. The channel listener iscorrectly added to the table, indicating that it is ready to output a channel name. Therefore,at Step 6 we perform an input from the channel listener. The variable value is assignedthe channel name three, which is the expected result since the channel name three, wasthe last name that was pushed on the stack.77CHAPTER 6. EVALUATIONFigure 6.2 Trace of stack program78CHAPTER 6. EVALUATIONTo confirm that the stack is working accurately, at Step 7 we push the channel name teston to the stack. Hence, at Step 8 we empty the stack by repeating the steps 5 and 6 foreach value to be popped from the stack. As one can notice, the returning results are asexpected, meaning that the first channel name retrieved was test, after which the namestwo and one, where retrieved sequentially. Notice, how the last pop did not retrieve anychannel name, since the stack is empty.ResultsThe expected results have were achieved from the test that was applied. Variations tothe sequence given in Figure 6.2, where performed as a test to verify that the Interactivevirtual machine is simulating the execution of Calculus correctly. These tests and theone discussed previously, gave very promising results. Note how program Stack A inSection A.3 is testing all of the features tackled throughout this dissertation. We evenverified that the typing column is showing accurate values, meaning that the type given tothe channel is the correct one.6.2.2 Test case  Program Details AbstractionAfter that the Interactive virtual machine has been verified as correct and that it is producing accurate results as expected, we investigated on the interactive feature of the machine.We developed a Calculus program with the same functionalities as that of Stack A thatwas used for the previous test. This program is given in Section A.4 of the appendices.The difference in this stack implantation Stack B is that the channel names are beingstored using two lists rather the a single list as in Stack A. This means that the head ofthe stack will iterate the push feature between the two stacks, and for the pop feature thesame principle applies but it has to be done in an opposite direction.79CHAPTER 6. EVALUATIONSetupThe plan for this test was to perform the same sequence of procedures, as performed inthe previous test on both stack implementations. We simply switch the Stack A programwith that of Stack B, and perform the same test. This would verify that the two programshave consistent functionalities, thus the user is unable to distinguish the Stack A programfrom the Stack B program.Figure 6.3 Program details are abstracted away from the userResultsThis test turned out to be most satisfying, since no difference could be noted between thetwo implementations. Both stacks are instantiated in the same manner, and both providethe push channel and the pop channel. Other tests have been performed, and it was notedthat the two programs have to be constructed using the same interface, meaning that theinteraction with the user has to provide the same type of channels and amount.6.2.3 RemarksPromising results have been achieved through these tests that have been carried out. To acertain point we proved the correctness of the machines, and verified most of our specula80CHAPTER 6. EVALUATIONtions especially the interactive abstraction that the Interactive virtual machine is capableof offering.6.3 LimitationsFollowing the evaluation stage, we can discuss a number of known problems and thelimitations of the application that has been developed.Both of our virtual machines do not conduct any Garbage Collection. By Garbage Collection we understand, that those channels that are no longer referenced, or no longer used,then these can be disposed. By disposing of these channels, the machine will be able toperform more efficiently since, the machine will be accounting for resource handling.Another limitation that our machine has is the lack of the Summation operator. This wasalready discussed earlier, and we explained how this was purposely omitted, because itoffers more complexity to the overall structure of the machines. However, it still remainslisted as a limitation since certain Calculus program which makes use of this operatorcannot be simulated on our machines.A crucial limitation that was noted concerns channel typing. Since, the typing mechanismthat was adopted for the development of the virtual machines is a limited one, then thisalso limits the capabilities of the virtual machines. We identify the Interactive Virtual Machine more restricted in this significance, since the StandAlone machine can be executedwithout the TypeChecker module, thus allowing it to simulate even complex programs.81Chapter 7Conclusions and Future WorkThroughout this dissertation we have seen how Calculus notation was easily encapsulated into a simple programming language, such as the Language. For this dissertation,the Language described in this study, has proven to be a decent language, to programa Calculus program. We even described a simple typing system to be used when composing Calculus programs, and this was followed by a TypeChecker to ensure correctchannel typing. We then described the construction of the intermediate code representation for Calculus. We suggested that this representation would act as the transitionalpoint between Calculus notation and various virtual machines. This guided us to develop a compiler to translate Calculus notation into this intermediate representation. Wethen focused on Turners, Abstract Machine for Calculus, and we illustrate how a similar machine can be implemented. This virtual machine was able to interpret Calculusprograms, and simulate the communication of the processes within an encloses environment. We next suggested to develop an Interactive virtual machine, which will extend thefunctionality of the StandAlone virtual machine, by allowing an external source to communicate with the machine. We even proposed, how such a machine would be capable ofabstracting the implementation details of Calculus programs from the user.82CHAPTER 7. CONCLUSIONS AND FUTURE WORKThe virtual machine implementations where then evaluated and tested for correctness andaccuracy. A number of examples where introduced, and these were used to verify that theStandAlone virtual machine is able to produce correct results, when compared with therealistic counterparts. Subsequently, the Interactive virtual machine was tested using theseexamples. However, special interest was given to the two different Stack implementations.These Calculus programs offered a stack data structure, using the same usertomachineinterface, but have a different inner implementation. We proved that the Interactive virtualmachine, does indeed provide a layer of abstraction to the user. The results demonstratedhow, a typical user is unable to distinguish between two Calculus programs, that offerthe same functionalities but with different internal methodologies.At this point we can suggest a few ideas for possible further work. Maybe the mostobvious task to follow would be to improve on the limitations of the developed virtualmachines. As we have stated, the current implementations to not offer Garbage Collection for unreferenced channels and it does not offer the possibility to use the Summationoperator. Hence, a potential task would be to develop a virtual machine which extendsthese functionalities.Throughout this study we did not focus much on typing mechanisms, since this was beyond the initial objectives. However, we did tackle simple channel typing in brief, andthis has an interesting topic in the field of Calculus. For that reason, a prospective taskwould be to elaborate on typing techniques for Calculus. We believe that typing isessential to carry out accurate interactivity, between the user and the Interactive virtualmachine. A potential project would be to develop a system of interactive machine, whichwill act as interactive agents over a distributed system.In conclusion we believe that, the study about Calculus has served as a stepping stonefor observing a different perspective of programming, and appreciating detailed issuesregarding concurrency and communication, from a distinct point of view.83Appendix AExamples of Calculus ProgramsThe following Calculus programs were constructed during this study, as part of theobjectives for the dissertation. These examples are used in Chapter 6, during the testingphase of the development.84APPENDIX A. EXAMPLES OF CALCULUS PROGRAMSA.1 Memory cellch createcell    ,       ch cell     ch helloworld   ch listener       begincreatecellvalue,getcell.cellcellvalue  getcellcell createcellhelloworld,listener.listenermyfirstcell.myfirstcellmessage.messageendA.2 Changing the network of communicationvar COM       ch one  COMch two  COMch change     ch n     ch helloworld   beginonechannel.if channelchange then nonen.nmessage onechange.onenew.twonew twonew.newhelloworldend85APPENDIX A. EXAMPLES OF CALCULUS PROGRAMSA.3 Stack Avar PUSH     var POP       var B  PUSH, POPch stack  Bch b  Bch pop  POPch push  PUSHvar rec CELL    , CELLch a  CELLch endd  CELLch head  CELLch createcell    , CELL, CELL def stackbbeginendd,head,createcell,push,popbpush,pop.headendd.0 createcellx,next,ret.aax,next.0  reta.0 pushx.heady.createcellx,y,head.0 popz.headx.if x  enddthen headendd.0else xv,w.zv.0  headw.0end86APPENDIX A. EXAMPLES OF CALCULUS PROGRAMSA.4 Stack Bvar PUSH     var POP       var B  PUSH, POPch stack  Bch b  Bch pop  POPch push  PUSHvar rec CELL    , CELLch a  CELLch end1  CELLch head1  CELLch end2  CELLch head2  CELLch current   CELL ch createcell    , CELL, CELL ch reset   def stackbbeginend1,end2,head1,head2,createcell,push,pop,current,reset bpush,pop. reset.head1end1.0  head2end2.0  currenthead1.0 reset createcellx,next,ret.aax,next.0  reta.0 pushx.currenthead.heady.createcellx,y,head.if headhead1 then currenthead2 else currenthead1 popz.currenthead.if headhead1then currenthead2.head2x.if xend2then reset else xv,w. zv  head2welse currenthead1.head1x.if xend1then resetelse xv,w.zv  head1w    end87Appendix BEBNF for the LanguageThe following EBNF describes the language that we designed, including all the requiredchanges. The standard Extended BackusNaur form EBNF ISO96 is used, which is anextension of the basic BackusNaur form BNF metasyntax notation.Start  Include  Declaration  Definition  Declaration  BEGIN  Pipe  END   EOF Include   INCLUDE  File  SEMICOLON File   STRING Definition   DEF  DefName  BEGIN  Declaration Pipe  END DefName  Name  LPAREN  Tuples  RPAREN RecArguments  TypeV ariable  RecArg  Name COMMA  TypeV ariable  RecArg  Name88APPENDIX B. EBNF FOR THE LANGUAGEArguments  TypeV ariable  Arg  COMMA  TypeV ariable  Arg Arg    Arguments  RecArg    RecArguments  TypeV ariable   TY PEV AR DecChannel   CH  Name  ASS  TypeV ariable  Arg SEMICOLON DecV ariable   V AR  TypeV ariable  ASS  TypeV ariable  Arg SEMICOLON DecRecV ariable   V AR  REC  TypeV ariable  ASS TypeV ariable  RecArg  SEMICOLON Declaration  DecChannel  DecV ariable  DecRecV ariableInt   INTEGER    STOP Pipe  Process PIPE  Pipe  Brackets PIPE  PipeBrackets   LPAREN  Pipe  RPAREN Process  Continuation  RestrictionContinuation  Input  Output  Tau  ReplicatedInput DefinitionCall Print CONTINUATION  Process IfThen  Stop  BracketsReplicatedInput   REPLICATION  InputStop   STOP Input  Channel  INPUT  NameTuplesOutput  Channel  OUTPUT  TuplesChannel   STRING Tuples  Channel COMMA  Channel NameTuples  Name COMMA  Name Name   STRING Tau   TAU Restriction   LPAREN  HASH  Channel BNamesBNames   COMMA  Channel BNames  RPAREN  Brackets  ProcessIfThen   IF  Expression  THEN  Brackets ELSE  BracketsExpression  Name  EQUALS  NameDefinitionCall  Channel  LPAREN  Tuples  RPAREN Print   PRINT  LPAREN  Tuples  RPAREN 89Appendix CClass DiagramsThis appendix contains classes diagrams, which describe the most important modules ofthe application.The PiParserVisitor class represents the visitor interface generated by the JavaCC tools.Several modules implement this interface, such as the TypeChecker and the Compiler.The TaskManager class is the core module of the StandAlone virtual machine. It encapsulates all of the reduction procedures and it handles the process communication.The Channel class represents the channel of communication within the Interactive virtual machine. The main changes that where applied to this machine revolve around theChannel class.The Machine class is the focal point of the Interactive virtual machine, by scheduling theprocesses on Channel objects. It also acts as the bridge between the user and the internalprogram, since it provides an interactive interface.90APPENDIX C. CLASS DIAGRAMSFigure C.1 PiParserVisitor Class Diagram Visitor interface generated by JavaCC91APPENDIX C. CLASS DIAGRAMSFigure C.2 TaskManager Class Diagram92APPENDIX C. CLASS DIAGRAMSFigure C.3 Channel Class Diagram93APPENDIX C. CLASS DIAGRAMSFigure C.4 Machine Class Diagram94Appendix DUser ManualFigure D.2, gives a screen shot of the application while running in editing mode. One canedit a number of Calculus programs. By using the toolbar functions or the main menu,one can create new files, save files, open existing files, and perform the standard functionsoffered by editors.Figure D.1 The editors toolbar95APPENDIX D. USER MANUALFigure D.2 Application running in editing modeThe application offers MDI support as shown in Figure D.3. Multiple documents can beopened concurrently, either displayed as separate windows or as a serious of tabs.Figure D.3 MDI support96APPENDIX D. USER MANUALFigure D.4 The editors sidebarThe editors sidebar is used to run the three main modules found in the application. Onecan either parse the program, and display a graphical view of the syntax tree, or simulatethe program on the StandAlone machine or simulate the program on the Interactive machine.Figure D.5 Showing the Syntax Tree for the program97APPENDIX D. USER MANUALThe user interface for the StandAlone machine, illustrates how the machine has computed the program internally.Figure D.6 Running the StandAlone virtual machine98APPENDIX D. USER MANUALThe interactive interface offers a panel for the processing of tasks. The user is able toselect a task and a channel, and input either a number of names or variables accordingly.For multiple names, or variables these have to be separated by commas. The table showthe current state of the Virtual Machine, given a list of channels, their type and the availability for input and output. The bottom panel gives the default output stream that is usedto receive channel names.Figure D.7 Running the Interactive virtual machine99Appendix EContents of the CDRom100BibliographyApp02 Andrew W. Appel. Modern Compiler Implementation In Java. CambridgeUniverity Press, 2002.ISO96 ISOIEC14977. Information Technology, Syntactic Metalanguage, ExtendedBNF. ISO Standards, 1996.Kob Naoki Kobayashi. Type systems for concurrent programs. Technical report,Department of Computer Science, Tokyo Institute of Technology.Mil89a Robin Milner. A calculus of mobile processes, part i. Technical report, University of Edinburgh, 1989.Mil89b Robin Milner. A calculus of mobile processes, part ii. Technical report, University of Edinburgh, 1989.Mil99 Robin Milner. Communicating and Mobile Systems the PiCalculus. Cambridge University Press, June 1999.PSP98 Pawel T. Wojciechowski Peter Sewell and Benjamin C. Pierce. Location independence for mobile agents. Technical report, In Workshop on Internet Programming Languages, Chicago, May 1998.PSP99 Pawel T. Wojciechowski Peter Sewell and Benjamin C. Pierce. Locationindependent communication for mobile agents a twolevel architecture. Technical report, Computer Laboratory, University of Cambridge, 1999.101BIBLIOGRAPHYPT00 Benjamin C. Pierce and David N. Turner. Pict A programming language basedon the picalculus. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors,Proof, Language and Interaction Essays in Honour of Robin Milner, pages455494. MIT Press, 2000.Sew00 Peter Sewell. Applied pi  a brief tutorial. Technical report, Computer Laboratory, University of Cambridge, 2000.SW Peter Sewell and Pawel T. Wojciechowski. Nomadic pict Language and infrastructure design for mobile agents. Technical report, Computer Laboratory,University of Cambridge.SW03a Davide Sangiorgi and David Walker. The PiCalculus  A Theory of MobileProcesses, chapter 1. 2003.SW03b Davide Sangiorgi and David Walker. The PiCalculus  A Theory of MobileProcesses, chapter 6. 2003.Tur95 David N. Turner. The Polymorphic Picalculus Theory and Implementation.PhD thesis, University of Edinburgh, 1995.Wis01 Lucian Wischik. Explicit fusions Theory and implementation. Technical report, Computer Laboratory, University of Cambridge, 2001.102
