An Introductory Textbook on CyberPhysical Systems Edward A. LeeEECS DepartmentUniversity of California, BerkeleyBerkeley, CA, USAealeecs.berkeley.eduSanjit A. SeshiaEECS DepartmentUniversity of California, BerkeleyBerkeley, CA, USAsseshiaeecs.berkeley.eduABSTRACTWe introduce a textbook that strives to identify and introduce the durable intellectual ideas of embedded systems asa technology and as a subject of study. The emphasis is onmodeling, design, and analysis of cyberphysical systems,which integrate computing, networking, and physical processes. The book is intended for students at the advancedundergraduate level or the introductory graduate level, andfor practicing engineers and computer scientists who wishto understand the engineering principles of embedded systems. It is also an experiment in publishing. The book isavailable free in electronic form, in the form of PDF file designed specifically for online reading. Specifically, the layout is optimized for mediumsized screens, particularly theiPad and forthcoming tablets. Extensive use of hyperlinksand color enhance the online reading experience. A printversion will be available through a printondemand service,enabling rapid evolution and immediate correction of errors.See httpLeeSeshia.org.1. INTRODUCTIONThe most visible use of computers and software is processing information for human consumption. We use themThis work was supported in part by NSF CAREER grant0644436, an Alfred P. Sloan Research Fellowship, andthe Center for Hybrid and Embedded Software SystemsCHESS at UC Berkeley, which receives support from theNational Science Foundation NSF awards CCR0225610ITR, 0720882 CSREHS PRET, 0647591 CSRSGER, 0931843 ActionWebs and 0720841 CSRCPS, the U. S. Army Research Office ARO W911NF0720019, the U. S. Air Force Office of Scientific ResearchMURI FA9550060312 and AFTRUST FA95500610244, the Air Force Research Lab AFRL, the MultiscaleSystems Center MuSyc, and the following companies Agilent, Bosch, National Instruments, Thales, and Toyota.Permission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page. To copy otherwise, torepublish, to post on servers or to redistribute to lists, requires prior specificpermission andor a fee.Workshop on Embedded Systems Education October 28, 2010, Scottsdale,USA.Copyright 2010 ACM 1581130000000010 ...10.00.to write books like the one presented here, search for information on the web, communicate via email, and keep trackof financial data. The vast majority of computers in use,however, are much less visible. They run the engine, brakes,seatbelts, airbag, and audio system in your car. They digitally encode your voice and construct a radio signal to sendit from your cell phone to a base station. They controlyour microwave oven, refrigerator, and dishwasher. Theyrun printers ranging from desktop inkjet printers to largeindustrial highvolume printers. They command robots ona factory floor, power generation in a power plant, processesin a chemical plant, and traffic lights in a city. They searchfor microbes in biological samples, construct images of theinside of a human body, and measure vital signs. They process radio signals from space looking for supernovae and forextraterrestrial intelligence. They bring toys to life, enablingthem to react to human touch and to sounds. They controlaircraft and trains. These less visible computers are calledembedded systems, and the software they run is calledembedded software.Despite this widespread prevalence of embedded systems,computer science has, throughout its relatively short history,focused primarily on information processing. Only recentlyhave embedded systems received much attention from researchers. And only recently has the community recognizedthat the engineering techniques required to design and analyze these systems are distinct. Although embedded systemshave been in use since the 1970s, for most of their historythey were seen simply as small computers. The principal engineering problem was understood to be one of coping withlimited resources limited processing power, limited energysources, small memories, etc.. As such, the engineeringchallenge was to optimize the designs. Since all designs benefit from optimization, the discipline was not distinct fromanything else in computer science. It just had to be moreaggressive about applying the same optimization techniques.Recently, the community has come to understand that theprincipal challenges in embedded systems stem from theirinteraction with physical processes, and not from their limited resources. The term cyberphysical systems CPSwas coined by Helen Gill at the National Science Foundation in the U.S. to refer to the integration of computationwith physical processes. In CPS, embedded computers andnetworks monitor and control the physical processes, usuallywith feedback loops where physical processes affect computations and vice versa. The design of such systems, therefore, requires understanding the joint dynamics of computers, software, networks, and physical processes. It is thisstudy of joint dynamics that sets this discipline apart.When studying CPS, certain key problems emerge thatare rare in socalled generalpurpose computing. For example, in generalpurpose software, the time it takes to performa task is a performance issue, not a correctness issue. It isnot incorrect to take longer to perform a task. It is merelyless convenient and therefore less valuable. In CPS, the timeit takes to perform a task may be critical to correct functioning of the system. In the physical world, as opposed tothe cyber world, the passage of time is inexorable.In CPS, moreover, many things happen at once. Physical processes are compositions of many things going on atonce, unlike software processes, which are deeply rooted insequential steps. Abelson and Sussman 1 describe computing as procedural epistemology, knowledge through procedure. In the physical world, by contrast, processes arerarely procedural. Physical processes are compositions ofmany concurrent processes. Measuring and controlling thedynamics of these processes by orchestrating actions thatinfluence the processes are the main tasks of embedded systems. Consequently, concurrency is intrinsic in CPS. Manyof the technical challenges in designing and analyzing embedded software stem from the need to bridge an intrinsically sequential semantics with an intrinsically concurrentphysical world.Today, getting computers to work together with physical processes requires technically intricate, lowlevel design.Embedded software designers are forced to struggle withinterrupt controllers, memory architectures, assemblylevelprogramming to exploit specialized instructions or to precisely control timing, device driver design, network interfaces, and scheduling strategies, rather than focusing onspecifying desired behavior. The sheer mass and complexity of these technologies tempts us to focus an introductorycourse on mastering them. But a better introductory coursewould focus on how to model and design the joint dynamicsof software, networks, and physical processes. Such a coursewould present the technologies only as todays rather primitive means of accomplishing those joint dynamics. Thebook presented here is our attempt at a textbook for such acourse.2. RELATED BOOKSMost texts on embedded systems focus on the collection oftechnologies needed to get computers to interact with physical systems 2, 3, 4, 9, 14, 16, 19, 22, 23. Others focus onadaptations of computerscience techniques like programming languages, operating systems, networking, etc. todealing with technical problems in embedded systems 5,6, 18. While these implementation technologies are today necessary for system designers to get embedded systems working, they do not form the intellectual core of thediscipline. The intellectual core is instead in models and abstractions that conjoin computation and physical dynamics.A few textbooks offer efforts in this direction. Jantsch 8focuses on concurrent models of computation, Marwedel 12focuses on models of software and hardware behavior, andSriram and Bhattacharyya 20 focus on dataflow modelsof signal processing behavior and their mapping onto programmable DSPs. These are excellent starting points. Models and concurrency such as dataflow and abstract modelsof software such as Statecharts provide a better startingpoint than imperative programming languages like C, interrupts and threads, and architectural annoyances that adesigner must work around like caches. These texts, however, are not suitable for an introductory course. They areeither too specialized or too advanced or both. This bookis our attempt to provide an introductory text that followsthe spirit of focusing on models and their relationship torealizations of systems.The variety of textbooks on embedded systems that haveappeared in recent years is surprising, often reflecting theperspective of a more established discipline that has migrated into embedded systems, such as VLSI design, controlsystems, signal processing, robotics, realtime systems, orsoftware engineering. Some of these books complement theone we present nicely. We strongly recommend them to thereader who wishes to broaden his or her understanding ofthe subject.Specifically, Patterson and Hennessey 17, although notfocused on embedded processors, is the canonical referencefor computer architecture, and a mustread for anyone interested embedded processor architectures. Sriram and Bhattacharyya 20 focus on signal processing applications, suchas wireless communications and digital media, and give particularly good coverage to dataflow programming methodologies. Wolf 23 gives an excellent overview of hardware design techniques and microprocessor architectures and theirimplications for embedded software design. Mishra and Dutt13 give a view of embedded architectures based on architecture description languages ADLs. Oshana 15 specializes in DSP processors from Texas Instruments, giving anoverview of architectural approaches and a sense of assemblylevel programming.Focused more on software, Buttazzo 5 is an excellentoverview of scheduling techniques for realtime software. Liu11 gives one of the best treatments yet of techniques forhandling sporadic realtime events in software. Edwards 6gives a good overview of domainspecific higherlevel programming languages used in some embedded system designs.Pottie and Kaiser 18 give a good overview of networkingtechnologies, particularly wireless, for embedded systems.No single textbook can comprehensively cover the breadthof technologies available to the embedded systems engineer.We have found useful information in many of the books thatfocus primarily on todays design techniques 2, 3, 4, 7, 9,14, 16, 19.3. THEME OF THE BOOKThe major theme of our book is on models and their relationship to realizations of systems. The models we study areprimarily about dynamics, the evolution of a system state intime. We do not address structural models, which representstatic information about the construction of a system, although these too are important to embedded system design.Working with models has a major advantage. Models canhave formal properties. We can say definitive things aboutmodels. For example, we can assert that a model is deterministic, meaning that given the same inputs it will alwaysproduce the same outputs. No such absolute assertion ispossible with any physical realization of a system. If ourmodel is a good abstraction of the physical system meaning that it omits only inessential details, then the definitiveassertion about the model gives us confidence in the physical realization of the system. Such confidence is enormouslyvaluable, particularly for embedded systems where malfunctions can threaten human lives. Studying models of systemsgives us insight into how those systems will behave in thephysical world.Our focus is on the interplay of software and hardwarewith the physical environment in which they operate. Thisrequires explicit modeling of the temporal dynamics of software and networks and explicit specification of concurrencyproperties intrinsic to the application. The fact that theimplementation technologies have not yet caught up withthis perspective should not cause us to teach the wrong engineering approach. We should teach design and modelingas it should be, and enrich this with a critical presentationof how to partially accomplish our objectives with todaystechnology. Embedded systems technologies today, therefore, should not be presented dispassionately as a collectionof facts and tricks, as they are in many of the above citedbooks, but rather as stepping stones towards a sound designpractice. The focus should be on what that sound designpractice is, and on how todays technologies both impedeand achieve it.Stankovic et al. 21 support this view, stating that existing technology for RTES realtime embedded systemsdesign does not effectively support the development of reliable and robust embedded systems. They cite a need toraise the level of programming abstraction. We argue thatraising the level of abstraction is insufficient. We have toalso fundamentally change the abstractions that are used.Timing properties of software, for example, cannot be effectively introduced at higher levels of abstraction if they areentirely absent from the lower levels of abstraction on whichthese are built.We require robust and predictable designs with repeatable temporal dynamics 10. We must do this by buildingabstractions that appropriately reflect the realities of cyberphysical systems. The result will be CPS designs that can bemuch more sophisticated, including more adaptive controllogic, evolvability over time, improved safety and reliability,all without suffering from the brittleness of todays designs,where small changes have big consequences.In addition to dealing with temporal dynamics, CPS designs invariably face challenging concurrency issues. Because software is so deeply rooted in sequential abstractions,concurrency mechanisms such as interrupts and multitasking, using semaphores and mutual exclusion, loom large. Wetherefore devote considerable effort in this book to developing a critical understanding of threads, message passing,deadlock avoidance, race conditions, and data determinism.4. ORGANIZATION OF THE BOOKAs shown in Figure 1, this book is divided into three majorparts, focused on modeling, design, and analysis. Modeling is the process of gaining a deeper understanding of asystem through imitation. Models imitate the system andreflect properties of the system. Models specify what asystem does. Design is the structured creation of artifacts.It specifies how a system does what it does. Analysis isthe process of gaining a deeper understanding of a systemthrough dissection. It specifies why a system does what itdoes or fails to do what a model says it should do.The three parts of the book are relatively independent ofone another and are largely meant to be read concurrently.Strong dependencies between chapters are shown with arrows in black. Weak dependencies are shown in grey. Whenthere is a weak dependency from chapter i to chapter j, thenj may mostly be read without reading i, at most requiringskipping some examples or specialized analysis techniques.A systematic reading of the text can be accomplished inseven segments, shown with dashed outlines. Each segmentincludes two chapters, so complete coverage of the text ispossible in a 14 week semester, assuming each of the sevenmodules takes two weeks. We now briefly describe the threemain parts.4.1 ModelingThis part of the book focuses on models of dynamic behavior. It begins with a light coverage of the modeling of physical dynamics, specifically focusing on continuous dynamicsin time. It then talks about discrete dynamics, using statemachines as the principal formalism. It then combines thetwo with a discussion of hybrid systems. The fourth chapterfocuses on concurrent composition of state machines, emphasizing that the semantics of composition is a critical issue that designers must grapple with. The fifth chaptergives an overview of concurrent models of computation, including many of those used in design tools that practitionersfrequently leverage, such as Simulink and LabVIEW.In this part of the book, we define a system to be simply a combination of parts that is considered a whole. Aphysical system is one realized in matter, in contrast toa conceptual or logical system such as software and algorithms. The dynamics of a system is its evolution in timehow its state changes. A model of a physical system is adescription of certain aspects of the system that is intendedto yield insight into properties of the system. In this text,models have mathematical properties that enable systematicanalysis. The model imitates properties of the system, andhence yields insight into that system.A model is itself a system. It is important to avoid confusing a model and the system that it models. These are twodistinct artifacts. A model of a system is said to have highfidelity if it accurately describes properties of the system.It is said to abstract the system if omits details. Modelsof physical systems inevitably do omit details, so they arealways abstractions of the system. A major goal of this textis to develop an understanding of how to use models, of howto leverage their strengths and respect their weaknesses.A cyberphysical system CPS is a system composed ofphysical subsystems together with computing and networking. Models of cyberphysical systems must include all threeparts. The models will typically need to represent bothstatic properties those that do not change during theoperation of the system and dynamics.Each of the modeling techniques described in this partof the book is an enormous subject, much bigger than onechapter, or even one book. In fact, such models are the focusof many branches of engineering, physics, chemistry, and biology. Our approach is aimed at engineers. We assume somebackground in mathematical modeling of dynamics calculus courses that give some examples from physics are sufficient, and then focus on how to compose diverse models.This will form the core of the cyberphysical system problem, since joint modeling of the cyber side, which is logicaland conceptual, with the physical side, which is embodiedin matter, is the core of the problem. We therefore make noattempt to be comprehensive, but rather pick a few modeling techniques that are widely used by engineers and wellFigure 1 Map of the book with strong and weak dependencies between chapters.understood, review them, and then compose them to forma cyberphysical whole.4.2 DesignThe second part of the book has a very different flavor,reflecting the intrinsic heterogeneity of the subject. Thispart focuses on the design of embedded systems, with emphasis on the role they play within a CPS. Chapter 6 discusses processor architectures, with emphasis on specializedproperties most suited to embedded systems. Chapter 7 describes memory architectures, including abstractions such asmemory models in programming languages, physical properties such memory technologies, and architectural propertiessuch as memory hierarchy caches, scratchpads, etc.. Theemphasis is on how memory architecture affects dynamics.Chapter 8 is about the interface between the software worldand the physical world. It discusses inputoutput mechanisms in software and computer architectures, and the digitalanalog interface, including sampling. Chapter 9 introduces the notions that underly operating systems, with particularly emphasis on multitasking. The emphasis is on thepitfalls of using lowlevel mechanisms such as threads, witha hope of convincing the reader that there is real value inusing the modeling techniques covered in the first part of thebook. Chapter 10 introduces realtime scheduling, coveringmany of the classic results in the area.In all chapters in this part, we particularly focus on themechanisms that provide concurrency and control over timing, because these issues loom large in the design of cyberphysical systems. When deployed in a product, embeddedprocessors typically have a dedicated function. They controlan automotive engine or measure ice thickness in the Arctic.They are not asked to perform arbitrary functions with userdefined software. Consequently, the processors, memory architectures, IO mechanisms, and operating systems can bemore specialized. Making them more specialized can bringenormous benefits. For example, they may consume far lessenergy, and consequently be usable with small batteries forlong periods of time. Or they may include specialized hardware to perform operations that would be costly to performon generalpurpose hardware, such as image analysis. Ourgoal in this part is to enable the reader to critically evaluatethe numerous available technology offerings.One of the goals in this part of the book is to teach students to implement systems while thinking across traditionalabstraction layers  e.g., hardware and software, computation and physical processes. While such crosslayer thinkingis valuable in implementing systems in general, it is particularly essential in embedded systems given their heterogeneous nature. For example, a programmer implementing acontrol algorithm expressed in terms of realvalued quantities must have a solid understanding of computer arithmetic e.g., of fixedpoint representations in order to create a reliable implementation. Similarly, an implementor ofautomotive software that must satisfy realtime constraintsmust be aware of processor features  such as pipeliningand caching  that can affect the execution time of tasksand hence the realtime behavior of the system. Likewise,an implementor of interruptdriven or multithreaded software must understand the level of atomicity provided by theunderlying softwarehardware platform and use appropriatesynchronization constructs to ensure correctness. Ratherthan doing an exhaustive survey of different implementation methods and platforms, this part of the book seeks togive the reader an appreciation for such crosslayer topics,and uses homework exercises to facilitate a deeper understanding of them.4.3 AnalysisEvery system must be designed to meet certain requirements. For embedded systems, which are often intended foruse in safetycritical, everyday applications, it is essential tocertify that the system meets its requirements. Such systemrequirements are also called properties or specifications.The need for specifications is aptly captured by the followingquotation paraphrased from 24A design without specifications cannot be rightor wrong, it can only be surprisingThis part of the book focuses on precise specifications ofproperties, on techniques for comparing specifications, andon techniques for analyzing specifications and the resultingdesigns. Reflecting the emphasis on dynamics in the text,Chapter 11 focuses on temporal logics, which provide precise descriptions of dynamic properties of systems. Thesedescriptions are treated as models. Chapter 12 focuses onthe relationships between models. Is one model an abstraction of another Is it equivalent in some sense Specifically,that chapter introduces type systems, as a way of comparing static properties of models, and language containmentand simulation relations as a way of comparing dynamicproperties of models. Chapter 13 focuses on techniques foranalyzing the large number of possible dynamic behaviorsthat a model may exhibit, with emphasis on model checking as a technique for exploring such behaviors. Chapter14 is about analyzing quantitative properties of embeddedsoftware, such as finding bounds on resources consumed byprograms. It focuses particularly on execution time analysis, with some introduction to others such as energy andmemory usage.In present engineering practice, it is common to have system requirements stated in a natural language such as English. It is important to precisely state requirements to avoidambiguities inherent in natural languages. The goal of thispart of the book to help replace descriptive techniques withformal ones, which we believe are less error prone.Importantly, formal specifications also enable the use ofautomatic techniques for formal verification of both modelsand implementations. This part of the book introduces readers to the basics of formal verification, including notions ofequivalence and refinement checking, as well as reachabilityanalysis and model checking. In discussing these verification methods, we take a users view of them, discussing, forexample, how model checking can be applied to find subtleerrors in concurrent software, or how reachability analysiscan be used in computing a control strategy for a robot toachieve a particular task.4.4 Missing SectionsVersion 1.0 of the book will not be complete. It is arguable, in fact, that complete coverage of embedded systemsin the context of CPS is impossible. Specific topics that wecover in the undergraduate Embedded Systems course atBerkeley1 and hope to include in version 2.0 or later versions of the book include sensors and actuators, networking,fault tolerance, simulation techniques, control systems, andhardwaresoftware codesign. If you are an author interestedin contributing, please contact us at authorsLeeSeshia.org.4.5 Intended AudienceThis book is intended for students at the advanced undergraduate level or the introductory graduate level, and forpracticing engineers and computer scientists who wish tounderstand the engineering principles of embedded systems.We assume that the reader has some exposure to machinestructures e.g., should know what an ALU is, computerprogramming we use C throughout the text, basic discretemathematics and algorithms e.g., graph traversal throughdepthfirst or breadthfirst search, and at least an appreciation for signals and systems what it means to sample acontinuoustime signal, for example.5. PUBLICATION STRATEGYRecent advances in technology are fundamentally changing the technical publishing industry. Almost every aspectof how academics, teachers, and intellectuals communicateis in flux, and we believe that the landscape in the 21stcentury will be very different from that of the 20th century. In response to this, the book we introduce here isan experiment in publishing. With apologies to the manyhardworking men and women in the traditional publishingindustry, we hope that if this approach is successful, that itwill be followed by other authors.The book is available free in electronic form from the website httpLeeSeshia.org. In recognition that there is realvalue in a tangible manifestation on paper, something youcan thumb through, something that can live on a bookshelfto remind you of its existence, the book will also be available in print form. Our plan is to use a printondemandservice, which has the advantages of dramatically reducedcost to the reader and the ability to quickly and frequentlyupdate the version of the book to correct errors and discussnew technologies.The reduced revenue stream that results from this publication strategy, of course, has disadvantages. But prior experience of these authors indicate that it is rare for authorsof technical books to even earn minimum wage for their efforts. Remuneration is clearly not the main goal. The maingoals seem to be communication, education, and impact. Webelieve that our strategy enhances all three goals.Consider for example the opportunities afforded by a focus on online dissemination. The electronic version is aPDF file designed specifically for online reading. The layout is optimized for mediumsized screens, particularly theiPad and forthcoming tablets. Extensive use of hyperlinksand color enhance the online reading experience. Links toexternal websites are included directly at the relevant point.We attempted to adapt the book to ebook formats, which,in theory, enable reading on various sized screens, attempting to take best advantage of the available screen. However,like HTML documents, ebook book formats are a reflowtechnology, where page layout is recomputed on the fly. Theresults are highly dependent on the screen size and prove ludicrous on many screens and suboptimal on all. As a conse1See httpchess.eecs.berkeley.edueecs149quence, we have opted for controlling the layout, and we donot recommend attempting to read the book on an iPhone.As of this writing, a preliminary version of the book isavailable at httpLeeSeshia.org. We plan a complete release of version 1.0 by the end of summer, 2010, with anassociated printondemand version available in the Fall.6. ACKNOWLEDGEMENTSThe authors gratefully acknowledge contributions and helpful suggestions on the text from Elaine Cheong, Gage Eads,Stephen Edwards, ShannaShaye Forbes, Jeff Jensen, Wenchao Li, Isaac Liu, Slobodan Matic, Steve Neuendorffer,Minxue Pan, Hiren Patel, Jan Reineke, Chris Shaver, StavrosTripakis, Pravin Varaiya, Maarten Wiggers, and the students in UC Berkeleys EECS 149 class, particularly NedBass and Dan Lynch.7. REFERENCES1 H. Abelson and G. J. Sussman. Structure andInterpretation of Computer Programs. MIT Press,second edition, 1996.2 M. Barr and A. Massa. Programming EmbeddedSystems. OReilly, 2nd edition, 2006.3 A. S. Berger. Embedded Systems Design AnIntroduction to Processes, Tools,  Techniques. CMPBooks, 2002.4 A. Burns and A. Wellings. RealTime Systems andProgramming Languages Ada 95, RealTime Java andRealTime POSIX. AddisonWesley, 3d edition, 2001.5 G. C. Buttazzo. Hard RealTime Computing SystemsPredictable Scheduling Algorithms and Applications.Springer, second edition, 2005.6 S. A. Edwards. Languages for Digital EmbeddedSystems. Kluwer Academic Publishers, 2000.7 D. D. Gajski, S. Abdi, A. Gerstlauer, and G. Schirner.Embedded System Design  Modeling, Synthesis, andVerification. Springer, 2009.8 A. Jantsch. Modeling Embedded Systems and SoCs Concurrency and Time in Models of Computation.Morgan Kaufmann, 2003.9 R. Kamal. Embedded Systems Architecture,Programming, and Design. McGraw Hill, 2008.10 E. A. Lee. Computing needs time. Technical ReportUCBEECS200930, EECS Department, Universityof California, Berkeley, February 18 2009.11 J. W. S. Liu. RealTime Systems. PrenticeHall, 2000.12 P. Marwedel. Embedded System Design. KluwerAcademic Publishers, 2003.13 P. Mishra and N. D. Dutt. Functional Verification ofProgrammable Embedded Processors  A TopdownApproach. Springer, 2005.14 T. Noergaard. Embedded Systems Architecture AComprehensive Guide for Engineers andProgrammers. Elsevier, 2005.15 R. Oshana. DSP Software Development Techniques forEmbedded and RealTime Systems. EmbeddedTechnology Series. Elsevier, 2006.16 J. S. Parab, V. G. Shelake, R. K. Kamat, and G. M.Naik. Exploring C for Microcontrollers. Springer, 2007.17 D. A. Patterson and J. L. Hennessey. ComputerArchitecture A Quantitative Approach. MorganKaufmann, 2nd edition, 1996.18 G. Pottie and W. Kaiser. Principles of EmbeddedNetworked Systems Design. Cambridge UniversityPress, 2005.19 D. E. Simon. An Embedded Software Primer.AddisonWesley, 2006.20 S. Sriram and S. S. Bhattacharyya. EmbeddedMultiprocessors Scheduling and Synchronization.CRC press, 2nd edition, 2009.21 J. A. Stankovic, I. Lee, A. Mok, and R. Rajkumar.Opportunities and obligations for physical computingsystems. Computer, pages 2331, 2005.22 J. W. Valvano. Embedded Microcomputer Systems Real Time Interfacing. Thomson, 2nd edition, 2007.23 W. Wolf. Computers as Components Principles ofEmbedded Computer Systems Design. MorganKaufman, 2000.24 W. Young, W. Boebert, and R. Kain. Proving acomputer system secure. Scientific Honeyweller,621827, July 1985.
