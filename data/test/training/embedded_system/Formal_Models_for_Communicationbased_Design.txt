Formal Models for CommunicationbasedDesignAlberto SangiovanniVincentelli1, Marco Sgroi1, Luciano Lavagno21 University of California at Berkeley, EECS Department, Berkeley, CA 947202 Cadence Berkeley Labs, 2001 Addison Street, Berkeley, CA 947041144Abstract. Concurrency is an essential element of abstract models forembedded systems. Correctness and eciency of the design depend critically on the way concurrency is formalized and implemented. Concurrency is about communicating processes. We introduce an abstract formal way of representing communication among processes and we showhow to rene this representation towards implementation. To this end,we present a formal model, Abstract Codesign Finite State MachinesACFSM, and its renement, Extended Codesign Finite State Machines ECFSM, developed to capture abstract behavior of concurrentprocesses and derived from a model Codesign Finite State MachineCFSM we have used in POLIS, a system for the design and verication of embedded systems. The design of communication protocols ispresented as an example of the use of these formal models.1 IntroductionBy the year 2002, it is estimated that more information appliances will be soldto consumers than PCs see Business Week, March 1999. This new marketincludes small, mobile, and ergonomic devices that provide information, entertainment, and communications capabilities to consumer electronics, industrialautomation, retail automation, and medical markets. These devices require complex electronic design and system integration, delivered in the short time framesof consumer electronics. The system design challenge of at least the next decadeis the dramatic expansion of this spectrum of diversity and the shorter andshorter timetomarket window. Given the complexity and the constraints imposed upon design time and cost, the challenge faced by the electronics industryis insurmountable unless a new design paradigm is developed and deployed thatfocuses on design reuse at all levels of abstraction correctbyconstruction transformations.An essential component of a new system design paradigm is the orthogonalization of concerns, i.e., the separation of the various aspects of design toallow more eective exploration of alternative solutions. The pillars of the design methodology that we have proposed over the years are the separation between function what the system is supposed to do andarchitecture how it does it the separation between computation and communication.1.1 FunctionArchitecture CoDesignThe mapping of function to architecture is an essential step from conceptionto implementation. In the recent past, there has been a signicant attention inthe research and industrial community to the topic of HardwareSoftware Codesign. The problem to be solved here is coordinating the design of the partsof the system to be implemented as software and the parts to be implementedas hardware, avoiding the HWSW integration problem that has marred theelectronics system industry for so long. We actually believe that worrying abouthardwaresoftware boundaries without considering higher levels of abstractionis the wrong approach. HWSW design and verication happens after some essential decisions have been already made, thus making the verication and thesynthesis problem so hard. SW is really the form that a given piece of functionality takes if it is mapped onto a programmable microprocessor or DSP.The origin of HW and SW is in behavior that the system must implement. Thechoice of an architecture, i.e. of a collection of components that can be eithersoftware programmable, recongurable or customized, is the other importantstep in design. Functional Level Mapping LevelArchitectural LevelBehavioralLibrariesArchitectureLibrariesCaptureBehaviorVerifyBehaviorMap Behavior toArchitectureVerify PerformanceLink toArchitectureVerificationRefine HWSWArchitectureCaptureArchitectureVerifyArchitectureLink to HWSWImplementationPerformanceBackAnnotationFig. 1. Proposed design strategy1.2 Communicationbased DesignThe implementation of ecient, reliable, and robust approaches to the design,implementation, and programming of concurrent systems is essential. In anylargescale embedded systems design methodology, concurrency must be considered as a rst class citizen at all levels of abstraction and in both hardware andsoftware.Concurrency implies communication among components of the design. Communication is too often intertwined with the behavior of the components of thedesign so that it is very dicult to separate out the two domains. Separatingcommunication and behavior is essential to dominate system design complexity.In particular, if in a design component behaviors and communications are intertwined, it is very dicult to reuse components since their behavior is tightlydependent on the communication mechanisms with other components of theoriginal design. In addition, communication can be described at various levelsof abstraction, thus exposing the potential of implementing communication behavior in many dierent forms according to the available resources. Today thisfreedom is often not exploited.1.3 Formal ModelsWe have promoted the use of formal models and transformations in systemdesign so that verication and synthesis can be applied to advantage in thedesign methodology 1. Further, the concept itself of synthesis can be appliedonly if the precise mathematical meaning of a description of the design is applied.It is then important to start the design process from a highlevel abstraction thatcan be implemented in a wide variety of ways. The implementation process is asequence of steps that remove freedom and choice from the formal model. In otherwords, the abstract representation of the design should contain all the correctimplementations in the sense that the behavior of the implementation shouldbe consistent with the abstract model behavior. Whenever a behavior is notspecied in the abstract model, the implicit assumption is that such behavior is adontcare in the implementation space. In other words, the abstract model is asource of nondeterministic behavior, and the implementation process progressestowards a deterministic system. It is important to underline that way too oftensystem design starts with a system specication that is burdened by unnecessaryreferences to implementations resulting in overdetermined representations withrespect to designer intent that obviously yield underoptimized designs.In the domain of formal model of system behavior, it is common to nd theterm Model of Computation MOC, an informal concept that has its roots inlanguage theory. This term refers more appropriately to mathematical modelsthat specify the semantics of computation and of concurrency. In fact, concurrency models are the most important dierentiating factors among models ofcomputation. Ed Lee 2 has very well stressed the importance of allowing oneto express designs making use of all models of computation, or at least of theprincipal ones, thus yielding a socalled heterogeneous environment for systemdesign. In his approach to simulation and verication, assembling a system description out of modules represented in dierent models of computation reducesto the problem of arbitrating communication among the dierent models. However, the concept of communication among dierent models of computation stillneeds to be carefully explored and understood from a synthesis and renementviewpoint.This diculty has actually motivated our approach to communicationbaseddesign where communication takes the driver seat in system design 8. In thisapproach, communication can be specied somewhat independently of the modules that compose the design. In fact, two approaches can be applied here. In therst case, we are interested in communication mechanisms that work in anyenvironment, i.e., independently of the formal models and specications of thebehavior of the components. This is a very appealing approach if we look at theease of component assembly. It is however rather obvious that we may end upwith an implementation that is overly wasteful, especially for embedded systemswhere production cost is very important. A more optimal but less modularapproach is to specify the communication behavior, and then to rene jointlyone side of the communication protocol and the behavior that uses it, in orderto exploit knowledge of both to improve the eciency of the implementation.Here, a synthesis approach is most appealing since it reduces the risk of makingmistakes and it may use powerful optimization techniques to reduce design costand time.Communication and time representation in a Model Of Computation arestrictly intertwined. In fact, in a synchronous system, communication can takeplace only at precise instants of time thus reducing the risk of unpredictablebehavior. Synchronous systems are notoriously more expensive to implement andoften less performing thus opening the door to asynchronous implementations.In this latter case, that is often the choice for large system design, particularcare has to be exercised to avoid undesired and unexpected behaviors. The balance between synchronous and asynchronous implementations is possibly themost challenging aspect of system design. We argue that globally asynchronouslocally synchronous GALS communication mechanisms are probably a goodcompromise in the implementation space 1. The research of our group in thelast few years has addressed the above problems and allowed us to dene a fulldesign methodology and a design framework, called Polis 1, for embedded systems. The methodology that we have proposed is based on the use of a formal andimplementationindependent MOC, called CFSMs Codesign Finite State Machines. CFSMs are Finite State Machines extended with arithmetic data paths,and communicating asynchronously over signals. Signals carry events, which arebuered at the receiving end, and are inherently unidirectional and potentiallylossy in case the receiver is not fast enough to keep up with the senders speed.The CFSMs model is Globally Asynchronous Locally Synchronous GALS, sinceevery CFSM locally behaves synchronously following the FSMs semantics whilethe interaction among CFSMs is asynchronous from a system perspective.However, the view of communication in CFSMs is still at a level of abstraction that is too low. We would like to be able to specify abstract communication patterns with highlevel constraints that are not implying yet a particular model of communication. For example, it is our opinion that an essentialaspect of communication is the guarantee of reception of all the informationthat has been sent. We argue that there must exist a level of abstraction thatis high enough to require that communication takes place without loss. Thesynchronousasynchronous mechanism, the protocols used and so on, are justimplementation choices that either guarantee no loss or that have a good chanceof ensuring that no data is lost where it matters but that need extensive verication to make sure that this is indeed the case. For example, Kahn processnetworks 4 guarantee no loss at the highest level of abstraction by assuming anideal buering scheme that has unbounded buer size. Clearly the unboundedbuer size is a nonimplementable way of guaranteeing no loss. When movingtowards implementable designs, this assumption has to be removed. A buer canbe provided to store temporarily data that are exchanged among processes butit must be of nite size. The choice of the size of the buer is crucial. Unfortunately deciding whether a nite buer implementation exists that guarantees noloss is not theoretically feasible in the general case, but there are cases for whichan optimal buer size can be found 2. In other cases, one has to hope for thebest for buer overwrite not to occur or has to provide additional mechanismsthat, when composed with the nite buer implementation, still guarantee thatno loss takes place for example, a requestacknowledge protocol. Note that inthis case the renement process is quite complex and involves the use of composite processes. Today, there is little that is known about a general approachto communication design that has some of the feature that we have exposed.An essential step to develop communicationbased design is the understanding of communication semantics. We believe that communication in formalmodels has not been treated at the correct level of abstraction.1.4 Outline of the paperIn this paper, using as a guideline the concepts presented above, we discusscommunication semantics and give a formal model for this semantics. Then weintroduce formal models that can be used to design eectively complex systemsand we present novel models obtained by abstracting Codesign Finite StateMachines CFSMs to deal with the problems posed by communicationbaseddesign. In particular, in Section  we review the models of computation thathave been most commonly used in system design. We then proceed to presentin Section 3, the Abstract Codesign Finite State Machine ACFSM globallyasynchronous locally synchronous model where communication is lossless. InSection 4, we introduce the Extended CFSM model, that renes the ACFSMmodel by having nite queues to buer communication and that contains theCFSM model as a special case. Finally, in Section 6 we show how to use thesemodels to design an application example a wireless communication protocol.2 CommunicationLarge distributed systems are composed of a set of concurrent and interactingcomponents 3.3 Following the Tagged Signal Model formalism 3, system components are modeledas functional processes, whose set of behaviors is dened by a mapping from a setA prerequisite for the interaction between distinct components is the existence of a connection between an output port of one component, called thesender, and an input port of another component, called the receiver. A connection can be modeled as a process whose function is the identity between inputand output signals. With respect to the interaction between sender and receiver,a connection imposes the equality of the input signal of the receiver with theoutput signal of the sender Figure 2.S Ro2o1o3i3i1i2ConnectionConnectionIdeal oio  Fci  iFig. 2. Connection ProcessConsider two components, the sender modeled by process S Fs  Is  Osand the receiver by process R Fr  Ir  Or. Connecting S and R as shownin Figure 3 implies that only a signal that is an output of S may be an inputof R. As a result, the input space of R is restricted to the intersection Os  Irof its domain Ir with the output space of S Figure 3. When the domain ofR includes a signal ir 2 Os, the connection results in a restriction of the set ofpossible behaviors of R that can be optimized by removing the behaviors thatcorrespond to the input signals ir 2 Os  Ir.If the set Os  Ir is not empty, we say that the behaviors of S and R arenot adapted, since the behavior of R is not dened for inputs os 2 Os  Ir. Thismismatch 4 can be solved in one of the following ways1. R discards inputs os and treats them as errors,2. outputs os of S and the behaviors originating them are removed from S,3. signals os are mapped into signals that can be accepted by R.In 1 the set of behaviors of R is extended to R0 to include the error handlingof the undesired input signals that may be received. In 2 the behavior of thesender is optimized and restricted to S0 to exclude the production of outputsignals incompatible with R. In 3 an interface represented in Figure 4 as aprocess with function Fbeh int is used to map the signal emitted by S into aof input signals I to a set of output signals O, F  I  O. Unless a denition isexplicitly given, terms like process, signal, behavior are used below as in 3.4 An example is when the sender is an analog system and the receiver is digital anAD converter is needed to allow the receiver to understand the messages of thesender.RorirFsIsFrOrIrSis osOsFc  idOsFig. 3. Behavior mismatchsignal that belongs to the domain of R. Such an interface 9 can be usuallysplit into two processes Fbeh int  Fbeh sint  Fbeh rint, that encapsulate Sand R Fs0  Fs Fbeh sint and Fr0  Fbeh rint Fr and permit communicationbetween the modied behaviors S0 and R0 over a connection. We call this typeof interface Behavior Adapter BA Figure 4.RorirSis osRorirSis osFF Fbehintbehsint behrintBAis orRSS Ros irFig. 4. Behavior AdapterConnections are implemented using physical channels 5 , whose function Fc Ic  Oc in general diers from the identity, e.g. due to noise or interference. As aresult, even if the behaviors S0 and R0 were perfectly adapted, the received signalFcic  Fcos might be out of the domain of R0 or trigger an incorrect behaviorof R. Therefore, for a safe and correct interaction among system components it iskey to select a channel whose behavior approximates that of the ideal connection.Quality of Service requirements 6 partition the set of behaviors F into twoclasses, the class of those that satisfy the quality requirements and the class ofthose that do not satisfy them. Let us introduce a relation  F F , such that f f 0jf 2 F f 0 2 F bothfandf 0satisfythequalityrequirements5 A connection establishes a relation between signals. A channel is a set of physicalobjects that implement a connection.6 Quality of Service requirements include delay, throughput, maximum number oferrors...Given a connection and a set of requirements on the quality of the receivedsignal, the set of the behaviors S  Fc  R, where Fc is the channel functionis partitioned into two classes the class of valid channels and the class of theinvalid ones. The former includes all the channels that guarantee a quality ofthe received signal that satises the requirements. Since the ideal connectionby denition satises the quality requirements, the set of valid channels can bedened asV alidChannels  Fc  Fs  Fc  Fr  Fs  id  Fr  Fs  FrThe rst step in designing a valid channel is to select a physical channelwhose function is Fc. If the channel is invalid due to its physical limitations,it is necessary to introduce an interface between the behaviors and the channel that matches the undesired eects. We call this type of interface Channel Adapter CA 7. be included in the behaviors of sender and receiver... Achannel adapter interface is usually symmetric to the channel and is denedby two functions, Fcs int implementing the senderchannel and Fcr int thechannelreceiver interfaces Figure 5. If Fcs int  Fc  Fcr int  id the interfacesuccessfully adapts the channel Fc, otherwise it is necessary to iterate the adaptation process and look for two other functions Fcs0 int and Fcr0 int such thatFcs int Fcs0 int Fc Fcr0 int Fcr int  id8. Note also that if channel adaptersintroduce some mismatch between the range of Fcs int  Fc and the domain ofFcs int a behavior adapter is needed.FcS Ros irFcS RFcS Ros iros irS RFcsint FcrintFig. 5. Channel AdapterFollowing the above discussion, we dene communication as the mechanism7 Example of Channel Adapters functions are error correction, ow control, mediumaccess control.8 The channel adapter interface often consist of a stack of several layers e.g. ISOOSIReference Model, each processing the signal at a dierent level of abstraction.that allows the interaction between at least two distinct behaviors. A protocolis the set of interfaces that implement the communication.Figure 6 describes the ow we propose for designing protocols. Given twocomponents S and R, they are rst connected and their behaviors are compared.If there is a need for a behavior adapter BA, this is introduced. The next stepis the selction of channel CH . If there is no valid channel available, a channeladapter composed of the two interfaces CRA channelreceiver adapter andSCA senderchannel adapter is introduced to overcome the limitations of theinvalid channel selected. If the behavior of the sender composed with the channeland the behavior of the receiver are not adapted, another behavior adapter isneeded. This process is iterated until the behaviors do not need to be adaptedand a valid channel is dened.Behavior AdapterSoBAoR  SoBAoBAoRSoRChannel AdapterSoSCAoCHoCRAoRConnection SoRIr  Os Begin S, R.YYNNChannel Selection SoCHoR.SoCHoR  SoR NYValid Channel EndBoCHs  Cr Fig. 6. Design Flow3 Abstract Codesign Finite State MachinesAbstract Codesign Finite State Machines ACFSMs is a formal model thatallows one to represent embedded systems specications, involving both controland dataow aspects, at a high level of abstraction. It consists of a networkof FSMs that communicate asynchronously by means of events that at theabstract level only denote partial ordering, not time over lossless signals withFIFO semantics. ACFSMs are a Globally Asynchronous Locally SynchronousGALS model the local behavior is synchronous from its own perspective, like the atomicring of Dataow actors, because each ACFSM executes a transition byproducing an output reaction based on a snapshot set of inputs in zero time, the global behavior is asynchronous as seen by the rest of the system sinceeach ACFSM detects inputs, executes a transition, and emits outputs in anunbounded but nite amount of time.The asynchronous communication among ACFSMs over an unbounded FIFOchannel supports a possibly very nondeterministic specication where the execution delay of each ACFSM is unknown a priori and, therefore, is not biasedtowards a specic hardwaresoftware implementation, decouples the behavior of each ACFSM from the communication with otherACFSMs. The communication can then be designed by renement independently from the functional specication of the ACFSMs, as we show inSection 4.3.1 Single ACFSM behaviorA single ACFSM describes a nite state control operating on a data ow. Itis an extended FSM, where the extensions add support for data handling andasynchronous communication. An ACFSM transition can be executed when aprecondition on the number of present input events and a boolean expressionover the values of those input events is satised. During a transition execution,an ACFSM rst atomically detects and consumes some of the input events, thenperforms a computation by emitting output events with the value determinedby expressions over detected input events. A key feature of ACFSMs is thattransitions in general consume multiple events from the same input signal, andproduce multiple events to the same output signal multirate transitions. Weformally dene an ACFSM as followsDenition 1. An ACFSM is a triple A  I O T  I  fI1 I2    INg is a nite set of inputs. Let iji indicate the event that ata certain instant occupies the jth position in the FIFO at input Ii. O  fO1 O2    OMg is a nite set of outputs. Let oji indicate the jth eventemitted by a transition on output Oi. T  fIR IBCROROBg is the transition relation, where IR is the input enabling rate,IR  fI1 ir1 I2 ir2     IN  irN  j1  n  N In 2 I irn 2 INgi.e., irn is the number of input events from each input In that are requiredto trigger the transition. IB is a booleanvalued expression over the values of the eventsfijig 1  i  N 1  j  irithat enable the transition. CR is the input consumption rate,CR  fI1 cr1 I2 cr2     IN  crN  j1  n  N In 2 I crn 2 INcrn  irn  crn  IALLn gi.e., crn is the number of input events consumed from each input9. OR is the output production rate,OR  fO1 or1 O2 or2     OM  orM  j1  m MOm 2 O orm 2 INgi.e., orn is the number of output events produced on each output Onduring a transition execution. OB is a set of vectors of expressions that determines the values of theoutput events, one vector per output with orn  0 and one element peremitted event.fojig 1  i  N 1  j  oriNote that signals that are at the same time input and output, and for whicha single event is produced and consumed at each transition act as implicit statevariables of the ACFSM.If several transitions can be executed in a given conguration events andvalues of the input signals, the ACFSM is nondeterministic and can executeany one of the matching transitions.ACFSMs dier from Dataow networks in that there is no blocking readrequirement, i.e. ACFSMs transitions, unlike rings in DF networks, can beconditioned to the absence of an event over a signal. Hence, ACFSMs are alsonot continuous in Kahns sense 4 the arrival of two events in dierent ordersmay change the behavior. Another dierence from DF models is that ACFSMscan ush an input signal, in order to model exception handling and reactionto disruptive events e.g., errors and reinitializations. A DF actor cannot doso, since when the input signal has been emptied, the actor is blocked waitingon the signal, rather than proceeding to execute the recovery action.9 The number of events that is consumed should be not greater than the numberof events that enabled the transition. It is also possible to specify, by saying thatcrn  IALLn , that a transition resets a given input, i.e., it consumes all the eventsin the corresponding signal that must be at least as many as those enabling thetransition.A dierence from most FSMbased models e.g., SDL is the possibility touse multirate transitions to represent production and consumption of eventsover the same signal at dierent rates e.g. images produced linebyline andconsumed pixelbypixel.As an example, consider the lter shown in Figure 7. It lters a sequence offrames, by multiplying all the pixels of a frame by a coecient. At the beginningof each iteration it receives the number of lines per frame and pixels per linefrom the input signal in and the initial ltering coecient used to multiply thepixels from the input signal coef . Then, it receives a frame, i.e. a sequence oflines of pixels, from in, possibly interleaved with new coecient values if it mustbe updated from coef . The ltered frame is produced on the output signal out .The primitives readin,n and writeout,n consume and produce n events fromsignal in and out , respectively, and presentcoef,n returns true if n events areavailable on signal coef .Innlines,npix,pixelsCoeffOut pixelsCONSUMERFILTERPRODUCERCONTROLLERmodule filterinput byte in, coefoutput byte outint nlines, npix, line, pixbyte kint bufferforever nlines, npix  read in, 2k  read coef, 1for line  1 line  nlines line if presentcoef, 1 k  read coef, 1buffer  read in, npixfor pix  1 pix  npix pixbufferpix  bufferpix  kwrite out, buffer, npixFig. 7. Filter example.Let prodv,s,n denote the multiplication of a vector v of n values by a scalars, and  a shorthand to represent writing to state feedback signals, which arealso omitted for simplicity from IR and OR, where they always have rate 1. Thelter can be modeled by an ACFSM as follows IR  CR  fin 2 coef 1g, IB  state  1,OR  fg, OB  fnlines npix readin 2line 1 k  readcoef 1 state 1g IR  CR  fin npixg,IB  state  2  line  nlines,OR  fout npixg,OB  fwriteout prodreadin npix k npix npixstate 2 line line  1g IR  CR  fin npixg,IB  state  2  line  nlines, OR  fout npixg,OB  fwriteout prodreadin npix k npix npixstate 1g IR  CR  fcoef 1g, IB  state  2,OR  fg, OB  fk  readcoef 1 state 2g3.2 Network of ACFSMsAn ACFSMs network is a set of ACFSMs and signals. The behavior of the network depends on both the individual behavior of each ACFSM, and that of theglobal system. In the mathematical model, the system is composed of ACFSMsand a scheduling mechanism coordinating them. The scheduler operates by continually deciding which ACFSMs can be run, and calling them to be executed.Each ACFSM is either idle waiting for input events, or ready waiting to berun by the scheduler, or executing a single transition from its transition relation.The topology of the network, as for dataow networks, simply species apartial order on the execution of the ACFSMs. Initially the time required byan ACFSM to perform a state transition is not specied, hence each ACFSMcaptures all its possible hardware with or without resource sharing constraintsand software generally with CPU sharing constraints implementations . TheACFSM model is fully implementationindependent but, as a consequence, it ishighly nondeterministic.The nondeterminism present in ACFSMs is resolved only after an architectural mapping implementation is chosen. An architectural mapping in thiscontext means a set of architectural and communication resources CPUs, ASICs, busses,   , a mapping from ACFSMs to architectural resources and from signals tocommunication resources, a scheduling policy for shared resources.Once an architectural mapping is selected for a network of ACFSMs, thecomputation delay for each ACFSM transition can be estimated with a variety of methods, depending on how the tradeo between speed and accuracy issolved 1.Annotating the ACFSM transitions with such delay estimates denes a globalorder of execution of the ACFSM network that has now been rened into aDiscrete Event semantics. At this level the designer can verify, by using a DiscreteEvent simulator 1, if the mapped ACFSM network satises not only functionalbut also performance and cost requirements.4 Rening ACFSMs EFCSMsAbstract CFSMs communicate asynchronously by means of events, transmittingand receiving data over unbounded communication channels with FIFO semantics. This abstract specication denes for each channel only a partial orderbetween the emission and the reception of events and therefore must be renedto be implemented with a nite amount of resources. To implement an abstractcommunication it is necessary to design a protocol that satises the functionaland performance requirements of the communication, and can be implementedat a minimum cost in terms of power, area, delay and throughput.The amount of data that should be correctly received is one requirement. Acommunication mechanism is called lossless, if no data in the form of eventsis lost over the communication channel during any system execution, and lossyotherwise. The specication requirements dictate if the communication must belossless or lossy and, if lossy, how much loss is acceptable. Data can be losteither because of the poor quality of the physical channel, e.g. due to noise orinterference, or because of the limited amount of resources in the implementation,e.g. the receiver is slow and does not have enough memory to store the incomingdata. In the rst case the problem is usually overcome by the denition of arobust protocol that probabilistically guarantees correctness of received databy means of retransmissions or coding techniques for error correction. In thesecond case the solution, as discussed below, is to use a sucient amount ofresources or an appropriate protocol to meet the requirements. The throughputand the latency in the arrival of the data to the destination are key requirementsespecially in the design of protocols for realtime applications, e.g. realtime videoor audio, that require that incoming video frames and audio samples are receivedand processed at regular intervals.Communication protocols in our approach are rened towards implementation through several levels of abstraction, by applying a sequence of renementsteps, such that each step preserves the original behavior and constraints arepropagated in a topdown fashion. At the same time the use of architecturalunits, e.g. the physical channel, and functional libraries, e.g. communicationprimitives, captures also the bottomup aspect of the design process. Therefore,we can say that the overall methodology we propose is really a mix of topdownand bottomup.At the Abstract CFSMs level, the specication includes the topology of thenetwork and the functional behavior of each module, while the protocols thatimplement the communication requirements are still undened. To optimally design a protocol for each communication channel it is necessary to use a model, orset of models, that allow one to capture dierent algorithmic solutions and evaluate their implementation costs. For this reason we introduce the Extended Codesign Finite State Machines ECFSMs model that implements the ACFSMsmodel, dened in the previous Section. ECFSMs are obtained from the ACFSMssimply by rening innitesize queues to implementable nitesize queues. Theeventbased communication semantics, as well as the rules for the execution ofECFSMs transitions, are the same as in the ACFSMs model.ECFSMs have input queues of nite size, and write operations can be eitherblocking or nonblocking on a channelbychannel basis. In the latter case,every time a queue is full and new data arrives over the channel, the data previously stored is lost overwritten10. To avoid this scenario it is often sucient touse a longer queue. Sometimes, instead, e.g. when the average production rateof the sender is greater than the average consumption rate of the receiver, thereexists no nitequeue solution guaranteeing no loss. The problem of checkingif there exists a lossless implementation with bounded queues, that has beensolved using static or quasistatic scheduling algorithms for Synchronous DataFlow networks 5 and FreeChoice Petri Nets 6, is undecidable in general forthe ACFSMs model. Therefore, to implement lossless communication in a givenECFSM network, it is necessary to dene an additional mechanism that, whena queue is full, blocks the sender until the queue has again enough space for newincoming data. This can be achieved by means of either a handshake protocol,consisting of explicit events carrying the sender request for an emission and thereceiver acknowledgment that new data can be accommodated in the queue,or scheduling constraints that ensure that the sender is scheduled for executiononly when the queue at the receiver has enough space. Depending on the requirements on data losses, ACFSM queues are rened into either lossy ones, that areeventually overwritten when they are full, or lossless ones, where overwriting isprevented by a blocking write protocol or scheduling constraints.The actual size of the queues should be determined by evaluating the costof dierent implementations that satisfy the communication requirements. Forexample, largesize queues mean high throughput due to the higher level ofpipelining that can be achieved by sender and receiver, but are also expensive interms of area. Smallsize queues reduce the area, but decrease the throughput,as the sender is blocked more often, and increase power consumption morefrequent request and acknowledgment messages.5 Communication over FIFO ChannelsThe ACFSMs and ECFSMs models follow in the computation part the same Extended Finite State Machines semantics described in Section 3. Their semanticsof the communication is instead dierent both models use FIFO channels, butwhile ACFSMs communicate over channels with unbounded queues, ECFSMscommunicate over channels with queues of nite size.10 Traditional CFSMs 1 are a special case of ECFSMs, where the queues have lengthone.A FIFO channel can be seen as an adapter between behaviors that operate ata dierent rate. If the sender produces outputs at a faster rate than the receiver,a FIFO allows to handle their rate dierence and prevent from losses.An unbounded queue is an ideal adapter, since it allows to accumulate aninnite number of tokens and therefore match any rate dierence. However, asdiscussed above, ACFSMs communication is to be implemented using ECFSMswhose channels have nite queues. Unfortunately, bounded FIFO channels donot prevent from overow, i.e. losses, when the FIFO is full. For this reason, abounded FIFO channel is in many cases not be a valid channel, especially forsystems where the rate dierence between sender and receiver is large. In thiscase it is necessary to introduce a channel adapter interface that here may takethe form either of a scheduling policy or an explicit RequestAcknowledgmentprotocol that blocks the sender when the FIFO is full. In particular the ReqAckprotocol restricts the behavior of S to S0 excluding all the behaviors, consideredillegal, where the number of consecutive output events exceeds the capacity ofthe queue 8.RorirSis osisRorReq.AckSSFig. 8. Fifo Channel6 Example a wireless protocolIntercom 7 is a singlecell wireless network supporting voice communicationamong a number of mobile terminals. The network operation is coordinated bya unit, called base station, that handles user service requests e.g. request toestablish a connection, and solves the shared wireless medium access problemusing a TDMA Time Division Multiple Access policy and assigning the slotsto communicating users.Figure 9 describes the Intercom protocol stack, that is composed of the following layers. The User Interface Layer interacts with the users and forwards tolower layers user service requests and logarithmically quantized voice samples.The Transport Layer takes care of message retransmission until acknowledgmentreception. The MAC Layer implements the TDMA scheme, keeping within internal tables the information on which action transmit, receive or standby theterminal should take at each slot. The Error Control Layer applies the CyclicRedundancy Check algorithm to the incoming and outgoing streams of data and,Fig. 9. Intercom protocol stackif detects an error, discards the incorrect packet. The Synchronization Layer extracts from the received bit stream the frame and slot synchronization patterns,and noties the MAC of the beginning of a new slot. The Physical Layer includescomputationintensive bitlevel data processing functions, e.g. modulation, timing recovery. The Intercom protocol specication includes both data processingand control functions. It includes computation intensive functions e.g. errorcontrol, logarithmic quantization that are applied to the ows of a data samples and b service requestacknowledgment messages both in transmission andreception . Control functions include timedependent and datadependent control. The rst type occurs at the MAC layer, where the processing and thetransmission or reception of data ows is enabled using a timebased TDMAmechanism. Error control is instead a datadependent control function since itenables some actions e.g. discarding a packet depending on the result of datacomputation.To model the Intercom protocol specication we have initially used ACFSMs.Then, starting from the communication requirements and taking into account theassumptions on the behavior of the environment, e.g. on the rates and patternsof the input events, we have rened the ACFSMs into implementable ECFSMsand selected a communication protocol for each channel currently this step ismanual, but we are exploring ways of automating it. Since highquality voicecommunication requires that no data is lost within the protocol stack due tobuer overow, we have rened ACFSMs into lossless ECFSMs. Additional timing requirement are imposed by the TDMA policy data transmission can occuronly within TDMA slots. Environmental assumptions concern the occurrence ofthe following input signals Voice samples is periodic at 64 kbps, Rx data is aperiodic bit stream at 1.6 Mbps. Let us consider in detail the behavior of a protocol stack fragment. Incoming voice samples are rst processed by the Mulawand sent to the CRC module that at each transmission slot is enabled by theMAC. The CRC input FIFO shapes the data stream to make it t the TDMAslot allocation pattern and, since the read and write operations from this queueoccur at regular times, in this case, the FIFO size can be simply computed frominputoutput rates and slotsize, and chosen to be 500 bytes. A smaller size wouldrequire to block the Mulaw module and introduce another queue at the inputof Mulaw. A greater size does not give any advantage since 500 bytes is themaximum amount of data arriving during a frame.If we used the classical CFSMs model instead of ACFSMs, we would beforced to represent each FIFO as a CFSM. A CFSM of type FIFO calls, uponoccurrence of external events, internal read and write functions that access aninternal memory in FIFO manner. This implies that the CFSM at the receiverend of the channel in this case CRC has to explicitly make a request in theform of an event for new data as soon as it can process it. This results in anunnecessary overhead that is not present in the ACFSM model where FIFOsare part of the model and can be directly accessed by simple communicationprimitives.Finally, we also compared the design of the Intercom using our ACFSMbasedmethodology with a previous design 7 of the same specication done followingan SDLbased approach. The overall design process turned out to be easierand more eective using ACFSMs due to their capability of modeling controland dataow components independently from the nal implementation. Theprevious approach, instead, due to SDLs purely asynchronous nature, requiredto partition into hardware and software components from the beginning andmodel the hardware components directly in VHDL. This greatly reduced thedesign space and prevented from some system optimizations.7 ConclusionsIn this paper, we presented a new way of formalizing communication amongprocesses. We then introduced a new Model Of Computation called AbstractCodesign Finite State Machines, in which a nite state control coordinates multirate transitions and dataintensive computations. We described how a specication using ACFSMs can be rened, by queue sizing and static scheduling, untilcommunication becomes implementable. We used a reallife example, a wirelesscommunication protocol, to illustrate how the abstract communication can berened to a concrete, implementable one, and we discussed the main tradeosinvolved.8 AcknowledgementsWe gratefully acknowledge the discussions about Models of Computation withKen McMillan and Roberto Passerone and about communication protocols withJan Rabaey. This research is sponsored in part by the Gigascale Silicon Research Center GSRC and the Consiglio Nazionale delle Ricerche, ProgettoMADESSII.References1. F. Balarin and al. HardwareSoftware CoDesign of Embedded Systems The POLISApproach. Kluwer Academic Publishers, 1997.2. J. Buck, S. Ha, E. Lee, and D. Messerschmitt. Ptolemy a framework for simulating and prototyping heterogeneous systems. International Journal of ComputerSimulation, Special issue on Simulation Software Development, Jan. 1990.3. E.A.Lee and A.L.SangiovanniVincentelli. A framework for comparing models ofcomputation. IEEE Transactions on ComputerAided Design of Integrated Circuitsand Systems, 1712121729, December 1998.4. G. Kahn. The semantics of a simple language for parallel programming. In Proceedings IFIP Congress, Aug. 1974.5. E. A. Lee and D. G. Messerschmitt. Synchronous data ow. IEEE Proceedings,Sept. 1987.6. M.Sgroi, L.Lavagno, Y.Watanabe, and A.SangiovanniVincentelli. Synthesis of embedded software using freechoice petri nets. In Proceedings of the Design Automation Conference, June 1999.7. J. Rabaey and et al. Intercom project.httpbwrc.eecs.berkeley.eduResearchIntercomgroup.8. J. Rowson and A. SangiovanniVincentelli. Interfacebased design. In Proceedingsof the Design Automation Conference, pages 178183, 1997.9. R.Passerone, J.Rowson, and A.SangiovanniVincentelli. Automatic synthesis of interfaces between incompatible protocols. In Proceedings of the Design AutomationConference, pages 813, June 1998.This article was processed using the LaTEX macro package with LLNCS style
