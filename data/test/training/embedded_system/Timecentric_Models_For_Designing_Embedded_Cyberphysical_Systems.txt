Timecentric Models For Designing Embedded Cyberphysical SystemsJohn C. EidsonEdward A. LeeSlobodan MaticSanjit A. SeshiaJia ZouElectrical Engineering and Computer SciencesUniversity of California at BerkeleyTechnical Report No. UCBEECS2009135httpwww.eecs.berkeley.eduPubsTechRpts2009EECS2009135.htmlOctober 9, 2009Copyright  2009, by the authors.All rights reserved. Permission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page. To copy otherwise, torepublish, to post on servers or to redistribute to lists, requires prior specificpermission. Acknowledgement     This work is supported in part by the Center for Hybrid and EmbeddedSoftware Systems CHESS, at UC Berkeley, which receives support fromthe National Science Foundation NSF awards 0720882 CSREHSPRET and 0720841 CSRCPS, the U. S. Army Research Office AROW911NF0720019, the U. S. Air Force Office of Scientific ResearchMURI FA9550060312 the Air Force Research Lab AFRL, the State ofCalifornia Micro Program, and the following companies Agilent, Bosch,LockheedMartin, National Instruments, Thales and Toyota.Timecentric Models For Designing Embedded CyberphysicalSystems John C. Eidson, Edward A. Lee, Slobodan Matic, Sanjit A. Seshia, Jia ZouSeptember 30, 2009University of California at BerkeleyBerkeley, CA, 94720, USAeidsoneecs.berkeley.eduealeecs.berkeley.edumaticeecs.berkeley.edusseshiaeecs.berkeley.edujiazoueecs.berkeley.eduAbstractThe problem addressed by this paper is that realtime embedded software today is commonly builtusing programming abstractions with little or no temporal semantics. The focus is on computerbasedsystems where multiple computers are connected on a network and interact with and through physicalprocesses the plant via sensors and actuators. Such systems are often termed cyberphysical systemsCPS.The paper discusses the use of an extension to the Ptolemy II framework as a coordination languagefor the design of distributed realtime embedded systems. Specifically, the paper shows how to use modalmodels in the context of the PTIDES extension of Ptolemy II to provide a firm basis for the design ofan important class of problems. Several examples are given to show the use of this environment in thedesign of interesting practical realtime systems.KEYWORDS Computation theory, Computer science, Design methodology, Discrete event systems,Distributed control, Modeling, Realtime systems, Programming environments, SynchronizationThis work is supported in part by the Center for Hybrid and Embedded Software Systems CHESS, at UC Berkeley,which receives support from the National Science Foundation NSF awards 0720882 CSREHS PRET and 0720841CSRCPS, the U. S. Army Research Office ARO W911NF0720019, the U. S. Air Force Office of Scientific ResearchMURI FA9550060312 the Air Force Research Lab AFRL, the State of California Micro Program, and the followingcompanies Agilent, Bosch, LockheedMartin, National Instruments, Thales and Toyota.1 IntroductionIn cyberphysical systems CPS the passage of time becomes a central feature  in fact, it is thiskey constraint that distinguishes these systems from distributed computing in general. Time is central topredicting, measuring, and controlling properties of the physical world given a deterministic physicalmodel, the initial state, the inputs, and the amount of time elapsed, one can compute the current state ofthe plant. This principle provides the foundations of control theory. However, for current mainstreamprogramming paradigms, given the source code, the programs initial state, and the amount of timeelapsed, we cannot reliably predict future program state. When that program is integrated into a systemwith physical dynamics, this makes principled design of the entire system difficult. Instead, engineersare stuck with a prototypeandtest style of design, which leads to brittle systems that do not easilyevolve to handle small changes in operating conditions and hardware platforms. Moreover, the disparitybetween the dynamics of the physical plant and the program seeking to control it potentially leads toerrors, some of which can be catastrophic.The foundations of computing, rooted in Turing, Church, and von Neumann, are about the transformation of data, not about physical dynamics. Although computers have become fast enough to adequately measure and control many physical processes, modern computing techniques such as instructionscheduling, memory hierarchies, garbage collection, multitasking, besteffort networking, and reusablecomponent libraries which do not expose temporal properties on their interfaces, introduce enormoustemporal variability. Those innovations are built on a key premise that time is irrelevant to correctnessit is at most a measure of quality. By contrast, what a CPS needs is not faster computing, but physicalactions taken at the right time. Time needs to be a semantic property, not a quality factor.The challenge of integrating computing and physical processes has been recognized for some time,motivating the emergence of hybrid systems theories 16. Progress in that area, however, remainslimited to relatively simple systems combining ordinary differential equations with automata. Thesemodels inherit from control theory a uniform notion of time, an oracle called t available simultaneouslyin all parts of the system. Even adaptations of traditional computer science concepts to distributedcontrol problems make the assumption of the oracle t. OlfatiSaber et al. 18, for example, translateconsensus problems from computer science into control systems formulations, showing connectionsbetween such consensus problems and a variety of dynamical systems problems such as synchronizationof coupled oscillators, flocking, formation control, and distributed sensor fusion. These formulations,however, break down without the uniform notion of time that governs the dynamics. In networkedsoftware implementations, such a uniform notion of time cannot be precisely realized. Time triggerednetworks 10 and time synchronization 9 can be used to approximate a uniform model of time, but theanalysis of the dynamics has to include the imperfections. Without that, one could construct a controlsystem model that violates causality, for example.This paper is organized as follows. First, section 2 discusses the use of the PTIDES 23 extension tothe Ptolemy II simulation framework 6 as a coordination language for the design of distributed realtime embedded systems. Section 3 then defines temporal semantics of PTIDES, and shows how the useof modal models in the context of PTIDES provides a firm basis for the design of an important class ofCPS. This is followed by several examples in section 4 , which show the use of this environment in thedesign of interesting practical realtime systems. Finally, an outline of future work and conclusions arepresented in section 5.22 Design environmentThe proposed design environment is an extension of the Ptolemy II framework. Ptolemy II supportsmodeling, simulation, and design of systems using mixed models of computation MoC 6. PtolemyII has been extended by the addition of a MoC for timingcentric distributed software called PTIDESprogramming temporallyintegrated distributed embedded systems 26, 4, 25, 11. PTIDES modelsdefine the interaction of distributed software components, the networks that bind them together, sensors,actuators, and physical dynamics.PTIDES is based on discreteevent DE systems 20, 2, 1, 22, which provide a model of time andconcurrency. We specify DE systems using the actororiented approach. Actors are concurrent components that exchange timestamped events via input and output ports. The time in timestamps is a partof the model, playing a formal role in the computation. We refer to this time as model time. It may ormay not bear any relationship to time in the physical world, which in this paper we will call physicaltime without attempting define this precisely. In basic DE semantics, each actor processes input eventsin timestamp order. There are no constraints on the physical time at which events are processed. Weassume a variant of DE that has a rigorous, determinate, formal semantics 15, 12 and that has beenshown to integrate well with models of continuous dynamics 14.PTIDES extends DE by establishing a relationship between model time and physical time at sensors, actuators, and network interfaces. Whereas DE models have traditionally been used to constructsimulations, PTIDES provides a programmers model for deployable cyberphysical systems.2.1 Constraints relating model time and physical timeIn this section, we explain how in PTIDES the model time of DE is related to the physical time of thereal world. There are three key constraints that define this relationship.The basic PTIDES model is explained by referring to Figure 1, which shows three computational platforms typically embedded computers connected by a network and having local sensors and actuators.On Platform 3, a component labeled Local Event Source produces a sequence of events that drive anactuator through two other components. The component labeled Computation4 processes each eventand typically produces an output event with the same timestamp as the input event that triggers thecomputation. Those events are merged in timestamp order by a component labeled Merge and deliveredto a component labeled Actuator1.In PTIDES, an actuator component interprets its input events as commands to perform some physicalaction at a physical time equal to the timestamp of the event. The physical time of this event is measuredbased on clocks commensurate with UTC or a local systemwide realtime clock. This interpretationimposes our first realtime constraint on all the software components upstream of the actuator. Eachevent must be delivered to the actuator at a physical time earlier than the events timestamp.In Figure 1, Platform 3 contains an actuator that is affected both by some local control and by messages received over the network. The local control commands are generated by the actor labeled LocalEvent Source, and modified by the component labeled Computation4. The Merge component can injectcommands to the actuator that originate from either the local event source or from the network. Themessages from the network may depend on sensor data obtained on platforms 1 and 2. The commandsare merged in order of their timestamps.In Figure 1, notice that the top input to the Merge component comes from components that get inputsfrom sensors on the remote platforms. The sensor components, like the actuator components, are typi3Figure 1. Prototypical CPScally thin software wrappers around hardware drivers. They produce on their output ports timestampedevents. Here, the PTIDES model imposes a second relationship between model timestamps and physicaltime. Specifically, when a sensor component produces a timestamped output event, that timestamp mustbe less than or equal to physical time, however physical time is measured. The sensor can only tell thesystem about the past, not about the future.The third and final relationship refers to network interfaces. In this work we assume that the act ofsending an event via a network is similar to delivering an event to an actuator i.e., the event must bedelivered to the network interface by a deadline equal to the timestamp of the event. Consider Platform1in Figure 1 as an example. When an event of timestamp  is to be sent into the network fabric, thetransmission of this event needs to happen no later than physical time  . In general, we could set thedeadline to something other than the timestamp, but for our purposes here, it is sufficient that there be adeadline, and that the deadline be a known function of the timestamp. Our assumption that it equals thetimestamp makes the analysis particularly simple, so we proceed with that.2.2 Real time delays in sensors and actuatorsIt is clearly possible for a sensor or an actuator to introduce real delays. Specifically, in Figure 1, thephysical interface that provides inputs to the sensor actors may introduce delays. These delays wouldbe any elapsed physical time between the actual sampling of the physics and the generation of theevent timestamp. In addition there can be a computational or communication delay within a processor4between the time a sensor generates a timestamp and when this timestamp is available for computationin the PTIDES environment. The first delay may affect how the closedloop system behaves, and thesecond may affect whether deadlines at actuators can be met i.e., whether the model is feasible, asdiscussed in section 5.Actuators have similar issues. There may be significant time between the delivery of an event to anactuator actor and the time the actuator affects the physics. This corresponds to setup time for a digitalcircuit for example. The model designer may need to take this into account.2.3 Event processing in PTIDESUnder benign conditions 15, 12, DE models are determinate in that given the timestamped inputs tothe model, all events are fully defined. Thus, any correct execution of the model must deliver the sametimestamped events to actuators, given the same timestamped events from the sensors this assumesthat each software component is itself determinate. An execution of a PTIDES model is required tofollow DE semantics, and hence deliver this determinacy. It is this property that makes executionsof PTIDES models repeatable. A test of any correct execution of a PTIDES model will match thebehavior of any other correct execution.The key question is how to deliver a correct execution. For example, consider the Merge componentin Figure 1. This component must merge events in timestamp order for delivery to the actuator. Givenan event from the local Computation4 component, when can it safely pass that event to the actuatorHere lies a key feature of PTIDES. The decision to pass the event to the actuator is made locally at runtime by comparing the timestamp of the event against a local clock that is tracking physical time. Thisstrategy results in decentralized control, removing the risks introduced by a single point of failure, andmaking systems much more modular and composable.How is this done There are two key assumptions made in PTIDES. First, distributed platforms haverealtime clocks synchronized with bounded error. These realtime clocks provide our measurement ofphysical time. The PTIDES model of computation works with any bound on the error, but the smaller thebound, the tighter the realtime constraints can be. Time synchronization techniques 9 such as IEEE1588 8 can deliver realtime clock synchronization with bounded errors. In fact, an Ethernet PHY chipsupporting IEEE 1588 introduced in 2007 by National Semiconductor advertises a clock precision onthe order 8 ns on a localarea network 21.Second, PTIDES requires that there be a bound on the communication delay between any two hardware components. Specifically, sensors and actuators must deliver timestamped events to the runtimesystem within a bounded delay, and a network must transport a timestamped event with a bounded delay.Bounding network delay is potentially more problematic when using generic networking technologiessuch as Ethernet and TCPIP, but bounded network delay is already required today in the applicationsof interest here. This has in fact historically forced deployments of these applications to use specialized networking techniques such as timetriggered architectures 10, FlexRay, and CAN buses. Fornow it is sufficient to observe that these boundedness assumptions are achievable in practice. SincePTIDES allows detection of runtime timing errors, it is possible to model responses to failures of theseassumptions.Once these two assumptions bounded time synchronization error and bounded communication latencies are accepted, together with deadlines for network interfaces and actuators, local decisions can bemade to deliver events in Figure 1 without compromising the determinate DE semantics. Specifically, in5Figure 1, notice that the top input to the Merge comes from Sensor1 and Sensor2 through a chain of software components and a network link. Static analysis of these chains reveals the operations performed ontimestamps. In particular, in this figure, assume that the only components that manipulate timestampsare the components labeled model time delay di. These components accept an input event and producean output event with the same data payload but with a timestamp incremented by di.Assume we have an event e with timestamp  at the bottom input of Merge, and that there is no otherevent on Platform 3 with an earlier time stamp. This event can be passed to the output only when we aresure that no event will later appear at the top input of Merge with a timestamp less than or equal to  .This will preserve DE semantics. When can we be sure that e is safe to process in this wayWe assume that events destined to the top input of Merge must be produced by a reaction in Computation3 to events that arrive over the network. Moreover, the outputs of Computation3 are furtherprocessed to increment their timestamps by d2. Thus, we are sure e is safe to process when no eventsfrom the network will arrive at Platform 3 with timestamps less than or equal to   d2. When can webe sure of this Let us assume a network delay bound of n and a clock synchronization error bound of sbetween platforms. By the network interface assumption discussed above, we know that all events sentby Platform 1 or Platform 2 with timestamps less than   d2 will be sent over the network by the physical time   d2. Consequently, all events with timestamp less than or equal to   d2 will be received onPlatform3 by the physical time   d2  n s, where the s term accounts for the possible disagreementin the measurement of physical time. Thus when physical time on Platform 3 exceeds   d2  n  s,event e will be safe to process.It is easy to see that if the model is static components are not added during runtime and connectionsare not changed, then given enough information about each component, a similar analysis can be madefor all paths through the model. This analysis is done at design time. PTIDES components includecausality interfaces with algebraic compositionality properties 24, enabling automatic analysis. Atruntime, the only test performed to ensure DE semantics is to compare timestamps to physical time withan offset in the previous example, the offset is d2  n s. This is not expensive to implement.Note that the distributed execution control of PTIDES introduces another valuable form of robustnessin the system. For example, in Figure 1, if, say, Platform 1 ceases functioning altogether, and stopssending events on the network, that fact alone cannot prevent Platform 3 from continuing to drive itsactuator with locally generated control signals. This would not be true if we preserved DE semantics byconservative techniques based on the work by Chandy and Misra 3. It is also easy to see that PTIDESmodels can include components that monitor system integrity. For example, Platform 3 could raise analarm and change operating modes if it fails to get messages from Platform 1. It could also raise analarm if it later receives a message with an unexpectedly small timestamp. Time synchronization withbounded error helps to give such mechanisms a rigorous semantics.Moreover, since execution of a PTIDES model carries timestamps at run time, run time violations ofdeadlines at actuators can be detected. PTIDES models can be easily made adaptive, changing modesof operation, for example, when such realtime violations occur. In general, therefore, PTIDES modelsprovide adequate runtime information for detecting and reacting to a rich variety of timing faults.Recall that in PTIDES models, timestamps represent a model time, and that model time need not haveany relationship to time in the physical world. In PTIDES, we establish such a relationship at sensors,actuators and network interfaces. Thus an execution of a PTIDES model has considerable freedom toprocess an event earlier or later than the physical time corresponding to the timestamp of the event. Aslong as events are delivered on time and in timestamp order to actuators, the execution will look exactly6the same to the environment. This makes PTIDES models much more robust than typical realtimesoftware, because small changes in the physical execution timing of internal events are not visible tothe environment as long as realtime constraints are met at sensors, actuators and network interfaces.3 Temporal semantics in PTIDESPTIDES semantics is fully described in 23, 26 and is based on a taggedsignal model 13. Forthis discussion the important point is that actors define a functional relationship between a set of taggedsignals on the input ports and a set of tagged signals on the output ports of the actor.Fa  SI  SO 1Here, I is a set of input ports, O is a set of output ports, and S a set of signals. The signals s  S aresets of timestamp, value pairs of the form , v  T  V where the time set T represents time and Vis a set of values the data payloads of events.For simulation, the most common use of DE modeling, timestamps typically have no connectionwith real time, and can advance slower or faster than real time 22. The timestamps can be real numbers or their approximations as floating point numbers. This is the choice of many commonly useddiscreteevent simulators. They may instead be given by integers, as used by most hardware description languages. PTIDES approximates a superdense model of time 17, because it facilitates modelsthat mix continuous dynamics with discreteevent models 14. Superdense timestamps are tuples t, nthat support a notion of a sequence of causallyrelated simultaneous events. The set of superdense timestamps that we assume here is T  R0N. Here R0 represents the set of values of time in the PTIDESmodel environment and N represents a set of index ordering events with the same value of model time.For a particular value of a timestamp   t, n, t is called the model time and n the microstep.Actors are permitted to modify the timestamp and most commonly will modify the model time member t of the timestamp   t, n to indicate the passage of model time. For example, a delay actor hasone input port and one output port and its behavior is given by F  S  S where for each s  SFs  t , n , v  t, n , v  s 2That is, the output events are identical to input events except that the model time is increased by , aparameter of the actor.Consider the simple sensor, actor, actuator system of Figure 2. In this example we assume Fas t, n , 2  v  t, n , v  s i.e., the output is the same as the input but with its value scaled by afactor of 2. Both variants a and b of this figure show a serial combination of a sensor, delay, scaling,and actuator actors. The sensor actors produce an event 25 seconds, 15 volts where the timestamp25 seconds is the physical time at the time of sensing. For this discussion the value of the superdensemicrostep n of an event t, n, v is omitted. The delay actor increments the model time part of thetimestamp by 10 and the scale actor doubles the value member from 15 volts to 30 volts. In both casesthe actuator receives an event 35 seconds, 30 volts, which is in accordance with the PTIDES model itinterprets as a command to the actuator to instantiate the value 30 volts at a physical time of 35 seconds.As long as deadlines at the actuators are met, models a and b are identical in that all observableeffects are identical, regardless of computation times and scheduling decisions.7Figure 2. Linear combination of actors3.1 FeasibilityRather than simply using these models for simulation, this design environment uses these models asthe basis for generating executable code for a particular target environment. Since PTIDES is based onDE, it is possible to generate code that preserves DE semantics, thus ensuring that the implementation iscorrect in the sense that events are processed in timestamp order. It is also necessary to consider whetherthis generated code can actually meet the specified deadlines on a given platform. A solution that meetsboth DE semantics and the specified execution deadlines is termed a feasible solution. To determinefeasibility, we must consider the execution times of the various actors in order to generate a feasibleschedule if one exists.For a feasible solution the delay between the physical time of a sensor input and the physical timeof a resulting actuation must not be less than the total execution time of the PTIDES actors involved.For example, let the total execution time of the actors of Figures 2 a or b be E. Unlike model timedelays, which are in general application specific, execution times are platform specific, and are unrelatedto model time delays. E must also include any time interval between the actual sensing time and the timethe sensor value is available to the PTIDES environment and importantly the interval between deliveringthe final tagged signal to the actuator and the time at which is can be applied to the physical analogousto setup time for a digital circuit.It is easy to prove that for simple designs such as that of Figure 2 the following two constraints implyfeasibility.  E 3where  is the total model time delay, e.g. 10 in Figure 2, and E is the total execution time. Furtherassume that the sensor inputs are either periodic with period  or sporadic with a minimum time betweenoccurrences of , then in addition the following constraint must hold.  E 4It is easy to see that in the case of Figure 2 both variants a and b are also equivalent with respect tofeasibility.8Figure 3. General pattern of a modal model with two modes, each with its own refinement.3.2 Modal modelsThe use of modal models is well established both in the literature, for example Statecharts 7, UML19, and in commercial products such as Simulink RStateflow R from the MathWorksTM. Our style formodal models follows the pattern shown in Figure 3. A modal model is an actor, shown in the figure withtwo input ports and one output port. Inside the actor is a finite state machine FSM, shown in the figurewith two states, labeled mode1 and mode2. The transitions between states have guards and actions, andeach state has a refinement that is a submodel. The meaning of such a modal model is that the inputoutput behavior of the ModalModel actor is given by the inputoutput behavior of the refinement of thecurrent state.In the proposed design environment, modal models can be incorporated into both the model of therealworld as well as the PTIDES models of the embedded world. This requires careful specification ofthe temporal semantics of all actors including modal models to allow analysis of the resulting systemand to enable code generation that preserves the timing semantics when executing as a runtime artifacton a computing platform.Modal models introduce additional temporal considerations into a design. This is especially true formodal models that modify the timestamp   t, n of a signal. There are several possible semanticsthat could be used to define the behavior of a modal model consistent with DE semantics. The principal temporal semantics in this design environment are that events are executed in timestamp order. Formodal models it is also necessary to specify the order of execution of the internal aspects of the model.While the Ptolemy II environment provides several modal model execution options such as a preemptiveevaluation of guards prior to execution of a state refinement, the principal features critical to the discussion of the examples in this paper are as follows. A modal model executes internal operations in thefollowing order When the modal model reacts to a set of input events with timestamp  , it first presents those input9Figure 4. Simple timesensitive modal modelevents to the refinement of the current state i. That refinement may, in reaction, produce outputevents with timestamp  . If any of input events have an effect within the refinement at a later timestamp     , that effectis postponed. The modal model is invoked again at timestamp  , and only if the current state isstill i will the effect be instantiated. The guards of all transitions originating from the current state are evaluated based on the currentinputs, state variables, and outputs of the current state refinement with the same timestamp  asthe current inputs. If one of the guards evaluates to true, the transition and any associated actions are executed, andthe new current state i becomes that at the destination of the transition.Thus all phases of the execution of a modal model occur in strict timestamp order in accordance withDE semantics. While straightforward, these rules can yield surprises particularly when one or more ofthe refinements modify the model time of a signal.For example consider the simple modal model of Figure 4. The two inputs to this state machine aremode and sensor. The two outputs are signalOut and flag. For this example it is assumed that the guardsare never both true.10Suppose a sensor event t, v  10, 30 again omitting the microstep is received while the FSM isin state gain 2. The refinement of this state generates an output 17, 60. If no state transition occursbefore time t  17 then at time t  17 the postponed signalOut event 17, 60 will be produced.However suppose that at time t  12 a mode event 12, true occurs. This will cause a transitionto state gain 3 at time t  12. In this case the postponed signalOut event 17, 60 is not produced.While in state gain 3 a sensor event, say 15, 3, will result in a signalOut event 15, 9. The event is notpostponed since the refinement does not contain a delay actor.Similarly, suppose sensor events 5, 1 and 9, 2 are received with the FSM in state gain 2. Therefinement of this state generates output events 12, 2 and 16, 4 which must be postponed until timest  12 and t  16 respectively. Following the rules above, at time t  12, a signalOut event 12, 2occurs. At t  16 the FSM again executes to handle the postponed event 16, 4. The first thing thathappens is the instantiation of the signalOut event 16, 4. Next, the guards on the FSM are evaluatedand a transition occurs at t  16 to the state gain 5. A subsequent sensor signal 17, 1 then results in asignalOut event 17, 5.These examples illustrate that careful attention must be paid to the temporal semantics of the modalmodels to ensure that the desired application behavior results. It is still an open question whether thesemantics implemented are appropriate to enable the design of target applications or whether alternatetemporal semantics must be provided in place of or in addition to the current design.3.3 Constraints on model time delaysFor every causal path between a sensor input and an actuator output, the path model delay must exceedthe sum of the execution times of the actors along the path, including any execution time from other pathsthat impacts the execution time of the path in question. This raises an interesting design question since1 a minimum model time delay must be provided in order to avoid causality problems, and 2 theserequired minimum delays obviously may influence the choice of model delays within modal models andelsewhere which are usually delay specifications of applications. An example of this will be discussedin section 4.3.Consider the system of Figure 5. For simplicity, consider a single event from the Sensor actor propagating through the model without any mode changes during its propagation. There are two possiblepaths between the sensor and the actuator, depending on the state of the modal model. For the paththrough state 1 call that path path1, the total delay is path1  4  8 and the total execution time isEpath1  E1  E2  E3  E7  E9 assuming the execution time of the model delay actors is negligible. For the path through state 2 call it path2, the corresponding delay and execution time valuesare path2  6  8 and Epath2  E1  E2  E5  E7  E9. The feasibility constraints require thatpath1  Epath1 and path2  Epath2.A complete feasibility analysis, of course, will need to take into account the sporadic nature of eventsfrom the Sensor actor, and also the time at which state transitions can be taken. In addition, applicationrequirements may impose specific bounds on these parameters of the form path1  25 seconds andpath2  5 seconds. Finding a feasible solution requires considering all these constraints while preserving the desired modal model temporal semantics of the application by properly distributing the delaysamong the delay actors of the system. While understandable for this simple example, in a complex system these considerations point out the need for automated or semiautomated analysis tools. Such toolswill require visibility of causality via actor interfaces and in particular the visibility of any model time11Figure 5. Specifying model delaydelays present within the actor.4 Application studiesPTIDES can be used to integrate models of software, networks, and continuous dynamics. A practicalconsequence is to enable codesign and cosimulation of software controllers, networks, and the physicalplant. It also facilitates hardware in the loop HIL simulation, where deployable software can be testedat greatly reduced cost and risk against simulations of the physical plant. The DE semantics of themodel ensures that simulations will match implementations, even if the simulation of the plant cannotexecute in real time. Conversely, prototypes of the software on generic execution platforms can betested against the actual physical plant. The model can be tested even if the software controllers are notfully implemented. This extremely valuable property cannot be achieved today because the temporalproperties of the software emerge from an implementation, and therefore complete tests of the dynamicsoften cannot be performed until the final stages of system integration, with the actual physical plant,using the final platform.Closed loop control typically requires a fixed or at least a bounded delay in the controller that iscompatible with loop time stability considerations. PTIDES enables enforcement of deterministic delaysin the code generated for embedded systems.The inclusion of a network into an embedded system introduces three principal complications in thedesign embedded systems To preserve DE semantics and the resulting determinism system wide, it is necessary to provide a12common sense of time to all platforms. As noted in section 2 this is often based on a timeslottednetwork protocol but can also be based on a clock synchronization protocol such as IEEE 1588. The design of model delays must now account not only for execution time within an actuationplatform, e.g. the platform containing an actuator causally dependent on signals from other platforms, but must include network delay as well as execution time in platforms providing signalsvia the network to the actuation platform. To ensure bounded network delay it is usually necessary to enforce some sort of admission controlexplicitly controlling the time that traffic is introduced onto the network.The introduction of timed reactions further complicates the design and analysis of system temporal semantics, particularly when these reactions must be synchronized across a multiplatform system.PTIDES is well suited in managing these multiplatform design issues.In addition it appears that a design environment with the properties of PTIDES is required for therobust generation of executable code or FPGA images which preserves the timing semantics of thedesign. Since generating feasible execution schedules is critical, it helps that the PTIDES environmentgives the user explicit control of timing within the system.The solid foundation of PTIDES should enable design and code generation for high value embeddedsystems including high confidence medical devices and systems, traffic control and safety, advancedautomotive systems, process control, energy conservation, environmental control, avionics, instrumentation, critical infrastructure control electric power, water resources, and communications systems forexample, distributed robotics telepresence, telemedicine, defense systems, and manufacturing.The remainder of this section discusses the use of PTIDES for some important industrial applications,namely The use of timebased detection of missing signals to drive mode changes in the operation ofpower plants. This technique is also applicable in implementing holdover properties of referenceclocks used in telecommunication systems. The use of timebased models of the plant in testing controller implementations of power plants. The use of timed sequences of operations to define startup, normal, shutdown, and emergencysequencing of the power supplies in a test and measurement system.4.1 Power plant controlThe design of the control systems for large electric power stations is interesting in that the physicalextent of the plant requires a networked solution. The two critical design issues of interest here are theprecision of the control loop, since this effectively controls the electrical output, voltage, and frequencywhich must be matched to that of the grid, and the reaction time to failures. Due to the large mass of theturbine and generator, the loop time is relatively long. Failure reaction time specifications must be met toprevent expensive or dangerous conditions due to the large amounts of stored energy in the system. Forexample, in the case where the electric grid is disconnected, the fuel supply to the turbine must typicallybe reduced within a few milliseconds.A typical power plant can involve up to 3000 nodes comprising monitoring equipment separated byseveral hundred meters. Many of these nodes have modest sampling intervals and data requirements13but in the aggregate produce rather large volumes of data. Typical are temperature and pressure gauges,equipment status, etc. on cooling towers, motors, pumps, pipelines, and all the other elements peripheralto the turbines and generators themselves. These measurements are sent, possibly after some localprocessing and data reduction, to a central repository for later analysis and archiving and some are sentto the system controllers. Since the purpose of this data is to make decisions about the state of thephysical world, it is critical that the time at which each measurement is made be known to an accuracyand precision appropriate to the physics being measured. The PTIDES design system allows thesemeasurement times to be precisely specified and timestamped with respect to the realtime clocks in theseparate platforms.Figure 6 illustrates a model of a power plant that is hopefully readable without much additional explanation. The model includes a GeneratorTurbine Model, which models continuous dynamics, a model ofa communication network, and a model the supervisory controller. The details of these three componentsare not shown. Indeed, each of these three components can be quite sophisticated models, although forour purposes here will use rather simple versions.The model in Figure 6 also includes a local controller, which is expanded showing two main components, a Heartbeat Detector and Plant Control block. The Plant Control block is a modal model withfour states, as shown. The Down state represents the off state of the power plant. Upon receipt of atimestamped startup event from the supervisory controller, this modal model transitions to the Startupstate. When the measured discrepancy between electric power output and the target output gets belowa threshold given by errorThreshold, the modal model transitions to the Normal state. If it receives atimestamped emergency event from the Heartbeat Detector, then it will transition to the Shutdownstate, and after achieving shutdown, to the Down state. Each of these states has a refinement not shownthat uses input sensor data to specify the amount of fuel to supply to the generatorturbine. The fuelamount is sent over the network to the generatorturbine.This model is executable. The plots generated by the two Plotter actors in Figure 6 are shown inFigure 7 for one simulation. In this simulation, the supervisory controller issues a startup request attime 1, which results in the fuel supply being increased and the power plant entering its Startup mode.Near time 7.5, a warning event occurs and the supervisory controller reduces the target output levelof the power plant. It then reinstates the higher target level around time 13. The power plant reachesnormal operation shortly before time 20, and around time 26, a warning and emergency occur in quicksuccession. The power plant enters its Shutdown state, and around time 33 its Down state. Only a startupsignal from the supervisory controller can restart the plant.This model has a number of interesting features that are typical in such distributed control applications. First, it has two levels of control, supervisory control and local control. Emergency shutdown ishandled entirely by the local control, whereas reduction in power output due to a warning is handled bythe supervisory control. One of the challenges in designing such mixed control strategies is to preventaccidental overrides, where for example the supervisory control might reinstate normal operation whilethe local controller is attempting to shut down the plant. The PTIDES model ensures that even commands that originate from different places on the network have a deterministic ordering determined bytheir time stamps.The timestamps not only give a determinate semantics to the interleaving of events, but they can alsobe explicitly used in the control algorithms. This power plant control example illustrates this point bythe technique it uses to send warning and emergency events. Specifically, as shown in Figures 6 and7, the GeneratorTurbine Model sends timestamped sensor readings over the network to the Local14Figure 6. Model of a small power plant.15electricOutputoperatingTargetfuel0123450 5 10 15 20 25 30 35 40Plant Input fuel, Output, and Operating Targetstatesensorclockemergencywarning432101230 5 10 15 20 25 30 35 40Heartbeat and Plant State DisplaytimeWarning EmergencyDownStartupNormalShutdownDownFigure 7. Power plant output and eventsControl component. These sensor events are shown with x symbols in Figure 7. Notice that just priorto each warning event, there is a gap in these sensor events. Indeed, this Local Control componentdeclares a warning if between any two local clock ticks it fails to receive a sensor reading from theGeneratorTurbine Model. If a second consecutive interval between clock ticks elapses without a sensormessage arriving, it declares an emergency and initiates shutdown.The mechanism for detecting the missing sensor reading messages is shown in Figure 8. In that figure,the monitoredSignal input provides timestamped sensor reading messages. The localClock input provides timestamped events from the local clock. The MissDetector component is a finite state machinewith two states. It keeps track of whether the most recently received event was a sensor message or alocal clock event. This is possible because PTIDES guarantees that these message will be delivered tothis component in timestamp order, even when the messages and their timestamps originate on a remoteplatform elsewhere in the network. This MissDetector component issues a missed event with value trueif two successive local clock events arrive without an intervening sensor event. The missed event willhave the same timestamp as the local clock event that triggered it.The second component, labeled StatusClassifier, determines how to react to missed events. In thisdesign, upon receiving one missed event, it issues a warning event. Upon receiving a second missedevent, it issues an emergency event. Note that this design can be easily elaborated, for example to requiresome number of missed events before declaring a warning. Also note that it is considerably easier inthis framework to evaluate the consequences of design choices like the local clock interval. Our pointis not to defend this particular design, but to show how explicit the design is. The PTIDES semanticsguarantee that an implementation will behave exactly like the simulation, given the same timestampedinputs, and hence the resulting design is principled and complete. Moreover, it is easy to integrate asimulation model of the plant, thus evaluating design choices well before system integration.A more detailed discussion of the design issues illustrated in this example for an actual commercialpower plant control system is found in 5.16Figure 8. Heartbeat detector that raises warning and emergency alarms.4.2 Holdover applicationsThe modal model and missing signal techniques discussed in section 4.1 above are also applicable tothe design of reference clocks in a telecommunications system. Telecommunications systems representone of the largest and most complex distributed applications in the world. A critical feature of thesesystems is the distribution of precise frequency and in some cases precise time among the various devices. For example, the transmission of digital information for services such as E1T1 lines requires thattransmitter and receiver pairs agree on transmission frequency to prevent loss of information. Specifications on frequency accuracy are set by several standards organizations such as the ITU and are typically 1 1011 over long periods of time.In these systems, frequency and time are established by a suite of primary reference clocks PRCswhich are synchronized to a common source such as GPS and which in turn distribute time and frequency information to client devices. PRCs consist of a very high quality quartz oscillator and an atomicclock, usually either cesium or rubidium based. The quartz oscillator provides short term stability and isdisciplined by the atomic clock which provides long term stability. The best of these devices can achievean accuracy of  5 1013 with a stability of  8 1014 over changes in all environmental variablesand  1 1014 averaged over a 5 day period. PRC clients are typically lower performance and lowercost devices which requires them to be synchronized to a PRC to meet international telecommunicationsstandards. Both PRCs and their clients are typically single platform devices. To a PRC client the reference source typically appears as a component analogous to the sensors in the power plant discussion17providing synchronization information over a network.What happens when a PRC client device loses contact with the PRC Again organizations such as theITU have set specifications, called holdover specifications, that detail the required frequency accuracyas a function of time since the loss of contact with the PRC. The PRC client holdover architecture ismuch like the startup, normal and shutdown modes of the power plant example and indeed the basicstructure of the controller of Figure 6 can be used but with the state refinements and transitions redefinedas discussed below.A PRC client typically generates an error signal based on the difference between the output of thelocal clock and the incoming reference signal from the PRC. This error signal, perhaps in conjunctionwith environmental sensor signal inputs, is used by the controller to compute a correction to the localclock.The input governing the state transitions of the controller FSM is a signal indicating whether the PRCsignal is valid and present. In the case of a PRC client controller the substates are State 1 Startup. At system startup or after coming out of the holdover state it must be presumedthat the error signal is large and more importantly that any parameters of the algorithms are outof date. In this state a correction signal is computed based on either a default or the most recentparameters and the values of these parameters are updated to reflect current conditions includingany environmental information available from sensors. In addition, there are often applicationrequirements that limit the rate of change of the output and these would appear as a slew ratelimitation on the correction signal. State 2 Normal. In this state the error is below some application set limit. In this state thecorrection algorithm may be somewhat different than in the startup state while making use of thealgorithm parameters established in the startup state. Algorithm parameters are updated to reflectlong term drift characteristics based on the current environment information. State 3 Holdover. In this state the PRC reference signal is absent and the correction signal mustbe calculated using an algorithm based only on the best projection available using the parameterson exit from the normal state and the current environmental information from sensors. It mayalso be possible to estimate how long the output will remain within specification based on theseparameters, a model of the clock physics and the environmental information.The transition between the startup and normal states occurs when the correction signal falls below anapplication defined threshold. The transition between the normal and holdover states occurs when thePRC signal indicates a failure of the PRC reference signal. The transition between holdover and startupoccurs when the PRC reference signal is reestablished.The reliable generation of the presence of absence of the PRC reference signal is critical to the operation of the controller. Since this signal is typically received from networked source, the heartbeatdetection techniques discussed in section 4.1 in connection with the power plant example are applicable.4.3 Shutdown sequencesA common application requirement is for a single primary event to spawn a sequence of events whichhave a specific time relationship to the primary event. Often this primary event is some sort of system orcomponent fault condition which may occur or be detected at M multiple points in the system and the18spawned events may likewise occur at N multiple locations each with a different time relationship to theprimary event. Whereas the powerplant example focused on detecting the absence of regular, expectedevents, in this section we focus on sporadic or unpredictable events and the chain of events triggered bythem. PTIDES is equally well suited to specifying such chains of events and precisely controlling thetiming between them, even across a networked system.For these M N applications, a multicast or publishsubscribe model is appropriate since this allowsevents with the same name to be detected and published from more than a single location and permits theinterpretation to vary by recipient. If precise timing is required then the inclusion of the primary eventtimestamp in the message enables the recipients to meet the timing requirements independent of networkand local delay and jitter, provided causality is not violated. Of course a onetoone communicationmodel could be used, but, except in the rather rare case where all recipients take exactly the sameaction with the same temporal semantics, this model requires a separate message to each recipient.This presents scaling problems and typically results in increased network traffic to the detriment of lownetwork delay and determinism.The requirements call for enforcing precise timing specifications on events executing on differentplatforms each with their own local clock. To do this, it is necessary to synchronize these local clocksto within some bounded error small enough to meet the application requirements. This can be done innetworked systems by means of a protocol such as IEEE 1588 as discussed in section 2.3.PTIDES is well suited for this type of application. An example is illustrated in Figures 9 and 10.In many test systems, and probably in operational systems, the failure of a power supply, or anotherdevice, can cause serious damage to instrumentation and operational systems. These failures may becaused by some internal fault in the power supply or may be due to over current demand by the load.In many cases system specifications require that in the event of such a power supply failure that otherpower supplies and other equipment in the system be shut down in a specific order and with specific timeconstraints. Furthermore the order, and possibly the timing, of the system shutdown may depend on theidentity of the first component to fail. This is a very common problem and typically quite expensive toimplement since the solution must be embedded in the primary application without undue degradationof primary application function or timing.This problem can be solved by the use of a named event, possibly with an attribute indicating thesource, and with a timestamp indicating the time the failure was detected. The detecting device, e.g. thepower supply that experienced the over current, multicasts or publishes this event. Recipient devices arepreprogrammed with the correct reaction to such an event with the reaction possibly depending on thetimestamp and identity attributes.A typical test system consists of the device under test DUT, several power supplies and other devicessuch as signal generators or digitizers. All communicate via a network. A typical test run is a follows At turn on all equipment is powered down. A system controller then issues a startup command which causes the power supplies to turn onin a specific order and with specific relative turn on times. These specifications will be DUTdependent. The other devices typically power up immediately but do not generate outputs in thisphase. After all supplies are at their target voltage the system moves to the normal or test phase in whichthe controller and other devices combine to execute the desired test on the DUT.19Figure 9. Power supply controller FSM At the conclusion of the test sequence the controller issues a shutdown command which causes thepower supplies and other devices to turn off in a specific order and with specific relative turnofftimes. If during the test a fault is detected, e.g. power supply over current, that can potentially damageeither the instrumentation or the DUT the shutdown sequence is started. Since such an event isusually time critical, this function is often difficult to meet if it requires involvement of the systemcontroller.The modal model of Figure 9 illustrates a typical design for a controller that implements these requirements. The shutdown and startup inputs typically are generated either by a front panel or via the networkfrom a supervisory controller. The voltageMonitor signal is generated elsewhere in the power supply andrepresents the actual output voltage of the supply. The trigger input is connected externally to the FSMvia a feedback loop to the triggerRequest output of the FSM. The triggerRequest output is generated20Shutdown triggered by overcurrent15 volt supplyLoad resistance decreasedTime unitsTime unitsPower supply output voltagesa Power supply output voltagesb Output current of 15 volt supplyOutput current 2 volt supply5 volt supplyFigure 10. Power supply system outputsduring selected state transitions as shown and serves to generate an execution cycle of the modal modelrefinements.The key inputs for the requirements discussed here are the fault or overcurrent signal inputs, whichinitiate an immediate start to the shutdown sequence from either the steady state or powerup states. Theovercurrent signal is generated internal to the supply and is also transmitted via a multicast transmissionto the fault input of other power supplies in the system.Note that in the refinements of both the powerup and shutdown states the output of the appropriatepowerOut signal, indicating the desired output voltage of the supply, are delayed by amounts that alloweach supply to be configured to meet the sequence timing requirements. From the temporal semanticsrules of section 3 it is clear that if a shutdown, fault or overcurrent input arrives at the FSM with a modeltime t earlier than the model time of the powerOut event of the powerup state, that this output will notoccur, and the transition to the shutdown state will be initiated. Otherwise the transition to the shutdownstate will occur while the power supply is reaching final voltage or is in steady state, thus meeting thestated application requirements. This also illustrates how the temporal semantics of an application can beadjusted or changed by placing a model delay inside a modal model, as shown in Figure 9, in which casethe output can be preempted by a mode change as discussed, or outside the modal model, as illustratedby actor delay8 in Figure 5, in which case the output will occur, at the specified model time irrespectiveof the state of the modal model at that time.The operation of this controller is illustrated in Figure 10. Figure 10 a shows the actual outputvoltages from the 15, 5, and 2 volt power supplies in the system. Figure 10 b shows the output currentof the 15 volt supply. The delay actors in the powerup state refinements of the FSMs of the supplies21delay the turn on of the supplies after receipt of a startup signal by 10, 8, and 6 time units respectivelyfor the 15, 5, and 2 volt supplies. The corresponding delays after a transition to the shutdown stateare 5, 7, and 9 respectively. In this example a startup is received by all supplies at 10 time units and ashutdown is received at 40 time units. As expected the times at which the various supplies begin to turnon are 16, 18, and 20 time units for the 2, 5, and 15 volt supplies. The supplies turn off in the reverseorder at 45, 47, and 49 for the 15, 5, and 2 volt supplies respectively.Following this sequence a second startup is received at time 60 with the resulting sequence of turn ontimes shown. However in this case the 15 volt supply experiences double the expected output currentas shown in Figure 10 b resulting in an overcurrent signal at approximately time 72. As noted thissignal is transmitted to the FSM of the 15 volt supply and as a fault signal to all other supplies. Theresulting shutdown sequence is shown where again the supplies turn off in the reverse order from theturn on sequence.This example illustrates several features of the PTIDES environment The use of a timed delay actor within a modal model to specify the temporal behavior of the device. Because these time delay actors manipulate timestamps, the relative ordering of the resultingevents is guaranteed by the PTIDES semantics. The use of synchronized clocks in a multiplatform system to allow FSMs and other actors in eachplatform to enforce systemwide temporal behavior. The enforcement of correspondence between model and physical time at sensors and actuators toensure that such timing specifications are realized, subject of course to finding a feasible solutionas discussed in section 3.3. The enforcement at platform network outputs of sending deadlines to ensure that multiplatformfeasible solutions are computable.5 Conclusion and future workThis paper reviewed Ptolemy II enhancements for several important aspects of CPS, namely PTIDESfor distributed realtime systems, and modal models for multimode system behavior. We presentedthe semantics for these enhancements, and discussed related constraints. We then demonstrated therelevance of these enhancements through several examples that apply PTIDES and modal models incommon industrial applications.Our future activities include work on several components of the PTIDES framework. PTIDES relieson software components providing information about model delay they introduce. This informationis captured by causality interfaces 24, and causality analysis is used to ensure that DE semantics ispreserved in an execution. The precise causality analysis when modal models are allowed is undecidablein general, but we expect that common use cases will yield to effective analysis. We plan to identifysubsets of modal models for which causality analysis is decidable, and study the complexity of theresulting analysis.Another challenge is to provide feasibility analysis for the PTIDES programming model, which wouldallow for a static analysis of the deployability of a given application on a set of resources. As noted,feasibility considerations in multi platform designs require managing execution times and model delay22actors. Research is also needed on additions to the design environment to enable designers to optimizethe distribution of actors on a set of platforms to meet these temporal requirements.A major component of our work will be the design of a distributed execution platform for PTIDES.The code generator integrated within the Ptolemy II environment will generate C code from PTIDESmodels and glue them together with the preexisting software components to produce executable programs for each of the platforms in the network. The code will be executed in the context of the PtidyOSruntime environment that can be considered as a lightweight operating system with PTIDES semantics.References1 F. Baccelli, G. Cohen, G. J. Olster, and J. P. Quadrat. Synchronization and Linearity, An Algebrafor Discrete Event Systems. Wiley, New York, 1992.2 C. G. Cassandras. Discrete Event Systems, Modeling and Performance Analysis. Irwin, 1993.3 K. M. Chandy and J. Misra. Distributed simulation A case study in design and verification ofdistributed programs. IEEE Transaction on Software Engineering, 55, 1979.4 P. Derler, E. Lee, and S. Matic. Simulation and implementation of the ptides programming model.In International Symposium on Distributed Simulation and Real Time Applications DSRT, Vancouver, Canada, 2008. IEEE.5 J. C. Eidson. Measurement, Control, and Communication Using IEEE 1588, pages 194200.Springer, London, 2006.6 J. Eker, J. W. Janneck, E. A. Lee, J. Liu, X. Liu, J. Ludvig, S. Neuendorffer, S. Sachs, and Y. Xiong.Taming heterogeneitythe ptolemy approach. Proceedings of the IEEE, 912127144, 2003.7 D. Harel. Statecharts A visual formalism for complex systems. Science of Computer Programming, 8231274, 1987.8 IEEE Instrumentation and Measurement Society. 1588 IEEE standard for a precision clock synchronization protocol for networked measurement and control systems. Standard specification,IEEE, July 24 2008.9 S. Johannessen. Time synchronization in a local area network. IEEE Control Systems Magazine,pages 6169, 2004.10 H. Kopetz and G. Bauer. The timetriggered architecture. Proceedings of the IEEE, 911112126,2003.11 E. Lee, S. Matic, S. Seshia, and J. Zou. The case for timingcentric distributed software. InInternational Workshop on CyberPhysical Systems, Montreal, Canada, 2009. IEEE.12 E. A. Lee. Modeling concurrent realtime processes using discrete events. Annals of SoftwareEngineering, 72545, 1999.2313 E. A. Lee and A. SangiovanniVincentelli. A framework for comparing models of computation.IEEE Transactions on ComputerAided Design of Circuits and Systems, 171212171229, 1998.14 E. A. Lee and H. Zheng. Leveraging synchronous language principles for heterogeneous modelingand design of embedded systems. In EMSOFT, Salzburg, Austria, 2007. ACM.15 X. Liu and E. A. Lee. CPO semantics of timed interactive actor networks. Theoretical ComputerScience, 4091110125, 2008.16 O. Maler, Z. Manna, and A. Pnueli. From timed to hybrid systems. In RealTime Theory andPractice, REX Workshop, pages 447484. SpringerVerlag, 1992.17 Z. Manna and A. Pnueli. Verifying hybrid systems. Hybrid Systems, pages 435, 1992.18 R. OlfatiSaber, J. A. Fax, and R. M. Murray. Consensus and cooperation in networked multiagentsystems. Proceedings of the IEEE, 951215233, 2007.19 O.M.G. U.m.l. specification Version 1.3. Object Management Group, 1999.20 P. Ramadge and W. Wonham. The control of discrete event systems. Proceedings of the IEEE,7718198, 1989.21 D. Rosselot. Simple, accurate time synchronization in an ethernet physical layer device. In ISPCSInternational IEEE Symposium on Precision Clock Synchronization for Measurement, Control andCommunication. Vienna, 2007.22 B. P. Zeigler, H. Praehofer, and T. G. Kim. Theory of Modeling and Simulation. Academic Press,2nd edition, 2000.23 Y. Zhao, E. A. Lee, and J. Liu. A programming model for timesynchronized distributed realtimesystems. In RealTime and Embedded Technology and Applications Symposium RTAS, Bellevue,WA, USA, 2007. IEEE.24 Y. Zhou and E. A. Lee. Causality interfaces for actor networks. ACM Transactions on EmbeddedComputing Systems TECS, 73135, 2008.25 J. Zou, J. Auerbach, D. Bacon, and E. Lee. Ptides on flexible task graph Realtime embeddedsystem building from theory to practice. In Conference on Languages, Compilers, and Tools forEmbedded Systems LCTES, Dublin, Ireland, 2009. ACM.26 J. Zou, S. Matic, E. Lee, T. Feng, and P. Derler. Execution strategies for ptides, a programmingmodel for distributed embedded systems. In RealTime and Embedded Technology and Applications Symposium RTAS, San Francisco, CA, USA, 2009. IEEE.24
