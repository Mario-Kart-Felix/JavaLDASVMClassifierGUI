AVATAR A Framework for Dynamic Security Analysis of Embedded Systems Firmwares Jonas Zaddach zaddacheurecom.fr Luca Bruno, Aurlien Francillon, Davide Balzarotti Outline  Introduction  AVATAR overview  Framework components  Use cases  Conclusion 22414 2 Software is everywhere  Embedded devices are diverse  but all of them run software  22414 3 Reasons for embedded security  Embedded devices are ubiquitous  Even if invisible, they are essential to your life  Can operate for many years  Legacy systems, no security updates  Have a large attack surface    Networking, forgotten debug interfaces, etc 22414 4 Third party security evaluation  No source code available  No toolchain available  No documentation available  Distinct tools to flash and debug for each manufacturer 22414 5 Wishlist for security evaluation 22414 6  Typical PC security toolbox  Advanced debugging techniques  Tracing  Fuzzing  Tainting  Symbolic Execution  Integrated tools  IDA Pro  GDB  A B C D E  0  0  8  8 0  x  8 Challenges  Advanced dynamic analysis needs emulation  Full emulation  Unknown peripherals  Firmware fails if peripherals are missing  Integration  Support multiple vendors and platforms 22414 7 Outline  Introduction  AVATAR overview  Framework components  Use cases  Conclusion 22414 8 AVATAR  Orchestrate execution between emulator and device  Forward peripheral accesses to the device under analysis  Do not attempt to emulate peripherals  No documentation  Reverse engineering is difficult 22414 9 Avatar overview 22414 10 Emulator  . . . mov   r2, r0 mov   r3, r1 add    r3, r3, 1 ldr      r2, r2, 0 cmp   r2, r3        . . .  Device Inmemory stub Memory Registers CPU state Avatar Analysis script plugins Analysis plugins Avatar overview 22414 11 Emulator  . . . mov   r2, r0 mov   r3, r1 add    r3, r3, 1 ldr      r2, r2, 0 cmp   r2, r3        . . .  Device Inmemory stub Memory Registers CPU state Avatar Analysis script plugins Analysis plugins Avatar overview 22414 12 Emulator  . . . mov   r2, r0 mov   r3, r1 add    r3, r3, 1 ldr      r2, r2, 0 cmp   r2, r3        . . .  Device Inmemory stub Memory Registers CPU state Avatar Analysis script plugins Analysis plugins Avatar overview 22414 13 Emulator  . . . mov   r2, r0 mov   r3, r1 add    r3, r3, 1 ldr      r2, r2, 0 cmp   r2, r3        . . .  Device Inmemory stub Memory Registers CPU state Avatar Analysis script plugins Analysis plugins IRQ Outline  Introduction  AVATAR overview  Framework components  Use cases  Conclusion 22414 14 Emulator 22414 15 Emulator Avatar Configuration Qemu GDB Remote Memory S2E Qemu Klee LLVM Analysis plugins Memory Registers CPU state Avatar core 22414 16 Emulator Avatar Device Configuration interface GDB interface Remote memory GDB interface plugins Analysis plugins Analysis script Embedded target 22414 17 Device Inmemory stub Memory Registers CPU state Avatar JTAG server Target communication  Either a debugging interface  JTAG  Debug Serial Interface  Or code injection and a communication channel  Custom GDB Stub  Serial Port 22414 18 Bottlenecks  Emulated execution is much slower than execution on the real device  Memory access forwarding through lowbandwidth channel is the bottleneck  In one case down to 10 memory accessessec.  Interrupts can saturate debug connection 22414 19 Improving performance  Transfer executionstate  From the device to the emulator  From the emulator to the device  Migrate memory and code snippets  Keep memory regions in the emulator  Execute IOintensive pieces of code on the device 22414 20 Full separation mode 22414 21 Emulator Device State Register State Memory Avatar Memory access optimization 22414 22 Emulator Device State Register Memory State IO Memory Avatar Execute code snippets on the device 22414 23 Emulator Device State State Avatar Code Execute code snippets on the device 22414 24 Emulator Device State State Code Code Outline  Introduction  AVATAR overview  Framework components  Use cases  Conclusion 22414 25 Use case Hard Disk  Recover bootloader protocol with symbolic execution  Inject GDB stub  Instrument flash loading  Inject symbolic values for  data read from serial port  Keep track of which input  leads into which code flow 22414 26 httpwww.s3.eurecom.frdocsndss14zaddach.pdf Use case GSM Phone  Search vulnerabilities in SMS decoding routine  Connect through JTAG  Execute on device until SMS  decoding  Replace SMS payload  with symbolic values  Check for symbolic values in   program counter  loadstore address 22414 27 Use case Econotag  Find proofofconcept bug in user application  Connect through JTAG  Execute on device until Zigbee packet arrives  Replace payload with symbolic values  Check for symbolic  values in  program counter  loadstore address 22414 28 We are adding more devices 22414 29 Outline  Introduction  AVATAR overview  Framework components  Use cases  Conclusion 22414 30 Future work  Enhance state consistency  DMA memory changes not tracked  Automatically emulate peripherals  Improve symbolic execution  Coherency between HW and SW  Improve bugfinding strategies 22414 31 Conclusion  AVATAR is a modular opensource tool to   Enable dynamic analysis  And perform symbolic execution  On embedded devices  Where only binary code is available A first step towards better analysis tools for embedded systems 22414 32 Questions 22414 33  Thank you for listening  Open source on github  httpsgithub.comeurecoms3avatarpython  Project page  https3.eurecom.frtoolsavatar Thanks to Pascal Sachs and Luka Malisa who built an earlier prototype of the system, and Lucian Cojocar for applying and extending AVATAR References  AVATAR web page httpwww.s3.eurecom.frtoolsavatar  AVATAR A Framework to Support Dynamic Security Analysis of Embedded Systems Firmwares, Jonas Zaddach, Luca Bruno, Aurelien Francillon, Davide Balzarotti  Howard a dynamic excavator for reverse engineering data structures, Asia Slowinska, Traian Stancescu, Herbert Bos  KLEE webpage httpccadar.github.ioklee  S2E webpage httpss2e.epfl.ch  S2E A Platform for InVivo MultiPath Analysis of Software Systems, italy Chipounov, Volodymyr Kuznetsov, George Candea  The S2E Platform Design, Implementation, and Applications, Vitaly Chipounov, Volodymyr Kuznetsov, George Candea  QEMU webpage httpqemu.org  Dowsing for Overflows A Guided Fuzzer to Find Buffer Boundary Violations, Istvan Haller, Asia Slowinska, Matthias Neugschwandtner, Herbert Bos 22414 34 Injecting a debugger 22414 35  Requires writing and executing memory  Debug menus allow this sometimes  A code execution vulnerability can be used  Requires a communication channel  Serial port, GPIO, Power consumption,   GPIO  Requires an unused memory location in the firmware  Stub is about 3k of code Full separation mode 22414 36 Emulator Device State Register State Memory Avatar Memory access optimization 22414 37 Emulator Device State Register Memory State IO Memory Avatar Transfer execution  from emulator to device 22414 38 Emulator Device State Register Memory State Transfer execution  from emulator to device 22414 39 Emulator Device State Avatar State Register Memory Transfer execution  from device to emulator 22414 40 Emulator Device State State Register Memory Transfer execution  from device to emulator 22414 41 Emulator Device State Register Memory State Avatar Software interrupts  Software Interrupts  Are issued by an interrupt  instruction in the code  Can be entirely emulated  Qemu manages calling of  software interrupt handlers 22414 42 httphome.netcom.comswansontinterrupt.jpg Task completion interrupts  Triggered by application requests  Responses aligned with firmware execution speed  E.g., signal that a requested DMA transfer has finished  Can be forwarded from the device to the emulator  A stub on the device traps interrupts and forwards them 22414 43 External event interrupts   Signals an external event  Events aligned to wallclock instead of execution time  E.g., that a time span has elapsed   Solution depends    Controllable interrupts can be forwarded  Uncontrollable interrupts need to be synthesized  Original interrupts are suppressed  Emulated interrupts are inserted according to emulated execution speed 22414 44
