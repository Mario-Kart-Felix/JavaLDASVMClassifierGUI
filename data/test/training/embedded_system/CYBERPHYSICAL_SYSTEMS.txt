2nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005International Journal of Modeling, Simulation,and Scientific ComputingVol. 4, No. 2 2013 1340005 26 pagesc World Scientific Publishing CompanyDOI 10.1142S1793962313400059HIGH FIDELITY VIRTUALIZATION OFCYBERPHYSICAL SYSTEMSYU ZHANG,,, FEI XIE, YUNWEI DONG,GANG YANG and XINGSHE ZHOUSchool of Computer ScienceNorthwestern Polytechnical UniversityXian, 710072, P. R. ChinaDepartment of Computer SciencePortland State UniversityPortland, Oregon 97207, USAyuzhang.nwpugmail.comReceived 1 April 2013Accepted 4 April 2013Published 19 June 2013Cyberphysical systems CPS tightly integrate cyber and physical components and transcend discrete and continuous domains. It is greatly desired that the synergy betweencyber and physical components of CPS is explored even before the complete system isput together. Virtualization has potential to play a significant role in exploring suchsynergy. In this paper, we propose a CPS virtualization approach based on the integration of virtual machine and physical component emulator. It enables real software,virtual hardware, and virtual physical components to execute in a holistic virtual execution environment. We have implemented this approach using QEMU as the virtualmachine and MatlabSimulink as the physical component emulator, respectively. Toachieve highfidelity between the real system and its virtualization, we have developeda strategy for synchronizing the virtual machine and the physical component emulator.To evaluate our approach, we have successfully applied it to realworld control systems.Experiments results have shown that our approach achieves highfidelity in capturingdynamic behaviors of the entire system. This approach is promising in enabling earlydevelopment of cyber components of CPS and early exploration of the synergy of cyberand physical components.Keywords Cyberphysical systems virtualization virtual machine cosimulation.1. IntroductionCyberphysical systems CPS are engineered systems that are built from anddepend upon the synergy of cyber and physical components.1 CPS engineeringmust account for the interacting and interdependent behaviors of both types ofcomponents. Representative application domains of CPS include medical devices134000512nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.and systems, automobiles, robotics, avionics, and other critical infrastructures. Dueto the criticality of CPS, they are often required to be highconfidence.CPS are generally difficult to analyze, design and validate because of the following two main reasons In contrast to the traditional embedded systems view where the focus tends tobe more on the cyber components, CPS emphasize the holistic system view overboth the cyber and physical components. CPS engineering must account for theinteracting and interdependent behaviors of cyber and physical components toachieve system level functionalities CPS conjoin two different semantic domains the continuous dynamics of thephysical components often modeled by differential equations and the discretedynamics of cyber components often modeled in discrete mathematics. Thesedifferent semantics make the integration of these components and also theirabstractions a major challenge.The above two reasons significantly complicate analysis of CPS. For certain components of CPS, particularly physical components, the only abstractions availableare usually simulation models, which makes complete formal analysis impracticaland simulation the key method for validating these systems. The need for effectivesimulation techniques for CPS integrating cyber and physical components has beenrecognized for some time. Most current techniques abstract cyber components intostate machines running in parallel with the simulation models of physical components. The omission of programminglanguage level details of cyber componentsmake it hard to achieve holistic validation of the complete CPS and detect theimplementationlevel errors of cyber components.In order to address this drawback, simulation techniques need to model the fullclosedloop system including both the cyber components in implementation leveland physical components. It is greatly desired that the synergy of cyber and physical components is explored even before the complete system is put together, forinstance, the cyber components can be developed and evaluated even before thephysical components are manufactured. Virtualization has the potential to play asignificant role in exploring the synergy between the cyber and physical componentsof CPS. Recently, virtual machine has been increasingly used in the analysis, design,verification and deployment of computer systems, particularly embedded systems.It enables early software development even before silicon prototypes become available. A notable example is how Intel used virtual devices to enable early driverdevelopment for their 40 Gigabit Ethernet adapter before the device became available.2 However, virtual machine lacks the capabilities to capture the continuousdynamics of physical components and enable holistic CPS visualization.In this paper, we present a CPS virtualization approach based on the integration of virtual machine and physical component emulator. Virtual machine emulates the hardware components such as the processor, bus, and peripheral devices,etc. It supports execution of a fullfledged operating system such as Linux and134000522nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systemsapplicationspecific software components such as software controllers. Physical component emulator provides the virtualization of physical components such as sensors,actuators, and control plants. Their integration enables real software, virtual hardware and virtual physical components to execute in a holistic virtual executionenvironment.Central to this integration is the synchronization between the virtual machineand the physical component emulator, which greatly affects fidelity and efficiencyof virtualization. Although differential equations modeling physical components aresolved with approximations, the events generated in the virtual machine and thephysical component emulator are quite different. To synchronize these events, wedesigned a synchronization strategy in which we unify the essential synchronizationevents along a synchronization clock. With this strategy, we only synchronize theemulators on the events that affect the system behaviors, to avoid unnecessaryoverheads.We have implemented this approach using QEMU3 as the virtual machineand MatlabSimulink4 as the physical component emulator, respectively. And wehave also implemented the synchronization strategy. To evaluate our approach, wehave successfully applied it to realworld control systems. Experiment results showthat our approach can achieve highfidelity in capturing system dynamic behaviorsefficiently.This paper makes the following contributions. 1 We present a CPS virtualization framework, which enables real software, virtual hardware and virtual physical components to execute in a holistic virtual execution environment.2 We have developed a synchronization strategy between the virtual machine andphysical component emulator, for tight integration of virtualized cyber and physical components. This approach is promising in enabling early development of cybercomponents of CPS and exploration of the synergy between cyber and physicalcomponents.The reminder of this paper is organized as follows. Section 2 reviews relatedwork. Section 3 introduces the background of this paper. Sections 4 and 5 presentthe design and implementation of our approach. Section 6 elaborates on case studieswe have conducted and discusses the experimental results. Section 7 concludes thepaper and discusses future work.2. Related Work2.1. CosimulationThe CPS concept transcends embedded systems and hybrid systems. Embeddedsystems research has been largely focused on hardware and software and, particularly, their interactions. Hybrid systems research has been largely focused on theinteractions between discrete and continuous domains. CPS research takes a comprehensive view of the whole system and, instead of focusing on a single semanticgap, it focuses on multiple semantic gaps simultaneously.134000532nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.In embedded systems research, closely related to CPS simulation is HWSWcosimulation. Cosimulation is lowcost and efficient in detecting shallow bugs.There has been much research59 on cosimulation that has led to industrial toolssuch as Seamless.10 For hybrid systems, continuous components are typically modeled with tools such as LabView,11 Mathematica,12 MatlabSimulink and Modelica.13 These tools are interfaced to the simulators for discrete components such asModelSim.14CPS cosimulation is based on HWSW cosimulation by utilizing the abovetools. The most closely related work is presented in Ref. 15, where a methodologyand an open toolset for the virtual prototyping of CPS were proposed. The focuswas on integration of tools while the synchronization issues and fidelity evaluationare not explicitly addressed. In Ref. 16, a comprehensive cosimulation platformfor CPS and examples showing the capabilities of the platform were presented. Thesimulation platform is built on Modelica and ns2 tools. Modelica is used to simulatesoftware and physical components. Software components are simulation models inhigh level. This makes it difficult for developers to observe and verify system onthe implementation level. In addition, there is no guarantee about the consistencybetween the simulation model and their implementation.2.2. Virtual machineThe other research closely related is the virtual machine. A virtual machine is asoftware implementation of a machine i.e., a computer that executes programslike a physical machine. The virtual machine research has been largely focusedon hardware and software and, particularly, their interactions, which lacks abilityto capture the physical dynamics. In Ref. 17, an approach to constructing a virtual platform by integrating hardware models in SystemC into the QEMU virtualmachine is proposed. It can be used to facilitate the codesign of hardware modelsand device drivers at the early stage of electronic system level design flow. In Ref. 18,DDT was proposed for testing closedsource binary device drivers against undesiredbehaviors. DDT combines virtualization with a specialized form of symbolic execution to thoroughly exercise tested drivers. However, CPS research requires takinga comprehensive view of the whole system of software hardware and physical.3. BackgroundIn this section, we introduce three related concepts QEMU, MatlabSimulink andsynchronous languages. We use QEMU as virtual machine in our implementation,and MatlabSimulink to simulate physical dynamics. Our integration of QEMUand MatlabSimulink is based on the synchronous language principle.3.1. QEMUQEMU is an open source system emulator and provides the flexibility of developing customized virtual machine environment. QEMU emulates several different134000542nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systemsprocessor architectures, such as x86, SPARC and ARM. It relies on dynamicbinary translation to achieve a reasonable speed. It also provides a set of virtualdevices, such as Industry Standard Architecture ISA devices, PCI devices andUSB devices. A virtual device is essentially a software implementation of a deviceintegrated into QEMU. The communication between the processor emulator andthe virtual device is done via registered callback functions for the correspondingmemory regions on the system bus.We illustrate the virtual device concept with the 16550A UART universal asynchronous receivertransmitter, an ISA device. As shown in Fig. 1, the virtual devicehas the following components ISA device state, as defined by 16550A UART, which keeps track of the state ofthe ISA device functions simulating basic behaviors of the device functions serial mm writeand serial mm read simulate how 16550A UART respond when the driverissues IO command function serial update irq simulates how 16550A UARTrespond when an interrupt is generated.Fig. 1. QEMU virtual device code structure.134000552nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.3.2. MatlabSimulinkPhysical components are often modeled using differential and integral calculus withcontinuous semantics. MatlabSimulink is a powerful numerical computing and simulation environment for multidomain dynamic systems, which enables effectivelysolving the differential and integral equations.Simulink supports extension via welldefined Sfunction systemfunctionsinterfaces. Sfunctions are written in Matlab, C, C, or Fortran. We illustrate theSfunction simulation flow as shown in Fig. 2. An Sfunction block flow includes asimulation loop. In each iteration of the simulation loop, Matlab first determines thenext sampling time, then calculates the output of the block, updates each discretevariable, and finally calculates the differential equations with suitable approximation solvers like RungeKutta and updates the output simultaneously.3.3. Synchronous languagesSynchronous languages such as Esterel19 and Lustre20 have been developed todescribe closeloop control systems. These systems interact continuously with theirenvironment in terms of a discrete sequence of reaction steps, at a speed imposedby the environment.21Execution of programs in synchronous languages follows instants of a globalclock. The operational semantics of these languages is defined by socalled microInitializeCalculate next sampling timeCompute the outputs of Sfunction blockUpdate discrete statesCompute the outputs of Sfunction blockTerminationCompute the Sfunction blocks derivativessolve differential  equations Minor time stepMajor time stepSimulation loopCompute the Sfunction blocks derivativesFig. 2. Sfunction simulation flow.134000562nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systemsand macro steps, where a macro step consists of finitely many micro steps. Macrosteps correspond with reaction steps of a control system, and micro steps correspondwith atomic actions. Variables of a synchronous program are synchronously updatedbetween macro steps, so that the execution of the micro steps of one macro step isdone in the same variable environment of their macro step.The synchronous language abstraction does not only lead to a convenient programming model for control systems as well as a simplified estimation of worstcasereaction times. It is also the key to a compositional formal semantics which is necessary for simulation and verification. Hence, synchronous languages lend themselvesto the development of embedded control systems.4. Design of CPS VirtualizationIn this section, we discuss the framework for CPS virtualization. CPS include notonly software and hardware components, but also physical components. The holisticvirtual execution environment is shown in Fig. 3.The virtual machine emulates the hardware components and provides a virtualplatform for executing the software controller. And we model physical componentswith differential equations and compute them with suitable approximation solversin the physical component emulator. Then we integrate the virtual machine and thephysical component emulator to virtualize the entire CPS. The software controllerexecutes on the virtual machine and, through it, interacts with the virtualizedphysical components. In what follows, we characterize the dynamic of the maincomponents in detail and discuss how their integration is handled.4.1. Cyber componentsCyber components include both software and hardware components. The virtualmachine emulates hardware components such as the processor, bus, and peripheralCPS virtual execution environmentCyberPhysical InterfaceVirtual PhysicalComponent ExecutablePhysical Component EmulatorPhysical ModelApplicationVirtual Machine...ISA devicePCI deviceLinux BSDX86 ARMSoftware ControllerVirtual Device Operating SystemWindowsFig. 3. Architecture of CPS virtualization.134000572nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.devices, etc. It supports execution of a fullfledged operating system such as Linuxand applicationspecific modules for a software controller. We maximize realismby running the software controller in the complete environment libraries, kernel,drivers, etc. Within a real software stack, the control program can readwrite files,sendreceive network packets or be preemptedblocked by the operating system. Wecapture all interactions of the software controller with its surrounding system, notjust with a simplified abstraction of that system. The software controller implementsthe desired sequences of actions according to the control algorithm. Figure 4 showsan example software controller.Software components represent sequences of causally related actions. This meansthe execution of software controller follows the sequence of events, whenever theseevents occur. We associate each statement in software with a temporal event. Wedefine the temporal event as a tuple n, t, where n  N is a natural number, andt  R is a realtime stamp. The tuple n, t identifies an ordered sequence numbern and a corresponding realtime instant t when the software actions are taken. Let as a partial function defined on the tuple n, t. So our time model of softwarecomponents has the form,  N  R  R.We also assume a lexical ordering on the tuple n, t n1, t1  n2, t2  t1 t2 t1  t2n1  n2. This allows software components to have a realtime stampat each action. At shown in Fig. 4, when initializing the controller, the softwarewill set a timer to invoke the control loop periodically. After that, the controllerwill wait to invoke the control loop. In the control loop, the controller first readssensor values from related channels line 5, read sensor event Estate, then calculatesoutputs according to the control algorithm, writes commands to relevant actuatorsline 15, write command event Ecomm and updates states in the end. Although weassociate a temporal event with each statement, we still do not know exact timet when the software actions are taken. Actually, the exact occurring time instantn, t of most software actions do not affect the whole system behavior. We focuson the sequence of actions n instead of exact occurring time instant t for theseevents. For the other temporal events such as Estate and Ecomm, we will associatewith exact realtime stamp t. We will discuss these in detail in Sec. 4.4.1.4.2. Physical componentsWe describe physical components evolving on a continuoustime basis, typically asa mathematical model. The mathematical model can be represented by a set offirstorder differential equations on a vectorvalued state. The most general statespace representation of a linear system with inputs, outputs and state variables iswritten in the following formxt  gxt, ut, tyt  fxt, ut, t,1134000582nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsFig. 4. Control software example.where xt  Rn, yt  Rm, ut  Rp and t  R are state, output, input vectorsand real time. The function, g  Rn Rp R  Rn and f  Rn Rp R  Rm arestate functions and output functions, respectively. The differential equations mustbe approximated by a solver. Take classical fourthorder RungeKutta method asan example. The fourthorder RungeKutta method is one member of the familyof RungeKutta methods which are iterative methods for the approximation ofsolutions of ordinary differential equations. For a stepsize h  0,xn  xn1 16hK1  2K2  2K3 K4, 2134000592nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.where xn is the approximation of xtn, and the value xn is determined by thevalue xn1 plus the weighted average of four increments, where each incrementis the product of the size of the interval, h, and an estimated slope specified byfunction g on the righthand side of the differential equation,K1  gxn1, tn1K2  gxn1 12hK1, utn1 12h, tn1 12hK3  gxn1 12hK2, utn1 12h, tn1 12hK4  gxn1  hK3, utn1  h, tn1  h.The solver provides samples of the continuous dynamics, and typically, to maintain adequate accuracy, must control the time steps between such samples. Forexample, in order to complete one step h, the solver will evaluate the function g atthe intermediate time tn1  12h.4.3. Cyberphysical interfaceCyber components and physical components are mostly asynchronous and onlytransition synchronously when they interact through the cyberphysical interface.The interface is determined by the cyber and physical components that it connects. This enables more flexible composition of cyber and physical componentsand creation of composite components including both cyber and physical subcomponents. A cyberphysical interface has two parts interface states and interfaceevents. Interface states, Ip, Ic, are state variables provided either by cyber orphysical and accessible by both. Interface events have two types cyber or physical. When cyber updates the physical interface states, a cyber interface eventoccurs such as when entry stack symbol of dscDAConvert is reached, and viceversa.We illustrate the concept of cyberphysical interface with an example as shownin Fig. 5. The interface is derived from the interfaces of software controller andphysical components. The specification of the interface defines What variables in cyber components are mapped to input vectors in physicalcomponents, for instance, the pos counts variable is mapped to the input vectorsut at time ti  d in physical components line 7 What output vectors in physical components are mapped to variables in cybercomponents, for instance, the output vectors, yt at time ti, is mapped to thevariable dscadscan.sample values line 10 What is sensor noise characterization in control system, such as mean and variance of the sensor signal line 13.1340005102nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsFig. 5. A cyberphysical interface example.4.4. Synchronization of cyber and physical component emulatorsAs already mentioned, physical components in CPS operate in a time continuum,whereas cyber components are composed of discrete, stepbystep actions. Theirinteraction has to be faithfully modeled to achieve highfidelity virtualization.4.4.1. Timing parameters of a control taskAccording to the analysis in Secs. 4.1 and 4.2, we can see that the approximation solver for physical components operates similarly to the virtual machine forcyber components. While the virtual machine uses an event queue to determinethe advancement of time for software controller, the physical emulator consults anapproximation solver for physical components. It is critical to place discrete controller and continuous physical behavior on a unified temporal semantic basis whereit can be proven that the results of simulation are mutually consistent.We assume the system must react to a stimuli from the environment within hardtime bounds. That is, we associate with a fixed constant time between synchronization events. Building on the synchronous language principles, the execution of sucha system is a discrete sequence of reaction steps following a unified temporal semantic basis. In each macro step, new inputs are read and corresponding outputs andnext states of the system are computed. At each micro step, interface states must besynchronously updated when interface events occur. Otherwise, cyber componentsand its controlled physical components execute asynchronously in correspondingemulators. The basic timing parameters of a control task are shown in Fig. 6.Assume that the control task is executed periodically at times given by tk T  k, where T is the fixed sampling interval of the controller and k is the number of controller iterations. Also assume time bound d for the fixed interval fromAD conversion to DA conversion. There are two types of synchronization temporal events read sensor event Estate and write command event Ecomm. We definethese temporal events Estate and Ecomm as n1, tci and n2, tci  d, respectively.1340005112nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.SynchronizationClockComputing ClockPhysical ClocktcitpiEcommEstatetcidLegendInstance of instantvtci1ti ti1tidtpi1temporal event instantODE solver time stepTdtpidFig. 6. Timing analysis of control task.The time n1, tci is earlier than n2, tci  d. The AD conversion is started bythe controller when the entry stack symbol of dscADScan is reached see Fig. 4,line 5 at tci triggering Estate. Meanwhile, the states of physical components attpi are sampled by the controller. The controller gets the state data and executesthe control logic. When the entry stack symbol of dscDAConvert is reached seeFig. 4, line 15, the control task will send the control command at tcid triggeringEcomm. Simultaneously, the physical components are controlled at ttpid. According to the causal dependencies in the control loop, we abstract the essential instantstci, tci  d, tci1 on the computing clock and tpi, tpi  d, tpi1 on the physicalclock. According to the way how the control task is executed, the time stampstci, tci d, tci1 and tpi, tpi d, tpi1 occur pairwise simultaneously. Therefore,we unify these instants on a synchronization clock and identify them as synchronization instants ti, ti  d, ti1 shown in the bottom horizontal axis of Fig. 6.Synchronization events are then triggered in the emulators on these instants.4.4.2. Synchronization protocolThe holistic simulation is based on the interaction of the virtual machine and thephysical component emulator. A single control iteration in the simulation begins atthe point the physical components state is sensed and ends after the plant evolvesfor a sampling period based on the controllers actions. As shown in Fig. 7, wedesign the synchronization protocol as followsi Start the virtual machine and physical component emulator at t0ii the scheduler of physical component emulator triggers the earliest future eventat time ti i  0, 1, 2, 3, . . .. The physical component state at ti is sent to thevirtual machineiii the physical component emulator and the virtual machine will then run asynchronously until ti  da The physical component emulator executes with the latest command untilti  d. Then it pauses at ti  d, waiting for the new command1340005122nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systemstnt2Time Time...Send physical state at t1 Physicalt0t12.1 Execute the control algorithm with physical state at t0 2. Process differential equations with the latest command C0Cyber...2.2 Send command C1 1. Send physical state at t0 Start3. Process differential equations with the new command C1 Control loop interval t0d3. Execute the control algorithmFig. 7. Synchronization protocol between cyber and physical.b meanwhile, the virtual machine receives the state data at the time ti,executes the control algorithm, and pauses at the time ti  d, where itsends the new command to the physical component emulator.iv Then the physical component emulator and the virtual machine will run asynchronously during the time interval ti  d, ti1a The physical component emulator will process differential equations fromti  d to ti1 with the new commandb meanwhile, the virtual machine will execute the control algorithm to timeti1 and pause there waiting for receiving the physical component stateat ti1.v Repeat steps ii, iii and iv until the end of simulation.The strategy will not miss any essential synchronization event between the virtual machine and physical component emulator. So our virtualization has the potential to achieve high fidelity efficiently.5. Implementation of CPS VirtualizationWe chose QEMU 1.0 as the virtual machine and Matlab 7.13 as the physical component emulator. Inputs of our virtualization include the source code of the controller,1340005132nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.Virtual execution environmentSoftware executableOperating system SimulinkSFunctionQEMU Virtual physical executableSynchronization MatlabVirtual deviceSource code Physical modelInput1.State data  MatlabQEMU2.Command data  QEMUMatlabCyberPhysical interfaceServerFig. 8. Implementation of virtual execution environment.the cyberphysical interface design, and the mathematical models of the physical.Then we instrument the source code and the physical mathematical model based onthe cyberphysical interface. Once model instrumentation is done, we can run thesoftware controller and the physical model in our virtual execution environment.Figure 8 shows the implementation of the CPS Virtualization.We instrument the source code based on the cyberphysical interface and rewritedscADScan and dscDAConvert functions. We compile the source code of the software controller to execute in QEMU. QEMU and MatlabSimulink communicatethrough a socket. QEMU run as a client to communicate with a server that employsMatlab as a computation engine. The Matlab engine provides a library of functionsthat allows the server to start and end a Matlab process and send commands to beprocessed in Matlab. The physical components are modeled in Simulink and set upby the Matlab engine. The communication block in Simulink is represented by anSfunction. The Sfunction, which we generate based on the cyberphysical interface, sends physical state data to or receives cyber commands from the server viashared memory. MatlabSimulink executes all blocks in the Simulink model at eachsampling step. During each step, the Sfunction block is executed to communicatewith QEMU.6. EvaluationIn this section, we report two experiments applying our approach to realworldcontrol systems TableSat22,23 and Automatic Transmission Controller.4 Throughthe first experiment, we show how the virtualization can be used as a platformto develop controllers by comparing results from the real and virtual TableSat.1340005142nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsThe second experiment is from an automotive application in Simulink. Throughthe second experiment, we show how our approach can achieve higher fidelity thanSimulinkStateflow. All experiments were performed on a machine with 2.93GHzIntelR Xeon and 8G memory.6.1. TableSatTableSat shown in Fig. 9 is an interactive platform from the University of Michigan, which emulates in one degreeoffreedom the dynamics, sensing, and actuationcapabilities required for satellite attitude control. We have obtained the TableSatvia collaboration and rebuilt it to suit our needs.TableSat is driven by two computer fans and spin down by the friction. Itcontains a highprecision rate gyro, Silicon Ring Gyro CRS03, to measure angular velocity. An onboard Diamond Systems Athena II SBC computer running theDebian operating system communicates to a ground station via a wireless 802.11binterface. The computer interfaces to sensors through 16bit analogtodigital converters and to actuators through amplified 12bit digitaltoanalog channels. Thecyber component gathers the angular velocity from the gyroscope sensor. Thenbased on the gyro data, the control algorithm calculates suitable voltage which isapplied to the fan to change the motion of TableSat. The controller relies only onthe gyroscope sensor to stabilize the TableSat motion.6.1.1. TableSat virtualizationWe have developed a virtual execution environment for TableSat, which is illustrated in Fig. 10. We utilize the X86 processor model to emulate the Athena II SBCFig. 9. TableSat.1340005152nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.vvControllerGyro  Fan Data StoreRate GyroTableSat motionEstimator ActuatorQEMUMatlabVirtual execution environment Real environmentMotorsVirtual deviceIPCSFunctionFig. 10. TableSat virtualization.in QEMU. The software controller is implemented in the C language. The physicalcomponents include TableSat dynamics, friction, fans and sensor. They are modeledmathematically according to respective physical characteristics in MatlabSimulink.The equations of TableSat motion areI  lKfv1  v2 fTS, 3v1  v1 KvV1  ffan1v1, 4v2  v2 KvV2  ffan2v2, 5where I is the TableSat moment of inertia,  is the TableSat angular velocity, v1 isthe speed of the fan1, v2 is the speed of the fan2, l is the fan moment arm, fTS isthe TableSat friction and is a function of , Kf is the fan speed to force constant,V1 is the voltage applied to the fan1, V2 is the voltage applied to the fan2,  is thefan time constant, Kv is the fan voltage to change in speed constant, and ffan1and ffan2 are the frictions in the fans and are functions of v1 and v2, respectively.We simulate the physical dynamics in MatlabSimulink as shown in Fig. 11.There are three blocks Communication, TableSat and Gyro Noise. Matlab communicates with the external environment through an Sfunction named Communication sends the angular velocity to the external environment and receives voltagecommands. The Sfunction named TableSat computes the Tablesat rotary TableSat motion, Rate Gyro and Motors, as described in Eqs. 35. The randomblock named Gyro Noise models the sensor noise characterization. The noise characterization of gyro signal is that Mean  0.0025, Variance  0.1936. The twoblocks work together to generate the final angular velocity data.1340005162nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsTableSatPhysical modelGyro noiseCommunicationCommunication with QEMUAddVoltageomegaFig. 11. Physical model in Simulink.6.1.2. Experiment resultIn this experiment, the angular velocity of the TableSat is controlled by manipulating voltage applied to the fan. The overall design requirements are Rise time the time required for the response to rise from 10 to 90 of its finalvalue under 10 s Peak overshoot ratio the ratio of the first highest peak value reached by theresponse to the desired value below 0.4 Steadystate error the difference between the desired final output and the actualone when the system reaches a steady state below 5s Settling time the time required for the response curve to reach and stay withina steadystate error band under 15 s.We have developed a Proportional Integral Derivative PID controller andtested it in the holistic virtual execution environment. The final discretization ofthe PID algorithm is an incremental formut  ut ut 1 Kp1  TsTi  TdTset Kp1 2TdTset 1 KpTdTset 2 Aet Bet 1  Cet 2, 6where u is the control inputs, e is the error between the measured value and desiredvalue, Kp is the proportional gain, Ti is the integral time, Td is the derivative time,Ts is the sampling time, t is the instantaneous time, A  Kp1  TsTi  TdTs,B  Kp1 2TdTs, C  KpTdTs.To evaluate the PID controller, we conducted tests for a series of step inputof expected angular velocity. In the virtual TableSat, we set the fixed samplinginterval T  0.2s and the fixed interval from AD conversion to DA conversiond  0.1s. As shown in Fig. 12, we run the controller eight times. Input of expected1340005172nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.0 20 40 60 80 100100102030405060708090Time secAngular Velocity degsecRun 10Run 20Run 30Run 40Run 50Run 60Run 70Run 80Fig. 12. TableSat test results gathered in virtual environment.angular velocity from 10s to 80s Run 10 10s, Run 20 20s, Run 30 30s,Run 40 40s, Run 50 50s, Run 60 60s, Run 70 70s, Run 80 80s. Thecurves of angular velocity, given the expected angular velocities, show that withincreasing voltage there is an initial step rise to a maximum value followed by afall to a first minimum value and then stabilization on the expected value. All theangular velocity response of TableSat shows that its control properties meet thedesign requirement.The designed controller is then tested on the real TableSat system. In the realTableSat, we use a timer 0.2 s to wake up the software periodically. Figure 13shows results gathered from the real TableSat. Comparing Fig. 12 with Fig. 13, wecan see the characters of angular velocity curves are closely matched.Before quantifying the divergence between the real TableSat and its virtualization, we first define an evaluation metric, absolute divergence, which is the difference between the actual velocity and expected ideal velocity. We can calculate thisdivergence by measuring the difference between the actual velocity and the idealvelocity. Table 1 shows statistics of absolute divergence over eight runs. Each rowin the table shows statistics of a system run. We recorded the angular velocity atevery 0.5 s. The average absolute divergence over all time instant is relatively lowand below 2.4s. All the maximum absolute divergence values occur in the firsttwo 2 s. The main reason is precision of TableSat static friction measurement. Thestatic friction in TableSat is represented by the voltage magnitude, applied to the1340005182nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systems0 20 40 60 80 100100102030405060708090Time secAngular Velocity degsecRun 10Run 20Run 30Run 40Run 50Run 60Run 70Run 80Fig. 13. TableSat test results gathered in real environment.Table 1. Summary of absolute divergence.Max Min Mean Stds s s sRun 10 3.637 10.84 1 2.069Run 20 3.788 13.88 1.115 2.424Run 30 2.702 16.38 1.429 2.514Run 40 4.219 12.22 1.177 2.376Run 50 2.738 8.529 1.105 2.132Run 60 4.792 19.44 1.528 3.478Run 70 3.847 19.39 1.818 3.864Run 80 2.352 27.44 2.356 5.004fans, below which TableSat will not move. The power supply may change frequentlydue to physical or mechanical causes such as battery level. The precision of staticfriction will influence initial motion of TableSat.We evaluate the time usages of the simulation shown in Fig. 14. We set thefixed interval T  2 s and d  1 s. Comparing the virtualized time with the simulation time used, the results show a nonlinear relationship between the virtualized1340005192nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.15 20 25 30 35 40 45101102103104Simulation Time secVirtualized Time secFig. 14. Summary of time utilizations.time and simulation time used. It spends most time on starting Matlab engine andinitializing the Simulink model. After the initialization, the growth of simulationtime tends to slow as the virtualized time increases. Therefore, our approach isreasonably fast and efficient.The experiment shows that our virtual environment can simulate the real system with reasonable accuracy. This can enable development of software on thevirtualization before the real physical environment becomes available.6.2. Automatic transmission controllerThe second experiment is on an automatic transmission model given as a samplein the Simulink package. The automatic transmission adjusts gear ratios as thevehicle moves. The gear shift controller performs the function of gear selectionin the automatic transmission. The model describes the control of a fourspeedautomatic transmission. Figure 15 illustrates the physical model of the automatictransmission.In the automatic transmission model, Engine block, Transmission block andVehicle block model the engine, fourspeed automatic transmission, and vehicle,respectively. The communication block in this model enables physical componentsto communicate with QEMU. Engine block interpolates engine torque ImprellerTorque, versus throttle Throttle and engine speed EngineRPM. The TorqueConverter and the Transmission Ratio subsystems make up the Transmission block.1340005202nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsVehicleNeGearNoutTiToutTransmissionPlotResultsThrottleBrakeManeuversGUITiThrottleNeEngineCommunicationCommunicate with QEMUImprellerTorqueEngineRPMEngineRPMOutputTorqueTransmissionRPMVehicleSpeedVehicleSpeedThrottleThrottle BrakeTorqueFig. 15. Automatic transmission physical model in Simulink.The transmission model first calculates the turbine speed based on the engine speed,and then outputs torque OutputTorque to the vehicle via the static gear ratio.The Vehicle block uses the torque OutputTorque to compute the acceleration andintegrates it to compute the vehicle speed VehicleSpeed. User inputs to the modelare in the form of throttle and brake torque. There are four maneuvers passingmaneuver, gradual acceleration, hard braking and coasting. Each maneuver hasdifferent throttle and brake torque schedule.We carry out a series of controller tests on both virtualization andSimulinkStateflow simulation. In the original model, the Stateflow block labeledShift Logic implements gear selection for the transmission. The model takes throttleand vehicle speed as the inputs and the desired gear number as the output. Thecontroller selects a gear based on the input throttle values and computes based ontable lookups. The selected gear is used to look up a Boolean value for each ofthe output clutch pressure. The overall Stateflow block is executed as a discretetime system, sampled every 40ms. In our virtualization, controller source code wasgenerated from the Stateflow block automatically by Simulink Coder.4 Then weport the control software into QEMU. We set the fixed interval T  0.04 s andd  0.02 s.We summarize the statistics of error between the output from the virtualization and that from the SimulinkStateflow simulation see Table 2. We use absolute divergence, the deviation of the SimulinkStateflow simulation value from thevirtualization value, to define the error. Each column in the subtable Maneuvershows error statistics of a system simulation run for a maneuver. For instance,the last column shows the error statistics of Throttle, EngineRPM, VehicleSpeed,1340005212nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.Table 2. Summary of error statistics.Type ManeuverPassing maneuver Gradual acceleration Hard braking CoastingThrottle degreemax 0 0 0 0min 0 0 0 0mean 0 0 0 0std 0 0 0 0EngineRPM RPMmax 480.9 0.7287 1.561 351.4min 989.1 106.7 251.2 689.1mean 3.333 0.4703 1.388 6.425std 49.83 5.746 12.44 48.45VehicleSpeed mphmax 0.3192 0.05764 0.2032 0.5237min 0.1662 0 0.04715 0.3215mean 0.01688 0.006017 0.03145 0.07979std 0.03248 0.007769 0.01972 0.04198Gearmax 1 1 1 1min 1 1 1 1mean 0 0 0.002663 0.003995std 0.07303 0.05164 0.07298 0.08155ImprellerTorque ftlbmax 445.8 24.21 185.8 578.6min 503.3 25.2 81.59 323.7mean 0.5863 0.09836 0.1297 0.4167std 30.72 1.507 7.949 31.13OutputTorque ftlbmax 519.5 111.4 356.4 1135min 544.3 41.98 219 825.5mean 0.7031 0.08794 0.1985 0.3177std 35.21 4.853 16.84 56.24Note Gears 1, 2, 3, or 4.Gear, ImprellerTorque, OutputTorque in the coasting maneuver. We record theseerrors between the output produced with our tool and that produced using theSimulinkStateflow not only for the response engine speed and vehicle speed butalso for the other values Throttle, Gear, ImprellerTorque and OutputTorque. Wecarry out tests in four different maneuvers and find errors in all recorded variablesexcept for Throttle. After analysis, we find these errors are all caused by gear selection. Here we choose the test generated in coasting maneuver to discuss these errorsin detail. We recorded these variables at every 0.04 s.The curves shown in Fig. 16 are composed of the gear selections gathered fromthe virtualization and the SimulinkStateflow simulation, for controlling the throttleand brake torque in the coasting maneuver. There are three times of gear upshift inthis maneuver. We indeed found the errors that occur only for few points during gear1340005222nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical Systems0 5 10 15 20 25 3000.511.522.533.544.55Time secGearSimulinkStateflowvirtualizationgear selection errorFig. 16. Gear selection error between virtualization and SimulinkStateflow simulation.Table 3. Time of gear selection in the virtualization and the SimulinkStateflow.2.28 s 2.32 s 2.36 s 4.88 s 4.92 s 4.96 s 5.00 s 5.04 s 5.08 sGear selection 1 1 2 2 2 3 3 4 4 4Gear selection 2 1 1 2 2 2 3 3 3 4Note Gear selection 1 and gear selection 2 are gathered in the virtualization andSimulinkStateflow, respectively. Gears 1, 2, 3, or 4.upshift. Table 3 shows different times of gear upshift. We can find the controller invirtualization performs gear selection with an earlier trigger time, when the vehicletransmission needs gear upshift. For example, the gear upshift from gear 1 to gear 2occurs at 2.32 s in virtualization, whereas in SimulinkStateflow the time is 2.36 s.In the virtualization environment, the physical components will be controlled bythe current command until the DA conversion finished tci, tci  d and thenevolves with new command in the rest of reactive interval tci  d, tci1. But inthe SimulinkStateflow environment, it will be controlled by the current commanduntil next reactive interval tci, tci1. Therefore, the error occurs during the timetci  d, tci1. In addition, the initial value of gear in SimulinkStateflow is 1,where the initial value is 0 in the source code. These will ultimately cause deviationof vehicle speed see Fig. 17. The curve shown in Fig. 17 represents the absolutedivergence of vehicle speed. The error of vehicle speed has always existed even it1340005232nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.0 5 10 15 20 25 300.40.30.20.100.10.20.30.40.50.6Time secError of VehicleSpeed mphFig. 17. Vehicle speed error between virtualization and SimulinkStateflow Simulation.is quite small. And the error increases sharply during gear upshift. Therefore, weconclude that our virtual environment can achieve higher fidelity than SimulinkStateflow.7. ConclusionsThis paper proposes a highfidelity approach to CPS virtualization. Our approachextends virtual machines and incorporates the ability to emulate physical components. We have developed a synchronization strategy to integrate two differentdomains cyber and physical. We have evaluated our approach on the realworldcontrol systems. The experiments and evaluations demonstrate that our approachis effective the comprehensive virtualization environment can capture the dynamicbehaviors of the system in highfidelity, and efficient the costs of simulation arelow. Our approach is promising in enabling early development of cyber componentsand early exploration of the synergy of cyber and physical components of CPS.Formal coverification has the potential for exhaustive state space coverage of awhole system. Thus, it is desired to integrate formal verification and virtualization,so that highconfidence achieved by formal verification and practicality supportedby virtualization can be properly leveraged for system validation. The virtualization technique presented in this paper is a preliminary step towards this direction.We will extend the CPS virtualization environment and further investigate theintegration of virtualization and formal verification under this common framework.1340005242nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005High Fidelity Virtualization of CyberPhysical SystemsAcknowledgmentsThis research received financial support from the National Science Foundation of theUnited States Grant  0720546 and Grant  0916968, the National HighTechResearch and Development Plan of China Grant  2011AA010105 and Grant 2011AA010102, and the National Infrastructure Software Plan of China Grant 2012ZX01041002003.References1. Lee E. A., Cps foundations, Proc. 47th Design Automation Conf. DAC , Anaheim,CA, ACM, June, pp. 737742, 2010.2. Nelson S., Waskiewicz P. J., Virtualization, Writing and testing device drivers without hardware, Linux Plumbers Conf., Santa Rasa, CA, August, 2011.3. Bellard F., Qemu, a fast and portable dynamic translator, Proc. Annu. Conf. USENIXAnnu. Tech. Conf., ATEC 05, Anaheim, CA, USENIX Association, Berkeley, CA,USA, pp. 4146, 2005.4. MathWorks, Matlabsimulink, httpwww.mathworks.com.5. Becker D., Singh R., Tell S., An engineering environment for hardwaresoftwarecosimulation, Design Automation Conf. 1992. Proc., 29th ACMIEEE, June,pp. 129134, 1992.6. Eker J., Janneck J., Lee E. A., Liu J., Liu X., Ludvig J., Sachs S., Xiong Y., Neuendorffer S., Taming heterogeneity  the ptolemy approach, Proc. IEEE 911127144,2003.7. Hoffmann A., Kogel T., Meyr H., A framework for fast hardwaresoftware cosimulation, Design, Automation and Test in Europe, 2001, Conference and Exhibition2001, Proc., Munich, ACM, pp. 760764, 2001.8. Semeria L., Ghosh A., Methodology for hardwaresoftware coverification in cc,Design Automation Conf., 2000. Proc. ASPDAC 2000. Asia and South Pacific, Yokohama, Japan, ACM, June, pp. 405408, 2000.9. Passerone C., Lavagno L., Chiodo M., SangiovanniVincentelli A., Fast hardwaresoftware cosimulation for virtual prototyping and tradeoff analysis, Proc. 34thAnnual Design Automation Conf., DAC 97, Anaheim, CA, ACM, New York, NY,pp. 389394, 1997.10. Mentor graphics, Seamless, httpwww.mentor.com.11. National instruments, Labview, httpwww.ni.comlabview.12. Wolfram research, Mathematica, httpwww.wolfram.com.13. Modelica association, Modelica, httpsmodelica.org.14. Mentor graphics, Modelsim, httpwww.model.com.15. Mueller W., Becker M., Elfeky A., DiPasquale A., Virtual prototyping of cyberphysical systems, Design Automation Conf. ASPDAC , 2012 17th Asia and SouthPacific, Sydney, ACM, February, pp. 219226, 2012.16. AlHammouri A. T., A comprehensive cosimulation platform for cyberphysical systems, Comput. Commun. 361819, 2012.17. Yeh T.C., Chiang M.C., On the interfacing between qemu and systemc for virtualplatform construction Using dma as a case, J. Syst. Archit. 583499111, 2012.18. Kuznetsov G. C. V., Vitaly Chipounov, Testing closedsource binary device driverswith ddt, USENIX Annual Technical Conf. USENIX , Boston, MA, pp. 159172,June, 2010.1340005252nd ReadingJune 14, 2013 178 WSPC262IJMSSCS17939623 1340005Y. Zhang et al.19. Benveniste A., Caspi P., Edwards S., Halbwachs N., Le Guernic P., de Simone R.,The synchronous languages 12 years later, Proc. IEEE 9116483, 2003.20. Halbwachs N., Caspi P., Raymond P., Pilaud D., The synchronous data flow programming language lustre, Proc. IEEE 79913051320, 1991.21. Bauer K., A New Modelling Language for CyberPhysical Systems, Ph.D. Thesis,Technical University of Kaiserslautern, Germany, 2012.22. Vess M. F., System modeling and controller design for a single degree of freedomspacecraft simulator, Masters Thesis, University of Maryland, USA, 2005.23. Atkins E., Green J., Yi J., Woo H., Browne J., Mok A., Xie F., The tablesat platformand its verifiable control software, American Institute of Aeronautics and Astronautics, Seattle, USA, 2009.134000526
