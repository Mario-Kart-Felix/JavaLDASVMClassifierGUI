Avatar A Framework to Support Dynamic SecurityAnalysis of Embedded Systems FirmwaresJonas Zaddach, Luca Bruno, Aurelien Francillon, Davide BalzarottiEURECOM, Francezaddach,bruno,francillon,balzarottieurecom.frAbstractTo address the growing concerns about the securityof embedded systems, it is important to perform accurate analysisof firmware binaries, even when the source code or the hardwaredocumentation are not available. However, research in this fieldis hindered by the lack of dedicated tools. For example, dynamicanalysis is one of the main foundations of security analysis, e.g.,through dynamic taint tracing or symbolic execution. Unlikestatic analysis, dynamic analysis relies on the ability to executesoftware in a controlled environment, often an instrumentedemulator. However, emulating firmwares of embedded devicesrequires accurate models of all hardware components used by thesystem under analysis. Unfortunately, the lack of documentationand the large variety of hardware on the market make thisapproach infeasible in practice.In this paper we present Avatar, a framework that enablescomplex dynamic analysis of embedded devices by orchestratingthe execution of an emulator together with the real hardware. Wefirst introduce the basic mechanism to forward IO accesses fromthe emulator to the embedded device, and then describe severaltechniques to improve the systems performance by dynamicallyoptimizing the distribution of code and data between the twoenvironments. Finally, we evaluate our tool by applying it tothree different security scenarios, including reverse engineering,vulnerability discovery and hardcoded backdoor detection. Toshow the flexibility of Avatar, we perform this analysis on threecompletely different devices a GSM feature phone, a hard diskbootloader, and a wireless sensor node.I. INTRODUCTIONAn embedded system consists of a number of interdependent hardware and software components, often designed tointeract with a specific environment e.g., a car, a peacemaker,a television, or an industrial control system. Those components are often based on basic blocks, such as CPUs andbus controllers, which are integrated into a complete customsystem. When produced in large quantities, such customizationresults in a considerable cost reduction. For large quantities,custom built integrated circuits ASIC are preferred as theyallow to tailor functionality according to the specific needs,which results in cost reduction, better integration, and areduction of the total number of parts. Such chips, also calledSystem on a Chip SoC, are often built from a standard CPUcore to which both standard and custom hardware blocks areadded. Standard blocks, commonly called IP Cores, are oftenin the form of a single component that can be integratedinto a more complex design e.g., memory controllers orstandard peripherals. On the other hand, custom hardwareblocks are often developed for a specific purpose, device,and manufacturer. For example, a mobile phone modem maycontain a custom voice processing DSP, an accelerator for theGSM proprietary hardware cryptography A5 algorithms andan offtheshelf USB controller.Over the years, such SoCs have significantly grown incomplexity. Nowadays, they often include Multiple ProcessorsMPSoC and complex, custom, hardware devices. As a consequence, virtually every embedded system relies on a different,application specific, system configuration. As a witness of thisphenomenon, the website of ARM Ltd., which provides oneof the most common CPU core used in embedded systems,lists about 200 silicon partners1. Most of those partners areproducing several product families of SoCs relying on ARMcores. This leads to a huge number of systems on the market,which are all different, but all rely on the same CPU corefamily.Unfortunately, the increasing pervasiveness and connectivity of embedded devices significantly increased their exposureto attacks and misuses. Such systems are often designedwithout security in mind. Moreover visible features, low timeto market, and reduction of costs are the common drivingforces of their engineering teams. As a consequence, anincrease in the number of reports of embedded systems exploitation has been recently observed, often with very seriousconsequences 8, 11, 12, 19, 23, 25, 44, 46, 54,60. To make things worse, such systems frequently play animportant role in securityrelevant scenarios they are often partof safety critical systems, integrated in home networks, or theyare responsible to handle personal user information. Therefore,it is very important to develop the tools and techniquesthat would make easier to analyze the security of embeddedsystems.In the traditional IT world, dynamic analysis systems play acrucial role in many security activities  ranging from malwareanalysis and reverse engineering, to vulnerability discovery andincident handling. Unfortunately, there is not an equivalentin the embedded system world. If an attacker compromisesthe firmware of a device e.g., a smart meter or a PLC in aStuxnetlike attack scenario 25 even vendors often do nothave the required tools to dynamically analyze the behavior ofthe malicious code.Dynamic analysis allows users to overcome many limitations of static analysis e.g., packed or obfuscated code and toperform a wide range of more sophisticated examinations 24 including taint propagation 33, 55, symbolic and concolicexecution 10, 15, 22, unpacking 34, malware sandboxing 1, 5, and whitebox fuzzing 28, 29.Unfortunately, all these techniques and their benefits arestill not available in the world of embedded systems. Thereason is that in the majority of the cases they require an1httpwww.arm.comcommunitypartnerssilicon.phpemulator to execute the code and possibly monitor or alter itsexecution. However, as we will explain in Section II, the largenumber of custom and proprietary hardware components makethe task of building an accurate emulator a daunting process. Ifwe then consider that additional modules and hardware pluginsshould be developed for each embedded system on the market,we can easily understand the infeasibility of this approach.In this paper, we present a technique to fill this gap andovercome the limitation of pure firmware emulation. Our tool,named Avatar, acts as an orchestration engine between thephysical device and an external emulator. By injecting a specialsoftware proxy in the embedded device, Avatar can execute thefirmware instructions inside the emulator while channeling theIO operations to the physical hardware. Since it is infeasible toperfectly emulate an entire embedded system and it is currentlyimpossible to perform advanced dynamic analysis by runningcode on the device itself, Avatar takes a hybrid approach.It leverages the real hardware to handle IO operations, butextracts the firmware code from the embedded device andemulates it on an external machine.To summarize, in this paper we make the following contributions We present the design and implementation of Avatar,a novel dynamic analysis framework that allows a userto emulate the firmware of an embedded device. We discuss several techniques that can be used tooptimize the performance of the system and to adaptAvatar to the users needs. We also show how complex dynamic analysis applications such as concolicexecution can be implemented on top of Avatar. We evaluate Avatar by applying it to three differentsecurity scenarios, including reverse engineering, vulnerability discovery, and backdoor detection. To showthe flexibility of our system, each test was performedon a completely different class of devices.II. DYNAMIC FIRMWARE ANALYSISWhile the security analysis of firmwares of embeddeddevices is still a new and emerging field, several techniqueshave been proposed in the past to support the debugging andtroubleshooting of embedded systems.Hardware debugging features mostly built around InCircuit Emulators 13, 35, 42 and JTAGbased hardwaredebuggers 3 are nowadays included in many embeddeddevices to simplify the debugging procedure. However, theanalysis remains extremely challenging and often requires dedicated hardware and a profound knowledge of the system undertest. Several debugging interfaces exist, like the BackgroundDebug Mode BDM 58 and the ARM CoreSight debug andtrace technology 58. Architectureindependent standards fordebugging embedded devices also exist, such as the IEEENEXUS standard 4. Most of these technologies allow the userto access, copy, and manipulate the state of the memory andof the CPU core, to insert breakpoints, to single step throughthe code, and to collect instructions or data traces.When available, hardware debugging interfaces can be usedto perform certain types of dynamic analysis. However, theyare often limited in their functionalities and do not allow theuser to perform complex operations, such as taint propagation or symbolic execution. In fact, these advanced dynamicanalysis techniques require an instruction set simulator tointerpret the firmware of the embedded target. But for a properemulation of the embedded system, not only the CPU, butall peripheral devices need to be emulated. Without such asupport, the emulated firmware would often hang, crash, orin the best case, show a different behavior than on the realhardware. Such deviations can be due, for example, to incorrectmemory mappings, active polling on a value that should bechanged by the hardware, or the lack of the proper hardwaregenerated interrupts or DMA operations.To overcome these problems, researchers and engineershave resolved to three classes of solutions, each with its ownlimitations and drawbacks Complete Hardware EmulationChipounov 14 and Kuznetsov et al. 37 analyzedevice drivers by relying on an emulated PCI busand network card that return symbolic values. Thisapproach has the main drawback that it requires toemulate the device properly. While this is not muchof a problem for well understood devices, like a PCInetwork card supported by most PC emulation software, it can be a real challenge in embedded systemsand can be just impossible when the hardware is notdocumented. Unfortunately, lack of documentation isthe rule in the embedded world, especially in complexproprietary SoCs.In some cases, accurate system emulators are developed as part of the product development to allow thefirmware development team to develop software whilethe final hardware is still not available. However, thoseemulators are usually unavailable outside the development team and they are often not designed for codeinstrumentation, making them unable to perform basicsecurity analysis like tainting or symbolic execution. Hardware OverApproximationAnother approach consists in using a generic, approximated, model of the hardware. For example, byassuming interrupts can happen at any time or thatreading an IO port can return any value. This approachis easy to implement because it does not requirea deep knowledge of the real hardware, but it canclearly lead to false positives, e.g., values that willnever be returned by the real system or misbehaviorof the emulated code when a particular value isrequired. This approach is commonly used when analyzing small systems and programs that are typicallylimited to a few hundreds lines of code, as showedby Schlich 49 and Davidson et al. 22. However,on larger programs and on complex peripherals thisapproach will invariably lead to a state explosion thatwill prevent any useful analysis.2 Firmware AdaptationAnother approach consists in adapting the firmwareor in extracting limited parts of its code in orderto emulate it in a generic emulator. While this ispossible in some specific cases, for example withLinuxbased embedded devices, this technique doesnot allow for an holistic analysis and may still belimited by the presence of custom peripherals. Moreover, this approach is not possible for monolithicfirmwares that cannot be easily split into independentparts  unfortunately a very common case in lowendembedded systems 20.In the next section we present our novel hybrid techniquebased on a combination of the actual hardware with a genericCPU emulator. Our approach allows to perform advanceddynamic analysis of embedded systems, even when very littleinformation is available on their firmware and hardware, orwhen basic hardware debugging support is not available. Thisopens the possibility to analyze a large corpus of devices onwhich dynamic analysis was not possible before.III. AVATARAvatar2 is an eventbased arbitration framework that orchestrates the communication between an emulator and a targetphysical device.Avatars goal is to enable complex dynamic analysis ofembedded firmware in order to assist in a wide range ofsecurityrelated activities including but not limited to reverse engineering, malware analysis, vulnerability discovery,vulnerability assessment, backtrace acquisition and rootcauseanalysis of known test cases.A. System ArchitectureThe architecture of the system is summarized in Figure 1the firmware code is executed inside a modified emulator,running on a traditional personal computer. Any IO access isthen intercepted and forwarded to the physical device, whilesignals and interrupts are collected on the device and injectedinto the emulator.The internal architecture is completely eventbased, allowing userdefined plugins to tap into the data stream and evenmodify the data as it flows between the emulator and the target.In the simplest case Avatar requires only a backend totalk to the emulator and one to talk to the target system,but more plugins can be added to automate, customize, andenhance the firmware analysis. In our prototype, we developeda single emulator backend. This controls S2E or SelectiveSymbolic Execution engine, which is an opensource platformfor selective symbolic execution of binary code 15. It buildson the foundation of Qemu, a very popular opensource systememulator 7. Qemu supports many processor families such asi386, x8664, Arm, Mips and many others. Apart from beinga processor emulator, Qemu can also mimic the behavior ofmany hardware devices that are typically attached to the centralprocessor, such as serial ports, network cards, displays, etc.2The Avatar framework is opensource and available athttps3.eurecom.frtoolsavatar.S2E leverages the intermediate binary code representationof Qemu called Tiny Code Generator TCG, and dynamicallytranslates from TCG bytecode to LowLevel Virtual MachineLLVM bytecode whenever symbolic execution is active 39.KLEE, the actual symbolic execution engine, is then takingcare of exploring the different execution paths and keeps trackof the path constraints for each symbolic value 10. Evaluatingpossible states exhaustively, for some symbolic input, can beassimilated to model checking and can lead to proving someproperty about a piece of software 38.Even though S2E uses the TCG representation of the binarycode to generate LLVM code, each processor architecture hasits own intricacies that make it necessary to write architecturespecific extensions to make S2E work with a new processorarchitecture. Since our focus was on embedded systems andall the systems we analyzed are ARM systems, we updatedand improved an existing incomplete ARM port3 of S2E, tosuit the needs of dynamic analysis of firmware binaries.To control the execution of code in more detail, S2E provides a powerful plugin interface that allows instrumentationof virtually every aspect of execution. Any emulation evente.g., translation of a basic block, instruction translation orexecution, memory accesses, processor exceptions can beintercepted by a plugin, which then can modify the executionstate according to its needs. This modular architecture letus perform dynamic analysis of firmware behaviour, suchas recording and sandboxing memory accesses, performinglive migration of subroutines see Section IIIC, symbolicallyexecuting specific portion of code as well as detecting vulnerabilities see Section V.S2E is connected through three different control interfaceswith Avatar the first interface is a GDB debug connectionusing the GDB serial protocol. Avatar is connecting to thisinterface using a GDB instance controlled via the GDBMIprotocol. This connection is used for finegrained control overthe execution, such as putting breakpoints, singlestepping theexecution, and inspecting register values. The second interfaceis Qemus Management Protocol QMP interface, a JSONbased requestresponse protocol. Though detailed virtual machine control is possible through this interface, it is currentlyonly used to dynamically change S2Es configuration at runtime. This is done by accessing S2E through its Lua interface,which is called from Lua code embedded in the JSON requests.The third interface is a plugin for S2E that is triggeredwhenever a memory access is performed. This S2E pluginthen forwards this request to Avatar, which in turn handles thememory access e.g., sends it to Avatars plugins, or forwardsit to the target.Even though at the moment the only available emulatorbackend is for QemuS2E, the emulator interface is genericand allows other emulators to be added easily.3Our patches have been submitted to the official S2E project and arecurrently under review for merging.3OpenOCDAvatarAnalysis scriptTargetbackendGDBadapterTelnetadapterBinProtoadapterGDBMIadapterEmulatorbackendMemoryforwarderQMPLuainterfaceGDBinterfaceConfigwriterEmulator RemoteMempluginSEQMPLuaQemuGDBQemuconfigTarget deviceInmemorystubTarget state Registers CPU state MemoryVM state Registers CPU state MemoryQemuexecuterQemufrontendLLVMSymbolicstatesKLEETCGJTAGUARTAnalysisPluginsSEhooksFig. 1 Overview of Avatar.On the target side, we developed three backends A backend that uses the GDB serial protocol tocommunicate with GDB servers e.g., a debugger stubinstalled on the device or a JTAG GDB server. A backend to support lowlevel access to theOpenOCDs JTAG debugging interface via a telnetlike protocol. A backend that talks to a custom Avatar debuggerproxy over an optimized binary protocol which ismore efficient than the verbose protocol used byGDB. This proxy can be installed in an embeddeddevice that lacks debugging hardware support e.g.,no hardware breakpoints or on which such supportwas permanently deactivated.The proper target backend has to be selected by the userbased on the characteristics and the debugging functionalitiesprovided by the hardware of the embedded device. For example, in our experiments we used the OpenOCD backend toconnect to the JTAG debugger of the mobile phone and of theEconotag, while we used the Avatar proxy to perform dynamicanalysis of the hard drive firmware.To analyze a firmware, an access to the firmwares deviceis needed. This can be either a debugging link e.g., JTAG, away to load software or a code injection vulnerability. In caseswhere a debugging stub, for example the GDB stub, is used,an additional communication channel, e.g., an UART, is alsoneeded.B. FullSeparation ModeWhen Avatar is first started on a previously unknownfirmware, it can be run in what we call fullseparation mode.In this configuration, the entire firmware code is executed inthe emulator and the entire memory state is kept in thephysical device. In other words, for each instruction that isexecuted by the emulator, the accessed memory addresses arefetched from and written to the real memory of the embeddedsystem. At the same time, interrupts are intercepted by thedebugging stub in the physical system and forwarded back tothe emulator. Code and memory are perfectly separated, andAvatar is responsible to link them together.Even though this technique is in theory capable of performing dynamic analysis on unknown firmwares, it has severalpractical limitations. First of all, the execution is very slow.Using a serial debug channel at 38400 Baud, the system canperform around five memory accesses per second, reducingthe overall emulation speed to the order of tens instructionsper second. Even worse, many physical devices have timecritical sections that need to be executed in a short amountof time or the execution would fail, making the system crash.For example, DRAM initialization, timer accuracy and stabilitychecks belong to this category.Moreover, tight hardwarepolling loops e.g., UART readwithtimeout become painfully slow in full separation mode.Finally, regular interrupts e.g., the clock tick quickly overloadthe limited bandwidth between the target system and theemulator.These limitations make the full separation approach viableonly to analyze a limited number of instructions or when theuser wants to focus only on particular events in more complexfirmwares. For this reason, Avatar supports arbitrary contextswitching between the emulator and the real device.C. Context SwitchingWhile it is possible to run the firmware code from beginning to end inside the emulator, sometimes it is moreefficient to let the firmware run natively on the target devicefor a certain amount of time. This allows, for example, toexecute the code without any delay until a particular pointof interest is reached, skipping through initialization routinesthat may involve intensive IO operations or network protocolcommunications that may need to be performed in realtime.In such cases, it is important to let the target device run thefirmware, while still monitoring the execution for regions ofcode relevant to the current analysis. The ability of Avatar toperform arbitrary context switches gives the user the abilityto quickly focus her analysis on a particular section of thecode, without the drawbacks of emulating the entire firmwareexecution.Starting the analysis at specific points of interest In thiscase the firmware starts the execution on the physical deviceand runs natively until a certain predefined event occurs e.g.,4 Firmware EmbeddeddeviceEmulator ProxyAvatarEmulatorBackendTargetBackendPlugins  readwrite memory   interruptreadwrite memoryvaluevalue   interrupt       . . .mov   r2, r0mov   r3, r1add    r3, r3, 1add    r2, ip, r2ldr      r2, r2, 0cmp   r2, r3       . . . Fig. 2 Avatar architecture and message exchange in full separation mode.a breakpoint is reached or an exception is raised. At thispoint, the execution on the physical device is frozen and thestate e.g., the content of the CPU registers is transferred tothe emulator, where the execution is resumed. An exampleof this transition is described in Section VIC, in which thefirmware of a mobile phone baseband chip is executed untilthe phone receives an SMS, and then transferred by Avatar inthe emulator to perform further analysis.Returning execution to the hardware After the requiredanalysis is performed on the emulator, the execution of thefirmware can be transferred back to continue on the real device.In this case, any state kept on the virtual environment is copiedback to the physical device. Depending on the users needs, itis possible to switch again to the emulator at a later stage. Thisapproach is used in Section VIA, in which the firmware ofa hard disk is started inside the emulator and later transferredback to the disk.D. Interrupts HandlingSoftware interrupts do not present a problem for ourframework, since they are issued by the firmware code andthe emulator takes care of calling the corresponding interrupthandler directly. However, as shown in Figure 2, hardwareinterrupts need to be trapped in the real hardware and forwarded back to the emulator. In this case, the stub in theembedded system receive the interrupt and forwards them toAvatars target backend. Finally, using the emulator backend, Avatar suspends the firmware execution and injects theinterrupt in the emulator.Based on the circumstances in which the interrupt isgenerated, we distinguish three different cases Hardware interrupts that indicate the completion of atask. These interrupts are issued by a device to indicatethat a particular task initiated by the code has beencompleted. For example, the UART send interruptindicates that the send buffer has been successfullytransmitted. This type of interrupts is easy to handlebecause it just needs to be forwarded from the targetto the emulator. Periodical hardware interrupts, e.g., the timer notifications. These interrupts can be forwarded to the emulator but their frequency needs to be scaled down to theactual execution speed in the emulator. The equivalentnumber of instructions between two interrupts shouldbe executed in the emulator as it would on the targetrunning in native mode. In our current implementation,an Avatar plugin detects periodic interrupts and reporttheir information to the user, who can decide how tohandle each class. For example, the user can instructAvatar to drop the clock interrupts on the device andjust generate them at the right frequency on theemulator, thus saving bandwidth and increasing theanalysis performance. Hardware interrupts that notify of an external event.For example the receive interrupt of an UART indicates that new data on the UART buffer is available.The emulation strategy for those interrupts dependson the frequency of the external event. For eventsthat require previous activity e.g., a requestresponseprotocol where the response triggers an interrupt asimple forwarding strategy can be used. For unrelatedevents that happen very frequently i.e., where thehandler in the emulator cannot process the interruptin time before the next interrupt is generated the usercan choose if she wants to suppress some of them orto handle the interrupt by migrating the handler itselfback to the embedded device see Section IVWhile the straightforward interrupt forwarding does notpresent any problem for Avatar, when the user needs to tunethe framework to handle specific cases e.g., regular or veryfrequent interrupts the stub needs to be able to distinguishbetween them. Unfortunately, this task is often difficult.Interrupts demultiplexing In a traditional, x86based,personal computer there is a standard interrupt controllerthat handles interrupt lines from each device and peripheral.However, on ARMbased systems there are only two interruptlines directly attached and visible to the processor IRQ andFIQ. Because of this embedded devices often use an interruptmultiplexer or controller peripheral that is normally includedas an hardware block IP core on the same chip. The disadvantage for a user is that at the point where the interrupt vectorroutine is called, all interrupt signals are still multiplexedtogether. The driver for a particular interrupt multiplexer willthen query the underlying hardware multiplexer to identify5which line was actually triggered and then forward the eventto the handler registered for this interrupt.Now, suppose the user wants to instruct Avatar to suppressa particular interrupt on the device e.g., the timer, whilestill letting through the ones associated to important hardwareevents that need to be forwarded to the emulator. In this case,the proxy needs to take a decision based on the interrupttype which is unfortunately not available when the interruptis received.In this case, the user needs to disassemble the interruptvector handler, and follow the code flow until the code of theinterrupt controller driver branches into different functions thathandle each devices interrupt. At this point, she can specifythese program points to Avatar that can terminate the interruptvectors execution and signal to the proxy that an interrupthas been identified. The proxy then sends the interrupt eventto Avatar. Now the target backend of Avatar can suppressa particular interrupt by instructing the proxy to drop thecorresponding event.E. Replaying Hardware InteractionIt is quite common for a firmware to have several sections that require only a limited interaction with dedicatedperipherals. In this case, the IO operations can be recorded byAvatar and transparently replayed during the next execution ofthe firmware.This allows the user to test the firmware without thebottleneck of the interaction with the physical device. In thismode of operation the firmware itself or parts of it e.g.,applications can be significantly changed, as long as theorder of IO interactions is not modified. This is a majoradvantage over resuming a snapshot, which requires the fullcode path until the snapshot point to be executed to ensurethat peripherals are in the state the snapshot expects them tobe in.IV. OVERCOMING THE LIMITS OF FULL SEPARATIONThe techniques introduced in the previous section areenough to perform dynamic analysis on small portions of afirmware code. However, sometimes the internals and behaviorof the system are completely unknown. In those cases, it canbe very useful to perform the analysis on larger portions ofthe binary, or, in the extreme case, on the entire firmware.In this case, the performance of Avatar running in fullseparation mode poses a great limitation to the usability ofour framework. To overcome this problem, in this section wepresent two techniques designed to overcome the limits of fullseparation by moving part of the code to the physical deviceand part of the memory to the emulator. This results in aconsiderable reduction in the number of messages forwardedby Avatar between the emulator and the target, and thereforea large improvement in the overall performance of the analysissystem.A. Memory OptimizationForwarding all memory accesses from the emulator to thetarget over a limitedbandwidth channel like UART or JTAGincurs in a heavy performance penalty. For example, in ourAccess type Read Write CumulativeCode 61,632  61,632Stack  data 646 1,795 64,073IO 3,614 2,097 69,784TABLE I Number of memory accesses grouped by memoryregions for the HDD bootloader.experiments an average of five instructions per second wereexecuted using the GDB stub through a 38400 baud UARTconnection.The reason why memory operations need to be forwardedin the first place is that different embedded systems typicallyhave different mappings of addresses to memory regions. Someof these memory regions are used for code in RAM, ROM orFlash memories, stack and heap, but one or several regionswill be used to access registers of physical peripherals throughMemoryMapped IO MMIO. In this case, any IO operationon those areas is equivalent to sending and receiving data froman external device. If these address ranges are known, the usercan configure Avatar to keep every readonly memory suchas the code segment on the emulator. Readwrite memoryregions can also be marked as local to the emulator, butmodifications to them need to be tracked by Avatar to be ableto transfer those changes to the target at a later context switch.In fact, when an emulatortotarget context switch happens, allmodified local memory dirty memory needs to be copiedto the target before the execution can resume on the embeddeddevice.However, in most of the cases the user does not know apriori which area of memory is assigned to IO. For this reason,Avatar includes an automated memory optimization pluginthat monitors the execution in the emulator and automaticallyidentifies the regions that do not require access to the hardware.This includes the stack easily identified by the executionof stackrelated operations and the code segment identifiedby the values of the program counter. For any other area,Avatar starts by forwarding the read and write operations tothe target device. It then keeps track of the values that arereturned and applies a simple heuristic if the target alwaysreturns the value that was previously written by the firmwarecode or if it always returns the same value and it is neverwritten by the firmware then it is probably not assigned to amemory mapped device.Table I shows an example of how many memory accessescould be saved by keeping memory regions local to the emulator transferring the code region to the emulator would save61,632 memory accesses 88. Moving the stack and dataregion in local memory as well would save 64,073 memoryaccesses 92. Only the IO accesses cannot be moved to theemulators memory.B. Selective Code MigrationSo far, we assumed that the firmware is either runningentirely inside the emulator, or entirely on the embeddeddevice. The user can instruct Avatar to switch from one modeto the other when certain conditions are met, but such contextswitches are time consuming.6In this section we present a finegrained solution thatallows the user to migrate only parts of the firmware codeback to the target. This technique allows to overcome twolimitations of the fullseparation mode. Some code blocksneed to be executed atomically, for example when there aretiming constraints on the code. We will describe such a casein Section VIA, where we encountered a function that readthe timer twice and waited for the difference to be belowa certain limit. Another example is when delays introducedby Avatar would lead the target in an invalid state. Weencountered such a case during the DRAM initialization ofthe HDD, as shown in Section VIA.The second limitation addressed by selective code migration is related to the analysis performance. In fact, certainfunctions e.g., polling loops and interrupt handlers can beexecuted significantly faster when run natively on the target.In the current Avatar prototype, code migration is supported at a function level. In this case, the code can be copiedto its location in the targets memory without modification. Itsexit points are then replaced by breakpoints, and the virtualmachine register state is transferred from the emulator to thetarget. The execution is resumed on the target until one ofthe exit breakpoints is triggered, and at that point the state istransferred back to the emulator. This transition is much fasterthan a complete context switch, since Avatar only needs totransfer few bytes and not the entire content of the memory.Even though this simple technique is enough to circumventcritical code regions in several real world scenarios, it neglectssome difficulties that may affect code migration. First, the codemay read or write arbitrary memory locations associated, forexample, with global variables. Avatar keeps track of thoselocations, copy their content over to the target before theexecution, and copy written locations back after the execution.Second, the code may use instructions that change the controlflow in unforeseen ways, like software interrupts, processormode changes, and indirect jumps.Our framework prototype addresses these issues by performing an onthefly static analysis. When a function isselected for code migration, Avatar disassembles its codeusing the llvmmc disassembler. The result is then analyzedto identify critical instructions. In this way, we can predictmemory accesses outside the function stack, compute thecontrol flow of the code and verify that no instructions canescape from this computed control flow. As we describe inSection VI, this technique is sufficient to migrate small, atomicfunctions. However, we plan to extend the capabilities ofthe code migration system to apply transformations to thecode. On the one hand, those transformations will allow toensure that instructions which are not statically verifiable e.g.,indirect jumps will not escape the proxys sandbox. On theother hand, it can be used to track memory accesses, sothat only the modified dirty part of the state needs to becopied back from the target to the emulator when a contextswitch happens. Those critical instructions will be replacedwith instrumentation code that calls functions in proxy, whichwill handle them in a safe way.V. EXTENDING AVATARAvatars architecture is designed to be modular and its baseframework can be easily customized to fit different analysisscenarios. We chose S2E as default Avatar emulator backendbecause it offers many hooks and manipulation facilities ontop of QEMU which facilitates the development of customdynamic analysis plugins.In this section, we show an example of an Avatar extensionwe built upon its core capabilities to support selective symbolicexecution. For this we add several features and plugins tothe ARM port of S2E. Moreover, we believe the symbolicexecution engine provides a superset of the capabilities neededto implement taint analysis, even though a targeted plugincould be needed to perform concrete data tracking and taintanalysis in a more lightweight way.In the rest of this section we describe the techniqueAvatar employs to fully exploit the symbolic engine of S2E andperform selective symbolic execution on unmodified portionsof firmware blobs. Moreover, we show how we use ourextended version of S2E in Avatar to dynamically detectpotential control flow corruption vulnerabilities by injectingand tracking symbolic inputs.A. Injecting Symbolic Values Into the Firmwares ExecutionFlowIn the field of program testing, symbolic execution isa technique employed to improve code coverage by usingsymbols as input data instead of concrete values and keepingtrack of constraints upon their manipulation or comparisonc.f. 51. The result of symbolic evaluation is an executiontree, where each path is a possible execution state that canbe reached by satisfying the constraints associated to eachsymbolic value.S2E further develops this concept by performing selectivesymbolic execution, i.e., by restricting the area of symbolicexecution to specific code portions and treating only specificinput data as symbolic 15. This greatly helps to speedupthe analysis process as symbolic execution of code results insignificant slowdowns and to drive the exhaustive symbolicexploration into selected regions of code. This process requiresAvatar to control the introduction of symbolic values into S2E,in place of existing real values.The remote memory interface between S2E and Avatar, asintroduced in Section III, ensures that only concrete valuesreach the real hardware through Avatar. Symbolic values remain therefore confined to the emulation domain. If a symbolicvalue is about to be written to the target hardware, the remotememory interface in S2E performs a forced concretizationbefore forwarding it. Such symbolic value concretizationshappen in two stages. First, all the constraints associated withthe value are retrieved and evaluated by the integrated SATsolver. Second, a single example value which satisfies all theconstraints is forwarded to Avatar to be written on the target.On the one hand, making Avatar handle only concretevalues leaves it as a controller with a simpler external viewof S2E and avoids having to keep track of execution pathsand paths conditions twice. On the other hand, this choicebrings the minor drawback that Avatar has no direct control7on symbolic execution, which is instead under the control ofS2EKLEE.We designed a simple plugin for detecting arbitrary execution conditions. It relies on the following heuristics as signsof possibly exploitable conditions a symbolic address being used as the target of a loador store instruction, a symbolic address being leaked into the programcounter e.g., as the target of a branch, a symbolic address being moved into the stack pointerregister.In order to selectively mark some input data as symbolic,two different approaches can be taken either modify thebinary code or the source code, if available to inject custom instructions into the firmware, or dynamically instrumentthe emulation environment to specify the scope of symbolicanalysis at runtime. The first approach requires some highlevel knowledge of the firmware under analysis e.g., accessto source code and the guarantee that injecting custom instructions into firmware code would not affect its behavior.Examples include the Android Dalvik VM, whose source codecan be modified and rebuilt to enable transparent analysis ofpristine Java bytecode with S2E 36.Since we did not want to limit Avatar to this scenario,we decided to follow the second approach, which requires toextend the symbolic engine and the Avatar framework. Suchextensions should know when symbolic execution has to betriggered and where symbolic values should be injected.This choice leads to two major advantages Firmware IntegrityThe binary code is emulated asis, without injectingcustom opcodes or performing recompilation. Thisguarantees that the emulated code adheres to theoriginal firmware behavior i.e., no sideeffects or bugsare introduced by the intermediate toolchain Programmatic AnnotationThe control and data flow of firmware emulation canbe manipulated and annotated with symbolic metadata in an imperative way. A highlevel language Luais used to dynamically script and interact with currentemulation environment, as well as introducing andtracing symbolic metadata.For this we first completed the port of S2E to the ARMarchitecture in order to have complete symbolic executioncapabilities, then we ported the Annotation plugin to the ARMarchitecture. The Annotation plugin lets the user specify atrigger event e.g., a callreturn to a specific subroutine or theexecution of code at a specific address, and a Lua functionto be executed upon the event. A simple API is then providedto allow for manipulation of the S2E emulation environmentdirectly from the Lua code. Avatar provides direct channels todynamically control the emulation flow via QMP commandmessages. These channels can also be used to inject Luacode at runtime, in order to dynamically generate annotationswhich depend on the current emulation flow and inject themback into S2E. Once symbolic values are introduced in the execution flow, S2E tracks them and propagates the constraints.Symbolic analysis via Lua annotations is intended to beused as a tool for late stage analysis, typically to ease thediscovery of flaws in logichandling code, with handmadeLua analysis code directly provided by the user. It can beemployed in both full separation mode and context switching,as soon as code execution can be safely moved to the emulatore.g., outside of raw IO setup routines, sensors polling. Thisnormally happens after an initial analysis has been done withAvatar to detect interesting code and memory mappings.A similar nonintrusive approach has already been usedin a x86specific context, to test and reverseengineer theWindows driver of a network card 14. To the best of ourknowledge, however, this technique has never been appliedbefore to embedded devices. In the context of firmware security testing, annotations can be used in a broad range ofscenarios. In Section VI, we present how we applied thistechnique to different technologies and devices, to performdynamic analysis of widespread embedded systems such ashard drives, GSM phones, and wireless sensors.B. Symbolically Detecting Arbitrary Execution ConditionsWhen dealing with modern operating systems, an incorrectbehavior in a userspace program is often detected becausean invalid operation is performed by the program itself. Suchoperations can be, for example, an unauthorized access to amemory page, or the access to a page that is not mapped inmemory. In those cases, the kernel would catch the wrongbehavior and terminate the program, optionally triggering someanalysis tools to register the event and collect further information that can later be used to identify and debug the problem.Moreover, thanks to the wide range of exploit mitigationtechniques in place today DEP, canaries, sandboxing andmore, the system is often able to detect the most commoninvalid operations performed by userspace processes.When dealing with embedded systems, however, detectingmisbehavior in firmware code can be more difficult. Theobservable symptoms are not always directly pinpointed tosome specific portion of code. For example, many firmwareare designed for devices without a Memory Management UnitMMU or Memory Protection Unit MPU or are just notusing them. In such a context, incorrect memory accessesoften result in subtle data corruption which sometimes leadsto erratic behaviors and rare software faults, such as randomevents triggering, UI glitches, system lock or slowdown 18.For this reason, it is common for embedded devices to have ahardware watchdog in charge of resetting the device executionin case of any erratic behavior, e.g., a missed reply to timedwatchdog probes.For these reasons, detecting incorrect execution insidethe emulation is easier when some OS support can be usedfor cooperation e.g., a Blue Screen Of Death interceptorfor Windows kernel bugs is implemented in S2E. On theother hand, catching such conditions during the emulationof an embedded device firmware is bound to many systemspecific constraints, and require additional knowledge aboutthe internal details of the firmware under analysis.8However, Avatar does not rely on the knowledge of anyspecific operating system or the fact that a MMU is used.Instead, it aims at detecting a larger range of potentiallycritical situations which may result in control flow hijackingof firmware code, by using a technique similar to the oneemployed by AEG 6.All three conditions may lead to false positives, when thevariable is symbolic but strongly constrained. Therefore, oncesuch a condition is detected the constraints imposed on thesymbolic variables must be analyzed the less constrained isthe result, the higher is the chance of control flow corruption.Intuitively, if the constraints are very loose e.g., a symbolicprogram counter without an upper bound then the attackermay obtain enough control on the code to easily exploit thebehavior. In addition to this, tight constraints are sometimesencountered in legitimate cases e.g., access to an array witha symbolic but constrained index such as with a jump table,and are not relevant for the purpose of security analysis.When an interesting execution path is detected by the aboveheuristic, the state associated to the faulty operation is recordedand the emulation is terminated. At this point a testcase withan example input to reach this state is generated, and theconstraints associated with each symbolic value are stored tobe checked for false positives i.e., values too strictly bound.Automatically telling normal constraints apart from thosethat are a sign of a vulnerability is a complex task. In factit would require knowledge of the program semantics thatwere lost during compilation e.g., array boundaries. Suchknowledge could be extracted from the source code if itis available, or might be extrapolated from binary artifactsin the executable itself or the build environment. In suchcases, specific constraints could be fed into Avatar by writingappropriate plugins to parse them, for example by scanningdebug symbols in a nonstripped firmware e.g., a DWARFparser for ELF firmwares or by reading other similar symbolsinformation.Finally, Avatar could highly benefit from a tighter couplingwith a dynamic data excavator, helping to reverse engineerfirmware data structures 17. In particular, the heuristicproposed in Howard 52 for recovering data structures byobserving access patterns under several execution cycles couldbe easily imported into the Avatar framework. Both toolsperform binary instrumentation on top of QEMU dynamictranslation and make use of a symbolic engine to expand theanalyzed code coverage area.C. Limitations of state synchronizationOur current implementation of the synchronization betweendevice state and emulator state works well in general, but isdifficult in some special cases.First it is difficult to handle DMA memory accesses in ourcurrent model. For example, the firmware can send a memoryaddress to a peripheral and request data to be written there.The peripheral will then notify the firmware of the requestscompletion using an interrupt. Since Avatar does not knowabout this protocol between firmware and peripheral, it willnot know which memory regions have been changed. On newerARM architectures with caches, data synchronization barrieror cache invalidation instructions might be taken as hint thatsome memory region has been changed by DMA.Second, if code is executed on the device, Avatar iscurrently incapable of detecting which regions have beenmodified. In consequence, whenever memory accesses of thecode run on the device are not predictable by static analysis,we need to transfer the whole memory of the device back tothe emulator on a devicetoemulator state switch. We plan toaddress this issue by using checksumming to detect memoryregion changes and minimize transferred data by identifyingsmallest changed regions through binary search.Third, when Avatar performs symbolic execution, symbolicvalues are confined to the emulator. In case that a symbolicvalue needs to be concretized and sent to the device, astrategy is needed to keep track of the different states andIO interactions that were required to put the device in thatstate. This can be performed reliably by restarting the deviceand replaying IO accesses. While this solution ensures fullconsistency, it is rather slow.VI. EVALUATIONIn this section we present three case studies to demonstratethe capabilities of the Avatar framework on three different realworld embedded systems. These three examples by no meanscover all the possible scenarios in which Avatar can be applied.Our goal was to realize a flexible framework that a user canuse to perform a wide range of dynamic analysis on knownand unknown firmware images.As many other security tools such as a disassembler or anemulator, Avatar requires to be configured and tuned for eachsituation. In this section, we try to emphasize this process, inorder to show all the steps a user would follow to successfullyperform the analysis and reach her goal. In particular, we willdiscuss how different Avatar configurations and optimizationtechniques affected the performance of the analysis and thesuccess of the emulation.Not all the devices we tested were equipped with a debuginterface, and the amount of available documentation variedconsiderably between them. In each case, human interventionwas required to determine appropriate points where to hookexecution and portions of code to be analyzed, incrementallybuilding the knowledgebase on each firmware in an iterativeway. A summary of the main characteristics of each deviceand of the goal of our analysis is shown in Table II.A. Analysis of the Mask ROM Bootloader of a Hard DiskDriveOur first case study is the analysis of a masked ROMbootloader and the first part of the secondary bootloader ofa hard disk drive.The hard disk we used in our experiment is a commercialofftheshelf SATA drive from a major hard disk manufacturer.It contains an ARM 966 processor that implements theARMv5 instruction set, an onchip ROM memory which contains the masked ROM bootloader and some library functions,an external serial flash that is connected over the SPI busto the processor, a dynamic memory SDRAM controller, aserial port accessible through the masterslave jumpers, and9Target device Manufacturer and model SystemonChip CPU Debug access Analyzed code Scope of analysisExperiment VIA Hard disk undisclosed unknown ARM966 Serial port Bootloader Backdoor detectionExperiment VIB ZigBee sensor Redwire Econotag MC13224 ARM7TDMI JTAG ZigBee stack Vulnerability discoveryExperiment VIC GSM phone Motorola C118 TI Calypso ARM7TDMI JTAG SMS decoding Reverse engineeringTABLE II Comparison of experiments described in Section VI.Fig. 3 The disk drive used for experiments. The disk isconnected to a SATA DataPower to USB interface blackbox on the right and its serial port is connected to a TTLserial to USB converter not shown via the 3 wires that canbe seen on the right.some other custom hardware that is necessary for the drivesoperation. The drive is equipped with a JTAG connection,but unfortunately the debugging features were disabled in ourdevice. The hard drives memory layout is summarized inFigure 4.The stage0 bootloader executed from mask ROM is normally used to load the next bootloader stage from a SPIattached flash memory. However, a debug mode is known tobe reachable over the serial port, with a handful of commandsavailable for flashing purposes. Our first goal was to injectthe Avatar stub through this channel to take over the bootingprocess, and later use our framework for deeper analysis ofpossible hidden features e.g., backdoors reachable via theUART.The first experiment we performed consisted of loading theAvatar stub on the drive controller and run the bootloadersfirmware in full separation mode. This mimics what a userwith no previous knowledge of the system would do in thebeginning. In full separation mode, all memory accesses wereforwarded through the Avatar binary protocol over the serialport connection to the stub and executed on the hard drive,while the code was interpreted by S2E. Because of the limitedcapacity of the serial connection, and the very intensive IOperformed at the beginning of the loader to read the nextstage from the flash chip, only few instructions per secondwere emulated by the system. After 24 hours of executionAddress Space0x000000000x00000040Interrupt vect.0x00008000Code SRAM0x001000000x00120000ROM0x002000000x00400000DRAM0x040000000x04004000Data SRAM0x400000000x50000000Memory Mapped IO0xFFFFFFFFFig. 4 Hard drive memory layout.without even reaching the first bootloader menu, we abortedthe experiment.In the second experiment we kept the same setting, but weused the memory optimization plugin to automatically detectthe code and the stack memory regions and mark them aslocal to the emulator. This change was enough to reach thebootloader menu after approximately eight hours of emulation.Though considerably faster than in the first experiment, theoverhead was still unacceptable for this kind of analysis.Since the bottleneck of the process was the multiple readoperations performed by the firmware to load the second stage,we configured Avatar to replay the hardware interaction fromdisk, without forwarding the request to the real hardware.In particular, we used the trace of the communication withthe flash memory from the second experiment to extract thecontent of the flash memory, and dump it into a file. Once theread operations were performed locally in the emulator, thebootloader menu was reached in less than four minutes.At this point, we reached an acceptable working configuration. In the next experiment, we show how Avatar can beused in conjunction with the symbolic execution of S2E toautomatically analyze the communication protocol of the harddrives bootloader and detect any hidden backdoor in it.10DS Use a minimal version of the Motorola SRecordbinary data format to transmit data to the deviceAP addr Set the value of the address pointer from the parameterpassed as hexadecimal number. The address pointerprovides the address for the read, write and executecommands.WT data Write a byte value at the address pointer. The addresspointer is incremented by this operation. The reply ofthis command depends on the current terminal echostate.RD Read a byte from the memory pointed to by the addresspointer. The address pointer is incremented by thisoperation. The reply of this command depends on thecurrent terminal echo state.GO Execute the code pointed to by the address pointer.The code is called as a function with no parameters,to execute Thumb code one needs to specify the codesaddress  1.TE Switch the terminal echo state. The terminal echo statecontrols the verbosity of the read and write commands.BR divisor Set the serial port baud rate. The parameter is thevalue that will be written in the baud rate register,for example A2 will set a baudrate of 38400.BT Resume execution with the firmware loaded from flash.WW Erase a word 4 bytes at the address pointer andincrement address pointer. Print the help menu showing these commands.TABLE III Mask ROM bootloader commands of the harddrive. In the left column you can see the output of the helpmenu that is printed by the bootloader. In the right columna description obtained by reverse engineering with symbolicexecution is given.We configured Avatar to execute the hard drives bootloader until the menu was loaded, and then replace all dataread from the serial port register by symbolic values. As aresult, S2E started exploring all possible code paths related tothe user input. This way, we were able to discover all possibleinput commands, either legitimate or hidden which may beconsidered backdoors, that could be used to execute arbitrarycode by using S2E to track when symbolic values were used asaddress and value of a memory write, and when the programcounter would become symbolic. With similar methodologies,a user could use symbolic execution to automatically discoverbackdoors or undocumented commands in input parsers andcommunication protocols.In order to conduct a larger verification of the firmwareinput handler, we were also able to recover all the acceptedcommands and verify their semantics. Since the menu offereda simple online help to list all the available commands, wecould demonstrate that Avatar was indeed able to automaticallydetect each and all of them the complete list is reportedin Table III. In this particular device, we verified that nohidden commands are interpreted by the firmware and thata subset of the commands can be used to make arbitrarymemory modifications or execute code on the controller, asdocumented.However, we found that the actual protocol as extracted bysymbolic analysis is much looser than what is specified in thehelp menu. For example the argument of the AP commandAddress SpaceROMRAMIO0x000000000x00000020ROM interrupt vect.0x00400000Libraries in ROM0x00400020User interrupt vect.0x80000000User program0x80003000Unused0x80003000Memory mapped IOUnused0xFFFFFFFFFig. 5 Econotag memory layout respective scales not respected.can be separated by any character from the command, not onlyspaces. It is also possible to enter arbitrarily long numbers asarguments, where only the last 8 digits are actually taken intoaccount by the firmware code.After the analysis of the first stage was completed, we triedto move to the emulation of the second stage bootloader. Atone point, in what turned out to be the initialization of theDRAM, the execution got stuck the proxy on the hard drivewould not respond any more, and the whole device seemed tohave crashed. Our guess was that the initialization writes theDRAM timings and needs to be performed atomically. Sincewe already knew the exact line of the crash from the executiontrace, it was easy to locate the responsible code, isolate thecorresponding function, and instruct Avatar to push its codeback to be executed natively on the hard drive.In a similar manner, we had to mark few other functionsto be migrated to the real hardware. One example is the timerroutine, which was reading the timer value twice and thenchecked that the difference was below a certain threshold mostprobably to ensure that the timer read had not been subjectto jitter. Using this technique, in few iterations we managedto arrive at the final Avatar configuration that allowed us toemulate the first and second stages up to the point in whichthe disk would start loading the actual operating system fromthe disks platters.B. Finding Vulnerabilities Into a Commercial Zigbee DeviceThe Econotag, shown in Figure 6, is an allinone device forexperimenting with low power wireless protocols based on theIEEE 802.15.4 standard 32, such as Zigbee or 6lowpan 43.It is built around the MC13224v System on a Chip fromFreescale. The MC13224v 47 is built upon an ARM7TDMImicrocontroller, includes several memories, peripherals andhas an integrated IEEE 802.15.4 compatible radio transceiver.As it can be seen in Figure 5, the device includes 96KB ofRAM memory, 80 KB of ROM and a serial Flash for storingdata. The ROM memory contains drivers for several peripherals as well as one to control the radio, known as MACA MACAccelerator, which allows to use the dedicated hardware logic11Fig. 6 The Econotag device. From left to right the USBconnector, serial and JTAG to USB converter FTDI, FreescaleMC13224v controller and the PCB 2.4 GHz antenna.supporting radio communications e.g., automated ACK andCRC computation.The goal of this experiment is to detect vulnerabilities inthe code that process incoming packets. For this purpose, weuse two Econotag devices and a program from the Freescaledemonstration kit that simulates a wireless serial connectionwireless UART 26 using the Simple MAC SMAC 27proprietary MAC layer network stack. The program is essentially receiving characters from its UART and transmittingthem as radio packets as well as forwarding the charactersreceived on the radio side to its serial port. Two such devicescommunicating together essentially simulate a wireless serialconnection.The data received from the radio is buffered before beingsent to the serial port. For demonstration purposes, we artificially modified this buffer management to insert a vulnerability a simple stackbased buffer overflow. We then compiledthis program for the Econotag and installed it on both devices.Avatar was configured to let the firmware run natively untilthe communication between the two devices started. At thispoint, Avatar was instructed to perform a context switch tomove the runtime state registers and data memory of oneof the devices to the emulator. At this point, the executionproceeded in full separation mode inside the emulator usingthe code loaded in ROM memory extracted from a previousdump, and the code loaded in RAM memory taken from theapplication. Every IO access was forwarded to the physicaldevice through the JTAG connection.The emulator was also configured to perform symbolicexecution. For this purpose, we used annotations to mark thebuffer that contains the received packet data as symbolic. Then,we employed a state selection strategy to choose symbolicstates which maximize the code coverage, leading to a thorough analysis of the function.On the first instruction that uses symbolic values in thebuffer, S2E would switch from concrete to symbolic execution mode. Execution will fork states when, for example,conditional branches that depend on such symbolic valuesare evaluated. After exploring 564 states, and within lessthan a minute of symbolic execution, our simple arbitraryexecution detection module detected that an unconstrainedFig. 7 The Motorola C118. The clipon battery on the righthas been wired to the corresponding power pins, while theribbon cable is connected to the JTAG pads reachable on theback not shown.symbolic value was used as a return address. This confirmedthe detection of the vulnerability and also provided an exampleof payload that triggers the vulnerability.We also used Avatar to exhaustively explore all possiblestates of this function on a program without the injected vulnerability, and confirmed the absence of control flow corruptionvulnerabilities that could be triggered by a network packet thatour simple arbitrary execution detection module could detect.C. Manipulating the GSM Network Stack of a Common Feature PhoneOur final testcase is centered on the analysis of thefirmware of a common GSM feature phone. In contrast withmost recent and advanced mobile phones and smartphones,feature phones are characterized by having one single embedded processor for both the network stack i.e., GSMbaseband capabilities and the HumantoMachine InterfaceHMI comprising the main Graphical User Interface, advancedphone services, and miscellaneous applications. As such,there is no clear code separation between different firmwaresections. On these phones, typically a realtime kernel takescare of scheduling all the tasks for the processes currentlyin execution. These are executed in the same context andhave shared access to the whole physical memory as well asmemorymapped IO.12Address Space0x000000000x00000020Interrupt vect.0x00002000ROM bootloader0x00002020User interrupt vector0x00400000NOR flash0x00800000Unused0x00c00000Internal SRAM0x01000000Unused0x01800000External SRAM0xFFFF0000UnusedMemory mapped IO0xFFFFFFFFFig. 8 Motorola C118 memory layout respective scales notrespected.GSM baseband stacks have already been shown to have alarge potentially exploitable attack surface 56. Those stacksare developed by few companies worldwide and have manylegacy parts which were not written with security in mind,and in particular were not considering attacks coming fromthe GSM infrastructure 57.For our experiment, we used a Motorola C118, which isa rebranded version of the Compal E88 board also foundin other Motorola feature phones. This board makes use ofthe Texas Instruments Calypso digital baseband, which iscomposed of a maskROM, a DSP for GSM signal decoding,and a single ARM7TDMI processor. It also includes severalperipherals such as an RTC clock, a PWM generator forcontrolling the lights and buzzer as well as a memory mappedUART as shown in Figure 8. Some board models have JTAGand UART ports available, which are from time to time leftenabled by manufacturers to simplify servicing devices. In ourcase, we gained access to the JTAG port and used an adapterto bridge communication between Avatar and the hardware, asshown in Figure 7.Some specification documents on the Calypso chipset havebeen leaked in the past, leading to the creation of homebrewphone OS that could be run on such boards. As part of theOsmocomBB project, most of the platform has been reversedand documented, and it is now possible to run a free opensource software GSM stack on it 2. However, we conductedour experiments on the original Motorola firmware, in order toassess the baseband code of an unmodified phone. Moreover,as the GSM network code is provided as a library by thebaseband manufacturer, there is an higher chance that flawsaffecting the library code would also be present in a broaderrange of phones using baseband chips from that same vendor.The phone has a firststage bootloader executed on hardware reset, which can be used to reflash the firmware. Afterphone setup, execution continues to the main firmware, whichis mainly composed of the Nucleus RTOS, the TI networkstack library, and of thirdparty code to manage the user interface. The phone bootloader can be analyzed using Avatar in asimilar way as the one already described for the hard disk inSection VIA to discover flashing commands, hidden menusand possible backdoors. However, the bootloader revealeditself to be simpler than the hard drive one, supporting onlya UART command to trigger firmware flashing and executingthe flashed firmware, or continuing execution after a timeoutexpiration.For this reason, we focused on the analysis of the GSMnetwork stack, and in particular on the routines dedicated toSMS decoding. It has already been shown in the past howmaliciously crafted SMS can cause misbehavior, ranging fromUI issues to phone crashes 44. However, due to the lackof a dynamic analysis platform to analyze embedded devices,previous studies relied on blind SMS fuzzing. Our experimentaims at improving the effectiveness of SMS fuzzing to detectremotely exploitable execution paths.In this scenario, Avatar was configured to start the execution of the firmware on the real device, and switch to theemulator once the code reached the SMS receiving state e.g.,by sending a legitimate SMS to it through the GSM network.Avatar was then used to selectively emulate and symbolicallyexplore the decoding routines. As a result of this exploration,a user is able to detect faulty conditions, to determine codecoverage due to different inputs and to recover precise inputconstraints to drive the firmware execution into interestingareas.In this context, Avatar uses the JTAG connection to stop theexecution on the target and later perform all synchronizationsteps between the emulator and the target. All memory andIO accesses through JTAG are traced by Avatar to let the useridentify address mappings. When the phone reaches the SMSreceiving state, a targettoemulator context switch happensand the phones state is transferred into S2E. Using addressmapping information previously recovered through Avatar, justthe relevant memory is moved into S2E e.g., portions ofcode and the execution stack, while remaining memory iskept on the target and forwarded onthefly by Avatar e.g.,IO regions. On this device, no selective code migration wasrequired.Using this Avatar configuration, the SMS payload can beintercepted in memory and marked as symbolic by employingthe techniques shown in Section V. In particular, we wroteAnnotation functions to be triggered before entering the decoding routines and we then proceeded to selectively mark somebytes of their input arguments as symbolic. The S2E pluginfor Arbitrary Execution Detection has been employed to isolateinteresting vulnerable cases, while other execution paths werekilled upon reaching the end of the decoding function.The symbolic execution experiments have been performedover several days, with the ones with larger number of symbolic inputs taking up to 10 hours before filling up 60 GBof available memory. In such case, we observed more than120,000 states being spawned according to different constraintssolving. Unfortunately, and contrary to the other experiments,13the GSM network stack proved to be way too complex to besymbolically analyzed without prior knowledge on the highlevel structure of the code. The analysis was clobbered byan explosion of possible states due to many forks happeningin pointermanipulating loops. Avatar was able to symbolically explore 42 subroutines executed during SMS decoding,without detecting any exploitable conditions. However, it wasable to highlight several situations of usercontrolled memoryload, which were unfortunately too strictly constrained to beexploited, as discussed in Section VB.State explosion is a wellknown limitation of symbolicexecution. To mitigate the problem, a user may need to defineheuristics to avoid an excessive resource consumption. Thiscould be done, for example, by employing more aggressivestate selectors to enhance code coverage, and actively prunestates by looking at loops invariants 50. However, thisoptimizations are outside the scope of our paper. The objectiveof our experiments are, in fact, limited to prove that Avatar canbe used to perform dynamic analysis of complex firmware ofembedded devices.VII. RELATED WORKThe importance of porting dynamic analysis techniques todifferent platforms has been discussed by Li and Wang 41,who proposed a set of tools built on top of IDA Pro and theREIL Intermediate Language to perform symbolic executionin a portable way.However, embedded systems have long been recognizedto be a difficult target for debugging and dynamic analysis.SymDrive 48 presents a technique based on symbolic execution to test Linux and FreeBSD device drivers withouttheir device present. However, by replacing every input witha symbolic value, this approach is hard to scale and wouldsuffer of state explosion on any real world firmware. In 14,Chipounov and Candea present REVNIC, a tool based onS2E 15 that helps to reverse engineer network device drivers.As a case study the authors port a Windows device driver for acommon network card to a different Operating System. Whilethe presented approach is interesting, it relies on the presenceand extension of the emulated device and PCI bus in QEMU.Instead, Avatar is hardware agnostic, as it does not need toknow how peripherals are connected, mapped and accessed.Instead IO can be simply forwarded to the real target and IOrelated code directly executed there.Cui et al., adopted software symbiotes 20, an ondevicebinary instrumentation to automatically insert hooks in embedded firmwares. Their solution allows to insert pieces of codethat can be used to interact with the original firmware. However, while this allows some analysis like tracing, performingadvanced dynamic analysis often requires to be able to run thefirmware code inside an emulator.Dynamic analysis based on virtualization has already beenproposed in the past 37, also in embedded systems contexts 40, 31. However, Avatar aims at overcoming manyof the limitations of purevirtualization systems, by providingan hybrid system where code execution can be transferred backand forth between the device and an emulator, as well as a fullframework to orchestrate all the analysis steps.The state migration technique employed by Avatar ishighly influenced by existing solutions been used to improvethe performance during hotmigration of virtual machines. Inparticular, our approach is a simplified version of the oneproposed by Clark et al. 16, where Avatar is the arbiter of amanaged migration, which can either happen in a single stopandcopy phase as in fullseparation mode or in an eventdriven pullphase during context switching.The security by obscurity approach is still relevantamong embedded systems manufacturers and has lead in thepast to the discovery of major weaknesses in commonlydeployed technologies 45. We believe that Avatar representsa flexible solution to provide a symbolic analysis environmentwhich can greatly speedup such blackbox analysis cases,aiming at automatically reverse engineer input formats 21, 9and detect hidden data structures 53. In the past, backdoorsand insecure firmware update facilities were found into embedded systems, often disguised into other standard interfacessuch as Printer Job Language updates for HP printers 19.In our experiments we showed how Avatar can be used toactively look for such backdoors, by symbolically executinginput parsing routines.Davidson et al. 22 present a tool to perform symbolicexecution of embedded firmware for MSP430based devices.Like Avatar, this tool is based on the KLEE symbolic executionengine. However, it relies on firmwares source code as wellas on documented SoCs, peripherals mapping, or on a simpleemulation layer for them, all of those are rarely available forcommercial devices.Delugre 23 reports on the techniques that were used toreverse engineer the firmware of a PCI network card, and todevelop a backdoored firmware. For this purpose, QEMU wasadapted to emulate the firmware and to forward IO access tothe device. However, this was limited by bad performance. Wehave seen similar performance blockers when using Avatar infull separation mode, but the ability to perform memoryoptimization and push back code to the physical device allowAvatar to overcome such limitations.Dedicated hardware support can provide a very goodsolution to improve efficiency of debugging, improving significantly the ability to replay events and system status. In59 Xu et al., presents an hardware architecture for recordingprecise events and replay them during debugging sessions. Forthis purpose custom hardware logs memory and taps on severalimportant internal features e.g., cache lines. Simpler systemsalso exist, like InCircuit Emulators 58, which replace theCPU core by an emulated CPU which can then directly interactwith hardware peripherals. While Avatar could make use ofsuch features, it also aims at enabling analysis on deviceswithout such dedicated hardware support.VIII. CONCLUSIONThis paper introduced Avatar, a new framework for dynamic analysis of embedded devices firmwares. Avatar enables the execution of firmware code in an analysisfriendlyemulator by forwarding memory access to the real device. Thisallows to analyze firmwares that rely on completely unknownperipherals.14Avatar proved to be capable of acceptable performancesand flexibility in three realword tests, performed on a varietyof target devices and with different goals. It was successfullyused across these three scenarios, which included a commonreverse engineering task, a vulnerability discovery and a hardcoded backdoor detection.Future work will consist in integrating better analysistechniques with avatar to improve its bug detection rate. Forexample, augmenting Avatar with techniques like those usedin Howard 52 would allow to recover memory structuresand therefore improve bug detection, while other techniquesas used in AEG 6 could be applicable as well. Another areawhere significant improvements can be achieved is in providing improved state exploration heuristics, that lead to bettercoverage or to the analysis of more error prone code 30.Finally, Avatar has been tested on ARM embedded systemsand could easily support x86 targets, but could be ported withreasonable effort to a wider set of architectures supported byQEMU such as MIPS and PowerPC, in order to analyze manyother devices.ACKNOWLEDGMENTSAuthors would like to thank Pascal Sachs and Luka Malisathat worked on an early prototype of the system, and LucianCojocar for his helpful comments on the current version ofAvatar. The research leading to these results was partiallyfunded by the European Union Seventh Framework Programme contract Nr 257007 and project FP7SEC285477CRISALIS.REFERENCES1 Anubis Analyzing Unknown Binaries. httpanubis.iseclab.org.2 OsmocomBB. httpbb.osmocom.orgtrac.3 IEEE Standard Test Access Port and BoundaryScan Architecture, 1990.IEEE Standard. 1149.11990.4 IEEEISTO 5001  2003 the nexus 5001 forum standard for a globalembedded processor debug interface. IEEE  Industry Standards andTechnology Organization, December 2003.5 CWSandbox, 2008. httpwww.cwsandbox.org.6 AVGERINOS, T., CHA, S. K., HAO, B. L. T., AND BRUMLEY, D.AEG Automatic exploit generation. In Network and Distributed SystemSecurity Symposium Feb. 2011, pp. 283300.7 BELLARD, F. QEMU, a fast and portable dynamic translator. In ATEC05 Proceedings of the annual conference on USENIX Annual Technical Conference Berkeley, CA, USA, 2005, USENIX Association,pp. 4141.8 BOJINOV, H., BURSZTEIN, E., AND BONEH, D. Embedded management interfaces Emerging massive insecurity. In Blackhat 2009Technical Briefing  whitepaper 2009.9 CABALLERO, J., YIN, H., LIANG, Z., AND SONG, D. Polyglotautomatic extraction of protocol message format using dynamic binaryanalysis. In Proceedings of the 14th ACM conference on Computer andcommunications security New York, NY, USA, 2007, CCS 07, ACM,pp. 317329.10 CADAR, C., DUNBAR, D., AND ENGLER, D. KLEE unassistedand automatic generation of highcoverage tests for complex systemsprograms. In OSDI 2008.11 CARNA BOTNET. Internet census 2012, port scanning 0 using insecureembedded devices, 2012. httpinternetcensus2012.bitbucket.orgpaper.html.12 CHECKOWAY, S., MCCOY, D., ANDERSON, D., KANTOR, B., SAVAGE, S., KOSCHER, K., CZESKIS, A., ROESNER, F., AND KOHNO,T. Comprehensive Experimental Analysis of Automototive AttackSurfaces. In Proceedings of the USENIX Security Symposium SanFrancisco, CA, August 2011.13 CHING, P. C., CHENG, Y., AND KO, M. H. An incircuit emulator forTMS320C25. IEEE Transactions on Education 37, 1 1994, 5156.14 CHIPOUNOV, V., AND CANDEA, G. Reverse Engineering of BinaryDevice Drivers with RevNIC. In Proceedings of the 5th ACM SIGOPSEuroSys European Conference on Computer Systems EuroSys, ParisFrance, April 2010 Paris, France, 2010.15 CHIPOUNOV, V., KUZNETSOV, V., AND CANDEA, G. The S2E Platform Design, Implementation, and Applications. ACM Trans. Comput.Syst. 30, 1 Feb. 2012, 21249.16 CLARK, C., FRASER, K., HAND, S., HANSEN, J. G., JUL, E.,LIMPACH, C., PRATT, I., AND WARFIELD, A. Live migration of virtualmachines. In Proceedings of the 2nd conference on Symposium onNetworked Systems Design  Implementation  Volume 2 Berkeley,CA, USA, 2005, NSDI05, USENIX Association, pp. 273286.17 COZZIE, A., STRATTON, F., XUE, H., AND KING, S. T. Diggingfor data structures. In Proceedings of the 8th USENIX conference onOperating systems design and implementation Berkeley, CA, USA,2008, OSDI08, USENIX Association, pp. 255266.18 CRISTIAN, F. Exception handling and software fault tolerance. IEEETransactions on Computers C31, 6 1982, 531540.19 CUI, A., COSTELLO, M., AND STOLFO, S. J. When firmware modifications attack A case study of embedded exploitation. In 20th AnnualNetwork and Distributed System Security Symposium, NDSS 2013, SanDiego, California, USA, February 2427, 2013 2013, The InternetSociety.20 CUI, A., AND STOLFO, S. J. Defending embedded systems with software symbiotes. In Proceedings of the 14th International Conferenceon Recent Advances in Intrusion Detection Berlin, Heidelberg, 2011,RAID11, SpringerVerlag, pp. 358377.21 CUI, W., PEINADO, M., CHEN, K., WANG, H. J., AND IRUNBRIZ,L. Tupni automatic reverse engineering of input formats. In CCS08 Proceedings of the 15th ACM conference on Computer andcommunications security New York, NY, USA, 2008, ACM, pp. 391402.22 DAVIDSON, D., MOENCH, B., JHA, S., AND RISTENPART, T. FIE onfirmware Finding vulnerabilities in embedded systems using symbolicexecution. In Proceedings of the USENIX Security Symposium Washington, DC, August 2013.23 DELUGRE, G. Closer to metal Reverse engineering the broadcomnetextremes firmware. HACK.LU 2010.24 EGELE, M., SCHOLTE, T., KIRDA, E., AND KRUEGEL, C. A surveyon automated dynamic malwareanalysis techniques and tools. ACMComput. Surv. 44, 2 Mar. 2008, 61642.25 FALLIERE, N., MURCHU, L. O., AND CHIEN, E. W32.Stuxnet Dossier,2011.26 FREESCALE SEMICONDUCTOR, INC. MC1322x Simple Media AccessController Demonstration Applications Users Guide, 9 2011. Rev. 1.3.27 FREESCALE SEMICONDUCTOR, INC. MC1322x Simple Media AccessController SMAC Reference Manual, 09 2011. Rev. 1.7.28 GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. Automated Whitebox Fuzz Testing. In Network Distributed Security Symposium NDSS2008, Internet Society.29 GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. SAGE whiteboxfuzzing for security testing. Communications of The ACM 2012, 4044.30 HALLER, I., SLOWINSKA, A., NEUGSCHWANDTNER, M., AND BOS,H. Dowsing for overflows A guided fuzzer to find buffer boundaryviolations. In Proceedings of USENIX Security13 Washington, DC,August 2013, USENIX.31 HAN, Y., LIU, S., SU, X., AND HU, Z. A dynamic analysis system forCisco IO based on virtualization. In Multimedia Information Networkingand Security MINES, 2011 Third International Conference on 2011,pp. 330332.32 IEEE COMPUTER SOCIETY. IEEE 802.15.4, Wireless Medium AccessControl MAC and Physical Layer PHY Specifications for LowRate15Wireless Personal Area Networks WPANs, June 2006. ISBN 0738149969.33 KANG, M. G., MCCAMANT, S., POOSANKAM, P., AND SONG, D.DTA Dynamic Taint Analysis with Targeted ControlFlow Propagation. In Proceedings of the 18th Annual Network and DistributedSystem Security Symposium San Diego, CA, Feb. 2011.34 KANG, M. G., POOSANKAM, P., AND YIN, H. Renovo a hidden codeextractor for packed executables. In Proceedings of the 2007 ACMworkshop on Recurring malcode New York, NY, USA, 2007, WORM07, ACM, pp. 4653.35 KAO, C.F., HUANG, I.J., AND CHEN, H.M. Hardwaresoftwareapproaches to incircuit emulation for embedded processors. DesignTest of Computers, IEEE 25, 5 2008, 462477.36 KIRCHNER, A. Data Leak Detection in Smartphone Applications.Master thesis, Vienna University of Technology.37 KUZNETSOV, V., CHIPOUNOV, V., AND CANDEA, G. Testing closedsource binary device drivers with DDT. In Proceedings of the 2010USENIX conference on USENIX annual technical conference Berkeley,CA, USA, 2010, USENIXATC10, USENIX Association, pp. 1212.38 KUZNETSOV, V., KINDER, J., BUCUR, S., AND CANDEA, G. Efficientstate merging in symbolic execution. In Proceedings of the 33rdACM SIGPLAN Conference on Programming Language Design andImplementation New York, NY, USA, 2012, PLDI 12, ACM, pp. 193204.39 LATTNER, C., AND ADVE, V. LLVM A compilation framework forlifelong program analysis  transformation. In International Symposiumon Code Generation and Optimization, 2004. CGO 2004. 2004, IEEE,pp. 7586.40 LEE, Y.H., SONG, Y. W., GIRME, R., ZAVERI, S., AND CHEN, Y.Replay debugging for multithreaded embedded software. In Embeddedand Ubiquitous Computing EUC, 2010 IEEEIFIP 8th InternationalConference on 2010, pp. 1522.41 LI, L., AND WANG, C. Dynamic analysis and debugging of binarycode for security applications. In 4th International Conference onRuntime Verification RV 2013, Rennes, France, September 2427,2013. Proceedings 2013, vol. 8174 of Lecture Notes in ComputerScience, Springer, pp. 403423.42 MELEAR, C. Emulation techniques for microcontrollers. In Wescon97.Conference Proceedings 1997, pp. 532541.43 MONTENEGRO, G., KUSHALNAGAR, N., HUI, J., AND CULLER, D.Transmission of IPv6 packets over IEEE 802.15.4 networks RFC4944. Tech. rep., IETF, September 2007. httpwww.ietf.orgrfcrfc4944.txt.44 MULLINER, C., GOLDE, N., AND SEIFERT, J.P. SMS of DeathFrom Analyzing to Attacking Mobile Phones on a Large Scale. InProceedings of the 20th USENIX Security Symposium San Francisco,CA, USA, August 2011.45 NOHL, K., EVANS, D., STARBUG, S., AND PLOTZ, H. Reverseengineering a cryptographic RFID tag. In Proceedings of the 17th conference on Security symposium Berkeley, CA, USA, 2008, USENIXAssociation, pp. 185193.46 PEREZ, Y.A., AND DUFLOT, L. Can you still trust your network cardCanSecWest 2010.47 REDWIRE LLC. Econotag MC13224V development board w onboarddebugging. httpwww.redwirellc.comstorenode1.48 RENZELMANN, M. J., KADAV, A., AND SWIFT, M. M. SymDrivetesting drivers without devices. In Proceedings of the 10th USENIXconference on Operating Systems Design and Implementation Berkeley,CA, USA, 2012, OSDI12, USENIX Association, pp. 279292.49 SCHLICH, B. Model checking of software for microcontrollers. ACMTrans. Embed. Comput. Syst. 9, 4 Apr. 2010, 3613627.50 SCHMITT, P. H., AND WEISS, B. Inferring invariants by symbolicexecution. In Proceedings, 4th International Verification WorkshopVERIFY07 2007, B. Beckert, Ed., vol. 259 of CEUR WorkshopProceedings, CEURWS.org, pp. 195210.51 SCHWARTZ, E. J., AVGERINOS, T., AND BRUMLEY, D. All you everwanted to know about dynamic taint analysis and forward symbolicexecution but might have been afraid to ask. In Proceedings of the2010 IEEE Symposium on Security and Privacy Washington, DC, USA,2010, SP 10, IEEE Computer Society, pp. 317331.52 SLOWINSKA, A., STANCESCU, T., AND BOS, H. Howard A dynamicexcavator for reverse engineering data structures. In Proceedings of theNetwork and Distributed System Security Symposium, NDSS 2011, SanDiego, California, USA, 6th February  9th February 2011 2011.53 SONG, D., BRUMLEY, D., CABALLERO, J., JAGER, I., KANG, M. G.,LIANG, Z., NEWSOME, J., POOSANKAM, P., AND SAXENA, P. Bitblaze A new approach to computer security via binary analysis. In InProceedings of the 4th International Conference on Information SystemsSecurity 2008.54 TRIULZI, A. A SSH server in your NIC. PacSec 2008.55 WANG, T., WEI, T., GU, G., AND ZOU, W. TaintScope A ChecksumAware Directed Fuzzing Tool for Automatic Software VulnerabilityDetection. In IEEE Symposium on Security and Privacy 2010,pp. 497512.56 WEINMANN, R.P. Baseband attacks remote exploitation of memorycorruptions in cellular protocol stacks. In Proceedings of the 6thUSENIX conference on Offensive Technologies Berkeley, CA, USA,2012, WOOT12, USENIX Association, pp. 22.57 WELTE, H. Anatomy of Contemporary GSM Cellphone Hardware.58 WILLIAMS, M. ARMV8 debug and trace architectures. In System,Software, SoC and Silicon Debug Conference S4D, 2012 2012,pp. 16.59 XU, M., BODIK, R., AND HILL, M. D. A flight data recorder for enabling fullsystem multiprocessor deterministic replay. In Proceedingsof the 30th annual international symposium on Computer architectureNew York, NY, USA, 2003, ISCA 03, ACM, pp. 122135.60 ZADDACH, J., KURMUS, A., BALZAROTTI, D., BLASS, E. O., FRANCILLON, A., GOODSPEED, T., GUPTA, M., AND KOLTSIDAS, I. Implementation and implications of a stealth harddrive backdoor. InACSAC 2013, 29th Annual Computer Security Applications Conference,December 913, 2013, New Orleans, Louisiana, USA New orleans,UNITED STATES, 12 2013.16
