SYNTHESIS TECHNIQUESFORBUILTIN SELFTESTABLE DESIGNSLaNae Joy AvraCRC Technical Report No. 946CSL TR 94633July 1994CENTER FOR RELIABLE COMPUTINGComputer Systems LaboratoryDepartments of Electrical Engineering and Computer ScienceStanford UniversityStanford, CA 943054055Copyright  1994 by LaNae Joy AvraAll Rights ReservedSYNTHESIS TECHNIQUESFORBUILTIN SELFTESTABLE DESIGNSA DISSERTATIONSUBMITTED TO THE DEPARTMENT OF ELECTRICAL ENGINEERINGAND THE COMMITTEE ON GRADUATE STUDIESOF STANFORD UNIVERSITYIN PARTIAL FULFILLMENT OF THE REQUIREMENTSFOR THE DEGREE OFDOCTOR OF PHILOSOPHYLaNae Joy AvraJune 1994iABSTRACTHardware synthesis techniques automatically generate a structural hardware implementationgiven an abstract description of the behavior of the design.  Many different hardware designs canimplement a given behavioral description, a subset of which also meet specified requirementssuch as cost, performance, and testability.  Existing synthesis techniques typically use minimumcost or maximum performance as the primary criteria for selecting the best hardwareimplementation.  This dissertation describes new synthesis techniques whose primary objectiveis to satisfy requirements associated with a specific builtin selftest BIST architecture.The use of  BIST techniques design techniques that allow a circuit to test itself has longbeen recognized as a means to reduce system life cycle test and maintenance costs.  BISTprovides shorter test times and allows the use of lowcost test equipment during all stages of theproduct life production test, acceptance test, field maintenance, and failure diagnosis.  However,hardware overhead, performance degradation, and increased design time are often cited asreasons for the limited use of BIST.  When BIST techniques are used, they are often added afterthe system logic has been designed.  At this point, system logic features that may increase BISToverhead or reduce the effectiveness of the BIST operation are expensive to change.This dissertation describes new synthesis techniques that address two of the major issuesassociated with BIST  1 implementation costs due to increased design time, area overhead,increased power consumprtion, and performance degradation and 2 test effectiveness due tosystem logic design decisions.  Our synthesis procedures use criteria associated with thespecified BIST architecture to guide the generation of the system logic, allowing for designdecisions that reduce BIST overhead and improve BIST effectiveness.  In particular, the primaryobjective of our synthesis techniques is to generate lowcost, builtin selftestable designs that arefree of the types of system bistable dependencies that can reduce the effectiveness of theembedded, multiple input signature registers MISRs that are used to perform BIST operations.One type of system bistable dependency that can be a problem for BIST occurs in a selfadjacent register, where the register inputs are a function of its outputs.  To address this problem,we have developed a highlevel synthesis technique that minimizes the number of selfadjacentregisters in the generated design without increasing the latency of the design.  Some systembistable dependencies provide opportunities for sharing BIST and scan logic with system logic,reducing the area and improving the performance of the design.  We show that introducingcertain, beneficial types of scan dependence in the design can increase logic sharingopportunities and can improve BIST effectiveness.  Other BIST design techniques attempt toavoid all types of scan dependence.  We have developed a logic synthesis technique that analyzesthe system bistable dependencies, then arranges the bistables in the MISR to maximize beneficialiiscan dependence.  For data path logic, we have developed a new scan path architecture, calledorthogonal scan path, for which the shift direction is orthogonal to the shift direction intraditional scan paths.  We show that using an orthogonal scan path increases the number ofbeneficial scan dependencies between data path logic bistables.  We have implemented oursynthesisforBIST techniques in a computeraided design system, which serves as a platform forexperimentation with existing and future synthesisfortest techniques.iiiACKNOWLEDGMENTSI express my deepest appreciation to my adviser, Edward J. McCluskey, for his guidance,support, and instruction during my time at Stanford.  His suggestions have greatly enhanced boththe technical content and the presentation of this dissertation, and his enthusiasm for learning andfor teaching have been a constant source of inspiration.I am most grateful to my colleagues at the Center for Reliable Computing who have providedmany hours of discussions, manuscript editing, and companionship  Piero Franco, Hong Hao,Siyad Ma, Samy Makar, Samiha Mourad, Rob Norwood, Nirmal Saxena, Alice Tokarnia, andNur Touba.  I especially wish to thank the CRC visitors who have worked so diligently on theOdin software  JeanCharles Giomi, Francoise Martinolle, Laurent Gerbaux, Dave Brokaw, andGian Luigi Sartori.  Their contributions have greatly improved the quality and usefulness of thetool.  Many thanks, also, to Siegrid Munda for her expert administrative support.I would like to thank my associate adviser, Giovanni De Micheli, for his useful commentsand suggestions for developing the highlevel synthesis algorithms.  Thanks, also, to themembers of his group that provided support and technical advice  David Ku, Michiel Ligthart,Polly Siegel, and Jerry Yang.I greatly appreciate the industry feedback and software donations provided by Dave Coelhoand Rick Lazansky of Vantage Analysis Systems, Inc., and Jacob El Ziq of Compass DesignAutomation.Finally, I wish to thank my family.  I thank my husband, Rick, for his support,encouragement, and technical advice.  His expertise in the design, validation, testing, andmanufacturing of VLSI chips provided invaluable realworld perspective to the material in thisdissertation.  I am grateful to both Rick and my daughter, Tamsin, for their patience,understanding, and unconditional love, without which this work would not have been possible.Thanks, also, to my parents for instilling in me the selfconfidence necessary to pursue my goalsand for providing me with every opportunity to learn.This work was supported in part by Digital Equipment Corporation, LowEnd DiagnosticsGroup, and in part by the Innovative Science and Technology Office of the Strategic DefenseInitiative Organization and administered through the Office of Naval Research under ContractNos. N0001485K0600 and N0001492J1782, and in part by the National Science Foundationunder grant Nos. MIP8709128 and MIP9107760.ivTABLE OF CONTENTSAbstract ................................................................................................................................ iAcknowledgments.............................................................................................................. iiiList of Tables ..................................................................................................................... viList of Illustrations ............................................................................................................ vii1 Introduction................................................................................................................ 11.1 Motivation ............................................................................................................ 11.2 Contributions........................................................................................................ 31.3 Outline.................................................................................................................. 42 Embedded BIST Architectures ............................................................................. 52.1 Parallel BIST Architecture ................................................................................... 62.2 Circular BIST Architecture ................................................................................ 122.3 Reconfigurable Register Design ........................................................................ 133 Allocation and Binding for Parallel BIST........................................................ 163.1 HighLevel Synthesis Tasks............................................................................... 173.2 Register Conflict Graph ..................................................................................... 183.3 Implementation and Results ............................................................................... 203.4 Contributions...................................................................................................... 224 Synthesis for Scan Dependence.......................................................................... 244.1 Scan Dependence ............................................................................................... 254.2 Synthesis for Scan Dependence ......................................................................... 284.3 Implementation and Results ............................................................................... 304.3.1 Area and Delay Results .......................................................................... 314.3.2 Fault Simulation Results ........................................................................ 344.4 Contributions...................................................................................................... 355 Scan Dependence in Data Path Logic ............................................................... 365.1 Orthogonal Scan Path Architecture.................................................................... 375.2 Scan Dependence Functions in Data Path Logic ............................................... 375.3 Results ................................................................................................................ 395.4 Contributions...................................................................................................... 406 SynthesisforTest Design System ..................................................................... 41v6.1 Overview ............................................................................................................ 416.2 Design System Input and Output ....................................................................... 426.2.1 VHDL Descriptions ............................................................................... 436.2.2 Component Library ................................................................................ 446.3 Data and Control Flow Graphs .......................................................................... 446.4 HighLevel Synthesis Techniques ..................................................................... 477 Concluding Remarks ............................................................................................. 50References ......................................................................................................................... 52viLIST OF TABLESTable 21 Test session register configurations for design example in Hudson 87. ....... 8Table 31 Register binding algorithm for parallel BIST register conflict graph............ 21Table 32 Comparison of synthesis procedures on Tseng Tseng 86 and DiffEqPaulin 89a data flow descriptions. .............................................................. 22Table 41 Area and delay for shaded logic in Fig. 43 based on data in LSI 91. ........ 28Table 42 Scan dependence classification of decomposed Boolean equations.............. 29Table 43 Bistable characteristics for circular BIST benchmark circuits. ..................... 32Table 44 Area and overhead for areaoptimized circular BIST benchmark circuits. ... 32Table 45 Delay and overhead for delayoptimized circular BIST benchmark circuits. 33Table 46 Layout area overhead for areaoptimized circular BIST benchmark circuits. 33Table 47 Fault simulation results for circular BIST benchmark circuits. ..................... 35Table 51 System equations for data path registers that benefit from scan dependence. 38Table 52 Data path design examples with orthogonal scan path and circular BIST. ... 40Table 61 Example VHDL behavioral description ........................................................ 43Table 62 Example VHDL structural description of data path logic generated by Odin. 44viiLIST OF ILLUSTRATIONSFigure 11 Test scenario for life cycle of integrated circuit part. ...................................... 1Figure 12 Builtin selftest configuration......................................................................... 2Figure 21 Parallel BIST architecture................................................................................ 7Figure 22 Selfadjacent register implemented with CBILBO ........................................... 9Figure 23 LFSR and MISR configurations for Fig. 21 ................................................. 11Figure 24 Circular BIST architecture............................................................................. 13Figure 25 Reconfigurable register.................................................................................. 14Figure 26 MISR error capture capabilities ..................................................................... 15Figure 31 Highlevel synthesis example ........................................................................ 17Figure 32 Register conflict graph example .................................................................... 19Figure 33 Testability conflict edges ............................................................................... 20Figure 41 Embedded MISR with scan dependence ....................................................... 25Figure 42 Fault simulation results of BIST operation of circular BIST circuits withmaximum scan dependence. .......................................................................... 26Figure 43 Scan dependence solutions for Z2  Q1  f .................................................. 28Figure 44 Beneficial scan dependence implementations ............................................... 29Figure 51 Orthogonal scan path example....................................................................... 37Figure 52 Live variable motion ...................................................................................... 40Figure 61 Odin design system overview. ....................................................................... 42Figure 62 DCFG example .............................................................................................. 45Figure 63 Data flow graphs ............................................................................................ 46Figure 64 Highlevel synthesis example ........................................................................ 48Figure 65 Control logic state machine description for Fig. 62. .................................... 49 11 INTRODUCTION1.1 MOTIVATIONAn integrated circuit part such as a chip, multichip module, board, or system must bethoroughly tested in order to determine whether or not it is defective.  Different types of tests areapplied to the part at various times in its life cycle to detect different types of failures.  Forexample, the part manufacturer applies production tests to the part to determine whether or notthere are manufacturing defects, whereas the end user applies field tests to identify failurescaused by stressful conditions in the operating environment e.g., radiation, vibration orreliability problems within the part e.g., electromigration.  Figure 11 illustrates a possible testscenario that encompasses the entire life cycle of an integrated circuit part.  In the first phase oftesting, the manufacturer applies production tests in order to prevent parts with manufacturingdefects from being shipped to the customer.  Next, the customer applies acceptance tests todetermine whether or not the parts should be placed in field operation.  Acceptance tests identifyparts that have been damaged during shipping, or parts that dont meet customer specifications.Parts that pass acceptance testing are then assembled into systems and placed into fieldoperation.  Field tests are applied to a system that has failed in the field in order to identify thedefective component parts that must be replaced.  For each testing phase in this particularscenario, diagnostic tests are applied to rejected parts to determine the cause of failure in aneffort to improve the manufacturing process.ProductionTestDiagnosticTestShippedPartsEnd UserPartsRejected PartsTestProducedPartsGoodBadPassFailAcceptanceTestFieldTestGoodBadManufacturingProcessFigure 11 Test scenario for life cycle of integrated circuit part.The goal in any test scenario is to apply the most rigorous tests possible, tests for which thenumber of good parts that fail, but most importantly, the number of bad parts that pass calledtest escapes are minimized.  The quality of a test is a function of how many of the targetedfailures are detected by the test, how well the targeted failures represent actual defects, and howeasily the part can be tested.  As integrated circuit parts become more and more complex, dense,and inaccessible, rigorous testing becomes less feasible unless design practices are used thatallow for easier testing.  These design practices, called designfortestability DFT techniques,simplify the test development task by constraining the design to easytotest structures, therebymaking it easier to generate and apply tests that detect all of the targeted failures.  However,2rigorous testing can still be impractical due to the expensive external test equipment required toapply the tests.Builtin selftest BIST is a DFT technique that allows a part to test itself.  BIST techniquessuch as those described in  McCluskey 85, McCluskey 86, Bardell 87, and Abramovici 90have long been recognized as a means to reduce life cycle test and maintenance costs byembedding external tester features, such as test pattern generation TPG and output responseanalysis ORA, into the part that contains the circuit under test CUT Fig. 12.  BIST canprovide shorter test times than externallyapplied tests and allows the use of lowcost testequipment during all stages of the product life including system debug, production test, fieldmaintenance, and failure diagnosis.  Even though industry use of BIST techniques is becomingmore common Gelsinger 86, Lake 86, Nozuyama 88, Ratiu 90, Starke 90, Bardell 91,Illman 91, Preissner 92, Sinaki 92, Yokomizo 92, Bonnenberg 93, Broseghini 93,Gage 93, Langford 93, Patel 93,  area overhead, performance degradation, and increaseddesign time are often cited as reasons for the limited use of BIST.CircuitUnderTestCUTGoodBadTestModeIntegrated Circuit PartTestPatternGeneratorOutputResponseAnalyzerORATPGFigure 12 Builtin selftest configuration.Traditional design methods separate the tasks of system logic design design of the logic thatimplements the normal operation of the part and BIST logic design.  During the initial stages ofdesign, system logic issues take priority over BIST issues such as selection of the mostappropriate BIST technique for the system logic, BIST logic implementation, and evaluation ofthe BIST operation.  As the design progresses, timetomarket pressures often cause thepostponement of BIST design until the end of the design process at which point little time isavailable to address BIST issues, and any mistakes made are expensive to fix.  Automated BISTsynthesis techniques, where BIST logic is added or a BIST architecture is selected after thesystem logic has been designed Abadir 85, Zhu 88, are valuable in that they reduce the designtime and the number of design mistakes by automating the BIST logic design process.Unfortunately, earlier system logic design decisions can reduce the effectiveness and increase theoverhead of the implemented BIST technique.Hardware synthesis techniques automatically generate a structural hardware implementationgiven an abstract description of the behavior of the part.  Many different hardware designs canimplement a given behavioral description, a subset of which also meet specified requirementssuch as cost, performance, and testability.  Current research in hardware synthesis techniques3e.g., Brayton 87, McFarland 88, De Micheli 94 typically focuses on the use of minimumarea or maximum performance as the primary criteria for selecting the best hardwareimplementation.  Some synthesisfortestability techniques attempt to generate the lowestcost,highestperformance implementation that also meets certain specified testability requirementssuch as irredundant combinational logic Hachtel 89, Bryan 89 or robustly delayfault testablelogic Devadas 90, Jha 92.  Testable logic is a necessary, but not sufficient, condition for highquality BIST operation.  This dissertation describes new synthesisforBIST techniques that havethe primary objective of satisfying requirements associated with a specific BIST architecturewhen generating the system logic structural implementation.  Cost is minimized and performanceis maximized to the extent that BIST requirements are not compromised.  These new synthesistechniques address two of the major issues associated with generating selftestable designs  1increased implementation costs due to added design time, area overhead, and performancedegradation, and 2 reduced selftest effectiveness due to system logic design decisions.Considering BIST issues during system logic synthesis allows for the generation of system logicthat is optimized for a particular BIST architecture and that can be more effectively tested by theBIST operation.1.2 CONTRIBUTIONSThis dissertation describes new synthesis techniques that use the requirements of theimplemented BIST architecture to guide the synthesis of the system logic in order to improve theeffectiveness of the selftest operation and to reduce the BIST logic overhead.  In developingthese new techniques, we have focused on embedded BIST architectures because they provideopportunities for the sharing of system and test logic.  Logic sharing makes it possible to reducethe area overhead of the BIST logic and improve the performance of the generated design.  Inparticular, the following are the contributions of this dissertation We have developed and implemented a new register allocation and binding algorithm forhighlevel synthesis that generates designs with a minimum number of selfadjacent registersAvra 91.  This technique is used for parallel BIST architectures. We have formalized the concept of scan dependence in embedded BIST architectures and havepresented fault simulation data showing that, if ignored, scan dependence can significantlyreduce the effectiveness of the BIST operation Avra 94a. We have identified certain types of scan dependence that can be beneficial to the design andhave developed new output response analysis ORA structures that take advantage of themAvra 93, Avra 94a. We have developed and implemented a new synthesis for scan dependence technique thatmaximizes the amount of beneficial scan dependence in the design Avra 93, Avra 94a.4 We have developed a new scan path architecture that increases the amount of beneficial scandependence in data path logic Avra 92. We have implemented a synthesisfortest computeraided design tool that includes thesynthesis techniques described in this dissertation and generates a selftestable design given abehavioral VHDL description of the design Avra 90, Avra 94b.1.3 OUTLINEThis dissertation is organized as follows.  In Sec. 2, we describe in detail the operation andimplementation of two embedded BIST  architectures  parallel BIST and circular BIST.  ParallelBIST is the target BIST architecture of the synthesis technique described in Sec. 3, and circularBIST is the target architecture of the synthesis techniques described in Secs. 4 and 5.  We alsodescribe a register design that can be used in the parallel and circular BIST architectures.  We usethis register design to illustrate the BIST concepts and design techniques presented in theremainder of the dissertation.  In general, each section discussing the contributions of thisdissertation Secs. 36 is a summary of material previously published by the author and includedin Appendices IIV.  Section 3 contains a description of a highlevel synthesis technique thatgenerates the system logic for a parallel BIST architecture.  In Sec. 4, we define scan dependenceand illustrate its advantages and disadvantages with a simple example.  We then describe asynthesis technique that arranges the system bistables into MISRs such that beneficial scandependence is maximized.  We illustrate the technique using the circular BIST architecture.  InSec. 5, we show that beneficial scan dependence can be increased in data path logic when anorthogonal scan path configuration is used.  Section 6 is an overview of the synthesisfortestcomputeraided design tool the implements the described synthesis techniques.  The tool isintended to be a platform for experimentation with existing and future test synthesis andsynthesisfortest techniques.  Section 7 concludes this dissertation.52 EMBEDDED BIST ARCHITECTURESBIST techniques are implemented by including a test pattern generator TPG and outputresponse analyzer ORA in the part e.g., chip, multichip module, board that contains thecircuit under test CUT.  During BIST operation, the TPG applies test patterns to the inputs ofthe CUT and the ORA captures the response of the CUT to those test patterns.  Typically, theTPG and ORA are implemented such that they automatically generate patterns and analyzeresponses at test time so that the test pattern and test response storage requirements areminimized.  Embedded BIST architectures use reconfigurable system bistables to implementboth the normal system operation and the BIST TPG and ORA operations.  Since the BIST logicis combined with the system logic, opportunities exist for synthesis technique to generatehardware that can be shared by both the system and test operations, resulting in improvedperformance and reduced cost.  However, in addition to system logic issues such as performanceand cost, the synthesis technique must be capable of addressing issues that affect the quality ofthe BIST operation, issues such as selftest time, and TPG and ORA effectiveness.  We discussthese issues in this section.Most BIST architectures use pseudorandom pattern generators such as linear feedback shiftregisters LFSRs or weighted random pattern generators Waicukauski 89 to perform TPGoperations.  The TPGs are called pseudorandom because, while they generate patterns withcharacteristics that are similar to randomlygenerated patterns, their behavior is deterministic.The test is therefore repeatable, and the results of the test can be compared with expected results.In order to test for all possible combinational faults e.g., single and multiple stuckat faultswithin an ninput cone of combinational logic in the CUT, where a cone of logic is delimited bystarting at a combinational logic output either a primary output or a bistable input and tracingbackwards through the gates to each input either a primary input or a bistable output, a TPGmust be capable of applying all 2n possible test patterns.  To test for patterndependent faultsHao 91, delay faults, or faults that cause combinational logic to behave sequentially, the TPGmay be required to generate multiple sequences of the 2n possible patterns.  Faults that affectmore than one cone of logic e.g., a bridging fault between the inputs of two logic gates that arein different cones can be detected if a single TPG covers multiple cones.  We evaluate the TPGsgenerated by our synthesis techniques in terms of their ability to generate 2n different testpatterns for each ninput cone of logic.  Even though it may be determined that not all of the 2ntest patterns need to be applied during BIST operation, it is difficult to determine a priori whichsubset of test patterns will be required to provide a high fault coverage test for each CUT.Therefore, the TPGs must be designed such that they could generate all 2n different test patternsif necessary.  This is known as the philosophy of possible exhaustion Bardell 87.  Also, if all62n test patterns can be generated, one can use probabilistic models, based on the number of testpatterns applied and the detectabilities of the faults in the CUT, to estimate the fault coverageprovided by the TPG McCluskey 88, thus avoiding expensive and timeconsuming faultsimulations.An ideal ORA is capable of analyzing the response of each test pattern applied to the CUT.In practice, of course, this is not feasible for a builtin ORA.  Instead, most BIST architecturesuse ORAs, such as multipleinput signature registers MISRs, that compact the test response,resulting in a loss of information.  Thus, under certain error conditions, the test response of afaulty CUT may be indistinguishable from the test response of a faultfree CUT, a phenomenonknown as aliasing.  Our synthesis techniques assume that MISRs are used as the ORAs in theimplemented BIST architecture and attempt to minimize the amount of aliasing in those MISRs.In this section, we describe two embedded BIST architectures, parallel BIST and circularBIST, and discuss BISTrelated synthesis issues for each.  In Sec. 2.1, we describe parallel BIST,emphasizing oftenoverlooked implementation complexities that must be addressed by thesynthesis technique so that it generates a design that performs a highquality BIST operation.The synthesis technique described in Sec. 3 generates designs with parallel BIST architectures.The synthesis techniques described in Secs. 4 and 5, though applicable to all BIST architecturesthat use embedded MISRs, generate designs that use the circular BIST technique.  We describethe assumed circular BIST architecture in Sec. 2.2.   In Sec. 2.3, we describe one possibleimplementation of a reconfigurable register design for embedded BIST architectures.  Theregister is configured as a normal parallel load register for system operation.  During BISToperation, it is configured as either a maximumlength LFSR for test pattern generation or as aMISR for output response analysis.2.1 PARALLEL BIST ARCHITECTUREThe parallel BIST architecture Konemann 80 is an embedded BIST architecture in whichsystem registers are reconfigured to perform either LFSR or MISR operations during BIST.   Thebuiltin logic block observer BILBO register Konemann 79 is often used to implement thesystem registers in parallel BIST architectures.  A possible implementation of the BILBO registeris described in detail in Sec. 2.3.  Variations of the parallel BIST architecture are discussed inMcCluskey 81, Krasniewski 85, Hudson 87.Figure 21 illustrates how the parallel BIST architecture is used to test a block of data pathlogic that consists of five registers R1R5, five combinational logic units CLU1CLU5,primary input signals PI, and primary output signals PO.  During normal operation Fig. 21a, the system registers are configured to load data from the outputs of the CLUs.  Prior toperforming BIST operation, the system bistables must begin in a known state.  This can be7accomplished by configuring the registers into a scan path and shifting in known data or byconfiguring the registers to perform a reset operation.  During BIST operation, the registers areconfigured as either LFSRs or MISRs.  At each clock cycle, pseudorandom test patterns areapplied to the inputs of the CLUs by the LFSRs at the same time that the test results the outputsof the CLUs are compacted in the MISRs.  Figures 21b and 21c represent two different testsessions of the BIST operation, where each test session consists of a unique mapping of registersto LFSRs and MISRs.  CLU3, CLU4, and CLU5 are tested during the first test session Fig. 21b, and CLU1 and CLU2 are tested during the second test session Fig. 21c.  After each testsession, the registers are configured into a serial shift path so that the test results can be shiftedout and compared with expected results.  This comparison can be performed either by externaltest equipment or by BIST control logic that may be included as part of a test access portcontroller IEEE 90.  The BIST control logic also generates signals that control theconfiguration of the system registers.R1R3CLU3PI PI R2CLU4 CLU5PIR4 R5CLU2PI PIPOCLU1CLU3PI PICLU4 CLU5PICLU2PI PIPOCLU1CLU3PI PICLU4 CLU5PICLU2PI PIPOCLU1LFSRMISR MISR MISRMISRLFSRMISRLFSR LFSRLFSRa b cFigure 21 Parallel BIST architecture  a normal operation b first test sessionconfiguration c second test session configuration.    One advantage of the parallel BIST architecture is that it supports atspeed selftestoperation  a new test pattern is applied to the CUT at each clock cycle.  Atspeed operationmeans that the parallel BIST technique may be able to detect some delay faults.  Anotheradvantage of this technique is that, since each system register can be reconfigured as either anLFSR or a MISR, multiple CLUs can be tested in parallel, reducing the total selftest time.We define an ideal parallel BIST architecture as one for which the system bistables can bearranged into LFSRs and MISRs such that, for each ninput CLU in the design, 2n different testpatterns can be applied to the CLU inputs during the same test session that the CLU outputs arecaptured in a MISR.  Unfortunately, due to the interconnectedness of the system bistables intypical designs, many test sessions may be required to test all of the CLUs in an ideal parallelBIST architecture.  For example, register interconnection data and test session configurations fora twentythree register, parallel BIST design is provided in Hudson 87.  This information is8shown in a different form in Table 21, which lists which registers, numbered 1 through 23, areconfigured as LFSRs and MISRs for each test session.  We assume that any CLU feeding aregister that is configured as a MISR during a given test session is tested during that test session.For example, during test session 10, the CLUs that feed registers 9 and 16 are tested by testpatterns supplied by registers 10, 12, and 17.  Registers 9, 16, 10, and 12 in Table 21 could beinterconnected in the same manner as registers R4, R3, R1, and R2, respectively, in Fig. 21a.The design requires a minimum of twelve different test sessions, where an average of 1.75registers are configured as MISRs and 13.9 registers are configured as LFSRs in each testsession.  The high number of test sessions corresponds to the low degree of selftest parallelismin the design.Table 21 Test session register configurations for design example in Hudson 87.Test Session MISRs LFSRs1 3,13,17 1,2,4,5,6,7,8,9,10,11,12,14,15,16,19,20,21,22,232 19,20 1,2,4,5,6,7,8,9,10,11,13,14,15,16,21,22,233 23 1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,19,20,21,224 6,10 1,2,4,5,7,8,9,11,13,14,15,16,19,20,21,22,235 5,11 1,2,4,6,7,8,9,10,13,14,15,16,20,21,22,236 4,12 1,2,3,7,8,9,10,11,13,14,15,16,17,19,20,21,22,237 18 1,2,4,6,7,8,9,10,11,12,13,14,15,16,19,20,21,22,238 14 1,2,4,7,8,9,10,11,13,15,16,20,21,22,239 7,8 1,2,9,10,13,14,15,16,20,21,22,2310 9,16 10,12,1711 1 13,20,21,2312 2,15 1,13,14,16,20,21,22,23Selfadjacent register configured as a MISR during test.One of the barriers to implementing an economical parallel BIST architecture is selfadjacentregisters.  A selfadjacent register, marked with an asterisk in Table 21, is one in which at leastone output of the register feeds through either a direct connection or combinational logic to atleast one input of the same register see register R2 in Fig. 21a.  If the selfadjacent register isconfigured as an LFSR in order to supply test patterns to the CLU during BIST operation, theresponse of the CLU cannot be observed.  A selfadjacent register that is implemented with aconcurrent builtin logic block observer CBILBO design as described in Wang 86 is able tosimultaneously perform both the LFSR and MISR operations because it has two sets of bistables.CBILBO register operation for a selfadjacent register is illustrated in Fig. 22.  During normaloperation, only one of the sets of CBILBO bistables is used Fig. 22a.  During BIST operation,the set of bistables that drives the system logic is configured into an LFSR, and the other set of9bistables is configured into a MISR.  Unfortunately, the prevalence of selfadjacent registerscombined with the higher hardware overhead for CBILBOs CBILBO registers areapproximately 1.75 times the size of BILBO registers  greatly increases the BIST overhead forthe design in Table 21.  When CBILBOs are not used, a selfadjacent register can be configuredas a MISR during BIST operation.  The MISR then provides test patterns to the CLU at the sametime that it captures the response of the CLU e.g., register R2 configured as a MISR in Fig. 21c.  Since the state of the selfadjacent MISR depends upon its previous state and the CLU,there is no guarantee that it can generate an exhaustive set of test patterns for the CLU.  Also, theCLU can adversely affect the output response capabilities of the selfadjacent MISR, as wasnoted by Hudson Hudson 87 for the case when a shift operation is implemented in the CLU .We discuss the effect of the CLU on the MISR output response capabilities in detail in Sec. 4.RaRbCLU CLUMISRLFSRa bFigure 22 Selfadjacent register implemented with CBILBO  a normal operation b BISToperation.In an effort to solve this problem, highlevel synthesis techniques have been proposed thatgenerate data path logic with a minimum number of selfadjacent registers Avra 91,Papachristou 91, Mujumdar 92.  These synthesis techniques are among the first to use BISTcriteria to guide the highlevel synthesis of the system logic.  Highlevel synthesis techniquesthat only consider area and performance during synthesis tend to generate system logic with alarge number of selfadjacent registers.  For example, five of the eight registers in the Tsengexample generated by the synthesis technique described in Tseng 86 and four of the fiveregisters in the DiffEq example generated by the synthesis technique described in Paulin 89aare selfadjacent.  The synthesis technique described in Avra 91 generated system logic withonly one selfadjacent register for both of these examples.  For both examples, when CBILBOregisters are used for the selfadjacent registers, the synthesisforBIST technique generatedlowercost parallel BIST implementations than the synthesis techniques that do not considerBIST.Another implementation difficulty of the ideal parallel BIST architecture is determining thearrangement of system bistables into LFSRs during each test session so that each CLU testedduring that test session could receive an exhaustive set of test patterns.  The simplestarrangement is to configure each nbit system register as a maximumlength LFSR, which10generates 2n1 different test patterns logic can easily be added to the LFSR so that it generatesall 2n different patterns McCluskey 86.  This is not an acceptable solution, however, when asingle CLU is fed by multiple system registers see CLU2 in Fig. 21.  In this case, the totalnumber of different test patterns, P, that can be applied to the CLU is the least common multipleof the periods of the individual LFSRs.  For n maximumlength LFSRs, where LFSR i has bibistables and b1  b2  ...  bn 2bn  1  P  2b1  1 2b2  1 2b3  1 ... 2bn1  1P  2b1b2b3...bn1The maximum value for P can only be achieved when the periods of the n LFSRs are mutuallyprime.  In data path logic, where a single CLU is often fed by n bbit system registers, we havethe worstcase scenarioP  2b  1  2nbA better solution for providing a nearly exhaustive set of test patterns to each CLU is toconfigure the bistables on the inputs of each CLU being tested during a given test session into asingle, maximumlength LFSR.  Figure 23 illustrates this solution by showing one way toconfigure the registers of Fig. 21 into LFSRs and MISRs for each of the two required testsessions.  During the first test session Fig. 21b and 23a, registers R1 and R2 are configuredinto a single maximumlength LFSR in order to provide an exhaustive set of test patterns toCLU4.  Registers R3, R4, and R5 are configured into a MISR to capture the output responses ofCLU3, CLU4, and CLU5.  During the second test session Fig. 21c and 23b, R2, which isimplemented with a CBILBO register, is configured with R3, R4, and R5 into a single LFSR inorder to test CLU2.  The second set of R2 bistables are configured with R1 into a MISR, whichcaptures the output responses of CLU1 and CLU2.  The signal lines in Fig. 23 represent theadditional interconnections required for BIST operation.  Each block of feedback logic f1, f2,and f3 consists of a tree of one or more exclusiveOR gates that implements the polynomial ofthe associated LFSR or MISR.  The arrangement of the registers during BIST operation R1 R2  R3  R4  R5 was chosen because it minimizes the amount of BIST interconnectionand feedback logic.11MISRLFSRR1 R5R3 R4R1 R2 R5R3 R4R2f2MISR LFSRa bf1f1f3Figure 23 LFSR and MISR configurations for Fig. 21  a first test session b second testsession.Unfortunately, the parallel BIST architecture illustrated in Fig. 23 can, in practice, beextremely complicated and costly to implement.  In our discussion, we have ignored how toconfigure LFSRs to drive the input signals primary input signals and control signals of the datapath logic during BIST operation.  Considering these signals could greatly complicate theconfigurations of the LFSRs during each test session, particularly if a single state machinegenerates all of the control signals for the data path logic.  Also, Fig. 21 is a relatively simpledata path design example.  More complicated data path designs, or nonBIST scan patharrangement requirements, such as minimizing test time for deterministic stuckat tests asdescribed in Gupta 91 and Narayanan 92, could greatly increase both the hardware overheadand the total selftest time for the parallel BIST architecture.  Table 21 provides a hint of howcomplicated the parallel BIST architecture could be for a real design.  For example, test sessionseven in Table 21 shows that the combinational logic feeding register 18 is fed by the outputs of19 different registers.  When these 19 registers are configured into a single, maximumlengthLFSR, 2b1 different test patterns are applied to the CLU, where b is the total number of bistablesin the 19 registers.  Subsets of these 19 registers must be combined with other registers to createthe LFSRs for the remaining eleven test sessions.  As the number of test sessions increases, theBIST control logic and the LFSR interconnection logic for the design can become verycomplicated.The synthesis technique described in Sec. 3 addresses one of the implementation difficultiesof parallel BIST architectures by generating system logic that has a minimum number of selfadjacent registers.  However, the data in Table 21 shows that complicated registerinterconnections in the system logic can greatly complicate the LFSR configurations required fora parallel BIST architecture.  This issue must be addressed by synthesis techniques beforeextensive use of the parallel BIST architecture is practical.  To that end, we have investigatedmore simple TPG and ORA configuration schemes, such as those found in the circular BIST12architecture.  The circular BIST architecture is described in Sec. 2.2 and new synthesistechniques for this architecture are described in Secs. 4 and 5.2.2 CIRCULAR BIST ARCHITECTURECircular BIST is a low overhead, embedded BIST architecture that provides atspeed selftestoperation.  Circular BIST has lower area overhead than parallel BIST because it has simplerBIST control logic and interconnection logic, which also simplifies and speeds theimplementation process.  The circular BIST architecture was first introduced as simultaneousselftest SST by Bardell and McAnney Bardell 82.  It was later described in slightly differentforms by Stroud Stroud 88 and Krasniewski Krasniewski 89.  Figure 24 illustrates thecircular BIST architecture for the data path logic in Fig. 21a.  During BIST operation, all systembistables are configured into a single MISR as shown in Fig. 24b.  At each clock cycle duringBIST operation, the outputs of all CLUs in the design are captured in a single MISR, and theoutputs of the MISR provide test patterns to the CLUs.  The circular BIST architecture requireslittle BIST control logic since there is only one test session during which a single MISRsimultaneously performs the TPG and ORA operations.  The problems of register selfadjacencyand LFSR configuration discussed in Sec. 2.1 for the parallel BIST architecture are notapplicable to circular BIST.  However, since the CLUs in the circular BIST architecture aresimultaneously tested by a single, selfadjacent MISR, the pattern generation and responseanalysis capabilities of selfadjacent MISRs must be analyzed to ensure an effective selftestoperation.  These issues are discussed in Sec. 4.1 and are addressed by our synthesis for scandependence techniques described in Secs. 4.2 and 5.Since slightly different versions of the circular BIST architecture have been described inBardell 82, Stroud 88, and Krasniewski 89, we state here our assumptions concerning thecircular BIST architecture implemented in our synthesized designs.  First, we assume that allbistables in the design are included in the MISR during BIST operation.  Other architecturesKrasniewski 89, Stroud 88 allow some bistables to be configured in the normal mode duringBIST operation in order to reduce the BIST overhead, but there is evidence that this can reducethe observability of the logic feeding those bistables Kim 88.  Second, we assume that everysystem bistable is an edgetriggered flipflop that can be configured to perform normal, shift, andMISR operations.  A reset mode of operation is optional since the bistables can be controlledthrough the shift mode of operation.  Using flipflops simplifies the discussion of the synthesistechniques.  Similar synthesis techniques can be applied if the doublelatch, levelsensitive scandesign method is used to implement the system bistables as described in Bardell 82, but we donot discuss these techniques in this dissertation.  Finally, we assume that the MISR feedbacklogic is simply a direct connection from the output of the last bistable in the MISR to the input of13the first bistable.  A reconfigurable register design that supports these operations is described inSec. 2.3. CLU3PI PICLU4 CLU5PICLU2PI PIPOCLU1R1 R2MISRR1 R5R3 R4R2fR3 R4 R5a bFigure 24 Circular BIST architecture  a normal operation b BIST register configuration.2.3 RECONFIGURABLE REGISTER DESIGNThe distinguishing characteristic of embedded BIST architectures is that the system bistablescan be configured to perform both normal operation parallel load as well as test operations suchas serial shift, TPG, and ORA.  The test operations that must be supported by each bistabledepend upon the embedded BIST architecture used.  The Circular SelfTest Path architectureKrasniewski 89, for example, does not require that the system bistables perform a serial shiftoperation.  The builtin logic block observer BILBO register Konemann 79 is often used inembedded BIST architectures and implements normal, synchronous reset, serial shift, TPG, andORA modes of operation.Figure 25 illustrates a reconfigurable register design that can be used for both the parallelBIST and circular BIST architectures.  The register implementation is not necessarily optimal.Its purpose is to more easily illustrate the BIST operations.  In Secs. 4 and 5, we use Fig. 25 toillustrate scan dependence and our synthesis techniques.  Figure 25a shows the registerconfiguration, where each bistable in the register is implemented as shown in Fig. 25b.  Thebistable could also be implemented with a dualport latch, such as the design specified for theSST technique Bardell 82.  The Qi1 input to the first bistable bistable B1 in the register isdetermined by BIST mode select signal BIST, and is either the scan data input SDI signal forshift operation or the output of the MISR feedback logic for MISR operation or LFSR operation.For circular BIST architectures, since a separate TPG operation is not required, signal BIST canbe replaced by signal T1, resulting in four possible modes of operation  reset, shift, normal, andMISR.  Test mode select signals T1 and T2 determine the D input to each bistable in the register,as specified in Fig. 25c, where Zi is the system logic input to bistable Bi.14NormalMode0 ResetShift orMISRT1Z  T20001101101MUXGQBISTT1T2ZQZQZQ 1DC1T1T2SDOZ 1 2 i n1 2 i nDiZiiZ iQ iQi1Q i1Qi1Di01LFSRSDIB 1 B 2 B i Bna b cFigure 25 Reconfigurable register  a bistable interconnections b reconfigurable bistablec modes of operation.For circular BIST architectures and for parallel BIST architectures with selfadjacentregisters that are not implemented with CBILBOs i.e., for selfadjacent MISRs, the MISRoperation must simultaneously provide both sufficient test patterns and accurate output responseanalysis.  It has been proven that, when the Z inputs are independent of the state of an nbitMISR, the MISR generates test patterns that are similar in behavior to random patternsKrasniewski 89, Kim 88.  Specifically, as P goes to infinity, where P is the number of testpatterns applied during BIST operation, the probability of the MISR being in any one of the 2npossible states is 2n.  The Z inputs to a selfadjacent MISR, however, are a function of the stateof the MISR.   Simulation results presented in Kim 88 and Stroud 88 indicate that the MISRtest pattern characteristics are not significantly different from random patterns when the Z inputsdepend upon the state of the MISR.  It is not clear whether a MISR implemented with a primitivepolynomial Kim 88 produces any better patterns than a MISR implemented with a single Qnfeedback connection Krasniewski 89.Figure 26a shows a portion of the reconfigurable register during MISR operation to illustrateits error capture capabilities.  During MISR operation, the input to each bistable, Di, is theexclusiveOR of the output of the previous bistable in the MISR, Qi1, and the system logic inputto the bistable, Zi.  At each clock cycle, an error in either Zi or Qi1 is observable at Di i.e.,captured in bistable Bi regardless of the state of the errorfree signal.  Figure 26b is a truth tablefor signals Di Di  Qi1  Zi and DEi DEi  QEi1  Zi, where QEi1 is the faulty version ofsignal Qi1.  Figure 26b shows that, regardless of the state of signal Zi, Di differs from DEi, sowhen Zi is faultfree, an error in Qi1 is always captured in bistable Bi.  Because the exclusiveORoperation is symmetric, the same is true when Qi1 is faultfree and Zi is faulty.  However, errorsin both signals Zi and Qi1 in a single clock cycle are not observable at Di.  Thus, once capturedin a bistable of the MISR, an error is transferred from one bistable Qi1 to the next Qi at eachclock cycle as long as it is not masked by a simultaneous error in the corresponding system logic15input signal Zi.  In addition, the error may be transferred to other bistables in the MISR throughthe MISR feedback logic or, if the MISR is selfadjacent, through the system logic. 1DC11DC1Q i1Di 00111100010101101001QE DEZ i DiZ iQ i1 i1 iSystemLogica bFigure 26 MISR error capture capabilities  a MISR configuration b error response.163 ALLOCATION AND BINDING FOR PARALLEL BISTThe interconnection of system logic registers can greatly affect the area overhead of parallelBIST architectures and the effectiveness of the TPGs and ORAs as was shown in Sec. 2.1.System register interconnect is an issue that must be addressed during highlevel synthesis, whenvariables in the behavioral description are mapped to specific registers in the structuraldescription.  Little work has been done in the area of highlevel synthesisfortestability.Recently, highlevel synthesis algorithms for nonscan and partialscan architectures have beengiven Lee 93.  These algorithms are not wellsuited for parallel BIST architectures, however,because they favor the generation of selfadjacent registers since selfadjacent bistables, whichcan occur in selfadjacent registers, are considered easier to test by sequential automatic testpattern generation tools Cheng 89.  Highlevel synthesis procedures that discourage thegeneration of selfadjacent registers are described in Avra 91, Papachristou 91, andMujumdar 92.  The technique described in Papachristou 91 generates data path logic with noselfadjacent registers, but may increase the latency of the functional operation in order to dothis.  The module and register binding algorithm given in Mujumdar 92 discourages, but doesnot prevent, the generation of selfadjacent registers.This section provides an overview of our highlevel synthesisforBIST technique, firstdescribed in Avra 90, that takes as input a scheduled data flow description of the system logicand, without increasing the latency of the description, generates a parallel BIST data pathstructure with a minimum number of selfadjacent registers.  A more detailed description of thetechnique is given in Avra 91.  The synthesis procedure consists of first mapping the input dataflow description to a register conflict graph.  The nodes of the graph are then colored using anode coloring algorithm that is guided by design implementation costs such as interconnectionarea and multiplexer size.  Finally, the colored graph is mapped to hardware.  A simple constraintimposed on the register conflict graph prevents the register binding algorithm from creating selfadjacent registers in the generated data path logic, thereby reducing the area overhead of theparallel BIST architecture when selfadjacent registers are implemented with CBILBO registers.We also incorporate a novel register allocation technique that allows the register bindingalgorithm increased flexibility in synthesizing an efficient hardware implementation.Section 3.1 is background material and provides an overview of the operations performedduring highlevel synthesis.  In Sec. 3.2, we describe the register conflict graph, focusing on thefeatures that make our highlevel synthesis procedure unique.  Section 3.3 describes the registerbinding algorithm that is implemented in our synthesis tool and compares designs generated byour tool with designs generated by other synthesis techniques.  Section 3.4 summarizes ourcontributions in highlevel synthesis for parallel BIST.173.1 HIGHLEVEL SYNTHESIS TASKSRegister binding is one of several tasks performed during highlevel synthesis.  We use Fig.31 to illustrate the highlevel synthesis operations of scheduling, allocation, and binding.  Moredetailed information on these and additional highlevel synthesis operations can be found in DeMicheli 94.  Highlevel synthesis operations are typically applied to a data flow graph Fig. 31b that represents a behavioral description of the system operation Fig. 31a.  Nodes and edgesin the data flow graph correspond to operations and variables, respectively, in the behavioraldescription.  Scheduling consists of assigning the operations in the data flow description toexecute in certain clock cycles.  For example, Fig. 31b shows that two addition operations areperformed in the first clock cycle, while one addition and one multiplication are performed in thesecond clock cycle.  Clock cycle boundaries in Fig. 31b are delimited by dotted lines.  Thescheduling algorithm may generate a schedule that, given a hardware constraint, executes in aminimum number of clock cycles or that, given a timing constraint, requires a minimum numberof function blocks to perform the operations in the behavioral description.  Allocation consists ofdetermining the number of hardware resources necessary to implement the data flow description.Two addition function blocks for 1 and 2, one multiplication function block, and fiveregisters represented by squares on the edges of the graph have been allocated for the data flowgraph in Fig. 31b.  During binding, operations in the data flow graph are mapped to specificinstances of hardware function blocks ADD1, ADD2, and MULT in Fig. 31c, variables thatexist at clock cycle boundaries are mapped to registers rectangles in Fig. 31c, and multiplexersand buses are generated to accommodate the required flow of data.  Our register allocation andbinding techniques differ from existing techniques in two ways  1 we incorporate a simpleconstraint in the binding of variables to registers such that the number of selfadjacent registers isminimized, and 2 to compensate for this constraint, we incorporate a register allocationtechnique that increases the flexibility of the register binding procedure.ADD1muxADD2 MULT 1 21X Ya b c d e a b c d eX Ymux muxt  c  dX  a  b  tY  t  ea b cFigure 31 Highlevel synthesis example  a data flow description b scheduled, bounddata flow graph c data path logic.183.2 REGISTER CONFLICT GRAPHOur register allocation and binding operations are applied to a register conflict graph datastructure.  Each node in the register conflict graph represents an edge from the data flow graphthat crosses a clock cycle boundary.  An edge between two nodes in the register conflict graphindicates that the two variables associated with those nodes cannot be stored in the same register.Register binding consists of assigning a color to each of the nodes in the register conflict graphsuch that adjacent nodes have different colors.  All nodes with the same color can be mapped tothe same register in the final implementation.  This is analogous to the techniques described inTseng 86 and Paulin 89b, where a register compatibility graph is created, clique partitioningis performed, and all nodes in the same clique are assigned to the same register.  Figure 32billustrates the typical conflict graphbased register allocation and binding procedures for the dataflow graph of Fig 31b.  Figure 32a is the same data flow graph as Fig. 31b except that theregister binding information colored squares on clock cycle boundaries has been removed.Nine nodes, corresponding to data flow graph variables a, b, c, d, e, s, t, X, and Y, are created inthe register conflict graph.  Edges are added between nodes whose variables cannot be assignedto the same register.  For example, variables a, b, c, d, and e all exist at the first clock cycle in thedata flow graph and must therefore all be assigned to different registers, so their nodes form aclique in the register conflict graph.  One possible coloring of the register conflict graph is shownin Fig. 32b, where the different colors correspond to different registers in the structuralimplementation.We define register allocation as the method used to determine how many nodes to create inthe register conflict graph.  Our register allocation procedure is illustrated in Fig. 32c and isunique in that it creates multiple nodes in the register conflict graph for a single variable in thedata flow graph under three conditions  delayed values, multiple targets, and multiple sources.We do this in order to increase the flexibility of the register binding algorithm in mappingvariables to nonselfadjacent registers.  For the delayed values situation, a node is added to theregister conflict graph for each clock cycle in a variables lifetime.  This means that the variablecould be transferred from one register to another rather than held in a single register for its entirelifetime as most register allocation techniques require.  The delayed values allocation scheme isillustrated by nodes e and De in Fig. 32c, which both represent variable e from the data flowdescription.  Note that there is no edge between nodes e and s since they exist at different clockcycles, but there is an edge between nodes De and s.  The delayed values consideration is anextension of the technique first introduced in Paulin 89b, where it was shown that when aregister is allocated for the first clock cycle of a variables lifetime, and another register isallocated for the remaining clock cycles of its lifetime, interconnect cost can sometimes bereduced.  Multiple targets means that a node is added to the register conflict graph for each19output of an operation that crosses a clock cycle boundary.  For example, nodes t1 and t2 in Fig.32c both represent the variable t in Fig. 32a.  Node t1 represents the input to the additionoperation, and node t2 represents the input to the multiplication operation.  No edge is addedbetween nodes t1 and t2 because they could be assigned to the same register since they representthe same variable.  Multiple sources, which is not shown in Fig. 32c, is similar to multipletargets except that a node is added to the conflict graph for each operation input that represents asingle variable.  This situation occurs when the input to an operation is assigned a value inmultiple, mutuallyexclusive branches of a conditional statement.  The multiple sources situationis described in detail in Avra 91. 1 21Det1abcde YXa b c d eDetsX Y stabcde YXst2a b cFigure 32 Register conflict graph example  a data flow graph from Fig. 31b  b typicalregister conflict graph c our register conflict graph.Conflict edges are edges in the register conflict graph that specify that the variablesassociated with the adjacent nodes cannot be assigned to the same register.  We call the edgesshown in the register conflict graphs in Fig. 32 schedule conflict edges because the conflict thatexists between the adjacent nodes is due to the schedule specified for the data flow graph.Schedule conflict edges therefore maintain the functionality of the system logic.  Our registerbinding algorithm is unique in that we include an additional type of conflict edge in the registerconflict graph that maintains the testability of the generated system logic.  Testability conflictedges are added between two nodes when one node represents a variable that is an input to afunction block and the other node represents a variable that is an output of the same functionblock.  For example, Fig. 33b is the register conflict graph for Fig. 33a, showing just thetestability conflict edges for the three function blocks, 1, 2, and .  Note that an edge is addedbetween nodes a and s and between nodes a and X because both s and X are outputs of the samefunction block.  Node e has no adjacent testability conflict edges because it is not an input or anoutput of any function block.  Testability conflict edges require that the inputs and the outputs ofa function block be assigned to different registers, and this guarantees that no selfadjacentregisters will be synthesized.  One situation requires the use of a selfadjacent register  when twooperations in consecutive clock cycles in the data flow graph are assigned to a single functionblock and the output of one operation is the input to the other see variable s in Fig. 33a.  In thiscase, the node that is associated with both the input and the output of the function block is20identified by a selfedge in the register conflict graph and must be assigned to a CBILBOregister.Det1 abcdYXst22 1 1 21a b c d eDetsX Y ea bFigure 33 Testability conflict edges a data flow graph b register conflict graph withtestability conflict edges.Cost edges are weighted edges that are added between certain compatible nodes nodes thatdo not already have a conflict edge between them in the register conflict graph, and are used toguide the graph coloring algorithm toward the lowestcost design.  A positive weight is assignedto the cost edge if it is not advantageous to assign the same color to the adjacent nodes, and anegative weight is assigned if it is advantageous.  For example, negativeweight cost edges areadded between nodes a  and t1, and between b  and t1 in Fig. 33b because they representvariables that are inputs to a single function block  1 in two different clock cycles.Interconnection and multiplexer cost will be lower if these two variables are assigned to the sameregister.3.3 IMPLEMENTATION AND RESULTSWe have implemented our register allocation and binding algorithm for parallel BIST designsin the synthesis tool described in Sec. 6.  Given a behavioral VHDL IEEE 88 description of thedesign, the tool first creates a data flow graph, then performs scheduling and operation allocationand binding as described in Sec. 6.4, and then creates the register conflict graph as described inSec. 3.2.  We have implemented a modified version of the Brelaz node coloring algorithmTurner 88 to perform the register binding operation.  The pseudocode for our register bindingalgorithm is given in Table 31.  The algorithm attempts to color the nodes in the register conflictgraph with the minimum number of colors in order to minimize the number of registers in thegenerated design.  Since solving the general node coloring problem is NPcomplete, we useheuristics to sort the uncolored nodes, then color the node with the highest priority.  The node tobe colored is assigned the same color as a node that is adjacent via the lowest, negativeweightcost edge.  If the node to be colored has no adjacent negativeweight cost edges, the algorithmtries to assign it the same color as a nonadjacent node.  After a node is colored, thecharacteristics of the adjacent, uncolored nodes are updated, and all of the uncolored nodes aresorted to find the next node to color.21Table 31 Register binding algorithm for parallel BIST register conflict graph.ColorNodes Register Conflict GraphWhile Some Nodes Uncolored doSort Uncolored Nodes According to1. Has SelfAdjacent Constraint Edge2. Has Least Number Available Colors3. Has Most Constraint Edges4. Has Least Sum Of Cost EdgesSelect HighestPriority NodeColor With LowestCost Adjacent ColorUpdate Uncolored, Adjacent Nodesend WhileThe data path logic in Fig. 31c was generated by applying the register binding algorithm inTable 31 to the data flow graph in Fig. 31b.  As shown by the selfedge in Fig. 33b, node smust be assigned to a selfadjacent register, so the register binding algorithm selected node s tocolor first.  The register associated with node s and nodes a and X since they were assigned thesame color is implemented as a CBILBO register and is the only selfadjacent register in thegenerated design.Table 32 compares the results of our register allocation and binding technique, calledRALLOC, with the results published in Tseng 86, Pangrle 88, Paulin 89a, and Papachristou91 for two design examples, Tseng Tseng 86 and DiffEq Paulin 89a.  The design costestimates of the synthesized hardware are based on the number of selfadjacent SA registers,nonselfadjacent NSA registers, multiplexer inputs mux, interconnections int, and controlsignals ctl, and are computed as followscost1  14  NSA reg  14  SA reg  mux  int  ctlcost2  20  NSA reg  35  SA reg  mux  int  ctlFor the first design cost estimate, cost1, all registers have the same cost.  This represents the costof data path logic with no BIST or scan circuitry.  The second design cost estimate, cost2,represents the cost of a parallel BIST implementation of the data path logic.  In this case, nonselfadjacent registers are implemented with the register design shown in Fig. 25a, which isestimated to be approximately 20 times the cost of a multiplexer input,  and selfadjacentregisters are implemented with the highercost CBILBO register.The goal of the synthesis techniques presented in Tseng 86, Pangrle 88, and Paulin 89ais to minimize the area of the generated data path logic.  Since  they do not consider testabilityduring the synthesis process, their implementations, understandably, have a higher number ofselfadjacent registers, which partially accounts for the higher values for cost2 in Table 32.  Bothour synthesis technique and the technique described in Papachristou 91 attempt to minimize thecost of the design while preventing the generation of selfadjacent registers.  By comparing our22technique with techniques that do not consider testability, we show the difference betweensynthesisforBIST, where the design is optimized for a particular BIST architecture, and BISTsynthesis, where BIST circuitry is added to a design that has been synthesized for area andperformance.For both examples in Table 32, our technique generated the lowestcost parallel BISTimplementation cost2.  Our technique also generated designs with the minimum number ofregisters, showing that the additional testability constraint edge in the register conflict graph didnot require an increase in the number of registers for these examples.  The cost1 column in Table32 shows that, if parallel BIST is not implemented, the costs of the data path designs generatedby our technique are comparable to the costs of the other designs.Table 32 Comparison of synthesis procedures on Tseng Tseng 86 and DiffEq Paulin 89adata flow descriptions.Name NSA reg SA reg mux int ctl cost1 cost2TsengTseng 86 3 5 15 31 23 181 304Pangrle 88 4 3 11 26 18 153 240Papachristou918 0 12 28 20 172 220RALLOC 4 1 16 29 21 136 181DiffEqPangrle 88 1 5 17 34 23 158 269Paulin 89a 1 4 19 35 24 148 238RALLOC 4 1 22 38 27 157 2023.4 CONTRIBUTIONSWe have developed and implemented a new register allocation and binding technique thatgenerates data path logic optimized for the parallel BIST architecture given a scheduled,operationbound data flow description of the design.  A simple testability constraint edge addedto the register conflict graph is used to guarantee that the generated data path logic has aminimum number of selfadjacent registers.  This testability requirement can be easily adapted toexisting register allocation and binding procedures.  We have also developed and implementednew techniques for register allocation delayed values, multiple targets, and multiple sourcesthat provide the register binding procedure increased flexibility in synthesizing an efficienthardware implementation while minimizing the number of selfadjacent registers.Results show that, when the parallel BIST architecture is used, addressing register selfadjacency during highlevel synthesis results in a lowercost design.  For both examplesevaluated, our technique synthesized the lowestcost, parallel BIST design.  In addition, for both23examples, if parallel BIST is not implemented, the costs of the data path designs generated byour technique are comparable to the costs of the other designs.  This shows that, even if BISTand scan circuitry is not included in the design, minimizing the number of selfadjacent registersduring synthesis does not necessarily increase, and may even reduce, the cost of the generateddata path logic.244 SYNTHESIS FOR SCAN DEPENDENCEPerformance degradation, area overhead, and test transparency the fraction of defects notdetected by the test are three issues that must be addressed when synthesizing a builtin selftestable design.  The register allocation and binding technique described in Sec. 3 reduces thearea overhead of a parallel BIST design without increasing test transparency or the number ofclock cycles required to execute the data path function.  However, since there is additional BISTlogic associated with each system register in the data path, the clock period may have to beincreased, resulting in slower performance.  In this section, we describe a new synthesistechnique, applied to the bistables in the design, that relies on the sharing of system logic and testlogic to reduce the area and improve the performance without increasing the test transparency ofBIST architectures, such as circular BIST and parallel BIST, that make use of embedded MISRs.This technique was first described in Avra 93.  A more detailed description of the technique isgiven in Avra 94a.The goal of our synthesis technique is to arrange the system bistables into scan paths so thatsome of the BIST and scan logic is shared with the system logic.  Logic sharing is possible whenscan dependence is introduced in the design.  Other BIST design techniques attempt to avoid alltypes of scan dependence because it can increase the test transparency of embedded MISRs.  Weshow that introducing certain types of scan dependence in embedded MISRs can reduce theoverhead and the test transparency, and we describe a synthesis technique that maximizes theamount of this beneficial scan dependence.  The synthesis technique first analyzes the CUTfeeding the MISR, then based on the CUT function, it modifies the MISR function in order toreduce the amount of aliasing during BIST operation.  We have implemented this synthesistechnique in our synthesisfortest design tool described in Sec. 6 and we present faultsimulation, layout area, and delay results for circular BIST versions of benchmark circuits thathave been synthesized with our technique.Section 4.1 provides a formal definition of scan dependence and includes design examplesthat illustrate its advantages and disadvantages.  In Sec. 4.2, we describe design techniques forbeneficial scan dependence and show how to introduce it in the design by arranging the systembistables into MISRs.  Section 4.3 contains fault simulation and overhead results of severalbenchmark circuits generated with our synthesis technique and optimized for the circular BISTarchitecture described in Sec. 2.2. Section 4.4 summarizes our contributions in the area of scandependence.254.1 SCAN DEPENDENCEA system bistable Bi that can be reconfigured to perform scan operation is scan dependent ifand only if its system logic input signal, Zi, is functionally dependent on the bistable thatimmediately precedes it in the scan path.  For example, assume that the system logic input tobistable B5 is the function Z5  Q 1 Q3  Q 2 Q4.  If any of the bistables B1  B4 immediatelyprecede B5 in the scan path, bistable B 5 is scan dependent on that preceding bistable.  If,however, bistable B6 immediately precedes B5 in the scan path, B5 is not scan dependent since Z5is not a function of Q6.  Bhatia Bhatia 93 showed that scan dependence can be used to reducethe area overhead of certain types of scan architectures.  We showed in Avra 93 that some typesof scan dependence can be used to reduce the overhead and improve the effectiveness ofembedded BIST architectures.Figure 41 illustrates a problem that can occur in embedded MISRs if the type of scandependence is not identified when arranging bistables in the scan path.  In this example, thesystem logic input to bistable B 2 is the function Z2  Q 1  f , where f is an output ofcombinational logic CLU, the inputs to which are primary inputs PIs and bistable outputsexcluding the output of bistable B1 DFFs.  When bistable B2 is implemented as shown in Fig.25b, the function of its D input during MISR mode T1  1, T2  1 is D2  Q1  Q1  f  Q1  f,as shown in Fig. 41b.  The problem with this function is that it greatly reduces the number oferrors that the MISR can capture during MISR operation.  An error previously captured by theMISR and located at bistable B1 will only remain in the MISR via transfer to bistable B2 when f 1.  Similarly, an error in f is only captured in the MISR when Q1  0. 1DC11DC1fD2Q1Z21DC11DC1D2f11Q1CLUDFFsPIsCLUDFFsPIs B2 B2B1B1a bFigure 41 Embedded MISR with scan dependence  a implementation b MISRoperation.In order to determine whether or not scan dependence could be a significant problem inembedded BIST architectures, we implemented the circular BIST architecture, as described inSec. 2.2, on three of the ACMSIGDA LGSynth91 benchmark circuits ACMSIGDA 91.  Foreach circuit, the order of the bistables in the MISR was selected to maximize the number of scandependent bistables in order to represent a worstcase scenario.  We then faultsimulated BISToperation, using the bistable outputs as observation points.  For each circuit, BIST operation wasfirst executed until all of the single stuckat faults in the circuit had been captured at least once in26the MISR i.e., detected by the BIST operation.  The number of BIST operation clock cycles, P,required to detect 100 of the single stuckat faults varies from circuit to circuit, depending uponthe testability of the combinational logic, and from simulation to simulation, depending upon theinitial state of the bistables.  To determine a value for P, we ran five fault simulations on thecombinational logic portion of each circuit, applying test patterns randomlygenerated by thefault simulator to the inputs of the circuit.  We chose P to be equal to the average number, overthe five simulations, of randomlygenerated test patterns required to detect all single stuckatfaults in the combinational logic.  We then faultsimulated the BIST operation of the entirecircuit combinational logic plus bistables for P90 clock cycles, observing the states of all ofthe bistables during the last 90 clock cycles.  The fault simulation results of these 90 clock cyclesare shown in Fig. 42.  At each clock cycle, the percentage of faults that alias is the percentage offaults for which the states of the bistables in the faulty and faultfree circuits are identical.  Ourmotivation for performing the experiment in this manner is that, in practice, BIST operationwould probably be terminated, and the test response shifted out, at some point during thatwindow of 90 clock cycles.  Figure 42 shows that, even though the TPG function of the BISTarchitecture is sufficient to detect all single stuckat faults, there is a significant chance that afaulty circuit will not be identified due to aliasing in the ORA function.  For example, if BISToperation is halted and the state of the circuit is observed at clock cycle P40, there is aprobability of approximately 40 for mult32b, 25 for mult16b, and 10 for s641 that thefaulty circuit will be indistinguishable from the faultfree circuit.  We show in Sec. 4.3.2 thatthese probabilities are approximately zero for the same circuits if there is no scan dependence inthe design.020406080100 Faults that Alias0 20 40 60 80Clock Cycle after 100 of Faults Detectedmult16bmult32bs641Figure 42 Fault simulation results of BIST operation of circular BIST circuits withmaximum scan dependence.One way to address the scan dependence problem is to arrange the bistables in the MISRsuch that a minimum number of bistables are scan dependent Stroud 88, Pilarski 92.  Forexample, in order to eliminate scan dependence for bistable B2 Z2  Q1  f in Fig. 41, neitherB1 nor any of the bistables whose outputs are inputs to function f can immediately precede B2 in27the MISR.  Unfortunately, it may not always be possible to create an embedded MISR that hasno scan dependent bistables, particularly in controldominated designs where bistable inputsare often a function of a significant number of the bistable outputs in the design.  Also,eliminating all scan dependence eliminates opportunities to share system and test logic.We propose to solve the problem of MISR aliasing due to scan dependence by using adifferent MISR mode function for the scan dependent bistables.  The MISR function useddepends upon the type of scan dependence.  For example, when the system logic for bistable B2has the general form Z2  Q1  f, where B1 immediately precedes B2 in the MISR, we use Q1  fas the MISR function.  The Boolean function for the input to B2 is thenD2  T1 T2 Q1  T1 T2 Q1  T1 T2 Q1  f  T1 T2 Q1  f T1 Q1  T1 T2 Q1  Q1  f  T1 T2 Q1  f Q1 T1  T2  f  Q1  T1 fOne possible logic implementation for this function is compared with a scan dependenceavoidance implementation in Fig. 43.  Figure 43a shows our implementation, where the MISRfunction is  D2  Q1  f.  The scan dependence avoidance implementation is shown in Fig. 43b,where the MISR function is D2  Qx  Z2  Qx  Q1  f, Qx is the output of another bistablein the scan path, and f is not a function of Qx.  Both implementations were mapped to LSI Logic1.0 micron standard cell gates LSI 91.  Area in LSI Logic cell units and delay f to D2 innanoseconds for the shaded areas of Fig. 43 are provided in Table 41.  Note that the circuit inFig. 43a performs the shift operation D2  Q1 when T1  T2  0, whereas the circuit in Fig. 43b performs a synchronous reset operation D2  0.  Note also that bistable B2 in Fig. 43a hasgreater observability of system logic errors during MISR mode than bistable B2 in Fig. 43b.  Ifbistable B2 is not scan dependent, an error observable at f is only captured in the MISR when Q1is 0 i.e., when the error is observable at Z2, whereas if scan dependence is implemented asshown in Fig. 43a, all errors observable at f are captured in the MISR.  Greater observability ofsystem logic errors can reduce the test transparency of the BIST operation.The disadvantage of scan dependence, as shown in Fig. 42, is that it can result in significanterror loss in embedded MISRs if the function for MISR mode is not specifically selected for thetype of scan dependence.  The advantage of scan dependence, as shown in Fig. 43, is that, whenthe MISR function is carefully selected, the delay and area of the test logic for the scandependent bistable can sometimes be reduced.   Section 4.2 summarizes our synthesis technique,which first analyzes the combinational logic feeding each system bistable, then based on thisanalysis, determines the best arrangement of bistables into MISRs and modifies the MISRfunction in order to reduce the amount of aliasing during BIST operation.28T1T2 1DC1fQ1T1T21DC1fQx1DC1 Q1Q201MUXG 01 1DC1D2Q201MUXG 01 1DC1D2a bFigure 43 Scan dependence solutions for Z2  Q1  f   a our technique  D2  Q1  fduring MISR operation b avoiding scan dependence  D2  Qx  Q1  f during MISRoperation.Table 41 Area and delay for shaded logic in Fig. 43 based on data in LSI 91.Circuit Area CUs fD2 Delay nsFig. 43a 33 1.88Fig. 43b 41 2.214.2 SYNTHESIS FOR SCAN DEPENDENCEScan dependence that may be beneficial for embedded MISRs must be identified early in thedesign cycle since it can affect how the system logic is implemented, as was illustrated in Fig. 43.  Rather than analyzing a structural description of the system logic, the synthesis techniquemust analyze the system logic Boolean equation for each system bistable to determine whether ornot scan dependence is beneficial, and if so, to select the appropriate test mode functions.  Weuse Shannon decomposition to transform each system logic equation, Zj, into a form that can beeasily analyzed for scan dependence, and if beneficial for embedded BIST, synthesized into anefficient structural implementation.  Shannon decomposition of a Boolean equation ZjQ1,Q2,...with respect to variable Q1 results inZjQ1, Q2, ...  Q1 Zj1, Q2, ...  Q1 Zj0, Q2, ...where Zj1, Q2, ... is the Q1residue and Zj0, Q2, ... is the Q1residue of Zj.  For each Qi that isessential for system logic equation Zj, i  j, we perform Shannon decomposition on Zj withrespect to Qi.  Then, based on the values of the residues, we classify Qi as one of four casesaccording to Table 42, where constant is either logic 0 or logic 1, and Qi  is either Qi or Q i .Qi is essential for Zj if and only if all sumofproducts expressions for Zj include either Qi or Q ior both.  If Qi cannot be classified as case 1, case 2, or case 3, it is classified as case 4.  Cases 1,2, and 3 are considered beneficial scan dependence because, when using the MISR functiongiven in Table 42, they can be implemented with less logic than if scan dependence is avoidedand the MISR function Qk   Z j is used. Figure 44 shows possible logic implementations forrepresentative functions of cases 1, 2, and 3.29Table 42 Scan dependence classification of decomposed Boolean equations.Class Qiresidue Qiresidue Equation Form MISR FunctionCase 1 constant constant Zj  Qi Dj  QiCase 2 constantnot constantnot constantconstant Zj  Qi   f Dj  Qi   fCase 3 Qi residue Qiresidue Zj  Qi  f Dj  Qi  fCase 4 not constant not constant Zj  Qi f  Qi g AVOID1DC11DC1fT1Q i D j1DC1T1T21DC1fTest OverheadD jQ i01MUXG 011DC11DC1Q i Dja b cFigure 44 Beneficial scan dependence implementations  a case 1 Zj  Qi b case 2  Zj Qi  f c case 3  Zj  Qi  f.To date, we have not determined a way for system logic equations classified as case4equations to benefit, in terms of reduced area and performance overhead, from scan dependence.Therefore, if the Shannon decomposition of Zj with respect to Qi is a case4 equation, bistable Bishould not immediately precede bistable Bj in the scan path, otherwise the effectiveness of theMISR will be compromised.  To show that this is true, let p and q be the Qi and Q i residues,respectively, of Zj Zj  Qi p  Qi  q, and let Bi immediately precede Bj in the scan path.  If Bj isimplemented as shown in Fig. 25b, then during MISR operation, Dj  Qi  Qi p  Qi  q  Qi p Q i  q.  Any error in p or q that is observable at Zj an error in p is observable when Qi is 1 anerror in q is observable when Qi is 0 is also observable at Dj i.e., captured in the MISR duringMISR operation.  However, an error in Qi is only observable at Dj i.e., transferred to the nextbistable in the MISR when p  q, because when pq0, Dj  Q i, and when pq1, Dj  Q i,whereas when pq, Dj  0.  If the bistables in the scan path are arranged such that Bi precedesbistable Bk where Qi is not essential for Zk, then during MISR operation,  Dk  Qi  Zk, and allerrors in either Qi or Zk, but not both, are observable at Dk.  Therefore, case4 scan dependencereduces the observability of errors in the previous bistable in the scan path, but does not reducethe observability of system logic errors.The goal of our synthesis technique is to determine the arrangement of system bistables in anembedded MISR that has the maximum amount of beneficial scan dependence and no nonbeneficial scan dependence case4 equations.  The procedure first creates a directed graphcalled a dependence graph, where the nodes of the graph represent the system bistables.  We add30a weighted edge from node i to node j if Zj is  a case1, case2, or case3 function of Qi see Table42.  The weight of the edge represents the cost of the test logic overhead, either theperformance overhead, the area overhead, or a combination of the two.  We also add a weightededge from node i to node j if Q i is not essential for Zj.  In this case, bistable B j is not scandependent on Bi, and the weight of the edge represents the cost of the test logic overhead of Fig.25b.  No edge is added from node i to node j if Zj is a case4 function of Qi since this representsa scan dependence situation that we wish to avoid.  The best order of bistables is determined byfinding the lowestcost Hamiltonian cycle in the graph, where the cost of the cycle is the sum ofthe weights of the edges in the cycle.  A Hamiltonian cycle contains all nodes in the graph, andall nodes in a Hamiltonian cycle are distinct.  Frieze Frieze 88 describes a polynomialtimealgorithm for finding Hamiltonian cycles in directed graphs.Unfortunately, some designs have a dependence graph that does not contain a Hamiltoniancycle.  For example, if a system bistable is a case4 function of all other bistables in the MISR,its corresponding node in the dependence graph has no incoming edges and can therefore not beincluded in a Hamiltonian cycle.  We solve this problem by adding nodes to the graph, one at atime, until a Hamiltonian cycle is created.  Adding a node to the dependence graph correspondsto adding a bistable to the design that is only used during test operations.  Since the addedbistable does not have a system logic function, it can perform a shift operation during both MISRmode and normal mode, so a case1 edge is added from each node in the graph to the new node.Also, the output of the new bistable is not essential for any of the system bistable functions, so anonessential edge is added from the new node to each system node in the graph.  In theworst case, which corresponds to an original dependence graph with n nodes and no edges eachbistable is a case4 function of every other bistable, n nodes must be added to create aHamiltonian cycle, and the cycle will have alternating system and testonly nodes.4.3 IMPLEMENTATION AND RESULTSWe have implemented both our synthesis technique called BSD for beneficial scandependence and the synthesis technique of avoiding all types of scan dependence called AVDusing procedures from the SIS logic synthesis tool Sentovich 92.  The synthesis techniques usethe categories listed in Table 42 to first identify the different dependence cases for each bistableinput and create a dependence graph.  Then, for the BSD technique, the bistables are arrangedinto a circular BIST scan path that has the maximum number of case1, case2, and case3functions, and no case4 functions.  For the AVD technique, the bistables are arranged into acircular BIST scan path that has no scan dependencies.  For both techniques, testonly verticesare added one at a time to the dependence graph, if necessary, until a Hamiltonian cycle iscreated.  We applied the synthesis techniques to the ACMSIGDA LGSynth91 benchmark31circuits ACM 91 and provide both implementation results and fault simulation results in thissection.Table 43 lists the number of system and testonly bistables in the generated circular BISTversions of the benchmark circuits, and the number of beneficial scan dependence equations inthe BSD versions of the benchmark circuits.  Twelve of the 23 benchmark circuits have noinstances of beneficial scan dependence in the circular BIST path selected by the BSD technique,so there is no difference between the AVD and BSD versions of these circuits.  Additionalimplementation details of the remaining circuits, highlighted in Table 43, are provided in Tables44, 45, and 46.4.3.1 Area and Delay ResultsTables 44 and 45 compare area and delay values for the circular BIST benchmark circuits.For both tables, the SIS logic synthesis tool Sentovich 92 was used to apply multilevel logicoptimizations, and the CERES technology mapping tool Mailhot 93 was used to map the logicto LSI logic 1.0 micron standard cell gates LSI 91.  The area values are given in terms of LSIlogic cell units, and the delay values are in nanoseconds.   Overhead is the percentageincrease in area or delay of the circular BIST version of the circuit over the system logic versionwith no test logic added.    Diff is the percentage decrease in area or delay of the BSDversion of the circuit over the AVD version.  Area optimization techniques were used for bothlogic optimization and technology mapping for the circuits in Table 44, and delay optimizationtechniques were used for the circuits in Table 45.32Table 43 Bistable characteristics for circular BIST benchmark circuits.AVD Bistables BSD Bistables  BSDCircuit System TestOnly System TestOnly Eqnss1196 18 0 18 0 0s1488 6 6 6 6 0s1494 6 6 6 6 0s208.1 8 1 8 1 0s298 14 0 14 0 1s344 15 3 15 3 0s349 15 3 15 3 0s382 21 0 21 0 3s386 6 6 6 3 3s400 21 0 21 0 3s420.1 16 1 16 1 0s444 21 0 21 0 3s510 6 6 6 6 0s526 21 0 21 0 1s641 17 0 17 0 6s713 17 0 17 0 8s820 5 5 5 5 0s832 5 5 5 5 0s838.1 32 1 32 1 0sbc 27 0 27 0 6mm4a 12 0 12 0 0mult16b 30 0 30 0 14mult32b 62 0 62 0 30Table 44 Area and overhead for areaoptimized circular BIST benchmark circuits.AVD BSDCircuit Area  Overhead Area  Overhead  Diffs298 779 38.4 778 38.2 0.1s382 1131 40.3 1110 37.7 1.9s386 649 51.3 624 50.7 3.9s400 1124 39.3 1111 37.7 1.2s444 1137 44.3 1134 43.9 0.3s526 1207 36.5 1206 36.4 0.1s641 1534 42.6 1635 52.0 6.6s713 1539 43.4 1595 49.5 3.6sbc 3053 23.7 3045 23.4 0.3mult16b 1516 46.7 1303 17.3 14.1mult32b 3096 49.2 2648 16.5 14.533Table 45 Delay and overhead for delayoptimized circular BIST benchmark circuits.AVD BSDCircuit Delay  Overhead Delay  Overhead  Diffs298 6.8 19.0 6.8 20.2  0.0s382 7.3 33.6 7.4 36.3  2.1s386 6.8 20.0 7.9 39.1  15.9s400 6.8 26.7 6.8 26.7 0.0s444 7.5 25.8 7.1 19.5 5.0s526 6.7 11.4 6.8 12.9 1.3s641 11.7 31.9 11.5 29.4 1.9s713 11.0 24.8 11.0 24.7 0.1sbc 11.8 10.1 11.8 10.0 0.1mult16b 9.1 0.4 8.6 6.6 6.1mult32b 14.2 13.1 13.7 16.1 3.5Table 46 shows the gate area overhead, net area overhead, and total area overhead forlayouts of the circular BIST benchmark circuits.  The layouts were generated using SIS for areaoptimized logic optimization, CERES for areaoptimized technology mapping, and TimberWolf6.0 for standard cell place and route.  The circuits were mapped to version 2.2 of the scalableCMOS standard cell library that is included with the TimberWolf tool.  We used the best of fivedifferent layouts generated by TimberWolf for each circuit in Table 46.Table 46 Layout area overhead for areaoptimized circular BIST benchmark circuits.AVD  Overhead BSD  Overhead  DifferenceCircuit Gate Net Total Gate Net Total Gate Net Totals298 46.7 61.5 55.1 45.1 53.5 51.8 1.1 4.9 2.1s382 44.8 62.4 53.7 44.3 62.3 53.7 0.4 0.1 0.0s386 39.8 32.9 36.3 39.0 39.1 39.9 0.6 4.7 2.6s400 45.1 51.5 49.7 43.8 55.7 52.9 0.9 2.8 2.1s444 51.2 62.0 52.5 51.4 54.9 53.0  0.1 4.3 0.3s526 39.5 53.5 49.3 38.3 53.8 49.3 0.9 0.2 0.0s641 45.1 57.0 54.3 55.3 71.9 68.2 7.0 9.5 9.0s713 44.4 56.5 53.9 53.9 68.5 67.3  6.6 7.6 8.7sbc 21.3 22.3 26.4 21.1 22.8 26.2 0.2 0.4 0.2mult16b 56.8 68.1 57.3 17.0 18.7 16.9 25.4 29.4 25.7mult32b 57.3 84.5 74.5 16.1 15.2 14.6 26.2 37.6 34.3For most of the benchmark circuits we investigated, the sizes of the AVD and BSD versionsare not significantly different.  Two of the BSD circuits s641 and s713 are larger than the AVDcircuits.  We determined that this is due to high fanout of some of the system logic equations that34are restructured for beneficial scan dependence in the circular BIST path according to Fig. 44.An enhancement to the synthesis technique should consider the fanout of the system logic whendetermining whether or not a particular system logic equation is beneficial for scan dependence.According to Tables 44, 45, and 46, the BSD versions of two of the circuits mult16b,mult32b have significantly less area and delay than the AVD versions of these circuits.  Thereason for this low overhead is that both mult16b and mult32b perform a serial multiplicationoperation which has the property that many of the system logic equations are case3 equations.Our synthesis technique is able to arrange the bistables into a circular BIST path such that mostof the bistables are case3 scan dependent on the previous bistable in the path, and these case3equations have very little overhead for BIST see Fig. 44c.  We focus on this property ofarithmetic operations in the Sec. 5 discussion of scan dependence in data path logic.4.3.2 Fault Simulation ResultsWe performed extensive fault simulations on several of the benchmark circuits in order toevaluate how scan dependence affects the quality of BIST operation.  For each benchmarkcircuit, we created four different circuit models for gatelevel, single stuckat fault simulationFNL, IGN, AVD, and BSD.  The FNL version is the original benchmark circuit, and it executesnormal operation during the fault simulation.  The frontend test logic shown in Fig. 25b wasused for every bistable in the IGN version IGN stands for ignore scan dependence, and thebistables were arranged into a circular BIST path such that the number of scan dependentbistables was maximized.  The AVD and BSD circuits were generated as described previously inthis section.  The fault simulation results are given in Table 47.  The fault coverage is thepercentage of collapsed, single stuckat faults that are detected at least once during BISToperation, and is a measure of the quality of the TPG operation.  We define error loss as thepercentage of clock cycles for which the faulty and faultfree machines are identical i.e., thepercentage of aliased clock cycles given that the fault has been detected.  Error loss is a measureof the quality of the ORA operation.  Table 47 shows that the BSD versions of the benchmarkcircuits have the highest fault coverage, and for most of the circuits, the lowest error loss.    Theslightly elevated error loss for the BSD version of circuit s386 could be attributed to the fact thatits circular BIST path has three fewer bistables than the AVD version.  Even if a circuit has a highfault coverage percentage, a nonzero error loss percentage means that there is a chance that adefective circuit will be labeled faultfree even if the fault is detected at some time during theBIST operation.  The defective circuit can only be identified if the BIST operation terminates ona nonaliased state.35Table 47 Fault simulation results for circular BIST benchmark circuits. Fault Coverage  Error LossCircuit FNL IGN AVD BSD FNL IGN AVD BSDs298 33.3 100.0 100.0 100.0 49.1 0.6 0.2 0.0s386 37.6 30.2 77.8 80.2 59.2 0.2 0.0 2.8s444 35.5 100.0 100.0 100.0 50.5 0.0 0.0 0.0s641 88.9 100.0 100.0 100.0 73.4 9.5 0.0 0.0mult16b 100.0 98.6 100.0 100.0 37.9 26.0 0.0 0.0mult32b 99.0 95.7 100.0 100.0 1.9 39.7 0.0 0.04.4 CONTRIBUTIONSIn this section, we have given a formal definition for scan dependence and have shown thatcertain types of scan dependence, called beneficial scan dependence, can be used to reduce thearea and delay of embedded BIST techniques.  We have developed new ORA functions for thesebeneficial scan dependence equations.  We have developed and implemented a new synthesistechnique that, given a design described in terms of Boolean equations and bistables, creates ascan path that has the maximum amount of beneficial scan dependence and no nonbeneficialscan dependence, and generates a circular BIST implementation of the design.  Most of thecircular BIST benchmark circuits generated by our synthesis technique are comparable in sizeand delay to circuits generated by other techniques.  However, our results are significantly betterfor the two arithmetic circuits in the benchmark suite.Finally, we have analyzed the effect that ignoring scan dependence has on fault observabilityduring BIST operation.  Fault simulations of circular BIST benchmark circuits confirms ouranalysis ignoring scan dependence can increase the aliasing of the ORA function of circularBIST architectures.  Our fault simulations have also shown that although fault coverage can behigh for both normal operation and for BIST operation where scan dependence is ignored, thehigh error loss of the ORA function reduces the overall quality of the BIST operation for thesecircuits.365 SCAN DEPENDENCE IN DATA PATH LOGIC  The synthesis technique described in Sec. 4 is a general technique for maximizing beneficialscan dependence given that the system logic is described in terms of Boolean equations andbistables.  One way to maximize beneficial scan dependence in data path logic is to first applyhighlevel synthesis operations to a data flow description of the design, then apply the techniquedescribed in Sec. 4 to the generated data path logic.  Unfortunately, due to the types of functionblocks typically found in data path logic e.g., multipliers, adders, generating the dependencegraph for the data path bistables could be very computationally expensive.  More importantly,the highlevel synthesis technique may generate data path logic with few beneficial dependenciesbetween the bistables.In this section, we describe a method for increasing the beneficial dependencies betweensystem bistables during highlevel synthesis.  There are several advantages when beneficial scandependence is considered during highlevel synthesis of data path logic, where the input tosynthesis is a data flow description, rather than Boolean equations.  First, we can simplify thegeneration of the dependence graph since the Boolean equations for the system logic can beinferred for multiple bistables given a single operation in a data flow equation.  For example,given the data flow equation R3  R1 ADD R2, where R1, R2, and R3 are nbit registers, we caninfer that the system logic equation for each bistable, Bi, of register R3 has the form R3i  R1i R2i  Ci, where Ci is the carry function for Bi.  We need not perform Shannon decomposition onthe system logic equations of the addition operation in order to determine the dependenceinformation for the bistables in R3.  Second, in data path logic, all bistables in a register aretypically controlled by the same group of control signals.  When test operation control signalscan be used in the same manner, i.e., one block of test control logic for each register rather thanfor each bistable in the design, test overhead can be reduced.  Finally, since the synthesistechnique determines how variables in the data flow description are assigned to bistables, it maybe able to generate data path logic with more instances of case1, case2, and case3dependencies between the bistables, resulting in a lowercost, selftestable design.This section is a summary of the material in Avra 92 and Sec. 6 of Avra 94a and containsa discussion of how to apply the synthesis technique described in Sec. 4 to data path logic.  Wefirst describe a new scan path architecture for data path logic, called orthogonal scan path, wherethe shift direction in the orthogonal scan path is orthogonal to the shift direction in traditionalscan paths shifting bits within registers.  We then identify data path functions that are wellsuited for the synthesis technique described in Sec. 4, and show that the occurrence of thesefunctions can be increased if an orthogonal scan path is used in the data path logic.  Finally, wediscuss a register binding technique that, assuming an orthogonal scan path architecture, attempts37to maximize the number of beneficial scan dependence equations in the generated data pathlogic.5.1 ORTHOGONAL SCAN PATH ARCHITECTUREFigure 51a is an example of logic that is commonly found in data path designs.  The outputsof two registers, R1 and R2, are the inputs to a combinational logic unit, Adder, that performs theaddition operation, the output of which is stored in register R3.  Each of the registers consists ofn bistables.  Traditional scan path architectures are arranged as shown in Fig. 51b, where eachbistable of register R1 feeds the next bistable of register R1 during scan operation.  When BIST isimplemented in the data path logic, this scan path arrangement implies a correspondence betweensystem registers and BIST registers, such as LFSRs and MISRs.  For example, registers R1 andR2 could be implemented as LFSRs and R3 could be implemented as a MISR during BISToperation if the parallel BIST architecture is used.Figure 51c shows the bistable arrangement for an orthogonal scan path.  Each bistable of R1feeds the corresponding bistable of register R3 during scan operation.  The outputs of R3 may, inturn, be inputs to another register in the data path logic during scan operation.  Note that, for thisexample, the flow of data during normal operation from R1 to R3 is parallel to the flow of dataduring scan operation.  This may allow for the sharing of system and test logic, which is themotivation for the orthogonal scan path arrangement.R1 R2R3Adder 1DC11DC11DC11DC11DC11DC11DC11DC11DC1R11SDI2 nSDOSDIR1R3B B B1 2 nB B B1 2 nB B B1 SDI2 SDInSDO1 SDO2 SDOna b cFigure 51 Orthogonal scan path example  a normal operation b typical scan patharrangement for R1 c orthogonal scan path arrangement for R1.5.2 SCAN DEPENDENCE FUNCTIONS IN DATA PATH LOGICThe system logic equations for the bistables in register R3 in Fig. 51a have the general formR3i  R1i  R2i  Ci, where Ci is the carry function for bistable Bi of R3.  Since Ci is a functionof the lesssignificant bistables of R1 and R2, and is not a function of R1i or R2i, each bistable inR3 is a case3 function of the corresponding bistable in R1 and the corresponding bistable in R2.The implementation for case3 equations shown in Fig. 44c can only be used if the bistables in38either R1 or R2 immediately precede the corresponding bistables in R3 in the scan path.  This canbe accomplished when an orthogonal scan path is used in the data path logic.Table 51 lists seven types of system logic equations for bistables in data path logic that wehave determined can benefit from scan dependence.  The equation type and an associated areaoverhead cost estimate based on LSI Logic cell units LSI 91 are listed, where n represents thewidth of the data path i.e., the number of bistables in each register.  Lowercase letters a and brepresent system logic control signals that determine the input to each bistable of register R1.Uppercase letters F and G represent outputs of combinational logic, the inputs to which areprimary inputs and outputs of bistables excluding the corresponding bistables associated withregister R2.  For example, for a 2bit data path n  2, the equation R1  a R2  a F representstwo system logic equationsZ10  a Q20  a F0Z11  a Q21  a F1where F0 is not a function of Q20, and F1 is not a function of Q21.Table 51 System equations for data path registers that benefit from scan dependence.Type Cost Function1 0 R1  R22 4 R1  a R2  a R2  F3 4n R1  R2  F4 122n R1  a b R2  a b R2  F  a G5 48n R1  a R2  F  a G6 88n R1  a R2  a F7 10n R1  R2  F8 18n R1  FData flow equation types 1, 7, and 3 correspond to the case1, case2, and case3 equations,respectively, described in Sec. 4.2, and the bistables of these registers can be implemented asshown in Fig. 44.  Equation types 2, 4, 5, and 6 are combinations of case1 and case3 equationsand have control logic can be shared between the test control signals and system control signals aand b.  If the system logic equation for R1 cannot be classified as one of the first seven types ofequations shown in Table 51, it is classified as type 8, and the more general synthesis techniquedescribed in Sec. 4 can be applied to determine whether or not beneficial scan dependence existsfor any of the bistables in the register.   Register R3 in Fig. 51a can be represented by the type3equation in Table 51, R1  R2  F.We have identified two types of operations that are common in data path designs and can bemapped to equation types 16 in Table 51  addition operations and live variable motion.Addition operations are common in DSPbased data path designs.  Waser 82 describes several39types of adder implementations, including conditional sum, Ling, and carrylookahead adders.The output equations for each of these adder implementations can be expressed as  R1i  R2i R3i  Ci, where Ci is a function of the lesssignificant bistables of R2 and R3, and is not afunction of R2i or R3i.  The logic implementation for Ci varies with adder type.  If any of thevariables in the data flow description that are assigned to register R1 are the result of an additionoperation, it may be possible to implement R1 by one of equation types 25 in Table 51.Another type of function that can occur in data path designs is the transfer of data from oneregister to the next, known as live variable motion.  Variables whose lifetimes are longer thanone clock cycle can either be held in a single register, or transferred from one register to another.When the latter technique is used, equations of the form R1  a R2  a F occur in the data pathlogic, where a live variable is transferred from R2  to R1 whenever control signal a   1.Depending on the logic that generates F, this equation can be mapped to equation types 1, 2, 4, 5,6, or 7 in Table 51.  Figure 52a is a data flow graph illustrating live variable motion.  VariableH is loaded into register R3 during the first clock cycle, but is not needed for computation untilthe second clock cycle, and so is loaded into R2 during the second clock cycle.  Variable G isloaded into R2 during the first clock cycle.  The system logic equations for the bistables of R2 aretype6 equations, which can be implemented as shown in  Fig. 52b.  The control signal a is highduring the first clock cycle and low during the second.  The test logic overhead for this caseconsists of two AND gates per bistable in R2 plus an AND gate and an OR gate to generatecontrol signals for all bistables in the register.  The exclusiveOR gate is used to perform theMISR function during BIST operation and a multiplexer function during normal operation.5.3 RESULTSOur highlevel synthesis procedure for beneficial scan dependence assumes that the data pathlogic has an orthogonal scan path architecture, and biases the register binding operation to assignvariables in the data flow equations to registers such that equation types 17 listed in Table 51are used most often.  This synthesis procedure was applied to two highlevel synthesisbenchmark circuits, Tseng Tseng 86 and  DiffEq Paulin 89a.  The results are presented inTable 52.  The size of the data path in LSI Logic cell units LSI 91 and the overhead for testlogic as a percentage of total size are given for two situations  1 bistables are arranged intoorthogonal scan paths after register binding labeled Test Synthesis, and 2 equation types 17in Table 51 are favored during register binding labeled SynthesisforTest.  We assumed a16bit data path, and estimated interconnect area as being one cell unit per interconnection. Forboth the test synthesis and synthesisfortest procedures, beneficial scan dependence wasmaximized by using an orthogonal scan path arrangement in a circular BIST architecture.  For40both examples, the total size and the test overhead are smaller when scan dependence isconsidered during register binding.T  1DC1R3R2Test OverheadGTaaR1 R3R2R2R1R1F G Hto each bistable in R212ii ia bFigure 52 Live variable motion  a data flow graph b implementation of bistables in R2.Table 52 Data path design examples with orthogonal scan path and circular BIST.Test Synthesis SynthesisforTestDesign Size cell units  Overhead Size cell units  OverheadTseng 14,146 13.5 11,574 6.4DiffEq 12,342 11.7 11,518 7.35.4 CONTRIBUTIONSWe have developed a new scan path architecture for data path logic called orthogonal scanpath.  The motivation for using this type of scan path arrangement is that it can increase thenumber of beneficial dependencies between the bistables in the data path logic, which allows formore sharing of system and test logic.  We have identified seven types of data path equations thatare beneficial for scan dependence, and have shown that using an orthogonal scan path increasesthe occurrence of these types of equations.  We discussed the synthesis of two data path designexamples and showed that, when the register binding operation assumes an orthogonal scan pathand is biased toward generating data path logic with certain structures for addition operations andlive variable motion, lowercost circular BIST designs result.416 SYNTHESISFORTEST DESIGN SYSTEMIn this section, we describe a computeraided design system, named Odin, that automaticallygenerates a synchronous hardware design given a behavioral, VHDL description of the design.Existing hardware synthesis systems typically use cost and performance as the main criteria to besatisfied when generating a design from a behavioral description, and seldom even consider testissues during the synthesis process.  The purpose of Odin is to serve as a platform for thedevelopment of synthesis techniques that generate lowcost, highperformance hardwareimplementations that also meet specified testability requirements.  By considering testabilityduring the synthesis process, Odin is able to generate designs that are optimized for specific testtechniques.  Odin can currently generate designs optimized for both parallel and circular BISTarchitectures.We have implemented in Odin all of the major design system algorithms necessary for thegeneration of data path and control logic given a behavioral VHDL description  VHDL inputand output file processing algorithms, internal data structure creation and manipulationalgorithms, and highlevel synthesis algorithms.  Emphasis was placed on ease of modificationwhen implementing the system in order to encourage the addition of future synthesisfortesttechniques.  In this section, we describe the current capabilities of Odin.  A more detaileddescription is given in Avra 94b.  Section 6.1 is a brief overview of the Odin design system.Section 6.2 describes the VHDL input and output files for the design system  the inputbehavioral description, the component library that Odin accesses when performing synthesisoperations, and the output structural description.  Section 6.3 contains a description of thehierarchical data and control flow graph that is Odins major internal data structure.  Finally, inSec. 6.4, we describe the highlevel synthesis operations that are currently implemented in Odin.6.1 OVERVIEWFigure 61 illustrates the flow of tasks that are performed by the Odin design system.  Theinput to Odin is a VHDL intermediate format VIF description that represents the behavioraldescription of the design.  A commercial VHDL compiler, developed by Vantage AnalysisSystems, is used to create VIF from the input behavioral description.  Several transformations areapplied to the VIF description in order to simplify Odins internal data structures.  VIF accessroutines supplied by Vantage are used to transform the VIF description into a data and controlflow graph DCFG.  Compiler optimizations are applied to the DCFG in order to minimize theamount of code that must be mapped to hardware.  If the behavioral VHDL description containsmultiple process statements, interprocess communication can be analyzed Martinolle 91 inorder to extract all potential functional parallelism in the description so that the most efficient42hardware can be synthesized.  The first task in highlevel synthesis is scheduling, whereoperations e.g., addition, comparison, multiplication in the behavioral description are assignedto specific clock cycles based upon data dependencies and the delays of the hardwarecomponents that are used to implement the operations.  Operations and variables are thenmapped to hardware components from a userspecified VHDL component library.  Control logicthat generates control signals for the components in the data path logic is synthesized based uponthe selected schedule and the binding of operations and variables to hardware components.  Theoutput is structural VHDL descriptions of control logic and data path logic that implement theinput behavioral description. Process Statements Signal Assignments Constant Propagation Loop Unrolling Dead Code Elmination Resolve Signal Assignments Maximize Parallelism Scheduling Operator Allocation and Binding Register Allocation and Binding Control logic generationData Path Logic VHDLTransformationsCompiler OptimizationsInterprocess AnalysisHighLevel SynthesisDCFG CreationControl LogicVantageVHDL CompilerComponentLibraryBehavioralModelVIFStructural VHDLFigure 61 Odin design system overview.6.2 DESIGN SYSTEM INPUT AND OUTPUTAs shown in Fig. 61, the input to Odin consists of two VIF data structures, generated by theVantage compiler from VHDL source code.  The data structures represent a behavioral model ofthe design and a library of hardware components used by the synthesis techniques to generate astructural implementation.436.2.1 VHDL DescriptionsThe VHDL behavioral description of the design to be synthesized consists of algorithmic,highlevel software constructs such as conditional statements, assignment statements, and loops.The behavioral description does not necessarily contain information, such as clock signaldesignations, that implies how it should be implemented in hardware.  Table 61, a processstatement from the DiffEq benchmark circuit description in HLSW 92, is an example of thetype of behavioral description that Odin accepts as input.Table 61 Example VHDL behavioral description  DiffEq from HLSW 92.process Aport, DXport, Xinport, Yinport, Uinportvariable xvar,yvar,uvar, avar, dxvar integer variable x1, y1, t1,t2,t3,t4,t5,t6 integer beginxvar  Xinport  yvar  Yinport uvar  Uinportavar  Aport dxvar  DXportwhile xvar  avar loopt1  uvar  dxvart2  3  xvart3  3  yvart4  t1  t2t5  dxvar  t3t6  uvar  t4uvar  t6  t5y1  uvar  dxvaryvar  yvar  y1xvar  xvar  dxvarend loopXoutport  xvarYoutport  yvarUoutport  uvarend processThe VHDL structural descriptions of the control and data path logic generated by Odin arenetlists that consist of component instantiations and signal interconnections.  All components inthe structural description are specified in the component library.  A portion of an example VHDLstructural description of data path logic generated by Odin is shown in Table 62.  Threecomponents ADD, SEL2, and SUB and their signal interconnections port map statement areshown.  The generic map16 statement specifies that the data path for that component is 16 bits,so, for example, the two data input signals, INTERNAL14 and INTERNAL9  for the ADDcomponent are each 16 bits.44Table 62 Example VHDL structural description of data path logic generated by Odin.architecture STRUCTURAL of DATA1 isuse work.COMPONENTPKG.all.....G14 ADDgeneric map16port mapINTERNAL8,INTERNAL14,INTERNAL9,cInG15 SEL2generic map16port mapINTERNAL7,SEL13,SEL14,INTERNAL13,INTERNAL20G16 SUBgeneric map16port mapINTERNAL6,INTERNAL18,INTERNAL7,cIn.....end STRUCTURAL6.2.2 Component LibraryThe VHDL structural description generated by Odin consists of hardware components thatare specified by the user in a VHDL component library.  Odin assumes that any operation in thebehavioral description can be implemented by one or more components in the component library.The library must also contain register components and multiplexer or selector components forimplementing the data path logic, and basic logic gates e.g., NAND, NOR, INVERT andbistables for implementing the control logic.  The user is able to guide the synthesis process bymeans of the types of components available in the library and the characteristics associated witheach available component.  For example, by including in the library components that have beenoptimized for scan architectures, the user can minimize the overhead of any scan designs thatOdin generates.Associated with each component in the component library are attributes that specify its area,delay, and control information.  The area attribute is used by Odin to estimate the cost of thecomponent, and the delay attribute is used to estimate its performance.  Since a single componentmay implement multiple operations e.g., ALUs, comparators, the control information attributesspecify the control signal values required for the component to implement the associatedoperation.  Components that implement operations with multiple inputs also have an attributethat specifies whether or not the operation is commutative.  The inputs to a commutativecomponent can sometimes be switched to reduce the number of interconnections in the data pathlogic.6.3 DATA AND CONTROL FLOW GRAPHSThe data and control flow graph DCFG is generated from the VHDL intermediate formatand provides an accurate and concise means of conveying the information flow of the behavioral45description to the compiler optimization and synthesis operations.  The DCFG has two levels ofhierarchy.  The top level is created by partitioning the behavioral description into basic blocksand control statements.  A basic block is a sequence of consecutive assignment statements fromthe behavioral description.  Figure 62a shows an example VHDL behavioral description that ispartitioned into two control statements circled, a wait and an if, and two basic blocks.  TheDCFG has six different types of nodes  Wait, If, and Case, which correspond to wait, if, and casestatements, respectively, While for loop statements, EndCond for joining the mutuallyexclusivebranches of conditional statements, and BB for basic blocks.  The information associated witheach node depends upon its type.  For example, Wait nodes are numbered since there aretypically multiple wait statements in a VHDL behavioral description.  Each Wait node also has apointer to the list of signals to which the corresponding wait statement is sensitive.  Figure 62bshows the top level of the DCFG for the process statement given in Fig. 62a.  The five nodes arelabeled N1  N5.  Edges in the DCFG represent the branching of operation between the behavioralstatements represented by the nodes.  A value associated with an edge represents the conditionunder which that branch is taken.Processvariable a, b  integer Beginwait unil go  1if y  x  3 thenb  a  1a  y  1x  abelseb  a  2a  y  2x  bend ifEnd ProcessWaitIfgo  1y  x  3b  a  1a  y  1x  abBBb  a  2a  y  2x  bBBfalse truetruefalseEndCondN1N2N3 N4N5a bFigure 62 DCFG example  a partitioned behavioral description b top level of theDCFG.A data flow graph DFG is associated with each node in the DCFG except for EndCondnodes.  The data flow graph is a directed, acyclic graph that specifies the operations and the datadependencies of a basic block or an expression.  Each node in the DFG represents an operation inthe behavioral description.  A directed edge from node Ni to node Nj specifies that the output ofthe operation represented by node Ni is an input to the operation represented by node Nj.  Each46DFG has a source node SRC which only has outgoing edges that represent variables that areoutputs of other DFGs, and a sink node SNK which only has incoming edges that representvariables that are inputs of other DFGs.  The DFG for basic block nodes specifies how thevariables defined by the statements in the basic block a variable is defined if it appears on thelefthandside of an assignment statement are used in subsequent statements of the block seeFig. 63a.  The DFG for control nodes Wait, For, While, If, Case represents the conditionalexpression associated with the control statement. For example, the DFG associated with an Ifnode represents the conditional expression of the If statement see Fig. 63b.SRCb  a  1a  y  1x  abBBxSNKa1 y 1x ab aIfy  x  3SRCSNKx3ya bFigure 63 Data flow graphs  a BB node DFG b If node DFG.Odin uses the DCFG to perform several basic compiler optimizations on the input behavioraldescription in order to minimize the amount of code that must be mapped to hardware and toimprove the performance of the final design.  The first optimization performed is constantpropagation, where each use of a constant is replaced with its value.  This simplifies expressionsin the behavioral description and reduces the cost of the hardware that implements thoseexpressions.  For example, the expression xy can be implemented in hardware with n exclusiveNOR gates and one ninput AND gate, where x is an nbit variable, and y is an nbit constantwith value 17.  When constant propagation is applied, the resulting expression, x17, can beimplemented with just one ninput AND gate.  Next, Odin analyzes the flow of data in the DFGsin order to identify dead code statements that can be removed without affecting the behavior ofthe description that can be eliminated from the behavioral description.  Since dead code does notcontribute to the behavior of the design, Odin removes it before synthesis so that it is not mappedto hardware.  Dead code may result from previouslyapplied compiler optimizations, such asconstant propagation, or may be inadvertently introduced by the designer.  The final optimizationapplied to the DCFG is to unroll loops with definite limits, where the limits do not exceed aspecified maximum.  The statements within a loop are executed sequentially for each iteration ofthe loop.  When the data dependencies between the statements within the loop are such that they47can be executed in parallel, unrolling the loop reduces the number of clock cycles required toexecute the loop statement.6.4 HIGHLEVEL SYNTHESIS TECHNIQUESAn overview of the highlevel synthesis tasks of scheduling, allocation, and binding is givenin Sec. 3.1.  In this section, we describe the highlevel synthesis algorithms implemented inOdin.The first highlevel synthesis task that Odin performs is scheduling, where the operations ineach DFG are assigned to execute in specific clock cycles.  We have implemented Paulinsforceddirected scheduling algorithm Paulin 89a which attempts to minimize the area of thedata path logic by evenly distributing the number of operations executed in each clock cyclewithout increasing the total number of clock cycles for the DFG.  The scheduling algorithm usesthe delay and area attributes of the components in the component library to perform thisoperation.  After the schedule has been defined, operations in the DFG are bound to specificfunction blocks by a greedy algorithm that simply binds each operation in a clock cycle to thefirst available function block that performs that operation.  For example, for the first clock cyclein Fig. 66a, Odin first binds one of the addition operations to the ADD1 function block, thenbinds the second addition operation to the ADD2 function block.The register allocation and binding algorithms are implemented as described in Sec. 3, wherethe number of selfadjacent registers is minimized when a parallel BIST architecture is specifiedby the user.  We have also implemented a register allocation and binding algorithm that allowsselfadjacent registers in the data path logic, the only difference being that testability conflictedges are not added to the register conflict graph.  Having both algorithms allows us to compareparallel BIST implementations with implementations that have been optimized withoutconsidering testability.Odin generates multiplexers for the inputs of registers and function blocks in order toaccommodate the flow of data required by the scheduled, bound DFG.  Multiplexer generationfor register inputs is performed in a straightforward manner by using the DFG to determine thesource of data for each register at each clock cycle.  For example, the register in Fig. 64a thatreceives input data from variable c in the first clock cycle receives input data from the output ofADD2 in the second clock cycle and from the output of ADD1 in the third clock cycle.  Thisregister therefore requires a 3to1 multiplexer on its input as shown in Figs 64b and 64c.Generation of multiplexers for function block inputs is performed in the same manner exceptthat, when the operation is commutative, Odin attempts to reduce the size of the inputmultiplexers by permuting the function block inputs.  For example, Fig. 64b shows that two, 3to1 multiplexers are required for the inputs to ADD1 when the left and right inputs of the48addition operation in the DFG correspond to the left and right inputs of the function block in thedata path logic.  Since the addition operation is commutative, however, the left and right inputsto ADD1 can be switched for one or more clock cycles.  For this example, by switching theinputs for the second clock cycle, Odin generates two 2to1 multiplexers for the inputs of ADD1Fig. 64c.ADD1muxa b a b c emuxc dmux muxmux eADD2dADD1muxa b c emuxmux muxmuxADD2d1112a b cFigure 64 Highlevel synthesis example  a scheduled, bound data flow graph b datapath logic c data path logic with optimized multiplexers.The last synthesis operation that Odin performs is to generate a control logic state machinethat supplies register enable signals, multiplexer select signals, and function block control signalsto the data path logic.  Each block of data path logic corresponds to the DFG of a node in theDCFG and can be controlled by a modm counter, where m is the total number of clock cyclesfor the scheduled DFG.  The DFG counters are reset, enabled, and disabled by control logic thatis generated from information in the DCFG edges.  Odin combines all of the counters and theDCFG control logic into a single state machine.  Figure 65 is a possible control logic statemachine description for the process statement in Fig. 62, where Nij represents clock cycle j ofthe scheduled DFG of DCFG node Ni.  For example, DCFG node N2 in Fig. 62b represents theif statement in Fig. 62a.  Assume that the output of the if statement conditional expression, y x3, is generated in two clock cycles in data path logic.  Then, when the control logic statemachine in Fig. 65 is in state N21, the first clock cycle of the DFG for y  x3 is executed, andwhen the machine is in state N22, the second clock cycle is executed.  Odin generates a KISSformat description of the control logic state machine, then uses procedures from the SIS  logicsynthesis tool Sentovich 92 to perform state assignment and logic optimization, and to generatea circular BIST state machine implementation as described in Sec. 4.49N11 N21 N22N41 N42N31 N32y  x  3y  x  3go  1go  1Figure 65 Control logic state machine description for Fig. 62.507 CONCLUDING REMARKSIn this dissertation, we have described new synthesis techniques that generate builtin selftestable designs.  The primary objective of these synthesisforBIST techniques is to satisfyrequirements associated with a specific BIST architecture when generating the system logicstructural implementation.  Cost is minimized and performance is maximized to the extent thatBIST requirements are not compromised.  Considering BIST issues during system logicsynthesis allows for the generation of system logic that is optimized for a particular BISTarchitecture and that can be more effectively tested by the BIST operation.In particular, we investigated techniques for generating lowcost, builtin selftestable designsthat are free of the types of system bistable dependencies that can reduce the effectiveness of theembedded MISRs that are used to perform BIST operations.  We showed that some types ofsystem bistable dependencies can reduce the effectiveness of BIST, whereas other types ofdependencies can allow sharing of BIST and scan logic with system logic, thereby reducingBIST overhead.  Care must be taken, however, when system logic and BIST logic is shared, sothat the BIST operation effectiveness is not compromised.Our first synthesis technique, allocation and binding for parallel BIST Sec. 3, minimizes thenumber of selfadjacent registers in the generated design without increasing the latency of thedesign.  We have implemented the technique in our synthesisfor test design tool, and resultsshow that, for the examples investigated, our technique generates the lowestcost parallel BISTimplementation and generates system logic that is comparable in cost to techniques that do notconsider BIST during synthesis.  There is one situation for which the generation of a selfadjacent register is unavoidable without changing the schedule or operation binding of the inputdata flow description.  For this case, we use a CBILBO register, which breaks the selfadjacencyduring BIST operation.  CBILBOs have a higher cost than regular BILBO registers, but have theadvantage that they simultaneously perform the TPG and ORA operations.  This can allow for areduction in the number of test sessions required for BIST operation.  The scheduling andoperation binding techniques could be modified in order to minimize the number of unavoidableselfadjacencies encountered during register binding, and this is the subject of further research.In Sec. 2, we showed that generating an ideal parallel BIST architecture requires addressingcomplex implementation details such as TPG interconnections, multiple feedback logic blocks,and test session scheduling.  The synthesis technique described in Sec. 3 addresses only one ofthese implementation details  selfadjacent registers.  One advantage of the ideal parallel BISTarchitecture is that the assumptions made in the generation of theoretical results for TPG faultcoverage Kim 88 and ORA aliasing Daehn 90 characteristics are applicable, and these resultscan be used to estimate the test transparency of the BIST operation.  Unfortunately, the51remaining implementation complexities must be addressed by synthesis techniques beforeautomatic generation of an ideal parallel BIST architecture is feasible.  It may be necessary forthese techniques to consider more general system bistable rather than system registerdependencies during highlevel synthesis.The synthesis techniques described in Secs. 4 and 5 address the more general problem ofsystem bistable dependency during logic synthesis Sec. 4 and highlevel synthesis Sec. 5.Both techniques attempt to maximize sharing of system logic and test logic to reduce the costand improve the performance without increasing the test transparency of BIST architectures,such as circular BIST and parallel BIST, that make use of embedded MISRs.  We haveimplemented the logic synthesis technique described in Sec. 4 in our system design tool and usedit to generate circular BIST implementations of several sequential logic synthesis benchmarkcircuits.  For most of the benchmark circuits we investigated, the sizes of the circuits generatedby our technique did not differ significantly from the sizes of circuits with no scan dependence.However, better results for our technique should be possible when higherlevel synthesisoperations, such as state assignment and register binding, are biased toward generating moresystem bistables with beneficial dependence equations.  Results presented in Sec. 5 showed thatthis is true for the register binding operation when an orthogonal scan path configuration is used.The orthogonal scan path allows for greater sharing of BIST logic and commonlyused data pathlogic such as multiplexers and adders.While the synthesis technique described in Sec. 4 is applicable to any BIST architecture thatuses embedded MISRs, our implementation of the technique generates circular BIST designsbecause circular BIST has far fewer complex implementation issues than the parallel BISTarchitecture.  Unfortunately, theoretical results for TPG fault coverage and ORA aliasing are notvalid for circular BIST because of the dependence of the MISR inputs on the state of the MISR.Extensive fault simulations of the circular BIST implementation must therefore be executed toguarantee highquality BIST operation.  Fault simulations of the designs generated by oursynthesis technique show that the test transparency is comparable to circular BIST architecturesthat allow no scan dependence.  These simulations also showed that for two common designpractices, not including any BIST circuitry, or if circular BIST is implemented, ignoring scandependence, fault coverage can be high, but high error loss reduces the overall quality of theBIST operation.  This suggests that further investigation into techniques for improving the ORAcharacteristics of selfadjacent MISRs could yield lowercost, selftestable designs.52REFERENCESAbadir 85 Abadir, M. S., and M. A. Breuer, A KnowledgeBased System for DesigningTestable VLSI Chips, IEEE Des. and Test of Comput., pp. 5668, August 1985.Abramovici 90 Abramovici, M., M. A. Breuer, and A. D. Friedman, Digital Systems Testingand Testable Design, Computer Science Press, New York, NY, USA 1990.ACM 91 ACMSIGDA 1991 Logic Synthesis Benchmark Circuits, available via anonymousftp from mcnc.mcnc.org.Avra 90 Avra, L., and E. J. McCluskey, Behavioral Synthesis of Testable Systems withVHDL, Dig. COMPCON Spring 90, San Francisco, pp. 410415, February 26March 2, 1990.Avra 91 Avra, L., Allocation and Assignment in HighLevel Synthesis for SelfTestable DataPaths, Int. Test Conf., Nashville, TN, USA, pp. 463472, October 2630, 1991.Avra 92 Avra, L., Orthogonal BuiltIn SelfTest, COMPCON Spring 1992 Dig. of Papers,San Francisco, CA, USA, pp. 452457, February 2428, 1992.Avra 93 Avra, L. J., and E. J. McCluskey, Synthesizing for Scan Dependence in BuiltIn SelfTestable Designs, Int. Test Conf., Baltimore, MD, USA, pp. 734743, October 1721, 1993.Avra 94a Avra, L. J., and E. J. McCluskey, Synthesizing for Scan Dependence in BuiltInSelfTestable Designs, Center for Reliable Comput. Tech. Rpt. 942, Comput. Sys. Lab., CSLTR 94621, Stanford University, Stanford, CA, May 1994.Avra 94b Avra, L. J., L. Gerboux, J.C. Giomi, F. Martinolle, and E. J. McCluskey, ASynthesisforTest Design System, Center for Reliable Comput. Tech. Rpt. 943, Comput.Sys. Lab., CSL TR 94622, Stanford University, Stanford, CA, May 1994.Bardell 82 Bardell, P. H., and W. H. McAnney, SelfTesting of Multichip Logic Modules,Int. Test Conf., pp. 200204, November 1982.Bardell 87 Bardell, P. H., W. H. McAnney, and J. Savir, BuiltIn Test for VLSI  PseudorandomTechniques, John Wiley  Sons, Inc., 1987.Bardell 91 Bardell, P. H., and M. J. Lapointe, Production Experience with BuiltIn SelfTestin the IBM ES9000 System, Int. Test Conf. Proc., Nashville, TN, USA, pp. 2836, October2630, 1991.Bhatia 93 Bhatia, S. and N. K. Jha, Synthesis of Sequential Circuits for Robust Path DelayFault Testability, 6th Int. Conf. on VLSI Des., pp. 275280, January 1993.Bonnenberg 93 Bonnenberg, H, A. Curiger, N. Felber, H. Kaeslin, R. Zimmermann, and W.Fichtner, VINCI  Secure Test of a VLSI HighSpeed Encryption System,   Int. Test Conf.,Baltimore, MD, USA, pp. 782790, October 1721, 1993.53Brayton 87 Brayton, R. K., R. Rudell, A. SangiovanniVincentelli, and A. R. Wang, MIS  AMultipleLevel Logic Optimization System, IEEE Trans. on Comput.Aided Des., Vol. CAD6, No. 6, pp. 10621081, November 1987.Broseghini 93 Broseghini, J., and D. H. Lenhert, An ALUBased ProgrammableMISRPsedudorandom Generator for a MC68HC11 Family SelfTest,  Int. Test Conf.,Baltimore, MD, USA, pp. 349358, October 1721, 1993.Bryan 89 Bryan, D., F. Brglez, and R. Lisanke, Redundancy Identification and Removal, Int.Workshop on Logic Synthesis, Research Triangle Park, NC, May 2326, 1989.Cheng 89 Cheng, K. T., and V. D. Agrawal, An Economical Scan Design for Sequential LogicTest Generation, Int. Symp. FaultTolerant Comput., Chicago, IL, USA, pp. 2835, June 2123, 1989.Daehn 90 Daehn, W., T. W. Williams, and K. D. Wagner, Aliasing Errors in Linear AutomataUsed as MultipleInput Signature Analyzers, IBM J. Res. Develop., Vol. 34, No. 23, pp. 363380, MarchMay 1990.De Micheli 94 De Micheli, Giovanni, Synthesis and Optimization of Digital Circuits,McGrawHill, Inc., Hightstown, NJ, USA, 1994.Devadas 90 Devadas, S., and K. Keutzer, Synthesis and Optimization Procedures for RobustlyDelayFault Testable Combinational Logic Circuits, 27th Des. Autom. Conf., Orlando, FL, pp.221227, June 2429, 1990.Frieze 88 Frieze, A. M., An Algorithm for Finding Hamiltonian Cycles in RandomDirected Graphs, J. of Algorithms, pp. 181204, June 1988.Gage 93 Gage, R., Structured CBIST in ASICs,  Int. Test Conf., Baltimore, MD, USA, pp.332338, October 1721, 1993.Gelsinger 86 Gelsinger, P. P., Built In Self Test of the 80386, Int. Conf. Comput. Des., pp.169173, 1986.Gupta 91 Gupta, R., and M. A. Breuer, Ordering Storage Elements in a Single Scan Chain,IEEE Int. Conf. Comput.Aided Des., Santa Clara, CA, USA, pp. 408411, November 1114,1991.Hachtel 89 Hachtel, G. D., R. Jacoby, K. Keutzer, and C. Morrison, On the RelationshipBetween Area Optimization and Multifault Testability of Multilevel Logic, Int. Workshop onLogic Synthesis, Research Triangle Park, NC, May 2326, 1989.Hao 91 Hao, H., and E. J. McCluskey, Resistive Shorts Within CMOS Gates, Int. TestConf., Nashville, TN, USA, pp. 292301, October 2630, 1991.HLSW 92 1992 HighLevel Synthesis Workshop Benchmark Circuits, available viaanonymous ftp from mcnc.mcnc.org.54Hudson 87 Hudson, C. L. Jr., and G. D. Peterson, Parallel SelfTest with PseudoRandom TestPatterns, Dig. Int. Test Conf., Washington, DC, USA, pp. 954963, September 13, 1987.IEEE 88  IEEE Standard 10761987, IEEE Standard VHDL Language Reference Manual,IEEE Standards Board, 345 East 47th Street, New York, NY  10017, 1988.IEEE 90 IEEE Standard 1149.11990, IEEE Standard Test Access Port and Boundary ScanArchitecture, Institute of Electrical and Electronics Engineers, Inc., New York, NY, USA,1990.Illman 91 Illman, R., T. Bird, G. Catlow, S. Clarke, L. Theobald, and G. Willetts, BuiltInSelfTest of the VLSI Content Addressable Filestore, Int. Test Conf. Proc., Nashville, TN,USA, pp. 3746, October 2630, 1991.Jha 92 Jha, N.H., I. Pomeranz, S.M. Reddy, and R. Miller, Synthesis of MultiLevelCombinational Circuits for Complete Robust Path Delay Fault Testability, Int. Symp. onFaultTolerant Comput., Boston, MA, USA, pp. 280287, July 810, 1992.Kim 88 Kim, K, D. S. Ha, and J. G. Tront, On Using Signature Registers as PseudorandomPattern Generators in Builtin SelfTesting, IEEE Trans. on Comput.Aided Des., Vol. 7, No.8, pp. 919928, August 1988.Konemann 79 Konemann, B., J. Mucha, and G. Zwiehoff, BuiltIn Logic Block ObservationTechniques, 1979 IEEE Test Conf., Cherry Hill, NJ, USA, pp. 3741, 1979.Konemann 80 Konemann, B., J. Mucha, and G. Zwiehoff, BuiltIn Test for Complex DigitalIntegrated Circuits, IEEE J. of SolidState Circuits, Vol. SC15, No. 3, pp. 315319, June1980.Krasniewski 85 Krasniewski, A., and A. Albicki, Automatic Design of Exhaustively SelfTesting Chips with BILBO Modules, Int. Test Conf., Philadelphia, PA, USA, pp. 362370,November 1921, 1985.Krasniewski 89 Krasniewski, A., and S. Pilarski, Circular SelfTest Path  A LowCost BISTTechnique for VLSI Circuits, IEEE Trans. on Comput.Aided Des., Vol. 8, No. 1, pp. 4655,January 1989.Lake 86 Lake, R., A Fast 20K Gate Array with OnChip Test System, VLSI Systems Design,pp. 4655, June 1986.Langford 93 Langford, T., Utilizing Boundary Scan to Implement BIST,  Int. Test Conf.,Baltimore, MD, USA, pp. 167173, October 1721, 1993.Lee 93 Lee, T.C., N. K. Jha, and W. H. Wolf, A Conditional Resource Sharing Method forBehavioral Synthesis of Highly Testable Data Paths,  Int. Test Conf., Baltimore, MD, USA,pp. 744753, October 1721, 1993.LSI 91 LSI Logic 1.0Micron CellBased Products Databook, LCB007 CellBased ASICs,February 1991.55Mailhot 93 Mailhot, F., and G. De Micheli, Algorithms for Technology Mapping Based onBinary Decision Diagrams and on Boolean Operations,IEEE Trans. on Comput.Aided Des.,Vol. 12, No. 5, pp. 599620, May 1993.Martinolle 91 Martinolle, F., Fusion of VHDL Processes, Center for Reliable ComputingTechnical Report 917, CSLTN91384, Computer Systems Laboratory, Stanford University,Stanford, CA, USA, December 1991.McCluskey 81 McCluskey, E. J., and S. BozorguiNesbat, Design for Autonomous Test,IEEE Trans. on Comput., Vol. C30, No. 11, pp. 866874, November 1981.McCluskey 85 McCluskey, E. J., BuiltIn SelfTest Structures, IEEE Des. and Test, pp. 2936, April 1985.McCluskey 86 McCluskey, E. J., Logic Design Principles with Emphasis on TestableSemicustom Circuits, PrenticeHall, Englewood Cliffs, NJ, USA, 1986.McCluskey 88 McCluskey, E. J., S. Makar, S. Mourad, and K. D. Wagner, Probability Modelsfor PseudoRandom Test Sequences, IEEE Trans. on Comput.Aided Des., Vol. 7, No. 1, pp.6874, January 1988.McFarland 88 McFarland, M. C., A. C. Parker, and R. Camposano, Tutorial on HighLevelSynthesis, 25th ACMIEEE Des. Autom. Conf., Anaheim, CA, USA, pp. 330336, June 1215,1988.Mujumdar 92 Mujumdar, A., K. Saluja, and R. Jain, Incorporating Testability Considerationsin HighLevel Synthesis, Int. Symp. FaultTolerant Comput., Boston, MA, USA, pp. 272279,July 810, 1992.Narayanan 92 Narayanan, S., R. Gupta, and M. Breuer, Configuring Multiple Scan Chains forMinimum Test Time, Int. Conf. on Comput.Aided Des., Santa Clara, CA, USA, pp. 48,November 812, 1992.Nozuyama 88 Nozuyama, Y., A. Nishimura, and J. Iwamura, Design for Testability of a 32Bit Microprocessor, the TX1, Int. Test Conf. Proc., Washington, DC, USA, pp. 172182,September 1214, 1988.Pangrle 88 Pangrle, B. M., Splicer  A Heuristic Approach to Connectivity Binding, 25thDes. Autom. Conf., Anaheim, CA, pp. 536541, June 1215, 1988.Papachristou 91 Papachristou, C. A., S. Chiu, and H. Harmanani, A Data Path SynthesisMethod for SelfTestable Designs, 28th Des. Autom. Conf., San Francisco, CA, USA, pp. 378384, June 1721, 1991.Patel 93 Patel, R, and K. Yarlagadda, Testability Features of the SuperSPARCMicroprocessor,  Int. Test Conf., Baltimore, MD, USA, pp. 773781, October 1721, 1993.56Paulin 89a Paulin, P. G., and J. P. Knight, ForceDirected Scheduling for the BehavioralSynthesis of ASICs, IEEE Trans. on Comput.Aided Des., Vol. 8, No. 6, pp. 661679, June1989.Paulin 89b Paulin, P. G., and J. P. Knight, Algorithms for HighLevel Synthesis, IEEE Des.and Test of Comput., pp. 1831, May 1989.Pilarski 92 Pilarski, S., A. Krasniewski, and T. Kameda, Estimating Testing Effectiveness ofthe Circular SelfTest Path Technique,  IEEE Trans. on Comput.Aided Des., Vol. 11, No. 10,pp. 13011316, October 1992.Preissner 92 Preissner, J., G.H. HuamannBollo, G. Mahlich, J. Schuck, H. Sahm, P. Weingart,D. Weinsziehr, J. Yeandel, R. Evans, An Open Modular Test Concept for the DSP KISS16V2, Int. Test Conf., Baltimore, MD, USA, pp. 678683, September 2024, 1992.Ratiu 90 Ratiu, I. M., and H. B. Bakoglu, Pseudorandom Builtin SelfTest Methodology andImplementation for the IBM RISC System6000 Processor, IBM J. Res. Develop., Vol. 34,No. 1, pp. 7884, January 1990.Sentovich 92 Sentovich, E.M., J. K. Singh, C. Moon, H. Savoj, R. K. Brayton, and A.SangiovanniVincentelli,  Sequential Circuit Design Using Synthesis and Optimization, Int.Conf. on Comput. Des., Los Alamitos, CA, USA, pp. 328333, 1992.Sinaki 92 Sinaki, G., C17A Mission Computer Builtin Test and Fault ManagementStrategies, IEEE National Aerospace and Electronics Conf., Dayton, OH, USA, pp. 822828,May 1822, 1992.Starke 90 Starke, C. W., Design for Testability and Diagnosis in a VLSI CMOS System370Processor, IBM J. Res. Develop., Vol. 34, No. 23, pp. 355362, MarchMay 1990.Stroud 88 Stroud, C. E., Automated BIST for Sequential Logic Synthesis, IEEE Des. andTest of Comput., pp. 2232, December 1988.Tseng 86 Tseng, C.J., and D. P. Siewiorek, Automated Synthesis of Data Paths in DigitalSystems, IEEE Trans. on Comput.Aided Des., Vol. CAD5, No. 3, pp. 379395, July 1986.Turner 88 Turner, J. S., Almost All kColorable Graphs Are Easy to Color, J. of Algorithms9, pp. 6382, 1988.Yokomizo 92 Yokomizo, K., and K. Naito, A 333 MHz, 72 Kb BiCMOS Pipelined BufferMemory with Builtin Self Test, Symp. on VLSI Circuits, Seattle, WA, USA, pp. 3233, June46, 1992.Waicukauski 89 Waicukauski, J. A., E. Lindbloom, E. B. Eichelberger, and O. P. Forlenza, AMethod for Generating Weighted Random Test Patterns, IBM J. Res. Develop., Vol. 33, No.2, pp. 149161, March 1989.57Wang 86 Wang, L.T., and E. J. McCluskey, Concurrent BuiltIn Logic Block ObserverCBILBO, Int. Symp. on Circuits and Systems, San Jose, CA, USA, pp. 10541057, May 57,1986.Waser 82 Waser, S., and M. Flynn, Introduction to Arithmetic for Digital Systems Designers,Holt, Rinehart, and Winston, 1982.Zhu 88 Zhu, X.A., and M. A. Breuer, A KnowledgeBased System for Selecting TestMethodologies, IEEE Des. and Test of Comput., pp. 4159, October 1988.
