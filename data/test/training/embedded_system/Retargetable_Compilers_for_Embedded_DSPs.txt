Retargetable Compilers for Embedded DSPsRainer Leupers, Peter MarwedelUniversity of DortmundDepartment of Computer Science 1244221 Dortmund, Germanyemail leupersjmarwedells12.cs.unidortmund.deAbstractProgrammable devices are a key technology for the design of embedded systems, suchas in the consumer electronics market. Processor cores are used as building blocks formore and more embedded system designs, since they provide a unique combination offeatures exibility and reusability. Processorbased design implies that compilers capableof generating ecient machine code are necessary. However, highly ecient compilersfor embedded processors are hardly available. In particular, this holds for digital signalprocessors DSPs. This contribution is intended to outline dierent aspects of DSPcompiler technology. First, we cover demands on compilers for embedded DSPs, whichare partially in sharp contrast to traditional compiler construction. Secondly, we presentrecent advances in DSP code optimization techniques, which explore a comparativelylarge search space in order to achieve high code quality. Finally, we discuss the dierentapproaches to retargetability of compilers, that is, techniques for automatic generation ofcompilers from processor models.11 IntroductionThe consumer electronics market can be characterized by rapidly growing complexities ofapplications and a rather short market window. Therefore, more and more complex designshave to be completed in shrinking time frames. Meeting short timetomarket requirementsis only possible, if system design technologies permit exibility, so as to accommodate latespecication changes, and reuse of predesigned components. Both conditions are met, ifembedded processors are used as building blocks in system design. They provide exibilitythrough programmability and enable the reuse of software modules, such as C function libraries. Therefore, a trend towards processorbased design of embedded systems is currentlyobserved. As a consequence, the major part of design eort is frequently spent in development of embedded software rather than in design of custom hardware 1. Fig. 1 shows adesign scenario for embedded software. An application source program is specied, typicallyin C language, and is proled, so as to identify and possibly accelerate hot spots in theprogram. Next, machine code for the embedded processor is generated using a highlevellanguage compiler. The generated code is simulated and debugged, and the source programis adapted in case that errors have been identied. This process is iterated until a feasibleimplementation has been achieved.In most cases, code is generated for a xed processor only, for instance a certain standardDSP. However, such an otheshelf processor frequently is not the most ecient solution interms of computation speed, chip area, andor power consumption. Instead, an applicationspecic processormay much better serve the needs of a particular application. Therefore, froma more general viewpoint, the design or at least the selection of a suitable target processor1Publication 7th European Multimedia, Microprocessor Systems and Electronic Commerce ConferenceEMMSEC, FlorenceItaly, Nov 1997.1retargetingcompilermachinegenerationcode processor andfirmware synthesisinstruction setspecificationpoorresourceutilizationinsufficientperformanceincorrectbehaviorsource programspecificationprofilingOK analysiscodesimulationdebuggingFigure 1 Embedded software design owis also part of the embedded software design process. In such a scenario, an initial targetprocessor model, e.g. an instruction set, is specied and the compiler is retargeted to thatinstruction set. Then, the program is compiled as described above. Performance informationgained during the simulationdebugging phase or during a subsequent code analysis phase cansuggest benecial adaptations of the target processor model. This retargetandcompile cycleis iterated until a satisfactory solution in terms of both software and target processor hardware has been obtained. Finally, the target processor and the rmware machine programcan be synthesized. Retargetable and optimizing compilers for embedded processors havereceived much interest recently, because they permit to study the interplay of target hardwarearchitectures and program execution speed 2.In this paper, we focus on retargetable code generation for embedded DSPs. The organization of the paper is as follows. First, in section 2, we summarize the demands on compilers forembedded DSPs. In section 3, we consider code generation and, in particular, optimizationtechniques. Approaches to retargetable compilation are treated in section 4, and an examplefor a retargetable DSP compiler system is presented in section 5. Finally, conclusions aregiven in section 6.2 Demands on compilers for embedded DSPsDSPs are programmable processors with instruction sets that are tuned to fast executionof arithmeticintensive programs. The general demands on DSP compilers arise from thecharacteristics of DSP applications as well as from the characteristics of system environmentswhich DSPs are embedded in.Extremely ecient code DSP programs frequently operate under realtime constraints.Meeting realtime constraints usually requires exploitation of the full amount of capabilities of a DSP, so that very ecient code must be generated. Furthermore, as programcode is typically stored in onchip memories, also the size of machine programs is critical.Thus, any loss of eciency caused by a compiler increases the silicon area. In addition,violations of realtime constraints in compilergenerated code must be compensated byhigher clock rates. In turn, this increases the power consumption. In general compiler2construction, generation of extremely ecient code has traditionally been treated withlower priority than high compilation speed. Therefore, many C compilers available forstandard DSPs show an unacceptable code quality 3, and most of the DSP software isstill written at the assembly level.Support for DSP algorithms and architectures DSP algorithms show characteristicsusually absent in generalpurpose computing. These include bittrue specications,rounding behavior of arithmetic operators, and cyclic buers. DSP processor architectures include special hardware to accommodate such characteristics. However, common programming languages like C do not directly support DSPspecic programmingconstructs, but certain workarounds have to be used. In turn, this often disables thecompiler to eciently map such constructs to the corresponding hardware. One wayto avoid this problem is to use a DSPspecic programming language, such as DFL 4.Nevertheless, DSP compilers still face the problem of mapping program constructs tohighly irregular architectures, as they are typically found in DSPs.Retargetability A large number of processor cores, including microcontrollers, RISCs, andDSPs, are currently available from vendors 5. Cores are macro cells, which can beinstantiated like library components, and which are shipped in form of soft registertransfer RT level VHDL models or in form of hard VLSI layout cells. For suchcores, compilers might even be not available at all. In order to avoid the necessity ofdeveloping a new compiler for each new processor core, retargetable compilers are apromising solution. Such compilers can be adapted, so as to generate machine code foreach member of a dened class of processors. Retargetable compilers are also importanttools for the extended software development cycle outlined in section 1.3 Code generation and optimizationIn classical compiler construction, code generation and optimization are often treated asseparate compilation phases. First, a program is translated into a valid possibly poorqualitymachine program, which is later optimized by applying transformation rules. For DSPs, suchan approach is not viable, because irregularities in the processor architecture cause a highinterdependence between all dierent code generation phases. In order to avoid code qualityoverhead due to separate execution of code generation phases, phase coupling is necessary.For instance, instruction selection should be done while taking into account its impact onscheduling. Simultaneously, allocation of registers for program values must be considered.In order to minimize combinational delays and to permit pipelined execution of instructions,DSPs typically show specialpurpose registers connected to specic functional units in the datapath. Obviously, an unfavorable instruction selection may cause a large number of data movesbetween such registers.An important source of potential optimization is parallelism at the instruction level. MostDSPs are capable of executing a set of RT operations in parallel in each machine cycle. Thisincludes parallel operations such as multiplyaccumulate and also parallel computation ofmemory addresses. In order to cope with these special requirements, a number of new codegenerationoptimization techniques have been developed. Important projects in this areaincludeSPAM In the SPAM project, graphbased approaches to tight coupling of instruction selection, register allocation, and scheduling have been developed for dierent standardDSPs, such as TI TMS320C2x and Motorola DSP56k 6, 7, 8. In certain cases, optimality has been proven, and commercial compilers have been outperformed in terms ofcode quality. Further contributions from the SPAM project include optimization tech3niques for parallel memory address computation 9, 10, aiming at high utilization ofautoincrement capabilities of address registers.FlexWare In this project, a rulebased C compilation technique for applicationspecicDSPs has been implemented 11. There, compilation of source code constructs intotarget machine instructions is guided by translation templates provided by the user.The more templates are available, the higher is the optimization potential for the compiler. Additionally, the compilation process can be steered by lowlevel programmingconstructions, such as manual binding of values to physical registers. It has been shown,that this approach can yield code quality comparable to that of manually written assembly programs. However, detection of good translation rules may be dicult, and theeort of lowlevel C programming may become close to assembly programming. Anothercontribution of this project is a C to C translator, which replaces array references inprograms by pointer arithmetic operations 12. Since pointers and pointer arithmeticcan be directly mapped to address registers and arithmetic operations on these, a higherexploitation of autoincrement capabilities of address registers can be achieved than inthe original arraystyle C program.Mutation Scheduling The Mutation Scheduling MS approach developed at UC Irvine13 aims at a tight coupling of all dierent code generation phases. The main idea isto maintain dierent translation schemes mutations for each source program valueduring compilation. For instance, the value x  2 may be equivalently written as x x or x  1. If a value has multiple occurrences in a program, it may be recomputedeach time or may be kept in a register for later reuse. The most appropriate mutationsare selected based on data path resource availability in each program control step. Dueto its ideal phase coupling, MS can yield very high quality code, however, at theexpense of long compilation times.Another research project  the Record compiler  will be described in more detail in section5.4 Retargetable compilationRetargetable compilers are useful if target processors for embedded software change frequently,but the main architectural characteristics remain constant. In that case, these target processors belong to a common class, for instance the class of xedpoint DSPs. We call a compilerretargetable, if it can be adapted, so as to generate machine code for any processor within aclass, in such a way that the largest part of the compiler source code is retained. With retargetable compilers, target processors can be switched by simply adapting the compiler insteadof completely developing a new compiler from scratch. This is particularly important in thearea of consumer electronics, where a large variety of dierent applicationspecic processorsare in use. Retargetable compilers are also important for design space exploration in case thatthe target processor is not completely xed in advance see g. 1.A common characteristic of retargetable compilers is, that they read another input besidesthe source program to be translated, namely a target processor description given in some modelling formalism. A wellknown approach to retargetable compilation is the GNU C compiler14. GNU C has been successfully ported to a number of dierent CISC and RISC machines,but it does not support frequent changes of the target processor due to a complicated targetprocessor modelling formalism. Therefore, researchers have looked at more convenient processor modelling formalisms. In the projects mentioned in the previous section, retargetabilityis achieved as followsSPAM The target processor model mainly consists of a set of treeshaped instruction patterns, which are textually specied in form of a tree grammar. Code generation is4considered as the process of parsing source program assignments with respect to thegiven tree grammar. Retargeting to a new processor is realized by replacing instruction patterns in the grammar. However, the grammar can become relatively large, andpotential parallelism between instructions cannot be captured.FlexWare The target processor model is implicit in the set of translation rules that are provided to the compiler, i.e., new instructions are modelled by specifying new translationrules. The main problem in this approach, however, is that mainly the user  and notthe compiler  is responsible for ecient exploitation of available instructions, since thecompiler only applies the rules by a macroexpansion mechanism.Mutation Scheduling Similar to FlexWare, the available target machine instructions areimplicitly encoded in the set of possible mutations for each program value. However,the compiler is burdened with appropriately selecting instructions. Therefore, a higherdegree of automation and a higher optimization potential are achieved.All of the above approaches use rather specic processor modelling formalisms. However,as the design of processorbased systems usually takes place within a hardware design environment, standardized hardware description languages HDLs such as VHDL are a morepromising solution, because they permit to use the same processor models for synthesis, simulation, and code generation. The Record compiler presented in the next section thereforeuses processor models described in an HDL.5 An example the Record compiler systemRecord is a retargetable compiler for xedpoint DSPs 15. Its coarse architecture is shownin g. 2.DSP source programDFL languagetarget processor modelMIMOLA languageCDFG generation instructionsetextractiontree parser generationiburg  C compilercode selection andregister allocationintegratedscheduling  spillingmode register settingaddress assignmentcode compactionvertical code augmentedwith AGU operationstransformationrule libraryavailableRT patternsversions for RTs and NOPsalternative encodingapplicationspecificrewrite rulesexpression treesexpression treescovered by RT patternsvertical codetargetspecific tree parserFigure 2 The Record compiler system55.1 RetargetingThe target processor model is specied in the MIMOLA HDL, which corresponds to a subset ofVHDL. In contrast to other related approaches, Record accepts both behavioral instructionlevel and structural RTlevel processor models. The user may select the most comfortablemodelling abstraction level. Independent of its abstraction level, the target processor modelis translated into a canonical behavioral model by instructionset extraction ISE. ISE eliminates structural details from the model, which are not required for code generation, and yieldsa set of RT patterns, i.e., primitive data path operations executable on the target processoras well as the corresponding instruction encodings opcodes. From the extracted patternsset, an executable processorspecic code selector tree parser is constructed by means ofstandard tools. After performing these steps once, Record is retargeted to the speciedprocessor, and programs can be compiled into its machine code.5.2 Code generationIn order to accommodate the special characteristics of DSP algorithms, Record uses DFL 4as a source program language. The DFL program is compiled into an internal controldataow graph CDFG representation. The atomic CDFG entities are expression trees ETs,for each of which instruction selection and register allocation are invoked. These phasesare executed in an integrated fashion by means of the automatically generated processorspecic tree parser. The result is an optimal covering of the ET by means of RT patternswith respect to the accumulated costs of selected patterns. Covered ETs are passed to ascheduling phase which heuristically minimizes spill code for specialpurpose registers. Theresult of scheduling is vertical i.e. sequential machine code. The vertical code is augmentedwith additional operations which implement necessary memory address computations. In thisaddress assignment phase, several graphbased optimizations are applied, so as to achieve ahigh utilization of parallel address generation unit AGU capabilities. As a last compilationphase, the generated machine code is compacted, i.e., potential parallelism at the instructionlevel is exploited. During this phase, constraints imposed by the instruction format need to betaken into account. This information is passed to code compaction by means of the encodinginformation obtained by ISE. A novel compaction techniques implemented in Record ensuresoptimal exploitation of parallelism within basic program blocks. The nal result is a binarymachine code listing.5.3 ResultsRecord has been retargeted to several applicationspecic and standard DSPs, including TIsTMS320C25. Once a new HDL processor model is available, retargeting can be performedwith a few CPU minutes on a SPARCstation. Thus, very short turnaround times are achievedfor evaluating the impact of architectural changes in the target processor on program size andspeed. Due to the use of exhaustive code optimization techniques, the compilation speed israther low approx. 1 instr. per CPU second compared to a targetspecic compiler. However,lower compilation speed is usually acceptable for embedded applications, where programs areoften rather short. The point is that  at the expense of lower compilation speed  muchhigher code quality can be achieved. Fig. 3 shows an evaluation of relative code size for DSPbenchmark programs 3 and the TMS320C25 target processor. The handwritten referencecode is set to 100 . The left columns show the size of code produced by TIs TMS320C25C compiler. The right columns show the code size achieved by Record. For most cases, theRecord code is more compact, and in total the average overhead of compilergenerated codeas compared to handwritten assembly code has been halved.6real update complexmultcomplexupdateN realupdatesN complexupdatesfir biquadone biquadN dot product convolution0100200300400500600700Figure 3 Experimental results code quality6 ConclusionsDesign of embedded systems based on programmable processors demands for compilers capable of generating very ecient code. The key approach to achieve this goal is the developmentof novel code optimization techniques, while treating compilation speed with lower prioritythan in classical compiler construction. Simultaneously, the large variety of applicationspecic embedded processors create a need for retargetable compilers, that can be quicklyadapted to new processors, so as to study the mutual dependence between processor architectures and program execution speed. In this paper, we have presented dierent recentapproaches to retargetable and optimizing compilers with emphasis on DSPs. More and moresystem designs are primarily based on programmable processors rather than on custom hardware. It is therefore expected that such compilers can enable a productivity breakthrough inembedded system design, as they permit to take the step from assemblylevel to highlevellanguage software development.7References1 P. Paulin, M. Cornero, C. Liem, et al. Trends in Embedded Systems Technology, in M.G.Sami, G. De Micheli eds. HardwareSoftware Codesign, Kluwer Academic Publishers,19962 P. Marwedel, G. Goossens eds. Code Generation for Embedded Processors, KluwerAcademic Publishers, 19953 V. Zivojnovic, J.M. Velarde, C. Schlager, H. Meyr DSPStone  A DSPoriented Benchmarking Methodology, Int. Conf. on Signal Processing Applications and Technology ICSPAT, 19944 Mentor Graphics Corporation DSP Architect DFL Users and Reference Manual, V8.2 6, 19935 World Wide Web httpwww.eedesign.comEEdesignSoftCoretables.html andhttpwww.eedesign.comEEdesignHardCoretables.html6 G. Araujo, S. Malik Optimal Code Generation for Embedded Memory NonHomogeneousRegister Architectures, 8th Int. Symp. on System Synthesis ISSS, 1995, pp. 36417 S. Liao, S. Devadas, K. Keutzer, S. Tjiang, A. Wang Code Optimization Techniques forEmbedded DSP Microprocessors, 32nd Design Automation Conference DAC, 1995, pp.5996048 G. Araujo, S. Malik, M. Lee Using Register Transfer Paths in Code Generation for Heterogeneous MemoryRegister Architectures, 33rd Design Automation Conference DAC,19969 S. Liao, S. Devadas, K. Keutzer, S. Tjiang, A. Wang Storage Assignment to DecreaseCode Size, ACM SIGPLAN Conference on Programming Language Design and Implementation PLDI, 199510 G. Araujo, A. Sudarsanam, S. Malik Instruction Set Design and Optimizations forAddress Computation in DSP Architectures, 9th Int. Symp. on System Synthesis ISSS,199611 C. Liem, P. Paulin, M. Cornero, A. Jerraya Industrial Experience Using RuledrivenRetargetable Code Generation for Multimedia Applications, 8th Int. Symp. on SystemSynthesis ISSS, 1995, pp. 606512 C. Liem, P.Paulin, A. Jerraya Address Calculation for Retargetable Compilation andExploration of InstructionSet Architectures, 33rd Design Automation Conference DAC,199613 S. Novack, A. Nicolau, N. Dutt A Unied Code Generation Approach using MutationScheduling, chapter 12 in 214 R.M. Stallmann Using and Porting GNU CC V2.4, Free Software Foundation, CambridgeMassachusetts, 199315 R. Leupers Retargetable Code Generation for Digital Signal Processors, Kluwer Academic Publishers, 19978
