Efficient Hardware Accelerator for IPSec based onPartial Reconfiguration on Xilinx FPGAsAhmad Salman, Marcin Rogawski and JensPeter KapsVolgenau School of EngineeringGeorge Mason UniversityFairfax, Virginia 22030email asalman, mrogawsk, jkapsgmu.eduAbstractIn this paper we present a practical lowend embedded system solution for Internet Protocol Security IPSec implemented on the smallest Xilinx Field Programmable Gate ArrayFPGA device in the Virtex 4 family. The proposed solutionsupports the three main IPSec protocols Encapsulating SecurityPayload ESP, Authentication Header AH and Internet KeyExchange IKE. This system uses efficiently hardwaresoftwarecodesign and partial reconfiguration techniques. Thanks toutilization of both methods we were able to save a significantportion of hardware resources with a relatively small penaltyin terms of performance. In this work we propose a division ofthe basic mechanisms of IPSec protocols, namely cryptographicalgorithms and their modes of operation to be implementedeither in software or hardware. Through this, we were able tocombine the high performance offered by a hardware solutionwith the flexibility of a software implementation. We show thata typical IPSec protocol configuration can be combined withPartial Reconfiguration techniques in order to efficiently utilizehardware resources.Index TermsPartial reconfiguration IPSec Xilinx FPGAI. INTRODUCTIONInternet Protocol Security IPSec 13 provides securityagainst attacks on data transmitted over the Internet throughsecurity services facilitated by a set of protocols. It was designed to operate at the level of the Internet layer according tothe OSI network model. This makes it completely transparentto applications and users.The security services provided by the Internet ProtocolSecurity IPSec include Confidentiality  Prevents unauthorized access to thetransmitted data. Data integrity  Ensures data was not altered duringtransmission. Authentication  Enables the identification of the information source.The IPSec series of protocols makes use of various cryptographic algorithms such as encryption modules, hash functionsand modular arithmetic in order to provide security services.The Internet Key Exchange IKEv2 protocol in version twohas to be used to establish secure connections, so called Security Associations SAs. IKEv2 uses cryptographic algorithmskey exchange algorithm DiffieHellman and pseudo randomfunction based on the Advanced Encryption Standard AESin XCBC modeAESXCBCPRF128. The EncapsulatingSecurity Payload ESP protocol provides mechanisms forconfidentiality and data integrity services. It uses AES cipherin CipherBlockChaining CBC and Counter CTR modes ofoperation. The Authentication Header AH protocol providesconnectionless integrity and data origin authentication. AHuses Hashed Message Authentication Code HMAC withSecure Hash Algorithm SHA. To assure protection andstandardization, the minimum set of cryptographic algorithmsthat must be supported by an implementation of IPSec forESP, AH and IKEv2 protocols as stated in 2 is illustrated inTable I.TABLE IIPSEC SUPPORTED PROTOCOLS AND ALGORITHMSProtocol Security Service ProvidedSupported AlgorithmESP confidentiality throughencryption and optionaldata integrityAES in CBC or CTR modeAH connectionlessintegrity and dataorigin authenticationHMACSHA196, AESXCBCMAC96, HMACSHA256IKE negotiates connectionparametersDiffieHellman scheme in1024 or 2048 bits groupsand AES in PRNG modeDue to the broad use of IPSec, it has been implemented inhardware and software with various designs and parameters tosuit different platforms and provide better solutions. Amongpopular implementations of IPSec in hardware are those thattarget FPGA platforms because of the flexibility they offer thedesigner, ease of programming and high speeds that cannotbe achieved through software. Due to the fact that FPGAsare resource limited devices, even efficient implementationsof IPSec with all the services it provides might not fit onlow cost devices or low area devices that are meant for lightweight implementations 4. A solution to this problem can bePartial Reconfiguration which allows some IPSec services tobe available in the system and the remaining services can berecalled when needed by an application.Partial Reconfiguration 5 is a configuration method forFPGAs that allows certain portions of the device to be reconfigured during runtime without affecting other portions inthe system or their functionality. In this paper we will investigate the effect of implementing IPSec services using PartialReconfiguration in terms of speed, area and reconfigurationtime. For that, we built an embedded system controlled throughan embedded processor to provide self reconfiguration of thesystem through a software application. We implemented theembedded system using the Microblaze softcore processortargeting a low area Virtex4 device to perform thoroughtesting on the proposed design and analyze the results.The rest of this paper is organized as follows In Sect. II wediscuss previous work, Sect. III is devoted to the descriptionof our proposed system, and Sect. IV describes the experimentmethodology we followed to evaluate the system. Sect. Vdiscusses and analyze the results and we draw conclusionsin Sect. VI.II. PREVIOUS WORKOne important software implementation of IPSec was developed within the KAME project 6. Racoon software whichis part of the KAME project is a tool for handling InternetKey Exchange IKE in IPSec and almost all of its sourcecode has been merged into FreeBSD and NetBSD. Hardwareimplementations of IPSec basic components were investigatedin several publications. In 7 a hardware coprocessor wasproposed based on AES and HMACSHA1 cores. This solution was implemented on XCV1000E Xilinx Virtex device. Animplementation on Xilinx VirtexII Pro FPGA was presentedin 8. The key management and negotiation functions weremoved into software. The encryption and data integrity supportwas based on AES, HMACMD5 and HMACSHA1. Thosealgorithms were implemented on a single device and allhardware cores achieved over 1 Gbs throughput.A typical node connected to the Internet has to processmultiple different streams of data. The efficient handling, ofthose streams of data, was investigated in 9 which proposedpipeline techniques on HMACSHA1.A very complex system such as an IPSec embedded solutionrequires finding the correct balance between flexibility and performance in a design. Principles of the hardwaresoftware codesign techniques are described in 10. A proposed embeddedsolution for only the IPSec AH protocol can be found in 11.There are also hardware accelerators of the IPSec protocolsuite available as commercial products 12, 13 and 14.A Partial Reconfiguration 5 technique is relatively new inthe area of SRAM based Altera devices 15 and it is onlysupported in the newest 28nm Stratix V. In the case of Xilinxdevices 16 this method has been known for almost a decade,but due to the complex nature it has never been very popularin both commercial and academic applications.To the best of authors knowledge, the first utilization ofpartial reconfiguration on Xilinx FPGA devices for IPSec wasproposed in 17.III. SYSTEM DESCRIPTIONA. OverviewOur proposed IPSec embedded systems structure is summarized in Table II. We implemented three cryptographictransformations in hardware where at any given point intime, only one is available for its utilization. In order touse a different algorithm than the one currently available,partial reconfiguration operation is performed. This processis controlled by a modified Round Robin with time sharingscheduling algorithm 18 implemented on the embeddedprocessor. Packets are sent from and received by the systemthrough input and output queues. The input queues sendpackets to be processed by the corresponding cryptographicalgorithm and the output queue is devoted for storing theoutput results as shown in Fig. 1.The Round Robin scheduling algorithm is used for switching the control between queues when packets are ready to beprocessed. In this system, we use a configurable time slot valuewhich specifies for how much time packets from one queueare being processed before switching to another queue. Even ifthe current queue still contains data the processor switches toa different queue to make sure that no specific type of packetsmonopolize the coprocessor. We will show in Sect V that thetime slot parameter can be considered as a tradeoff betweentotal throughput of the proposed system and latency of packettransition through the IPSec coprocessor.ProcessorESP QueueAH QueueIKEV2 QueueOutput QueueSoftwareHardwareIPSECcoprocessorSchedulingAlgorithmEmbeddedSystemFig. 1. Synchronization Circuit Between Hardware and SoftwareFor example, if the scheduler assigned a time slot for thepackets that require AES operation ESP packets, the CPUmakes sure that the AES module is currently running on thecoprocessor otherwise it performers partial reconfiguration tomake it available for the assigned packets. If the time slotexpires and there are new packets in the SHA2 AH Packetsrelated queue then another partial reconfiguration operationis required to load the SHA2 module to the coprocessor.After this operation is completed, the packets from SHA2 related queue can be transmitted to IPSec coprocessor.The transmission between the embedded processor and coprocessor requires hardwaresoftware synchronization whichis described in the synchronization circuit subsection.We can observe that the system latency consists of thelatency of data preparation for computation and latency of thecomputation process itself. The latency of the data preparationincludes the time needed to perform partial reconfiguration.The latency of computation consists of latency of inputtransmission to the hardware core, latency of cryptographictransformation and finally the time for sending and storing theresult. It is clear that in order to utilize the coprocessor moreefficiently, the time for computations should be maximizedcompared to the time needed for data preparation. On theother hand, if both latencies are too high, the responsivenessof system will degrade. Finally, in order to maximize theefficiency of computation time, the interface latency needs tobe minimal.TABLE IIHARDWARESOFTWARE CODESIGN IMPLEMENTATION DETAILS OFPROPOSED IPSEC SYSTEMImplementationIn Hardware In Software ApplicationAES CBC, CTR modes ESPMACXCBC96 AHXCBCPRF128 IKEv2SHA256 HMAC AHMODEXP Montgomery domain IKEv2transformations Round Robin PR triggerscheduling algorithmB. Partial ReconfigurationPartial Reconfiguration PR 5 is the process of configuring a portion of a FPGA while the other part is still running 5.The PR method is independent of its implementation method,meaning that although the idea of creating a partially reconfigurable design is the same between different companies andPLD manufacturers like Xilinx and Altera, each has their owntools and implementation methods.A typical PR system is composed of static regions knownas Base Region BR and a dynamic region known as PartialReconfigurable Region PRR. The BR holds the portion ofthe design that does not get affected by partial reconfigurationwhile the PRR holds the portion of the design that getsswapped during partial reconfiguration process which is knownas Reconfigurable Modules RM. A PRR is composed of atleast a single RM and usually multiple ones as shown in Fig. 2.MODEXPEmbeddedProcessorIPsecCoprocessorPRRMBFPGAICAPSoftwareRMRMMemoryExternalSHA256AESRMFig. 2. A Partial Reconfigurable Region and Associated ReconfigurableModulesIn our design, the BR includes an embedded processor thatcontrols the PR process and some supporting peripherals whilethe PRR includes hardware accelerators for IPSec protocols.Initially the system is configured with the BR and the PRR isloaded with one of the RMs or left blank with no RM loaded.The remaining RMs are stored on an external memory and areswapped with other RMs by the scheduler.During PR, the embedded processor communicates with theInternal Configuration Access Port ICAP which loads thepartial bitstream that holds the information of the requestedRM from the external memory and replaces the currentlyrunning RM or the blank space in the PRR with it duringruntime as shown in Fig. 2.BMPLBPLBMicroblazeCNTRLBRAMBRAMOPBPLB2OPBBridgeOPB2DCRBridgeDCRSocketPRRSystem  ACECFICAP UARTEnableBMFig. 3. Embedded System Processor and PeripheralsC. HardwareOur design targets the ML403 board with a Virtex4 device described in 19. Although the target device includesa PowerPC embedded processor, the softcore Microblazeprocessor was used as the embedded processor in the designto insure compatibility with other devices that do not includea PowerPC. Figure 3 shows our embedded system block diagram. The internal data bus for the Microblaze processor is32bit wide. It is connected to the BRAMblock peripheralthrough the Processor Local Bus PLB BRAM InterfaceController BRAM IF Ctrl which is interfaced to the PLBBus. The BRAMblock peripheral gives the processor accessto the BRAM components which constitute the memory of thesystem.The peripherals in the system are interfaced with eachother and the Microblaze through the Onchip PeripheralBus OPB. Peripherals in the system include a UniversalAsynchronous ReceiverTransmitter UART for debuggingand output display, a System ACE to interface a FAT32Compact Flash CF memory card used as the nonvolatilememory that holds the partial bitstreams of the RMs andthe Hardware Internal Configuration Access Port HWICAPwhich is the hardware peripheral that enables the Microblazeto access and modify the configuration memory while thecircuit is operational through the ICAP. There is a customperipheral which represents the PRR in the system which isthe target for the RMs. This custom peripheral is interfaced tothe system through the Device Control Register DCR bus.There are also two bus bridges used, the plb2Opb bridge andopb2dcr bridge, to allow the communication between differentbuses in the system and the peripherals interfaced to them.Bus Macros BMs are used to provide a means of lockingthe routing between RMs and the BR, making the RMs pincompatible with the base design. With the exception of globalclock signals, all other signals including reset signals mustpass through BMs. During PR process, the Microblaze disablesBMs using a Bus Macro EnableDisable signal as shown inFig. 3 to prevent data from being sent to or received from thetarget PRR until the PR process is completed then BMs areenabled again.The PRR in the system is composed of three RMs, Advanced Encryption Standard AES, Secure Hash AlgorithmSHA256 and a modular exponentiation module MODEXPrepresenting the hardware accelerators for the IPSec ESP, AHand IKEv2 protocols respectively.The AES hardware core is based on a 128bit datapathand the latency is 11, 13 and 15 clock cycles for 128, 192and 256bit main key length, respectively. This architecture isdescribed in 20. The SHA256 hardware implementation isbased on the architecture with the best throughputarea ratioproposed in 21. The modular arithmetic is based on the high216 radix multiplication Algorithm 3 proposed in 22 andon the exponentiation algorithm proposed in 23. In order tosave area, we decided to restrict the number of processingelements to one, which can be described by the parametersword size  16 bits, number of scanned bit  16. Thanksto this assumption our basic processing element could beefficiently implemented on just 3 DSP blocks. We decidedto exploit special shift register mode SRL16 to organizestorage system for arithmetic arguments and intermediateresults. Our very restricted area budget did not allow us touse directly FPGA optimized architectures proposed in 24or 25. All three cores support a simple FIFO based interfacedescribed in 26 where the input and output data width is 32bit wide.D. SoftwareThe software portion of the system includes the softwaredrivers for the hardware peripherals in the system, somebasic C libraries as well as Initialization functions for theHWICAP and the ICAP API. In addition to that, all modes ofoperations e.g. CBC and XCBC and data preparation e.g.HMAC calculations are being done in software to give thesystem flexibility as these operations can be used with differentcryptographic algorithms by applying minimal softwareonlychanges to the system.E. Synchronization CircuitAs the speed of hardware is significantly higher thansoftware, any hardwaresoftware codesign should include asynchronization method between the hardware and softwareto assure correctness of communication and prevent data loss.We created a hardwaresoftware synchronization circuit with aFIFO interface shown in Fig. 4. Sending and receiving data iscontrolled by control signals from the embedded processor.When data is being sent from software to the hardwarecore, the processor sets the read ack signal to high enablinghardware to read data in 32 bit at a time according to the coresettings. After the core performs calculations, data is sent fromhardware to software in the same manner with the processorsetting the write ack signal to high to let the software knowthat the output is ready.1111FFin outrst32111 13232rstBUS2IPclksrcreadysrcreaddstreadydstwritedatain dataoutBUS2IPrst32FFoutrstinRDACKSHAAESMODEXPSoftware Input Register Software Output RegisterWRACKFig. 4. Synchronization Circuit Between Hardware and SoftwareIV. METHODOLOGYA. OverviewBefore implementing the proposed design in a PR system,we first implemented it in a nonPR system. The main reasonfor the nonPR implementation was to make sure that theAES, SHA256 and MODEXP cores perform as expected andproducing the correct results at runtime. We also wanted totest the synchronization circuit and to find out the amountof area consumed by each core implemented separately tocompare it to that of the PR design.The bottleneck in the design is the PR process, i.e. theprocess of replacing one module with another. PR is a timeconsuming process which increases the system latency hencedecreasing performance. This could make the design impractical. Therefore, we used the scheduling algorithm describedin the Sect. III to increase the throughput.To test the design, we emulated IPSec traffic through asequence as input to the system. The sequence starts withan IKEv2 packet for handshaking, algorithm selection andsharing of keys. The reset of the sequence is composedof string of bits representing the data portion in the ESPand AH packets. Packets are identified and assigned to thequeues corresponding to their type. The scheduler always startsfrom the IKEv2 queue when a new SA is established. Forthis reason, the MODEXP module should be loaded to thePRR during the initial FPGA configuration. Following SAestablishment, the scheduler assigns packets to the Microblazeto be processed by the hardware.B. IKEv2 vs AH and IKEv2 vs ESPIn a typical IPSec Security Policy Database SPD tunnelconfiguration, a connection parameter renegotiation is established no more than once per hour. Even though there aresome applications that require more exotic configurations. AHand ESP protocol handling will take more than 99 of anypractical IPSec coprocessor. Due to that fact, the IKEv2is rarely used compared to AHESP. The MODEXP, whichis a basic module for this protocol, can be swapped withAHESP accelerators when needed. The AH and ESP hardwareaccelerators are also being used interchangeably on the chipusing PR but due to the fact that they are both used excessively,techniques like using input queues or on board memory aswell as packets scheduling algorithms as we described in theprevious section should be used to allow for high throughput.C. AH vs ESPIn the case of ESP and AH protocols the situation withefficient Partial Reconfiguration is more complicated. Firstof all, the number of tasks related to AH vs ESP is morebalanced than in case of IKEv2. This means that in orderto decrease the influence of relatively expensive, in termsof latency, partial reconfiguration operation, we have to usescheduling of tasks. We selected Round Robin with timesharing scheduling algorithm, because it is a very simpleand well known scheduling algorithm. One very importantproperty of this algorithm is its security against the starvationproblem 18.V. RESULTS DISCUSSIONThe design was synthesized and implemented using Xilinx Design Suite 9.1 as it supports PR design implementations as well as nonPR designs. The target device is theXC4VFX12 Virtex4 FPGA on the ML403 board. We choosethe XC4VFX12 FPGA because it is a low cost high speeddevice and has enough area to implement the proposed design. The SHA256 and AES cores were verified individuallyusing test vectors provided by FIPS standards 27 and 28respectively. The MODEXP arithmetic core was verified usingtest vectors generated by the OpenSSL protocol suite 29.The implementation results are summarized in Table III. Thefirst two columns summarize the resources of the static anddynamic portions of the system. The other three columns areimplementation results for each of the three cores AES, SHA256 and MODEXP implemented independently in nonPRdesigns. When comparing the dynamic portion of the designto the nonPR implementations, it can be noticed that thePR design uses 2148 slices compared to 3285 slices used bythe three nonPR designs combined together. This is an areaimprovement of more than 34. These area savings are opento further improvements if more RMs are available for thesame PRR. Which means that other cryptographic algorithmssupported by IPSec can be added without requiring additionallogic resources.Not only is the PR design more resource efficient, it alsomakes implementing an embedded processor with the IPSeccoprocessor feasible on the target platform. When Implementing all three cores as parallel independent IP cores in a singlenonPR processor system, The Microblaze adds an overhead tothe area of each core. This area increase in addition to routingissues makes the target device fails to accommodate a fullyparallel implementation of the design.A. Latency vs ThroughputAs a systems performance is measured by area and throughput together. We wanted to test how the overhead time causedby the PR process degrades performance. The most commonscenario is when the system processes IKEv2 and ESP packets.Initially the system has to perform PR to load Modxp RMto process IKEv2, perform PR again to load AES RM andprocess ESP packets until the time slot for ESP expiresas shown in Fig. 5a. Then this scenario repeats. During PRand IKEv2 processing, ESP packets are being received andbuffered in the ESP queue. The amount of bits buffered is alsoshown in Fig. 5a. This buffer size defines the size of the queuefor each protocol depending on the time slot assigned as wellas the network traffic. Once the AES RM is loaded, processingof ESP packets starts. ESP has to process the packets fasterthan the arrival rate such that the ESP queue is empty when theESP time slot expires. Hence, the ESP throughput is dependingon the ratio of ESP time slot versus the time required for PRand IKEv2 processing as shown in Fig. 5b.Bits BufferedPR ESP time slotProcessing timeBuffering timeTimePR IKEV2a Buffer level depending on operation0 20 40 60 80 100 120 140 160 180 0 100 200 300 400 500 600 700 800 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 2.1 2.2 Throughput Buffer Buffer SizeMb ThroughputMbs ESP Time Till PRs Maximum Throughput b AES hardware core performance depending on size of time slotFig. 5. AES hardware core performance dependency on ESP time slot forthe 32bit internal interface widthIt can be shown that in order to reduce the effect of PRon the total time time needed from packet received by thesystem to sent back after being processed, the amount oftime assigned for computations encryptionhashing shouldbe increased. For example, if the PRR is loaded with the AEScore module, then the scheduling algorithm should direct theMicroblaze to fetch tasks from the ESP queue as long as itTABLE IIIRESOURCES SUMMARY FOR IMPLEMENTATIONS ON XC4VFX12 VIRTEX4 FPGADevice Utilization PR Design NonPRSummary ImplementationStatic Dynamic AES core SHA256 core MODEXP coreResource Logic Used Utilization Used Utilization Used Utilization Used Utilization Used UtilizationNumber of Slices 1588 29 2148 39 1862 34 924 16 499 9Number of Slice Flip Flops 1566 14 1008 9 807 7 1008 9 421 4Number of 4 input LUTs 2059 18 3600 32 3600 32 1620 14 861 9Number of DSP48 0 0 3 9 0 0 0 0 3 9Number of FIFO16RAMB16s 33 91 0 0 1 2 0 0 0 0is not empty or the other queues are not full. The less PR istriggered, the higher the throughput.Fig. 6 is a 3D representation of the systems total throughputcalculated from the time slots assigned for AH and ESPprotocols. The graph shows that the maximum throughput isachieved when more ESP packets are processed within a timeslot as the AES core has the highest throughput among all threecores. As more time is assigned to AH packets processing, theoverall throughput decreases. If the work is evenly dividedamong both protocols, then the system will achieve a totalthroughput higher than the maximum throughput of the SHA256 core but lower than that of the AES core.0.1 0.3 0.5 0.7 0.9 1.1 1.3 1.5 1.7 250 300 350 400 450 500 550 600 650 0.1 0.3 0.5 0.7 0.9 1.1 1.3 1.5 1.7 Throughput Mbs Fig. 6. 3D representation of the overall system performance dependency onprocessing time assigned to ESP and AH protocolsThese results indicates that it is practical to use our designfor higher traffic networks where the flow of packets to theinput queues allows the scheduler to assign tasks that willminimize PR which will increase the throughput.VI. CONCLUSIONWe implemented a PR design to perform IPSec protocoloperations in hardware. The design is divided into a staticregion representing a Microblaze embedded processor withsome supporting peripherals and the dynamic region representing an IPSec coprocessor to perform AH, ESP andIKEv2 calculations using hardware accelerators. The resultsindicate that the PR design shows significant improvementsin terms of area savings compared to nonPR designs. Thesesavings in area can be further improved if more cryptographicalgorithms supported by IPSec are implemented as RMs inthe coprocessor. A scheduling algorithm was used to handletask assignments to minimize the effect of additional latencycaused by the PR process. Another advantage of this solutioncan be observed when comparing utilization time of IKEv2functions against ESP and AH functions. Implementing ahardware accelerator for IKEv2 as a RM not only saves areawith almost no time penalty, but it also protects the modulefrom attacks especially if it was preloaded with keys. In thecase of ESP and AH hardware accelerators, the traffic flowshould be high to minimize PR and increase throughput.VII. FUTURE WORKWe would like to investigate our system on a Virtex6platform and compare its results to this work to see what theimpact of the new bitstream authentication is on the overallperformance of the Virtex6. We would also like to investigatehow implementing the AES core as part of the static regionand only implementing the SHA256 and MODXP cores asRMs affects the throughputarea of the system. This analysisis interesting because our AES core is comparatively large andAES is used by ESP, AH, and IKEv2.REFERENCES1 RFC4301, httpwww.ietf.orgrfcrfc4301.txt, 2005.2 RFC4308, httpwww.ietf.orgrfcrfc4308.txt, 2005.3 RFC4309, httpwww.ietf.orgrfcrfc4309.txt, 2005.4 J.P. Kaps, Cryptography for ultralow power devices, Ph.D. Dissertation, ECE Department, Worcester Polytechnic Institute, Worcester,Massachusetts, USA, May 2006.5 Early Acess Partial Reconfiguration, User Guide, Ug208 v1.1 ed.,Xilinx, Inc., Mar 2006.6 K. Project, httpwww.kame.netprojectoverview.html, 2006.7 M. McLoone and J. McCanny, A singlechip IPSEC cryptographicprocessor, in Signal Processing Systems, 2002. SIPS 02. IEEEWorkshop on, Oct 2002, pp. 133138.8 J. Lu and J. Lockwood, Ipsec implementation on xilinx virtexii profpga and its application, in Reconfigurable Architecture Workshop,RAW, 2005.9 A. P. Kakarountas, H. Michail, A. Milidonis, C. E. Goutis, andG. Theodoridis, Highspeed fpga implementation of secure hash algorithm for ipsec and vpn applications, The Journal of Supercomputing,vol. 37, no. 21, pp. 179195, Aug 2006.10 P. R. Schaumont, A Practical Introduction to HardwareSoftware Codesign. Springer, 2010.11 H. Michail, G. Athanasiou, A. Gregoriades, C. L. Panagiotou, andS. Goutis, High throughput hardwaresoftware codesign approach forsha256 hashing cryptographic module in ipsecipv6, Global Journalof Computer Science and Technology, vol. 10, no. 4, pp. 5459, June2010.12 Fortinet, httpwww.fortinet.comproductsfortigate, 2011.13 An Introduction to the Helion IPsec ESP Engine, v. 1.0.0 ed., HelionTechnology Limited, 2006.14 Sun Crypto Accelerator 4000 Board, v. 1.1 ed., Sun Microsystems, Inc.,2004.15 Increasing Design Functionality with Partial and Dynamic Reconfiguration in 28nm FPGAs, v. 1.0 ed., Altera Corporation, 2010.16 Partial Reconfiguration, User Guide, Ug702 v12.1 ed., Xilinx, Inc.,May 2010.17 A. A. Salman, IPSec implementation in embedded systems for partialreconfigurable platforms, Masters Thesis, ECE Department, GeorgeMason University, Fairfax, Virginia, USA, May 2011.18 A. Silberschatz, P. B. Galvin, and G. Gagne, Operating System Concepts.Wiley, 2008.19 ML401ML402ML403 Evaluation Platform, User Guide, Ug080v2.5 ed., Xilinx, Inc., May 2006.20 K. Gaj and P. Chodowiec, Cryptographic Engineering. Springer, 2009,ch. FPGA and ASIC Implementations of AES, pp. 235294.21 R. Chaves, G. Kuzmanov, L. Sousa, and S. Vassiliadis, Improving sha2hardware implementations, in Cryptographic Hardware and EmbeddedSystems  CHES 2006, Oct 2006, pp. 298310.22 H. Orup, Simplifying quotient determination in highradix modularmultiplication, in Proceedings of the 12th Symposium on ComputerArithmetic, Jul 1995, pp. 193199.23 M. Joye and S.M. Yen, The montgomery powering ladder, in Cryptographic Hardware and Embedded Systems CHES 2002,, ser. LectureNotes in Computer Science, B. Kaliski, Cetin K.. Koc, and C. Paar,Eds., vol. 2523. SpringerVerlag, 2002, pp. 291302.24 D. Suzuki, How to maximize the potential of fpga resources formodular exponentiation, in Workshop on Cryptographic Hardware andEmbedded SystemsCHES 2007. Berlin SpringerVerlag, 2007.25 E. Oksuzoglu and E. Savas, Parametric, secure and compact implementation of RSA on FPGA, in Reconfigurable Computing and FPGAs,2008. ReConFig 08. International Conference on, Dec. 2008, pp. 391396.26 Hardware Interface of a Secure Hash Algorithm SHA, v. 1.4 ed.,Cryptographic Engineering Research Group, George Mason University,Jan 2010.27 Secure Hash Standard SHS, National Institute of Standards andTechnology NIST, Oct. 2008, httpcsrc.nist.govpublicationsfipsfips1803fips1803 final.pdf.28 Advanced Encryption Standard AES, National Institute of Standardsand Technology NIST, FIPS Publication 197, Nov 2001, httpcsrc.nist.govpublicationsfipsfips197fips197.pdf.29 Openssl, httpwww.openssl.orgdocsappsopenssl.html, 2009.
