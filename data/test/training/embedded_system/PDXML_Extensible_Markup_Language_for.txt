PDXML Extensible Markup Language forProcessor DescriptionS. P. Seng1, K. V. Palem2, R. M. Rabbah2, W.F. Wong3, W. Luk1, P.Y.K. Cheung11 Imperial College of Science, Technology and Medicine, England, sps,wldoc.ic.ac.uk,p.cheungic.ac.uk2 School of Electrical and Computer Engineering, Georgia Institute of Technology, USA, palem, rabbahece.gatech.edu3 Department of Computer Science, National University Singapore, Singapore, wongwfcomp.nus.edu.sgABSTRACTThis paper introduces PDXML, a metalanguage for describing instruction processors in general and with an emphasis on embedded processors, with the specific aim ofenabling their rapid prototyping, evaluation and eventualdesign and implementation. The proposed methodology isbased on the extensible markup language XML widely usedstructured information exchange and collaboration. PDXML allows for both highlevel and lowlevel architecturalspecifications required to support a toolchain for design spaceexploration. PDXML consists of three intuitive entities,describing a the storage components available in a design, b the instructions supported by an architecture, andc the resources afforded by the microarchitecture implementation. PDXML is not specific to any one architecture, compiler or simulation environment and hence providesgreater flexibility than related machine description methodologies. We demonstrate how PDXML can be interfaced toto existing description methodologies and toolflows. In particular, we show how PDXML specifications can be translated into appropriate machine descriptions for the parametric HPLPD VLIW processor and for the flexible instructionprocessor approach.1. INTRODUCTIONDuring the past three decades, the microprocessor has proliferated many aspects of daily life with a scope and depththat was hard to imagine during its early development. Formicroprocessors, the periodic doubling in the number oftransistors that can be fabricated on a chip often meanta hundred percent increase in performance every year anda half, at no additional cost 1. The advance in silicon design and fabrication technology is leading to an evolutiontowards custom computing solutions recent years have witnessed the emergence of a plethora of customized processorsthat are embedded within products such as media players,digital cameras, network routers, and settop boxes. It isbelieved 1 that the trends of customization will continueto evolve in the lower market tiers and gradually over a period of years, the trend will creep upward into higher tiersof the market, including personal computers.Today, several commercially available strategies afford competing degrees of customization and scalability, ranging fromvariations of traditional embedded processors such as theARM and MIPS, to wholly configurable processors such asthe Tensilica Xtensa architecture and ARC Cores. Numerous other companies such as Philips, StarCore, ST Microelectronics and Texas Instruments have announced embedded VLIW cores for high performance embedded computing.Common to each of these commercial solutions is the needto overcome high nonrecurring engineering costs NREwhich are key hurdles in designing custom solutions in theshort timetomarket characteristic of the industry. To thisend, an embedded system is often assembled using a specialized core to carry out number crunching functions requiredby a given application, and leverages the latest technologydevelopments available in commercialofftheshelf COTSembedded processors for less computationally demandingtasks 1, 15. All the while, the design process is subjectto various stringent constraints of size, power consumption,timing and performance. Hence, an intensive design spaceexploration is conducted to find a desirable solution for aspecified set of constraints. The exploration or design process typically proceeds by first discovering a new candidatearchitecture and measuring its costs. Next, a toolchain consisting of a compiler and simulator for the candidate architecture is generated and used to assess the relative merits ofthe target hardware for a given application. The process isrepeated until a satisfactory solution is discovered.In this paper, we propose a processor description extensible markup language PDXML as a means of describing instruction processors in general, with the specific aimof enabling their rapid prototyping, evaluation and eventual design and implementation. It can be used to supportmethods and tools for developing and optimizing instruction set architectures and their implementations, such asTrimaran 21, FIP 17 and architecture assembly 10. Inparticular, PDXML allows for extensible descriptions forboth instruction set architectures and their microarchitecture implementations. The framework follows a specificationformat which may be easily simulated or even synthesized.This will permit the rapid exploration of the architecturalspace and will complement several wellfounded methodologies that have emerged to ameliorate the engineering costsassociated with exploring the design space of custom computing components 11, 16, 17. The contributions of ourwork are as follows1. We propose PDXML, a generic and extensible methodology for describing, simulating and implementinginstruction set architectures. Information is organizedinto two entities one about storage, and the otherabout the instruction set.2. We extend PDXML to cover descriptions of microar1chitectures, by including information about the resources associated with a given microarchitecture.3. We demonstrate how PDXML can be used to supportexisting description methodologies and toolflows. Inparticular, we show how a specification realized in PDXML may be translated into a machine description forthe parametric HPLPD VLIW processor 7 and forthe FIP approach 17.The rest of the paper is organised as follows. Section 2provides an overview of our approach. Section 3 discussesrelated work. Section 4 and 5 respectively cover ISA and microarchitecture descriptions in PDXML. Section 6 describesTrimaran and FIP interfaces for PDXML, and Section 7presents a summary and future work. Appendix A contains an example of ISA and microarchitecture descriptionsin PDXML.2. OVERVIEW OF APPROACHOur description framework is based on an extensible markuplanguage known as XML 2. XML provides a set of guidelines and conventions for structuring and representing data in our case instruction processor description. It is genericand easily extensible, and its merits as an architecture description language have been discussed in the past 13. Inaddition, XML is widely popular with the World Wide WebCommunity as a means for structured information exchangeand collaboration. Furthermore, by virtue of using XML asa building block for the proposed framework, it is possibleto leverage various publicly available opensource tools designed to work with XML. Thus, PDXML subsumes manyof the existing processor description languages, and overcomes many of their disadvantages and drawbacks. In particular, i PDXML is not tied to any one architecture,compiler or simulation environment, ii it is capable of representing both highlevel as well as lowlevel specificationsrequired to support a design space exploration toolchain,and iii it does not require expertlevel knowhow to read,understand and extend.PDXML consists of a collection of four main entities. Thefirst captures information about components that store information, such as registers, register files, stacks, externalmemory, or block RAMs on FPGAs hence it shall be calledthe store entity. The second entity describes the instruction set and shall be called the inst entity it may includepseudo instructions which are decomposed by a compilerinto several operations that are executed by the processor.The third is the resource entity and it contains information about physical resources available in a microarchitecture such as ALUs, cache control units as well as fetch anddecode units. The fourth, instance declares an instance ofa resource. An instruction set architecture description ofa processor mainly involves the store and inst entities tobe described in Section 4 the microarchitecture descriptionrequires all four entities, to be explained in Section 5.A microarchitecture description comes in two flavours highlevel and low level. A highlevel microarchitecture description makes explicit the resources associated with each instruction, enabling simulation to take place. A lowlevelmicroarchitecture description contains detailed informationISAHuALuA LuA...Highlevel compilationand simulationLowlevel compilation,simulation and hardwaregenerationApplicationsoftwareFigure 1 An ISA, HuA pair, where ISA denotesan instruction set architecture description and HuAdenotes a highlevel microarchitecture description,can be used for highlevel design exploration involving application software. For detailed design development and implementation, an LuA lowlevel microarchitecture description is also required. Thebox labeled highlevel compilation and simulationwill be elaborated in Figure 2.the datapath and control, allowing design optimisation, evaluation and implementation. Note that an ISA can be implemented by multiple highlevel microarchitectures, and ahighlevel microarchitecture can be implemented by multiple lowlevel microarchitectures Figure 1.While PDXML affords several advantages compared to previously published related work outlined in the following section, it is necessary to demonstrate its utility and flexibility to interface with other machine description methodologies. PDXML is designed to provide a vehicle for the easyand rapid extension of existing frameworks where potentially substantial resources, and investments have alreadybeen committed. To this end, in Section 6 we shall demonstrate how PDXML can be used to support two development approaches first, an existing machine description language used in Trimaran 21, an infrastructure for researchon explicitly parallel instruction computers EPIC second,design libraries for flexible instruction processors 17.3. RELATED WORKVarious hardware description languages have been proposedin the past. Languages such as VHDL 19 and Verilog 12allow engineers to describe their designs in a highlevel language for which a compiler can synthesize the circuitry. Unfortunately, such languages tend to revolve around lowleveldetails and it is generally wellknown that even slight designvariations require welltrained experts who are familiar withthe architecture as well as the description language. To helpalleviate the problems commonly associated with lowleveldescription languages, a new generation of hardware description languages such as SystemC 20 and HandelC 6 haveemerged. However, these are intended as generalpurposehardware description languages and do not provide the necessary specifics to facilitate the easy and direct descriptionof instruction set architectures or microarchitectures.Many architecture description languages ADLs have beenproposed to describe both hardware and software architectures. Examples of hardware architecture description languages include HMDES 4 and Pebble 8. Such languages2are specific to a particular architecture domain or a compilationsimulation infrastructure. In contrast, PDXML is ageneric metalanguage that is extensible and may be used todescribe widelyvarying architectures such as superscalar orVLIW processors, including their multiclustered variants.The need for a metadescription of software architectures the very same role that PDXML is intended to play  hasbeen a wellstudied subject in software engineering 13.Other related work involving instruction processor descriptions include ISDL 5, an instruction set description language, and MAML 3 and MESCAL 14, architecture description languages. ISDL supports the description of theISA and microarchitecture of a processor, while MAML andMESCAL can be used for pipelined processor designs. PDXML includes the capabilities available in these languages.In addition PDXML captures the ISA and microarchitectures at multiple levels of abstraction, enabling an ISA tobe mapped onto various microarchitectures.4. DESCRIBING ISAAn ISA description contains information about the memoryor storage capabilities and the related instructions. As suchan ISA description is made up of store and inst entities. Thisallows an ISA designer to concentrate on the functionalityof the processor. The bitwidth of registers and instructionformats are included at this stage to allow for the generationof binary code.To summarize, the ISA description should1. expose the capabilities of an instruction set to the programmer and compiler writer,2. provide functional specification of the instruction setfor implementation by microarchitectures.In PDXML, the instruction repertoire of an ISA can be obtained by inspecting the list of inst entities. The list of storeentities provide information on the storage resources available to the ISA. Criterion 1 and 2 can be satisfied bythe information contained in the two lists. For example, theopcode attribute and the inst format tag provide information on how to translate assembly code into machine code.The behav tag specifies the functional capability of the instruction, and can be used to directly map onto a high levelmicroarchitecture description.Multiple issue architectures can be simulated at the ISAlevel by composing instructions in parallel and issuing themas a single sequential instruction. Technicalities such asMultiOpP and MultiOpS or EQ and LEQ machines canbe dealt with in the behav section. The following is an example of a store entitystore typeRegFile namerdocregisters used for general computationdocbitsize32bitsizedepth5depthindex0..31indexstoreThe store entity has two fields, type and name. Here, wedeclare a register file called r. The doc field provides documentation for the entity. The bitsize field provides information on the number of bits size of the number that canbe represented by a single register. The depth field providesinformation on the depth of the register file here it says thatthe register file can be accessed by a pointer that is 5 bitswide, so there are 25 registers in this register file, r0..r31.The index field shows the indexing count for this registerfile. In other words the depth value tells the compiler thenumber of bits required to index into this register file, andthe index value tells the compiler the actual index positionsinto the register file. This allows for a single physical register file to be logically split up into separate smaller registerfiles.At this level of abstraction no decisions are made as to thephysical implementation of components. However, it is oftenconvenient to segregate the use of registers within a register file. For example, there are 32 general purpose registersin the MIPS ISA description, which are split up into different categories of usage temporary store, argument store,reserved for stack, frame pointer etc. This can be defined bycreating a store entity with a type that refers to a previouslydefined entity.store typeRegFile.r nametdoctemporary registers, not preservedacross calls. t0t10docindex8..15,23..25indexstoreHere we define an alias to the register file r the t registersare referred to like a register file, but indices for t registersare translated into indices for r registers, using the convention outlined in the index section. Here t0 is an alias ofr8. An example of an inst entityinst opcodeADDdocDefinition for the add instructionadd rd,rs,rtrd  rs  rtwhere rd,rs,rt are from the r register filedocin typeRegFile.rin1,in2inout typeRegFile.rout1outinstformat000000in1in2out1xxxxx100000instformatbehavrout1  rin1  rin2behavinstHere we define an instruction called ADD. It takes threeoperands that contain indices for the RegFile.r register file.3CompilerSimulatorISAHuAApplicationsoftwareFigure 2 The ISA and HuA highlevel microarchitecture descriptions can be used to produce highlevel compilation and simulation tools. The dottedline indicates that the simulation result can be usedto refine the ISA and HuA descriptions.The names in1, in2 and out1 are labels that refer to indicesinto the store entity RegFile.r. The inst format tag givesthe binary instruction format for the ADD instruction. Thefirst six bits correspond to the opcode while the last six bitscorresponds to the function code, as defined by the MIPSinstruction set. The  operator denotes concatenation. xdenotes bits whose value we dont care about.For convenience, the labels in1, in2, and out1 above refer to5bit numbers derived from the depth value of the RegFile.robject and acceptable values for this 5bit number are numbers between 0 and 31 derived from the index tag of theRegFile.r object. The behav field contains the behaviouralinformation that outlines the operation of this instructionin a highlevel manner.Figure 2 shows that the ISA description can be used to produce compilation and simulation tools to facilitate highleveldesign exploration. Note that multiple highlevel microarchitectures can be used to implement each ISA details of ahighlevel microarchitecture description will be explained inthe next section.5. DESCRIBING MICROARCHITECTUREThe microarchitecture section captures resource dependencein the processor, so that a cycle accurate description can bedeveloped. This level contains descriptions of resources thatare not directly accessible by a programmer, such as thefetch module or the program counter. The following describes the requirements of microarchitecture descriptions,followed by an explanation of highlevel and lowlevel microarchitecture descriptions in PDXML.5.1 RequirementsThe purpose of a microarchitecture description is to includeimplementation constraints to enable effective implementation and evaluation. From experience it should1. expose the hardware capabilities of an instruction processor,2. expose the resource dependencies,3. allow the compiler to be further optimized,pcInstmemRegFileLOADSTOREADDSUBXORBEQDatamemJMPFigure 3 A graph representation of a high levelmicroarchitecture description.4. provide enough information for cycleaccurate simulation of the microarchitecture.In PDXML, the uA field can be written in two levels ofabstraction highlevel microarchitecture and lowlevel microarchitecture. From the uA definition, we can deducedependence information, which can be drawn as a DOTgraph 9. Each node in the graph maps to a physical implementation block. This exposes the hardware capabilitiesof the processor. The in and out tags capture dependenceinformation. This is reflected in the edges of the graphs.Section 5.4 and 5.5 show how information for further optimizing a compiler can be captured. Simulation of a microarchitecture can be done in two levels. The high level microarchitecture can be simulated using information captured inthe behav tags in the ISA and low level microarchitecturecan be simulated with information from the struct tags.5.2 Highlevel microarchitectureThe high level microarchitecture description closely resembles the ISA specification, where instructions are segregated.The uA description at this level is organized around the instructions in the processor and only data flow between thestore and inst entities are shown. Figure 3 shows a graphrepresentation of part of a MIPS processor. The uA fieldcontains information about the modules and provides information such as data dependence, allowing pipelining andscheduling to take place. An example of the uA definitionfollowsstore typeRegFile nameruAinInstmeminoutADDXORSUBLOADSTOREBEQoutuAstoreThis shows that RegFile takes information from Inst memand provides information for LOAD, ADD etc. As anotherexample, consider the ADD module4pcFetchincInstmemRegFile MulALUBranchUnitDatamemDecodeLoadStoreFigure 4 A graph representation of a processor withshared functional units.inst opcodeADDuAinRegFile.rinoutRegFile.routuAinstBehavioural information can be incorporated in the sameway as in the lowlevel microarchitecture definition shown inthe next section. Latency information can be incorporatedmanually or can be determined by simulation.5.3 Lowlevel microarchitectureWhile the highlevel microarchitecture describes the resourcedependences of the ISA, the lowlevel microarchitecture alsoknown as the implementation captures how the ISA may berealized. This is divided into two parts1. LL1 The first part describes the types of resourcesfound in the datapath and the instances of these resources. Instances may also contain additional implementation dependent information. For example, in thecase of a cache, different cache parameters and policiescan be described.2. LL2 The second part describes resources that control the flow of instructions. Information regardingimplementation details such as whether the processor is EPIC or superscalar, UAL, NUAL, MultiOpP,MultiOpS, EQ or LEQ are also encapsulated in thispart of the machine description.5.4 LL1  data pathThe uA field can also be written to conform to more conventional processor architectures, with shared computationunits, such as the ALU and branch units. At this levelof description, the microarchitecture description is resourceoriented and contains control information. The inst tag is nolonger used and the resource and store tags are used as typedefinitions. The instance tag is used to declare an instanceof a resource or store entity. The following description ofthe microarchitecture can be seen as a refinement of thefirst example.resource typearith nameALUpcFetchincInstmemRegFileLoadStoreMul1Mul2ALU1ALU2ALU3ALU4DatamemDecodeBranchUnitPrefetchFigure 5 A graph representation of the MIPS ISAwith multiissue microarchitecture.docThe ALU unit for adds, sub, xor ... docuAin typeRegFile.rin1,in2inin typeDecodealuopinout typeRegFile.rout1outout typeBranchUnitbranchoutimplementsADD,XOR ...implementsstruct...structuAresourceThe resource entity at this level contains fields that relatesthe information in the inst field to this resource. The in andout fields provide connection information. The implementsfield denotes what instructions are supported. The structfield provides information on how to build each of the modules. This can be captured in Pebble 8, VHDL or othersimilar hardware description languages.Figure 4 shows a single issue implementation of the MIPSISA, while Figure 5 shows a multiissue implementation.The high level microarchitecture description provides an easybut inefficient way to implement the ISA. The ISA can thenbe mapped into different low level microarchitecture implementations depicted in Figure 4 and 5.This format allows microarchitectures of different levels ofabstraction and functionality to be coupled with an ISA description. Conversely several ISA definitions can be mappedonto a microarchitecture description.instance typearith.ALU nameALU0doc...docinstanceinstance typearith.ALU nameALU15doc...docinstanceinstance typestore.cache nameICACHEdoc...docsize8Kbytesizelinesize...linesizeassociativity...associativityreplacementpolicy...replacementpolicyinstanceInstances contain information about a particular instance ofa resource. The example above shows the instantiation oftwo ALU units and a cache.5.5 LL2  control pathThe control path of a microarchitecture can be described ina similar manner to the data path. The distinction is arbitrary and both control and data paths can be described bythe same tags. The example below shows the declarationof two control resources an instruction issue resource anda reservation station resource. Information required by thecompiler is provided within the uA tags, such as the discipline and instruction window size. Control resources areinstanced using the instance tag.resource typecontrol nameinstissuedoc Instruction issue controller docuAdisciplineInorderdisciplineinstructionwindow10instructionwindowstruct...structuAresourceresource typecontrol nameresstatdoc Reservation stations docuAdepth5depthdisciplineInorderdisciplinestruct...structuAresourceinstance typecontrol.resstat nameALU0statdoc The instance of the reservation stationresource for ALU0docuAin typecontrol.instissueinout typearith.ALU0outuA...instance6. INTERFACING PDXMLThis section covers two design and implementation flows towhich PDXML can be interfaced.6.1 HMDES interfaceIn this section, we demonstrate how PDXML may interface with and enhance HMDES 4, a powerful and complex machine description language used in the Trimaranresearch compiler and simulation environment. The architecture specifications in HMDES consist of six entities1. format, specifying the operands allowed by each typeof operation,2. resource usage, specifying how operations use the processors resources when they execute,3. latency, specifying how to calculate dataflow dependences between operations,4. operation, describing the operations supported by thearchitecture and specifying their format with respectto operands, resources usage, and latency,5. register, providing information necessary for registerallocation performed by Trimaran,6. compiler, a generic entity intended to communicateother information required by the compiler.While HMDES provides a facility to model various specifications, it does often prove difficult to use. For example, toaugment the ISA of a HMDESmodeled processor requiresmodifications at several different levels  namely, the format, the resource usage, the latency and the operation levels and additional compiler flags may be necessary as well.Similarly, altering the microarchitecture often requires modifications to various entities. In contrast, PDXML consistsof only three components, each a selfcontained and easilymodified entity. Furthermore, most of the specifications anddefinitions required by the HMDES infrastructure can be directly inferred from the XML descriptions. In what follows,we highlight a few such examples.Consider the declaration of register file r shown earlier inSection 4 and the equivalent HMDES code below. TheRegister section creates a total of 32 registers  r0 throughr31  which are subsequently assigned to the register filer in section Register File. Specified in the former is thewidth of each register. Information as to whether a register is preserved across function calls can be described usingsimilar annotations. Earlier we have shown how PDXMLsupports the segregation of registers for instance registerfile t in Section 4. This can be trivially translated to theequivalent HMDES specification illustrated below.SECTION Registerfor N in 0..31 rNwidth 32SECTION RegisterFiler registersfor N in 0..31 rNt registersfor N in 8..15 ...6While the HMDES specification of register files is somewhatstraightforward, the definitions of the ISA and the resourceusage patterns i.e. microarchitecturelevel descriptions areslightly more complex and are illustrated below.SECTION OperandTypeFTiregfilerFTlregfileLFTilcompatiblewithFTi FTlSECTION OperationFormatOFADDsrcFTil FTil destFTiSECTION ResourceRALU0SECTION OperationADDformatOFADD usesRALU0 ...As shown above, in order to define an ADD operation, itis necessary to first define its format OF ADD. In this case,it requires two source operands, where each may be a register r or a literal L, modeled as a pseudoregister file.In HMDES, it is often not possible to avoid some microarchitectural specifications when defining an operation. Tothis end, a R ALU0 resource is instantiated and declared tobe capable of carrying out the operation of interest. Subsequently the actual operation is defined1. Referring backto the PDXML specification for the ADD operation it isreadily apparent how the operation format may be inferredfor the HMDES specification. However, whereas PDXMLaffords an ISAonly specification  hence is not tied to aparticular architecture implementation  it is now necessaryto include some lowlevel details required to complete theHMDES specification. To this end, we extend the PDXMLdescription to include a pseudoresource field which may besubsequently realized at the microarchitecture level.The examples above are intended to highlight how PDXMLmay easily and readily adapt to an existing machine description facility such as HMDES. Thus, we believe that it canbe used to augment the Trimaran infrastructure which wasconceived to explore the evolution of VLIW architectures.In particular, the machinedriven optimizing compiler andperformance monitoring tools available in Trimaran maybe easily retargeted to investigate the merits of architecturalinnovations via rapid prototyping using PDXML. This is ofincreasing significance as VLIW architectures continue toproliferate at various tiers of the processor industry.1Several details are omitted for clarity. We refer the interested reader to the HMDES technical report 4.Customisation specificationeg. application source code and dataFIP ProfilerInstructioninformationProcessorarchitectureinformationFIP libraryFIP analysis and instantiationAnnotatedsource codeFIP compilerExecutableFIP codeDecisionconditioninformationFIPconfigurationinformationFIPmanagementsystemFIP templategeneratorFigure 6 The design flow for the Flexible Instruction Processor FIP approach.6.2 FIP InterfaceThe Flexible Instruction Processor FIP approach providesa mechanism for the systematic customization of instruction processors, targeting mainly reconfigurable devices 17.This approach helps designers to tune hardware implementations to the characteristics of a system both at design timeand at run time 18. PDXML provides a concise way toexpress both the ISA and the microarchitecture informationrequired by the FIP approach.Figure 6 shows a simplified FIP design flow. The FIP profiler takes in a custom specification, usually in C or in Java,as well as ISA information in PDXML format from theFIP library. The ISA description is customized to the application source code provided in the custom specification.This information is then passed to the FIP template generator which creates a highlevel microarchitecture in PDXMLthat corresponds to the ISA description.Next, the FIP template is put through an analysis phasewhere operations are optimized and custom instructions areintroduced if appropriate 18. After instancing, a FIP configuration is produced to program a reconfigurable device.A PDXML description of the lowlevel microarchitecture isalso passed to the FIP compiler, so that executable code canbe produced for the FIP implementation.7. SUMMARYThis paper introduces PDXML, a metalanguage for describing processors in general with an emphasis on embedded processors. PDXML enables rapid highlevel as wellas lowlevel architectural specifications required to supporta toolchain for design space exploration. The proposed ap7proach should become increasingly important in the contextof generalpurpose systems design, and especially in embedded systems where the needs for applicationspecific architectures are increasing prevalent, and timetomarket is aprimary concern. In addition, we have demonstrated howPDXML can interface to and extend the flexibility of existing machine description methodologies such as HMDESused to model the parametric HPLPD processor centralto the Trimaran infrastructure. Current and future workincludes the completion of the retargeting of our tools tosupport PDXML, and the extension of PDXML to support adaptive implementations that can be reconfigured atrun time 18.ACKNOWLEDGEMENTSThe authors acknowledge Mongkol Ekpanyapong, Georgia Institute of Technology, Anjani Kumar Tripathi, Banares Hindu University, and David Thomas, Imperial College, for their contributions to this paper. This work is supported in part by DARPAcontract F306020020564, ASTAR Project No. 0121060046,UK EPSRC projects GRN 66599 and GRR 55931, CeloxicaLimited, Hewlett Packard Laboratories, and Yamacraw.REFERENCES1 M. Bass and C. Christensen. The future of the microprocessor business. IEEE Spectrum, Apr. 2002.2 R. Cover. The XML cover pages. xml.coverpages.org.3 D. Fisher et al. Design space characterisation for architecturecompiler coexploration. In Proc. CASES, ACM, 2001.4 J. Gyllenhaal, W. Hwu, and B. R. Rau. HMDES version 2.0specification. Technical Report IMPACT963, University ofIllinois, Urbana, 1996.5 G. Hadjiyiannis, S. Hanono, and S. Devadas. Isdl An instruction set description language for retargetability. In Proc.34th Design Automation Conference, 1997.6 The HandelC programming language. www.embeddedsolutions.ltd.ukproductsdesign suite.7 V. Kathail, M. Schlansker, and B. R. Rau. HPLPD architecture specification Version 1.1. Technical Report HPL9380R.1, Hewlett Packard Laboratories, Feb. 2000.8 W. Luk and S. McKeever. Pebble a language forparametrised and reconfigurable hardware design. In Proc.FPL, LNCS 1482, Springer, 1998.9 Open source graph drawing software.www.research.att.comswtoolsgraphviz.10 K. Palem. Cbased architecture assembly supports customdesign. In EE Times, Feb. 2002.11 K. Palem. Rapid design of custom embedded systems viaarchitecture assembly. Technical report, Proceler Inc., Feb.2002.12 S. Palnitkar. Verilog HDL. Prentice Hall, 1996.13 S. Pruitt, D. Stuart, W. Sull, , and T. Cook. The merit ofXML as an architecture description language metalanguage.xml.coverpages.orgADLmeritofxml.html.14 W. Qin. Mescal architecture description.httpwww.ee.princeton.eduMESCALarde.html.15 B. R. Rau and M. Schlansker. Embedded computer architecture and automation. IEEE Computer, Apr. 2001.16 R. Schreiber, S. Aditya, S. Mahlke, V. Kathail, B. R. Rau,D. Cronquist, and M. Sivaraman. PICONPA Highlevelsynthesis of nonprogrammable hardware accelerators. Journal of VLSI Signal Processing, 2001.17 S. Seng, W. Luk, and P. Cheung. Flexible Instruction Processors. In Proc. CASES, ACM, 2000.18 S. Seng, W. Luk, and P. Cheung. Runtime Adaptive FlexibleInstruction Processors. In Proc. FPL, LNCS 2438, Springer,2002.19 S. Sjoholm and L. Lindh. VHDL for Designers. PrenticeHall, 1997.20 The open SystemC initiative. www.systemc.org.21 Trimaran An infrastructure for research in instruction levelparallelism. www.trimaran.org.APPENDIX AAn example of a PDXML ISA and microarchitecture description. The implementation tag relates an ISA with amicroarchitecture. Comments are enclosed by doc tags.PDXMLimplementation ISAMIPSuAsingleissuesuperscalarinstructionsetarchitecture nameMIPSstore type Register namepcISAbitsize32bitsizeISAstore... other store declarationsinst opcodeBEQdocDefinition for branch if equalbeq rs,rt,offsetdocISAin typeRegFile.rin1,in2inin typeInstmem bitsize16offsetinout typeRegister.pcpcoutinstformat000100in1in2offsetinstformatbehavrin1rin2pcoffsetpcbehavISAinst... other inst declarationsinstructionsetarchitecturemicroarchitecturenamesingleissuesuperscalarstore type Register namepcdoc Declaration of the PC register docuAstructunsigned 32 pcstructuAstore... other store declarationsresource typebranch nameBranchUnitdoc Declaration of a branch unit docuAinin1,in2in8outout1outimplementsBEQ,BNE...implementsstruct ... structuAresource... other resource declarationsinstance typebranch.BranchUnit nameBR1doc Instancing of a branch unit docuAin typeRegFile.rin1,in2inin typeInstmem bitsize16offsetinout typeRegister.pcpcoutuAinstance... other instancesmicroarchitecturePDXML9
