When and How to Develop DomainSpecificLanguagesMarjan Mernik1, Jan Heering2, Anthony M. Sloane31 University of Maribor, Slovenia, marjan.mernikunimb.si2 CWI Amsterdam, The Netherlands, Jan.Heeringcwi.nl3 Macquarie University, Australia, asloanecomp.mq.edu.auAbstractDomainspecific languages DSLs are languages tailored to a specificapplication domain. They offer substantial gains in expressiveness andease of use compared with general purpose programming languages intheir domain of application. DSL development is hard, requiring bothdomain knowledge and language development expertise. Few people haveboth. Not surprisingly, the decision to develop a DSL is often postponedindefinitely, if considered at all, and most DSLs never get beyond theapplication library stage.While many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to developa DSL. To aid the DSL developer, we identify patterns in the decision,analysis, design, and implementation phases of DSL development. Ourpatterns try to improve on and extend earlier work on DSL design patterns, in particular by Spinellis 2001. We also discuss domain analysistools and language development systems that may help to speed up DSLdevelopment. Finally, we state a number of open problems.1 Introduction1.1 GeneralMany computer languages are domainspecific rather than general purpose.Domainspecific languages DSLs are also called applicationoriented, specialpurpose, taskspecific, problemoriented, specialized, or application languages.DSLs trade generality for expressiveness in a limited domain. By providingnotations and constructs tailored toward a particular application domain, theyoffer substantial gains in expressiveness and ease of use compared with generalpurpose programming languages GPLs for the domain in question. These inturn lead to gains in productivity and reduced maintenance costs. While GPLsyield an order of magnitude productivity improvement over assembly languages,1DSL Application domainBNF Syntax specificationExcel macro language SpreadsheetsHTML Hypertext web pagesLATEX TypesettingMake Software buildingSQL Database queriesVHDL Hardware designTable 1 Some widely used domainspecific languages.DSLs give another order of magnitude improvement over GPLs in their domainof application.The use of DSLs is by no means new. APT, a DSL for programming numerically controlled machine tools, was developed in 19571958 76. BNF, thewellknown syntax specification formalism, dates back to 1959 4. Socalledfourthgeneration languages 4GLs are usually DSLs for database applications.Little languages are small DSLs that do not include many features found inGPLs 10, p. 715. Some widely used DSLs with their application domains arelisted in Table 1. Many others will be mentioned in later sections. Visual DSLs,such as UML, are important, but are beyond the scope of this article.We will not try to give a definition of what constitutes an application domainand what does not. Some people consider Cobol to be a DSL for businessapplications, while others would argue this is pushing the notion of applicationdomain too far. Leaving matters of definition aside, it is natural to think ofDSLs in terms of a gradual scale with very specialized DSLs such as HTML onthe left and GPLs such as C on the right. On this scale, Cobol would besomewhere between BNF and C, but much closer to the latter. Similarly, itis hard to tell if command languages like the Unix shell or scripting languageslike Tcl are DSLs. Clearly, domainspecificity is a matter of degree.In combination with an application library, any GPL can act as a DSL, sowhy were DSLs developed in the first place Simply because they can offerdomainspecificity in better ways Appropriate or established domainspecific notations are usually beyondthe limited userdefinable operator notation offered by GPLs. A DSLoffers appropriate domainspecific notations from the start. Their importance should not be underestimated as they are directly related to theproductivity improvement associated with the use of DSLs. Appropriate domainspecific constructs and abstractions cannot always bemapped in a straightforward way on functions or objects that can be putin a library. This means a GPL in combination with an application librarycan only express these constructs indirectly or in a cumbersome, repetitious way. Again, a DSL would incorporate domainspecific constructs2from the start. Unlike GPLs, DSLs need not be executable. There is some confusion onthis in the DSL literature. For instance, the importance of nonexecutableDSLs is emphasized in 96, while DSLs are required to be executable in28. We discuss DSL executablility in Section 1.2.Despite their shortcomings, application libraries are formidable competitors toDSLs. It is probably fair to say that most DSLs never get beyond the applicationlibrary stage. These are sometimes called domainspecific embedded languagesDSELs. Even with improved DSL development tools, application librarieswill remain the most costeffective solution in many cases, the more so since theadvent of component frameworks has further complicated the relative merits ofDSLs and application libraries.Consider Microsoft Excel, for instance. Its macro language is a DSL forspreadsheet applications which adds programmability to Excels fundamentalinteractive mode. Using COM, Excels implementation has been restructuredinto an application library or toolbox of COM components. This has opened itup to general purpose programming languages such as C, Java and Basic,which can access it through its COM interfaces. This is called automation 17.Unlike the Excel macro language, which by its very nature is limited to Excelfunctionality, general purpose programming languages are not. They can beused to write applications transcending Excels boundaries by using componentsfrom other automated programs and COM libraries in addition to componentsfrom Excel itself.1.2 Executability of DSLsDSLs are executable in various ways and to various degrees, even to the pointof being nonexecutable. Accordingly, DSL programs are often more properlycalled specifications, definitions, or descriptions. We identify some points on theDSL executability scale DSL with welldefined execution semantics Excel macro language, HTML. Input language of an application generator 19, 83. These languages arealso executable, but they usually have a more declarative character and aless welldefined execution semantics as far as the details of the generatedapplications are concerned. The application generator is a compiler forthe DSL in question. DSL not primarily meant to be executable, but nevertheless useful forapplication generation. The syntax specification formalism BNF is anexample of a DSL with a purely declarative character that can also act asinput language for a parser generator. DSL not meant to be executable 96. Just like their executable relatives,such nonexecutable DSLs may benefit from various kinds of tool sup3port such as specialized editors, prettyprinters, consistency checkers, andvisualizers.1.3 DSLs as enablers of reuseThe importance of DSLs can also be appreciated from the wider perspective ofthe construction of large software systems. In this context the primary contribution of DSLs is to enable reuse of software artifacts 11. Among the types ofartifact that can be reused via DSLs are syntax, source code, software designs,and domain abstractions.In his definitive survey of reuse 59, Krueger categorises reuse approachesalong the following dimensions abstracting, selecting, specializing, and integrating. In particular, he identifies application generators as an important reusecategory. As already noted, application generators often use DSLs as their inputlanguage, thereby enabling the reuse of domain semantics. Krueger identifiesdefinition of domain coverage and concepts as a difficult challenge for implementors of application generators. We identify patterns for domain analysis inthis paper.DSLs also play a role in other reuse categories identified by Krueger. Forexample, software architectures are commonly reused when DSLs are employedbecause the application generator or compiler follows a standard design whenproducing code from a DSL input. DSLs implemented as application librariesclearly enable reuse of source code and DSLs can play a role in the formalspecification of software schemas.Reuse of syntax may take the form of reuse of parts of an actual grammaralready available in an existing GPL or DSL processor or reuse of a notationalready in use by domain experts, but perhaps not yet available in a computerlanguage.1.4 Scope of this articleThere are no easy answers to the when and how question in the title of thisarticle. The abovementioned benefits of DSLs do not come for free DSL development is hard, requiring both domain and language development expertise. Few people have both. DSL development techniques are more varied than those for GPLs, requiring careful consideration of the factors involved. Depending on the size of the user community, development of training material, language support, standardization, and maintenance may becomeserious and timeconsuming issues.These are not the only factors complicating the decision to develop a new DSL.Initially, it is often far from evident that a DSL might be useful or that developing a new one might be worthwhile. This may become clear only after a4sizeable investment in domainspecific software development using a GPL hasbeen made. The concepts underlying a suitable DSL may emerge only after alot of GPL programming has been done. In such cases, DSL development maybe a key step in software reengineering or software evolution 9.To aid the DSL developer, we provide a systematic survey of the manyfactors involved by identifying patterns in the decision, analysis, design, andimplementation phase of DSL development Section 2. The DSL developmentprocess can be facilitated by using domain analysis tools and language development systems. These are surveyed in Section 3. Our patterns try to improve onand extend earlier work on DSL design patterns, in particular by Spinellis 85.This is discussed in Section 2.6. Other related work is discussed at appropriatepoints throughout rather than in a separate section. Finally, conclusions andopen problems are given in Section 4. As mentioned before, visual DSLs arebeyond the scope of this article.1.5 LiteratureUntil recently, DSLs received relatively little attention in the computer scienceresearch community and there are few books on the subject. 62 is an exhaustiveaccount of the state of 4GLs at the time it was written, 12 is a twovolumecollection of articles on software reuse including DSL development and programgeneration, 70 focuses on the role of DSLs in enduser programming, 77 isa collection of articles on little languages not all of them DSLs, 6 treatsscripting languages again, not all of them DSLs, 24 discusses domain analysis,program generators, and generative programming techniques, and 20 discussesdomain analysis and the use of XML, DOM, XSLT, and related languages andtools to generate programs.Proceedings of recent workshops and conferences partly or exclusively devoted to DSLs are 53, 74, 29, 46, 47, 48. Several journals have publishedspecial issues on DSLs 98, 64, 65. There are many workshops and conferences at least partly devoted to DSLs for a particular domain, for example,description of features of telecommunications and other software systems 36.The annotated DSL bibliography 28 78 items has limited overlap with thereferences in this article because of our emphasis on general DSL developmentissues. Finally, articles on DSL patterns and DSL development methodologiesare 21, 49, 83, 85, 96.2 DSL Patterns2.1 Pattern classificationThe following DSL development phases can be distinguished decision, analysis,5When Pattern class DescriptionHowWhen Decision pattern Common situations suitable fordesigning a new DSL or use ofan existing oneHow Analysis pattern Common approaches to domainanalysisHow Design pattern Common approaches to DSL designHow Implementation pattern Common approaches to DSL implementationTable 2 Pattern classification. design, implementation, deployment.DSL development is not a simple sequential process of positive decision followed by domain analysis, followed by DSL design, and so on. In practice, thedecision process may be influenced by preliminary analysis, analysis in turn mayhave to supply answers to unforeseen questions arising during design, and designis often influenced by implementation considerations.As shown in Table 2, we associate classes of patterns with each of the abovedevelopment phases except deployment, which is beyond the scope of this article.Patterns in different classes are independent. For a particular decision patternvirtually any analysis or design pattern can be chosen, and the same is true fordesign and implementation patterns. Patterns in the same class, on the otherhand, need not be independent, but may have some overlap.We discuss each development phase and the associated patterns in a separatesection. Inevitably, there may be some patterns we have missed.2.2 DecisionThe decision phase corresponds to the whenpart of DSL development. Deciding in favor of a new DSL is usually not easy. The investment in DSLdevelopment including deployment has to pay for itself by more economicalsoftware development andor maintenance later on. In practice, shortterm considerations and lack of expertise may easily cause indefinite postponement of thedecision.To aid in the decision process, we identify a number of decision patterns.These are common situations that potential developers find themselves in thatmight motivate the use of DSLs. Underlying these patterns are general, interrelated concerns such as6Pattern DescriptionNotation The availability of appropriate new or existingdomainspecific notations is the decisive factor. Important special cases Make existing visual notation available in textualform. There are many benefits to such a visualtotextual transformation, such as easier composition of large programs or specifications, etc. Thepreeminent example of this subpattern is probablyVHDL 2. Another one is MSF 41. Add domainspecific notation beyond the limiteduserdefinable operator notation offered by GPLs toan existing application library.Task automation Programmers often spend time on GPL programming tasks that are tedious and follow the same pattern. In such cases, the required code can be generated automatically by an application generator foran appropriate DSL e.g., SODL 67, proprietaryspecification language 32.Data structurerepresentationDatadriven code relies on initialized data structureswhose complexity may make them difficult to writeand maintain. These structures are often more easilyexpressed using a DSL e.g., Fido 58.Data structuretraversalTraversals over complicated data structures can oftenbe expressed better and more reliably in a suitableDSL e.g., TVL 41.System frontend A DSL based frontend may often be used for handling a systems configuration and adaptation e.g.,Nowra 81.Interaction Text or menu based interaction with application software often has to be supplemented with an appropriate DSL for the specification of complicated or repetitive input. For example, Excels interactive modeis supplemented with the Excel macro language tomake Excel programmable. Another example inthe context of web computing is discussed in 16.AVOT Domainspecific analysis, verification, optimization,and transformation of application programs writtenin a GPL are usually not feasible, because the sourcecode patterns involved are too complex or not welldefined. Use of an appropriate DSL makes these operations possible e.g., Promela 7.Table 3 Decision patterns.7Pattern DescriptionInformal The domain is analyzed in an informal way.Formal A domain analysis methodology is used.Extract from code Mining of domain knowledge from GPLcode.Table 4 Analyis patterns. improved software economics, enabling of enduser programming or enduser specification, enabling of domainspecific analysis, verification, optimization, andortransformation.The decision patterns we have identified are listed in Table 3. We discuss someof them in more detail. XXX2.3 AnalysisIn the analysis phase of DSL development, the problem domain is identifiedand domain knowledge is gathered. This requires input from domain expertsandor the availability of documents or code from which domain knowledgecan be obtained. Most of the time, domain analysis is done informally, butsometimes domain analysis methodologies such as DARE Domain Analysisand Reuse Environment 34, DSSA DomainSpecific Software Architectures86, FODA FeatureOriented Domain Analysis 55, or ODM OrganizationDomain Modeling 80 are used. See also 24, Part I.There is a close link with knowledge engineering, which is only beginningto be explored. Knowledge capture, knowledge representation, and ontologydevelopment 25 are potentially useful in the analysis phase. The latter istaken into account in ODE Ontologybased Domain Engineering 31.The output of formal domain analysis varies widely, but is some kind ofrepresentation of the domain knowledge obtained. It may range from a feature diagram, which is a graphical representation of assertions propositions,predicates about software systems in a particular domain, to a domain implementation consisting of a set of domainspecific reusable components, or afullfledged theory in the case of highly developed scientific domains.The analysis patterns we have identified are shown in Table 4. The lastpattern overlaps with the first two. Code may be used as a source of domainknowledge informally or formally in the context of ODM or another methodology. Tool support for formal domain analysis is discussed in Section 3.2.8Pattern DescriptionLanguage exploitation DSL is based on an existing language. Important special cases Piggyback Existing language is partiallyused. Specialization Existing language is restricted. Extension Existing language is extended.Language invention A DSL is designed from scratch with no commonality with existing languages.Informal DSL is described informally.Formal DSL is described formally using an existingsemantics definition method such as attributegrammars, rewrite systems, or abstract statemachines 82.Table 5 Design patterns.2.4 DesignApproaches to DSL design can be characterised along two orthogonal dimensions the relationship between the DSL and existing languages, and the formalnature of the design description Table 5.The easiest way to design a DSL is to base it on an existing language. Onepossible benefit is familiarity for users, but this only applies if the domain usersare also programmers in the existing language, which as noted above is oftennot the case.We identify three patterns of design based on an existing language. First, wecan piggyback domainspecific features on part of an existing language. A relatedapproach restricts the existing language to provide a specialisation targeted atthe problem domain. The difference between these two patterns is really amatter of how rigid the barrier is between the DSL and the rest of the existinglanguage. Both of these approaches are often used where a notation is alreadywidely known. For example, many DSLs contain arithmetic expressions whichare usually written in the infixoperator style of mathematics.Another approach is to take an existing language and extend it with newfeatures that address domain concepts. In most applications of this pattern theexisting language features remain available. The challenge is to integrate thedomainspecific features with the rest of the language in a seamless fashion.At the other end of the spectrum to language extension is a DSL whosedesign bears no relationship to any existing language. In practice, developmentof this kind of DSL can be extremely difficult and is hard to characterise. Wellknown GPL design citeria such as readability, simplicity, orthogonality, etc.,and Tennents design principles 87 retain some validity for DSLs. However,9the DSL designer has to keep in mind both the special character of DSLs as wellas the fact that users need not be programmers. Since ideally the DSL adoptsestablished notations of the domain, the designer should suppress a tendencyto improve them. We quote lesson 3 of a total of 12 lessons learned from realDSL experiments from 97Lesson 3 You are almost never designing a programming language.Lesson 3 Corollary Design only what is necessary. Learn torecognize your tendency to overdesign.Most DSL designers come from language design backgrounds. Therethe admirable principles of orthogonality and economy of form arenot necessarily wellapplied to DSL design. Especially in cateringto the preexisting jargon and notations of the domain, one must becareful not to embellish or overgeneralize the language.Once the relationship to existing languages has been determined, a DSL designer must turn to specifying the design before implementation. We distinguishbetween informal and formal designs. In an informal design the specification isusually in some form of natural language probably including a set of illustrativeDSL programs. A formal design would consist of a specification written usingone of the available semantic definition methods 82. The most widely usedformal notations include regular expressions and grammars for syntax specifications, and attribute grammars, rewrite systems and abstract state machinesfor semantic specification.Clearly, an informal approach is likely to be easiest for most people. However,a formal approach should not be discounted. Informal language designs cancontain imprecisions that cause problems in the implementation phase. Theytypically focus on syntax, leaving semantic concerns to the imagination. Thediscipline required by development of a formal specification of both syntax andsemantics can bring problems to light before implementation. Furthermore, aswe shall see, formal designs can be implemented automatically by tools, therebysignificantly reducing implementation effort.2.5 Implementation2.5.1 PatternsWhen an executable DSL is designed, the most suitable implementation approach should be chosen. The implementation patterns we have identified areshown in Table 6. We discuss some of them in more detail.First, it should be noted that interpretation and compilation are as relevantfor DSLs as for GPLs, even though the special character of DSLs often makesthem amenable to other, more efficient, implementation methods, such as preprocessing and embedding. This viewpoint is at variance with 85, where itis argued that DSL development is radically different from GPL development,since the former is usually just a small part of a project and hence DSL development costs have to be modest. Development cost is not directly related to10Pattern DescriptionInterpreter DSL constructs are recognized and interpretedusing a standard fetchdecodeexecute cycle.This approach is appropriate for languageshaving a dynamic character or if executionspeed is not an issue. The advantages of interpretation over compilation are greater controlover the execution environment and easier extension.CompilerapplicationgeneratorDSL constructs are translated to base language constructs and library calls. A completestatic analysis can be done on the DSL programspecification. DSL compilers are oftencalled application generators.Preprocessor DSL constructs are translated to constructs inthe base language. Static analysis is limitedto that done by the base language processor.Important special cases Sourcetosource transformation DSLsource code is transformed translated intosource code of existing language the baselanguage. Pipeline Processors successively handlingsublanguages of a DSL and translating themto the input language of the next stage. Thispattern also includes examples where onlysimple lexical processing is required, withoutcomplicated treebased syntax analysis.Embedding DSL constructs are embedded in existing GPLthe host language by defining new abstractdata types and operators. Application libraries are the basic form of embedding.Extensible compilerinterpreterGPL compilerinterpreter is extended withdomainspecific optimization rules andordomainspecific code generation. While interpreters are usually relatively easy to extend,extending compilers is hard unless they weredesigned with extension in mind.Commercial OffTheShelf Existing tools andor notations are applied toa specific domain.Hybrid A combination of the above approaches isused.Table 6 Implementation patterns for executable DSLs.11implementation method, however, especially if a language development systemor toolkit is used to generate the implementation Section 3. DSL compilersare often called application generators.An alternative to the traditional approach to the implementation of DSLs isby embedding. In the embedding approach, a DSL is implemented by extendingan existing GPL the host language by defining specific abstract data typesand operators. A problem in a domain then can be described with these newconstructs. Therefore, the new language has all the power of the host language,but an application engineer can become a programmer without learning toomuch of it.To approximate domainspecific notations as closely as possible, the embedding approach can use any features for userdefinable operator syntax thehost language has to offer. For example, it is common to develop C classlibraries where the existing operators are overloaded with domainspecific semantics. While this technique is quite powerful, pitfalls exist in overloadingfamiliar operators to have unfamiliar semantics.C is also emblematic of another specific embedding approach templatemetaprogramming 23. In this method, templates are used to achieve compiletime generation of domainspecific code. Significant mileage has been made outof this approach to develop mathematical libraries for C which have familiardomain notation but also achieve good performance.Although the host language in the embedding approach can be any generalpurpose language, functional languages are often appropriate, as shown by manyresearchers 49, 54. This is due to functional language features such as expressiveness, lazy evaluation, higherorder functions, and strong typing with polymorphism and overloading. Imperative, objectoriented or logic languages areused as host languages to a lesser extent usually due to a lack of these sorts ofmechanisms.Extending an existing language implementation can also be seen as a formof embedding. The difference is usually a matter of degree. In a traditionalapproach the implementation would usually only be extended with a few features, such as new data types and operators for them. For a proper embedding,the extensions might encompass fullblown domainspecific language features.In both settings, however, extending implementations is often very difficult.Techniques for doing so in a safe and modular fashion are still the subject ofmuch research. Since compilers are particularly hard to extend, much of thiswork is aimed at preprocessors and extensible compilers allowing addition ofdomainspecific optimization rules andor domainspecific code generation. Wemention userdefinable optimization rules in the CodeBoost C preprocessor5 and in the Simplicissimus GCC compiler plugin 79, the Montana extensibleC programming environment 84, and userdefinable optimization rules inthe GHC Haskell compiler 72. Some extensible compilers, such as OpenC18, support a metaobject protocol. This is an objectoriented interface forspecifying language extensions and transformations.The COTSbased approach builds a DSL around existing tools and notations. Typically this approach involves applying existing functionality in a12restricted way, according to domain rules. For example, the generalpurposePowerpoint tool has been applied in a domainspecific setting for diagram editing 96. The current prominence of XMLbased DSLs is another instance ofthis approach 38.Many DSL endeavours apply a number of these approaches in a hybrid fashion. Thus the advantages of different approaches can be exploited. For instance,embedding can be combined with userdefined domainspecific optimization inan extensible compiler.2.5.2 Implementation tradeoffsAdvantages of the interpreter and compilerapplication generator approachesare DSL syntax can be close to notations used by domain experts, good error reporting possible, domainspecific analysis, verification, optimization, and transformationAVOT possible,while some disadvantages are the development effort is high because a complex language processor mustbe implemented, the DSL is more likely to be designed from scratch, often leading to incoherent designs compared with exploitation of an existing language, language extension is hard to realise because most language processors arenot designed with extension in mind.These disadvantages can be minimized or eliminated altogether when a language development system or toolkit is used so that much of the workof language processor construction is automated, and a modular and extensible formal method for DSL design is used so thatnew features can be added without significant modification to the processing of old features.Advocates of the embedded approach often criticize DSLs implemented bythe traditional approach in that too much effort is put into the syntax. Onthe other hand, the language semantics is often poorly designed and cannot beeasily extended with new features 54. Indeed, the syntax of a DSL is extremelyimportant and should not be underestimated. The syntax should be as close aspossible to the notation used in a domain.The abovementioned shortcomings of the traditional approach can be avoidedif a formal method is used for the development of the DSL. To date the followingformal methods for programming language description have been used abstract13state machines, algebraic specifications, attribute grammars, denotational semantics, and operational semantics. Furthermore, a useful formal method has tosupport incrementality, modularity and extensibility of specifications since DSLschange more frequently than GPLs 96, 13. An example of an extensible formalmethod is multiple attribute grammar inheritance 66 which enables incremental language development similar to the modular monadic approach often usedin embedding 49. The most productive development of languages is based onhighlevel automated tools which automatically generate compilerinterpreterfrom formal specifications.To return to the embedded approach, its advantages are development effort is modest because an existing implementation can bereused, often produces a more powerful language than other methods since manyfeatures come for free, reuse of host language infrastructure development and debugging environments editors, debuggers, tracers, profilers etc., user training costs might be lower since many users may already know thehost language.However, it is much harder to overcome the disadvantages of the embeddedapproach syntax is far from optimal because most languages do not allow arbitrarysyntax extension, overloading existing operators can be confusing if the new semantics doesnot have the same properties as the old, bad error reporting because messages are in terms of host language concepts instead of DSL concepts, domainspecific optimizations and transformations are hard to achieve,so efficiency may be affected, particularly when embedding in functionallanguages 54, 81.In the functional setting, some of these shortcomings can be reduced byusing monads 49 or userdefined optimizations in the GHC compiler if Haskellis used 72 for domainspecific optimizations and by using partial evaluationfor better overall efficiency 49, 21.The decision diagram on how to proceed with DSL implementation Fig. 1shows when a particular implementation approach is more appropriate.If in the DSL design phase the exploitation pattern is used then the piggyback pattern, language extension pattern, and language specialization patterncan be implemented using various implementation patterns. Figure 2 shows theimplementation costbenefit tradeoff associated with applying the implementation patterns to realise various design patterns.14Is DSL designed usingLanguage exploitationdesign patternAre domainspecificoptimizations andtransformationsrequirednoyes follow implementationguidelines for piggyback,extension and specializationpatterns figure 2Has domainspecificnotations bestrictly obeyedfollowing implementation patternsare recommended interpreter,compilerapplication generator,preprocessor  and extensiblecompilerinterpreternoyesyesWill user comunitybe largegood errorreportingis needed,...yesnonoEmbedding implementationpattern is recommendedFigure 1 Implementation guidelines.15LowLowMediumMediumHighHigh.EE.XE,X s.CP,CE,CSImplementation effortBenefits.PP,PE,PSFigure 2 Implementation costbenefit tradeoff for feasible pairs of design andimplementation pattern. Pairs are denoted IJ where I is an implementation pattern compilerinterpreter C, preprocessor P, exensible compilerinterpreterX, and embedding E, and J is a design pattern piggyback P, extensionE, and specialization S.16Note, that if the existing language is just partially used then the embeddingpattern or extensible compilerinterpreter pattern are not suitable. Furthermore, the embedding pattern is not suitable if the existing language has to berestricted. Such language specialization can be implemented using an extensiblecompilerinterpreter approach in some languages e.g., Smalltalk. In general,with the extensible compilerinterpreter approach it is much easier to extendthe language rather than restrict it.2.6 Comparison with other classificationsWe start by comparing our patterns with those proposed in 85. Closely following 35, Spinellis distinguishes three classes of DSL patterns as shown inTable 7. The specific patterns for each class are summarized in Tables 8, 9, and10. Most patterns are creational. The piggyback pattern might be classifiedas creational as well, since it is very similar to language extension. This wouldleave only a single pattern in each of the other two categories.First, it should be noted that Spinelliss patterns do not include traditionalGPL design and implementation techniques, while ours do, since we considerthem to be as relevant for DSLs as for GPLs. Second, Spinelliss classificationdoes not correspond in an obvious way to our classification in decision, analysis,design, and implementation patterns. The latter are all basically creational, butcovering a wider range of creationrelated activities than Spinelliss patterns.The correspondence of Spinelliss patterns with ours is shown in Table 11.Since our patterns have a wider scope, many of them have no counterpart inSpinelliss classification. These are not shown in the righthand column. As canbe seen, we have retained the terminology used by Spinellis whenever appropriate.Another classification of DSL development approaches is given in 96, namely,full language design, language extension, and COTSbased approaches. Sinceeach approach has its own pros and cons, the author discusses them with respectto three kinds of issues DSL specific, GPL support, and pragmatic support issues. Finally, the author shows how a hybrid development approach can beused.3 DSL Development Support3.1 Design and implementation supportAs we have seen, DSL development is hard, requiring both domain knowledgeand language development expertise. The development process can be facilitated by using a language development system or toolkit. Some systems andtoolkits that have actually been used for DSL development are listed in Table12. They have widely different capabilities and are in widely different stages ofdevelopment, but are based on the same general principle they generate toolsfrom language descriptions 44. The tools generated may vary from a consis17Pattern class DescriptionCreational pattern DSL creationStructural pattern Structure of system involving a DSLBehavioral pattern DSL interactionsTable 7 Pattern classification proposed by Spinellis.Pattern DescriptionLanguage extension DSL extends existing language with newdatatypes, new semantic elements, andornew syntax.Language specialization DSL restricts existing language for purposes ofsafety, static checking, andor optimization.Sourcetosource transformationDSL source code is transformed translatedinto source code of existing language the baselanguage.Data structure representationDatadriven code relies on initialized datastructures whose complexity may make themdifficult to write and maintain. These structures are often more easily expressed using aDSL.Lexical processing Many DSLs may be designed in a form suitable for recognition by simple lexical scanning.Table 8 Creational patterns.Pattern DescriptionPiggyback DSL has elements, for instance, expressions incommon with existing language. DSL processor passes those elements to existing languageprocessor.System frontend A DSL based frontend may often be used forhandling a systems configuration and adaptation.Table 9 Structural patterns.Pattern DescriptionPipeline Pipelined processors successively handlingsublanguages of a DSL and translating themto input language of next stage.Table 10 Behavioral patterns.18Spinelliss pattern Our patternCreational language extension Design language exploitationlanguage extensionCreational language specializationDesign language exploitationlanguage specializationCreational sourcetosourcetransformationImplementation preprocessingsourcetosource transformationCreational data structure representationDecision data structure representationCreational lexical processing Implementation preprocessingStructural piggyback Design language exploitationpiggybackStructural system frontend Decision system frontendBehavioral pipeline Implementation preprocessingpipelineTable 11 Correspondence of Spinelliss patterns with ours. Since our patternshave a wider scope, many of them have no counterpart in Spinelliss classification. These are not shown in the righthand column.tency checker and interpreter to an integrated development environment IDEconsisting of a syntaxdirected editor, a prettyprinter, an incremental consistency checker, an interpreter or compilerapplication generator, and a debuggerfor the DSL in question assuming it is executable. As noted in Section 1.2,nonexecutable DSLs may also benefit from various kinds of tool support suchas syntaxdirected editors, prettyprinters, and consistency checkers. These canbe generated in the same way.Some of these systems support a specific DSL design methodology, whileothers have a largely methodologyindependent character. For instance, Sprintassumes an interpreter for the DSL to be given and then uses a form of programtransformation called partial evaluation 50 to remove the interpretation overhead by automatically transforming a DSL program into a compiled program.Other systems would not only allow an interpretive definition of the DSL, butwould also accept a transformational or translational one. On the other hand,they might not include partial evaluation of a DSL interpreter given a specificprogram among their capabilities.The input to these systems is a description of various aspects of the DSL tobe developed in terms of specialized metalanguages. Depending on the type ofDSL, some important language aspects are syntax, prettyprinting, consistencychecking, execution, translation, transformation, and debugging. It so happensthat the metalanguages used for describing these aspects are themselves DSLsfor the particular aspect in question. For instance, DSL syntax is usually described in something close to BNF, the de facto standard for syntax specification19System Developed atASFSDF 14 CWIUniversity of AmsterdamAsmL 37 Microsoft Research, RedmondDraco 71 University of California, IrvineEli 42 University of Colorado, University of Paderborn,Macquarie UniversityGemMex 1 University of LAquilaInfoWiz 69 Bell LabsATT LabsJTS 8 University of Texas at AustinKhepera 30 University of North CarolinaKodiyak 45 University of MinnesotaLaCon 56 University of PaderbornLaCon uses Eli as backend  see aboveLISA 68 University of MariborMetatool 19 Bell LaboratoriesPOPART 95 USCInformation Sciences Institutesmgn 57 Intel Compiler LabUniversity of VictoriaSPARK 3 University of CalgarySprint 21 LaBRIINRIAStratego 94 University of UtrechtTXL 92 University of TorontoQueens Universityat KingstonTable 12 Some language development systems and toolkits that have been usedfor DSL development.Development phase Support providedPattern classDecision NoneAnalysis Not yet integrated  seeSection 3.2Design WeakImplementation StrongTable 13 Development support provided by current language development systems and toolkits for DSL development phasespattern classes.20System used DSL Application domainASFSDF Box 15 PrettyprintingRisla 26 Financial productsAsmL UPnP 93 Networked device protocolXLANG 88 Business protocolsEli Maptool 52 Grammar mappingVarious 73 Class generationGemMex Cubix 60 Virtual data warehousingJTS Jak 8 Syntactic transformationLaCon Various 56 Data model translationLISA SODL 67 Network applicationsmgn Hoof 57 Compiler IR specificationIMDL 57 Software reengineeringSPARK Guide 61 Web programmingCML2 75 System configurationSprint GAL 90 Video device driversPLANP 89 Applicationspecific protocolsStratego Autobundle 51 Software buildingCodeBoost 5 Domainspecific C optimizationTable 14 Examples of DSL development using the systems in Table 12.Table 1. The corresponding tool generated by the language development system is a parser.Although the various specialized metalanguages used for describing language aspects differ from system to system, they are often but not always rulebased. For instance, depending on the system, the consistency of programs orscripts may have to be checked in terms of attributed syntax rules an extensionof BNF, conditional rewrite rules, or transition rules. See, for instance, 82 forfurther details.The level of support provided by these systems in various phases of DSLdevelopment is summarized in Table 13. Their main strength lies in the implementation phase. Support of DSL design tends to be weak. Their main assetsare the metalanguages they support, and in some cases a metaenvironment toaid in constructing and debugging language descriptions, but they have littlebuiltin knowledge of language concepts or design rules. Furthermore, to thebest of our knowledge, none of them provides any support in the analysis ordecision phase. Analysis support tools are discussed in Section 3.2.Examples of DSL development using the systems in Table 12 are given inTable 14. They cover a wide range of appplication domains and implementation patterns. The Box prettyprinting metalanguage is an example of a DSLdeveloped with a language development system in this case the ASFSDFMetaEnvironment for later use as one of the metalanguages of the systemitself. Similarly, the Jak transformational metalanguage for specifying the se21mantics of a DSL or domainspecific language extension in the Jakarta ToolSuite JTS, was developed using JTS itself. In this case, this involved bootstrapping, since JTS not only requires language definitions to be written in Jak,but is itself written in Jak.3.2 Analysis supportThe language development toolkits and systems discussed in the previous sectiondo not provide support in the analysis phase of DSL development. Separateframeworks and tools for this have been or are being developed, however. Someof them are listed in Table 15. This is a research area. We have included a shortdescription of each entry, largely taken from the reference given for it. The factthat a framework or tool is listed does not necessarily mean it is in use or evenexists.As noted in Section 2.3 the output of formal domain analysis is some kind ofrepresentation of the domain knowledge obtained. It may range from a featurediagram see FDL entry in Table 15 to a domain implementation consistingof a set of domainspecific reusable components see DARE entry in Table 15,or a fullfledged theory in the case of highly developed scientific domains. Animportant issue is how to link formal domain analysis with DSL design andimplementation. The possibility of linking DARE directly to the Metatool metagenerator 19 is mentioned in 33.4 Conclusions and Open ProblemsDSLs will never be a solution to all software engineering problems, but theirapplication is currently unduly limited by a lack of reliable knowledge availableto potential DSL developers. To help remedy this situation, we distinguishedfive phases of DSL development and identified patterns in each phase, exceptdeployment. These are summarized in Table 16. Furthermore, we discussedlanguage development systems and toolkits that can be used to facilitate thedevelopment process, especially its later phases.Our survey also implicitly or explicitly showed many opportunities for further work. As indicated in Table 13, for instance, there are serious gaps in theDSL development support chain. More specifically, some of the issues needingfurther attention areDecision Can useful computeraided decision support be provided If so,its integration in existing language development systems or toolkits Table 12might yield additional advantages.Analysis Further development and integration of domain analysis supporttools. As noted in Section 2.3, there is a close link with knowledge engineering.Existing knowledge engineering tools and frameworks may be useful directly or22Analysis framework or toolDescriptionAriadne 80 ODM support framework enabling domain practitioners to collaboratively develop and evolve theirown semantic models, and to compose and customizeapplications incorporating these models as firstclassarchitectural elements.DARE 34 Supports the capture of domain information from experts, documents, and code in a domain. Captureddomain information is stored in a domain book thatwill typically contain a generic architecture for thedomain and domainspecific reusable components.DOMAIN 91 DSSA 86 support framework consisting of a collection of structured editors and a hypertextmedia engine that allows the user to capture, represent, andmanipulate various types of domain knowledge in ahyperweb. DOMAIN supports a scenariobasedapproach to domain analysis. Users enter scenariosdescribing the functions performed by applications inthe domain of interest. The text in these scenarioscan then be used in a semiautomated manner todevelop a domain dictionary, reference requirements,and domain model, each of which are supported bytheir own editor.FDL 27 The Feature Description Language FDL is a textual representation of feature diagrams, which are agraphical notation for expressing assertions propositions, predicates about systems in a particularapplication domain. These were introduced in theFODA 55 domain analysis methodology. FDL isan example of the visualtotextual transformationsubpattern in Table 3.ODE editor 31 Ontology editor supporting ODE  see also 25.Table 15 Some domain analysis frameworks and tools.23Development phase PatternDecision NotationSection 2.2 Task automationData structure representationData structure traversalSystem frontendInteractionAVOTAnalysis InformalSection 2.3 FormalExtract from codeDesign Language exploitationSection 2.4 Language inventionInformalFormalImplementation InterpreterSection 2.5 Compilerapplication generatorPreprocessorEmbeddingExtensible compilerinterpreterCOTSHybridTable 16 Summary of DSL development phases and corresponding patterns.24act as inspiration for further developments in this area. An important issue ishow to link formal domain analysis with DSL design and implementation.Design and implementation How can DSL design and implementation bemade easier for domain experts not versed in GPL development Some approaches are not mutually exclusive Building DSLs from parameterized language building blocks 1, 21, 44. A related issue is how to combine different parts of existing GPLs andDSLs into a new DSL. For instance, in the Microsoft .NET frameworkmany GPLs are compiled to the Common Language Runtime CLR 39.Can this be helpful in including selected parts of GPLs into a new DSL Provide pattern aware development support. The Sprint system 21, forinstance, provides partial evaluation support for the interpreter patternsee Section 3.1. Other patterns might benefit from specialized supportas well. Reduce the need for learning some of the specialized metalanguages of language development systems by supporting description by example DBEof selected language aspects like syntax or prettyprinting. The userfriendliness of DBE is due to the fact that examples of intended behaviordo not require a specialized metalanguage, or only a small part of it.Grammar inference from example sentences, for instance, may be viable,especially since many DSLs are small. This is certainly no new idea 22,but it remains to be realized. Some preliminary results are reported in63. How can DSL development tools generated by language development systems and toolkits be integrated with other software development toolsUsing a COTSbased approach, XML technologies such as DOM andXMLparsers have great potential as a uniform data interchange formatfor CASE tools. See also 20.Embedding GPLs should provide more powerful support for embedding DSLs,both syntactically and semantically. Some issues are Embedding suffers from the very limited userdefinable syntax offered byGPLs. Perhaps surprisingly, there is no trend toward more powerful userdefinable syntax in GPLs over the years. Java has no userdefinable syntaxat all. This is a neglected aspect of GPL design. The discussion in 43 isstill relevant. Improved embedding support is not only a matter of language features,but also of language implementation, and in particular of preprocessorsor extensible compilers allowing addition of domainspecific optimizationrules andor domainspecific code generation. See the references given in25Section 2.5.1 and 40, 78. Alternatively, the GPL itself might featuredomainspecific optimization rules as a special kind of compiler directive.Such compiler extension makes the embedding process significantly morecomplex, however, and its costbenefit ratio needs further scrutiny.Estimation In this article our approach toward DSL development has been qualitative.Can the costs and benefits of DSLs be reliably quantifiedAcknowledgements Arie van Deursen kindly gave us permission to use thesource of the annotated DSL bibliography 28.References1 M. Anlauff, P. W. Kutter, and A. Pierantonio. Formal aspects and development environments for Montages. In M. P. A. Sellink, editor, 2nd International Workshop on the Theory and Practice of Algebraic SpecificationsASFSDF 97, Electronic Workshops in Computing. SpringerBritishComputer Society, 1997.2 P. J. Ashenden. The Designers Guide to VHDL. Morgan Kaufmann, 1995.3 J. Aycock. The design and implementation of SPARK, a toolkit for implementing domainspecific languages. In Journal for Computing and Information Technology 65, pages 5566.4 J. W. Backus. The syntax and semantics of the proposed International Algebraic Language of the Zurich ACMGAMM conference. In Proceedings ofthe International Conference on Information Processing, UNESCO, Paris,1959, pages 125132. Oldenbourg, Munich and Butterworth, London, 1960.5 O. S. Bagge and M. Haveraaen. Domainspecific optimisation with userdefined rules in CodeBoost. In Proceedings 4th International Workshopon RuleBased Programming RULE 2003, 2003. To appear in ElectronicNotes in Theoretical Computer Science.6 D. W. Barron. The World of Scripting Languages. Wiley, 2000.7 A. Basu, M. Hayden, G. Morrisett, and T. von Eicken. A languagebasedapproach to protocol construction. In Kamin 53, pages 115. httpwwwsal.cs.uiuc.edukamindsl.8 D. Batory, B. Lofaso, and Y. Smaragdakis. JTS Tools for implementingdomainspecific languages. In P. Devanbu and J. Poulin, editors, Proceedings of the Fifth International Conference on Software Reuse JCSR 98,pages 143153. IEEE Computer Society, 1998.269 K. H. Bennett and V. T. Rajlich. Software maintenance and evolution Aroadmap. In A. Finkelstein, editor, The Future of Software Engineering,pages 7387. ACM Press, 2000.10 J. L. Bentley. Programming pearls Little languages. Communications ofthe ACM, 298711721, August 1986.11 T. J. Biggerstaff. A perspective of generative reuse. Annals of SoftwareEngineering, 5169226, 1998.12 T. J. Biggerstaff and A. J. Perlis, editors. Software Reusability. ACMPressAddisonWesley, 1989. Vol. I Concepts and Models, Vol. II Applications and Experience.13 J. Bosch and Y. Dittrich. Domainspecific languages for a changing world,n.d. httpwww.cs.rug.nlboscharticles.html.14 M. G. J. van den Brand, A. van Deursen, J. Heering, H. A. de Jong,M. de Jonge, T. Kuipers, P. Klint, L. Moonen, P. A. Oliver, J. Scheerder,J. J. Vinju, E. Visser, and J. Visser. The ASFSDF metaenvironmentA componentbased language development environment. In R. Wilhelm,editor, Compiler Construction CC 2001, volume 2027 of Lecture Notes inComputer Science, pages 365370. SpringerVerlag, 2001.15 M. G. J. van den Brand and E. Visser. Generation of formatters for contextfree languages. ACM Transactions on Software Engineering and Methodology, 5141, 1996.16 L. Cardelli and R. Davies. Service combinators for web computing. 98,pages 309316.17 D. Chappell. Understanding ActiveX and OLE. Microsoft Press, 1996.18 S. Chiba. A metaobject protocol for C. In Proceedings of the ACMConference on ObjectOriented Programming Systems, Languages, and Applications, pages 285299. ACM, 1995.19 J. C. Cleaveland. Building application generators. IEEE Software, pages2533, July 1988.20 J. C. Cleaveland. Program Generators Using Java and XML. PrenticeHall,2001.21 C. Consel and R. Marlet. Architecturing software using a methodologyfor language development. In C. Palamidessi, H. Glaser, and K. Meinke,editors, Principles of Declarative Programming PLILP 98ALP 98, volume 1490 of Lecture Notes in Computer Science, pages 170194. SpringerVerlag, 1998.2722 S. CrespiReghizzi, M. A. Melkanoff, and L. Lichten. The use of grammatical inference for designing programming languages. Communications of theACM, 168390, 1973.23 K. Czarnecki and U. Eisenecker. Generative Programming. AddisonWesley,2000.24 K. Czarnecki and U. Eisenecker. Generative Programming Methods, Techniques and Applications. AddisonWesley, 2000.25 M. Denny. Ontology building A survey of editing tools. Technical report,XML.com, 2003. httpwww.xml.comlpta20021106ontologies.html.26 A. van Deursen and P. Klint. Little languages Little maintenance Journalof Software Maintenance, 107592, 1998.27 A. van Deursen and P. Klint. Domainspecific language design requiresfeature descriptions. In Journal for Computing and Information Technology65, pages 117.28 A. van Deursen, P. Klint, and J. Visser. Domainspecific languages Anannotated bibliography. ACM SIGPLAN Notices, 3562636, June 2000.29 Proceedings of the second USENIX Conference on DomainSpecific Languages DSL 99. USENIX Association, 1999.30 R. E. Faith, L. S. Nyland, and J. F. Prins. Khepera A system for rapidimplementation of domain specific languages. In Ramming 74, pages 24355.31 R. A. Falbo, G. Guizzardi, and K. C. Duarte. An ontological approach todomain engineering. In Proceedings of the 14th International Conferenceon Software Engineering and Knowledge Engineering SEKE 2002, pages351358. ACM Press, 2002.32 K. Fertalj, D. Kalpic, and V. Mornar. Source code generator based on aproprietary specification language. In HICSS35 47.33 W. Frakes. Panel Linking domain analysis with domain implementation.In Proceedings of the Fifth International Conference on Software Reuse,pages 348349. IEEE Computer Society, 1998.34 W. Frakes, R. PrietoDiaz, and C. Fox. DARE Domain analysis and reuseenvironment. Annals of Software Engineering, 5125141, 1998.35 E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns Elements of Reusable ObjectOriented Software. AddisonWesley, 1995.36 S. Gilmore and M. Ryan, editors. Language Constructs for Describing Features  Proceedings of the FIREworks Workshop. SpringerVerlag, 2001.2837 U. Glasser, Y. Gurevich, and M. Veanes. An abstract communicationmodel. Technical Report MSRTR200255, Microsoft Research, Redmond,2002.38 K. Gondow and H. Kawashima. Towards ANSI C program slicing usingXML. In M. G. J. van den Brand and R. Lammel, editors, Second Workshopon Language Descriptions, Tools and Applications LDTA 02, 2002.39 J. Gough. Compiling for the .NET Common Language Runtime CLR.Prentice Hall, 2002.40 A. Granicz and J. Hickey. Phobos Extending compilers with executablelanguage definitions. In HICSS36 48.41 J. Gray and G. Karsai. An examination of DSLs for concisely representingmodel traversals and transformations. In HICSS36 48.42 R. W. Gray, S. P. Levi, V. P. Heuring, A. M. Sloane, and W. M. Waite.Eli a complete, flexible compiler construction system. Communications ofthe ACM, 352121130, February 1992.43 J. Heering and P. Klint. The syntax definition formalism SDF. In J. A.Bergstra, J. Heering, and P. Klint, editors, Algebraic Specification, chapter 6. ACM Press, 1989.44 J. Heering and P. Klint. Semantics of programming languages A tooloriented approach. ACM SIGPLAN Notices, 3533948, March 2000.45 R. M. Herndon and V. A. Berzins. The realizable benefits of a languageprototyping language. IEEE Transactions on Software Engineering, SE14803809, 1988.46 Proceedings of the 34th Hawaii International Conference on System Sciences HICSS34. IEEE CDROM, 2001.47 Proceedings of the 35th Hawaii International Conference on System Sciences HICSS35. IEEE CDROM, 2002.48 Proceedings of the 36th Hawaii International Conference on System Sciences HICSS36. IEEE CDROM, 2003.49 P. Hudak. Modular domain specific languages and tools. In P. Devanbuand J. Poulin, editors, Proceedings of the Fifth International Conference onSoftware Reuse JCSR 98, pages 134142. IEEE Computer Society, 1998.50 N. D. Jones, C. K. Gomard, and P. Sestoft. Partial Evaluation and Automatic Program Generation. Prentice Hall, 1993.51 M. de Jonge. Source tree composition. In C. Gacek, editor, Software ReuseMethods, Techniques, and Tools 7th International Conference ICSR7,volume 2319 of Lecture Notes in Computer Science, pages 1732. SpringerVerlag, 2002.2952 B. M. Kadhim and W. M. Waite. Maptool  Supporting modular syntax development. In T. Gyimothy, editor, Compiler Construction CC96, volume 1060 of Lecture Notes in Computer Science, pages 268280.SpringerVerlag, 1996.53 S. Kamin, editor. DSL 97  First ACM SIGPLAN Workshop on DomainSpecific Languages, in Association with POPL 97. University of IllinoisComputer Science Report, 1997. httpwwwsal.cs.uiuc.edukamindsl.54 S. Kamin. Research on domainspecific embedded languages and programgenerators. Electronic Notes in Theoretical Computer Science, 14, 1998.55 K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak, and A. S. Peterson.Featureoriented domain analysis FODA feasibility study. Technical Report CMUSEI90TR21, Software Engineering Institute, Carnegie MellonUniversity, 1990.56 U. Kastens and P. Pfahler. Compositional design and implementation ofdomainspecific languages. In R. N. Horspool, editor, IFIP TC2 WG 2.4Working Conference on System Implementation 2000 Languages, Methodsand Tools, pages 152165. Chapman and Hall, 1998.57 H. M. Kienle and D. L. Moore. smgn Rapid prototyping of small domainspecific languages. In Journal for Computing and Information Technology65, pages 3753.58 N. Klarlund and M. Schwartzbach. A domainspecific language for regularsets of strings and trees. In IEEE Transactions on Software Engineering98, pages 378386.59 C. W. Krueger. Software reuse. ACM Computing Surveys, 242131183,June 1992.60 P. W. Kutter, D. Schweizer, and L. Thiele. Integrating domain specificlanguage design in the software life cycle. In D. Hutter et al., editors,Applied Formal MethodsFMTrends 98, volume 1641 of Lecture Notes inComputer Science, pages 196212. SpringerVerlag, 1998.61 M. R. Levy. Web programming in Guide. Software  Practice and Experience, 2815811603, 1998.62 J. Martin. FourthGeneration Languages. PrenticeHall, 1985. Vol. IPrinciples, Vol II Representative 4GLs.63 M. Mernik, M. Crepinsek, G. Gerlic, V. Zumer, B. R. Bryant, andA. Sprague. Learning contextfree grammars using an evolutionary approach. Technical report, University of Maribor and The University ofAlabama at Birmingham, 2003.3064 M. Mernik and R. Lammel eds.. Special issue on domainspecific languages, Part I. Journal for Computing and Information Technology, 94,2001.65 M. Mernik and R. Lammel eds.. Special issue on domainspecific languages, Part II. Journal for Computing and Information Technology, 101,2002.66 M. Mernik, M. Lenic, E. Avdicausevic, and V. Zumer. Multiple attributegrammar inheritance. Informatica, 243319328, September 2000.67 M. Mernik, U. Novak, E. Avdicausevic, M. Lenic, and V. Zumer. Designand implementation of Simple Object Description Language. In Proceedingsof the 2001 ACM Symposium on Applied Computing SAC 2001, pages590594. ACM Press, 2001.68 M. Mernik, V. Zumer, M. Lenic, and E. Avdicausevic. Implementation ofmultiple attribute grammar inheritance in the tool LISA. ACM SIGPLANNotices, 3466875, June 1999.69 L. Nakatani and M. Jones. Jargons and infocentrism. In Kamin 53, pages5974. httpwwwsal.cs.uiuc.edukamindsl.70 B. A. Nardi. A Small Matter of Programming Perspectives on End UserComputing. MIT Press, 1993.71 J. M. Neighbors. The Draco approach to constructing software fromreusable components. IEEE Transactions on Software Engineering, SE10556474, September 1984.72 S. Peyton Jones, A. Tolmach, and T. Hoare. Playing by the rules Rewriting as a practical optimisation technique in GHC. In Proceedings HaskellWorkshop 2001, 2001.73 P. Pfahler and U. Kastens. Configuring componentbased specifications fordomainspecific languages. In HICSS34 46.74 J. C. Ramming, editor. Proceedings of the USENIX Conference on DomainSpecific Languages. USENIX Association, 1997.75 E. S. Raymond. The CML2 language Python implementation of aconstraintbased interactive configurator. In Proceeding of the 9th International Python Conference, pages 135142, 2001.76 D. T. Ross. Origins of the APT language for automatically programmedtools. In R. L. Wexelblat, editor, History of Programming Languages, pages279338. Academic Press, 1981.77 P. H. Salus, editor. Little Languages, volume III of Handbook of Programming Languages. MacMillan, 1998.3178 J. Saraiva and S. Schneider. Embedding domain specific languages in theattribute grammar formalism. In HICSS36 48.79 S. Schupp, D. P. Gregor, D. R. Musser, and S. Liu. Userextensible simplification  Typebased optimizer generators. In R. Wilhelm, editor, Compiler Construction CC 2001, volume 2027 of Lecture Notes in ComputerScience, pages 86101. SpringerVerlag, 2001.80 M. Simos and J. Anthony. Weaving the model web A multimodelingapproach to concepts and features in domain engineering. In Proceedingsof the Fifth International Conference on Software Reuse, pages 94102.IEEE Computer Society, 1998.81 A. M. Sloane. Postdesign domainspecific language embedding A casestudy in the software engineering domain. In HICSS35 47.82 K. Slonneger and B. L. Kurtz. Formal Syntax and Semantics of Programming Languages A Laboratory Based Approach. AddisonWesley, 1995.83 Y. Smaragdakis and D. Batory. Application generators. Technical report,Department of Computer Science, University of Texas at Austin, n.d. httpwww.cc.gatech.eduyannisgenerators.pdf.84 D. Soroker, M. Karasick, J. Barton, and D. Streeter. Extension mechanismsin Montana. In Proceedings of the 8th Israeli Conference on ComputerBased Systems and Software Engineering ICCSSE 97, pages 119128.IEEE Computer Society, 1997.85 D. Spinellis. Notable design patterns for domainspecific languages. TheJournal of Systems and Software, 569199, 2001.86 R. N. Taylor, W. Tracz, and L. Coglianese. Software development usingdomainspecific software architectures. ACM SIGSOFT Software Engineering Notes, 2052737, 1995.87 R. D. Tennent. Language design methods based on semantic principles.Acta Informatica, 897112, 1977.88 S. Thatte. XLANG Web services for business process design. Technical report, Microsoft, 2001. httpwww.gotdotnet.comteamxmlwsspecsxlangc.89 S. A. Thibault, C. Consel, and G. Muller. Safe and efficient active network programming. In Proceedings 17th IEEE Symposium on Reliable Distributed Systems, pages 135143, 1998.90 S. A. Thibault, R. Marlet, and C. Consel. Domainspecific languages Fromdesign to implementation  application to video device drivers generation.98, pages 363377.3291 W. Tracz and L. Coglianese. DOMAIN DOmain Model All INtegrated a DSSA domain analysis tool. Technical Report ADAGELOR9411,Loral Federal Systems, 1995.92 The TXL Programming Language, 2003. httpwww.txl.ca.93 Universal Plug and Play Forum, 2003. httpwww.upnp.org.94 E. Visser. Stratego  Strategies for program transformation, 2003. httpwww.strategolanguage.org.95 D. S. Wile. POPART Producer of Parsers and Related Tools.USCInformation Sciences Institute, November 1993. httpmr.teknowledge.comwilepopart.html.96 D. S. Wile. Supporting the DSL spectrum. In Journal for Computing andInformation Technology 64, pages 263287.97 D. S. Wile. Lessons learned from real DSL experiments. In HICSS36 48.98 D. S. Wile and J. C. Ramming eds.. Special issue on domainspecificlanguages. IEEE Transactions on Software Engineering, 253, MayJune1999.33
