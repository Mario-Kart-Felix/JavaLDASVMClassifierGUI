Distributed Operating Systems ANDREW S. TANENBAUM and ROBBERT VAN RENESSE Department of Mathematics and Computer Science, Vrije Universiteit, Amsterdam, The Netherlands Distributed operating systems have many aspects in common with centralized ones, but they also differ in certain ways. This paper is intended as an introduction to distributed operating systems, and especially to current university research about them. After a discussion of what constitutes a distributed operating system and how it is distinguished from a computer network, various key design issues are discussed. Then several examples of current research projects are examined in some detail, namely, the Cambridge Distributed Computing System, Amoeba, V, and Eden. Categories and Subject Descriptors C.2.4 ComputerCommunications Networks Distributed Systemsnetwork operating system D.4.3 Operating Systems File Systems Managementdistributed file systems D.4.5 Operating Systems Reliabilityfault tolerance D.4.6 Operating Systems Security and Protectionaccess controls D.4.7 Operating Systems Organization and Designdistributed systems General Terms Algorithms, Design, Experimentation, Reliability, Security Additional Key Words and Phrases File server INTRODUCTION Everyone agrees that distributed systems are going to be very important in the future. Unfortunately, not everyone agrees on what they mean by the term distributed system. In this paper we present a view point widely held within academia about what is and is not a distributed system, we discuss numerous interesting design issues concerning them, and finally we conclude with a fairly close look at some experimen tal distributed systems that are the subject of ongoing research at universities. To begin with, we use the term distrib uted system to mean a distributed operat ing system as opposed to a database system or some distributed applications system, such as a banking system. An operating system is a program that controls the re sources of a computer and provides its users with an interface or virtual machine that is more convenient to use than the bare ma chine. Examples of wellknown centralized i.e., not distributed operating systems are CPM, MSDOS, and UNIX.3 A distributed operating system is one that looks to its users like an ordinary central ized operating system but runs on multi ple, independent central processing units CPUs. The key concept here is transpar ency. In other words, the use of multiple processors should be invisible transparent to the user. Another way of expressing the same idea is to say that the user views the system as a virtual uniprocessor, not as a collection of distinct machines. This is easier said than done. Many multimachine systems that do not fulfill this requirement have been built. For  CPM is a trademark of Digital Research, Inc.  MSDOS is a trademark of Microsoft. 3 UNIX is a trademark of ATT Bell Laboratories. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee andor specific permission. 0 1986 ACM 036003008512000419 00.75 Computing Surveys, Vol. 17, No. 4, December 1985 420 l A. S. Tanenbaum and R. van Renesse CONTENTS INTRODUCTION Goals and Problems System Models 1. NETWORK OPERATING SYSTEMS 1.1 File System 1.2 Protection 1.3 Execution Location 1.4 An Example The Sun Network File System 2. DESIGN ISSUES 2.1 Communication Primitives 2.2 Naming and Protection 2.3 Resource Management 2.4 Fault Tolerance 2.5 Services 3. EXAMPLES OF DISTRIBUTED OPERATING SYSTEMS 3.1 The Cambridge Distributed Computing System 3.2 Amoeba 3.3 The V Kernel 3.4 The Eden Project 3.5 Comparison of the Cambridge, Amoeba, V, and Eden Systems 4. SUMMARY ACKNOWLEDGMENTS REFERENCES example, the ARPANET contains a sub stantial number of computers, but by this definition it is not a distributed system. Neither is a local network consisting of personal computers with minicomputers and explicit commands to log in here or copy a file from there. In both cases we have a computer network but not a distrib uted operating system. Thus it is the soft ware, not the hardware, that determines whether a system is distributed or not. As a rule of thumb, if you can tell which computer you are using, you are not using a distributed system. The users of a true distributed system should not know or care on which machine or machines their programs are running, where their files are stored, and so on. It should be clear by now that very few distributed systems are currently used in a production environ ment. However, several promising research projects are in progress. To make the contrast with distributed operating systems stronger, let us briefly look at another kind of system, which we call a network operating system. A typical configuration for a network operating sys tem would be a collection of personal com puters along with a common printer server and file server for archival storage, all tied together by a local network. Generally speaking, such a system will have most of the following characteristics that distin guish it from a distributed system l Each computer has its own private oper ating system, instead of running part of a global, systemwide operating system. l Each user normally works on his or her own machine using a different machine invariably requires some kind of remote login, instead of having the operating system dynamically allocate processes to CPUS. l Users are typically aware of where each of their files are kept and must move files between machines with explicit file transfer commands, instead of having file placement managed by the operating system. l The system has little or no fault toler ance if 1 percent of the personal com puters crash, 1 percent of the users are out of business, instead of everyone sim ply being able to continue normal work, albeit with 1 percent worse performance. Goals and Problems The driving force behind the current inter est in distributed systems is the enormous rate of technological change in micropro cessor technology. Microprocessors have become very powerful and cheap, compared with mainframes and minicomputers, so it has become attractive to think about de signing large systems composed of many small processors. These distributed sys tems clearly have a priceperformance ad vantage over more traditional systems. Another advantage often cited is the rela tive simplicity of the softwareeach pro cessor has a dedicated functionalthough this advantage is more often listed by people who have never tried to write a Computing Surveys, Vol. 17, No. 4, December 1985 Distributed Operating Systems l 421 VAXs, each with multiple users. Each user is logged onto one specific machine, with remote access to the other machines. This model is a simple outgrowth of the central timesharing machine. In the workstation model, each user has a personal workstation, usually equipped with a powerful processor, memory, a bit mapped display, and sometimes a disk. Nearly all the work is done on the work stations. Such a system begins to look dis tributed when it supports a single, global file system, so that data can be accessed without regard to their location. The processor pool model is the next evolutionary step after the workstation model. In a timesharing system, whether with one or more processors, the ratio of CPUs to loggedin users is normally much less than 1 with the workstation model it is approximately 1 with the processor pool model it is much greater than 1. As CPUs get cheaper and cheaper, this model will become more and more widespread. The idea here is that whenever a user needs computing power, one or more CPUs are temporarily allocated to that user when the job is completed, the CPUs go back into the pool to await the next request. As an example, when ten procedures each on a separate file must be recompiled, ten pro cessors could be allocated to run in parallel for a few seconds and then be returned to the pool of available processors. At least one experimental system described below Amoeba attempts to combine two of these models, providing each user with a work station in addition to the processor pool for general use. No doubt other variations will be tried in the future. distributed operating system than by those who have. Incremental growth is another plus if you need 10 percent more computing power, you just add 10 percent more pro cessors. System architecture is crucial to this type of system growth, however, since it is hard to give each user of a personal computer another 10 percent of a personal computer. Reliability and availability can also be a big advantage a few parts of the system can be down without disturbing people using the other parts. On the minus side, unless one is very careful, it is easy for the communication protocol overhead to become a major source of inefficiency. There has been built more than one system requiring the full computing power of its machines just to run the protocols, leaving nothing over to do the work. The occasional lack of simplicity cited above is a real prob lem, although in all fairness, this problem comes from inflated goals With a central ized system no one expects the computer to function almost normally when half the memory is sick. With a distributed system, a high degree of fault tolerance is often, at least, an implicit goal. A more fundamental problem in distrib uted systems is the lack of global state information. It is generally a bad idea to even try to collect complete information about any aspect of the system in one table. Lack of uptodate information makes many things much harder. It is hard to schedule the processors optimally if you are not sure how many are up at the moment. Many people, however, think that these obstacles can be overcome in time, so there is great interest in doing research on the subject. System Models Various models have been suggested for building a distributed system. Most of them fall into one of three broad categories, which we call the minicomputer model, the workstation model, and the proces sor pool model. In the minicomputer model, the system consists of a few per haps even a dozen minicomputers e.g., 1. NETWORK OPERATING SYSTEMS Before starting our discussion of distrib uted operating systems, it is worth first taking a brief look at some of the ideas involved in network operating systems, since they can be regarded as primitive forerunners. Although attempts to connect computers together have been around for decades, networking really came into the limelight with the ARPANET in the early Computing Surveys, Vol. 17, No. 4, December 1985 422 . A. S. Tanenbaum and R. van Renesse 1970s. The original design did not provide for much in the way of a network operating system. Instead, the emphasis was on using the network as a glorified telephone line to allow remote login and file transfer. Later, several attempts were made to create net work operating systems, but they never were widely used Millstein 19771. In more recent years, several research organizations have connected collections of minicomputers running the UNIX operat ing system Ritchie and Thompson 19741 into a network operating system, usually via a local network Birman and Rowe 1982 Brownbridge et al. 1982 Chesson 1975 Hwang et al. 1982 Luderer et al. 1981 Wambecq 19831. Wupit 1983 gives a good survey of these systems, which we shall draw upon for the remainder of this section. As we said earlier, the key issue that distinguishes a network operating system from a distributed one is how aware the users are of the fact that multiple machines are being used. This visibility occurs in three primary areas the file system, pro tection, and program execution. Of course, it is possible to have systems that are highly transparent in one area and not at all in the other, which leads to a hybrid form. 1.1 File System When connecting two or more distinct sys tems together, the first issue that must be faced is how to merge the file systems. Three approaches have been tried. The first approach is not to merge them at all. Going this route means that a program on ma chine A cannot access files on machine B by making system calls. Instead, the user must run a special file transfer program that copies the needed remote files to the local machine, where they can then be ac cessed normally. Sometimes remote print ing and mail is also handled this way. One of the bestknown examples of net works that primarily support file transfer and mail via special programs, and not system call access to remote files, is the UNIX uucp program, and its network, USENET. The next step upward in the direction of a distributed file system is to have adjoining Computing Surveys, Vol. 17, No. 4, December 1985 file systems. In this approach, programs on one machine can open files on another ma chine by providing a path name telling where the file is located. For example, one could say open machinelpathname , READ openmachinelpathname, READ openf. .machinelpathname, READ The latter naming scheme is used in the Newcastle Connection Brownbridge et al. 19821 and Netix Wambecq 19831 and is derived from the creation of a virtual superdirectory above the root directories of all the connected machines. Thus . . means start at the local root directory and go upward one level to the superdirectory, and then down to the root directory of machine. In Figure 1, the root directory of three machines, A, B, and C are shown, with a superdirectory above them. To ac cess file x from machine C, one could say open . .Cx , READONLY In the Newcastle system, the naming tree is actually more general, since machine 1 may really be any directory, so one can attach a machine as a leaf anywhere in the hierarchy, not just at the top. The third approach is the way it is done in distributed operating systems, namely, to have a single global file system visible from all machines. When this method is used, there is one bin directory for binary programs, one password file, and so on. When a program wants to read the pass word file it does something like open etcpasswd , READONLY without reference to where the file is. It is up to the operating system to locate the file and arrange for transport of data as they are needed. LOCUS is an example of a system using this approach Popek et al. 1981 Walker et al. 1983 Weinstein et al. 19851. The convenience of having a single global name space is obvious. In addition, this approach means that the operating system is free to move files around among ma chines to keep all the disks equally full and busy, and that the system can maintain Distributed Operating Systems l 423 way, the network is just being used as a fancy switch to allow users at any terminal to log onto any computer, just as a tele phone company switching center allows any subscriber to call any other subscriber. This solution is usually inconvenient for people and impractical for programs, so something better is needed. The next step up is to allow any user to access files on any machine without having to log in, but to have the remote user appear to have the UID corresponding to GUEST or DEMO or some other publicly known login name. Generally such names have little authority and can only access files that have been designated as readable or writable by all users. A better approach is to have the operat ing system provide a mapping between UIDs, so that when a user with UID 12 on his or her home machine accesses a remote machine on which his or her UID is 15, the remote machine treats all accesses as though they were done by user 15. This approach implies that sufficient tables are provided to map each user from his or her home machine, UID pair to the appropri ate UID for any other machine and that messages cannot be tampered with. In a true distributed system there should be a unique UID for every user, and that UID should be valid on all machines with out any mapping. In this way no protection problems arise on remote accesses to files as far as protection goes, a remote access can be treated like a local access with the same UID. The protection issue makes the difference between a network operating system and a distributed one clear In one case there are various machines, each with its own usertoUID mapping, and in the other there is a single, systemwide mapping that is valid everywhere. r 9 t u v w x Y 2 Figure 1. A virtual superdirectory above the root directory provides access to remote files. replicated copies of files if it so chooses. When the user or program must specify the machine name, the system cannot decide on its own to move a file to a new machine because that would change the user visi ble name used to access the file. Thus in a network operating system, control over file placement must be done manually by the users, whereas in a distributed operating system it can be done automatically by the system itself. 1.2 Protection Closely related to the transparency of the file system is the issue of protection. UNIX and many other operating systems assign a unique internal identifier to each user. Each file in the file system has a little table associated with it called an inode in UNIX telling who the owner is, where the disk blocks are located, etc. If two previ ously independent machines are now con nected, it may turn out that some internal User IDentifier UID, for example, num ber 12, has been assigned to a different user on each machine. Consequently, when user 12 tries to access a remote file, the remote file system cannot see whether the access is permitted since two different users have the same UID. One solution to this problem is to require all remote users wanting to access files on machine X to first log onto X using a user name that is local to X. When used this 1.3 Execution Location Program execution is the third area in which machine boundaries are visible in network operating systems. When a user or a running program wants to create a new process, where is the process created At least four schemes have been used thus far. The first of these is that the user simply Computing Surveys, Vol. 17, No. 4, December 1985 424 l A. S. Tanenbaum and R. van Renesse says CREATE PROCESS in one way or another, and specifies nothing about where. Depending on the implementation, this can be the best or the worst way to do it. In the most distributed case, the system chooses a CPU by looking at the load, location of files to be used, etc. In the least distributed case, the system always runs the process on one specific machine usually the machine on which the user is logged in. The second approach to process location is to allow users to run jobs on any machine by first logging in there. In this model, processes on different machines cannot communicate or exchange data, but a sim ple manual load balancing is possible. The third approach is a special command that the user types at a terminal to cause a program to be executed on a specific ma chine. A typical command might be remote vax4 who to run the who program on machine vax4. In this arrangement, the environment of the new process is the remote machine. In other words, if that process tries to read or write files from its current working direc tory, it will discover that its working direc tory is on the remote machine, and that files that were in the parent processs di rectory are no longer present. Similarly, files written in the working directory will appear on the remote machine, not the local one. The fourth approach is to provide the CREATE PROCESS system call with a parameter specifying where to run the new process, possibly with a new system call for specifying the default site. As with the pre vious method, the environment will gener ally be the remote machine. In many cases, signals and other forms of interprocess communication between processes do not work properly among processes on different machines. A final point about the difference be tween network and distributed operating systems is how they are implemented. A common way to realize a network operating system is to put a layer of software on top of the native operating systems of the in dividual machines e.g., Mamrak et al. 1982. For example, one could write a special library package that would intercept Computing Surveys, Vol. 17, No. 4, December 1985 all the system calls and decide whether each one was local or remote Brownbridge et al. 19821. Although most system calls can be handled this way without modifying the kernel, invariably there are a few things, such as interprocess signals, interrupt char acters e.g., BREAK from the keyboard, etc., that are hard to get right. In a true distributed operating system one would normally write the kernel from scratch. 1.4 An Example The Sun Network File System To provide a contrast with the true distrib uted systems described later in this paper, in this section we look briefly at a network operating system that runs on the Sun Microsystems workstations. These work stations are intended for use as personal computers. Each one has a 68000 series CPU, local memory, and a large bit mapped display. Workstations can be configured with or without local disk, as desired. All the workstations run a ver sion of 4.2BSD UNIX specially modified for networking. This arrangement is a classic example of a network operating system Each com puter runs a traditional operating system, UNIX, and each has its own users, but with extra features added to make network ing more convenient. During its evolution the Sun system has gone through three distinct versions, which we now describe. In the first version each of the work stations was completely independent from all the others, except that a program rep was provided to copy files from one work station to another. By typing a command such as rep Mlusrjimfile.c M2usrastf.c it was possible to transfer whole files from one machine to another. In the second version, Network Disk ND, a network disk server was provided to support diskless workstations. Disk space on the disk servers machine was divided into disjoint partitions, with each partition acting as the virtual disk for some diskless workstation. Whenever a diskless workstation needed to read a file, the request was processed locallv until it not down to the level of the device driver, it which point the block needed was retrieved by sending a message to the remote disk server. In effect, the network was merely being used to simulate a disk controller. With this network disk system, sharing of disk partitions was not possible. The third version, the Network File Sys tem NFS, allows remote directories to be mounted in the local file tree on any work station. By mounting, say, a remote direc tory dot on the empty local directory usrdoc, all subsequent references to usrdoc are automatically routed to the remote system. Sharing is allowed in NFS, so several users can read files on a remote machine at the same time. To prevent users from reading other peo ples private files, a directory can only be mounted remotely if it is explicitly exported by the workstation it is located on. A direc tory is exported by entering a line for it in a file etcexports. To improve perform ance of remote access, both the client ma chine and server machine do block caching. Remote services can be located using a Yellow Pages server that maps service names onto their network locations. The NFS is implemented by splitting the operating system up into three layers. The top layer handles directories, and maps each path name onto a generalized inode called a unode consisting of a machine, inode pair, making each vnode globally unique. Vnode numbers are presented to the mid dle layer, the virtual file system VFS. This layer checks to see if a requested vnode is local or not. If it is local, it calls the local disk driver or, in the case of an ND partition, sends a message to the re mote disk server. If it is remote, the VFS calls the bottom layer with a request to process it remotely. The bottom layer accepts requests for accesses to remote vnodes and sends them over the network to the bottom layer on the serving machine. From there they prop agate upward through the VFS layer to the top layer, where they are reinjected into the VFS layer. The VFS layer sees a request for a local vnode and processes it normally, without realizing that the top layer is ac Distributed Operating Systems l 425 tually working on behalf of a remote kernel. The reply retraces the same path in the other direction. The protocol between workstations has been carefully designed to be robust in the face of network and server crashes. Each request completely identifies the file by its vnode, the position in the file, and the byte count. Between requests, the server does not maintain any state information about which files are open or where the current file position is. Thus, if a server crashes and is rebooted, there is no state informa tion that will be lost. The ND and NFS facilities are quite different and can both be used on the same workstation without conflict. ND works at a low level and just handles remote block IO without regard to the structure of the information on the disk. NFS works at a much higher level and effectively takes re quests appearing at the top of the operating system on the client machine and gets them over to the top of the operating system on the server machine, where they are pro cessed in the same way as local requests. 2. DESIGN ISSUES Now we turn from traditional computer systems with some networking facilities added on to systems designed with the intention of being distributed. In this sec tion we look at five issues that distributed systems designers are faced with l communication primitives, l naming and protection, l resource management, 0 fault tolerance, l services to provide. Although no list could possibly be exhaus tive at this early stage of development, these topics should provide a reasonable impression of the areas in which current research is proceeding. 2.1 Communication Primitives The computers forming a distributed sys tem normally do not share primary mem ory, and so communication via shared memory techniques such as semaphores and monitors is generally not applicable. Computing Surveys, Vol. 17, No. 4, December 1985 426 . A. S. Tanenbaum and R. van Renesse Instead, message passing in one form or another is used. One widely discussed framework for messagepassing systems is the IS0 OS1 reference model, which has seven layers, each performing a well defined function Zimmermann 19801. The seven layers are the physical layer, data link layer, network layer, transport layer, session layer, presentation layer, and ap plication layer. By using this model it is possible to connect computers with widely different operating systems, character codes, and ways of viewing the world. Unfortunately, the overhead created by all these layers is substantial. In a distrib uted system consisting primarily of huge mainframes from different manufacturers, connected by slow leased lines say, 56 kilobytes per second, the overhead might be tolerable. Plenty of computing capacity would be available for running complex protocols, and the narrow bandwidth means that close coupling between the sys tems would be impossible anyway. On the other hand, in a distributed system consist ing of identical microcomputers connected by a lomegabyteper second or faster local network, the price of the IS0 model is generally too high. Nearly all the experi mental distributed systems discussed in the literature thus far have opted for a differ ent, much simpler model, so we do not mention the IS0 model further in this paper. 2.1.1 Message Passing The model that is favored by researchers in this area is the clientserver model, in which a client process wanting some service e.g., reading some data from a tile sends a message to the server and then waits for a reply message, as shown in Figure 2. In the most naked form the system just pro vides two primitives SEND and RE CEIVE. The SEND primitive specifies the destination and provides a message the RECEIVE primitive tells from whom a message is desired including anyone and provides a buffer where the incoming message is to be stored. No initial setup is required, and no connection is established, hence no tear down is required. Computing Surveys, Vol. 17, No. 4, December 1985 I Client sends request Remage El Server rend8 reply marage Figure 2. Clientserver model of communication. Precisely what semantics these primi tives ought to have has been a subject of much controversy among researchers. Two of the fundamental decisions that must be made are unreliable versus reli able and nonblocking versus blocking prim itives. At one extreme, SEND can put a message out onto the network and wish it good luck. No guarantee of delivery is pro vided, and no automatic retransmission is attempted by the system if the message is lost. At the other extreme, SEND can handle lost messages, retransmissions, and acknowledgments internally, so that when SEND terminates, the program is sure that the message has been received and acknowledged. Blocking versus Nonblocking Primitives. The other choice is between nonblocking and blocking primitives. With nonblocking primitives, SEND returns control to the user program as soon as the message has been queued for subsequent transmission or a copy made. If no copy is made, any changes the program makes to the data before or heaven forbid while they are being sent are made at the programs peril. When the message has been transmitted or copied to a safe place for subsequent transmission, the program is interrupted to inform it that the buffer may be reused. The corresponding RECEIVE primitive signals a willingness to receive a message and provides a buffer for it to be put into. When a message has arrived, the program is informed by interrupt, or it can poll for status continuously or go to sleep until the interrupt arrives. The advantage of these nonblocking primitives is that they provide the maximum flexibility Programs can Distributed Operating Systems l 427 compute and perform message IO in par allel in any way they want. Nonblocking primitives also have a dis advantage They make programming tricky and difficult. Irreproducible, timing dependent programs are painful to write and awful to debug. Consequently, many people advocate sacrificing some flexibility and efficiency by using blocking primitives. A.blocking SEND does not return control to the user until the message has been sent unreliable blocking primitive or until the message has been sent and an acknowledg ment received reliable blocking primitive. Either way, the program may immediately modify the buffer without danger. A block ing RECEIVE does not return control until a message has been placed in the buffer. Reliable and unreliable RECEIVES differ in that the former automatically acknowl edges receipt of a message, whereas the latter does not. It is not reasonable to com bine a reliable SEND with an unreliable RECEIVE, or vice versa so the system designers must make a choice and provide one set or the other. Blocking and non blocking primitives do not conflict, so there is no harm done if the sender uses one and the receiver the other. receiver. Although buffered message pass ing can be implemented in many ways, a typical approach is to provide users with a system call CREATEBUF, which creates a kernel buffer, sometimes called a mailbox, of a userspecified size. To communicate, a sender can now send messages to the receivers mailbox, where they will be buffered until requested by the receiver. Buffering is not only more complex creat ing, destroying, and generally managing the mailboxes, but also raises issues of pro tection, the need for special highpriority interrupt messages, what to do with mail boxes owned by processes that have been killed or died of natural causes, and more. Buffered versus Unbuffered Primitives. Another design decision that must be made is whether or not to buffer messages. The simplest strategy is not to buffer. When a sender has a message for a receiver that has not yet executed a RECEIVE primitive, the sender is blocked until a RECEIVE has been done, at which time the mes sage is copied from sender to receiver. This strategy is sometimes referred to as a rendezvous. A more structured form of communica tion is achieved by distinguishing requests from replies. With this approach, one typ ically has three primitives SENDGET, GETREQUEST, and SENDREPLY. SENDGET is used by clients to send re quests and get replies. It combines a SEND to a server with a RECEIVE to get the servers reply. GETREQUEST is done by servers to acquire messages containing work for them to do. When a server has carried the work out, it sends a reply with SENDREPLY. By thus restricting the message traffic and using reliable, blocking primitives, one can create some order in the chaos. 2.1.2 Remote Procedure Call RPC A slight variation on this theme is to copy the message to an internal buffer on the senders machine, thus providing for a nonblocking version of the same scheme. As long as the sender does not do any more SENDS before the RECEIVE occurs, no problem occurs. A more general solution is to have a buffering mechanism, usually in the oper ating system kernel, which allows senders to have multiple SENDS outstanding, even without any interest on the part of the The next step forward in messagepassing systems is the realization that the model of client sends request and blocks until ser ver sends reply looks very similar to a traditional procedure call from the client to the server. This model has become known in the literature as remote procedure call and has been widely discussed Birrell and Nelson 1984 Nelson 1981 Spector 19821. The idea is to make the semantics of inter machine communication as similar as pos sible to normal procedure calls because the latter is familiar and well understood, and has proved its worth over the years as a tool for dealing with abstraction. It can be viewed as a refinement of the reliable, blocking SENDGET, GETREQUEST, Computing Surveys, Vol. 17, No. 4, December 1985 428 . A. S. Tanenbaum and R. van Renesse SENDREP primitives, with a more user friendly syntax. The remote procedure call can be organ ized as follows. The client calling program makes a normal procedure call, say, px, y on its machine, with the intention of invok ing the remote procedure p on some other machine. A dummy or stub procedure p must be included in the callers address space, or at least be dynamically linked to it upon call. This procedure, which may be automatically generated by the compiler, collects the parameters and packs them into a message in a standard format. It then sends the message to the remote machine using SENDGET and blocks, waiting for an answer see Figure 3. At the remote machine, another stub pro cedure should be waiting for a message using GETREQUEST. When a message comes in, the parameters are unpacked by an inputhandling procedure, which then makes the local call px, y. The remote procedure p is thus called locally, and so its normal assumptions about where to find parameters, the state of the stack, etc., are identical to the case of a purely local call. The only procedures that know that the call is remote are the stubs, which build and send the message on the client side and disassemble and make the call on the server side. The result of the procedure call follows an analogous path in the reverse direction. Remote Procedure Call Design Issues. Although at first glance the remote procedure call model seems clean and sim ple, under the surface there are several problems. One problem concerns parameter and result passing. In most programming languages, parameters can be passed by value or by reference. Passing value param eters over the network is easy the stub just copies them into the message and off they go. Passing reference parameters pointers over the network is not so easy. One needs a unique, systemwide pointer for each ob ject so that it can be remotely accessed. For large objects, such as files, some kind of capability mechanism Dennis and Van Horn 1966 Levy 1984 Pashtan 19821 could be set up, using capabilities as pointers. For small objects, such as integers and Boo Computing Surveys, Vol. 17, No. 4, December 1985 Client Machine Server Machine I Figure 3. Remote procedure call. leans, the amount of overhead and mecha nism needed to create a capability and send it in a protected way is so large that this solution is highly undesirable. Still another problem that must be dealt with is how to represent parameters and results in messages. This representation is greatly complicated when different types of machines are involved in a communication. A floatingpoint number produced on one machine is unlikely to have the same value on a different machine, and even a negative integer will create problems between the ls complement and 2s complement machines. Converting to and from a standard for mat on every message sent and received is an obvious possibility, but it is expensive and wasteful, especially when the sender and receiver do, in fact, use the same inter nal format. If the sender uses its internal format along with an indication of which format it is and lets the receiver do the conversion, every machine must be pre pared to convert from every other format. When a new machine type is introduced, much existing software must be upgraded. Any way it is done, with remote procedure call RPC or with plain messages, it is an unpleasant business. Some of the unpleasantness can be hid den from the user if the remote procedure call mechanism is embedded in a program ming language with strong typing, so that the receiver at least knows how many pa rameters to expect and what types they have. In this respect, a weakly typed lan guage such as C, in which procedures with a variable number of parameters are com mon, is more complicated to deal with. Still another problem with RPC is the issue of clientserver binding. Consider, for example, a system with multiple file ser vers. If a client creates a file on one of the file servers, it is usually desirable that sub Distributed Operating Systems l 429 Client crashes can also cause trouble for servers. Consider, for example, the case of processes A and B communicating via the UNIX pipe model A  B with A the server and B the client. B asks A for data and gets a reply, but unless that reply is acknowl edged somehow, A does not know when it can safely discard data that it may not be able to reproduce. If B crashes, how long should A hold onto the data Hint If the answer is less than infinity, problems will be introduced whenever B is slow in send ing an acknowledgment. Closely related to this is the problem of what happens if a client cannot tell whether or not a server has crashed. Simply waiting until the server is rebooted and trying again sometimes works and sometimes does not. This is a case in which it works Client asks to read block 7 of some file. This is a case in which it does not work Client says transfer a million dollars from one bank account to another. In the former case, it does not matter whether or not the server carried out the request before crashing carrying it out a second time does no harm. In the latter case, one would definitely pre fer the call to be carried out exactly once, no more and no less. Calls that may be repeated without harm like the first ex ample are said to be idempotent. Unfortu nately, it is not always possible to arrange for all calls to have this property. Any call that causes action to occur in the outside world, such as transferring money, printing lines, or opening a valve in an automated chocolate factory just long enough to fill exactly one vat, is likely to cause trouble if performed twice. Spector 1982 and Nelson 1981 have looked at the problem of trying to make sure that remote procedure calls are exe cuted exactly once, and they have devel oped taxonomies for classifying the seman tics of different systems. These vary from systems that offer no guarantee at all zero or more executions, to those that guaran tee at most one execution zero or one, to those that guarantee at least one execution one or more. Getting it right exactly one is probably impossible, because even if the remote ex ecution can be reduced to one instruction sequent writes to that file go to the file server where the file was created. With mailboxes, arranging for this is straight forward. The client simply addresses the WRITE messages to the same mailbox that the CREATE message was sent to. Since each file server has its own mailbox, there is no ambiguity. When RPC is used, the situation is more complicated, since all the client does is put a procedure call such as writeFileDescriptor, BufferAddress, ByteCount in his program. RPC intentionally hides all the details of locating servers from the client, but sometimes, as in this example, the details are important. In some applications, broadcasting and multicasting sending to a set of destina tions, rather than just one is useful. For example, when trying to locate a certain person, process, or service, sometimes the only approach is to broadcast an inquiry message and wait for the replies to come back. RPC does not lend itself well to sending messages to sets of processes and getting answers back from some or all of them. The semantics are completely different. Despite all these disadvantages, RPC re mains an interesting form of communica tion, and much current research is being addressed toward improving it and solving the various problems discussed above. 2.1.3 Error Handling Error handling in distributed systems is radically different from that of centralized systems. In a centralized system, a system crash means that the client, server, and communication channel are all completely destroyed, and no attempt is made to revive them. In a distributed system, matters are more complex. If a client has initiated a remote procedure call with a server that has crashed, the client may just be left hanging forever unless a timeout is built in. However, such a timeout introduces race conditions in the form of clients that time out too quickly, thinking that the server is down, when in fact, it is merely very slow. Computing Surveys, Vol. 17, No. 4, December 1985 430 l A. S. Tanenbaum and R. van Renesse e.g., setting a bit in a device register that opens the chocolate valve, one can never be sure after a crash if the system went down a microsecond before or a micro second after the one critical instruction. Sometimes one can make a guess based on observing external events e.g., looking to see whether the factory floor is covered with a sticky, brown material, but in gen eral there is no way of knowing. Note that the problem of creating stable storage Lampson 19811 is fundamentally different, since remote procedure calls to the stable storage server in that model never cause events external to the computers. 2.1.4 Implementation issues Constructing a system in principle is al ways easier than constructing it in practice. Building a 16node distributed system that has a total computing power about equal to a singlenode system is surprisingly easy. This observation leads to tension between the goals of making it work fast in the normal case and making the semantics rea sonable when something goes wrong. Some experimental systems have put the empha sis on one goal and some on the other, but more research is needed before we have systems that are both fast and graceful in the face of crashes. Some things have been learned from past work, however. Foremost among these is that making message passing efficient is very important. To this end, systems should be designed to minimize copying of data Cheriton 1984a. For example, a re mote procedure call system that first copies each message from the user to the stub, from the stub to the kernel, and finally from the kernel to the network interface board requires three copies on the sending side, and probably three more on the re ceiving side, for a total of six. If the call is to a remote file server to write a 1K block of data to disk, at a copy time of 1 micro second per byte, 6 milliseconds are needed just for copying, which puts an upper limit of 167 calls per second, or a throughput of 167 kilobytes per second. When other sources of overhead are considered e.g., the reply message, the time waiting for access Computing Surveys, Vol. 17, No. 4, December 1985 to the network, transmission time, achiev ing even 80 kilobytes per second will be difficult, if not impossible, no matter how high the network bandwidth or disk speed. Thus it is desirable to avoid copying, but this is not always simple to achieve since without copies, part of a needed message may be swapped or paged out when it is needed. Another point worth making is that there is always a substantial fixed overhead with preparing, sending, and receiving a mes sage, even a short message, such as a re quest to read from a remote file server. The kernel must be invoked, the state of the current process must be saved, the desti nation must be located, various tables must be updated, permission to access the net work must be obtained e.g., wait for the network to become free or wait for the token, and quite a bit of bookkeeping must be done. This fixed overhead argues for making messages as long as possible, to reduce the number of messages. Unfortunately, many current local networks limit physical pack ets to 1K or 2K 4K or 8K would be much better. Of course, if the packets become too long, a highly interactive user may occa sionally be queued behind ten maximum length packets, degrading response time so the optimum size depends on the work load. Virtual Circuits versus Datagrams There is much controversy over whether remote procedure call ought to be built on top of a flowcontrolled, errorcontrolled, virtual circuit mechanism or directly on top of the unreliable, connectionless data gram service. Saltzer et al. 1984 have pointed out that since high reliability can only be achieved by endtoend acknowl edgments at the highest level of protocol, the lower levels need not be 100 percent reliable. The overhead incurred in provid ing a clean virtual circuit upon which to build remote procedure calls or any other messagepassing system, is therefore wasted. This line of thinking argues for building the message system directly on the raw datagram interface. The other side of the coin is that it would be nice for a distributed system to be able Distributed Operating Systems l 431 to encompass heterogeneous computers in different countries with different post, telephone, and telegraph PTT networks and possibly different national alphabets, and that this environment requires com plex multilayered protocol structures. It is our observation that both arguments are valid, but, depending on whether one is trying to forge a collection of small com puters into a virtual uniprocessor or merely access remote data transparently, one or the other will dominate. Even if one opts for building RPC on top of the raw datagram service provided by a local network, there are still a number of protocols open to the implementer. The simplest one is to have every request and reply separately acknowledged. The mes sage sequence for a remote procedure call is then REQUEST, ACK, REPLY, ACK, as shown in Figure 4a. The ACKs are man aged by the kernel without user knowledge. The number of messages can be reduced from four to three by allowing the REPLY to serve as the ACK for the REQUEST, as shown in Figure 4b. However, a problem arises when the REPLY can be delayed for a long time. For example, when a login process makes an RPC to a terminal server requesting characters, it may be hours or days before someone steps up to a terminal and begins typing. In this event, an addi tional message has to be introduced to allow the sending kernel to inquire whether the message has arrived or not. A further step in the same direction is to eliminate the other ACK as well, and let the arrival of the next REQUEST imply an acknowledgment of the previous REPLY see Figure 4. Again, some mechanism is needed to deal with the case that no new REQUEST is forthcoming quickly. One of the great difficulties in imple menting efficient communication is that it is more of a black art than a science. Even straightforward implementations can have unexpected consequences, as the following example from Sventek et al. 1983 shows. Consider a ring containing a circulating token. To transmit, a machine captures and removes the token, puts a message on the network, and then replaces the token, thus allowing the next machine downstream Request Reply Ack Request Ack Reply 4 Request I RePlY Reply Ack b f Request Request 2 RePlY c Figure 4. Remote procedure call a with individual acknowledgments per message, b with the reply as the request acknowledgment, c with no explicit acknowledgments. the opportunity to capture it. In theory, such a network is fair in that each user has equal access to the network and no one user can monopolize it to the detriment of others. In practice, suppose that two users each want to read a long file from a file server. User A sends a request message to the server, and then replaces the token on the network for B to acquire. After As message arrives at the server, it takes a short time for the server to handle the incoming message interrupt and reen able the receiving hardware. Until the re ceiver is reenabled, the server is deaf. Within a microsecond or two of the time A puts the token back on the network, B sees and grabs it, and begins transmitting a request to the unbeknown to B deaf file server. Even if the server reenables halfway through Bs message, the message will be rejected owing to missing header, bad frame format, and checksum error. According to the ring protocol, after sending one mes sage, B must now replace the token, which A captures for a successful transmission. Once again B transmits during the servers deaf period, and so on. Conclusion B gets Computing Surveys, Vol. 17, No. 4, December 1985 432 . A. S. Tanenbaum and R. van Renesse no service at all until A is finished. If A happens to be scanning through the Man hattan telephone book, B may be in for a long wait. This specific problem can be solved by inserting random delays in places to break the synchrony, but our point is that totally unexpected problems like this make it necessary to build and observe real systems to gain insight into the problems. Abstract formulations and simulations are not enough. 2.2 Naming and Protection All operating systems support objects such as files, directories, segments, mailboxes, processes, services, servers, nodes, and IO devices. When a process wants to access one of these objects, it must present some kind of name to the operating system to specify which object it wants to access. In some instances these names are ASCII strings designed for human use in others they are binary numbers used only inter nally. In all cases they have to be managed and protected from misuse. 2.2.1 Naming as Mapping Naming can best be seen as a problem of mapping between two domains. For exam ple, the directory system in UNIX provides a mapping between ASCII path names and inode numbers. When an OPEN system call is made, the kernel converts the name of the file to be opened into its inode number. Internal to the kernel, files are nearly always referred to by inode number, not ASCII string. Just about all operating systems have something similar. In a dis tributed system a separate name server is sometimes used to map userchosen names ASCII strings onto objects in an analo gous way. Another example of naming is the map ping of virtual addresses onto physical ad dresses in a virtual memory system. The paging hardware takes a virtual address as input and yields a physical address as out put for use by the real memory. In some cases naming implies only a single level of mapping, but in other cases it can imply multiple levels. For example, to use some service, a process might first Computing Surveys, Vol. 17, No. 4, December 1985 have to map the service name onto the name of a server process that is prepared to offer the service. As a second step, the server would then be mapped onto the num ber of the CPU on which that process is running. The mapping need not always be unique, for example, if there are multi ple processes prepared to offer the same service. 2.2.2 Name Servers In centralized systems, the problem of nam ing can be effectively handled in a straight forward way. The system maintains a table or database providing the necessary name toobject mappings. The most straightfor ward generalization of this approach to distributed systems is the single name server model. In this model, a server ac cepts names in one domain and maps them onto names in another domain. For exam ple, to locate services in some distributed systems, one sends the service name in ASCII to the name server, and it replies with the node number where that service can be found, or with the process name of the server process, or perhaps with the name of a mailbox to which requests for service can be sent. The name servers da tabase is built up by registering services, processes, etc., that want to be publicly known. File directories can be regarded as a special case of name service. Although this model is often acceptable in a small distributed system located at a single site, in a large system it is undesira ble to have a single centralized component the name server whose demise can bring the whole system to a grinding halt. In addition, if it becomes overloaded, perform ance will degrade. Furthermore, in a geo graphically distributed system that may have nodes in different cities or even coun tries, having a single name server will be inefficient owing to the long delays in ac cessing it. The next approach is to partition the system into domains, each with its own name server. If the system is composed of multiple local networks connected by gate ways and bridges, it seems natural to have one name server per local network. One way to organize such a system is to have a Distributed Operating Systems . Name server 1 looks up abc Name server 2 looks up bc Name server 3 looks up c 433 a X  Y  2  a X El C r Figure 5. Distributing the lookup of abc over three name servers. global naming tree, with files and other objects having names of the form coun trycitynetworkpathname. When such a name is presented to any name server, it can immediately route the request to some name server in the designated country, which then sends it to a name server in the designated city, and so on until it reaches the name server in the network where the object is located, where the mapping can be done. Telephone numbers use such a hier archy, composed of country code, area code, exchange code first three digits of tele phone number in North America, and sub scriber line number. Having multiple name servers does not necessarily require having a single, global naming hierarchy. Another way to organize the name servers is to have each one effec tively maintain a table of, for example, ASCII string, pointer pairs, where the pointer is really a kind of capability for any object or domain in the system. When a name, say abc, is looked up by the local name server, it may well yield a pointer to another domain name server, to which the rest of the name, bc, is sent for further processing see Figure 5. This facility can be used to provide links in the UNIX sense to files or objects whose precise whereabouts is managed by a remote name server. Thus if a file foobar is located in another local network, n, with name server n.s, one can make an entry in the local name servers table for the pair x, n.s and then access xlfoobar as though it were a local object. Any appropriately authorized user or process knowing the name xlfoobar could make its own synonym s and then perform accesses using sxfoobar. Each name server parsing a name that involves multiple name servers just strips off the first component and passes the rest of the name to the name server found by looking up the first component locally. A more extreme way of distributing the name server is to have each machine man age its own names. To look up a name, one broadcasts it on the network. At each ma chine, the incoming request is passed to the local name server, which replies only if it finds a match. Although broadcasting is easiest over a local network such as a ring net or CSMA net e.g., Ethernet, it is also possible over storeandforward packet switching networks such as the ARPANET Dalal 19771. Although the normal use of a name server is to map an ASCII string onto a binary number used internally to the system, such as a process identifier or machine number, once in a while the inverse mapping is also useful. For example, if a machine crashes, upon rebooting it could present its hard wired node number to the name server to ask what it was doing before the crash, that is, ask for the ASCII string corresponding to the service that it is supposed to be offering so that it can figure out what pro gram to reboot. 2.3 Resource Management Resource management in a distributed system differs from that in a centralized system in a fundamental way. Centralized Computing Surveys, Vol. 17, No. 4, December 1985 434 l A. S. Tanenbaum and R. van Renesse systems always have tables that give com plete and uptodate status information about all the resources being managed dis tributed systems do not. For example, the process manager in a traditional centralized operating system normally uses a process table with one entry per potential process. When a new process has to be started, it is simple enough to scan the whole table to see whether a slot is free. A distributed operating system, on the other hand, has a much harder job of finding out whether a processor is free, especially if the system designers have rejected the idea of having any central tables at all, for reasons of reliability. Furthermore, even if there is a central table, recent events on outlying processors may have made some table en tries obsolete without the table manager knowing it. The problem of managing resources without having accurate global state infor mation is very difficult. Relatively little work has been done in this area. In the following sections we look at some work that has been done, including distributed process management and scheduling. 2.3.1 Processor Allocation One of the key resources to be managed in a distributed system is the set of available processors. One approach that has been proposed for keeping tabs on a collection of processors is to organize them in a logical hierarchy independent of the physical structure of the network, as in MICROS Wittie and van Tilborg 19801. This ap proach organizes the machines like people in corporate, military, academic, and other realworld hierarchies. Some of the machines are workers and others are managers. For each group of k workers, one manager machine the department head is as signed the task of keeping track of who is busy and who is idle. If the system is large, there will be an unwieldy number of de partment heads so some machines will function as deans, riding herd on k de partment heads. If there are many deans, they too can be organized hierarchically, with a big cheese keeping tabs on k deans. Computing Surveys, Vol. 17, No. 4, December 1985 This hierarchy can be extended ad infini tum, with the number of levels needed growing logarithmically with the number of workers. Since each processor need only maintain communication with one superior and k subordinates, the information stream is manageable. An obvious question is, What happens when a department head, or worse yet, a big cheese, stops functioning crashes One answer is to promote one of the direct subordinates of the faulty manager to fill in for the boss. The choice of which one can either be made by the subordinates themselves, by the deceaseds peers, or in a more autocratic system, by the sick man agers boss. To avoid having a single vulnerable manager at the top of the tree, one can truncate the tree at the top and have a committee as the ultimate authority. When a member of the ruling committee malfunc tions, the remaining members promote someone one level down as a replacement. Although this scheme is not completely distributed, it is feasible and works well in practice. In particular, the system is self repairing, and can survive occasional crashes of both workers and managers without any longterm effects. In MICROS, the processors are mono programmed, so if a job requiring S pro cesses suddenly appears, the system must allocate S processors for it. Jobs can be created at any level of the hierarchy. The strategy used is for each manager to keep track of approximately how many workers below it are available possibly several levels below it. If it thinks that a sufficient number are available, it reserves some number R of them, where R 2 S, because the estimate of available workers may not be exact and some machines may be down. If the manager receiving the request thinks that it has too few processors avail able, it passes the request upward in the tree to its boss. If the boss cannot handle it either, the request continues propagating upward until it reaches a level that has enough available workers at its disposal. At that point, the manager splits the request into parts and parcels them out among the managers below it, which then do the same Distributed Operating Systems l 435 thing until the wave of scheduling requests hits bottom. At the bottom level, the pro cessors are marked as busy, and the ac tual number of processors allocated is re ported back up the tree. To make this strategy work well, R must be large enough so that the probability is high that enough workers will be found to handle the whole job. Otherwise, the re quest will have to move up one level in the tree and start all over, wasting considerable time and computing power. On the other hand, if R is too large, too many processors will be allocated, wasting computing capac ity until word gets back to the top and they can be released. The whole situation is greatly compli cated by the fact that requests for proces sors can be generated randomly anywhere in the system, so at any instant, multiple requests are likely to be in various stages of the allocation algorithm, potentially giv ing rise to outofdate estimates of available workers, race conditions, deadlocks, and more. In Van Tilborg and Wittie 1981 a mathematical analysis of the problem is given and various other aspects not de scribed here are covered in detail. 2.3.2 Scheduling The hierarchical model provides a general model for resource control but does not provide any specific guidance on how to do scheduling. If each process uses an entire processor i.e., no multiprogramming, and each process is independent of all the oth ers, any process can be assigned to any processor at random. However, if it is com mon that several processes are working to gether and must communicate frequently with each other, as in UNIX pipelines or in cascaded nested remote procedure calls, then it is desirable to make sure that the whole group runs at once. In this sec tion we address that issue. Let us assume that each processor can handle up to N processes. If there are plenty of machines and N is reasonably large, the problem is not finding a free machine i.e., a free slot in some process table, but something more subtle. The basic difficulty can be illustrated by an TiilE slot Machine Machine 0 1 01234567 0 A c 1 0 Q 2 A c 3 4 5 1 0 D A c 0 D a b Figure6. a Two jobs running out of phase with each other. b Scheduling matrix for eight machines, each with six time slots. The Xs indicated allocated slots. example in which processes A and B run on one machine and processes C and D run on another. Each machine is time shared in, say, lOOmillisecond time slices, with A and C running in the even slices, and B and D running in the odd ones, as shown in Figure 6a. Suppose that A sends many mes sages or makes many remote procedure calls to D. During time slice 0, A starts up and immediately calls D, which unfortu nately is not running because it is now Cs turn. After 100 milliseconds, process switching takes place, and D gets As mes sage, carries out the work, and quickly re plies. Because B is now running, it will be another 100 milliseconds before A gets the reply and can proceed. The net result is one message exchange every 200 milliseconds. What is needed is a way to ensure that processes that communicate frequently run simultaneously. Although it is difficult to determine dy namically the interprocess communication patterns, in many cases a group of related processes will be started off together. For example, it is usually a good bet that the filters in a UNIX pipeline will communi cate with each other more than they will with other, previously started processes. Let us assume that processes are created in groups, and that intragroup commu nication is much more prevalent than intergroup communication. Let us further assume that a sufficiently large number of machines are available to handle the largest group, and that each machine is Computing Surveys, Vol. 17, No. 4, December 1985 436 l A. S. Tanenbaum and R. van Renesse multiprogrammed with N process slots N way multiprogramming. Ousterhout  19821 has proposed several algorithms based on the concept of co scheduling, which takes interprocess communication patterns into account while scheduling to ensure that all members of a group run at the same time. The first al gorithm uses a conceptual matrix in which each column is the process table for one machine, as shown in Figure 6b. Thus, col umn 4 consists of all the processes that run on machine 4. Row 3 is the collection of all processes that are in slot 3 of some ma chine, starting with the process in slot 3 of machine 0, then the process in slot 3 of machine 1, and so on. The gist of his idea is to have each processor use a roundrobin scheduling algorithm with all processors first running the process in slot 0 for a fixed period, then all processors running the process in slot 1 for a fixed period, etc. A broadcast message could be used to tell each processor when to do process switching, to keep the time slices synchronized. By putting all the members of a process group in the same slot number, but on different machines, one has the advantage of Nfold parallelism, with a guarantee that all the processes will be run at the same time, to maximize communication through put. Thus in Figure 6b, four processes that must communicate should be put into slot 3, on machines 1, 2, 3, and 4 for optimum performance. This scheduling technique can be combined with the hierarchical model of process management used in MICROS by having each department head maintain the matrix for its workers, assign ing processes to slots in the matrix and broadcasting time signals. Ousterhout also described several varia tions to this basic method to improve per formance. One of these breaks the matrix into rows and concatenates the rows to form one long row. With k machines, any k consecutive slots belong to different ma chines. To allocate a new process group to slots, one lays a window k slots wide over the long row such that the leftmost slot is empty but the slot just outside the left edge of the window is full. If sufficient empty slots are present in the window, the pro Computing Surveys, Vol. 17, No. 4, December 1985 cesses are assigned to the empty slots otherwise the window is slid to the right and the algorithm repeated. Scheduling is done by starting the window at the left edge and moving rightward by about one win dows worth per time slice, taking care not to split groups over windows. Ousterhouts paper discusses these and other methods in more detail and gives some performance results. 2.3.3 Load Balancing The goal of Ousterhouts work is to place processes that work together on different processors, so that they can all run in par allel. Other researchers have tried to do precisely the opposite, namely, to find sub sets of all the processes in the system that are working together, so that closely related groups of processes can be placed on the same machine to reduce interprocess com munication costs Chow and Abraham 1982 Chu et al. 1980 Gylys and Edwards 1976 Lo 1984 Stone 1977,1978 Stone and Bokhari 19781. Yet other researchers have been concerned primarily with load balanc ing, to prevent a situation in which some processors are overloaded while others are empty Barak and Shiloh 1985 Efe 1982 Krueger and Finkel 1983 Stankovic and Sidhu 19841. Of course, the goals of maxi mizing throughput, minimizing response time, and keeping the load uniform are to some extent in conflict, so many of the researchers try to evaluate different com promises and tradeoffs. Each of these different approaches to scheduling makes different assumptions about what is known and what is most important. The people trying to cluster processes to minimize communication costs, for example, assume that any process can run on any machine, that the comput ing needs of each process are known in advance, and that the interprocess com munication traffic between each pair of processes is also known in advance. The people doing load balancing typically make the realistic assumption that nothing about the future behavior of a process is known. The minimizers are generally theorists, whereas the load balancers tend to be Distributed Operating Systems 2 Machine 1 I Machine l 437 2 Machine 1 f Machine 4 b people making real systems who care less about optimality than about devising algo rithms that can actually be used. Let us now briefly look at each of these approaches. GraphTheoretic Models. If the system consists of a fixed number of processes, each with known CPU and memory re quirements, and a known matrix giving the average amount of traffic between each pair of processes, scheduling can be attacked as a graphtheoretic problem. The system can be represented as a graph, with each pro cess a node and each pair of communicating processes connected by an arc labeled with the data rate between them. The problem of allocating all the pro cesses to k processors then reduces to the problem of partitioning the graph into k disjoint subgraphs, such that each subgraph meets certain constraints e.g., total CPU and memory requirements below some limit. Arcs that are entirely within one subgraph represent internal communica tion within a single processor fast, whereas arcs that cut across subgraph boundaries represent communication be tween two processors slow. The idea is to find a partitioning of the graph that meets the constraints and minimizes the network traffic, or some variation of this idea. Figure 7a depicts a graph of interact ing processors with one possible partition ing of the processes between two machines. Figure 7b shows a better partitioning, with less intermachine traffic, assuming that all the arcs are equally weighted. Many papers have been written on this subject, for ex ample, Chow and Abraham 1982, Chow and Kohler 1979, Stone 1977, 19781, Stone and Bokhari 1978, and Lo 1984. The results are somewhat academic, since in real systems virtually none of the as sumptions fixed number of processes with Figure 7. Two ways of statically al locating processes nodes in the graph to machines. Arcs show which pairs of processes communicate. static requirements, known traffic matrix, errorfree processors and communication are ever met. Heuristic Load Balancing. When the goal of the scheduling algorithm is dy namic, heuristic load balancing, rather than finding related clusters, a different ap proach is taken. Here the idea is for each processor to estimate its own load contin ually, for processors to exchange load in formation, and for process creation and migration to utilize this information. Various methods of load estimation are possible. One way is just to measure the number of runnable processes on each CPU periodically and take the average of the last n measurements as the load. Another way Bryant and Finkel19811 is to estimate the residual running times of all the processes and define the load on a processor as the number of CPU seconds that all its pro cesses will need to finish. The residual time can be estimated mostly simply by assum ing it is equal to the CPU time already consumed. Bryant and Finkel also discuss other estimation techniques in which both the number of processes and length of re maining time are important. When round robin scheduling is used, it is better to be competing against one process that needs 100 seconds than against 100 processes that each need 1 second. Once each processor has computed its load, a way is needed for each processor to find out how everyone else is doing. One way is for each processor to just broadcast its load periodically. After receiving a broadcast from a lightly loaded machine, a processor should shed some of its load by giving it to the lightly loaded processor. This algorithm has several problems. First, it requires a broadcast facility, which may not be available. Second, it consumes Computing Surveys, Vol. 17, No. 4, December 1985 438 l A. S. Tanenbaum and R. van Renesse considerable bandwidth for all the here is my load messages. Third, there is a great danger that many processors will try to shed load to the same previously lightly loaded processor at once. A different strategy Barak and Shiloh 1985 Smith 19791 is for each processor periodically to pick another processor pos sibly a neighbor, possibly at random and exchange load information with it. After the exchange, the more heavily loaded pro cessor can send processes to the other one until they are equally loaded. In this model, if 100 processes are suddenly created in an otherwise empty system, after one ex change we will have two machines with 50 processes, and after two exchanges most probably four machines with 25 processes. Processes diffuse around the network like a cloud of gas. Actually migrating running processes is trivial in theory, but close to impossible in practice. The hard part is not moving the code, data, and registers, but moving the environment, such as the current position within all the open files, the current values of any running timers, pointers or file de scriptors for communicating with tape drives or other IO devices, etc. All of these problems relate to moving variables and data structures related to the process that are scattered about inside the operating system. What is feasible in practice is to use the load information to create new processes on lightly loaded machines, in stead of trying to move running processes. If one has adopted the idea of creating new processes only on lightly loaded ma chines, another approach, called bidding, is possible Farber and Larson 1972 Stan kovic and Sidhu 19841. When a process wants some work done, it broadcasts a re quest for bids, telling what it needs e.g., a 68000 CPU, 512K memory, floating point, and a tape drive. Other processors can then bid for the work, telling what their workload is, how much memory they have available, etc. The process making the request then chooses the most suitable machine and creates the process there. If multiple requestforbid messages are outstanding at the same time, a processor accepting a bid may discover that the workload on the bidding machine Computing Surveys, Vol. 17, No. 4, December 1985 is not what it expected because that pro cessor has bid for and won other work in the meantime. 2.3.4 Distributed Deadlock Detection Some theoretical work has been done in the area of detection of deadlocks in distributed systems. How applicable this work may be in practice remains to be seen. Two kinds of potential deadlocks are resource dead locks and communication deadlocks. Re source deadlocks are traditional deadlocks, in which all of some set of processes are blocked waiting for resources held by other blocked processes. For example, if A holds X and B holds Y, and A wants Y and B wants X, a deadlock will result. In principle, this problem is the same in centralized and distributed systems, but it is harder to detect in the latter because there are no centralized tables giving the status of all resources. The problem has mostly been studied in the context of database systems Gligor and Shattuck 1980 Isloor and Marsland 1978 Menasce and Muntz 1979 Obermarck 19821. The other kind of deadlock that can oc cur in a distributed system is a communi cation deadlock. Suppose A is waiting for a message from B and B is waiting for C and C is waiting for A. Then we have a deadlock. Chandy et al. 1983 present an algorithm for detecting but not preventing commu nication deadlocks. Very crudely summa rized, they assume that each process that is blocked waiting for a message knows which process or processes might send the message. When a process logically blocks, they assume that it does not really block but instead sends a query message to each of the processes that might send it a real data message. If one of these processes is blocked, it sends query messages to the processes it is waiting for. If certain mes sages eventually come back to the original process, it can conclude that a deadlock exists. In effect, the algorithm is looking for a knot in a directed graph. 2.4 Fault Tolerance Proponents of distributed systems often claim that such systems can be more relia ble than centralized systems. Actually, there are at least two issues involved here reliability and availability. Reliability has to do with the system not corrupting or losing ones data. Availability has to do with the system being up when it is needed. A system could be highly reliable in the sense that it never loses data, but at the same time be down most of the time and hence hardly usable. However, many people use the term reliability to cover availa bility as well, and we will not make the distinction either in the rest of the paper. Distributed systems are potentially more reliable than a centralized system because if a system only has one instance of some critical component, such as a CPU, disk, or network interface, and that component fails, the system will go down. When there are multiple instances, the system may be able to continue in spite of occasional fail ures. In addition to hardware failures, one can also consider software failures. These are of two types The software failed to meet the formal specification implemen tation error, or the specification does not correctly model what the customer wanted specification error. All work on program verification is aimed at the former, but the latter is also an issue. Distributed systems allow both hardware and software errors to be dealt with, albeit in somewhat different ways. An important distinction should be made between systems that are fault tolerant and those that are fault intolerant. A fault tolerant system is one that can continue functioning perhaps in a degraded form even if something goes wrong. A fault intolerant system collapses as soon as any error occurs. Biological systems are highly fault tolerant if you cut your finger, you probably will not die. If a memory failure garbles l10 of 1 percent of the program code or stack of a running program, the program will almost certainly crash in stantly upon encountering the error. It is sometimes useful to distinguish be tween expected faults and unexpected faults. When the ARPANET was designed, people expected to lose packets from time to time. This particular error was expected and precautions were taken to deal with it. On the other hand, no one expected a mem ory error in one of the packetswitching Distributed Operating Systems Network l 439 Message Message RE2 EEZ Backup process messa e to bo h a Figure 8. Each process has its own backup process. machines to cause that machine to tell the world that it had a delay time of zero to every machine in the network, which re sulted in all network traffic being rerouted to the broken machine. One of the key advantages of distributed systems is that there are enough resources to achieve fault tolerance, at least with respect to expected errors. The system can be made to tolerate both hardware and software errors, although it should be em phasized that in both cases it is the soft ware, not the hardware, that cleans up the mess when an error occurs. In the past few years, two approaches to making distrib uted systems fault tolerant have emerged. They differ radically in orientation, goals, and attitude toward the theologically sen sitive issue of the perfectability of man kind programmers in particular. One approach is based on redundancy and the other is based on the notion of an atomic transaction. Both are described briefly below. 2.4.1 Redundancy Techniques All the redundancy techniques that have emerged take advantage of the existence of multiple processors by duplicating critical processes on two or more machines. A par ticularly simple, but effective, technique is to provide every process with a backup process on a different processor. All pro cesses communicate by message passing. Whenever anyone sends a message to a process, it also sends the same message to the backup process, as shown in Figure 8. The system ensures that neither the pri mary nor the backup can continue running until it has been verified that both have correctly received the message. Thus, if one process crashes because of any hardware fault, the other one can con tinue. Furthermore, the remaining process Computing Surveys, Vol. 17, No. 4, December 1985 440 l A. S. Tanenbaum and R. van Renesse can then clone itself, making a new backup to maintain the fault tolerance in the fu ture. Borg et al. 1983 have described a system using these principles. One disadvantage of duplicating every process is the extra processors required, but another, more subtle problem is that, if processes exchange messages at a high rate, a considerable amount of CPU time may go into keeping the processes synchronized at each message exchange. Powell and Pre sotto 1983 have described a redundant system that puts almost no additional load on the processes being backed up. In their system all messages sent on the network are recorded by a special recorder process see Figure 9. From time to time, each process checkpoints itself onto a remote disk. If a process crashes, recovery is done by sending the most recent checkpoint to an idle processor and telling it to start run ning. The recorder process then spoon feeds it all the messages that the original process received between the checkpoint and the crash. Messages sent by the newly restarted process are discarded. Once the new process has worked its way up to the point of crash, it begins sending and receiving messages normally, without help from the recording process. The beauty of this scheme is that the only additional work that a process must do to become immortal is to checkpoint itself from time to time. In theory, even the checkpoints can be disposed with, if the recorder process has enough disk space to store all the messages sent by all the cur rently running processes. If no checkpoints are made, when a process crashes, the re corder will have to replay the processs whole history. When a process successfully terminates, the recorder no longer has to worry about having to rerun it so all the messages that it received can be safely discarded. For serv ers and other processes that never termi nate, this idea must be varied to avoid repeating individual transactions that have successfully completed. One drawback of this scheme is that it relies on reliable reception of all messages all the time. In practice, local networks are Computing Surveys, Vol. 17, No. 4, December 1985 Message Message  Receiving process Recorder process iEG1l traffic Figure9. A recorder process copies and stores all network traffic without affecting the sender and receiver. very reliable, but they are not perfect. If occasional messages can be lost, the whole scheme becomes much less attractive. Still, one has to be very careful about reliability, especially when the problem is caused by faulty software. Suppose that a processor crashes because of a software bug. Both the schemes discussed above Borg et al. 1983 Powell and Presotto 19831 deal with crashes by allocating a spare processor and restarting the crashed program, possi bly from a checkpoint. Of course the new processor will crash too, leading to the al location of yet another processor and another crash. Manual intervention will eventually be required to figure out what is going on. If the hardware designers could provide a bit somewhere that tells whether a crash was due to hardware or software, it would be very helpful. Both of the above techniques apply only to tolerance of hardware errors. It is also possible, however, to use redundancy in distributed systems to make systems toler ant of software errors. One approach is to structure each program as a collection of modules, each one with a welldefined func tion and a precisely specified interface to the other modules. Instead of writing a module only once, N programmers are asked to program it, yielding N functionally identical modules. During execution, the program runs on N machines in parallel. After each module finishes, the machines compare their re sults and vote on the answer. If a majority of the machines say that the answer is X, then all of them use X as the answer, and all continue in parallel with the next mod ule. In this manner the effects of an occa sional software bug can be voted down. If formal specifications for any of the modules Distributed Operating Systems 441 are available, the answers can also be checked against the specifications to guard against the possibility of accepting an an swer that is clearly wrong. A variation of this idea can be used to improve system performance. Instead of always waiting for all the processes to fin ish, as soon as k of them agree on an answer, those that have not yet finished are told to drop what they are doing, accept the value found by the k processes, and continue with the next module. Some work in this area is discussed by Avizienis and Chen  19771, Avizienis and Kelly  19841, and Anderson and Lee 1981. 2.4.2 Atomic Transactions When multiple users on several machines are concurrently updating a distributed database and one or more machines crash, the potential for chaos is truly impressive. In a certain sense, the current situation is a step backward from the technology of the 1950s when the normal way of updating a database was to have one magnetic tape, called the master file, and one or more tapes with updates e.g., daily sales reports from all of a companys stores. The master tape and updates were brought to the com puter center, which then mounted the mas ter tape and one update tape, and ran the update program to produce a new master tape. This new tape was then used as the master for use with the next update tape. Lampson 1981 has described a way of achieving atomic transactions by building up a hierarchy of abstractions. We sum marize his model below. Real disks can crash during READ and WRITE opera tions in unpredictable ways. Furthermore, even if a disk block is correctly written, there is a small but nonzero probability of it subsequently being corrupted by a newly developed bad spot on the disk sur face. The model assumes that spontaneous block corruptions are sufficiently infre quent that the probability of two such events happening within some predeter mined time T is negligible. To deal with real disks, the system software must be able to tell whether or not a block is valid, for example, by using a checksum. This scheme had the very real advantage that if the update program crashed, one could always fall back on the previous mas ter tape and the update tapes. In other words, an update run could be viewed as either running correctly to completion and producing a new master tape or having no effect at all crash part way through, new tape discarded. Furthermore, update jobs from different sources always ran in some undefined sequential order. It never hap pened that two users would concurrently read a field in a record e.g., 6, each add 1 to the value, and each store a 7 in that field, instead of the first one storing a 7 and the second storing an 8. The first layer of abstraction on top of the real disk is the careful disk, in which every CAREFULWRITE is read back im mediately to verify that it is correct. If the CAREFULWRITE persistently fails, the system marks the block as bad and then intentionally crashes. Since CAREFUL WRITES are verified, CAREFULREADS will always be good, unless a block has gone bad after being written and verified. The next layer of abstraction is stable storage. A stable storage block consists of an ordered pair of careful blocks, which are typically corresponding careful blocks on different drives, to minimize the chance of both being damaged by a hardware failure. The stable storage algorithm guarantees that at least one of the blocks is always valid. The STABLEWRITE primitive first does a CAREFULWRITE on one block of the pair, and then the other. If the first one fails, a crash is forced, as men tioned above, and the second one is left untouched. The property of runtocompletion or do After every crash, and at least once every nothing is called an atomic update. The time period T, a special cleanup process is property of not interleaving two jobs is called serializability. The goal of people working on the atomic transaction ap proach to fault tolerance has been to regain the advantages of the old tape system, without giving up the convenience of databases on disk that can be modified in place, and to be able to do everything in a distributed way. Computing Surveys, Vol. 17, No. 4, December 1985 442 . A. S. Tanenbaum and R. van Renesse run to examine each stable block. If both blocks are good and identical, nothing has to be done. If one is good and one is bad failure during a CAREFUL WRITE, the bad one is replaced by the good one. If both are good but different crash between two CAREFULWRITES, the second is replaced by a copy of the first. This algorithm allows individual disk blocks to be updated atomically and survive infrequent crashes. Stable storage can be used to create sta ble processors Lampson 19811. To make itself crashproof, a CPU must checkpoint itself on stable storage periodically. If it subsequently crashes, it can always restart itself from the last checkpoint. Stable stor age can also be used to create stable moni tors in order to ensure that two concurrent processes never enter the same critical re gion at the same time, even if they are running on different machines. Given a way to implement crashproof processors stable processors and crash proof disks stable storage, it is possible to implement multicomputer atomic transac tions. Before updating any part of the data in place, a stable processor first writes an intentions list to stable storage, providing the new value for each datum to be changed. Then it sets a commit flag to in dicate that the intentions list is complete. The commit flag is set by atomically up dating a special block on stable storage. Finally it begins making all the changes called for in the intentions list. Crashes during this phase have no serious conse quences because the intentions list is stored in stable storage. Furthermore, the actual making of the changes is idempotent, so repeated crashes and restarts during this phase are not harmful. Atomic actions have been implemented in a number of systems see, e.g., Fridrich and Older 1981, 19841, Mitchell and Dion  19821, Brown et al.  19851, Popek et al. 1981, and Reed and Svobodova 1981. 2.5 Services In a distributed system, it is natural for userlevel server processes to provide func tions that have been traditionally provided Computing Surveys, Vol. 17, No. 4, December 1985 by the operating system. This approach leads to a smaller hence more reliable kernel and makes it easier to provide, mod ify, and test new services. In the following sections, we look at some of these services, but first we look at how services and servers can be structured. 2.5.1 Server Structure The simplest way to implement a service is to have one server that has a single, se quential thread of control. The main loop of the server looks something like this while true do begin GetRequest CarryOutRequest SendReply end This approach is simple and easy to under stand, but has the disadvantage that if the server must block while carrying out the request e.g., in order to read a block from a remote disk, no other requests from other users can be started, even if they could have been satisfied immediately. An obvious example is a file server that main tains a large disk block cache, but occasion ally must read from a remote disk. In the time interval in which the server is blocked waiting for the remote disk to reply, it might have been able to service the next ten requests, if they were all for blocks that happened to be in the cache. Instead, the time spent waiting for the remote disk is completely wasted. To eliminate this wasted time and im prove the throughput of the server, the server can maintain a table to keep track of the status of multiple partially completed requests. Whenever a request requires the server to send a message to some other machine and wait for the result, the server stores the status of the partially completed request in the table and goes back to the top of the main loop to get the next message. If the next message happens to be the reply from the other machine, that is fine and it is processed, but if it is a new request for service from a different client, that can Distributed Operating Systems l 443 Message arrives at dispatcher I Shared data Dispatcher passes ,request to worker Figure 10. The dispatcher task waits for requests and passes them on to the worker tasks. also be started, and possibly completed be the dispatcher or some other previously fore the reply for the first request comes in. blocked task can now run. Thus waiting for In this way, the server is never idle if there a remote procedure call to finish only is any work to be done. blocks one task, not the whole server. Although this organization makes better use of the servers CPU, it makes the soft ware much more complicated. Instead of doing nicely nested remote procedure calls to other machines whose services it needs, the server is back to using separate SEND and RECEIVE primitives, which are less structured. The other way of organizing the server is to have each task capable of accepting new requests for work. When a message arrives, the kernel gives it at random to one of the tasks listening to the address or port to which the message was addressed. That task carries the work out by itself, and no dispatcher is needed. One way of achieving both good perfor mance and clean structure is to program the server as a collection of miniprocesses, which we call a cluster of tadas. Tasks share the same code and global data, but each task has its own stack for local variables and registers and, most important, its own program counter. In other words, each task has its own thread of control. Multipro gramming of the tasks can be done either by the operating system kernel or by a run time library within each process. Both of these schemes require some method of locking the shared data to pre vent races. This locking can be achieved explicitly by some kind of LOCK and UNLOCK primitives, or implicitly by hav ing the scheduler not stop any task while it is running. For example, task switching only occurs when a task blocks. With or dinary user programs, such a strategy is undesirable, but with a server whose behavior is well understood, it is not unreasonable. There are two ways of organizing the tasks. The first way is to assign one task the job of dispatcher, as shown in Figure 10. The dispatcher is the only task that accepts new requests for work. After in specting an incoming request, it determines if the work can be done without blocking e.g., if a block to be read is present in the cache. If it can, the dispatcher just carries out the work and sends the reply. If the work requires blocking, the dispatcher passes the work to some other task in the cluster, which can start work on it. When that task blocks, task switching occurs, and 25.2 File Service There is little doubt that the most impor tant service in any distributed system is the file service. Many file services and file serv ers have been designed and implemented, so a certain amount of experience is avail able e.g., Birrell and Needham 1980, Del lar  19821, Dion 1980, Fridrich and Older  19811, Fridrich and Older  19841, Mitchell and Dion  19821, Mullender and Tanen baum 1985, Reed and Svobodova 1981, Satyanarayanan et al. 1985, Schroeder et Computing Surveys, Vol. 17, No. 4, December 1985 444 l A. S. Tanenbaum and R. van Renesse al. 1985, Sturgis et al. 1980, Svobodova 1981, and Swinehart et al. 1979. A survey about file servers can be found in Svobodova  19841. File services can be roughly classified into two kinds, traditional and robust. Traditional file service is offered by nearly all centralized operating systems e.g., the UNIX file system. Files can be opened, read, and rewritten in place. In particular, a program can open a file, seek to the middle of the file, and update blocks of data within the file. The file server implements these updates by simply overwriting the relevant disk blocks. Concurrency control, if there is any, usually involves locking entire tiles before updating them. Robust file service, on the other hand, is aimed at those applications that require extremely high reliability and whose users are prepared to pay a significant penalty in performance to achieve it. These file ser vices generally offer atomic updates and similar features lacking in the traditional file service. In the following paragraphs, we discuss some of the issues relating to traditional file service and file servers and then look at those issues that specifically relate to robust file service and servers. Since robust file service normally includes traditional file service as a subset, the issues covered in the first part also apply. Conceptually, there are three compo nents that a traditional file service nor mally has l disk service, l flat file service, l directory service. The disk service is concerned with reading and writing raw disk blocks without regard to how they are organized. A typical com mand to the disk service is to allocate and write a disk block, and return a capability or address suitably protected so that the block can be read later. The flat file service is concerned with providing its clients with an abstraction consisting of files, each of which is a linear sequence of records, possibly lbyte records as in UNIX or clientdefined records. The operations are reading and writing records, starting at some particular place in the file. Computing Surveys, Vol. 17, No. 4, December 1985 The client need not be concerned with how or where the data in the file are stored. The directory service provides a mecha nism for naming and protecting tiles, so they can be accessed conveniently and safely. The directory service typically pro vides objects called directories that map ASCII names onto the internal identifica tion used by the file service. Design Issues. One important issue in a distributed system is how closely the three components of a traditional file service are integrated. At one extreme, the system can have distinct disk, file, and directory ser vices that run on different machines and only interact via the official interprocess communication mechanism. This approach is the most flexible, because anyone need ing a different kind of file service e.g., a B tree file can use the standard disk server. It is also potentially the least efficient, since it generates considerable interserver traffic. At the other extreme, there are systems in which all three functions are handled by a single program, typically running on a machine to which a disk is attached. With this model, any application that needs a slightly different file naming scheme is forced to start all over making its own private disk server. The gain, however, is increased runtime efficiency, because the disk, file, and directory services do not have to communicate over the network. Another important design issue in dis tributed systems is garbage collection. If the directory and file services are inte grated, it is a straightforward matter to ensure that, whenever a tile is created, it is entered into a directory. If the directory system forms a rooted tree, it is always possible to reach every file from the root directory. However, if the file directory ser vice and file service are distinct, it may be possible to create files and directories that are not reachable from the root directory. In some systems this may be acceptable, but in others unconnected files may be regarded as garbage to be collected by the system. Another approach to the garbage collec tion problem is to forget about rooted trees altogether and permit the system to remove Distributed Operating Systems l 445 model each request is completely selfcon tained file name, file position, etc., so a newly reincarnated server will have no trouble carrying it out. The price paid for this robustness, how ever, is a slightly longer message, since each file request must contain the full file name and position. Furthermore, the virtual circuit model is sometimes less complex in environments in which the network can reorder messages, that is, deliver the second message before the first. Local networks do not have this defect, but some widearea networks and internetworks do. any file that has not been accessed for, say, five years. This approach is intended to deal with the situation of a client creating a temporary file and then crashing before recording its existence anywhere. When the client is rebooted, it creates a new tempo rary file, and the existence of the old one is lost forever unless some kind of timeout mechanism is used. There are a variety of other issues that the designers of a distributed file system must address for example, will the file ser vice be virtualcircuit oriented or stateless In the virtualcircuit approach, the client must do an OPEN on a file before reading it, at which time the file server fetches some information about the file in UNIX terms, the inode into memory, and the client is given some kind of a connection identifier. This identifier is used in subsequent READS and WRITES. In the stateless ap proach each READ request identifies the file and file position in full, so the server need not keep the inode in memory al though most servers will maintain a cache for efficiency reasons. Both virtualcircuit and stateless file servers can be used with the IS0 OS1 and RPC models. When virtual circuits are used for communication, having the file server maintain open files is natural, However, each request message can also be selfcon tained so that the file server need not hold the file open throughout the communica tion session. Similarly, RPC fits well with a stateless file server, but it can also be used with a file server that maintains open files. In the latter case the client does an RPC to the file server to OPEN the file and get back a tile identifier of some kind. Subsequent RPCs can do READ and WRITE opera tions using this file identifier. The difference between these two be comes clear when one considers the effects of a server crash on active clients. If a virtualcircuit server crashes and is then quickly rebooted, it will almost always lose its internal tables. When the next request comes in to read the current block from file identifier 28, it will have no way of knowing what to do. The client will receive an error message, which will generally lead to the client process aborting. In the stateless Protection. Another important issue faced by all file servers is access control who is allowed to read and write which file. In centralized systems, the same problem exists and is solved by using either an ac cess control list or capabilities. With access control lists, each file is associated with a list of users who may access it. The UNIX RWX bits are a simple form of access con trol list that divides all users into three categories owner, group, and others. With capabilities, a user must present a special ticket on each file access proving that he or she has access permission. Capabilities are normally maintained in the kernel to prevent forgery. With a distributed system using remote file servers, both of these approaches have problems. With access control lists the file server has to verify that the user in fact is who he or she claims to be. With capabili ties, how do you prevent users from making them up One way to make access control lists viable is to insist that the client first set up an authenticated virtual circuit with the file server. The authentication may involve a trusted third party as in Birrell et al. 1982, 19841. When remote procedure calls are used, setting up an authenticated ses sion in advance is less attractive. The problem of authentication using RPC is discussed by Birrell  19851. With capabilities, the protection nor mally results from the fact that the kernel can be trusted. With personal computers on a network, how can the file server trust the kernel After all, a user can easily boot up a nonstandard kernel on his or her Computing Surveys, Vol. 17, No. 4, December 1985 446 . A. S. Tanenbaum and R. van Renesse machine. A possible solution is to encrypt the capabilities, as discussed by Mullender and Tanenbaum 1984, 1985, 19861 and Tanenbaum et al. 1986. Performance. Performance is one of the key problems in using remote file servers especially from diskless workstations. Reading a block from a local disk requires a disk access and a small amount of CPU processing. Reading from a remote server has the additional overhead of getting the data across the network. This overhead has two components the actual time to move the bits over the wire including contention resolution time, if any and the CPU time the file server must spend running the pro tocol software. Cheriton and Zwaenepoel  19831 describe measurements of network overhead in the context of the V system. With an 8 megahertz 68000 processor and a lome gabytepersecond Ethernet, they observe that reading a 512byte block from the local machine takes 1.3 milliseconds and from a remote machine 5.7 milliseconds, assuming that the block is in memory and no disk access is needed. They also observe that loading a 64K program from a remote file server takes 255 milliseconds versus 60 mil liseconds locally, when transfers are in 16K units. A tentative conclusion is that access to a remote file server is four times as expensive as to a local one. It is also worth noting that the V designers have gone to great lengths to achieve good performance many other file servers are much slower than Vs. One way to improve the performance of a distributed file system is to have both clients and servers maintain caches of disk blocks and possibly whole files. However, maintaining distributed caches has a num ber of serious problems. The worst of these is, What happens when someone modifies the master copy on the disk Does the file server tell all the machines maintaining caches to purge the modified block or file from their caches by sending them unsolicited messages as in XDFS Sturgis et al. 1980 How does the server even know who has a cache Introducing a complex centralized administration to keep track is probably not the way to go. Computing Surveys, Vol. 17, No. 4, December 1985 Furthermore, even if the server did know, having the server initiate contact with its clients is certainly an unpleasant reversal of the normal clientserver relationship, in which clients make remote procedure calls on servers, but not vice versa. More re search is needed in this area before we have a satisfactory solution. Some results are presented by Schroeder et al. 1985. Reliability. Reliability is another key design issue. The simplest approach is to design the system carefully, use good qual ity disks, and make occasional tape back ups. If a disk ever gets completely wiped out because of hardware failure, all the work done since the last tape backup is lost. Although this mode of operation may seem scary at first, nearly all centralized com puter systems work this way, and with a mean time between failure of 20,000 or more hours for disks these days, it works pretty well in practice. For those applications that demand a higher level of reliability, some distributed systems have a more robust file service, as mentioned at the beginning of this section. The simplest approach is mirrored disks Every WRITE request is carried out in parallel on two disk drives. At every instant the two drives are identical, and either one can take over instantly for the other in the event of failure. A refinement of this approach is to have the file server offer stable storage and atomic transactions, as discussed earlier. Systems offering this facility are described by Brown et al. 1985, Dion 1980, Mitchell and Dion 1982, Needham and Herbert  19821, Reed and Svobodova  19811, Sturgis et al.  19801, and Svobodova 1981. A detailed comparison of a number of file servers offering sophisticated con currency control and atomic update facili ties is given by Svobodova 1984. We just touch on a few of the basic concepts here. At least four different kinds of files can be supported by a file server. Ordinary files consist of a sequence of disk blocks that may be updated in place and that may be destroyed by disk or server crashes. Recoverable files have the property that groups of WRITE commands can be brack eted by BEGIN TRANSACTION and END TRANSACTION, and that a crash or abort midway leaves the file in its origi nal state. Robust files are written on stable storage and contain sufficient redundancy to survive disk crashes generally two disks are used. Finally, multiversion files consist of a sequence of versions, each of which is immutable. Changes are made to a file by creating a new version. Different file servers support various combinations of these. All robust file servers need some mecha nism for handling concurrent updates to a file or group of files. Many of them allow users to lock a file, page, or record to pre vent conflicting writes. Locking introduces the problem of deadlocks, which can be dealt with by using twophase locking Eswaran et al. 19761 or timestamps Reed 19831. When the file system consists of multiple servers working in parallel, it becomes pos sible to enhance reliability by replicating some or all files over multiple servers. Reading also becomes easier because the workload can now be split over two servers, but writing is much harder because multi ple copies must be updated simultaneously, or this effect simulated somehow. One approach is to distribute the data but keep some of the control information semi centralized. In LOCUS Popek et al. 1981 Walker et al. 19831, for example, files can be replicated at many sites, but when a file is opened, the file server at one site examines the OPEN request, the num ber and status of the files copies, and the state of the network. It then chooses one site to carry out the OPEN and the subse quent READS and WRITES. The other sites are brought up to date later. 2.5.3 Print Service Compared with file service, on which a great deal of time and energy has been expended by a large number of people, the other services seem rather meager. Still, it is worth saying at least a little bit about a few of the more interesting ones. Nearly all distributed systems have some kind of print service to which clients can send files, file names, or capabilities for files with instructions to print them on one Distributed Operating Systems l 447 of the available printers, possibly with some text justification or other formatting be forehand. In some cases the whole file is sent to the print server in advance, and the server must buffer it. In other cases only the file name or capability is sent, and the print server reads the file block by block as needed. The latter strategy eliminates the need for buffering read a disk on the  server side but can cause problems if the file is modified after the print command is given but prior to the actual printing. Users generally prefer callbyvalue rather than callbyreference semantics for printers. One way to achieve the callbyvalue semantics is to have a printer spooler server. To print a file, the client process sends the file to the spooler. When the file has been copied to the spoolers directory, an acknowledgment is sent back to the client. The actual print server is then imple mented as a print client. Whenever the print client has nothing to print, it requests another file or block of a file from the print spooler, prints it, and then requests the next one. In this way the print spooler is a server to both the client and the printing device. Printer service is discussed by Janson et al. 1983 and Needham and Herbert 1982. 2.5.4 Process Service Every distributed operating system needs some mechanism for creating new pro cesses. At the lowest level, deep inside the system kernel, there must be a way of cre ating a new process from scratch. One way is to have a FORK call, as UNIX does, but other approaches are also possible. For ex ample, in Amoeba, it is possible to ask the kernel to allocate chunks of memory of given sizes. The caller can then read and write these chunks, loading them with the text, data, and stack segments for a new process. Finally, the caller can give the filledin segments back to the kernel and ask for a new process built up from these pieces. This scheme allows processes to be created remotely or locally, as desired. At a higher level it is frequently useful to have a process server that one can ask Computing Surveys, Vol. 17, NO. 4, December 1985 448 l A. S. Tanenbaum and R. van Renesse whether there is a Pascal, TROFF, or some other service, in the system. If there is, the request is forwarded to the relevant server. If not, it is the job of the process server to build a process somewhere and give it the request. After, say, a very largescale inte gration VLSI design rule checking server has been created and has done its work, it may or may not be a good idea to keep it in the machine where it was created, depend ing on how much work e.g., network traffic is required to load it, and how often it is called. The process server could easily manage a server cache on a least recently used basis, so that servers for common applications are usually preloaded and ready to go. As specialpurpose VLSI pro cessors become available for compilers and other applications, the process server should be given the job of managing them in a way that is transparent to the systems users. 2.55 Terminal Service How the terminals are tied to the system obviously depends to a large extent on the system architecture. If the system consists of a small number of minicomputers, each with a welldefined and stable user popu lation, then each terminal can be hard wired to the computer that its user nor mally logs on to. If, however, the system consists entirely of a pool of processors that are dynamically allocated as needed, it is better to connect all the terminals to one or more terminal servers that serve as concentrators. The terminal servers can also provide such features as local echoing, intraline editing, and window management, if de sired. Furthermore, the terminal server can also hide the idiosyncracies of the various terminals in use by mapping them all onto a standard virtual terminal. In this way the rest of the software deals only with the virtual terminal characteristics and the ter minal server takes care of the mappings to and from all the real terminals. The ter minal server can also be used to support multiple windows per terminal, with each window acting as a virtual terminal. Computing Surveys, Vol. 17, No. 4, December 1985 2.5.6 Mail Service Electronic mail is a popular application of computers these days. Practically every university computer science department in the Western world is on at least one inter national network for sending and receiving electronic mail. When a site consists of only one computer, keeping track of the mail is easy. When a site has dozens of computers spread over multiple local networks, how ever, users often want to be able to read their mail on any machine they happen to be logged on to. This desire gives rise to the need for a machineindependent mail ser vice, rather like a print service that can be accessed systemwide. Almes et al. 1985 discuss how mail is handled in the Eden system. 2.5.7 Time Service There are two ways to organize a time service. In the simplest way, clients can just ask the service what time it is. In the other way, the time service can broadcast the correct time periodically, to keep all the clocks on the other machines in sync. The time server can be equipped with a radio receiver tuned to WWV or some other transmitter that provides the exact time down to the microsecond. Even with these two mechanisms, it is impossible to have all processes exactly synchronized. Consider what happens when a process requests the time of day from the time server. The request message comes in to the server, and a reply is sent back immediately. That reply must propa gate back to the requesting process, cause an interrupt on its machine, have the ker nel started up, and finally have the time recorded somewhere. Each of these steps introduces an unknown, variable delay. On an Ethernet, for example, the amount of time required for the time server to put the reply message onto the network is non deterministic and depends on the number of machines contending for access at that instant. If a large distributed system has only one time server, messages to and from it may have to travel a long distance and pass over storeandforward gateways with Distributed Operating Systems l 449 variable queuing delays. If there are multi nal format to those demanded by the wide ple time servers, they may get out of syn area network carrier. chronization because their crvstals run at slightly different rates. Einsteins special theory of relativity also puts constraints on synchronizing remote clocks. The result of all these problems is that having a single global time is impossible. Distributed algorithms that depend on being able to find a unique global ordering of widely separated events may not work as expected. A number of researchers have tried to find solutions to the various prob lems caused by the lack of global time see, e.g., Jefferson 1985, Lamport 1978, 19841, Marzullo and Owicki 1985, Reed 1983, and Reif and Spirakis 1984. 2.58 Boot Service The boot service has two functions bring ing up the system from scratch when the power is turned on and helping important services survive crashes. In both cases, it is helpful if the boot server has a hardware mechanism for forcing a recalcitrant ma chine to jump to a program in its own read only memory ROM in order to reset it. The ROM program could simply sit in a loop waiting for a message from the boot service. The message would then be loaded into that machines memory and executed as a program. The second function alluded to above is the immortality service. An important service could register with the boot service, which would then poll it periodically to see if it were still functioning. If not, the boot service could initiate measures to patch things up, for example, forcibly reboot it or allocate another processor to take over its work. To provide high reliability, the boot service should itself consist of multiple processors, each of which keeps checking that the others are still working properly. 2.5.9 Gateway Service If the distributed system in question needs to communicate with other systems at re mote sites, it may need a gateway server to convert messages and protocols from inter 3. EXAMPLES OF DISTRIBUTED OPERATING SYSTEMS Having disposed with the principles, it is now time to look at some actual distributed systems that have been constructed as re search projects in universities around the world. Although many such projects are in various stages of development, space limi tations prevent us from describing all of them in detail. Instead of saying a few words about each system, we have chosen to look at four systems that we consider representative. Our selection criteria were as follows. First, we only chose systems that were designed from scratch asdistributed systems systems that gradually evolved by connecting together existing centralized systems or are multiprocessor versions of UNIX were excluded. Second, we only chose systems that have actually been im plemented paper designs did not count. Third, we only chose systems about which a reasonable amount of information was available. Even with these criteria, there were many more systems that could have been discussed. As an aid to the reader interested in pursuing this subject further, we provide here some references to other relevant work Accent Fitzgerald and Rashid 1985 Rashid and Robertson 19811, Argus Liskov 1982,1984 Liskov and Scheifler 1982 Oki et al. 19851, Chorus Zimmermann, et al. 19811, CRYSTAL Dewitt et al. 19841, DEMOS Powell and Miller 19831, Distrib uted UNIX Luderer et al. 19811, HXDP Jensen 19781, LOCUS Popek et al. 1981 Walker et al. 1983 Weinstein et al. 19851, Meglos Gaglianello and Katseff 19851, MICROS Curtis and Wittie 1984 Mohan and Wittie 1985 Wittie and Curtis 1985 Wittie and van Tilborg 19801, RIG Ball et al. 19761, RoscoeArachne Finkel et al. 1979 Solomon and Finkell978,1979, and the work at Xerox Palo Alto Research Cen ter Birrell 1985 Birrell and Nelson 1984 Birrell et al. 1984 Boggs et al. 1980 Brown et al. 1985 Swinehart et al. 19791. Computing Surveys, Vol. 17, No. 4, December 1985 450 l A. S. Tanenbaum and R. van Renesse The systems we examine here are the Cambridge Distributed Computing System, Amoeba, V, and Eden. The discussion of each system follows the list of topics treated above, namely, communication primitives, naming and protection, resource manage ment, fault tolerance, and services. 3.1 The Cambridge Distributed Computing System The Computing Laboratory at the Univer sity of Cambridge has been doing research in networks and distributed systems since the mid1970s, first with the Cambridge ring and later with the Cambridge Distrib uted Computing System Needham and Herbert 19821. The Cambridge ring is not a tokenpassing ring, but rather contains several minipacket slots circulating around the ring. To send a packet, a machine waits until an empty slot passes by, then inserts a minipacket containing the source, desti nation, some flag bits, and 2 bytes of data. Although the 2byte minipackets them selves are occasionally useful e.g., for acknowledgments, several blockoriented protocols have been developed for reliably exchanging 2K packets by accumulating 1024 minipackets. The nominal ring band width is 10 megabytes per second, but since each minipacket has 2 bytes of data and 3 bytes of overhead, the effective bandwidth is 4 megabytes per second. The Cambridge ring project was very suc cessful, with copies of the ring currently in operation at many universities and com panies in the United Kingdom and else where. The availability of the ring led to research on distributed computing systems initially using nine Computer Automation LS14 minicomputers and later using about a dozen Motorola 680008, under the direc tion of Roger Needham. The Cambridge system is primarily com posed of two components the processor bank and the servers. When a user logs in, he or she normally requests one machine from the processor bank, uses it as a per sonal computer for the entire work session, and returns it when logging out. Processors are not normally dynamically allocated for short periods of time. The servers are ded Computing Surveys, Vol. 17, No. 4, December 1985 icated machines that provide various useful services, including file service, name ser vice, boot service, etc. The number and location of these servers is relatively static. 3.7.7 Communication Primitives Owing to the evolution from network to distributed system described earlier, the communication primitives are usually de scribed as network protocols rather than language primitives. The choice of the primitives was closely tuned to the capabil ities of the ring in order to optimize per formance. Nearly all communication is built up from sending packets consisting of a 2byte header, a 2byte process identifier, up to 2048 data bytes, and a 2byte check sum. On top of this basic packet protocol are a simple remote procedure call protocol and a byte stream protocol. The basic packet protocol, which is a pure datagram system, is used by the single shot protocol to build up something similar to a remote procedure call. It consists of having the client send a packet to the server containing the request, and then having the server send a reply. Some machines are multiprogrammed, so that the second minipacket is used to route the incoming packet to the correct process. The request packet itself contains a function code and the parameters, if any. The reply packet contains a status code and the result, if any. Clients do not acknowledge receipt of the result. Some applications, such as terminal han dling and file transfer, work better with a flowcontrolled, virtualcircuit protocol. The byte stream protocol is used for these applications. This protocol is a fullduplex, connectionoriented protocol, with full flow control and error control. 3.1.2 Naming and Protection Services can be located in the Cambridge system by using the name server. To look up a name, the client sends an ASCII string to the name server, which then looks it up in its tables and returns the machine num ber where the service is located, the port used to address it, and the protocol it Distributed Operating Systems l 451 Login Session Class Control MARVIN 1 91432 sTwENl 31513 expects. The name server stores service names as unstructured ASCII strings, which are simply matched against incoming requests character by character that is, it does not manage hierarchical names. The name server itself has a fixed address that never changes, so this address may be embedded into programs. Although the service database is rela tively static, from time to time names must be added or deleted to the name servers database. Commands are provided for this purpose, but for protection reasons these commands may only be executed by the system administrator. Finding the location of a service is only half the work. To use most services, a pro cess must identify itself in an unforge able way, so that the service can check to see whether that user is authorized. This identification is handled by the Active Name Server, which maintains a table of currently loggedin users. Each table entry has four fields the users login name, his or her session key a big random number, the users class e.g., faculty, student, and a control key, as shown in Figure 11. To use a service, a user supplies the ser vice with his login name, session key ob tained at login time, and class. The service can then ask the Active Name Server if such an entry exists. Since session keys are sparse, it is highly unlikely that a student will be able to guess the current session key for the computer center director, and thus be able to obtain services reserved for the director. The control key must be presented to change an entry, thus providing a mech anism to restrict changing the Active Name Servers table to a few people. 3.1.3 Resource Management The main resource managed by the system is the processor bank, handled by a service called the resource manager. Usually a user requests a processor to be allocated at login time, and then loads it with a singleuser operating system. The processor then be comes the users personal computer for the rest of the login session. The resource manager accepts requests to allocate a processor. In these requests l6AR6ARA 1 61300 19lWENl I I 27130AMY 42106 FACLLTY 31616 61346 DIRECmR 41940 Figure 11. The Active name table. the user specifies a CPU type e.g., 68000, a list of attributes e.g., memory size, and a program to be run. The resource manager then selects the most suitable CPU cur rently available for allocation. Various defaults are available, so, for example, a user can specify wanting to run TRIPOS a straightforward singleuser operating system, and the resource manager will se lect an appropriate CPU type if none has been specified. The downloading of programs into pro cessor bank machines is controlled by a server called the ancilla, although some of the machines have intelligent ring inter faces that actually do most of the work. The ancilla also helps simulate the ma chines console and front panel, so that users have the same control over a proces sor bank machine as they would over real personal computers on their desks. 3.1.4 Fault Tolerance The approach taken to fault tolerance in the Cambridge system is to make it easy to bring servers back up after a crash. When a ring interface detects a special minipacket whose source is the name server, it reboots the processor by forcing it to jump to a program in ROM. This program then sends a request to the boot server, which in turn goes to the name server asking for reverse name lookup. The name server then searches its tables to find the service that is running on the machine from which the reverse lookup request came. As soon as the reply comes in, the server knows what it is supposed to be doing and can request the resource manager and ancilla to download the appropriate program. When machines are physically reset or Computing Surveys, Vol. 17, No. 4, December 1985 452 . A. S. Tanenbaum and R. van Renesse Figure 12. The filing machine is posi tioned between the users and the file server. It maintains a block cache and handles ASCII names. Processor bank machines Filing File machine server Block cache Regular files ASCII names Special files Index files powered up, the same procedure is carried out automatically. Another area in which some effort has been put to make the system fault tolerant is the file system, which supports atomic updates on special files. This facility is described in the next section. 3.1.5 Services We have already described several key serv ers, including the name server, resource manager, ancilla, and active name server. Other small servers include the time server, print server, login server, terminal server, and error server, which records system er rors for maintenance purposes. The tile server is examined here. The file system started out with the idea of a single universal file server that pro vided basic storage service but very primi tive naming and protection system, coupled with singleuser TRIPOS operating sys tems in the processor bank machines, in which the naming and directory manage ment would be done. The CAP computer a large research machine within the Cam bridge Computing Laboratory that does not have any disks of its own also uses the file server. After some experience with this model, it was decided to create a new server, known as the filing machine, as a front end to the file system to improve the perform ance mostly by providing the filing ma chine with a large cache, something that the small user machines could not afford. The CAP machine, which has adequate memory, continues to use the file server directly. The position of the filing machine is shown in Figure 12. The universal file server supports one basic file type, with two minor variations. The basic file type is an unstructured file Computing Surveys, Vol. 17, No. 4, December 1985 consisting of a sequence of 16bit words, numbered from 0 to some maximum. Operations are provided for reading or writ ing arbitrary numbers of words, starting anywhere in the file. Each file is uniquely identified by a 64bit PUID Permanent User IDentifier consisting of a 32bit disk address and a 32bit random number. The first variation is the special file, which has the property that writes to it are atomic, that is, they will either succeed completely or not be done at all. They will never be partly completed, even in the face of server crashes. The second variation is a file called an index, which is a special file consisting of a sequence of slots, each holding one PUID. When a file is created, the process creating it must specify an index and slot in that index into which the new files PUID is stored. Since indexes are also files and as such have PUIDs themselves, an index may contain pointers PUIDs to other indices, allowing arbitrary directory trees and graphs to be built. One index is distin guished as being the root index, which has the property that the file servers internal garbage collector will never remove a file reachable from the root index. In the initial implementation, the full code of the TRIPOS operating system was loaded into each pool processor. All of the directory management and handling of ASCII names was done on the processor bank machines. Unfortunately, this scheme had several problems. First, TRIPOS was rather large and filled up so much memory that little room was left for buffers, mean ing that almost every read or write request actually caused a disk access the universal file server has hardly any buffers. Second, looking up a name in the directory hierar chy required all the intermediate directo ries between the starting point and the file to be physically transported from the file server to a machine doing the search. To get around these problems, a filing machine with a large cache was inserted in front of the file server. This improvement allowed programs to request files by name instead of PUID, with the name lookup occurring in the filing machine now. Owing to the large cache, most of the relevant directories are likely to be already present in the filing machine, thus eliminating much network traffic. Furthermore, it al lowed the TRIPOS code in the user ma chines to be considerably stripped, since the directory management was no longer needed. It also allowed the file server to read and write in large blocks this was previously possible, but rarely done because of lack of buffer space on the user side. The resulting improvements were substantial. 3.1.6 Implementation As should be clear by now, the whole Cam bridge system is a highly pragmatic design, which from its inception Wilkes and Need ham 19801 was designed to be actually used by a substantial user community. About 90 machines are connected by three rings now, and the system is fairly stable. A related research project was the connection of a number of Cambridge rings via a satellite Adams et al. 19821. Future research may include interconnection of multiple Cambridge rings using veryhighspeed 2megabitpersecond lines. 3.2 Amoeba Amoeba is a research project on distributed operating systems being carried out at the Vrije Universiteit in Amsterdam under the direction of Andrew Tanenbaum. Its goal is to investigate capabilitybased, object oriented systems and to build a working prototype system to use and evaluate. It currently runs on a collection of 24 Moto rola 68010 computers connected by a lomegabytespersecond local network. The Amoeba architecture consists of four principal components, as shown in Figure 13. First are the workstations, one per user, Distributed Operating Systems l 453 Processor pool Workstations Specialized servers file. data base, etc Figure 13. The Amoeba architecture. on which users can carry out editing and other tasks that require fast interactive re sponse. Second are the pool processors, a group of CPUs that can be dynamically allocated as needed, used, and then re turned to the pool. For example, the make command might need to do six compila tions so six processors could be taken out of the pool for the time necessary to do the compilation and then returned. Alterna tively, with a fivepass compiler, 5 X 6  30 processors could be allocated for the six compilations, gaining even more speedup. Third are the specialized servers, such as directory, file, and block servers, database servers, bank servers, boot servers, and var ious other servers with specialized func tions. Fourth are the gateways, which are used to link Amoeba systems at different sites and, eventually, different countries into a single, uniform system. All the Amoeba machines run the same kernel, which primarily provides message passing services and little else. The basic idea behind the kernel was to keep it small, not only to enhance its reliability, but also to allow as much as possible of the operat ing system to run as user processes, provid ing for flexibility and experimentation. Some of the research issues addressed by the project are how to put as much of the operating system as possible into user pro cesses, how to use the processor pool, how to integrate the workstations and pro cessor pool, and how to connect multiple Amoeba sites into a single coherent system using widearea networks. All of these issues use objects and capabilities in a uniform way. Computing Surveys, Vol. 17, No. 4, December 1985 454 l A. S. Tanenbaum and R. van Renesse 3.2.1 Communication Primitives The conceptual model for Amoeba com munication is the abstract data type or object model, in which clients perform op erations on objects in a locationindepen dent manner. To implement this model, Amoeba uses a minimal remote procedure call model for communication between clients and servers. The basic client primi tive is to send a message of up to about 32 kilobytes to a server and then block waiting for the result. Servers use GETRE QUEST and PUTREPLY to get new work and send back the results, respec tively. These primitives are not embedded in a language environment with automatic stub generation. They are implemented as small library routines that are used to in voke the kernel directly from C programs. All the primitives are reliable in the sense that detection and retransmission of lost messages, acknowledgment processing, and messagetopacket and packettomessage management are all done transparently by the kernel. Messages are unbuffered. If a message arrives and no one is expecting it, the message is simply discarded. The send ing kernel then times out and tries again. Users can specify how long the kernel should retransmit before giving up and re porting failure. The idea behind this strat egy is that server processes are generally cloned in Nfold, so normally there will be a server waiting. Since a message is dis carded only if the system is badly over loaded, having the client time out and try again later is not a bad idea. Although the basic message primitives are blocking, special provision is made for handling emergency messages. For exam ple, if a database server is currently blocked waiting for a tile server to get some data for it, and a user at a terminal hits the BREAK key indicating that he or she wants to kill off the whole request, some way is needed to gracefully abort all the processes working on behalf of that request. In the Amoeba system the terminal server generates and sends a special EX CEPTION message, which causes an inter rupt at the receiving process. This message forces the receiver to stop working on the request and send an Computing Surveys, Vol. 17, No. 4, December 1985 immediate reply with a status code of REQUEST ABORTED. If the receiver was also blocked waiting for a server, the excep tion is recursively propagated all the way down the line, forcing each server in turn to finish immediately. In this manner, all the nested processes terminate normally with error status, so that little violence is done to the nesting structure. In effect, an EXCEPTION message does not terminate execution. Instead, it just says Force nor mal termination immediately, even if you are not done yet, and return an error status. 3.2.2 Naming and Protection All naming and protection issues in Amoeba are dealt with by a single, uniform mechanism sparse capabilities Tanen baum et al. 19861. The system supports objects such as directories, files, disk blocks, processes, bank accounts, and de vices, but not small objects such as integers. Each object is owned by some service and managed by the corresponding server pro cesses. When an object is created, the process requesting its creation is given a capability for it. Using this capability, a process can carry out operations on the object, such as reading or writing the blocks of a file, or starting or stopping a process. The number and types of operations applicable to an object are determined by the service that created the object a bit map in the capa bility tells which of those the holder of the capability is permitted to use. Thus the whole of Amoeba is based on the conceptual model of abstract data types managed by services, as mentioned above. Users view the Amoeba environment as a collection of objects, named by capabilities, on which they can perform operations. This is in contrast to systems in which the user view is a collection of processes connected by virtual circuits. Each object has a globally unique name contained in its capabilities. Capabilities are managed entirely by user processes they are protected cryptographically, not by any kernelmaintained tables or mech anisms. A capability has four fields, as Distributed Operating Systems l 455 directory server with a capability for a di rectory itself an object and an ASCII string and ask for the capability that cor responds to that string in the given direc tory. Other operations are entering and deleting ASCII string, capability pairs. This naming scheme is flexible in that a directory may contain capabilities for an arbitrary mixture of object types and loca tions, but it is also uniform in that every object is controlled by a capability. A direc tory entry may, of course, be for another directory, and so it is simple to build up a hierarchical e.g., UNIXlike directory tree, or even more general naming graphs. Furthermore, a directory may also contain a capability for a directory managed by a different directory service. As long as all the directory services have the same inter faces with the user, one can distribute ob jects over directory services in an arbitrary way. 3.2.3 Resource Management Resource management in Amoeba is per formed in a distributed way, again using capabilities. Each Amoeba machine pool processor, work station, etc. runs a re source manager process that controls that machine. This process actually runs inside the kernel for efficiency reasons, but it uses the normal abstract data type interface with its clients. The key operations it sup ports are CREATE SEGMENT, WRITE SEGMENT, READ SEGMENT, and MAKE PROCESS. To create a new pro cess, a process would normally execute CREATE SEGMENT three times for the child processs text, data, and stack segments, getting back one capability for each segment. Then it would fill each one in with that segments initial data and finally perform MAKE PROCESS with these capabilities as parameters, getting back a capability for the new process. Using the above primitives, it is easy to build a set of processes that share text andor data segments. This facility is useful for constructing servers that consist inter nally of multiple miniprocesses tasks that share text and data. Each of these processes has its own stack and, most important, its own program counter, so that when one of 40 24 0 48 Service port Object Rts Check Figure 14. An Amoeba capability. shown in Figure 14 The service port a sparse address cor responding to the service that owns the object, such as a file or directory service. The object number an internal identi fier that the service uses to tell which of its objects this is comparable to the inumber in UNIX. The rights field a bit map telling which operations on the object are permitted. The check field a large random number used to authenticate the capability. When a server is asked to create an ob ject, it picks an available slot in its internal tables e.g., a free inode, in UNIX termi nology, puts the information about the new object there, and picks a new random number to be used exclusively to protect this new object. Each server is free to use any protection scheme that it wants to, but the normal one is for it to build a capability containing its port, the object number, the rights initially all present, and a known constant. The two latter fields are then thoroughly mixed by encrypting them with the random number as key, which is then stored in the internal table. Later, when a process performs an oper ation on the object, a message containing the objects capability is sent to the server. The server uses the plaintext object num ber to find the relevant internal table entry and extract the random number, which is then used to decrypt the rights and check fields. If the decryption yields the correct known constant, the rights field is believed and the server can easily check whether the requested operation is permitted. More de tails about protection of capabilities can be found in Mullender and Tanenbaum  1984, 19861 and Tanenbaum et al. 1986. Capabilities can be stored in directories managed by the directory service. A direc tory is effectively a set of ASCII string, capability pairs. The most common direc tory operation is for a user to present the Computing Surveys, Vol. 17, No. 4, December 1985 456 . A. S. Tanenbaum and R. van Renesse them blocks on a remote procedure call, the others are not affected. For example, the file server might consist of 10 processes sharing a disk cache, all of which start out by doing a GETREQUEST. When a mes sage comes in, the kernel sees that ten processes are all listening to the port spec ified in the message so it picks one process at random and gives it the message. This process then performs the requested oper ation, possibly blocking on remote proce dure calls e.g., calling the disk while doing so, but leaving the other server processes free to accept and handle new requests. At a higher level the processor pool is managed by a process server that keeps track of which processors are free and which are not. If an installation wants to multiprogram the processor pool machines, then the process server manages each proc ess table slot on a pool processor as a virtual processor. One of the interesting research issues here is the interplay between the workstations and the processor pool that is When should a process be started up on the workstation and when should it be off loaded to a pool processor Research has not yet yielded any definitive answers here, although it seems intuitively clear that highly interactive processes, such as screen editors, should be local to the workstation, and batchlike jobs, such as big compila tions e.g., UNIX make, should be run elsewhere. The bank server provides a basic mech anism on top of which many interesting policies can be implemented. For example If some resource is in short supply, are servers allowed to raise the price as a ra tioning mechanism Do you get your money back when you release disk space That is Is the model one of clients and servers buying and selling blocks, or is it like renting something If it is like renting, there will be a flow of money from users to the various servers, and so users need in comes to keep them going, rather than sim ply initial fixed budgets. When new users are added, virtual money has to be created for them. Does this lead to inflation The possibilities here are legion. 3.2.4 Fault Tolerance The basic idea behind fault tolerance in Amoeba is that machine crashes are infre quent, and that most users are not willing to pay a penalty in performance in order to make all crashes 100 percent transparent. Instead, Amoeba provides a boot service, with which servers can register. The boot service polls each registered server at agreed upon intervals. If the server does not reply properly within a specified time, the boot service declares the server to be broken and requests the process server to start up a new copy of the server on one of the pool processors. Accounting. Amoeba provides a general To understand how this strategy affects mechanism for resource management and clients, it is important to realize that accounting in the form of the bank server, Amoeba does not have any notion of a which manages bank account objects. virtual circuit or a session. Each remote Bank accounts hold virtual money, possibly procedure call is completely selfcontained in multiple currencies. The principal oper and does not depend on any previous setup ation on bank account objects is transfer that is, it does not depend on any volatile ring virtual money between accounts. For information stored in servers memories. If example, to pay for file storage, a file server a server crashes before sending a reply, the might insist on payment in advance of X kernel on the client side will time out and dollars per megabyte of storage, and a pho try again. When the new server comes up, totypesetter server might want a payment the clients kernel will discover this and in advance of Y yen per page. The system send the request there, without the client management can decide whether or not dol even knowing that anything has happened. lars and zlotys are convertible, depending Of course, this approach does not always on whether or not it wants users to have work, for example, if the request is not separate quotas on disk space and typeset idempotent the chocolate factory or if a ter pages, or just give each user a single sick disk head has just mechanically budget to use as he or she sees fit. scraped all the bits from some disk surface, Computing Surveys, Vol. 17, No. 4, December 1985 Distributed Operating Systems l 457 but it works much of the time and has zero overhead under normal conditions. 3.2.5 Services Amoeba has several kinds of block, file, and directory services. The simplest one is a server running on top of the Amoeba kernel that provides a file service functionally equivalent to the UNIX system call inter face, to allow most UNIX programs to run on Amoeba with only the need to relink them with a special library. A more interesting server, however, is FUSS Free University Storage System, which views each file as a sequence of versions. A process can acquire a capability for a private copy of a new version, modify it, and then commit it in a single indivisible atomic action. Providing atomic commits at the file level rather than only as a facility in some database systems simpli fies the construction of various servers, such as the bank server, that have to be highly robust. FUSS also supports multiple, simultaneous access using optimistic con currency control. It is described in greater detail by Mullender and Tanenbaum 1985. Other key services are the directory ser vice, bank service, and boot service, all of which have already been discussed. 3.2.6 Implementation The Amoeba kernel has been ported to five different CPUs 68010, NS32016, 8088, VAX, and PDP11. All the servers de scribed above, except the boot server, have been written and tested, along with a num ber of others. Measurements have shown that a remote procedure call from user space on one 68010 to user space on a different 68010 takes just over 8 millisec onds plus the time to actually carry out the service requested. The data rate be tween user processes on different machines has been clocked at over 250,000 bytes per second, which is about 20 percent of the raw network bandwidth, an exceptionally high value. A library has been written to allow UNIX programs to run on Amoeba. A substantial number of utilities, including compilers, ed itors, and shells, are operational. A server has also been implemented on UNIX to allow Amoeba programs to put capabilities for UNIX files into their directories and use them without having to know that the files are actually located on a VAX running UNIX. In addition to the UNIX emulation work, various applications have been im plemented using pure Amoeba, including parallel traveling salesman and parallel alphabeta search Bal et al. 19851. Current research includes connecting Amoeba sys tems at five locations in three countries using widearea networks. 3.3 The V Kernel The V kernel is a research project on dis tributed systems at Stanford University under the direction of David Cheriton Cheriton 1984a Cheriton and Mann 1984 Cheriton and Zwaenepoel 1984a, 1984131. It was motivated by the increasing avail ability of powerful microcomputerbased workstations, which can be seen as an alternative to traditional timeshared mini computers. The V kernel is an outgrowth of the experience acquired with earlier sys tems, Thoth Cheriton 1982 Cheriton et al. 19791 and Verex. The V kernel can be thought of as a software back plane, analogous to the Multibus or S100 bus back planes. The function of a back plane is to provide an infrastructure for components for hard ware, boards for software, processes to communicate, and nothing else. Conse quently, most of the facilities found in tra ditional operating systems, such as a file system, resource management, and protec tion, are provided in V by servers outside the kernel. In this respect V and Amoeba are conceptually very similar. Another point on which V and Amoeba agree is the freemarket model of services. Services such as the file system are, in principle, just ordinary user processes. Any user who is dissatisfied with the standard file system Stonebraker 1981 Tanenbaum and Mullender 19821 is free to write his or her own. This view is in contrast to the centrally planned economy model of most Computing Surveys, Vol. 17, No. 4, December 1985 458 l A. S. Tanenbaum and R. van Renesse Work Work station station Network I  I I I I I File File Rint server server server Figure 15. A typical V configuration. timesharing systems, which present the file system on a like it or lump it basis. The V system consists of a collection of workstations currently SUNS, each run ning an identical copy of the V kernel. The kernel consists of three components the interprocess communication handler, the kernel server for providing basic services, such as memory management, and the de vice server for providing uniform access to IO devices. Some of the workstations support an interactive user, whereas others function as file servers, print servers, and other kinds of servers, as shown in Figure 15. Unlike Amoeba, V does not have a processor pool. 3.3.1 Communication Primitives The V communication primitives have been designed in accordance with the backplane model mentioned above. They provide basic, but fast communication. To access a server, a client does SENDmessage, pid, which transmits the fixedlength 32byte message to the server, and then blocks until the server has sent back a reply, which overwrites message. The second param eter, pid, is a 32bit integer that uniquely identifies the destination process. A mes sage may contain a kind of pseudopointer to one of the clients memory segments. This pseudopointer can be used to permit the server to read from or write to the clients memory. Such reads and writes are handled by kernel primitives COPYFROM and COPYTO. As an optimization, when a client does a SEND containing one of these pseudopointers with READ permission, the first 1K of the segment is piggybacked onto the message, on the assumption that the server will probably want to read it even Computing Surveys, Vol. 17, No. 4, December 1985 tually. In this way, messages longer than 32 bytes can be achieved. Servers use the RECEIVE and REPLY calls. The RECEIVE call can provide a segment buffer in addition to the regular message buffer, so that if part of a seg ment has been piggybacked onto the mes sage, it will have a place to go. The REPLY call can also provide a segment buffer for the case in which the client provides a pseudopointer that the server can use to return results exceeding 32 bytes. To make this communication system eas ier to use, calls to servers can be embedded in stubs so that the caller just sees an ordinary procedure call. Stub generation is not automated, however. 3.3.2 Naming and Protection V has three levels of naming. At the bottom level, each process has a unique 32bit pid, which is the address used to send messages to it. At the next level, services i.e., pro cesses that carry out requests for clients can have symbolic ASCII string names in addition to their pids. A service can register a symbolic name with its kernel so that clients can use the symbolic name instead of the pid. When a client wants to access a service by its name, the clients kernel broadcasts a query to all the other kernels, to see where the server is. The Server Name, pid pair is then put in a cache for future use. The top level of naming makes it possible to assign symbolic names to objects, such as files. Symbolic names are always inter preted in some context, analogous to looking up a file name in some directory in other systems. A context is a set of records, each including the symbolic name, servers pid, context number, and object identifier. Each server manages its own contexts there is no centralized name server. A symbolic name is looked up in a context by searching all the records in that context for one whose name matches the given name. When a match is found, the context num ber and object identifier can be sent to the appropriate server to have some operation carried out. Names may be hierarchical, as in ubc. When a is looked up in some context, the result will probably be a new context, pos sibly managed by a new server on a differ ent machine. In that case the remaining string, bc is passed on to that new server for further lookup, and so on. It is also possible to prefix a symbolic name with an explicit context, as in HomeDirectory abc, in which case the name is looked up in the context specified, rather than in the current context analo gous to the current working directory in other systems. A question that quickly arises is, Who keeps track of the various context names, such as HomeDirectory above The answer is that each worksta tion in the system has a Context Prefix Server, whose function is to map context names onto server names, so that the ap propriate server can be found to interpret the name itself. 3.3.3 Resource Management Each processor in V has a dedicated func tion, either as a user workstation or a file, print, or other dedicated server so no form of dynamic processor allocation is provided. The key resources to be managed are pro cesses, memory, and the IO devices. Process and memory management is pro vided by the kernel server. IO manage ment is provided by the device server. Both of these are part of the kernel present on each machine, and are accessed via the standard message mechanism described above. They are special only in that they run in kernel mode and can get at the raw hardware. Processes are organized into groups called teams. A team of processes share a common address space, and therefore must Distributed Operating Systems l 459 all run on the same processor. Application programs can make use of concurrency by running as a team of processes, each of which does part of the kernel. If one process in a team is blocked waiting for a reply to a message, the other ones are free to run. The kernel server is prepared to carry out operations such as creating new processes and teams, destroying processes and teams, reading and writing processes states, and mapping processes onto memory. All IO in V is done using a uniform interface called the V IO protocol. The protocol allows processes to read and write specific blocks on the device. This block orientation was chosen to provide idempo tency. Terminal drivers must store the last block read and filter out duplicate requests in order to maintain the idempotency prop erty. Implementation of byte streams is up to the users. The IO protocol has proved general enough to handle disks, printers, terminals, and even a mouse. 3.3.4 Fault Tolerance Since it was designed primarily for use in an interactive environment, V provides little in the way of fault tolerance. If something goes wrong, the user just does it again. V, however, does address excep tion handling. Whenever a process causes an exceptional condition to occur, such as stack overflow or referencing nonexistent memory, the kernel detecting the error sends a specially formatted message to the exception server, which is outside the ker nel. The exception server can then invoke a debugger to take over. This scheme does not require a process to make any advance preparation for being debugged and in prin ciple, can allow the process to continue execution afterward. 3.3.5 Services Since most of the V workstations do not have a disk, the central file server plays a key role in the system. The file server is not part of the operating system. Instead, it is just an ordinary user program running on top of the V kernel. Internally it is structured as a team of processes. The main Computing Surveys, Vol. 17, No. 4, December 1985 460 . A. S. Tanenbaum and R. van Renesse process handles directory operations, in cluding opening files subsidiary processes perform the actual read and write com mands, so that when one of them blocks waiting for a disk block, the others can continue operation. The members of file server team share a common buffer cache, used to keep heavily used blocks in main memory. The file system is a traditional hierar chical system, similar to that of Thoth Cheriton 19821. Each file has a file descrip tor, similar to an inode in UNIX, except that the file descriptors are gathered into an ordinary file, which can grow as needed. Extensive measurements have been made of the performance of the file server. As an indication, it takes 7.8 milliseconds to read a 1K block from the file server when the block is in the cache. This time includes the communication and network overhead. When the block must be fetched from the disk, the time is increased to 35.5 millisec onds. Given that the access time of the small Winchester disks used on personal computers is rarely better than 40 millisec onds, it is clear that the V implementation of diskless workstations with a fast 18 millisecond central file server is definitely competitive. Other V servers include the print server, gateway server, and time server. Other servers are in the process of being devel oped. 3.3.6 Implementation The V kernel has been up and running at Stanford University since September 1982. It runs on SUN Microsystems 68000based workstations, connected by 3megabitper second and lomegabitpersecond Ether nets. The kernel is used as a base for a variety of projects at Stanford, including the research project on distributed operat ing systems. A great deal of attention has been paid to tuning the system to make it fast. 3.4 The Eden Project The goal of the Eden system Almes et al. 1985 Black 1983, 1985 Jessop et al. 1982 Lazowska et al. 19811, which is being de Computing Surveys, Vol. 17, No. 4, December 1985 veloped at the University of Washington in Seattle under the direction of Guy Almes, Andrew Black, Ed Lazowska, and Jerre Noe, is to investigate logically integrated but physically distributed operating sys tems. The idea is to construct a system based on the principle of one user and one workstation no processor pool, but with a high degree of systemwide integration. Eden is object oriented, with all objects accessed by capabilities, which are pro tected by the Eden kernel. Eden objects, in contrast to, say, Amoeba objects, contain not only passive data, but also one or more processes that carry out the operations de fined for the object. Objects are general Applications programmers can determine what operations their objects will provide. Objects are also mobile, but at any instant each object and all the processes it con tains resides on a single workstation. Much more than most research projects of this kind, Eden was designed top down. In fact, the underlying hardware and lan guage was radically changed twice during the project, without causing too much rede signing. This would have been much more difficult in a bottomup, hardwaredriven approach. 3.4.1 Communication Primitives Communication in Eden uses invocation, a form of remote procedure call. Programs are normally written in EPL, the Eden Programming Language, which is based on Concurrent Euclid. The EPL translator is actually a preprocessor for Concurrent Euclid. To perform an operation on an object, say, Lookup, on a directory object, the EPL programmer just calls Lookup, specifying a capability for the directory to be searched, the string to be searched for, and some other parameters. The EPL compiler translates the call to Lookup to a call to a stub routine linked together with the calling procedure. This stub routine assembles the parameters and packs them in a standard form called ESCII Eden Standard Code for Informa tion Interchange, and then calls a lower level routine to transmit the function code and packed parameters to the destination machine. Distributed Operating Systems l 461 Each directory entry contains the ASCII string by which the capability is accessed and the capability itself. Clients can only access the contents of a directory by invok ing the directory object with one of the valid operations, which include add entry, delete entry, lookup string, and rename ca pability. Capabilities are protected from forgery by the kernel, but users keep copies of capabilities for their own use the kernel verifies them when they are used. The basic protection scheme protects ob jects, using capabilities. Since all processes are embedded in objects, a process can be protected by restricting the distribution of capabilities to its object. The only way to obtain service from an object is by invoking the object with the proper capability, pa rameters, etc., all of which are checked by the kernel and EPL runtime system before the call is made. When the message arrives at the desti nation machine, a stub routine there un packs the ESCII message and makes a local call on Lookup using the normal EPL call ing sequence. The reply proceeds analo gously in the opposite direction. The stub routines on both sides are automatically generated by the EPL compiler. The implementation of invocation is slightly complicated by the fact that an object may contain multiple processes. When one process blocks waiting for a re ply, the others must not be affected. This problem is handled by splitting the invo cation into two layers. The upper layer builds the message, including the capability for the object to be invoked and the ESCII parameters, passes it to the lower layer, and blocks the calling process until the reply arrives. The lower layer then makes a nonblocking call to the kernel to actually send the message. If other processes are active within the object, they can now be run if none are active, the object waits until a message arrives. On the receiving side, a process within the invoked object will normally have pre viously executed a call announcing its will ingness to perform some operation e.g., Lookup in the above example, thereby blocking itself. When the Lookup message comes in, it is accepted by a special dis patcher process that checks to see which process, if any, is blocked waiting to per form the operation requested by the mes sage. If a willing process is found, it runs and sends a reply, unblocking the caller. If no such process can be found, the message is queued until one becomes available. 3.4.2 Naming and Protection Naming and protection in Eden are accom plished using the capability system. Data are encapsulated within objects, and are only accessible by invoking one of the op erations defined by the object. To invoke an object, a process must have a valid ca pability. Thus there is a uniform naming and protection scheme throughout Eden. Capabilities may be stored in any object. Directories provide a convenient mecha nism for grouping capabilities together. 3.4.3 Resource Management Because no version of Eden runs on bare machines, most of the issues associated with lowlevel resource management have not yet been dealt with. Nevertheless, some resource management issues have been ad dressed. For example, when an object is created, the issue arises of where to put it. At present, it is just put on the same work station as the object that created it unless an explicit request has been given to put it somewhere else. Another issue that has received consid erable attention is how to achieve concur rency within an object. From the beginning of the project it was considered desirable to allow multiple processes to be simultane ously active within an object. These pro cesses all share a common address space, although each one has its own stack for local variables, procedure callreturn in formation, etc. Having multiple active processes within an object, coupled with the basic Eden semantics of remote invoca tions that block the caller but not the whole object, makes the implementation somewhat complicated. It is necessary to allow one process to block waiting for a reply without blocking the object as a whole. Monitors are used for synchroniza tion. This multiprogramming of processes Computing Surveys, Vol. 17, No. 4, December 1985 462 . A. S. Tanenbaum and R. van Renesse within an object is handled by a runtime system within that object, rather than by the kernel itself as is done in Amoeba and also in V. The experiences of Eden, Amoeba, and V all seem to indicate that having cheap, lightweight processes that share a common address space is often useful Black 19851. Management of dynamic storage for ob jects has also been a subject of some work. Each object has a heap for its own internal use, for which the EPL compiler generates explicit allocate and deallocate commands. However, a different storage management scheme is used for objects themselves. When a kernel creates an object, it allocates storage for the object from its own heap and gives the object its own address space. It also manages the user capabilities for the object in such a way that it is possible systematically to find all capabilities by scanning the kernels data structures. 3.4.4 Fault Tolerance The Eden kernel does not support atomic actions directly, although some services provide them to their clients. Invocations can fail with status CANNOT LOCATE OBJECT when the machine on which the invoked object resides crashes. On the other hand, Eden goes to a considerable length to make sure that objects are not totally destroyed by crashes. The technique used to accomplish this goal is to have objects checkpoint themselves periodically. Once an object has written a copy of its state to disk, a subsequent crash merely has the effect of resetting the object to the state that it had at the most recent checkpoint. Checkpoints themselves are atomic, and this property can be used to build up more complex atomic actions. By judicious timing of its checkpoints, an object can achieve a high degree of reli ability. For example, within the user mail system, a mailbox object will checkpoint itself just after any letter is received or removed. Upon receipt of a letter, a mailbox can wait for confirmation of the checkpoint before sending an acknowledgment back to the sender, to ensure that letters are never lost because of crashes. One drawback of Computing Surveys, Vol. 17, No. 4, December 1985 the whole checkpoint mechanism is that it is expensive Any change to an objects state, no matter how small, requires writing the entire object to the disk. The Eden designers acknowledge this as a problem. Another feature of Eden that supports fault tolerance is the ability of the file system, when asked, to store an object as multiple copies on different machines see below. 3.4.5 Services The Eden file system maintains arbitrary objects. One particular object type, the BYTESTORE, implements linear files, as in UNIX. It is possible to set the current position anywhere in the file and then read sequentially from that point. Unlike V and Amoeba, Eden does not have special ma chines dedicated as servers. Instead, each workstation can support file objects, either for the benefit of the local user or remote ones. The model used for file service in Eden is quite different from the usual model of a file server, which manages some set of tiles and accepts requests from clients to per form operations on them. In Eden, each file i.e., BYTESTORE object contains within it the processes needed to handle opera tions on it. Thus the file contains the server rather than the server containing the file as in most other systems. Of course, actually having a process run ning for each file in existence would be unbearably expensive, so an optimization is used in the implementation. When a file is not open, its processes are dormant and consume no resources other than the disk space for its checkpoint. Mailboxes, direc tories, and all other Eden objects work the same way. When an object is not busy with an invocation, the processes inside it are put to sleep by checkpointing the whole object to the disk. When a file is opened, a copy of the code for its internal processes is found, and the processes started up. Although all files on a given workstation share the same code, when the first file is opened on a work station, the code may have to be fetched from another workstation. Distributed Operating Systems l 463 The approach has advantages and dis advantages compared with the traditional onefileserverforallfiles way of doing things. There are two main advantages. First, the complicated, multithreaded file server code is eliminated There is no tile server. The processes within a BYTE STORE object are dedicated to a single file. Second, files can be migrated freely about all the nodes in the system, so that, for example, a tile might be created locally and then moved to a remote node where it will later be used. The chief disadvantage is performance. All the processes needed for the open tiles consume resources, and fetching the code for the first file to be opened on a work station is slow. The Eden file system supports nested transactions Pu and Noe 19851. When an atomic update on a set of files or other objects is to be carried out, the manager for that transaction first makes sure that all the new versions are safely stored on disk, then it checkpoints itself, and finally it updates the directory. The transaction facility can be used to support replicated tiles Pu et al. 19861. In the simplest case, a directory object maps an ASCII name onto the capability for that object. However, the system also has repdirs, objects that map ASCII names onto sets of capabilities, for example, all the copies of a replicated file. Updating a replicated file is handled by a transaction manager, which uses a twophase commit algorithm to update all the copies simul taneously. If one of the copies is not available for updating e.g., its machine is down or the network is partitioned, a new copy of the file is generated, and the capa bility for the unreachable copy discarded. Sooner or later, the garbage collector will notice that the old copy is no longer in use and remove it. We touched briefly on the mail server above. The mail system defines message, mailbox, and address list objects, with op erations to deliver mail, read mail, reply to mail, and so on. The appointment calendar system is an other example of an Eden application. It is used to schedule meetings and runs in two phases. When someone proposes a meeting, a transaction is first done to mark the proposed time as tentatively occupied on all the participants calendars. When a par ticipant notices the proposed date, he or she can then approve or reject it. If all participants approve the meeting, it is committed by another transaction if someone rejects the proposed appointment, the other participants are notified. 3.4.6 Implementation Eden has had a somewhat tortuous imple mentation history. The initial version was designed to be written in Ada4 on the Intel 432, a highly complex multiprocessor, fault tolerant microprocessor chip ensemble. To make a long story short, neither the Ada compiler nor the 432 lived up to the pro jects expectations. To gather information for further design, a throwaway imple mentation was made on top of VMS on a VAX. The VAXVMS version, called Newark because that was thought to be far from Eden, was written in Pascal and was not distributed i.e., it ran on a single VAX. It supported multiple processes per object VMS kernel processes but did not have automatic stub generation. Furthermore, the whole implementation was rather cum bersome, so it was then decided to design a programming language that would provide automatic stub generation, better type checking, and a more convenient way of dealing with concurrency. This reevaluation led to EPL and a new implementation on top of UNIX instead of VMS. Subsequently, Eden was ported to 68000based workstations SUNS, also on top of UNIX, rather than on the bare hard ware and in contrast to the Cambridge system, V, and Amoeba, all of which run on bare 68000s. The decision to put UNIX on the bottom, instead of the top as was done with Amoeba, made system develop ment easier and assisted users in migrating from UNIX to Eden. The price that has been paid is poor performance and a fair Ada is a trademark of the U.S. Department of Defense. Computing Surveys, Vol. 17, No. 4, December 1985 464 . A. S. Tanenbaum and R. van Renesse amount of effort spent trying to convince UNIX to do things against its will. 3.5 Comparison of the Cambridge, Amoeba, V, and Eden Systems Our four example systems have many as pects in common, but also differ in some significant ways. In this section we sum marize and compare the four systems with respect to the main design issues that we have been discussing. 3.5.1 Communication Primitives All four systems use an RPClike mecha nism as opposed to an IS0 OS1 commu nicationoriented mechanism. The Cambridge mechanism is the sim plest, using the singleshot protocol with a 2K request packet and a 2K reply packet for most clientserver communication. A byte stream protocol is also available. Amoeba uses a similar REQUEST REPLY mechanism, but allows messages up to 32 kilobytes with the kernelhan dling message fragmentation and reassem bly, as well as acknowledgments and time outs, thus providing user programs with a more reliable and simpler interface. V also uses a REQUESTREPLY mech anism, but messages longer than an Eth ernet packet are dealt with by having the sender include a sort of capability for a message segment in the REQUEST packet. Using this capability, the receiver can fetch the rest of the message, as needed. For efficiency, the first 1K is piggybacked onto the REQUEST itself. Eden comes closest to a true RPC mech anism, including having a language and compiler with automatic stub generation and a minilanguage for parameter passing. None of the four examples attempts to guarantee that remote calls will be executed exactly once. 3.5.2 Naming and Protection All four systems use different schemes for naming and protection. In the Cambridge system a single name server process maps symbolic service names onto node, process identifier pairs so that the client will know Computing Surveys, Vol. 17, No. 4, December 1985 where to send the request. Protection is done by the active name table, which keeps track of the authorization status of each logged in user. Amoeba has a single mechanism for all naming and protectionsparse capabili ties. Each capability contains bits specify ing which operations on the object are allowed and which are not. The rights are protected cryptographically, so that user programs can manipulate them directly they are not stored in the kernel. ASCII stringtocapability mapping and capability storage are handled by directory servers for convenience. Eden also uses capabilities, but these are not protected by sparseness or encryption, and so they must be protected by the ker nel. A consequence of this decision is that all the kernels must be trustworthy. The Amoeba cryptographic protection scheme is less restrictive on this point. V has naming at three levels Processes have pids, kernels have ASCIItopid map pings, and servers use a context mechanism to relate symbolic names to a given context. 3.5.3 Resource Management Resource management is also handled quite differently on all four systems. In the Cam bridge system the main resource is the processor bank. A resource manager is pro vided to allocate machines to users. Gen erally, this allocation is fairly staticupon login a user is allocated one machine for the duration of the login session, and this is the only machine the user uses during the session. The user may load any oper ating system that he or she chooses in this machine. Amoeba also has a pool of processors, but these are allocated dynamically. A user run ning make might be allocated ten pro cessors to compile ten files afterward, all the processors would go back into the pool. Amoeba also provides a way for processes to create segments on any machine assum ing that the proper capability can be shown and for these segments to be forged into processes. Amoeba is unique among the four systems in that it has a bank server that can allow servers to charge for services Distributed Operating Systems l 465 entire objects can be checkpointed, making checkpointing a slow operation and thus discouraging its frequent use. and to limit resource usage by accounting for it. In V, each processor is dedicated as either a workstation or a server, so processors are not resources to be dynamically allocated. Each V kernel manages its own local re sources there is no systemwide resource management. Eden has been built on top of existing operating systems, and therefore most of the issues of resource management are done by the underlying operating system. The main issue remaining for Eden is allocating and deallocating storage for objects. 3.5.4 Fault Tolerance None of the four systems go to great lengths to make themselves fault tolerant for ex ample, none support atomic actions as a basic primitive. All four with the possible exception of Eden were designed with the intention of actually being used, so that the inherent tradeoff between performance and fault tolerance tended to get resolved in favor of performance. In the Cambridge system the only con cession to fault tolerance is a feature in the ring interface to allow a machine to be remotely reset by sending a special packet to the interface. There is also a small server that helps get the servers started up. Amoeba provides some fault tolerance through its boot server, with which pro cesses can register. The boot server pools the registered processes periodically and, finding one that fails to respond, requests a new processor and downloads the failed program to it. This strategy does not re trieve the processes that were killed when a machine has gone down, but it does au tomatically ensure that no key service is ever down for more than, say, 30 seconds. V does not address the problem of fault tolerance at all. Of the four systems, Eden makes the most effort to provide a higher degree of reliability than provided by the bare hard ware. The main tool used is checkpointing complete objects from time to time. If a processor crashes, each of its objects can be restored to the state it had at the time of the last checkpoint. Unfortunately, only 3.5.5 Services The file systems used by Cambridge, Amoeba, V, and Eden are all quite different. The Cambridge system has two servers, the universal file server, and the filing machine, which was added later to improve the per formance by providing a large buffer cache. The universal file server supports a primi tive flat file, with no directory structure, which is provided by the filing machine or the user machines. The universal file server has regular and special files, of which the latter can be updated atomically. Amoeba has several file systems. One of them is compatible with UNIX, to allow UNIX applications to run on Amoeba. An other one, FUSS, supports multiversion, multiserver, treestructured, immutable files with atomic commit. Directory servers map ASCII names to capabilities, thus al lowing an arbitrary graph of files and direc tories to be constructed. V has a traditional file server similar to UNIX. It is based on the earlier Thoth system. Eden has no file server at all in the usual sense. Instead, each file object has embed ded in it a process that acts like a private file server for that one file. Like Amoeba, Eden has separate directory servers that map ASCII strings onto capabilities and provides the ability to map one string onto several files, thus providing for file repli cation. All four systems have a heteroge neous variety of other services e.g., print, mail, bank. 4. SUMMARY Distributed operating systems are still in an early phase of development, with many unanswered questions and relatively little agreement among workers in the field about how things should be done. Many experi mental systems use the clientserver model with some form of remote procedure call as the communication base, but there are also systems built on the connection model. Computing Surveys, Vol. 17, No. 4, December 1985 466 . A. S. Tanenbaum and R. van Renesse Relatively little has been done on distrib uted naming, protection, and resource management, other than building straight forward name servers and process servers. Fault tolerance is an upandcoming area, with work progressing in redundancy tech niques and atomic actions. Finally, a con siderable amount of work has gone into the construction of file servers, print servers, and various other servers, but here too there is much work to be done. The only conclusion that we draw is that distributed operating systems will be an interesting and fruitful area of research for a number of years to come. ACKNOWLEDGMENTS We would like to thank Andrew Black, Dick Grune, Sape Mullender, and Jennifer Steiner for their critical reading of the manuscript. REFERENCES ADAMS, C. J., ADAMS, G. C., WATERS, A. G., LESLIE, I., AND KIRK, P. 1982. Protocol architecture of the UNIVERSE project. In Proceedings of the 6th International Conference on Computer Commu nication London, Sept. 710. International Con ference for Computer Communication, pp. 379 383. ALMES, G. T., BLACK, A. P., LAZOWSKA, E. D., AND NIIE, J. D. 1985. The Eden system A technical review. IEEE Trans. Softw. Eng. SE11 Jan.. 4359. ANDERSON, T., AND LEE, P. A. 1981. Fault Toler ance, Principles and Practice. PrenticeHall International, London. AVIZIENIS, A., AND CHEN, L. 1977. On the im plementation of Nversion programming for software faulttolerance during execution. In Proceedings of the International Computer Soft ware and Applications Conference. IEEE, New York, pp. 149155. AVIZIENIS, A., AND KELLY, J. 1984. Fault tolerance by design diversity. Computer 17 Aug., 6680. BAL, H. E., VAN RENESSE, R., AND TANENBAUM, A. S. 1985. A distributed, parallel, fault tolerant computing system. Rep. 1106, Dept. of Mathe matics and Comnuter Science. Vriie Univ., The Netherlands, Oct.  BALL, J. E., FELDMAN, J., Low, R., RASHID, R., AND ROVNER, P. 1976. RIG, Rochesters intelligent gateway System overview. IEEE Trans. Softw. Eng. SEZ Dec., 321329. BARAK, A., AND SHILOH, A. 1985. A distributed load balancing policy for a multicomputer. Softw. Pratt. Exper. 1.5 Sept., 901913. BIRMAN, K. P., AND ROWE, L. A. 1982. A local network based on the UNIX operating system. IEEE Trans. Softw. Eng. SE8 Mar., 137146. BIRRELL, A. D. 1985. Secure communication using remote procedure calls. ACM Trans. Comput. Syst. 3, 1 Feb., 114. BIRRELL, A. D., AND NEEDHAM, R. M. 1980. A uni versal file server. IEEE Trans. Softw. Eng. SE6, Sept., 450453. BIRRELL, A. D., AND NELSON, B. J. 1984. Implementing remote procedure calls. ACM Trans. Comput. Syst. 2, 1 Feb., 3959. BIRRELL, A. D., LEVIN, R., NEEDHAM, R. M., AND SCHROEDER, M. 1982. Grapevine An exercise in distributed computing. Commun. ACM 25, 4 Apr., 260274. BIRRELL, A. D., LEVIN, R., NEEDHAM, R. M., AND SCHROEDER, M. 1984. Experience with Grape vine The growth of a distributed system. ACM Trans. Comput. Syst. 2, 1 Feb., 323. BLACK, A. P. 1983. An asymmetric stream commu nications system. Oper. Syst. Rev. ACM 17, 5, 410. . BLACK, A. P. 1985. Supporting distributed applica tions Experience with Eden. In Proceedings of the 10th Symposium on Operating Systems Prin ciples Orcas Island, Wash., Dec. l4. ACM, New York, pp. 181193. Boccs, D. R., SCHOCH, J. F., TAFT, E. A., ANY METCALFE, R. M. 1980. Pup An internetwork architecture. IEEE Trans. Commun. COM28 Apr., 612624. BORG, A., BAUMBACH, J., AND GLAZER, S. 1983. A message system supporting fault tolerance. Oper. Syst. Rev. ACM 17,5,9099. BROWN, M. R., KOLLING, K. N., AND TAG. E. A. 1985. The Alnine file svstem. ACM Trans. Com put. Syst. 3, 4 Nov., 261293. BROWNBRIDGE, D. R., MARSHALL, L. F., AND RANDELL, B. 1982. The Newcastle connec tionOr UNIXES of the world unite Softw. Pratt. Exper. 12 Dec., 11471162. BRYANT, R. M., AND FINKEL, R. A. 1981. A stable distributed scheduling algorithm. In Proceed ings of the 2nd International Conference on Dis tributed Computer Systems Apr.. IEEE, New York, pp. 314323. CHANDY, K. M., MISRA, J., AND HAAS, L. M. 1983. Distributed deadlock detection. ACM Trans. Comput. Syst. 1,2 May, 145156. CHERITON, D. R. 1982. The Thoth System Multi Process Structuring and Portability. American Elsevier, New York. CHERITON, D. R. 1984a. An experiment using regis ters for fast messagebased interprocess commu nication. Oper. Syst. Rev. 18 Oct., 1220. CHERITON, D. R. 1984b. The V kernel A software base for distributed svstems. IEEE Softw. 1 Apr., 1942.  CHERITON, D. R., AND MANN, T. P. 1984. Uniform access to distributed name interpretation in the Computing Surveys, Vol. 17, No. 4, December 1985 Distributed Operating Systems 467 FARBER, D. J., AND LARSON, K. C. 1972. The system architecture of the distributed computer sys temThe communications system. In Proceed ings of the Symposium on Computer Networks Brooklyn, Apr.. Polytechnic Inst. of Brooklyn, Brooklyn, N.Y. FINKEL, R. A., SOLOMON, M. H., AND TISCHLER, R. 1979. The Roscoe resource manager. COMP CON 79 Digest of Papers Feb.. IEEE, New York, pp. 8891. FITZGERALD, R., AND RASHID R. 1985. The integra tion of virtual memory management and inter process communication in Accent. In Proceedings of the 10th Symposium on Operating Systems Principles Orcas Island, Wash., Dec. l4. ACM, New York, pp. 1314. FRIDRICH, M., AND OLDER, W. 1981. The Felix file server. In Proceedings of the 8th Symposium on Operating Systems Principles Pacific Grove, Calif., Dec. 1416. ACM, New York, pp. 3744. FRIDRICH, M., AND OLDER, W. 1984. HELIX The architecture of a distributed file system. In Pro ceedings of the 4th International Conference on Distributed Computing Systems. IEEE, New York, pp. 422431. GAGLIANELLO, R. D., AND KATSEFF, H. P. 1985. Meglos An operating system for a multiprocessor environment. In Proceedings of the 5th Znterna tional Conference on Distributed Computing Sys tems May. IEEE, New York, pp. 3542. GLIGOR, V. D., AND SHATTUCK, S. H. 1980. Deadlock detection in distributed systems. IEEE Trans. Softw. Eng. SE6 Sept., 435440. GYLYS, V. B., AND EDWARDS, J. A. 1976. Optimal partitioning of workload for distributed systems. In Proceedings of COMPCON Sept.. IEEE, New York, pp. 353357. HWANG, K., CROFT, W. J., GOBLE, G. H. WAH, B. W., BRIGGS, F. A., SIMMONS, W. R., AND COATES, C. L. 1982. A UNIXbased local com puter network. Computer 15 Apr., 5566, ISLOOR, S. S., AND MARSLAND, T. A. 1978. An ef fective online deadlock detection technique for distributed database management systems. In Proceedings of the International Computer and Software Application Conference. IEEE, New York, pp. 283288. JANSON, P., SVOBODOVA, L., AND MAEHLE, E. 1983. Filing and printing services in a local area network. In Proceedings of the 8th Data Commu nications Symposium Cape Cod, Mass., Oct. 36. IEEE, New York, pp. 211219. JEFFERSON, D. R. 1985. Virtual time. ACM Trans. Program. Lang. Syst. 7 July, 404425. JENSEN, E. D. 1978. The Honeywell experimental distributed processorAn overview of its objec tive, philosophy and architectural facilities. Com puter 1 Z Jan, 2838. JESSOP, W. H., JACOBSON, D. M., NOE, J. D., BAER, J.L., AND Pu, C. 1982. The Eden transaction based file system. In Proceedings of the 2nd Sym V system. In Proceedings of the 4th International Conference on Distributed Computing Systems. IEEE, New York, pp. 290297. CHERITON, D. R., AND ZWAENEPOEL, W. 1983. The distributed V kernel and its performance for disk less workstations. In Proceedings of the 9th Sym posium on Operating System PrincipZes. ACM, New York, pp. 128140. CHERITON, D. R., AND ZWAENEPOEL, W. 1984. Onetomany interprocess communication in the Vsvstem. In SZGCOMM 84 Tutorials and Svm poskm on Communications Architectures and Protocols Montreal, Quebec, June 68. ACM, New York. CHERITON, D. R., MALCOLM, M. A., MELEN, L. S., AND SAGER, G. R. 1979. Thoth, a portable real time operating system. Commun. ACM 22, 2 Feb., 105115. CHESSON, G. 1975. The network UNIX system. In Proceedings of the 5th Symposium on Operating Systems Principles Austin, Tex., Nov. 1921. ACM, New York, pp. 6066. CHOW, T. C. K., AND ABRAHAM, J. A. 1982. Load balancing in distributed svstems. IEEE Trans. Softw. Eng. SE8 July, 401412. CHOW, Y. C., AND KOHLER, W. H. 1979. Models for dynamic load balancing in heterogeneous multi ple processor systems. IEEE Trans. Comput. C28 May, 354361. CHU, W. W., HOLLOWAY, L. J., MINTSUNG, L., AND EFE, K. 1980. Task allocation in distributed data processing. Computer 23 Nov., 5769. CURTIS, R. S., AND WIIE, L. D. 1984. Global naming in distributed systems. IEEE Softw. 1, 7680. DALAL, Y. K. 1977. Broadcast protocols in packet switched computer networks. Ph.D. Dissertation, Computer Science Dept., Stanford Univ., Stan ford, Calif. DELLAR, C. 1982. A file server for a network of lowcost personal microcomputers. Softw. Pratt. Erper. 22 Nov., 10511068. DENNIS, J. B., AND VAN HORN, E. C. 1966. Programming semantics for multiprogrammed computations. Commun. ACM 9, 3 Mar., 143 154. DEWIIT, D. J., FINKEL, R. A., AND SOLOMON, M. 1984. The CRYSTAL multicomnuter Design and implementation experience. Tech. Rep. TR 553, Computer Science Dept., Univ. of Wisconsin, Madison, Wis. DION, J,. 1980. The Cambridge file server. Oper. Syst. Reu. ACM 14 Oct., 4149. EFE, K. 1982. Heuristic models of task assignment scheduling in distributed systems. Computer 15 June, 5056. ESWARAN, K. P., GRAY, J. N., LORIE, J. N., AND TRAIGER, I. L. 1976. The notions of consistency and predicate locks in a database system. Com mun. ACM 19, 11 Nov., 624633. Computing Surveys, Vol. 17, No. 4, December 1985 468 l A. S. Tanenbaum and R. van Renesse posium on Reliability in Distributed Software ana Database Systems Julv. IEEE. New York. MILLSTEIN, R. E. 1977. The national software works. In Proceedings of the ACM Annual Con ference Seattle, Wash., Oct. 1619. ACM, New York, pp. 4452. MITCHELL, J. G., AND DION, J. 1982. A comparison of two networkbased file servers. Commun. ACM 25, 4 Apr., 233245. pp. 163169 . KRUEGER, P., AND FINKEL, R. A. 1983. An adaptive load balancing algorithm for a multicomputer. Unpublished manuscript, Computer Science Dept., Univ. of Wisconsin. LAMPORT, L. 1978. Time, clocks, and the ordering of events in a distributed system. Commun. ACM 21, 7 July, 558565. LAMPORT, L. 1984. Using time instead of timeout for faulttolerant distributed systems. ACM Trans. Program. Long. Syst. 6 Apr., 254280. LAMPSON, B. W. 1981. Atomic transactions. In Dis tributed SystemsArchitecture and Implementa tion, B. W. Lampson, Ed. SpringerVerlag, Berlin and New York, pp. 246265. LAZOWSKA, E. D., LEVY, H. M., ALMES, G. T., FISCHER, M. J., FOWLER, R. J., AND VESTAL, S. C. 1981. The architecture of the Eden svstem. In Proceedings of the 8th Symposium on Operating Svstems Princioles Pacific Grove. Calif.. Dec. 14 16. ACM, New York, pp. 148159. LEVY, H. M. 1984. CapabilityBased Computer Sys tems. Digital Press, Maynard, Mass. LISKOV, B. 1982. On linguistic support for distrib uted nrozrams. IEEE Trans. Softw. Ens. SE8 Mayj, 203210. LISKOV, B. 1984. Overview of the Argus language and system. Programming Methodology Group Memo 40. Laboratory for Computer Science, Massachusetts Institute of Technology, Cam bridge, Mass., Feb. LISKOV, B., AND SCHEIFLER, R. 1982. Guardians and actions Linguistic support for robust, distributed programs. ACM Trans. Program. Lang. Syst. 5, 3 July, 381404. 1983. ACM, pp. 719, Jan. 1982. LO, V. M. 1984. Heuristic algorithms for task assign ment in distributed systems. In Proceedings of the 4th International Conference on Distributed Computing Systems. IEEE, New York, pp. 3039. LUDERER, G. W. R., CHE, H., HAGGERTY, J. P., KIRSLIS, P. A., AND MARSHALL, W. T. 1981. A distributed UNIX system based on a virtual cir cuit switch. In Proceedings of the 8th Symposium on Operating Systems Principles Pacific Grove, Calif., Dec. 1416. ACM, New York, pp. 160 168. MAMRAK, S. A., MAURATH, P., GOMEZ, J., JANARDAN, S., AND NICHOLAS, C. 1982. Guest layering dis tributed processing support on local operating systems. In Proceedings of the 3rd Znternational Conference on Distributed Computing Systems. IEEE, New York, pp. 854859. MARZULLO, K., AND OWICKI, S. 1985. Maintaining the time in a distributed system. Oper. Syst. Reu. 19 July, 4454. MENASCE, D., AND MUNTZ, R. 1979. Locking and deadlock detection in distributed databases. IEEE Trans. Softw. Eng. SE5 May, 195202. MOHAN, C. K., AND WIIE, L. D. 1985. Local re configuration of management trees in large net works. In Proceedings of the 5th International Conference on Distributed Computing Systems May. IEEE, New York, pp. 386393. MULLENDER, S. J., AND TANENBAUM, A. S. 1984. Protection and resource control in distributed operating systems. Comput. Networks 8 Nov., 421432. MULLENDER, S. J., AND TANENBAUM, A. S. 1985. A distributed file service based on optimistic con currency control. In Proceedings of the 10th Sym posium on Operating Systems Principles Orcas Island, Wash., Dec. l4. ACM, New York, pp. 5162. MULLENDER, S. J., AND TANENBAUM, A. S. 1986. The design of a capabilitybased distributed op erating system. Computer J. in press. NEEDHAM, R. M., AND HERBERT, A. J. 1982. The Cambridge Distributed Computing System. AddisonrWesley, Reading, Mass.   NELSON, B. J. 1981. Remote procedure call. Tech. Rep. CSL819, Xerox Palo Alto Research Center, Palo Alto, Calif. OBERMARCK, R. 1982. Distributed deadlock detec tion algorithm. ACM Trans. Database Syst. 7 June, 187208. OKI, B. M., LISKOV, B. H., AND SCHEIFLER, R. W. 1985. Reliable object storage to support atomic actions. In Proceedings of the 10th Symposium on Operating Systems Principles Orcas Island, Wash., Dec. l4. ACM, New York, pp. 147159. OUSTERHOUT, J. K. 1982. Scheduling techniques for concurrent systems. In Proceedings of the 3rd International Conference on Distributed Comput ing Systems. IEEE, New York, pp. 2230. PASHTAN, A. 1982. Object oriented operating sys terns An emerging design methodology. In Pro ceedings of the ACM National Conference Dallas. Tex., t 2527. ACM, New York, pp. 126131 POPEK, G., WALKER, B., CHOW, J., EDWARDS, D., KLINE, C., RUDISIN, G., AND THIEL, G. 1981. LOCUS A network transparent, high reliability distributed system. In Proceedings of the 8th Symposium on Operating Systems Principles Pa cific Grove, Calif., Dec. 1416. ACM, New York, pp. 160168. POWELL, M. L., AND MILLER, B. P. 1983. Process migration in DEMOSMP. Oper. Syst. Rev. ACM 17,5,110119. POWELL, M. L., AND PRESOITO, D. L. 1983. PublishingA reliable broadcast communication mechanism. Oper. Syst. Reu. ACM 17, 5, lOO 109. Computing Surveys, Vol. 17, No. 4, December 1985 Distributed Operating Systems 469 Principles Pacific Grove, Calif., Dec. 1012. ACM, New York, pp. 108114. SPECTOR, A. Z. 1982. Performing remote operations efficiently on a local computer network. Commun. ACM 25,4 Apr., 246260. STANKOVIC, J. A., AND SIDHU, I. S. 1984. An adap tive bidding algorithm for processes, clusters, and distributed ups. In Proceedings of the 4th Inter national Conference on Distributed Computing Systems. IEEE, New York, pp. 4959. STONE, H. S. 1977. Multiprocessor scheduling with the aid of network flow algorithms. IEEE Trans. Softw. Eng. SE3 Jan., 8893. STONE, H. S. 1978. Critical load factors in distrib uted computer systems. IEEE Trans. Softw. Eng. SE4 May, 254258. STONE, H. S., AND BOKHARI, S. H. 1978. Control of distributed processes. Computer 11 July, 97106. STONEBRAKER, M. 1981. Operating system support for database management. Commun. ACM 24, 7 July, 412418. STURGIS, H. E., MITCHELL, J. G., AND ISRAEL, J. 1980. Issues in the design and use of a distrib uted file system. Oper. Syst. Rev. 24 July, 5569. SVENTEK, J., GREIMAN, W., ODELL, M., AND JANSEN, A. 1983. Token ring local networks A comparison of experimental and theoretical performance. Lawrence Berkeley Lab. Rep. 16254. SVOBODOVA, L. 1981. A reliable objectoriented data repository for a distributed computer system. In Proceedings of the 8th Symposium on Operating Systems Principles Pacific Grove, Calif., Dec. 14 16. ACM, New York, pp. 4758. SVOBODOVA, L. 1984. File servers for networkbased distributed systems. ACM Comput. Sure. 16, 4 Dec., 353398. SWINEHART, D., MCDANIEL, G., AND Boccs, D. 1979. WFS A simple shared file system for a distributed environment. In Proceedings of the 7th Symposium on Operating Systems Principles Pacific Grove, Calif., Dec. 1012. ACM, New York, pp. 917. TANENBAUM, A. S., AND MULLENDER, S. J. 1982. Operating system requirements for distributed data base systems. In Distributed Data Bases, H.J. Schneider, Ed. NorthHolland Publ., Amsterdam, pp. 105114. TANENBAUM, A. S., MULLENDER, S. J., AND VAN RENESSE, R. 1986. Using sparse capabilities in a distributed operating system. In Proceedings of the 6th International Conference on Distributed Computer Systems. IEEE, New York, 1986, pp. 558563. VAN TILBORG, A. M., AND WIE, L. D. 1981. Wave scheduling Distributed allocation of task forces in network computers. In Proceedings of the 2nd International Conference on Distributed Comput ing Systems. IEEE, New York, pp. 337347. m pu, C., AND NOE, J. D. 1985. Nested transactions for general objects. Rep. TR851203, Computer Science Dept., Univ. of Washington, Seattle, Wash. C., NOE, J. D., AND PROUDFOOT, A. 1986. Regeneration of replicated objects A technique and its Eden implementation. In Proceedings of the 2nd International Conference on Data I neering Los Angeles, Calif., Feb. 46. IEEE, New York, pp. 175187. RASHID, R. F., AND ROBERTSON, G. G. 1981. Accent A communication oriented network operating system kernel. In Proceedings of tne 8th Sympo sium on Operating Systems Principles Pacific Grove, Calif., Dec. 1416. ACM, New York, pp. 6475. REED, D. P. 1983. Implementing atomic actions on decentralized data. ACM Trans. Comput. Syst. 1, 1 Feb., 323. REED, D. P., AND SVOBODOVA, L. 1981. SWALLOW A distributed data storage system for a local network. In Local Networks for Com puter Communications, A. West and P. Janson, Eds. NorthHolland Publ., Amsterdam, pp. 355 373. REIF, J. H., AND SPIRAKIS, P. G. 1984. Realtime synchronization of interprocess communications. ACM Trans. Program. Lang. Syst. 6, 2 Apr., 215238. RITCHIE, D. M., AND THOMPSON, K. 1974. The UNIX timesharing system. Commun. ACM 19, 7 July, 365375. SALTZER, J. H., REED, D. P., AND CLARK, D. D. 1984. Endtoend arguments in system design. ACM Trans. Comput. Syst. 2, 4 Nov., 277278. SATYANARAYANAN, M., HOWARD, J., NICHOLS, D., SIDEBOTHAM, R., SPECTOR, A., AND WEST, M. 1985. The ITC distributed file system Princi ples and design. In Proceedings of the 10th Sym posium on Operating Systems Principles Orcas Island, Wash., Dec. l4. ACM, New York, pp. 3550. SCHROEDER, M., GIFFORD, D., AND NEEDHAM, R. 1985. A caching file system for a program mers workstation. In Proceedings of the 10th Symposium on Operating Systems Principles Orcas Island, Wash., Dec. l4. ACM, New York, pp. 2534. SMITH, R. 1979. The contract net protocol High level communication and control in a distributed problem solver. In Proceedings of the 1st Znter national Conference on Distributed Computing Systems. IEEE, New York, pp. 185192. SOLOMON, M. H., AND FINKEL, R. A. 1978. ROSCOE A multimicrocomputer operating sys  tern. In Proceedings of the 2nd Rocky Mountain Symposium on Microcomputers Aug., pp. 201 210. SOLOMON, M. H., AND FINKEL, R. A. 1979. The Roscoe distributed operating system. In Proceed ings of the 7th Symposium on Operating Systems Computing Surveys, Vol. 17, No. 4, December 1985 470 l A. 5. Tanenbaum and R. van Renesse WALKER, B., POPEK, G., ENGLISH, R., KLINE, C., Distributed Computing Systems May. IEEE, AND THIEL, G. 1983. The LOCUS distributed New York, pp. 549551. operating system. Oper. Syst. Reu. ACM 17, 5, 4970. WIIE, L. D., AND VAN RLBORG, A. M. 1980. WAMBECQ, A. 1983. NETIX A networkusing op MICROS, a distributed operating system for MI erating system, based on UNIX software. In Pro CRONET, a reconfigurable network computer. ceedings of the NFWOENRS Contact Group IEEE Trans. Comput C29 Dec., 11331144. Leuven, Belgium, Mar.. WUPIT, A. 1983. Comparison of UNIX network sys WEINSTEIN. M. J.. PAGE. T. W.. JR.. LIVESEY. B. K.. terns. ACM, New York, pp. 99108. ,  ,  ,  I  I  AND POPEK, G. J. 1985. Transactions and syn ZIMMERMANN, H. 1980. OS1 reference modelThe chronization in a distributed operating system. In IS0 model of architecture for open systems in Proceedings of the 20th Symposium on Operating terconnection. IEEE Trans. Commun. COM28 Systems Principles Orcas Island, Wash., Dec. Apr., 425432. l4. ACM, New York, pp. 115125. WILKES, M. V., AND NEEDHAM, R. M. 1980. The ZIMMERMANN, H., BANINO, J.S., CARISTAN, A., Cambridge model distributed system. Oper. Syst. GUILLEMONT, M., AND MORISSET, G. 1981. Reu. 14 Jan., 2129. Basic concepts for the support of distrib uted systems The chorus approach. In Proceed WITTIE, L., AND CURTIS, R. 1985. Time manage ment for debugging distributed systems. In Pro ceedings of the 5th International Conference on ings of t 2nd International Conference on Dis tributed Computing Systems. IEEE, New York, pp. 6066. Received July 1985 final revision accepted April 1986. Computing Surveys, Vol. 17, No. 4, December 1985
