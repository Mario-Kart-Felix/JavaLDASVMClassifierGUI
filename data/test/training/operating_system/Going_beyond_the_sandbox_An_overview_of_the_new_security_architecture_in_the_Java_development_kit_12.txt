The following paper was originally published in theProceedings of the USENIX Symposium on Internet Technologies and SystemsMonterey, California, December 1997For more information about USENIX Association contact1. Phone 510 52886492. FAX 510 54857383. Email officeusenix.org4. WWW URL httpwww.usenix.orgGoing Beyond the Sandbox An Overview of the New SecurityArchitecture in the Java Development Kit 1.2Li Gong, Marianne Mueller, Hemma Prafullchandra, and Roland SchemersJavaSoft, Sun Microsystems, Inc.Going Beyond the Sandbox An Overview of the New SecurityArchitecture in the JavaTM Development Kit 1.2Li Gong, Marianne Mueller, Hemma Prafullchandra, and Roland SchemersJavaSoft, Sun Microsystems, Inc.fgong,mrm,hemma,schemersgeng.sun.comAbstractThis paper describes the new security architecture that has been implemented as part of JDK1.2,the forthcoming JavaTM Development Kit. In goingbeyond the sandbox security model in the originalrelease of Java, JDK1.2 provides negrained access control via an easily congurable security policy. Moreover, JDK1.2 introduces the concept ofprotection domain and a few related security primitives that help to make the underlying protectionmechanism more robust.1 IntroductionSince the inception of Java 8, 11, there has beenstrong and growing interest around the security ofJava as well as new security issues raised by thedeployment of Java. From a technology providerspoint of view, Java security includes two aspects 6 Provide Java primarily through JDK as a secure, readybuilt platform on which to run Javaenabled applications in a secure fashion. Provide security tools and services implemented in Java that enable a wider range ofsecuritysensitive applications, for example, inthe enterprise world.This paper focuses on issues related to the rstaspect, where the customers for such technologiesinclude vendors that bundle or embed Java in theirproducts such as browsers and operating systems.It is worth emphasizing that this work by itselfdoes not claim to break signicant new ground interms of the theory of computer security. Instead,it oers a real world example where wellknown security principles 5, 12, 13, 16 are put into engineering practice to construct a practical and widelydeployed secure system.1.1 The Original Security ModelThe original security model provided by Java isknown as the sandbox model, which exists in orderto provide a very restricted environment in whichto run untrusted code called applet obtained fromthe open network. The essence of the sandboxmodel, as illustrated by Figure 1, is that local code istrusted to have full access to vital system resourcessuch as the le system while downloaded remotecode is not trusted and can access only the limitedresources provided inside the sandbox.Figure 1 JDK1.0.x Security ModelThis sandbox model is deployed through the JavaDevelopment Toolkit in versions 1.0.x, and is generally adopted by applications built with JDK, including Javaenabled web browsers.Overall security is enforced through a number ofmechanisms. First of all, the language is designedto be typesafe, and easy to use. The hope is thatthe burden on the programmer is such that it is lesslikely to make subtle mistakes, compared with usingother programming languages such as C or C.Language features such as automatic memory management, garbage collection, and range checking onstrings and arrays are examples of how the languagehelps the programmer to write safer code.Second, compilers and a bytecode verier ensurethat only legitimate Java code is executed. Thebytecode verier, together with the Java virtual machine, guarantees language type safety at run time.Moreover, a class loader denes a local namespace, which is used to ensure that an untrustedapplet cannot interfere with the running of otherJava programs.Finally, access to crucial system resources is mediated by the Java virtual machine and is checked inadvance by a SecurityManager class that restrictsto the minimum the actions of untrusted code.JDK1.1.x introduced the concept of signed applet. In this extended model, as shown in Figure 2,a correctly digitally signed applet is treated as if it istrusted local code if the signature key is recognizedas trusted by the end system that receives the applet. Signed applets, together with their signatures,are delivered in the JAR Java Archive format.Figure 2 JDK1.1 Security ModelThe rest of this paper focuses on the new system security features. Discussion of various language safety issues can be found elsewhere e.g.,3, 4, 19, 21.1.2 Evolving the Sandbox ModelThe new security architecture in JDK1.2, as illustrated in Figure 3, is introduced primarily for thefollowing purposes. Finegrained access control.This capability has existed in Java from the beginning, but to use it, the application writer hasFigure 3 JDK1.2 Security Modelto do substantial programming e.g., by subclassing and customizing the SecurityManagerand ClassLoader classes.HotJava is such an example application. However, such programming is extremely securitysensitive and requires sophisticated skills andindepth knowledge of computer security. Thenew architecture makes this exercise simplerand safer. Easily congurable security policy.Once again, this feature exists in Java but isnot easy to use. This design goal implies thatthe security and its implementation or enforcement mechanism should be clearly separated.Moreover, because writing security code is notstraightforward, it is desirable to allow application builders and users to congure securitypolicies without having to program. Easily extensible access control structure.Up to JDK1.1, to create a new access permission, one has to add a new check methodto the SecurityManager class. The new architecture allows typed permissions and automatic handling. No new method in theSecurityManager class needs to be created inmost cases. Actually, we have not encountereda situation where a new method must be created. Extension of security checks to all Java programs, including applets as well as applications.There should not be a builtin concept that alllocal code is trusted. Instead, local code shouldbe subjected to the same security controls asapplets, although one should have the choiceto declare that the policy on local code or remote code be the most liberal thus local codeeectively runs as totally trusted. The sameprinciple applies to signed applets and applications.Finally, we also take this opportunity to makeinternal structural adjustment in order to reducethe risks of creating subtle security holes in programs. This eort involves revising the designand implementation of the SecurityManager andClassLoader classes as well as the underlying access control checking mechanism.1.3 Related WorkThe fundamental ideas adopted in the new security architecture have roots in the last 40 years ofcomputer security research, such as the overall ideaof access control list 10. We followed some of theUnix conventions in specifying access permissionsto the le system and other system resources, butsignicantly, our design has been inspired by theconcept of protection domains and the work dealing with mutually suspicious programs in Multics17, 15, and right amplication in Hydra 9, 20.One novel feature, which is not present in operating systems such as Unix or MSDOS, is that weimplement the leastprivilege principle by automatically intersecting the sets of permissions granted toprotection domains that are involved in a call sequence. This way, a programming error in systemor application software is less likely to be exploitableas a security hole.Note that although the Java Virtual MachineJVM typically runs over another hosting operating system such as Solaris, it may also run directlyover hardware as in the case of the network computer JavaStation running JavaOS 14. To maintain platform independence, our architecture doesnot depend on security features provided by an underlying operating system.Furthermore, our architecture does not overridethe protection mechanisms in the underlying operating system. For example, by conguring a negrained access control policy, a user may grant specic permissions to certain software, but this is effective only if the underlying operating system itselfhas granted the user those permissions.Another signicant character of JDK is that itsprotection mechanisms are languagebased, within asingle address space. This feature is a major distinction from more traditional operating systems, butis very much related to recent works on softwarebased protection and safe kernel extensions e.g.,2, 1, 18, where various research teams have latelyaimed for some of the same goals with dierent programming techniques.2 New Protection MechanismsThis section covers the concept and implementation of some important new primitives introduced inJDK1.2, namely, security policy, access permission,protection domain, access control checking, privileged operation, and Java class loading and resolution.2.1 Security PolicyThere is a system security policy, set by the useror by a system administrator, that is representedby a policy object, which is instantiated from theclass java.security.Policy. There could be multiple instances of the policy object, although onlyone is in eect at any time. This policy objectmaintains a runtime representation of the policy, istypically instantiated at the Java virtual machinestartup time, and can be changed later via a securemechanism.In abstract terms, the security policy is a mappingfrom a set of properties that characterize runningcode to a set of access permissions that is grantedto the concerned code.1Currently, a piece of code is fully characterizedby its origin its location as specied by a URLand the set of public keys that correspond to theset of private keys that have been used to signthe code using one or more digital signature algorithms. Such characteristics are captured in theclass java.security.CodeSource, which can beviewed as a natural extension of the concept of acode base within HTML. It is important not to confuse CodeSourcewith the CodeBase tag in HTML.Wild cards are used to denote any location orunsigned.Informally speaking, for a code source to matchan entry given in the policy, both the URL information and the signature informationmust match. ForURL matching, if the code sources URL is a prexof an entrys URL, we consider this a match. Forsignature matching, if one public key correspondingto a signature in the code source matches the key ofa signer in the policy entry, we consider it a match.1In the future, the security policy can be extended to include and consider information such user authentication anddelegation.When a code source matches multiple policy entries, for example, when the code is signed with multiple signatures, permissions granted are additive inthat the code is given all permissions contained inall the matching entries. For example, if code signedwith key A gets permission X and code signed bykey B gets permission Y, then code signed by bothA and B gets permissions X and Y.Verication of signed code uses a new package ofcerticate java.security.cert that fully supportsthe processing of X.509v3 certicates.The policy within the Java runtime is set via aprogramming API. We also specify an external policy representation in the form of an ASCII policyconguration le. Such a le essentially contains alist of entries, each being a pair, consisting of a codesource and its permissions. In such a le, a publickey is signied by an alias  the string name of thesigner  where we provide a separate mechanism tocreate aliases and import their matching public keysand certicates.2.2 PermissionWe have introduced a new hierarchy of typedand parameterized access permissions that is rootedby an abstract class java.security.Permission.Other permissions are subclassed either from thePermission class or one of its subclasses, and generally should belong to their own packages.For example, the permission representing lesystem access is located in the Java IO package, as java.io.FilePermission. Other permission classes that are introduced in JDK1.2 includejava.net.SocketPermission for access to networkresources, java.lang.RuntimePermission for access to runtime system resources such as properties,and java.awt.AWTPermision for access to windowing resources. In other words, access methods andparameters to most of the controlled resources, including access to Java properties and packages, arerepresented by the new permission classes.A crucial abstract method in the Permissionclass that needs to be implemented for each newclass of permission is the implies method. Basically, a.impliesb  true means that, if one isgranted permission a, then one is naturally grantedpermission b. This is the basis for all access controldecisions.For convenience, we also created abstract classesjava.security.PermissionCollection andjava.security.Permissions that are subclassesof the Permission class. PermissionCollectionis a collection i.e., a set that allows duplicates of Permission objects for a categorysuch as FilePermission, for ease of grouping.Permissions is a heterogeneous collection of collections of Permission objects.Not every permission class must support a corresponding collection class. When they do, it is crucialto implement the correct semantics for the impliesmethod in the corresponding permission collectionclasses. For example, FilePermission can get addedto the FilePermissionCollection object in anyorder, so the latter must know how to correctly compare a permission with a permission collection.Typically, each permission consists of a target andan action thus, informally, a permission implies another if and only if both the target and the action ofthe former respectively implies those of the latter.Take FilePermission for example. There aretwo kinds of targets a directory and a le. Thereare four ways to express a le target path,pathfile, path, and path. path denotesall les and directories in the directory path, andpath denotes all les and directories under thesubtree of the le system starting at path. The actions include read, write, execute, and delete.Therefore, read le tmpabc is a permission,and can be created using the following Java codep  new FilePermissiontmpabc, readPermission tmp, read implies permissiontmpabc, read, but not vice versa. Permissionhomegong, read,write implies permissionhomegongpublic htmlindex.html, read.In the case of SocketPermission, a net targetconsists of an IP address and a range of port numbers. Actions include connect, listen, accept,and others. One SocketPermission implies anotherif and only if the former covers the same IP addressand the port numbers for the same set of actions.Applications are free to add new categories of permissions. Note that a piece of Java code can create any number of permission objects, but such actions do not grant the code the corresponding accessrights. What matters is that permission objects theJava runtime system associates with the Java codethrough the concept of protection domains.2.3 Protection DomainA new class java.security.ProtectionDomainis packageprivate, and is transparent to most Javadevelopers. It serves as a useful level of indirection in that permissions are granted to protectiondomains, to which classes and objects belong, andnot to classes and objects directly.2 In other words,a domain can be scoped by the set of objects thatcorrespond to a principal, where a principal is anentity in the computer system to which authorizations and as a result, accountability are granted16. The Java sandbox in JDK1.0.2 is one exampleof a protection domain with a xed boundary.In JDK1.2, protection domains are created ondemand, based on code source. Each class belongsto one and only one domain. The Java runtimemaintains the mapping from code classes and objects to their protection domains and then to theirpermissions.Protection domain also serves as a convenientpoint for grouping and isolation between units ofprotection within the Java runtime. For example, itis possible to separate dierent domains from interacting with each other. Any permitted interactionmust be either through system code or explicitly allowed by the domains concerned.The above point brings up the issue of accessibility, which is orthogonal to security. In the Java virtual machine, a class is distinguished by itself plusthe class loader instance that loaded the class. Inother words, a class loader denes a distinct namespace and can be used to isolate and protect codewithin one protection domain if the loader refuses toload code from dierent domains and with dierentpermissions.On the other hand, it is sometimes desirable toallow code from dierent domains to interact witheach other  for example, in the case of an application made up from Java Beans signed by dierent public keys, the beans should be able to access each other which is the purpose of the application although the runtime environment mayinsist that dierent beans are loaded into dierentdomains. The AppletClassLoader class used bythe appletviewer in JDK1.2 will load classes fromdierent domains.One protection domain is special the system domain, which consists of system code that is loadedwith a null class loader basically all classes locatedon CLASSPATH and is given special privileges. Itis important that all protected external resources,such as the le system, the networking facility, andthe screen and keyboard, are directly accessible onlyvia system code.2In the future, protection domains can be further characterized by user authentication and delegation so that thesame code could obtain dierent permissions when runningon behalf of of dierent principals.2.4 DomainBased Access ControlThe decision of granting access to controlled resources can only be made within the right context,which must provide answers to questions such aswho is requesting what, on whose behalf. Often, a thread is the right context for access control.Less frequently, access control decisions have to becarried out among multiple threads that must cooperate in obtaining the right context information.This section focuses on the former, as it is the mostcommon case encountered in building JDK1.2.A thread of execution may occur completelywithin a single protection domain i.e., all classesand objects involved in the thread belong to theidentical protection domain or may involve multiple domains such as an application domain and alsothe system domain.For example, an application that prints a messageout will have to interact with the system domainthat is the only access point to an output stream.In this case, it is crucial that at any time the application domain does not gain additional permissionsby calling the system domain. Otherwise, there canbe security serious implications.In the reverse situation where a system domain invokes a method from an application domain, such aswhen the AWT system code calls an applets paintmethod to display the applet, it is again crucial thatat any time the eective access rights are the sameas current rights enabled in the application domain.In other words, a less powerful domain cannotgain additional permissions as a result of calling amore powerful domain whereas a more powerful domain must lose its power when calling a less powerful domain. This principle of least privilege is applied to a thread that transverses multiple protection domains.Up to JDK1.1, any code that performs an access control decision relies on explicitly knowingits callers status i.e., being system code or appletcode. This is fragile in that it is often insucientlysecure to know only the callers status but also thecallers callers status and so on. At this point, placing this discovery process explicitly on the typicalprogrammer becomes a serious burden, and can beerrorprone.To relieve this burden by automating the access checking process, JDK1.2 introduces a newclass java.security.AccessController. Insteadof trying to discover the history of callers andtheir status within a thread, any code can querythe access controller as to whether a permissionwould succeed if performed right now. This isdone by calling the checkPermissionmethod of theAccessController class with a Permission objectthat represents the permission in question.By default, the access controller will returnsilently only if all callers in the thread history e.g., all classes on the call stack belong to domains that have been granted thesaid permission. Otherwise, it throws ajava.security.AccessControlException, whichis a subclass of java.lang.SecurityException,usually printing the reason of denial.This default behavior is obviously the most secure but is limiting in some cases where a piece ofcode wants to temporarily exercise its own permissions that are not available directly to its callers.For example, an applet may not have direct accessto certain system properties, but the system codeservicing the applet may need to obtain some properties in order to complete its tasks.For such exceptional cases, we provide a primitive, via static methods beginPrivileged andendPrivileged in the AccessController class. Bycalling beginPrivileged, a piece of code is tellingthe Java runtime system to ignore the status of itscallers and that it itself is taking responsibility inexercising its permissions.To summarize, a simple and prudent rule ofthumb for calculating permissions is the following The permission of an execution thread is theintersection of the permissions of all protectiondomains transversed by the execution thread. When some code calls the beginPrivilegedprimitive, the permission of the executionthread includes a permission if it is allowed bythe said codes protection domain and by allprotection domains that are called or entereddirectly or indirectly subsequently. When a new thread is created, it inherits fromits parent thread the current security contexti.e., the set of protection domains present inthe parent at child creation time. This inheritance is transitive.In following the above rule, the access controller examines the call history and the permissionsgranted to the relevant protection domains, and toreturn silently if the request is granted or throw asecurity exception if the request is denied.There are two obvious strategies for implementing this access control rule. In an eager evaluation implementation, whenever a thread enters anew protection domain or exits from one, the set ofeective permissions is updated dynamically. Thebenet is that checking whether a permission is allowed is simplied and can be faster in many cases.The disadvantage is that, because permission checking occurs much less frequently than crossdomaincalls, a large percentage of permission updates maybe useless eort.JDK1.2 employs a lazy evaluation implementation where, whenever a permission checking is requested, the thread state as reected by the current thread stack or its equivalent is examined anda decision is reached to either deny or grant theparticular access requested. One potential downside of this approach is performance penalty at permission checking time, although this penalty wouldhave been incurred anyway in the eager evaluation approach albeit at earlier times and spreadout among each crossdomain call. In our implementation, performance of this algorithm is quiteacceptable3, so we feel that lazy evaluation is themost economical approach overall.2.5 Revised SecurityManagerUp to JDK1.1., when access to a critical systemresource such as le IO and network IO is requested, the resource handling code directly or indirectly invokes the appropriate check method onthe installed java.lang.SecurityManager to evaluate the request and decide if the request should begranted or denied.JDK1.2 maintains backward compatibility in thatall check methods in SecurityManager are stillsupported, but we have changed their default implementations to invoke AccessController, whenever feasible, with the appropriate permission object. This class, which has been abstract up toJDK1.1.x, is made concrete in JDK1.2.To illustrate the usage of the new access control mechanism, let us examine a small example forchecking le access. In earlier versions of the JDK,the following code is typicalClassLoader loader this.getClass.getClassLoaderif loader  null SecurityManager security System.getSecurityManagerif security  null security.checkReadpathfile3For details of the implementation of protection domain,and a discussion on performance and optimization techniques, please refer to 7.Under the new architecture, the check typicallyshould be invoked whether or not there is a classloader associated with a calling class. It should besimplyFilePermission p new FilePermissionpathfile, readAccessController.checkPermissionpNote that there are legacy cases for example, insome browsers where whether there is an instanceof the SecurityManager class installed signies oneor the other security state that may result in different actions being taken. We currently do notchange this aspect of the SecurityManager usage,but would encourage application developers to usethe techniques introduced in this new version of theJDK in their future programming.Moreover, we have not revised system code toalways call AccessController and not checking for the existence of a classloader, becauseof the potential of existing software subclassingthe SecurityManager and customizing these checkmethods.To use the privilege primitive, the following codesample should be followedtry AccessController.beginPrivilegedsome sensitive code finally AccessController.endPrivilegedSome important points about being privileged.Firstly, this concept only exists within a singlethread. That is, a protection domain being so privileged is scoped by the thread within which the callto become privileged is made. Other threads are notaected.Secondly, in this example, the body of code withintrynally is privileged. However, it will lose itsprivilege if it calls from within the privileged blockcode that is less privileged.Moreover, although it is a good idea to usebeginPrivileged and endPrivileged in pairs asthis clearly scopes the privileged code, we haveto deal with the case when endPrivileged is notcalled, because forgetting to disable a privilege canbe very dangerous. To reduce or eliminate the risk,we have put in additional mechanism to safe guardthis primitive.2.6 Secure Class LoadingThe class java.security.SecureClassLoader isa concrete implementation of the abstract classjava.lang.ClassLoader that loads classes andrecords the protection domains they belong to. Italso provides methods to load a class from bytecode stored in a byte array, an URL, and anInputStream. This class can be extended to includenew methods, but most existing methods are nal,as this class is signicant for security.All applets and applications except for systemclasses are loaded by a SecureClassLoader eitherdirectly or indirectly in which case, it is probablyloaded by another classloader that itself is loadedby a SecureClassLoader.SecureClassLoaders loadClass methods enforce the following search algorithm where, if thedesired class by the given name is not found, thenext step is taken. If the class is still not foundafter the last step, a ClassNotFoundException isthrown.1. See if the class is already loaded and resolved2. See if the class requested is a system class. if so,load the class with the null system classloader.3. Attempt to nd the class in a customizable way,using a nonnal method findAppClass, whichby default will try to nd the class in a secondlocal search path that is dened by a propertynamed java.app.class.path.Note that in step 2, all classes on the searchpath CLASSPATH are treated as system classes,whereas in step 3, all classes on the search pathjava.app.class.path are considered nonsystemclasses.4Programmers who must write class loadersshould, whenever feasible, subclass from the concrete SecureClassLoader class, and not directlyfrom the abstract class java.lang.ClassLoader.A subclass of SecureClassLoadermay choose tooverwrite the findAppClassmethod in order to customize class searching and loading. For example,the AppletClassLoader caches all raw class materials found inside a JAR le. Thus, it is reasonablefor the AppletClassLoader, which is a subclass ofthe SecureClassLoader, to use findAppClass tolook into its own cache. A class introduced in sucha fashion is guaranteed not to be a system class,and is subjected to the same security policy as itsloading class.4The path java.app.class.path is currently specied ina platform dependent format. There might be a future needto develop a generic Path class that not only provides platform independentpath names but also makes dynamicalpathmanipulation easier.Often a class may refer to an another class andthus cause the second class belonging to anotherdomain to be loaded. Typically the second class isloaded by the same classloader that loaded the rstclass, except when either class is a system class, inwhich case the system class is loaded with a nullclassloader.2.7 Extending Security to ApplicationsTo apply the same security policy to applicationsfound on the local le system, we provide a new classjava.security.Main, which can be used in the following fashion in place of the traditional commandjava application to invoke a local applicationjava java.security.Main applicationThis usage makes sure that any local application on the java.app.class.path is loaded witha SecureClassLoader and therefore is subjected tothe security policy that is being enforced. Clearly,nonsystem classes that are stored on the localle system should all be on this path, not on theCLASSPATH.3 DiscussionIn this section, we discuss a number of open questions and possible improvement to the current architecture. But we start by discussing how a developeror user is impacted by the new architecture.3.1 Utilizing the New ArchitectureFor a user of the builtin appletviewer or a newversion of a browser that deploys this new securityarchitecture, the user can continue to do things thesame way as before, which means that the samepolicy in JDK1.1.x will apply.On the other hand, a power user can use thePolicyTool builtin for JDK1.2 or an equivalentone shipped with the browser to customize the security policy, thus utilizing the full benet of thenew security architecture. Such customization mayinvolve setting up a certicate store, which can bedone via the KeyTool.The typical application developer, in general,needs to do nothing special because, when the application is run on top of JDK1.2, the security featuresare invoked automatically. Except that the developer might want to use the builtin tools to packagethe resulting application into JAR les, and maychoose to digitally sign them.For a software library developer whose code controls certain resources, the developer may need toextend the existing permission class hierarchy tocreate applicationspecic permissions. The developer may also need to learn to use features providedby the AccessController class, such as the privilege primitive.3.2 Handling NonClass ContentWhen running applets or applications with signedcontent, the JAR and Manifest specications oncode signing allow a very exible format. Recallthat classes within the same archive can be unsigned, signed with one key, or signed with multiplekeys. Other resources within the archive, such asaudio clips and graphic images, can also be signedor unsigned.This exibility brings about the issue of interpretation. The following questions need to beanswered, especially when not all signatures aregranted the same privileges. Should images and audio clips be required to be signed with the same keyif any class in the archive is signed If images andaudio les are signed with dierent keys, can theybe placed in the same appletviewer or browserpage, or should they be sent to dierent viewersThese questions are not easy to answer, and require consistency across platforms and products tobe most eective. Our intermediate approach isto provide a simple answer  all images and audioclips are forwarded to be processed whether theyare signed or not. This temporary solution will beimproved once a consensus is reached.3.3 Enabling FineGrained PrivilegesThe privileged primitive discussed earlier in asense enables all permissions granted to a domain.We can contemplate to enrich the construct so thata protection domain can request to enable privilege for only some of its granted permissions. Thisshould further reduce the security impact of makinga programmingmistake. For example, the code segment below illustrates how to turn on the privilegeof only reading everything in the tmp directory.FilePermission p new FilePermissiontmp, readtry AccessController.beginPrivilegedpsome sensitive code finally AccessController.endPrivilegedp3.4 Extending Protection DomainsThe rst possibility is to subdivide the system domain. For convenience, we can think of the systemdomain as a single, big collection of all system code.For better protection, though, system code shouldbe run in multiple system domains, where each domain protects a particular type of resource and isgiven a special set of rights. For example, if le system code and network system code run in separatedomains, where the former has no rights to the networking resources and the latter has no rights to thele system resources, the risks and consequence ofan error or security aw in one system domain ismore likely to be conned within its boundary.Moreover, protection domains currently are created transparently as a result of class loading. Itmight be desirable to provide explicit primitives tocreate a new domain. Often, a domain supports inheritance in that a subdomain automatically inherits the parent domains security attributes, exceptin certain cases where the parent further restricts orexpands the subdomain explicitly.Finally, each domain system or application mayalso implement additional protection of its internalresources within its own domain boundary. Becausethe semantics of such protection is unlikely to bepredictable by the JDK, the protection system atthis level is best left to the application developers. Nevertheless, JDK1.2 provides SignedObject,Guard, and GuardedObject classes that simplify adevelopers task.4 Summary and Future WorkThis paper gives an overview of the motivationand the new security architecture implemented inJDK1.2. Although we do not break new theoretical ground in computer security, we attemptto distill the best practices from research in thepast four decades, such as clear separation betweensecurity policy and implementation, and engineerthem into a widely deployed programming platform.Our implementation has a number of novel aspectsthat demonstrate beyond the doubt the eciencyof languagebased protection mechanisms. The success of this development eort also highlights theexcellent extensibility of the Java platform.In future releases, we are investigating user authentication techniques, an explicit principal concept, a general mechanism for crossprotectiondomain authorization, and the runningonbehalfstyle delegation. We are also working towards additional features such as arbitrary grouping of permissions, the composition of security policies, andresource consumption management, which is relatively easy to implement in some cases, e.g., whenlimiting the number of windows any application canpop up at any one time, but more dicult in othercases, e.g., when limiting memory or le system usage.AcknowledgmentsAdditional members of the JavaSoft securitygroup, including Gigi Ankeny, Charlie Lai, JanLuehe, and Je Nisewanger, made signicant contributions during the course of the design and implementation of new security features in JDK1.2.Other members of the JavaSoft community, notably Josh Bloch, Sheng Liang, Roger Riggs, NakulSaraiya, and Bill Shannon, provided invaluable insight, detailed reviews, and much needed technicalassistance.We are grateful for support from Dick Neiss, JonKannegaard, and Alan Baratz, for technical guidance from James Gosling, Graham Hamilton, andJim Mitchell, and for indispensable collaborationfrom the testing and documentation groups. Wereceived numerous suggestions from our corporatepartners and licensees, whom we could not fully listhere.References1 B. N. Bershad, S. Savage, P. Pardyak, E. G.Sirer, M. Fiuchynski, D. Becker, S. Eggers, andC. Chambers. Extensibility, Safety, and Performance in the SPIN Operating System. InProceedings of the 15th ACM Symposium onOperating Systems Principles, pages 251266,Colorado, December 1995. Published as ACMOperating System Review 295251266, 1995.2 J.S. Chase, H.M. Levy, M.J. Feeley, and E.D.Lazowska. Sharing and Protection in a SingleAddressSpace Operating System. ACM Transactions on Computer Systems, 124271307,November 1994.3 D. Dean. The Security of Static Typing withDynamic Linking. In Proceedings of the 4thACM Conference on Computer and Communications Security, pages 1827, Zurich, Switzerland, April 1997.4 D. Dean, E.W. Felten, and D.S. Wallach. JavaSecurity From HotJava to Netscape and Beyond. In Proceedings of the IEEE Symposiumon Research in Security and Privacy, pages190200, Oakland, California, May 1996.5 M. Gasser. Building a Secure Computer System. Van Nostrand Reinhold Co., New York,1988.6 L. Gong. Java Security Present and NearFuture. IEEE Micro, 1731419, MayJune1997.7 L. Gong and R. Schemers. Implementing Protection Domains in the JavaTM Development Kit1.2. In Proceedings of the Internet Society Symposium on Network and Distributed System Security, San Diego, California, March 1998.8 J. Gosling, Bill Joy, and Guy Steele. TheJava Language Specication. AddisonWesley,Menlo Park, California, August 1996.9 A.K. Jones. Protection in Programmed Systems. Ph.D. dissertation, CarnegieMellon University, Pittsburgh, PA 15213, June 1973.10 B.W. Lampson. Protection. In Proceedingsof the 5th Princeton Symposium on Information Sciences and Systems, Princeton University, March 1971. Reprinted in ACM OperatingSystems Review, 811824, January, 1974.11 T. Lindholm and F. Yellin. The Java VirtualMachine Specication. AddisonWesley, MenloPark, California, 1997.12 P.G. Neumann. ComputerRelated Risks.AddisonWesley, Menlo Park, California, 1995.13 U.S. General Accounting Oce. InformationSecurity Computer Attacks at Departmentof Defense Pose Increasing Risks. TechnicalReport GAOAIMD9684, Washington, D.C.20548, May 1996.14 S. Ritchie. Systems Programming in Java.IEEE Micro, 1733035, MayJune 1997.15 J.H. Saltzer. Protection and the Control of Information Sharing in Multics. Communicationsof the ACM, 177388402, July 1974.16 J.H. Saltzer and M.D. Schroeder. The Protection of Information in Computer Systems.Proceedings of the IEEE, 63912781308,September 1975.17 M.D. Schroeder. Cooperation of MutuallySuspicious Subsystems in a Computer Utility.Ph.D. dissertation, Massachusetts Institute ofTechnology, Cambridge, MA 02139, September1972.18 M. I. Seltzer, Y. Endo, C. Small, and K. A.Smith. Dealing with Disaster Surviving Misbehaved Kernel Extensions. In Proceedings ofthe 2nd USENIX Symposium on Operating Systems Design and Implementation, pages 213227, Seattle, Washington, October 1996. Published as ACM Operating Systems Review, 30,special winter issue, 1996.19 T. Thorn. Programming Languages for MobileCode. ACM Cumpting Surveys, 293213239,September 1997.20 W.A. Wulf, R. Levin, and S.P. Harbison. HYDRAC.mmp  An Experimental ComputerSystem. McGrawHill, 1981.21 F. Yellin. Low Level Security in Java. In Proceedings of the 4th International World WideWeb Conference, Boston, Massachusetts, December 1995.
