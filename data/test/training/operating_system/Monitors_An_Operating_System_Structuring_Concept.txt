Monitors An Operating System StructuringConceptC.A.R HoareThe Queens University of BelfastReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.This is a digitized copy derived from an ACM copyrighted work. It is not guaranteed to be an accuratecopy of the authors original work.This paper develops BrinchHansens concept of a monitor as a method of structuring an operatingsystem. It introduces a form of synchronization, describes a possible rnctltotl of implementation interms of semaphorcs and gives a suitable proof rule. Illustrative examples include a single rcsourccscheduler, a bounded buffer, an alarm clock, a buffer pool, a disk head optimizer, and a version of theproblem of readers and writers.Key Words and Phrasesmonitors, operating systems,schcduling, mutual exclusion, synchronization, systemimplementation langua yes, structured multiprogrammingCR Categories4.31, 4.221. Introduction2. Interpretation3. Proof Rules4. Example Bounded Buffer5. Scheduled Waits6. Further Examples7. ConclusionMonitors An Operating System Structuring Concepthttpwww.acm.orgclassicsfeb96 1 von 2 01.06.1999 110132ReferencesMAC  96Feb12Monitors An Operating System Structuring Concepthttpwww.acm.orgclassicsfeb96 2 von 2 01.06.1999 110132Monitors An Operating System StructuringConcept1. IntroductionReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.A primary aim of an operating system is to share a computer installation among many programsmaking unpredictable demands upon its resources. A primary tusk of its designer is therefore toconstruct resource allocation or scheduling algorithms for resources of various kinds main store,drum store, magnetic tape handlers, consoles, etc.. In order to simplify his task, he should try toconstruct separate schedulers for each class of resource. Each scheduler will consist of a certainamount of local administrative data, together with some procedures and functions which are called byprograms wishing to acquire and release resources. Such a collection of associated data andprocedures is known as a monitor and a suitable notation can be based on the class notalion ofSIMULA67 6.monitorname monitor  begin ... declarations of data local to the monitor    procedure procname  formal parameters . . .       begin ... procedure body ... end      ... declarations of other procedures local to the monitor      ... initialization of local data of the monitor ...  endNote that the procedure bodies may have local data, in the normal way.In order to call a procedure of a monitor, it is necessary to give the name of the monitor as well as thename of the desired procedure, separating them by a dotmonitorname.procname.. actual parameters ...In an operating system it is sometimes desirable to declare several monitors with identical structureand behavior, for example to schedule two similar resources. In such cases, the declaration shownabove. will be preceded by the word class, and the separate monitors will be declared lo belong to this1. Introductionhttpwww.acm.orgclassicsfeb96introduction.html 1 von 4 01.06.1999 110140classmonitor 1, monitor 2 classnameThus the structure of a class of monitors is identical to that described for a data representation in 13,except for addition of the basic word monitor. BrinchHansen uses the word shared for the samepurpose 3.The procedures of a monitor are common to all running programs, in the sense that any program mayat any time attempt to call such a procedure. However, it is essential that only one program at a timeactually succeed in entering a monitor procedure, and any subsequent call must be held up until theprevious call has been completed. Otherwise, if two procedure bodies were in simulatenous execution,the effects on the local variables of the monitor could be chaotic. The procedures local to a monitorshould not access any nonlocal variables other than those local to the same monitor, and thesevariables of the monitor should be inaccessible from outside the monitor. If these restrictions areimposed, it is possible to guarantee against certain of the more obscure forms of timedependentcoding error and this guarantee could be underwritten hy a visual scan of the text of the program,which coulcl readily be automated in a compiler.Any dynamic resource allocator will sometimes need to delay a program wishing to acquire a resourcewhich is not currently available, and to resume that program after some other program has releasedthe resource required. We therefore need a wait operation, issued from inside a procedure of themonitor, which causes the calling program to be delayed and a signal operation, also issued frominside a procedure of the same monitor, which causes exactly one of the waiting programs to beresumed immediately. If there are no waiting programs the signal has no effect. In order to enableother programs to release resources during a wait, a wait operation must relinquish the exclusionwhich would otherwise prevent entry to the releasing procedure. However, we decree that a signaloperation be followed immediately by resumption of a waiting program, without possibility of anintervening procedure call from yet a third program. It is only in this way that a waiting program hasan absolute guarantee that it can acquire the resource just released hy the signalling program withoutany danger that a third program will interpose a monitor entry and seize the resource instead.In many cases, there may be more than one reason for waiting, and these need to be distinguished byboth the waiting and the signalling operation. We therefore introduce a new type of variable knownas a condition and the writer of a monitor should declare a variable of type condition for eachreason why a program might have to wait. Then the wait and signal operations should be preceded bythe name of the relevant condition variable, separated from it by a dotcondvariable.waitcondvariable.signalNote that a condition variable is neither true nor false indeed, it does not have any stored valueaccessible to the program. In practice, a condition variable will be represented by an initially emptyqueue of processes which are currently waiting on the condition but this queue is invisible both towaiters and signallers. This design of the condition variable has been deliberately kept as primitiveand rudimentary as possible, so that it may be implemented efficiently and used flexibly to achieve awide variety of effects. There is a great temptation to introduce a more complex synchronizationprimitive, which may be easier to use use many purposes. We shall resist this temptation for a while.1. Introductionhttpwww.acm.orgclassicsfeb96introduction.html 2 von 4 01.06.1999 110140As the simplest example of a monitor, we will design a scheduling algorithm for a single resource,which is dynamically acquired and releasecd by an unknown number of customer processes by callson proceduresprocedure acquireprocedure releaseA variable 1busy Booleandetermines whether or not the resource is in use. If an attempt is made to acquire the resource when itis busy, the attempting program must be delayed by waiting on a variablenonbusyconditionwhich is signalled by the next subsequent release. The initial value of busy is false. These designdecisions lead to the following code for the monitorsingle resourcemonitor begin busyBoolean      nonbusycondition  procedure acquire      begin if busy then nonbusy.wait              busy  true     end   procedure release      begin busy  false            nonbusy.signal     end  busy  false comment inital valueend single resourceNotes1. In designing a monitor, it seems natural to design the procedure headings, the data, the conditions,and the procedure bodies, in that order. All subsequent examples will be designed in this way.2. The acquire procedure does not have to retest that busy has gone false when it resumes after itswait, since the release procedure has guaranteed that this is so and as mentioned before, no otherprogram can intervene between the signal and the continuation of exactly one waiting program.3. If more than one program is waiting on a condition, we postulate that the signal operation willreactivate the longest waiting program. This gives a simple neutral queuing discipline which ensurcsthat every waiting program will eventually get its turn.4. The single resource monitor simulates a Boolcan semaphore 7 with acquire and release used forP and V respectively. This is a simple proof that the monitorcondition concepts are not in principleless powerful than semaphores, and that they can be used for all the same purposes.1. Introductionhttpwww.acm.orgclassicsfeb96introduction.html 3 von 4 01.06.1999 1101401 As in PASCAL 15, a variable declaration is of the form variable identifiertypeNext Section 2. Interpretation1. Introductionhttpwww.acm.orgclassicsfeb96introduction.html 4 von 4 01.06.1999 110140Monitors An Operating System StructuringConcept2. InterpretationReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.Huving proved that semaphores can be implemented by a monitor, the next task is to prove thatmonitors can be implemented by semaphores.Obviously, we shall require for each monitor a Boolean semaphore mutex to ensure that the bodiesof the local procedures exclude each other. The semaphore is initialized to 1 a Pmutex must beexecuted on entry to each local proccdure, and a Vmutex must usually be executed on exit from it.When a process signals a condition on which another process is waiting, the signalling process mustwait until the resumed process permits it to proceed. We therefore introduce for each monitor asecond semaphore urgent initialized to 0, on which signalling processes suspend themselves bythe operation Purgent. Before releasing exclusion, each process must test whether any other processis waiting on urgent, and if so, must release it instead by a Vurgent instruction We therefore need tocount thc number of processes waiting on urgent, in an integer urgentcount initially zero. Thuseach exit from aprocedure of a monitor should be codedif urgentcount  0 then Vurgent else VmutexFinally, for each condition local to the monitor, we introduce a semaphore condsem initialized to0, on which a process desiring to wait suspends itself by a Pcondsem operation. Since a processsignalling this condition needs to know whether anybody is waiting, we also need a count of tjenumber of waiting processes held in an integer variable condcount initially 0. The operationcond.wait may now be implemented as follows recall that a waiting program must releaseexclusion before suspending itselfcondocunt  condcount  1if urgentcount  0 then Vurgent else VmutexPcondsem2. Interpretationhttpwww.acm.orgclassicsfeb96interpretation.html 1 von 3 01.06.1999 110149comment This will always waitcondcount  condcount  1The signal operation may be codedurgentcount  urgentcount  1if condcount  0 then Vcondsem Purgent urgentcount  urgentcount  1In this implementation, possession of the monilor is regarded as a privilege which is explicilly passedfrom one process to another. only when no one further wants the privilege is mutex finally released.This solution is not intended to correspond to recommended style in the use of semaphores. Theconcept of a conditionvariable is intended as a substitute for semaphores, and has its own style ofusage, in the same way that while loops or coroutines are intended as a substitute for jumps.In many cases, the generality of this solution is unnecessary, and a significant improvement inefficiency ispossible.1. When a procedure body in a monitor contains no wait or signal, exit from the body can be coded bya simple Vmutex since urgentcount cannot have changed during the execution of the body.2. If a cond.signal is the last operation of a procedure body, it can be combined with monitor exit asfollows     if condcount  0 then Vcondsem else if urgentcount  0 then Vurgent                         else Vmutex3. If there is no other wait or signal in the procedure body, the second line shown above can also beomitted.4. If every signal occurs as the last operation of its procedure body, the variables urgentcount andurgent can be omitted, together with all operations upon them. This is such a simplification that OJ.Dahl suggests that signals should always be the last operation of a monitor procedure in fact, thisrestriction is a very natural one, which has been unwittingly observed in all examples of this paper.Significaut improvements in efficiency may also be obtained by avoiding the use of semaphores, andby implementing conditions directly in hardware, or at the lowest and most uninterruptible level ofsoftware e.g. supervisor mode. In this case, the following optimizations are possible.1. urgentcount and condcount can be abolished, since the fact that someone is waiting can beestablished by examining the representation of the semaphore, which cannot change surreptitiouslywithin noninterruptible mode.2. Many monitors are very short and contain no calls to other monitors. Such monitors can beexecuted wholly in noninterruptible mode, using, as it were, the common exclusion mechanismprovided by hardware. This will often involve less time in noninterruptible mode than the2. Interpretationhttpwww.acm.orgclassicsfeb96interpretation.html 2 von 3 01.06.1999 110149establishment of separate exclusion for each monitor.I am grateful to J. Bezivin, J. Horning, and R.M. McKeag for assisting in the discovery of thisalgorithm.Next Section 3. Proof RulesPrevious Section 1. Introduction2. Interpretationhttpwww.acm.orgclassicsfeb96interpretation.html 3 von 3 01.06.1999 110149Monitors An Operating System StructuringConcept3. Proof RulesReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.The analogy between a monitor and a data representation has been noted in the introduction. Themutual exclusion on the code of a monitor ensures that procedure calls follow each other in time, justas they do in sequential programming and the same restrictions are placed on access to nonlocal data.These are the reasons why the same proof rules can be applied to monitors as to data representations.As with a data representation, the programmer may associate an invariant g with the local data of amonitor, to describe some contlition which will be true of this data before and after every procedurecall. g must also be made true after initialization of the data, and before every wait instructionotherwise the next following procedure call will not find the local data in a state which it expects.With each condition variable b the programmer may associate an assertion B which describes thecondition under which a program writing on b wishes to be resumed. Since other programs mayinvoke a monitor procedure during a wait, a waiting program must ensure that the invariant g for themonitor is true beforehand. This gives the proof rule for waitsg b.wait gBSince a signal can cause immediate resumption of a waiting program, the conditions gB which areexpected by that program must be made true before the signal and since B may be made false againby the resumed program, only g may be assumed true afterwards. Thus the proof rule for a signal isgBb.signalgThis exhibits a pleasing symmetry with the rule for waiting.The introduction of condition variables makes it possible to write monitors subject to the risk ofhttpwww.acm.orgclassicsfeb96proofrules.html 1 von 2 01.06.1999 110154deadly embrace 7. It is the responsibility of the programmer to avoid this risk, together with otherscheduling disasters thrashing, indefinitely repeated overtaking, etc. 11. Assertionoriented proofmethods cannot prove absence of such risks perhaps it is better to use less formal methods for suchproofs. Finally, in many cases an operating system monitor constructs some virtual resource whichis used in place of actual resources by its customer programs. This virtual resource is an abstractionfrom the set of local variables of the monitor. The program prover should therefore define thisabstraction in terms of its concrete representation, and then express the intended effect of each of theprocedure bodies in terms of the abstraction. This proof method is described in detail in 13.Next Section 4. Example Bounded BufferPrevious Section 2. Interpretationhttpwww.acm.orgclassicsfeb96proofrules.html 2 von 2 01.06.1999 110154Monitors An Operating System StructuringConcept4. Example Bounded BufferReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.A bounded buffer is a concrete representation of the abstract idea of a sequence of portions. Thesequence is accessible to two programs running in parallel the first of these the producer updates thesequence by appending a new portion x at the end and the second the consumer updates it byremoving the first portion. The initial value of the sequence is empty. We thus require two operations1 appendx portionwhich should be equivalent to the abstract operation   sequence  sequence  xwhere x is the sequence whose only item is x and n denotes concatenation of two sequences.2 removeresult xportionwhich should be equivalent to the abstract operations    x  firstsequence sequence  restsequencewhere first selects the first item of a sequence and rest denotes the sequence with its first itemremoved. Obviously, if the sequence is empty, first is undefined and in this case we want to ensurethat the consumer waits until the producer has made the sequence nonempty.We shall assume that the amount of time taken to produce a portion or consume it is large incomparison with the time taken to append or remove it from the sequence. We may therefore bejustified in making a design in which producer and consumer can both update the sequence, but notsimultaneously.The sequence is represented why an array4. Example Bounded Bufferhttpwww.acm.orgclassicsfeb96boundedbuffer.html 1 von 4 01.06.1999 110201buffer array 0. .N  1 of portionand two variables1  lastpointer 0..N  1which points to the buffer position into which the next append operation will put a new item, and2  count0.. Nwhich always holds the length of the sequence initially 0.We define the function  seq b,l,c df if c  0 then empty                  else seqb,l 1,c  1  bl  1where the circled operations are taken modulo N. Note that if c not  0,   firstseqb,l,c  bl cand   restseqb,l,c  seqb,l,c  1The definition of the abstract sequence in terms of its concrete representation may now be given   sequence df seqbuffer, lastpointer, countless formally, this may be written   sequence  df bufferlastpointer count,               bufferlastpointer count 1,               ...,               bufferlastpointer 1Another way of conveying this information would be by an example and a picture, which would beeven less formal.The invariant for the monitor is    0  count  N  0  lastpointer  N  1There are two reasons for waiting, which must represented by condition variables    nonemptyconditionmeans that the count is greater than 0, and    nonfullcondition4. Example Bounded Bufferhttpwww.acm.orgclassicsfeb96boundedbuffer.html 2 von 4 01.06.1999 110201means that the count is less than N.With this constructive approach to the design 8, it is relatively easy to code the monitor withouterror.bounded buffermonitor   begin bufferarray O..N  1 of portion          lastpointer O..N  1          count O..N         nonempty,nonfullcondition   procedure appendxportion      begin if count  N then nonfull.wait             note 0  count  N            bufferlastpointer  x            lastpointer  lastpointer o l            count  count  1             nonempty.signal      end append    procedure removeresult x portion      begin if count  0 then nonempty.wait             note 0  count  N            x  bufferlastpointer o count            nonfull.signal      end remove   count  0 lastpointer  0  end bounded bufferA formal proof of the correctness of this monitor with respect to the stated abstraction and invariantcan be given if desired by techniques described in 13. However, these techniques seem not capableof dealing with subsequent examples of this paper.Singlebuffered input and output may be regarded as a special ease of the bounded buffer with N  1.In this ease, the array can be replaced by a single variable, the lastpointer is redundant, and we getiostream monitor begin buffer portion       count 0..1            nonmepty,nonfullcondition procedure appendxportion   begin if count  1 then nonfull.wait     buffer  x     count  I     nonempty.signal   end append procedure removeresult xportion   begin if count  0 then nonempty.wait         x  buffer         count  0         nonfull.signal   end remove4. Example Bounded Bufferhttpwww.acm.orgclassicsfeb96boundedbuffer.html 3 von 4 01.06.1999 110201 count  O end iostreamIf physical output is carried out by a separate special purpose channel, then the interrupt from thechannel should simulate a call of iostream. removex and similarly for physical input, simulating acall of iostream..appendx.Next Section 5. Scheduled WaitsPrevious Section 3. Proof Rules4. Example Bounded Bufferhttpwww.acm.orgclassicsfeb96boundedbuffer.html 4 von 4 01.06.1999 110201Monitors An Operating System Structuring Concept5. Scheduled WaitsReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright  1974,Association for Computing Machinery Inc.Up to this point, we have assumed that when more than one program is waiting for the same condition, asignal will cause the longest waiting program to he resumed. This is a good simple scheduling strategy, whichprecludes indefinite overtaking of a waiting process.However, in the design of an operating system, there are many cases when such simple scheduling on the basisof firstcomefirstserved is not adequate. In order to give a closer control over scheduling strategy, weintroduce a further feature of a conditional wait, which makes it possible to specify as a parameter of the waitsome indication of the priority of the waiting program, e.g.busy.wait pWhen the condition is signalled, it is the program that specilied the lowest value of p that is resumed. In usingthis facility, the designer of a monitor must take care to avoid the risk of indefinite overtaking and often it isadvisable to make priority a nondecreasing function of the time at which the wait commences.This introduction of a scheduled wait concedes to the temptation to make the condition concept moreelaborate. The main justifications areI. It has no effect whatsoever on the logic of a program, or on the formal proof rules. Any program whichworks without a scheduled wait will work with it, but possibly with better timing characteristics.2. The automatic ordering of the queue of waiting processes is a simple fast scheduling technique, exceptwhen the queue is exceptionally long  and when it is, central processor time is not the major bottleneck.3. The maximum amount of storage required is one word per process. Without such a builtin schedulingmethod, each monitor may have to allocate storage proportional to the number of its customers the alternativeof dynamic storage allocation in small chunks is unattractive at the low level of an operating system wheremonitors are found.I shall yield to one further temptation, to introduce a Boolean function of condilionscondname.queue5. Scheduled Waitshttpwww.acm.orgclassicsfeb96schedwaits.html 1 von 2 01.06.1999 110206which yields the value true if anyone is waiting on condname and false otherwise. This can obviously beeasily implementecl by a couple of instructions, and affords valuable information which could otherwise beobtained only at the expense of extra storage, time, and trouble.A trivially simple example is an alarmclock monitor, which enables a calling program to delay itself for astated number n of timeunits, or ticks. There are two entriesprocedure wakemeninlegerprocodure tickThe second of these is invoked by hardware e.g. an interrupt at regular intervals, say ten times per second.Local variables arenowintegerwhich records the current time initially zero andwakeup condition on which sleeping programs wait. But the alarmsetting at which these programs will be aroused is known atthe time when they start the wait and this can be used to determine the correct sequence of waking up.alarmclockmonitorbegin nowinteger           wakeupcondition  procedure wakemeninteger    begin alarmsettinginteger      alarmsetting  now  n      while now  alarmsetting do wakeup.waitalarmsetting      wakeup.signal      comment In case the next process is due to wake up at the same time    end  procedure tick    begin now  now  1      wakeup.signal        end  now  0end alarmclockIn the program given above, the next candidate for wakening is actually woken at every tick of the clock. Thiswill not matter if the frequency of ticking is low enough, and the overhead of an accepted signal is not toohigh.I am grateful to A. Ballard and J. Horning for posing this problem.Next Section 6. Further ExamplesPrevious Section 4. Example Bounded Buffer5. Scheduled Waitshttpwww.acm.orgclassicsfeb96schedwaits.html 2 von 2 01.06.1999 110206Monitors An Operating System Structuring Concept6. Further ExamplesReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright  1974, Association forComputing Machinery Inc.In proposing a new feature for a high level language it is very difficult to make a convincing case that the feature will be botheasy to use efficiently and easy to implement efficiently. Quality of implementation can be proved by a single good example,but ease and efficiency of use require a great number of realistic examples otherwise it can appear that the new feature hasbeen specially designed to suit the examples, or vice versa. This section contains a number of additional examples of solutionsof familiar problems. Further examples may be found in 14.6.1 Buffer AllocationThe bounded buffer described in Section 4 was designed to be suitable only for sequences with small portions, for example,message queues. If the buffers contain high volume information for example, files for pseudo offline input and output, thebounded buffer may still be used to store the addresses of the buffers which are being used to hold the information. In thisway, the producer can be filling one buffer while the consumer is emptying another buffer of the same sequence. But thisrequires an allocator for dynamic acquisition and relinquishment of buffer addresses.These may be declared as a typetype bufferaddress  1..Bwhere B is the number of buffers available for allocation. The buffer allocator has two entriesprocedure acquire result bbufferaddresswhich delivers a free buffer address b andprocedure releaseb bufferaddresswhich returns a bufferaddress when it is no longer required. In order to keep a record of free buffer addresses the monitorwill needfreepoolpowerset bufferaddresswhich uses the PASCAL powerset facility to define a variable whose values range over all sets of buffer addresses from theempty set to the set containing all buffer addresses. It should be implemented as a bitmap of B consecutive bits, where the ithbit is 1 if and only if i is in the set. There is only one condition variable needednonemptycondition which means that freepool  empty. The code for the allocator isbuffer allocator monitor begin freepoolpowerset bufferaddress      nonemptycondition   procedure acquire result bbufferaddress 6. Further Exampleshttpwww.acm.orgclassicsfeb96furtherexamples.html 1 von 5 01.06.1999 110220    begin if freepool  empty then nonempty.wait       b  firstfreepool       comment Any one would do       freepool  freepool   b        comment Set subtraction     end acquire   procedure releasebbufferaddress     begin freepool  freepool   b       nonempty.signal    end release  freepool  all buffer addresses end buffer allocatorThe action of a producer and consumer may be summarizedproducer begin bbufferaddress ...            while not finished do              begin bufferallocator.acquireb               ... fill buffer b ...               bounded buffer.appendb              end ...          end producerconsumer begin bbufferaddress ...            while not finished do              begin bounded buffer.removeb                ...                   ... empty buffer b ...                buffer allocator.releaseb              end          end consumerThis buffer allocator would appear to be usable to share the buffers among several streams, each with its own producer and itsown consumer, and its own instance of a bounded buffer monitor. Unfortunately, when the streams operate at widely varyingspeeds and when the freepool is empty the scheduling algorithm can exhibit persistent undesirable behavior If two producersare competing for each buffer as it becomes free a firstcomefirstserve discipline of allocation will ensure apparently fairlythat each gets alternate buffers and they will consequently begin to produce at equal speeds. But if one consumer is a 1000linesmin printer unti the other is a 10 linesmin teletype the faster consumer will be eventually reduced to the speed of theslower, since it cannot forever go faster than its producer. At this stage nearly all buffers will belong to the slower stream, sothe situation could take a long time to clear.A solution to this is to use a scheduled wait, to ensure that in heavy load conditions the available buffers will be sharedreasonably fairly between the streams that are competing for them. Of course, inactive streams need not be considered, andstreams for which the consumer is currently faster than the producer will never ask for more than two buffers anyway. In orderto achieve fairness in allocation it is sufficient to allocate a newly freed buffer to that one among the competing producerswhose stream currently owns fewest buffers. Thus the system will seek a point as far away from the undesirable extreme aspossible.For this reason the entries to the allocator should indicate for what stream the buffer is to be or has been used, and theallocator must keep a count of the current allocation to each stream in an arraycountarray stream of integerThe new version of the allocator isbufferallocator monitor  begin freepoolpowerset bufferaddress        nonemptycondition        countarray stream of integer    procedure acquireresult bbufferaddress sstream      begin if freepool  empty then nonempty.waitcounts        counts  counts  1        b  firstfreepool6. Further Exampleshttpwww.acm.orgclassicsfeb96furtherexamples.html 2 von 5 01.06.1999 110220        freepool  freepool  b      end acquire    procedure releasebbufferaddress sstream      begin counts  counts  1        freepool  freepool  b        nonempty.signal      end    freepool  all buffer addresses    for sstream do counts  0  end bufferallocatorOf course, if a consumer stops altogether perhaps owing to mechanical failure. The producer must also be halted before it hasacquired too many buffers, even if no one else currently wants them. This can perhaps be most easily accomplished byappropriate fixing of the size of the bounded buffer for that stream andor by ensuring that at least two buffers are reserved foreach stream even when inactive. It is an interesting comment on dynamic resource allocation that as soon as resources areheavily loaded, the system must be designed to fall back toward a more static regime.I am grateful to E. W. Dijkstra for pointing out this problem and its solution 10.6.2 Disk Head SchedulerOn a moving disk, the time taken to move the heads increases monotonically with the distance traveled. If several programswish to move the heads, the average waiting that can be reduced by selecting first, the program which wishes to move them theshortest distance. But unfortunately this policy is subject to an instability since a program wishing to access a cylinder at oneedge of the disk can be indefinitely overtaken by programs operating at the other edge or the middle.A solution to this is to minimize the frequency of change of direction of movement of the heads. At any thee, the heads arekept movhig in a given direction, and they service the progran1 requesthig the nearest cylinder in that direction. If there is nosuch request, the direction changes, and the heads make another sweep across the surface of the disk. This may be called theelevator algorithm, since it simulates the behavior of a lift in a multistorey building. There are two entries to a disk headscheduler1  requestdestcylinderwhere    type cylinder  0..cylmax.which is entered by a program just before issuing the instruction to move the heads to cylinder dest.2  releasewhich is entered by a program when it has made all the transfers it needs on the current cylinder.The local data of the monitor must include a record of thc current headposition, headpos, the current direction of sweep, andwhether the disk is busy     headposcylinder     directionup,down     busyBooleanWe need two conditions, one for requests waiting for an upsweep and the other for requests waiting for a downsweepdischeadmonitorbegin headposcylinder     directionup,down     busyBoolean     upsweep,downsweepcondition   procedure requestdestcylinder      begin if busy then          if headpos  dest  headpos  dest  direction  up                  thenupsweep.waitdest6. Further Exampleshttpwww.acm.orgclassicsfeb96furtherexamples.html 3 von 5 01.06.1999 110220            else downsweep.waitdest          busy  true headpos  dest      end request   procedure release      begin busy  false         if direction  up then            if upsweep.queue then upsweep.signal                                elsedirection  down                   downsweep.signal         else if downsweep.queue then downsweep.signal                                              else direction  up                                                   upsweep.signal     end release     headpos  0 direction  up busy  falseend dischead 6.3 Readers and WritersAs a more significant example, we take a problem which arises in online realtime applications such as airspace control.Suppose that each aircraft is represented by a record, and that this record is kept up to date by a number of writer processesand accessed by a number of reader processes. Any number of reader processes may simultaneously access the samerecord, but obviously any process which is updating writing the individual components of the record must have exclusiveaccess to it, or chaos will ensue. Thus we need a class of monitors an instance of this class local to each individual aircraftrecord will enforce the required discipline for that record. If there are many aircraft, there is a strong motivation for minimizinglocal data of the monitor and if each read or write operation is brief, we should also minimize the time taken by each monitorentry.When many readers are interested in a single aircraft record, there is a danger that a writer will be indefinitely prevented fromkeeping that record up to date. We therefore decide that a new reader should not be permitted to start if there is a writerwaiting. Similarly, to avoid the danger of indefinite exclusion of readers, all readers waiting at the end of a write should havepriority over the next writer. Note that this is a very different scheduling rule from that propounded in 41, and does not seemto require such subtlety in implementation. Nevertheless, it may be more suited to this kind of application, where it is better toread stale information than to wait indefinitelyThe monitor obviously requires four local proceduresstartreadentered by reader who wishes to readendreadentered by reader who has finished reading.startwriteentered by writer who wishes to write.endwriteentered by writer who has finished writing.We need to keep a count of the number of users who are rending, so that the last reader to finish will know this fact    readercount integerWe also need a Boolean to indicate that someone is actually writing    busy BooleanWe introduce separate conditions for readers and writers to wait on    OKtoread, OKtowriteconditionThe following annotation is relevant    OKtoread  not busy6. Further Exampleshttpwww.acm.orgclassicsfeb96furtherexamples.html 4 von 5 01.06.1999 110220    OKtowrite  not busy  readercount  0    invariant busy  readercount  0class readers and writers monitors   begin readercountinteger        busyBoolean        OKtoread, OKtowritecondition     procedure startread        begin if busy or OKtowrite.queue then OKtoread.wait          readercount  readercount  1          OKtoread.signal          comment Once one reader can start, they all can        end startread     procedure endread        begin readercount  readercount  1          if readercount  0 then OKtowrite.signal        end endread     procedure startwrite        begin          if readercount  0 or busy then OKtowrite.wait          busy  true        end startwrite     procedure endwrite        begin busy  false          if OKtoread.queue then OKtoread.signal                             else OKtowrite.signal        end endwrite     readercount  0     busy  false   end readers and writersI am grateful to Dave Gorman for assisting in the discovery of this solution.Next Section 7. ConclusionPrevious Section 5. Scheduled Waits6. Further Exampleshttpwww.acm.orgclassicsfeb96furtherexamples.html 5 von 5 01.06.1999 110220Monitors An Operating System StructuringConcept7. ConclusionReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.This paper suggests that an appropriate structure for a module of an operating system, whichschedules resources for parallel user processes, is very similar to that of a data representation used bya sequential program. However, in the case of monitors, the bodies of the procedures must beprotected against reentrance by being implemented as critical regions. The textual grouping of criticalregions together with the data which they update seems much superior to critical regions scatteredthrough the user program, as described in 7, 121. It also corresponds to the traditional practice of thewriters of operating system supervisors. It can be recommended without reservation.However, it is much more difficult to be confident about the condition concept as a synchronizingprimitive. The synchronizing facility which is easiest to use is probably the conditional wait 2,12waitBwhere B is a general Boolcan expression it causes the given process to wait until B becomes true butthis may be too inefficient for general use in operating systems, because its implementation rcqttircsreevahtation of the expression B after every exit from a procedure of the monitor. The conditionvariable gives the programmer better control over efficiency and over scheduling it was designed tobe very primitive, and to have a simple proof rule. But perhaps some other copromise betweenconvenience and efficiency might be better. The question whether the signal should always be the lastoperation of a monitor procedure is still open. These problems will be studied in the design andimplementation of a pilot project operating syslem, currently enjoying the support of the ScienceItesearch Council of Great Britain.Another question which will be studied will be that of the disjointness of motiitors Is it possible todesign a separate isolated monitor for each kind of resource, so that it will make sensible schedulingdecisions for that resource, using only the minimal information about the utilization of any resource,and using no information about the utilization of any resource administered by other monitors Inprinciple, it would seem that, when more knowledge of the status of the entire system is available it7. Conclusionhttpwww.acm.orgclassicsfeb96conclusion.html 1 von 2 01.06.1999 110234should be easier to take decisions nearer to optimality. Furthermore, in principle, independentscheduling of different kinds of resources can lead lo deadly embrace. These considerations wouldlead to the design of a traditional monolithic monitor, maintaining large system tables, all of whichcan be accessed and updated by any of the procedures of the monitor.There is no a priori reason why the attempt to split the functions of an operating system into a numberof isolated disjoint monitors should succeed. It can be made to succeed only by discovering andimplementing good scheduling algorithms in each monitor. In order to avoid undesirable interactionsbetween the separate scheduling algorithms, it appears necessary to observe the following principles1. Never seek to make an optimal decision merely seek to avoid persistently pessimal decisions.2. Do not seek to present the user with a virtual machine which is belier than the actual hardwaremerely seek to pass on the speed, size, and flat unopiniated structure of a simple hardware design.3. Use preemptive techniques in preference to non preemptive ones where possible.4. Use gain of time 9 methods to secure independence of scheduling strategies.5. Keep a low variance as well as a low mean on waiting times.6. Avoid fixed priorities instead, try to ensure that every program in the system makes reasonablysteady progress. In particular, avoid indefinite overtaking.7. Ensure that when demand for resources outstrips the supply i.e. in overload conditions, thebehavior of the scheduler is satisfactory i.e. thrashing is avoided.8. Make rules for the correct and sensible use of monitor calls, and assume that user programs willobey them. Any checking which is necessary should he done not by a central shared monitor, butrather by an lgorithm called user envelope which is local to each process executing a userprogram. This algorithm should be implemented at least partially in the hardware e.g. base and rangeregisters, address translation mechanisms capabilities, etc..It is the possibility of. constructing separate monitors for different purposes, and of separating thescheduling decisions embodied in monitors from the checking embodied in user envelopes, that mayjustify a hope that monitors are an appropriate concept for the structuring of an operating system.Acknowledgments. The development of the monitor concept is due to frequent discussions andcommunications with E. W. Dijkstra and P. Brinch Hansen. A monitor corresponds to the secretarydescribed in 9, and is also described in 1,3.Acknowledgment is also due to the support of IFIP WG.2.3., which provides a meeting place at whichthese and many other ideas have been germinated, fostered, and tested.Received February 1973 revised April 1974Next Section ReferencesPrevious Section 6. Further Examples7. Conclusionhttpwww.acm.orgclassicsfeb96conclusion.html 2 von 2 01.06.1999 110234Monitors An Operating System StructuringConceptReferencesReprinted from Communications of the ACM, Vol. 17, No. 10. October 1974, pp. 549557. Copyright 1974, Association for Computing Machinery Inc.1. BrinchHansen, P. Structured multiprogramming. Comm. ACM 15, 7 July 1972, 574577.2. BrinchHansen, P.  A comparison of two synchronizing concepts, Acta Information 1 1972,190199.3. Brinch Hansen P. Operating System Principles. PrenticeHall, Englewood Cliffs, N.J., 1973.4. Courtois, P. J., Heymans, F., Parnas, D.L. Concurrent control with readers and writers. Comm.ACM 14, 10 Oet. 197 1 , 667668.5. Courtois, P.J. Heymans, F., Paranas, D.L. Comments on 2. Acta Informatica 1972, 375376.6. Dahl, O.J. Hierarchical program structures. In Structured Programming, Academic Press, NewYork, 1972.7. Dijkstra, E. W. Cooperating Sequnential Processes. In programming Languages Ed. F. Genuys,Acauemic Press, New York,8. Dijkstra, E.W. A constructive approach to the problem of program corrcctness. BIT 8 1968,174186.9. Dijkstra, E,W, Hierarchical ordering of sequential processes. In Operating Systems Techniques,Academic Press, New York, 1972.10. Dijkstra, E.W, Information streams sharing a finite buffer. Information Processing Letters 1,5Oct. 1972, 179180.11. Dijkstra, E.W. A class of allocation strategies inducing bounded delays only. Proc AFIPS 1972Referenceshttpwww.acm.orgclassicsfeb96references.html 1 von 2 01.06.1999 110242SJCC, Vol. 40, AFIPS Press, Montvale, N.J., pp. 933936.12. Hoare, C.A.R. Towards a theory of parallel programming. In Operating Systens techniques,Academic Press, New York, 1972.13. Hoarea, C.A.R. Proof of correctness of data representations. Acta Informatica 1 1972, 271281.14. Hoare, C.A.R. A structured paging system. Computer J. 16, 3 1973, 20921515. Wirth, N. The programming language PASCAL. Acta Informatica 1, 11971, 3563.Referenceshttpwww.acm.orgclassicsfeb96references.html 2 von 2 01.06.1999 110242
