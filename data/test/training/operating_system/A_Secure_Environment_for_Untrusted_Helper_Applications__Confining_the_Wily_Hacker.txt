A Secure Environment for Untrusted Helper ApplicationsConning the Wily HackerIan Goldberg David Wagner Randi Thomas Eric A. Brewerfiang,daw,randit,brewergcs.berkeley.eduUniversity of California, BerkeleyAbstractMany popular programs, such as Netscape, use untrusted helper applications to process data from thenetwork. Unfortunately, the unauthenticated network data they interpret could well have been created by an adversary, and the helper applications areusually too complex to be bugfree. This raises signicant security concerns. Therefore, it is desirableto create a secure environment to contain untrustedhelper applications. We propose to reduce the riskof a security breach by restricting the programs access to the operating system. In particular, we intercept and lter dangerous system calls via the Solarisprocess tracing facility. This enabled us to build asimple, clean, usermode implementation of a secureenvironment for untrusted helper applications. Ourimplementation has negligible performance impact,and can protect preexisting applications.1 IntroductionOver the past several years the Internet environmenthas changed drastically. This network, which wasonce populated almost exclusively by cooperating researchers who shared trusted software and data, isnow inhabited by a much larger and more diversegroup that includes pranksters, crackers, and business competitors. Since the software and data exchanged on the Internet is very often unauthenticated, it could easily have been created by an adversary.Web browsers are an increasingly popular tool forretrieving data from the Internet. They often relyon helper applications to process various kinds ofinformation. These helper applications are securitycritical, as they handle untrusted data, but they arenot particularly trustworthy themselves. Older versions of ghostscript, for example, allowed malicious programs to spawn processes and to read orwrite an unsuspecting users les 15, 18, 19, 34, 36.What is needed in this new environment, then, isprotection for all resources on a users system fromthis threat.Our aim is to conne the untrusted software and databy monitoring and restricting the system calls it performs. We built Janus1, a secure environment foruntrusted helper applications, by taking advantageof the Solaris process tracing facility. Our primarygoals for the prototype implementation include security, versatility, and congurability. Our prototype is meant to serve as a proofofconcept, and webelieve our techniques may have a wider application.2 Motivation2.1 The threat modelBefore we can discuss possible approaches to theproblem, we need to start by clarifying the threatmodel. Web browsers and .mailcap les make itconvenient for users to view information in a widevariety of formats by demultiplexing documents tohelper applications based on the document format.For example, when a user downloads a Postscriptdocument from a remote network site, it may beautomatically handled by ghostview. Since thatdownloaded data could be under adversarial control,it is completely untrustworthy. We are concernedthat an adversary could send malicious data that subverts the document viewer through some unspeciedsecurity bug or misfeature, compromising the userssecurity. Therefore we consider helper applicationsuntrusted, and wish to place them outside the hoststrust perimeter.1Janus is the Roman god of entrances and exits, who hadtwo heads and eternally kept watch over doorways and gateways to keep out intruders.We believe that this is a prudent level of paranoia. Many helper programs were initially envisioned as a viewer for a friendly user and were notdesigned with adversarial inputs in mind. Furthermore, ghostscript implements a full programminglanguage, with complete access to the lesystemmany other helper applications are also very general. Worse still, these programs are generally bigand bloated, and large complex programs are notoriously insecure.2 Security vulnerabilities have beenexposed in these applications 15, 18, 19, 34, 36.2.2 The dicultiesWhat security requirements are demanded from asuccessful protection mechanism Simply put, anoutsider who has control over the helper applicationmust not be able to compromise the condentiality,integrity, or availability of the rest of the system,including the users les or account. Any damagemust be limited to the helper applications displaywindow, temporary les and storage, and associatedshortlived objects. In other words, we insist on thePrinciple of Least Privilege the helper applicationshould be granted the most restrictive collection ofcapabilities required to perform its legitimate duties,and no more. This ensures that the damage a compromised application can cause is limited by the restricted environment in which it executes. In contrast, an unprotected Unix application that is compromised will have all the privileges of the accountfrom which it is running, which is unacceptable.Imposing a restricted execution environment onhelper applications is more dicult than it mightseem. Many traditional paradigms such as the reference monitor and network rewall are insucient ontheir own, as discussed below. In order to demonstrate the diculty of this problem and appreciatethe need for a novel solution, we explore several possible approaches.Building security directly into each helperapplication Taking things to the extreme, wecould insist all helper applications be rewritten in asimple, secure form. We reject this as completely unrealistic it is simply too much work to reimplementthem. More practically, we could adopt a reactive philosophy, recognizing individual weaknesses aseach appears and engineering security patches oneat a time. Historically, this has been a losing battle,at least for large applications for instance, explore2For instance, ghostscript is more than 60,000 lines of Cand mpeg play is more than 20,000 lines long.the sad tale of the sendmail bug of the month1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 16. In any event,attempts to build security directly into the manyhelper applications would require each program tobe considered separatelynot an easy approach toget right. For now, we are stuck with many useful programs which oer only minimal assurances ofsecurity therefore what we require is a general, external protection mechanism.Adding new protection features into theOS We reject this design for several reasons.First, it is inconvenient. Development and installation both require modications to the kernel. Thisapproach, therefore, has little chance of becomingwidely used in practice. Second, wary users maywish to protect themselves without needing the assistance of a system administrator to patch andrecompile the operating system. Third, securitycritical kernel modications are very risky a bugcould end up allowing new remote attacks or allow a compromised application to subvert the entire system. The chances of exacerbating the currentsituation are too high. Better to nd a userlevelmechanism so that users can protect themselves, andso that preexisting access controls can serve as abackup even in the worst case, security cannot decrease.The preexisting reference monitor Thetraditional operating systems monolithic referencemonitor cannot protect against attacks on helper applications directly. At most, it could prevent a penetration from spreading to new accounts once thebrowser users account has been compromised, butby then the damage has already been done. In practice, against a motivated attacker most operating systems fail to prevent the spread of penetration onceone account has been subverted, the whole systemtypically falls in rapid succession.The conventional network firewall Packetlters cannot distinguish between dierent types ofHTTP trac, let alone analyze the data for securitythreats. A proxy could, but it would be hardpressedto understand all possible le formats, interpret theoftencomplex application languages, and squelch alldangerous data. This would make for a very complexand thus untrustworthy proxy.We therefore see the need for a new, simple, andgeneral userlevel protection mechanism that doesnot require modication of existing helper applications or operating systems. The usual techniquesand conventional paradigms do not work well in thissituation. We hope that the diculty of the problemand the potential utility of a solution should help tomotivate interest in our project.3 DesignOur design, in the style of a reference monitor, centers around the following basic assumptionAn application can do little harm ifits access to the underlyingoperating system is appropriatelyrestricted.Our goal, then, was to design a userlevel mechanismthat monitors an untrusted application and disallowsharmful system calls.A corollary of the assumption is that an application may be allowed to do anything it likes thatdoes not involve a system call. This means it mayhave complete access to its address space, both codeand data. Therefore, any userlevel mechanism weprovide must reside in a dierent address space. Under Unix, this means having a separate process.One of our basic design goals was security. Theuntrusted application should not be able to accessany part of the system or network for which our program has not granted it permission. We use theterm sandboxing to describe the concept of conning a helper application to a restricted environment,within which it has free reign. This term was rstintroduced, in a slightly dierent setting, in 35.To achieve security, a slogan we kept in mind waskeep it simple 29. Simple programs are morelikely to be secure simplicity helps to avoid bugs,and makes it easier to nd those which creep in 17,Theorem 1. We would like to keep our programsimpler than the applications that would run underit.Another of our goals was versatility. We wouldlike to be able to allow or deny individual systemcalls exibly, perhaps depending on the argumentsto the call. For example, the open system call couldbe allowed or denied depending on which le the application was trying to open, and whether it was forreading or for writing.Our third goal was configurability. Dierentsites have dierent requirements as to which les theapplication should have access, or to which hosts itshould be allowed to open a TCP connection. Infact, our program ought to be congurable in thisway even on a peruser or perapplication basis.On the other hand, we did not strive for the criteriaof safety or portability of applications. By safety, wemean protecting the application from its own bugs.We allow the user to run any program he wishes,and we allow the executable to play within its ownaddress space as much as it would like.We adopted for our program, then, a simple, modular design a framework, which is the essential body of theprogram, and dynamicmodules, used to implement various aspects of a congurable security policy by ltering relevant system calls.The framework reads a conguration le, which canbe site, user, or applicationdependent. This lelists which of the modules should be loaded, and maysupply parameters to them. For example, the conguration linepath allow read,write tmpwould load the path module, passing it the parameters allow read,write tmp at initialization time. This syntax is intended to allow les undertmp to be opened for reading or writing.Each module lters out certain dangerous systemcall invocations, according to its area of specialization. When the application attempts a system call,the framework dispatches that information to relevant policy modules. Each module reports its opinionon whether the system call should be permitted orquashed, and any necessary action is taken by theframework. We note that, following the Principle ofLeast Privilege, we let the operating system executea system call only if some module explicitly allowsit the default is for system calls to be denied. Thisbehavior is important because it causes the systemto err on the side of security in case of an underspecied security policy.Each module contains a list of system calls that itwill examine and lter. Note that some system callsmay appear in several modules lists. A module mayassign to each system call a function which validatesthe arguments of the call before the call is executedby the operating system.3 The function can thenuse this information to optionally update local state,and then suggest allowing the system call, suggestdenying it, or make no comment on the attemptedsystem call.The suggestion to allow is used to indicate a modules explicit approval of the execution of this systemcall. The suggestion to deny indicates a system callwhich is to be denied execution. Finally, a no comment response means that the module has no inputas to the dispatch of this system call.Modules are listed in the conguration le frommostgeneral to most specic, so that the last relevantmodule for any system call dictates whether the callis to be allowed or denied. For example, a suggestionto allow countermands an earlier denial. Note thata no comment response has no eect in particular, it does not override an earlier deny or allowresponse.Normally, when conicts arise, earlier modules areoverridden by later ones. To escape this behavior,for very special circumstances modules may unequivocally allow or deny a system call and explicitly insist that their judgement be considered nal. In thiscase, no further modules are consulted a superallow or superdeny cannot be overridden. Theintent is that this feature should be used quite rarely,for only the most critical of uses. Write access to.rhosts could be superdenied near the top of theconguration le, for example, to provide a safetynet in case we accidentally miswrite a subsequentle access rule.In designing the framework we aimed for simplicityand versatility as much as possible, though thesegoals often conict. One can imagine more versatile and sophisticated algorithms to dispatch systemcalls, but they would come at a great cost to simplicity.4 Implementation4.1 Choice of operating systemIn order to implement our design, we needed to ndan operating system that allowed one userlevel process to watch the system calls executed by another3In addition, a module can assign to a system call a similarfunction which gets called after the system call has executed,just before control is returned to the helper application. Thisfunction can examine the arguments to the system call, as wellas the return value, and update the modules local state.process, and to control the second process in variousways such as causing selected system calls to fail.Luckily, most operating systems have a processtracing facility, intended for debugging. Most operating systems oer a program called trace1,strace1, or truss1 which can observe the system calls performed by another process as well astheir return values. This is often implemented witha special system call. ptrace2, which allowsthe tracer to register a callback that is executedwhenever the tracee issues a system call. Unfortunately, ptrace oers only very coarsegrained allornothing tracing we cannot trace a few system callswithout tracing all the rest as well. Another disadvantage of the ptrace2 interface is that many OSimplementations provide no way for a tracing process to abort a system call without killing the tracedprocess entirely.Some more modern operating systems, such as Solaris 2.4 and OSF1, however, oer a better processtracing facility through the proc virtual lesystem.This interface allows direct control of the traced processs memory. Furthermore, it has negrained control we can request callbacks on a persystem callbasis.There are only slight dierences between the Solarisand the OSF1 interfaces to the proc facility. Oneof them is that Solaris provides an easy way for thetracing process to determine the arguments and return values of a system call performed by the tracedprocess. Also, Solaris operating system is somewhatmore widely deployed. For these reasons, we choseSolaris 2.4 for our implementation.4.2 The policy modules4.2.1 OverviewThe policy modules are used to select and implement security policy decisions. They are dynamically loaded at runtime, so that dierent securitypolicies can be congured for dierent sites, users,or applications. We implemented a sample set ofmodules that can be used to set up the traced applications environment, and to restrict its ability toread or write les, execute programs, and establishTCP connections. In addition, the traced application is prevented from performing certain systemcalls, as described below. The provided modules offer considerable exibility themselves, so that maycongure them simply by editing their parameters inthe conguration le. However, if dierent modulesare desired or required, it is very simple to compilenew ones.Policy modules need to make a decision as to whichsystem calls to allow, which to deny, and for whicha function must be called to determine what to do.The rst two types of system calls are the easiest tohandle.Some examples of system calls that are always allowed in our sample modules are close, exit,fork, and read. The operating systems protectionon these system calls is sucient for our needs.Some examples of system calls that are always deniedin our samplemodules are ones that would not succeed for an unprivileged process anyway, like setuidand mount, along with some others, like chdir, thatwe disallow as part of our security policy.The hardest system calls to handle are those forwhich a function must, in general, be called to determine whether the system call should be allowedor denied. The majority of these are system callssuch as open, rename, stat, and kill whose arguments must be checked against the congurable security policy specied in the parameters given to themodule at load time.4.2.2 Sample security policyWe implemented a sample security policy to test ourideas, as a proof of concept.Helper applications are allowed to fork children, wethen recursively trace. Traced processes can onlysend signals to themselves or to their children, andnever to an untraced application. Environment variables are initially sanitized, and resource usage iscarefully limited.In our policy, access to the lesystem is severely limited. A helper application is placed in a particulardirectory it cannot chdir out of this directory. Weallow it full access to les in or below this directoryto prevent escape from this sandbox directory, access to paths containing .. are always denied. Theuntrusted application is allowed read access to certain carefully controlled les referenced by absolutepathnames, such as shared libraries and global conguration les. We concentrate all access controlin the open system call, and always allow read andwrite calls this is safe, because write is only useful when used on a le descriptor obtained from asystem call like open. This approach simplies matters, and also allows us a performance optimizationfurther down the line see Section 4.4.Of course, protecting the lesystem alone is notenough. Nearly any practical helper application willrequire access to network resources. For example,all of the programs we considered need to open awindow on the X11 display to present document contents. In our security policy, network access must becarefully controlled we allow network connectionsonly to the X display, and this access is allowed onlythrough a safe X proxy.X11 does not itself provide the security services werequire X access control is allornothing. A rogueX client has full access to all other clients on thesame server, so an otherwise conned helper application could compromise other applications if it wereallowed uncontrolled access to X. Fortunately therewall community has already built several safe Xproxies that understand the X protocol and lter outdangerous requests 26, 31. We integrated our Janusprototype with Xnest 31, which lets us run anothercomplete instance of the X protocol under Xnest.Xnest acts as a server to its clients e.g. untrusted helper applications, but its display is paintedwithin one window managed by the root X server.In this way, untrusted applications are securely encapsulated within the child Xnest server and cannotescape from this sandbox display area or aect othernormal trusted applications. Xnest is not idealit isnot as small or simple as we would likebut furtheradvances in X protocol ltering are likely to improvethe situation.4.2.3 Sample modulesOur modules implementing this sample policy areas follows. The basic module supplies defaultsfor the system calls which are easiest to analyze,and takes no conguration parameters. The putenvmodule allows one to specify environment variablesettings for the traced application via its parameters those which are not explicitly mentioned areunset. The special parameter display causes thehelper application to inherit the parents DISPLAY.The tcpconnect module allows us to restrict TCPconnections by host andor port the default is todisallow all connections. The path module, the mostcomplicated one, lets one allow or deny le accessesaccording to one or more patterns.Because this policy is just an example, we have notgone into excruciating detail regarding the specicpolicy decisions implemented in our modules.Our sample conguration le for this policy can beseen in Figure 2 in the Appendix.4.3 The framework4.3.1 Reading the conguration leThe framework starts by reading the congurationle, the location of which can be specied on thecommand line. This conguration le consists oflines like those shown in Figure 2 the rst wordis the name of the module to load, and the rest ofthe line acts as a parameter to the module.For each module specied in the conguration le,dlopen3x is used to dynamically load the moduleinto the frameworks address space. The modulesinit function is called, if present, with the parameters for the module as its argument.The list of system calls and associated values andfunctions in the module is then merged into theframeworks dispatch table. The dispatch table is anarray, indexed by system call number, of linked lists.Each value and function in the module is appendedto the list in the dispatch table that is indexed by thesystem call to which it is associated.The result, after the entire conguration le has beenread, is that for each system call, the dispatch tableprovides a linked list that can be traversed to decidewhether to allow or deny a system call.4.3.2 Setting up the traced processAfter the dispatch table is set up, the framework getsready to run the application that is to be traced achild process is forked, and the childs state iscleaned up. This includes setting a umask of 077,setting limits on virtual memory use, disabling coredumps, switching to a sandbox directory, and closingunnecessary le descriptors. Modules get a chanceto further initialize the childs state for instance, theputenv module sanitizes the environment variables.The parent process waits for the child to completethis cleanup, and begins to debug the child via theproc interface. It sets the child process to stopwhenever it begins or nishes a system call actually, only a subset of the system calls are marked inthis manner see Section 4.4, below. The child waitsuntil it is being traced, and executes the desired application.In our sample security policy, the application is conned to a sandbox directory. By default, this directory is created in tmp with a random name, butthe SANDBOX DIR environment variable can be usedto override this choice.4.3.3 Running the traced processThe application runs until it performs a system call.At this point, it is put to sleep, and the tracingprocess wakes up. The tracing process determineswhich system call was attempted, along with the arguments to the call. It then traverses the appropriatelinked list in the dispatch table, in order to determinewhether to allow or to deny this system call.If the system call is to be allowed, the tracing process simplywakes up the application, which proceedsto complete the system call. If, however, the system call is to be denied, the tracing process wakesup the application with the PRSABORT ag set. Thiscauses the system call to abort immediately, returning a value indicating that the system call failed andsetting errno to EINTR. In either case, the tracingprocess goes back to sleep.The fact that an aborted system call returns EINTR tothe application presents a potential problem. Someapplications are coded in such a way that, if theyreceive an EINTR error from a system call, they willretry the system call. Thus, if such a applicationtries to execute a system call which is denied by thesecurity policy, it will get stuck in a retry loop. Wedetect this problem by noticing when a large number currently 100 of the same system call with thesame arguments are consecutively denied. If this occurs, we assume the traced application is not goingto make any further progress, and just kill the application entirely, giving an explanatory message tothe user. We would prefer to be able to return othererror codes such as EPERM to the application, butSolaris does not support that behavior.When a system call completes, the tracing processhas the ability to examine the return value if it sowishes. If any module had assigned a function tobe executed when this system call completes, as described above, it is executed at this time. This facility is not widely used, except in one special case.When a fork or vfork system call completes,the tracing process checks the return value and thenforks itself. The child of the tracing process thendetaches from the application, and begins tracing theapplications child. This method safely allows thetraced application to spawn a child as ghostviewspawns gs, for example by ensuring that all childrenof untrusted applications are traced as well.We have not aimed for extensive auditing, but logging of the actions taken by the framework would beeasy to add to our implementation if desired.We should point out that the Solaris tracing facilities will not allow a traced application to exec asetuid program. Furthermore, traced programs cannot turn o their own tracing.4.4 The optimizerOur program has the potential to add a nontrivial amount of overhead to the traced applicationwhenever it intercepts a system call. In order to keepthis overhead down, we obviously want to interceptas few system calls as possibleor at least, as few ofthe common ones as possible. However, we do notwish to give up security to gain performance.Therefore, we apply several optimizations to the system call dispatch table before the untrusted helperapplication executes. We note that one common casearises when a modules system call handler alwaysreturns the same allowdeny value and leaves noside eects this special case allows us to removeredundant values in the dispatch table.The most important optimization observes that certain system calls, such as write, are always allowedso we need not register a callback with the OS forthem. This avoids the extra context switches to andfrom the tracing process each time the traced application makes such a system call, and thus thosesystem calls can execute at full speed as thoughthere were no tracing or ltering. By eliminating theneed to trace common system calls such as read andwrite, we can greatly speed up the common case.5 EvaluationThe general population is more interested in eciency and convenience than in security, so any security product intended for general use must addressthese concerns. For this reason, we evaluate ourprototype implementation by a number of criteria,including security, applicability, and ease of use, inaddition to performance.5.1 Ease of useThe secure environment is relatively easy to install.All that is needed is to protect the invocation of anyhelper application with our environment. The mostconvenient solution is to specify our janus programin a mailcap le, which could look likeimage janus xv sapplicationpostscript janus ghostview svideompeg janus mpegplay svideo janus xanim sWith little eort, a system administrator could setup the inhouse security policy by listing janus inthe default global mailcap le then the secure environment would be transparent to all the users onthe system. Similarly, users could protect themselvesby doing the same to their personal .mailcap le.5.2 ApplicabilityUsers will want to run our secure environment withpreexisting helper applications. We tested a numberof programs under our secure environment, including ghostview, mpeg play, xdvi, xv, and xanim.Though we followed the Principle of Least Privilegeand were very restrictive in our security policy, wefound that each of the applications had sucientprivilege, and we had not unduly restricted the applications from doing their legitimate intended jobs.In addition, we ran the shells sh and bash underour secure environment. Unless the user explicitlytries to violate the security policy e.g., by writingto .rhosts, there is no indication of the restrictednature of the shell. Attempts to violate the securitypolicy are rewarded with a shell error message.5.3 SecurityThere is no universally accepted way to assesswhether our implementation is secure however, thereare denite indications we can use to make this decision.We believe in security through simplicity, and thiswas a guiding principle throughout the design andimplementation process. Our entire implementationconsists of approximately 2100 lines of code theframework has 800, and the modules have the remaining 1300. Furthermore, we have attempted tominimize the amount of securitycritical state wherepossible. Since the design concept is a simple one,and because the entire program is small, the implementation is easier to understand and to evaluate.Thus, there is a much smaller chance of having anundetected security hole.We performed some simple sanity checks to verifythat our implementation appropriately restricts applications. More work on assurance is needed.Most importantly, the best test is outside scrutinyby independent experienced security researchers adetailed code review would help improve the assurance and security oered by our secure environment.All are encouraged to examine our implementationfor aws.5.4 PerformanceSince our design potentially adds timeconsumingcontext switches for every system call the untrusted application makes, the obvious performance metric to evaluate is time. We measured the peak performance of ghostscript and mpeg play, two largecommonly used helper applications, under our secureenvironment. Note that mpeg play in particular isperformance critical.mpeg play was used to display nine mpeg moviesranging in size from 53 KB 18 frames to 740 KB400 frames. ghostscript was used to displayseven Postscript les ranging in size from 9 KB to1.7 MB. ghostscript was run noninteractively, sothat all the pages in the Postscript le were displayed in succession with no user intervention. Wetook 100 measurements for each le, 50 traced underour secure environment and 50 untraced, calculatingthe mean and standard deviation for each set. Themeasurements were done using an unloaded singleprocessor SPARCstation 20 workstation running Solaris 2.4. The Xnest X windows proxy 31 was usedwith the secure environment, but not with the untraced measurements.The results are displayed in Figure 1. For eachset, we plotted the traced time against the untracedtime.4 The boxes around the data points indicateone standard deviation. The diagonal line shows theideal result of no statistically signicant performanceoverhead. In the best possible case, the error boxeswill all intersect the ideal line. Boxes entirely abovethe line indicate statistically signicant overhead. Ascan be seen, the secure environment imposes no sig4Similar results were obtained when measuring frame rateper second for mpeg play.Figure 1 Performance data for ghostscript andmpeg play00 5510101515202025253030Untraced ghostscript times secTraced ghostscript times sec00 2244668810101212Untraced mpegplay times secTraced mpegplay times secnicant performance penalty.The negligible performance impact can be attributedto the unintrusive nature of our implementation. Ofcourse, all computations and memory references thatdo not involve the OS will execute at full speed, sosystem calls can be the only source of performanceoverhead. We rst note that system calls are alreadyso timeconsuming that the additional overhead ofthe Janus process ltering is insignicant. Furthermore, most of the heavily used system calls suchas read and write require no access checks andtherefore run at full speed. By staying out of the applications way and optimizing for the common case,we have allowed typical applications to run with negligible performance overhead.6 Related workDue to the accelerated development of communication technology, the security and protection problemsinherent in an open and free communication environment, such as the Internet, are relatively new onesto solve. Consequently, much of the work addressingsecurity for this environment is still being developed.To achieve security, we use the concept of sandboxing, rst introduced by Wahbe et al. in the context of software fault isolation 35. However, theywere actually solving a dierent problem. What theyachieved was safety for trusted modules running inthe same address space as untrusted modules. Theyignored the problem of systemlevel security conversely, we do not attempt to provide safety. Theyalso use binaryrewriting technology to accomplishtheir goals, which prevents them from running arbitrarily general preexisting applications.Java 25 is an comprehensive system that addresses,among other things, both safety and security, although it achieves security by a dierent approachfrom ours. Java cannot secure preexisting programs, because it requires use of a new language.We do not have this problem our design will runany application, and so is more versatile in this respect. However, Java oers many other advantagesthat we do not address for instance, Java providesarchitectureindependence, while Janus only appliesto native code and provides no help with portability.OmniWare 20 takes advantage of software faultisolation techniques and compiler support to safelyexecute untrusted code. Like Java, it also hasarchitectureindependence, extensibility, and eciency as important goals.We note two important dierences between the Javaapproach and the Janus philosophy. The Java protection mechanism is much more complex, and isclosely intertwined with the rest of Javas other functionality. In contrast, we have more limited goals,explicitly aim for extreme simplicity, and keep the security mechanism orthogonal from the nonsecuritycritical functionality.securelib is a shared library that replaces the Caccept, recvfrom, and recvmsg library calls by aversion that performs addressbased authenticationit is intended to protect securitycritical Unix systemdaemons 30. Other research that also takes advantage of shared libraries can be found in 27, 24. Wenote that simple replacement of dangerous C librarycalls with a safe wrapper is insucient in our extended context of untrusted and possibly hostile applications a hostile application could bypass this accesscontrol by simply issuing the dangerous system calldirectly without invoking any library calls.Fernandez and Allen 23 extend the lesystem protection mechanismwith peruser access control lists.Lai and Gray 28 describe an approach which protects against Trojan horses and viruses by limiting lesystem access their OS extension connesuser processes to the minimal lesystem privilegesneeded, relying on hints from the command line andwhen necessary runtime user input. TRON 7 discourages Trojan horses by adding perprocess capabilities support to the lesystem discretionary accesscontrols. These works all suer two major disadvantages they require kernel modications, and they donot address issues such as control over process andnetwork resources.Domain and Type Enforcement DTE is a way toextend the OS protection mechanisms to let system administrators specify negrained mandatoryaccess controls over the interaction between securityrelevant subjects and objects. A research groupat TIS has amassed considerable experience withDTE and its practical application to Unix systems5, 6, 32, 33. DTE is an attractive and broadly applicable approach to mandatory access control, butits main disadvantage is that it requires kernel modications we aimed instead for userlevel protection.7 Limitations and future work7.1 Limitations of the prototypeOne inherent limitation of the Janus implementationis that we can only successfully run helper applications which do not legitimately need many privileges.Our approach will easily accommodate any programthat only requires simple privileges, such as access toa preferences le. Application developers may wantto keep this in mind and not assume, for example,that their applications will be able to access the wholelesystem.We have followed one simple direction in our prototype implementation, but others are possible as well.One could consider using specialized Unix systemcalls to revoke certain privileges. The two majorcontenders are chroot, to conne the applicationwithin a safe directory structure, and setuid, tochange to a limitedprivilege account such as nobody.Unfortunately, programs need superuser privilegesto use these features since we were committed toa userlevel implementation, we decided to ignorethem. However, this design choice could be reconsidered. Other security policies such as mandatoryaudit logs may also be more appropriate in someenvironments.The most fundamental limitation of our implementation, however, stems from its specialization for asingle operating system. Each OS to which Janusmight be ported requires a separate security analysis of its system calls. Also, a basic assumption ofJanus is that the operating system provides multipleaddress spaces, allows trapping of system calls, andmakes it feasible to interpose proxies where necessary. Solaris 2.4 has the most convenient supportfor these mechanisms we believe our approach mayalso apply to some other Unix systems. On the otherhand, platforms that do not support these servicescannot directly benet from our techniques. In particular, our approach cannot be applied to PCs running MSDOS or Microsoft Windows. The utility ofthese connement techniques, then, will be determined by the underlying operating systems supportfor userlevel security primitives.7.2 Future workIn this paper, we have limited discussion to the topicof protecting untrusted helper applications. It wouldalso be interesting to explore how these techniquesmight be extended to a more ambitious scope.One exciting area for further research involves Javaapplet security. Java 25 is seeing widespread deployment, but several implementation bugs 22 havestarted to shake condence in its security model. Formore protection, one could run Java applets within asecure environment built from techniques describedin this paper. This approach provides defense indepth if the Java applet security mechanism is compromised, there is still a second line of defense. Weare experimenting with this approach more work isneeded.Another natural extension of this work is to run webbrowsers under the Janus secure environment. Therecursive tracing of child processes would ensure thatrunning a browser under Janus would protect allspawned helper applications as well. The argumentswhich leave us suspicious of helper applications alsoapply to web browsers they are large, complex programs that interpret untrusted network data. For example, a buer overrun bug was found in an earlierversion of the Netscape browser 21. The main challenge is that browsers legitimately require manymoreprivileges for instance, most manage congurationles, data caches, and network connections. Of these,the broader network access seems to pose the mostdiculties.We believe proxies are a promising approach for improving control over network accesses. By taking advantage of earlier work in rewalls, we were able toeasily integrate a safe X proxy into our prototype.We have shown that one can guard access to system calls with a reference monitor constructed fromprocesstracing facilities we suspect that one can effectively and exibly guard access to the outside network with existing proxies developed by the rewallcommunity. One issue is how to interpose proxiesforcibly upon untrusted and uncooperative applications. We currently use environment variables ashintsfor instance, we change the DISPLAY variableto point to a proxy X server, and disallow access toany other X displaybut this only works for wellbehaved applications that consult environment variables consistently. One might consider implementingsuch hints with a shared library that replaces network library calls with a safe call to a secure proxy.So far we have followed the policy that a helper application should not be able to communicate with theoutside network, since there are several subtle security issues with addressbased authentication, trustperimeters, and covert channels 22. Integrationwith ltering proxies and negrained control overaccess to other network services, such as domainnameservers and remote web servers, would enableour techniques to be used in broader contexts. Theoverlap with research into rewalls lends hope thatthese problems can be solved satisfactorily.8 ConclusionWe designed and implemented a secure environmentfor untrusted helper applications. We restrict an untrusted programs access to the operating system byusing the process tracing facility available in Solaris2.4. In this way, we have demonstrated the feasibility of building and enforcing practical security foruntrusted helper applications.The Janus approach has two main advantages The Janus protection mechanism is orthogonalfrom other application functionality, so our usermode implementation is simple and clean. Thismakes it more likely to be secure, and allowsour approach to be broadly applicable to all applications. We can protect existing applications with littleperformance penalty.We feel that this eort is a valuable step toward security for the World Wide Web.9 AvailabilityThe Web pagehttpwww.cs.berkeley.edudawjanuswill contain more information on availability of theJanus software described in this paper.10 AcknowledgementsWe would like to thank Steven Bellovin, David Oppenheimer, Armando Fox, Steve Gribble, and the anonymous reviewers for their helpful comments.References1 8lgmAdvisory16.UNIX.sendmail6Dec1994, December 1994.2 8lgmAdvisory17.UNIX.sendmailV52May1995, May 1995.3 8lgmAdvisory17.UNIX.sendmailV5.22Aug1995, August 1995.4 8lgmAdvisory20.UNIX.sendmailV5.1Aug1995, August 1995.5 Lee Badger, Daniel F. Sterne, David L. Sherman, and Kenneth M. Walker. A domain andtype enforcement UNIX prototype. USENIXComputing Systems, 914783, Winter 1996.6 Lee Badger, Daniel F. Sterne, David L. Sherman, Kenneth M. Walker, and Sheila A.Haghighat. Practical domain and type enforcement for UNIX. In Proc. 1995 IEEE Symposiumon Security and Privacy, 1995.7 Andrew Berman, Virgil Bourassa, and Erik Selberg. TRON Processspecic le protection forthe UNIX operating system. In Proc. 1995USENIX Winter Technical Conference, pages165175. USENIX Assoc., 1995.8 CERT advisory CA8801, 1988.9 CERT advisory CA9001, January 1990.10 CERT advisory CA9315, October 1993.11 CERT advisory CA9316, November 1993.12 CERT advisory CA9412, July 1994.13 CERT advisory CA9505, February 1995.14 CERT advisory CA9508, August 1995.15 CERT advisory CA9510, August 1995.16 CERT advisory CA9511, September 1995.17 William R. Cheswick and Steven M. Bellovin.Firewalls and Internet Security Repelling theWily Hacker. AddisonWesley, 1994.18 Frederick Cohen. Personal communication.19 Frederick Cohen. Internet holes. Network Security Magazine, January 1996.20 Colusa Software. OmniWare technical overview,1995.21 Ray Cromwell. Buer overow, September 1995. Announced on the Internet.httpwww.c2.nethacknetscape.22 Drew Dean, Edward W. Felten, and Dan S.Wallach. Java security From HotJava to Netscape and beyond. In Proc. of the 1996 IEEESymposium on Security and Privacy, 1996.23 G. Fernandez and L. Allen. Extending theUnix protection model with access control lists.In Proc. Summer 1988 USENIX Conference,pages 119132. USENIX Assoc., 1988.24 Glenn S. Fowler, Yennun Huang, David G.Korn, and Herman Rao. A userlevel replicatedle system. In Summer 1993 USENIX Conference Proceedings, pages 279290. USENIX Assoc., 1993.25 James Gosling and Henry McGilton. The Javalanguage environment A white paper, 1995.httpwww.javasoft.comwhitePaperjavawhitepaper 1.html.26 Brian L. Kahn. Safe use of X window systemprotocol across a rewall. In Proc. of the 5thUSENIX UNIX Security Symposium, 1995.27 David G. Korn and Eduardo Krell. The 3Dle system. In Summer 1989 USENIX Conference Proceedings, pages 147156. USENIX Assoc., 1989.28 Nick Lai and Terence Gray. Strengthening discretionary access controls to inhibit Trojanhorses and computer viruses. In Proc. Summer 1988 USENIX Conference, pages 275286.USENIX Assoc., 1988.29 Butler Lampson. Hints for computer systemdesign. In Proceedings of the 9th ACM Symposium on Operating Systems Review, volume175, pages 3348. Bretton Woods, 1983.30 William LeFebvre. Restricting network accessto system daemons under SunOS. In UNIXSecurity Symposium III Proceedings, pages 93103. USENIX Assoc., 1992.31 Davor Matic. Xnest. Available in the X11R6source. Also ftpftp.cs.umass.edupubrcfexpX11R6xcprogramsXserverhwxnest.32 David L. Sherman, Daniel F. Sterne, LeeBadger, and S. Murphy. Controlling networkcommunication with domain and type enforcement. Technical Report 523, TIS, March 1995.33 Daniel F. Sterne, Terry V. Benzel, Lee Badger,Kenneth M. Walker, Karen A. Oostendorp,David L. Sherman, and Michael J. Petkac.Browsing the web safely with domain and typeenforcement. In 1996 IEEE Symposium on Security and Privacy, 1996. Research abstract.34 Je Upho. Re Guidelines on cgibin scripts,August 1995. Post to bugtraq mailing list.httpwww.eecs.nwu.educgibinmfsfiles2jmyerspublic htmlbugtraq0166.html30mfs.35 Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. Ecientsoftwarebased fault isolation. In Proc. of theSymp. on Operating System Principles, 1993.36 Christian Wettergren. Re Mime question...,March 1995. Post to bugtraq mailing list.httpwww.eecs.nwu.educgibinmfsfiles2jmyerspublic htmlbugtraq1995a0759.html30mfs.Note CERT advisories are available on the Internetfromftpinfo.cert.orgpubcert advisories.8lgm advisories can be obtained fromhttpwww.8lgm.orgadvisories.Figure 2 Sample conguration lebasicputenv displayputenv HOME. TMP. PATHbinusrbinusrucbusrlocalbinusrlocalX11binusrbinX11usrcontribbinusrlocalbin XAUTHORITY..Xauthority LDLIBRARYPATHusrlocalX11libtcpconnect allow displaypath superdeny read,write,exec .forward .rhosts .klogin .ktrust this is the paradigm to deny absolute paths and allow relative paths of course, we will later allow selected absolute paths assumes someone will put us in a safe sandboxed dir. note that the wildcard  can match anything, including path allow read,write path deny read,write  allow certain explicit pathspath allow read devzero devnull etcnetconfig etcnsswitch.conf etchostsetcresolv.conf etcdefaultinit etcTIMEZONE etcmagic etcmotd etcservices etcinetservices etchosts etcinethosts note subtle issues here. make sure tcpconnect is loaded, to restrict connects devticotsord is the loopback equivalent of devtcp.path allow read,write devtcp devticotsord where libraries live includes appdefaults stuff toopath allow read lib usrlib usrlocalX11lib usrlocalX11R6lib usrsharelibzoneinfo usrlocallib usropenwinlib these are here so you can read the files placed by Netscape and Mosaicpath allow read vartmp tmp this is where binaries live it should look a lot like your PATHpath allow read,exec bin usrbin usrucb usrlocalbin usrlocalX11bin usrbinX11 usrcontribbin usrlocalbin
