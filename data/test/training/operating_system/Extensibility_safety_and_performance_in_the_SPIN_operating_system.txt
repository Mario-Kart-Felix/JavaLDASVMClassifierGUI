A version of this paper appeared in the Proceedings of the Fifteenth Symposium on Operating Systems PrinciplesExtensibility Safety and Performance in theSPIN Operating SystemBrian N Bershad Stefan Savage Przemyslaw Pardyak Emin Gun SirerMarc E Fiuczynski David Becker Craig Chambers Susan EggersDepartment of Computer Science and EngineeringUniversity of WashingtonSeattle WA AbstractThis paper describes the motivation architecture andperformance of SPIN an extensible operating systemSPIN provides an extension infrastructure togetherwith a core set of extensible services that allow applications to safely change the operating systems interfaceand implementation Extensions allow an application tospecialize the underlying operating system in order toachieve a particular level of performance and functionality SPIN uses language and linktime mechanisms toinexpensively export negrained interfaces to operating system services Extensions are written in a typesafe language and are dynamically linked into the operating system kernel This approach oers extensionsrapid access to system services while protecting the operating system code executing within the kernel addressspace SPIN and its extensions are written in Modulaand run on DEC Alpha workstations IntroductionSPIN is an operating system that can be dynamicallyspecialized to safely meet the performance and functionality requirements of applications SPIN is motivatedby the need to support applications that present demands poorly matched by an operating systems implementation or interface A poorly matched implementation prevents an application from working well while apoorly matched interface prevents it fromworking at allFor example the implementations of disk buering andThis research was sponsored by the Advanced ResearchProjects Agency the National Science Foundation Grants noCDA and CCR and by an equipment grantfrom Digital Equipment Corporation Bershad was partially supported by a National Science FoundationPresidential Faculty Fellowship Chambers was partially sponsored by a National ScienceFoundation Presidential Young Investigator Award Sirer wassupported by an IBM Graduate Student Fellowship Fiuczynskiwas partially supported by a National Science Foundation GEEFellowshippaging algorithms found in modern operating systemscan be inappropriate for database applications resulting in poor performance Stonebraker  General purpose network protocol implementations are frequentlyinadequate for supporting the demands of high performance parallel applications von Eicken et al  Otherapplications such as multimedia clients and servers andrealtime and fault tolerant programs can also presentdemands that poorly match operating system servicesUsing SPIN an application can extend the operatingsystems interfaces and implementations to provide abetter match between the needs of the application andthe performance and functional characteristics of thesystem Goals and approachThe goal of our research is to build a general purposeoperating system that provides extensibility safety andgood performance Extensibility is determined by theinterfaces to services and resources that are exportedto applications it depends on an infrastructure thatallows negrained access to system services Safety determines the exposure of applications to the actions ofothers and requires that access be controlled at thesame granularity at which extensions are dened Finally good performance requires low overhead communication between an extension and the systemThe design of SPIN reects our view that an operating system can be extensible safe and fast through theuse of language and runtime services that provide lowcost negrained protected access to operating systemresources Specically the SPIN operating system relies on four techniques implemented at the level of thelanguage or its runtime Colocation Operating system extensions are dynamically linked into the kernel virtual addressspace Colocation enables communication betweensystem and extension code to have low cost Enforced modularity Extensions are written inModula Nelson  a modular programming language for which the compiler enforces interfaceboundaries between modules Extensions whichexecute in the kernels virtual address space cannot access memory or execute privileged instructions unless they have been given explicit accessthrough an interface Modularity enforced by thecompiler enables modules to be isolated from oneanother with low cost Logical protection domains Extensions existwithin logical protection domains which are kernel namespaces that contain code and exported interfaces Interfaces which are languagelevel unitsrepresent views on system resources that are protected by the operating system An inkernel dynamic linker resolves code in separate logical protection domains at runtime enabling crossdomaincommunication to occur with the overhead of a procedure call Dynamic call binding Extensions execute in response to system events An event can describeany potential action in the system such as a virtualmemory page fault or the scheduling of a threadEvents are declared within interfaces and can bedispatched with the overhead of a procedure callColocation enforced modularity logical protectiondomains and dynamic call binding enable interfaces tobe dened and safely accessed with low overhead However these techniques do not guarantee the systems extensibility Ultimately extensibility is achieved throughthe system service interfaces themselves which denethe set of resources and operations that are exportedto applications SPIN provides a set of interfaces tocore system services such as memory management andscheduling that rely on colocation to eciently exportnegrained operations enforced modularity and logicalprotection domains to manage protection and dynamiccall binding to dene relationships between system components and extensions at runtime System overviewThe SPIN operating system consists of a set of extensionservices and core system services that execute within thekernels virtual address space Extensions can be loadedinto the kernel at any time Once loaded they integratethemselves into the existing infrastructure and providesystem services specic to the applications that requirethem SPIN is primarily written in Modula whichallows extensions to directly use system interfaces without requiring runtime conversion when communicatingwith other system codeAlthough SPIN relies on language features to ensuresafety within the kernel applications can be written inany language and execute within their own virtual address space Only code that requires lowlatency accessto system services is written in the systems safe extension language For example we have used SPIN toimplement a UNIX operating system server The bulkof the server is written in C and executes within its ownaddress space as do applications The server consistsof a large body of code that implements the DEC OSFsystem call interface and a small number of SPIN extensions that provide the thread virtual memory anddevice interfaces required by the serverWe have also used extensions to specialize SPIN tothe needs of individual application programs For example we have built a clientserver video system thatrequires few control and data transfers as images movefrom the servers disk to the clients screen Using SPINthe server denes an extension that implements a directstream between the disk and the network The clientviewer application installs an extension into the kernelthat decompresses incoming network video packets anddisplays them to the video frame buer The rest of this paperThe rest of this paper describes the motivation designand performance of SPIN In the next section we motivate the need for extensible operating systems and discuss related work In Section  we describe the systems architecture in terms of its protection and extension facilities In Section  we describe the core servicesprovided by the system In Section  we discuss thesystems performance and compare it against that ofseveral other operating systems In Section  we discussour experiences writing an operating system in Modula Finally in Section  we present our conclusions MotivationMost operating systems are forced to balance generality and specialization A general system runs manyprograms but may run few well In contrast a specialized system may run few programs but runs themall well In practice most general systems can withsome eort be specialized to address the performanceand functional requirements of a particular applicationsneeds such as interprocess communication synchronization thread management networking virtual memory and cache management Draves et al  Bershadet al b Stodolsky et al  Bershad  Yuharaet al  Maeda  Bershad  Felten  Younget al  Harty  Cheriton  McNamee  Armstrong Anderson et al  Fall  Pasquale  Wheeler Bershad  Romer et al  Romer et al  Caoet al  Unfortunately existing system structuresare not wellsuited for specialization often requiring asubstantial programming eort to aect even a smallchange in system behavior Moreover changes intendedto improve the performance of one class of applicationscan often degrade that of others As a result systemspecialization is a costly and errorprone processAn extensible system is one that can be changed dynamically to meet the needs of an application The needfor extensibility in operating systems is shown clearlyby systems such as MSDOS Windows or the Macintosh Operating System Although these systems werenot designed to be extensible their weak protectionmechanisms have allowed application programmers todirectly modify operating system data structures andcode Schulman et al  While individual applications have beneted from this level of freedom the lackof safe interfaces to either operating system services oroperating system extension services has created systemconguration chaos Draves  Related workPrevious eorts to build extensible systems have demonstrated the threeway tension between extensibilitysafety and performance For example Hydra Wulf et al dened an infrastructure that allowed applicationsto manage resources through multilevel policies Thekernel dened the mechanism for allocating resourcesbetween processes and the processes themselves implemented the policies for managing those resourcesHydras architecture although highly inuential hadhigh overhead due to its weighty capabilitybased protection mechanism Consequently the system was designed with large objects as the basic building blocksrequiring a large programming eort to aect even asmall extensionResearchers have recently investigated the use ofmicrokernels as a vehicle for building extensible systems Black et al  Mullender et al  Cheriton Zwaenepoel  Cheriton  Duda  Thacker et al A microkernel typically exports a small numberof abstractions that include threads address spacesand communication channels These abstractions canbe combined to support more conventional operatingsystem services implemented as userlevel programsApplicationspecic extensions in a microkernel occurat or above the level of the kernels interfaces Unfortunately applications often require substantial changes toa microkernels implementation to compensate for limitations in interfaces Lee et al  Davis et al  Waldspurger  Weihl Although a microkernels communication facilitiesprovide the infrastructure for extending nearly any kernel service Barrera  Abrossimov et al  Forin et al few have been so extended We believe this is because of high communication overhead Bershad et al Draves et al  Chen  Bershad  which limits extensions mostly to coarsegrained services Golubet al  Stevenson  Julin  Bricker et al Otherwise protected interaction between system components which occurs frequently in a system with negrained extensions can be a limiting performance factorAlthough the performance of crossdomain communication has improved substantially in recent years Hamilton  Kougiouris  Hildebrand  Engler et al it still does not approach that of a procedure call encouraging the construction of monolithic nonextensiblesystems For example the L microkernel even with itsaggressive design has a protected procedure call implementation with overhead of nearly  procedure calltimes Liedtke  Liedtke  Int  As a point ofcomparison the Intel  Int  which provided hardware support for protected crossdomain transfer hada crossdomain communication overhead on the orderof about  procedure call times Colwell  and wasgenerally considered unacceptableSome systems rely on little languages to safely extend the operating system interface through the useof interpreted code that runs in the kernel Lee et al Mogul et al  Yuhara et al  These systemssuer from three problems First the languages beinglittle make the expression of arbitrary control and datastructures cumbersome and therefore limit the rangeof possible extensions Second the interface betweenthe languages programming environment and the restof the system is generally narrow making system integration dicult Finally interpretation overhead canlimit performanceMany systems provide interfaces that enable arbitrarycode to be installed into the kernel at runtime Heidemann  Popek  Rozier et al  In these systemsthe right to dene extensions is restricted because anyextension can bring down the entire system applicationspecic extensibility is not possibleSeveral projects Lucco  Engler et al  Small Seltzer  are exploring the use of software fault isolation Wahbe et al  to safely link application codewritten in any language into the kernels virtual address space Software fault isolation relies on a binaryrewriting tool that inserts explicit checks on memoryreferences and branch instructions These checks allow the system to dene protected memory segmentswithout relying on virtual memory hardware Softwarefault isolation shows promise as a colocation mechanism for relatively isolated code and data segments Itis unclear though if the mechanism is appropriate for asystem with negrained sharing where extensions mayaccess a large number of segments In addition software fault isolation is only a protection mechanism anddoes not dene an extension model or the service interfaces that determine the degree to which a system canbe extendedAegis Engler et al  is an operating system thatrelies on ecient trap redirection to export hardwareservices such as exception handling and TLB management directly to applications The system itself denesno abstractions beyond those minimally provided by thehardware Engler  Kaashoek  Instead conventional operating system services such as virtual memoryand scheduling are implemented as libraries executingin an applications address space System service codeexecuting in a library can be changed by the application according to its needs SPIN shares many of thesame goals as Aegis although its approach is quite different SPIN uses language facilities to protect the kernel from extensions and implements protected communication using procedure call Using this infrastructureSPIN provides an extension model and a core set of extensible services In contrast Aegis relies on hardwareprotected system calls to isolate extensions from the kernel and leaves unspecied the manner by which thoseextensions are dened or appliedSeveral systems Cooper et al  Redell et al Mossenbock  Organick  like SPIN have relied on language features to extend operating systemservices Pilot for instance was a singleaddress spacesystem that ran programs written in Mesa Geschkeet al  an ancestor of Modula In general systems such as Pilot have depended on the language forall protection in the system not just for the protectionof the operating system and its extensions In contrastSPINs reliance on language services applies only to extension code within the kernel Virtual address spacesare used to otherwise isolate the operating system andprograms from one another The SPIN ArchitectureThe SPIN architecture provides a software infrastructure for safely combining system and application codeThe protection model supports ecient negrained access control of resources while the extension model enables extensions to be dened at the granularity of aprocedure call The systems architecture is biased towards mechanisms that can be implemented with lowcost on conventional processors Consequently SPINmakes few demands of the hardware and instead relieson languagelevel services such as static typecheckingand dynamic linkingRelevant properties of ModulaSPIN and its extensions are written in Modula ageneral purpose programming language designed in theearly s The key features of the language includesupport for interfaces type safety automatic storagemanagement objects generic interfaces threads andexceptions We rely on the languages support for objects generic interfaces threads and exceptions for aesthetic reasons only we nd that these features simplifythe task of constructing a large systemThe design of SPIN depends only on the languagessafety and encapsulation mechanisms specically interfaces type safety and automatic storage managementAn interface declares the visible parts of an implementation module which denes the items listed in the interface All other denitions within the implementationmodule are hidden The compiler enforces this restriction at compiletime Type safety prevents code fromaccessing memory arbitrarily A pointer may only refer to objects of its referents type and array indexingoperations must be checked for bounds violation Therst restriction is enforced at compiletime and the second is enforced through a combination of compiletimeand runtime checks Automatic storage managementprevents memory used by a live pointers referent frombeing returned to the heap and reused for an object ofa dierent type The protection modelA protection model controls the set of operations thatcan be applied to resources For example a protectionmodel based on address spaces ensures that a processcan only access memory within a particular range of virtual addresses Address spaces though are frequentlyinadequate for the negrained protection and management of resources being expensive to create and slowto access Lazowska et al CapabilitiesAll kernel resources in SPIN are referenced by capabilities A capability is an unforgeable reference to a resource which can be a system object an interface or acollection of interfaces An example of each of these is aphysical page a physical page allocation interface andthe entire virtual memory system Individual resourcesare protected to ensure that extensions reference onlythe resources to which they have been given access Interfaces and collections of interfaces are protected toallow dierent extensions to have dierent views on theset of available servicesUnlike other operating systems based on capabilitieswhich rely on specialpurpose hardware Carter et al virtual memory mechanisms Wulf et al  probabilistic protection Engler et al  or protected message channels Black et al  SPIN implements capabilities directly using pointers which are supportedby the language A pointer is a reference to a block ofmemorywhose type is declared within an interface Figure  demonstrates the denition and use of interfacesand capabilities pointers in SPINThe compiler at compiletime prevents a pointerfrom being forged or dereferenced in a way inconsistent with its type There is no runtime overhead forusing a pointer passing it across an interface or dereferencing it other than the overhead of going to memoryto access the pointer or its referent A pointer can bepassed from the kernel to a userlevel application whichcannot be assumed to be type safe as an externalizedreference An externalized reference is an index into aperapplication table that contains type safe referencesto inkernel data structures The references can laterbe recovered using the index Kernel services that intend to pass a reference out to user level externalize thereference through this table and instead pass out theindexProtection domainsA protection domain denes the set of accessible namesavailable to an execution context In a conventional operating system a protection domain is implemented using virtual address spaces A name within one domaina virtual address has no relationship to that same namein another domain Only through explicit mapping andsharing operations is it possible for names to becomemeaningful between protection domainsINTERFACE Console  An interface TYPE T  REFANY  Read as ConsoleT is opaque CONST InterfaceName  ConsoleService A global name PROCEDURE OpenT Open returns a capability for the console PROCEDURE Writet T msg TEXTPROCEDURE Readt VAR msg TEXTPROCEDURE Closet TEND ConsoleMODULE Console  An implementation module  The implementation of ConsoleT TYPE Buf  ARRAY  OF CHARREVEAL T  BRANDED REF RECORD  T is a pointer inputQ Buf  to a record outputQ Buf device specific info END Implementations of interface functions  have direct access to the revealed type PROCEDURE OpenT  END ConsoleMODULE Gatekeeper  A client IMPORT ConsoleVAR c ConsoleT  A capability for  the console device PROCEDURE IntruderAlert BEGINc  ConsoleOpenConsoleWritec Intruder AlertConsoleClosecEND IntruderAlertBEGINEND GatekeeperFigure  The Gatekeeper module interacts with SPINs Console service through the Console interface Although GatekeeperIntruderAlert manipulates objects of type ConsoleT itis unable to access the elds within the object even though itexecutes within the same virtual address space as the ConsolemoduleIn SPIN the naming and protection interface is atthe level of the language not of the virtual memorysystem Consequently namespace management mustoccur at the language level For example if the namec is an instance of the type ConsoleT then both c andConsoleT occupy a portion of some symbolic namespace An extension that redenes the type ConsoleTcreates an instance of the new type and passes it toa module expecting a ConsoleT of the original typecreates a type conict that results in an error Theerror could be avoided by placing all extensions intoa global module space but since modules proceduresand variable names are visible to programmers we feltthat this would introduce an overly restrictive programming model for the system Instead SPIN provides facilities for creating coordinating and linking programlevel namespaces in the context of protection domainsINTERFACE DomainTYPE T  REFANY  DomainT is opaque PROCEDURE CreatecoffCoffFileTT Returns a domain created from the specified objectfile coff is a standard object file format PROCEDURE CreateFromModuleT Create a domain containing interfaces defined by thecalling module This function allows modules toname and export themselves at runtime PROCEDURE Resolvesourcetarget T Resolve any undefined symbols in the target domainagainst any exported symbols from the sourcePROCEDURE Combined d TT Create a new aggregate domain that exports theinterfaces of the given domains END DomainFigure  The Domain interface This interface operates on instances of type DomainT which are described by type safe pointers The implementation of the Domain interface is unsafe withrespect to Modula memory semantics as it must manipulatelinker symbols and program addresses directlyA SPIN protection domain denes a set of names orprogram symbols that can be referenced by code withaccess to the domain A domain named by a capabilityis used to control dynamic linking and corresponds toone or more safe object les with one or more exportedinterfaces An object le is safe if it is unknown to thekernel but has been signed by the Modula compileror if the kernel can otherwise assert the object le to besafe For example SPINs lowest level device interfaceis identical to the DEC OSF driver interface Dig allowing us to dynamically link vendor drivers into thekernel Although the drivers are written in C the kernelasserts their safety In general we prefer to avoid usingobject les that are safe by assertion rather than bycompiler verication as they tend to be the source ofmore than their fair share of bugsDomains can be intersecting or disjoint enabling applications to share services or dene new ones A domain is created using the Create operation which initializes a domain with the contents of a safe object leAny symbols exported by interfaces dened in the object le are exported from the domain and any imported symbols are left unresolved Unresolved symbolscorrespond to interfaces imported by code within thedomain for which implementations have not yet beenfoundThe Resolve operation serves as the basis for dynamiclinking It takes a target and a source domain andresolves any unresolved symbols in the target domainagainst symbols exported from the source During resolution text and data symbols are patched in the targetdomain ensuring that once resolved domains are ableto share resources at memory speed Resolution onlyresolves the target domains undened symbols it doesnot cause additional symbols to be exported Crosslinking a common idiom occurs through a pair of Resolve operationsThe Combine operation creates linkable namespacesthat are the union of existing domains and can be usedto bind together collections of related interfaces Forexample the domain SpinPublic combines the systemspublic interfaces into a single domain available to extensions Figure  summarizes the major operations ondomainsThe domain interface is commonly used to importor export particular named interfaces A module thatexports an interface explicitly creates a domain for itsinterface and exports the domain through an inkernelnameserver The exported name of the interface whichcan be specied within the interface is used to coordinate the export and import as in many RPC systems Schroeder  Burrows  Brockschmidt  Theconstant ConsoleInterfaceName in Figure  denes aname that exporters and importers can use to uniquelyidentify a particular version of a serviceSome interfaces such as those for devices restrict access at the time of the import An exporter can registeran authorization procedure with the nameserver thatwill be called with the identity of the importer whenever the interface is imported This negrained controlhas low cost because the importer exporter and authorizer interact through direct procedure calls The extension modelAn extension changes the way in which a system provides service All software is extensible in one wayor another but it is the extension model that determines the ease transparency and eciency with whichan extension can be applied SPINs extension modelprovides a controlled communication facility betweenextensions and the base system while allowing for avariety of interaction styles For example the modelallows extensions to passively monitor system activityand provide uptodate performance information to applications Other extensions may oer hints to the system to guide certain operations such as page replacement In other cases an extension may entirely replacean existing system service such as a scheduler with anew one more appropriate to a specic applicationExtensions in SPIN are dened in terms of eventsand handlers An event is a message that announces achange in the state of the system or a request for service An event handler is a procedure that receives themessage An extension installs a handler on an event byexplicitly registering the handler with the event througha central dispatcher that routes events to handlersEvent names are protected by the domain machinerydescribed in the previous section An event is denedas a procedure exported from an interface and its handlers are dened as procedures having the same type Ahandler is invoked with the arguments specied by theevent raiser The kernel is preemptive ensuring that ahandler cannot take over the processorThe right to call a procedure is equivalent to the rightto raise the event named by the procedure In fact thetwo are indistinguishable in SPIN and any procedureexported by an interface is also an event The dispatcherexploits this similarity to optimize event raise as a directprocedure call where there is only one handler for agiven event Otherwise the dispatcher uses dynamiccode generation Engler  Proebsting  to constructoptimized call paths from the raiser to the handlersThe primary right to handle an event is restrictedto the default implementation module for the eventwhich is the module that statically exports the procedure named by the event For example the moduleConsole is the default implementation module for theevent ConsoleOpen shown in Figure  Other modules may request that the dispatcher install additionalhandlers or even remove the primary handler For eachrequest the dispatcher contacts the primary implementation module passing the event name provided by theinstaller The implementationmodule can deny or allowthe installation If denied the installation fails If allowed the implementation module can provide a guardto be associated with the handler The guard denesa predicate expressed as a procedure that is evaluatedby the dispatcher prior to the handlers invocation Ifthe predicate is true when the event is raised then thehandler is invoked otherwise the handler is ignoredGuards are used to restrict access to events at a granularity ner than the event name allowing events to bedispatched on a perinstance basis For example theSPIN extension that implements IP layer processing denes the event IPPacketArrivedpkt IPPacket whichit raises whenever an IP packet is received The IPmodule which denes the default implementation of thePacketArrived event upon each installation constructsa guard that compares the type eld in the header ofthe incoming packet against the set of IP protocol typesthat the handler may service In this way IP does notThe dispatcher also allows a handler to specify an additionalclosure to be passed to the handler during event processing Theclosure allows a single handler to be used within more than onecontexthave to export a separate interface for each event instance A handler can stack additional guards on anevent further constraining its invocationThere may be any number of handlers installed on aparticular event The default implementation modulemay constrain a handler to execute synchronously orasynchronously in bounded time or in some arbitraryorder with respect to other handlers for the same eventEach of these constraints reects a dierent degree oftrust between the default implementation and the handler For example a handler may be bounded by a timequantum so that it is aborted if it executes too long Ahandler may be asynchronous which causes it to execute in a separate thread from the raiser isolating theraiser from handler latency When multiple handlersexecute in response to an event a single result can becommunicated back to the raiser by associating witheach event a procedure that ultimately determines thenal result Pardyak  Bershad  By default the dispatcher mimics procedure call semantics and executeshandlers synchronously to completion in undened order and returns the result of the nal handler executed The core servicesThe SPIN protection and extension mechanisms described in the previous section provide a framework formanaging interfaces between services within the kernel Applications though are ultimately concernedwith manipulating resources such as memory and theprocessor Consequently SPIN provides a set of coreservices that manage memory and processor resourcesThese services which use events to communicate between the system and extensions export interfaces withnegrained operations In general the service interfaces that are exported to extensions within the kernelare similar to the secondary internal interfaces foundin conventional operating systems they provide simplefunctionality over a small set of objects In SPIN itis straightforward to allocate a single virtual page aphysical page and then create a mapping between thetwo Because the overhead of accessing each of theseoperations is low a procedure call it is feasible to provide them as interfaces to separate abstractions and tobuild up higher level abstractions through direct composition By contrast traditional operating systems aggregate simpler abstractions into more complex onesbecause the cost of repeated access to the simpler abstractions is too high Extensible memory managementA memory management system is responsible for theallocation of virtual addresses physical addresses andmappings between the two Other systems have demonstrated signicant performance improvements from specialized or tuned memory management policies thatare accessible through interfaces exposed by the memory management system Some of these interfaces havemade it possible to manipulate large objects such as entire address spaces Young et al  Khalidi  Nelson or to direct expensive operations for example pageout Harty  Cheriton  McNamee  Armstrong entirely from user level Others have enabled controlover relatively small objects such as cache pages Romeret al  or TLB entries Bala et al  entirely fromthe kernel None have allowed for fast negrained control over the physical and virtual memory resources required by applications SPINs virtual memory systemprovides such control and is enabled by the systemslowoverhead invocation and protection servicesThe SPINmemorymanagement interface decomposesmemory services into three basic components physical storage naming and translation These correspondto the basic memory resources exported by processorsnamely physical addresses virtual addresses and translations Applicationspecic services interact with thesethree services to dene higher level virtual memory abstractions such as address spacesEach of the three basic components of the memorysystem is provided by a separate service interface described in Figure  The physical address service controls the use and allocation of physical pages Clientsraise the Allocate event to request physical memorywitha certain size and an optional series of attributes thatreect preferences for machine specic parameters suchas color or contiguity A physical page represents a unitof high speed storage It is not for most purposesa nameable entity and may not be addressed directlyfrom an extension or a user program Instead clientsof the physical address service receive a capability forthe memory The virtual address service allocates capabilities for virtual addresses where the capabilitysreferent is composed of a virtual address a lengthand an address space identier that makes the addressunique The translation service is used to express the relationship between virtual addresses and physical memory This service interprets references to both virtualand physical addresses constructs mappings betweenthe two and installs the mappings into the processorsmemory management unit MMUThe translation service raises a set of events thatcorrespond to various exceptional MMU conditionsFor example if a user program attempts to accessan unallocated virtual memory address the TranslationBadAddress event is raised If it accesses an allocated but unmapped virtual page then the TranslationPageNotPresent event is raised Implementors ofhigher level memory management abstractions can usethese events to dene services such as demand paging copyonwrite Rashid et al  distributed sharedmemory Carter et al  or concurrent garbage collection Appel  Li The physical page service may at any time reclaimphysical memory by raising the PhysAddrReclaimevent The interface allows the handler for this event tovolunteer an alternative page which may be of less importance than the candidate page The translation serINTERFACE PhysAddrTYPE T  REFANY  PhysAddrT is opaque PROCEDURE Allocatesize Size attrib Attrib T Allocate some physical memory with particularattributes PROCEDURE Deallocatep TPROCEDURE Reclaimcandidate T T Request to reclaim a candidate page Clientsmay handle this event to nominatealternative candidates END PhysAddrINTERFACE VirtAddrTYPE T  REFANY  VirtAddrT is opaque PROCEDURE Allocatesize Size attrib Attrib TPROCEDURE Deallocatev TEND VirtAddrINTERFACE TranslationIMPORT PhysAddr VirtAddrTYPE T  REFANY  TranslationT is opaque PROCEDURE Create TPROCEDURE Destroycontext T Create or destroy an addressing context PROCEDURE AddMappingcontext T v VirtAddrTp PhysAddrT prot Protection Add vp into the named translation contextwith the specified protection PROCEDURE RemoveMappingcontext T v VirtAddrTPROCEDURE ExamineMappingcontext Tv VirtAddrT Protection A few events raised during  illegal translations PROCEDURE PageNotPresentv TPROCEDURE BadAddressv TPROCEDURE ProtectionFaultv TEND TranslationFigure  The interfaces for managing physical addresses virtual addresses and translationsvice ultimately invalidates any mappings to a reclaimedpageThe SPIN core services do not dene an address spacemodel directly but can be used to implement a rangeof models using a variety of optimization techniquesFor example we have built an extension that implements UNIX address space semantics for applicationsIt exports an interface for copying an existing addressspace and for allocating additional memory within oneFor each new address space the extension allocates anew context from the translation service This contextis subsequently lled in with virtual and physical address resources obtained from the memory allocationservices Another kernel extension denes a memorymanagement interface supporting Machs task abstraction Young et al  Applications may use these interfaces or they may dene their own in terms of thelowerlevel services Extensible thread managementAn operating systems thread management system provides applications with interfaces for scheduling concurrency and synchronization Applications though canrequire levels of functionality and performance that athread management system is unable to deliver Userlevel thread management systems have addressed thismismatchWulf et al  Cooper  Draves  Marshet al  Anderson et al  but only partiallyFor example Machs userlevel CThreads implementation Cooper  Draves  can have anomalous behavior because it is not wellintegrated with kernel services Anderson et al  In contrast scheduler activations which are integrated with the kernel have highcommunication overhead Davis et al In SPIN an application can provide its own threadpackage and scheduler that executes within the kernelThe thread package denes the applications executionmodel and synchronization constructs The schedulercontrols the multiplexing of the processor across multiple threads Together these packages allow an application to dene arbitrary thread semantics and to implement those semantics close to the processor and otherkernel servicesAlthough SPIN does not dene a thread model forapplications it does dene the structure on which animplementation of a thread model rests This structureis dened by a set of events that are raised or handledby schedulers and thread packages A scheduler multiplexes the underlying processing resources among competing contexts called strands A strand is similar toa thread in traditional operating systems in that it reects some processor context Unlike a thread thougha strand has no minimal or requisite kernel state otherthan a name An applicationspecic thread packagedenes an implementation of the strand interface for itsown threadsTogether the thread package and the scheduler implement the control ow mechanisms for userspace contexts Figure  describes this interface The interfacecontains two events Block and Unblock that can beraised to signal changes in a strands execution state Adisk driver can direct a scheduler to block the currentstrand during an IO operation and an interrupt handler can unblock a strand to signal the completion of theIO operation In response to these events the scheduler can communicate with the thread package managing the strand using Checkpoint and Resume eventsallowing the package to save and restore execution stateINTERFACE StrandTYPE T  REFANY  StrandT is opaque PROCEDURE BlocksT Signal to a scheduler that s is not runnable PROCEDURE Unblocks T Signal to a scheduler that s is runnable PROCEDURE Checkpoints T Signal that s is being descheduled and that itshould save any processor state required forsubsequent rescheduling PROCEDURE Resumes T Signal that s is being placed on a processor andthat it should reestablish any state saved duringa prior call to Checkpoint END StrandFigure  The Strand Interface This interface describes thescheduling events aecting control ow that can be raised withinthe kernel Applicationspecic schedulers and thread packagesinstall handlers on these events which are raised on behalf ofparticular strands A trusted thread package and scheduler provide default implementations of these operations and ensure thatextensions do not install handlers on strands for which they donot possess a capabilityApplicationspecic thread packages only manipulatethe ow of control for application threads executing outside of the kernel For safety reasons the responsibility for scheduling and synchronization within the kernel belongs to the kernel As a thread transfers fromuser mode to kernel mode it is checkpointed and aModula thread executes in the kernel on its behalfAs the Modula thread leaves the kernel the blockedapplicationspecic thread is resumedA global scheduler implements the primary processor allocation policy between strands Additionalapplicationspecic schedulers can be placed on topof the global scheduler using Checkpoint and Resumeevents to relinquish or receive control of the processorThat is an applicationspecic scheduler presents itselfto the global scheduler as a thread package The delivery of the Resume event indicates that the new scheduler can schedule its own strands while Checkpoint signals that the processor is being reclaimed by the globalschedulerThe Block and Unblock events when raised on strandsscheduled by applicationspecic schedulers are routedby the dispatcher to the appropriate scheduling implementation This allows new scheduling policies to beimplemented and integrated into the kernel providedthat an applicationspecic policy does not conict withthe global policy While the global scheduling policy isreplaceable it cannot be replaced by an arbitrary application and its replacement can have global eects Inthe current implementation the global scheduler implements a roundrobin preemptive priority policyWe have used the strand interface to implement askernel extensions a variety of thread management interfaces including DEC OSF kernel threads Dig  CThreads Cooper  Draves  and Modula threadsThe implementations of these interfaces are built directly from strands and not layered on top of othersThe interface supporting DEC OSF kernel threadsallows us to incorporate the vendors device drivers directly into the kernel The CThreads implementationsupports our UNIX server which uses the Mach CThreads interface for concurrency Within the kernela trusted thread package and scheduler implements theModula thread interface Nelson  Implications for trusted servicesThe processor and memory services are two instances ofSPINs core services which provide interfaces to hardware mechanisms The core services are trusted whichmeans that they must perform according to their interface specication Trust is required because the services access underlying hardware facilities and at timesmust step outside the protection model enforced by thelanguage Without trust the protection and extensionmechanisms described in the previous section could notfunction safely as they rely on the proper managementof the hardware Because trusted services mediate access to physical resources applications and extensionsmust trust the services that are trusted by the SPINkernelIn designing the interfaces for SPINs trusted serviceswe have worked to ensure that an extensions failure touse an interface correctly is isolated to the extensionitself and any others that rely on it For examplethe SPIN scheduler raises events that are handled byapplicationspecic thread packages in order to start orstop threads Although it is in the handlers best interests to respect or at least not interfere with thesemantics implied by the event this is not enforcedAn applicationspecic thread package may ignore theevent that a particular userlevel thread is runnablebut only the application using the thread package willbe aected In this way the failure of an extension isno more catastrophic than the failure of code executingin the runtime libraries found in conventional systems System performanceIn this section we show that SPIN enables applicationsto compose system services in order to dene new kernelservices that perform well Specically we evaluate theperformance of SPIN from four perspectives System size The size of the system in terms of linesof code and object size demonstrates that advancedruntime services do not necessarily create an operating system kernel of excessive size In additionthe size of the systems extensions shows that theycan be implemented with reasonable amounts ofcode Microbenchmarks Measurements of lowlevel system services such as protected communicationthread management and virtual memory show thatSPINs extension architecture enables us to construct communicationintensive services with lowoverhead The measurements also show that conventional system mechanisms such as a system calland crossaddress space protected procedure callhave overheads that are comparable to those in conventional systems Networking Measurements of a suite of networking protocols demonstrate that SPINs extensionarchitecture enables the implementation of highperformance network protocols Endtoend performance Finally we show thatendtoend application performance can benetfrom SPINs architecture by describing two applications that use system extensionsWe compare the performance of operations on threeoperating systems that run on the same platform SPINV of August  DEC OSF V which is amonolithic operating system and Mach  which is amicrokernel We collected our measurements on DECAlpha MHz AXP  workstations which arerated at  SPECint  Each machine has  MBs ofmemory a KB unied external cache an HP C GB diskdrive a Mbsec Lance Ethernet interface and a FORE TCA Mbsec ATM adaptercard connected to a FORE ASX switch The FOREcards use programmed IO and can maximally deliveronly about Mbsec between a pair of hosts Brustoloni Bershad  We avoid comparisons with operatingsystems running on dierent hardware as benchmarkstend to scale poorly for a variety of architectural reasons Anderson et al  All measurements are takenwhile the operating systems run in singleuser mode System componentsSPIN runs as a standalone kernel on DEC Alpha workstations The system consists of ve main componentssys core rt lib and sal that support dierent classesof service Table  shows the size of each componentin source lines object bytes and percentages The rstcomponent sys implements the extensibility machinery domains naming linking and dispatching Thesecond component core implements the virtual memory and scheduling services described in the previoussection as well as device management a diskbased andnetworkbased le system and a network debugger Redell  The third component rt contains a version ofthe DEC SRC Modula runtime system that supportsautomatic memory management and exception processing The fourth component lib includes a subset of thestandard Modula libraries and handles many of themore mundane data structures lists queues hash tables etc generally required by any operating systemkernel The nal component sal implements a lowlevel interface to device drivers and the MMU oeringfunctionality such as install a page table entry geta character from the console and read block  fromSCSI unit  We build sal by applying a few dozen ledis against a small subset of the les from the DECOSF kernel source tree This approach while increasing the size of the kernel allows us to track the vendorshardware without requiring that we port SPIN to eachnew system congurationComponent Source size Text size Data sizelines  bytes  bytes sys      core      rt      lib      sal      Total kernel      Table  This table shows the size of dierent components of thesystem The sys core and rt components contain the interfacesvisible to extensions The column labeled lines does not includecomments We use the DEC SRC Modula compiler release  MicrobenchmarksMicrobenchmarks reveal the overhead of basic systemfunctions such a protected procedure call thread management and virtual memory They dene the boundsof system performance and provide a framework forunderstanding larger operations Times presented inthis section measured with the Alphas internal cyclecounter are the average of a large number of iterationsand may therefore be overly optimistic regarding cacheeects Bershad et al aProtected communicationIn a conventional operating system applications services and extensions communicate using two protectedmechanisms system calls and crossaddress space callsThe rst enables applications and kernel services to interact The second enables interaction between applications and services that are not part of the kernelThe overhead of using either of these mechanisms is thelimiting factor in a conventional systems extensibilityHigh overhead discourages frequent interaction requiring that a system be built from coarsegrained interfacesto amortize the cost of communication over large operationsSPINs extension model oers a third mechanismfor protected communication Simple procedure callsrather than system calls can be used for communication between extensions and the core system Similarlysimple procedure calls rather than crossaddress procedure calls can be used for communication betweenapplications and other services installed into the kernelIn Table  we compare the performance of the different protected communication mechanisms when invoking the null procedure call on DEC OSF Machand SPIN The null procedure call takes no argumentsand returns no results it reects only the cost of control transfer The protected inkernel call in SPINis implemented as a procedure call between two domains that have been dynamically linked Althoughthis test does not measure data transfer the overheadof passing arguments between domains even large arguments is small because they can be passed by reference System call overhead reects the time to crossthe userkernel boundary execute a procedure and return In Mach and DEC OSF system calls ow fromthe trap handler through to a generic but xed system call dispatcher and from there to the requestedsystem call written in C In SPIN the kernels traphandler raises a TrapSystemCall event which is dispatched to a Modula procedure installed as a handlerThe third line in the table shows the time to performa protected crossaddress space procedure call DECOSF supports crossaddress space procedure call using sockets and SUN RPC Mach provides an optimizedpath for crossaddress space communication using messages Draves  SPINs crossaddress space procedurecall is implemented as an extension that uses systemcalls to transfer control in and out of the kernel andcrossdomain procedure calls within the kernel to transfer control between address spacesOperation DEC OSF Mach SPINProtected inkernel call na na System call   Crossaddress space call   Table  Protected communication overhead in microsecondsNeither DEC OSF nor Mach support protected inkernel communicationThe table illustrates two points about communicationand system structure First the overhead of protectedcommunication in SPIN can be that of procedure callfor extensions executing in the kernels address spaceSPINs protected inkernel calls provide the same functionality as crossaddress space calls in DEC OSF andMach namely the ability to execute arbitrary code inresponse to an applications call Second SPINs extensible architecture does not preclude the use of traditional communication mechanisms having performancecomparable to that in nonextensible systems Howeverthe disparity between the performance of a protected inkernel call and the other mechanisms encourages the useof inkernel extensionsSPINs inkernel protected procedure call time is conservative Our Modula compiler generates code forwhich an intermodule call is roughly twice as slow as anintramodule call A more recent version of the Modulacompiler corrects this disparity In addition our compiler does not perform inlining which can be an important optimization when calling many small proceduresThese optimizations do not aect the semantics of thelanguage and will therefore not change the systems protection modelThread managementThread management packages implement concurrencycontrol operations using underlying kernel services Aspreviously mentioned SPINs inkernel threads are implemented with a trusted thread package exporting theModula thread interface Applicationspecic extensions also rely on threads executing in the kernel to implement their own concurrent operations At user levelthread management overhead determines the granularity with which threads can be used to control concurrentuserlevel operationsTable  shows the overhead of thread managementoperations for kernel and user threads using the dierent systems ForkJoin measures the time to createschedule and terminate a new thread synchronizingthe termination with another thread PingPong reectssynchronization overhead and measures the time for apair of threads to synchronize with one another the rstthread signals the second and blocks then the secondsignals the rst and blocksWe measure kernel thread overheads using the native primitives provided by each kernel thread sleep andthread wakeup in DEC OSF and Mach and locks withcondition variables in SPIN At userlevel we measurethe performance of the same program using CThreadson Mach and SPIN and PThreads a CThreads superset on DEC OSF The table shows measurements fortwo implementations of CThreads on SPIN The rstimplementation labeled layered is implemented asa userlevel library layered on a set of kernel extensionsthat implementMachs kernel thread interface The second implementation labeled integrated is structuredas a kernel extension that exports the CThreads interface using system calls The latter version uses SPINsstrand interface and is integrated with the schedulingbehavior of the rest of the kernel The table showsthat SPINs extensible thread implementation does notincur a performance penalty when compared to nonextensible ones even when integrated with kernel servicesVirtual memoryApplications can exploit the virtual memory fault pathto extend system services Appel  Li  For exampleconcurrent and generational garbage collectors can usewrite faults to maintain invariants or collect referenceinformation A longstanding problem with faultbasedDEC OSF Mach SPINkernel user kernel user kernel userOperation layered integratedForkJoin       PingPong       Table  Thread management overhead in microsecondsstrategies has been the overhead of handling a page faultin an application Thekkath  Levy  Anderson et al There are two sources of this overhead First handling each fault in a user application requires crossingthe userkernel boundary several times Second conventional systems provide quite general exception interfaces that can perform many functions at once As aresult applications requiring only a subset of the interfaces functionality must pay for all of it SPIN allowsapplications to dene specialized fault handling extensions to avoid userkernel boundary crossings and implement precisely the functionality that is requiredTable  shows the time to execute several commonlyreferenced virtual memory benchmarks Appel  Li Engler et al  The line labeled Dirty in thetable measures the time for an application to query thestatus of a particular virtual page Neither DEC OSFnor Mach provide this facility The time shown in thetable is for an extension to invoke the virtual memorysystem an additional  microseconds system call timeis required to invoke the service from user level Trapmeasures the latency between a page fault and the timewhen a handler executes Fault is the perceived latencyof the access from the standpoint of the faulting threadIt measures the time to reect a page fault to an application enable access to the page within a handler andresume the faulting thread Prot measures the timeto increase the protection of a single page SimilarlyProt and Unprot measure the time to increaseand decrease the protection over a range of  pagesMachs unprotection is faster than protection since theoperation is performed lazily SPINs extension does notlazily evaluate the request but enables the access as requested Appel and Appel measure a combination oftraps and protection changes The Appel benchmarkmeasures the time to fault on a protected page resolvethe fault in the handler and protect another page inthe handler Appel measures the time to protect pages and fault on each one resolving the fault in thehandler Appel is shown as the average cost per pageSPIN outperforms the other systems on the virtualmemory benchmarks for two reasons First SPIN useskernel extensions to dene applicationspecic systemcalls for virtual memory management The calls provide access to the virtual and physical memory interfaces described in the previous section and install handlers for TranslationProtectionFault events that occurwithin the applications virtual address space In contrast DEC OSF requires that applications use theUNIX signal and mprotect interfaces to manage virtualmemory and Mach requires that they use the external pager interface Young et al  Neither signalsnor external pagers though have especially ecient implementations as the focus of each is generalized functionality Thekkath  Levy  The second reason forSPINs dominance is that each virtual memory eventwhich requires a series of interactions between the kernel and the application is reected to the applicationthrough a fast inkernel protected procedure call DECOSF and Mach though communicate these eventsby means of more expensive traps or messagesOperation DEC OSF Mach SPINDirty na na Fault   Trap   Prot   Prot   Unprot   Appel   Appel   Table  Virtual memory operation overheads in microsecondsNeither DEC OSF nor Mach provide an interface for queryingthe internal state of a page frame NetworkingWe have used SPINs extension architecture to implement a set of network protocol stacks for Ethernet andATM networks Fiuczynski  Bershad  Figure  illustrates the structure of the protocol stacks which aresimilar to the xkernels Hutchinson et al  exceptthat SPIN permits user code to be dynamically placedwithin the stack Each incoming packet is pushedthrough the protocol graph by events and pulled byhandlers The handlers at the top of the graph can process the message entirely within the kernel or copy itout to an application The RPC and AM extensionsfor example implement the network transport for a remote procedure call package and active messages vonEicken et al  The video extension provides a direct path for video packets from the network to theframebuer The UDP and TCP extensions supportthe Internet protocols The Forward extension provides transparent UDPIP and TCPIP forwarding forpackets arriving on a specic port Finally the HTTPextension implements the HyperText Transport Protocol BernersLee et al  directly within the kernelenabling a server to respond quickly to HTTP requestsby splicing together the protocol stack and the local lesystemLatency and BandwidthTable  shows the round trip latency and reliable bandwidth between two applications using UDPIP on DECWe currently use the DEC OSF TCP engine as a SPINextension and manually assert that the code which is written inC is safeFigure  This gure shows a protocol stack that routes incoming network packets to applicationspecic endpoints within thekernel Ovals represent events raised to route control to handlerswhich are represented by boxes Handlers implement the protocolcorresponding to their labelOSF and SPIN For DEC OSF the applicationcode executes at user level and each packet sent involves a trap and several copy operations as the datamoves across the userkernel boundary For SPIN theapplication code executes as an extension in the kernelwhere it has lowlatency access to both the device anddata Each incoming packet causes a series of eventsto be generated for each layer in the UDPIP protocol stack EthernetATM IP UDP shown in Figure For SPIN protocol processing is done by a separatelyscheduled kernel thread outside of the interrupt handlerWe do not present networking measurements for Machas the system neither provides a path to the Ethernetmore ecient than DEC OSF nor supports our ATMcardLatency BandwidthDEC OSF SPIN DEC OSF SPINEthernet    ATM    Table  Network protocol latency in microseconds and receivebandwidth in Mbsec We measure latency using small packets bytes and bandwidth using large packets  for Ethernetand  for ATMThe table shows that processing packets entirelywithin the kernel can reduce roundtrip latency whencompared to a system in which packets are handled inuser space Throughput which tends not to be latencysensitive is roughly the same on both systemsWe use the same vendor device drivers for both DECOSF and SPIN to isolate dierences due to systemarchitecture from those due to the characteristics of theunderlying device driver Neither the Lance Ethernetdriver nor the FORE ATM driver are optimized for latency Thekkath  Levy  and only the Lance Ethernet driver is optimized for throughput Using dierentdevice drivers we achieve a roundtrip latency of secs on Ethernet and  secs on ATM while reliable ATM bandwidth between a pair of hosts rises to Mbsec We estimate the minimum round trip timeusing our hardware at roughly secs on Ethernet andsecs on ATM The maximum usable Ethernet andATM bandwidths between a pair of hosts are roughly Mbsec and MbsecProtocol forwardingSPINs extension architecture can be used to provideprotocol functionality not generally available in conventional systems For example some TCP redirectionprotocols Balakrishnan et al  that have otherwiserequired kernel modications can be straightforwardlydened by an application as a SPIN extension A forwarding protocol can also be used to load balance service requests across multiple serversIn SPIN an application installs a node into the protocol stack which redirects all data and control packetsdestined for a particular port number to a secondaryhost We have implemented a similar service using DECOSF with a userlevel process that splices togetheran incoming and outgoing socket The DEC OSFforwarder is not able to forward protocol control packets because it executes above the transport layer Asa result it cannot maintain a protocols endtoend semantics In the case of TCP endtoend connectionestablishment and termination semantics are violatedA userlevel intermediary also interferes with the protocols algorithms for window size negotiation slow startfailure detection and congestion control possibly degrading the overall performance of connections betweenthe hosts Moreover on the userlevel forwarder eachpacket makes two trips through the protocol stack whereit is twice copied across the userkernel boundary Table  compares the latency for the two implementationsand reveals the additional work done by the userlevelforwarderTCP UDPDEC OSF SPIN DEC OSF SPINEthernet    ATM    Table  Round trip latency in microseconds to route  bytepackets through a protocol forwarder Endtoend performanceWe have implemented several applications that exploitSPINs extensibility One is a networked video systemthat consists of a server and a client viewer The serveris structured as three kernel extensions one that usesthe local le system to read video frames from the diskanother that sends the video out over the network and athird that registers itself as a handler on the SendPacketevent transforming the single send into a multicast toa list of clients The server transmits  frames persecond to each client On the client an extension awaitsincoming video packets decompresses and writes themdirectly to the frame buer using the structure shownin Figure Because each outgoing packet is pushed through theprotocol graph only once and not once per clientstream SPINs server can support a larger number ofclients than one that processes each packet in isolationTo show this we measure processor utilization as a function of the number of clients for the SPIN server and fora server that runs on DEC OSF The DEC OSFserver executes in user space and communicates withclients using sockets each outgoing packet is copied intothe kernel and is pushed through the kernels protocolstack into the device driver We determine processorutilization by measuring the progress of a lowpriorityidle thread that executes on the serverUsing the FORE interface we nd that both SPINand DEC OSF consume roughly the same fraction ofthe servers processor for a given number of clients Although the SPIN server does less work in the protocolstack the majority of the servers CPU resources areconsumed by the programmed IO that copies data tothe network one word at a time Using a network interface that supports DMA though we nd that the SPINservers processor utilization grows less slowly than theDEC OSF servers Figure  shows server processor utilization as a function of the number of supportedclient streams when the server is congured with a Digital TPKT adapter The T is an experimental network interface that can send  Mbsec using DMA Weuse the same device driver in both operating systemsAt  streams both SPIN and DEC OSF saturatethe network but SPIN consumes only half as much ofthe processor Compared to DEC OSF SPIN cansupport more clients on a faster network or as manyclients on a slower processorAnother application that can benet from SPINsarchitecture is a web server To service requestsquickly a web server should cache recently accessedobjects not cache large objects that are infrequentlyaccessed Chankhunthod et al  and avoid doublebuering with other caching agents Stonebraker A server that does not itself cache but is built on topof a conventional caching le system avoids the doublebuering problem but is unable to control the cachingpolicy In contrast a server that controls its own cacheon top of the le systems suers from double bueringSPIN allows a server to both control its cache andavoid the problem of double buering A SPIN webserver implements its own hybrid caching policy basedon le type LRU for small les and nocache for largeles which tend to be accessed infrequently The clientside latency of an HTTP transaction to a SPIN webserver running as a kernel extension is  millisecondswhen the requested le is in the servers cache Otherwise the server goes through a noncaching le sys0510152025303540452 4 6 8 10 12 14CPU UtilizationNumber of ClientsSPIN T3 DriverDEC OSF1 T3 DriverFigure  Server utilizationas a function of the number of clientvideo streams Each stream requires approximately  Mbsectem to nd the le A comparable userlevel web serveron DEC OSF that relies on the operating systemscaching le system no double buering takes about milliseconds per request for the same cached le Other issuesScalability and the dispatcherSPINs event dispatcher matches event raisers to handlers Since every procedure in the system is eectivelyan event the latency of the dispatcher is critical Asmentioned in the case of a single synchronous handler an event raise is implemented as a procedure callfrom the raiser to the handler In other cases such aswhen there are many handlers registered for a particularevent the dispatcher takes a more active role in eventdelivery For each guardhandler pair installed on anevent the dispatcher evaluates the guard and if trueinvokes the handler Consequently dispatcher latencydepends on the number and complexity of the guardsand the number of event handlers ultimately invokedIn practice the overhead of an event dispatch is linearwith the number of guards and handlers installed onthe event For example round trip Ethernet latencywhich we measure at  secs rises to about  secswhen  additional guards and handlers register interest in the arrival of some UDP packet but all  guardsevaluate to false When all  guards evaluate to truelatency rises to  secs Presently we perform noguardspecic optimizations such as evaluating commonsubexpressions Yuhara et al  or representing guardpredicates as decision trees As the system matures weplan to apply these optimizationsImpact of automatic storage managementAn extensible system cannot depend on the correctnessof unprivileged clients for its memory integrity As previously mentioned memory management schemes thatallow extensions to return objects to the system heap areunsafe because a rogue client can violate the type systemby retaining a reference to a freed object SPIN uses atracebased mostlycopying garbage collector Bartlett to safely reclaim memory resources The collectorserves as a safety net for untrusted extensions and ensures that resources released by an extension eitherthrough inaction or as a result of premature termination are eventually reclaimedClients that allocate large amounts of memory cantrigger frequent garbage collections with adverse globaleects In practice this is less of a problem than mightbe expected because SPIN and its extensions avoid allocation on fast paths For example none of the measurements presented in this section change when we disablethe collector during the tests Even in systems without garbage collection generalized allocation is avoidedbecause of its high latency Instead subsystems implement their own allocators optimized for some expectedusage pattern SPIN services do this as well and for thesame reason dynamic memory allocation is relativelyexpensive As a consequence there is less pressure onthe collector and the pressure is least likely to be applied during a critical pathSize of extensionsTable  shows the size of some of the extensions described in this section SPIN extensions tend to requirean amount of code commensurate with their functionality For example the Null syscall and IPC extensionsare conceptually simple and also have simple implementations Extensions tend to import relatively fewabout a dozen interfaces and use the domain andevent system in fairly stylized ways As a result wehave not found building extensions to be exceptionallydicult In contrast we had more trouble correctly implementing a few of our benchmarks on DEC OSFor Mach because we were sometimes forced to followcircuitous routes to achieve a particular level of functionality Machs external pager interface for instancerequired us to implement a complete pager in user spacealthough we were only interested in discovering writeprotect faults Experiences with ModulaOur decision to use Modula was made with some careOriginally we had intended to dene and implement acompiler for a safe subset of C All of us being C programmers were certain that it was infeasible to buildan ecient operating system without using a languagehaving the syntax semantics and performance of C Asthe design of our safe subset proceeded we faced the difComponent Source size Text size Data sizelines bytes bytesNULL syscall   IPC   CThreads   DEC OSF threads   VM workload   IP   UDP   TCP   HTTP   TCP Forward   UDP Forward   Video Client   Video Server   Table  This table shows the size of some dierent systemextensions described in this papercult issues that typically arise in any language designor redesign For each major issue that we consideredin the context of a safe version of C type semanticsobjects storage management naming etc we foundthe issue already satisfactorily addressed by ModulaMoreover we understood that the denition of our service interfaces was more important than the languagewith which we implemented themUltimately we decided to use Modula for both thesystem and its extensions Early on we found evidenceto abandon our two main prejudices about the languagethat programs written in it are slow and large and thatC programmers could not be eective using another language In terms of performance we have found nothingremarkable about the languages code size or executiontime as shown in the previous section In terms of programmer eectiveness we have found that it takes lessthan a day for a competent C programmer to learn thesyntax and more obvious semantics of Modula andanother few days to become procient with its moreadvanced features Although anecdotal our experiencehas been that the portions of the SPIN kernel writtenin Modula are much more robust and easier to understand than those portions written in C ConclusionsThe SPIN operating system demonstrates that it is possible to achieve good performance in an extensible system without compromising safety The system providesa set of ecient mechanisms for extending services aswell as a core set of extensible services Colocationenforced modularity logical protection domains and dynamic call binding allow extensions to be dynamicallydened and accessed at the granularity of a procedurecallIn the past system builders have only relied onthe programming language to translate operating system policies and mechanisms into machine code Using a programming language with the appropriate features we believe that operating system implementorscan more heavily rely on compiler and language runtime services to construct systems in which structureand performance are complementaryAdditional information about the SPIN project isavailable at httpwwwspincswashingtonedu an Alpha workstation running SPIN and the HTTP extensiondescribed in this paperAcknowledgementsMany people have contributed to the SPIN projectDavid Dion has been responsible for bringing up thesystems UNIX server Jan Sanislo made it possible forus to use the DEC OSF SCSI driver from SPIN Anthony Lamarca Dylan McNamee Geo Voelker andAlec Wolman assisted in understanding system performance on DEC OSF and Mach David Nichols HankLevy and Terri Watson provided feedback on earlierdrafts of this paper David Boggs provided us with theT cards that we used in the video server experimentSpecial thanks are due to DEC SRC who provided uswith much of our compiler infrastructureReferencesAbrossimov et al  Abrossimov V Rozier M and ShapiroM Generic Virtual Memory Management for OperatingSystem Kernels In Proceedings of the Thirteenth ACMSymposium on Operating Systems Principles pages  Litcheld Park AZ December Anderson et al  Anderson T E Levy H M BershadB N and Lazowska E D The Interaction of Architectureand Operating SystemDesign In Proceedings of the FourthInternational Conference on Architectural Support for Programming Languages and Operating Systems ASPLOSIV pages  Santa Clara CA April Anderson et al  Anderson T E Bershad B N LazowskaE D and Levy H M Scheduler Activations Eective Kernel Support for the UserLevel Management ofParallelism ACM Transactions on Computer Systems February Appel  Li  Appel W and Li K Virtual Memory Primitives for User Programs In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOSIV pages  Santa Clara CA April Bala et al  Bala K Kaashoek M F and Weihl W ESoftware Prefetching and Caching for Translation Lookaside Buers In Proceedings of the First USENIX Symposium on Operating Systems Design and ImplementationOSDI pages  Monterey CA November Balakrishnan et al  Balakrishnan H Seshan S Amir Eand Katz R H Improving TCPIP Performance overWireless Networks In Proceedings of the First ACM Conference on Mobile Computing and Networking NovemberBarrera  Barrera J S A Fast Mach Network IPC Implementation In Proceedings of the Second USENIX MachSymposium pages  Monterey CA November Bartlett  Bartlett J F CompactingGarbage Collection withAmbiguous Roots Technical Report WRLTR Digital EquipmentCorporationWestern Research Labs February BernersLee et al  BernersLee T Cailliau R LuotonenA Nielsen H F and Secretr A The WorldWide WebCommunications of the ACM  August Bershad  Bershad B N Practical Considerations for NonBlocking Concurrent Objects In Proceedings of the Thirteenth International Conference on Distributed ComputingSystems pages  Pittsburgh PA May Bershad et al  Bershad B N Anderson T E LazowskaE D and Levy H M Lightweight Remote ProcedureCall ACM Transactions on Computer Systems  February Bershad et al a Bershad B N Draves R P and Forin AUsing Microbenchmarks to Evaluate System PerformanceIn Proceedings of the Third Workshop on Workstation Operating Systems pages  Key Biscayne FL AprilBershad et al b Bershad B N Redell D D and Ellis J RFast Mutual Exclusion for Uniprocessors In Proceedings ofthe Fifth International Conference on Architectural Support for Programming Languages and Operating SystemsASPLOSV pages  Boston MA October Black et al  Black D L et al Microkernel Operating SystemArchitecture and Mach In Proceedings of the USENIXWorkshop on MicroKernels and Other Kernel Architectures pages  Seattle WA April Bricker et al  Bricker A Gien M Guillemont M Lipkis J Orr D and Rozier M A New Look at Microkernelbased UNIX Operating Systems Lessons in Performance and Compatibility In Proceedings of the EurOpenSpring Conference Tromsoe Norway May Brockschmidt  Brockschmidt K Inside OLE  MicrosoftPress Brustoloni  Bershad  Brustoloni J C and Bershad B NSimple Protocol Processing for HighBandwidth LowLatency Networking Technical Report CMUCSCarnegie Mellon University March Cao et al  Cao P Felten E W and Li K Implementationand Performance of ApplicationControlled File CachingIn Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation OSDI pages Monterey CA November Carter et al  Carter J B Bennett J K and ZwaenepoelW Implementation and Performance of Munin In Proceedings of the Thirteenth ACM Symposium on OperatingSystems Principles pages  Pacic Grove CA October Carter et al  Carter N P Keckler S W and Dally W JHardware Support for Fast CapabilityBased AddressingIn Proceedings of the Sixth International Conference onArchitectural Support for Programming Languages and Operating Systems ASPLOSVI pages  San JoseCA October Chankhunthod et al  Chankhunthod A Danzig P Neerdaels C Schwartz M and Worrell K A HierarchicalInternet Object Cache Technical Report CUCSDCS University of Colorado July Chen  Bershad  Chen J B and Bershad B N The Impact of Operating System Structure on Memory SystemPerformance In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles pages Asheville NC December Cheriton  Duda  Cheriton D R and Duda K J ACaching Model of Operating System Kernel FunctionalityIn Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation OSDI pages Monterey CA November Cheriton  Zwaenepoel  Cheriton D R and ZwaenepoelW The DistributedV Kernel and its Performance for Diskless Workstations In Proceedings of the Ninth ACM Symposium on Operating Systems Principles pages Bretton Woods NH October Colwell  Colwell R The Performance Eects of Functional Migration and Architectural Complexity in ObjectOriented Systems Technical Report CMUCSCarnegie Mellon University August Cooper  Draves  Cooper E C and Draves R P CThreads Technical ReportCMUCS CarnegieMellon University June Cooper et al  Cooper E Harper R and Lee P TheFox Project Advanced Development of Systems SoftwareTechnical Report CMUCS Carnegie Mellon University August Davis et al  Davis PB McNamee D Vaswani R andLazowska E Adding Scheduler Activations to Mach In Proceedings of the Third USENIX Mach Symposiumpages  Santa Fe NM April Dig  Digital Equipment Corporation DEC OSF WritingDevice Drivers Advanced Topics Draves  Draves R The Case for RunTime Replaceable Kernel Modules In Proceedings of the Fourth Workshop onWorkstation Operating Systems pages  Napa CAOctober Draves  Draves R P Control Transfer in Operating SystemKernels Technical Report CMUCS Carnegie Mellon University May Draves et al  Draves R P Bershad B N Rashid R Fand Dean R W Using Continuations to ImplementThread Management and Communication in OperatingSystems In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles pages  Pacic Grove CA October Engler  Kaashoek  Engler D and Kaashoek M F Exterminate All Operating System Abstractions In Proceedingsof the Fifth Workshop on Hot Topics in Operating Systemspages  Orcas Island WA May Engler  Proebsting  Engler D R and Proebsting T ADCG An Ecient Retargettable Dynamic Code Generation System InProceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOSVI pages  San Jose CA October Engler et al  Engler D Kaashoek M F and OToole JThe Operating System Kernel as a Secure ProgrammableMachine In Proceedings of the  ACM EuropeanSIGOPS Workshop September Engler et al  Engler D R Kaashoek M F and JrJ O Exokernel An Operating System Architecture forApplicationLevel Resource Management In Proceedingsof the Fifteenth ACM Symposium on Operating SystemsPrinciples Copper Mountain CO December Fall  Pasquale  Fall K and Pasquale J ImprovingContinuousMedia Playback Performance with InKernelData Paths In Proceedings of the First IEEE International Conference on Multimedia Computing and Systemspages  Boston MA May Felten  Felten E W The Case for ApplicationSpecicCommunication Protocols In Intel Supercomputer SystemsTechnology Focus Conference pages  April Fiuczynski  Bershad  Fiuczynski M and Bershad B AnExtensible Protocol Architecture for ApplicationSpecicNetworking In Proceedings of the  Winter USENIXConference San Diego CA January Forin et al  Forin A Golub D and Bershad B N AnIO System for Mach  In Proceedings of the SecondUSENIX Mach Symposium pages  Monterey CANovember Geschke et al  Geschke C Morris J and SatterthwaiteE Early Experiences with Mesa Communications of theACM  August Golub et al  Golub D Dean R Forin A and RashidR Unix as an Application Program In Proceedings ofthe  Summer USENIX Conference pages  JuneHamilton  Kougiouris  Hamilton G and Kougiouris PThe Spring Nucleus A Microkernel for Objects In Proceedings of the  Summer USENIX Conference pages Cincinnati OH June Harty  Cheriton  HartyK and Cheriton D R ApplicationControlled PhysicalMemory using External PageCache Management In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOSIV pages  Santa ClaraCA April Heidemann  Popek  Heidemann J and Popek G FileSystem Development with Stackable Layers Communications of the ACM  February Hildebrand  Hildebrand D An Architectural Overview ofQNX In Proceedings of the USENIX Workshop on MicroKernels and Other Kernel Architectures pages Seattle WA April Hutchinson et al  Hutchinson N C Peterson L AbbottM B and OMalley S RPC in xkernel Evaluating NewDesign Techniques In Proceedings of the Thirteenth ACMSymposium on Operating Systems Principles pages  Litcheld Park AZ December Int  Intel Corporation Introduction to the iAPX  Architecture Int  Intel Corporation i Microprocessor ProgrammersReference Manual Khalidi  Nelson  Khalidi Y A and Nelson M An Implementation of UNIX on an ObjectOriented OperatingSystem In Proceedings of the  Winter USENIX Conference pages  San Diego CA January Lazowska et al  Lazowska E D Levy H M Almes G TFischer M Fowler R and Vestal S The Architectureof the Eden System In Proceedings of the Eighth ACMSymposium on Operating Systems Principles pages  December Lee et al  Lee C H Chen M C and Chang R C HiPECHigh Performance External Virtual Memory Caching InProceedings of the First USENIX Symposium on OperatingSystems Design and Implementation OSDI pages  Monterey CA November Liedtke  Liedtke J Fast Thread Management and Communication Without Continuations In Proceedings of theUSENIX Workshop on MicroKernels and Other KernelArchitectures pages  Seattle WA April Liedtke  Liedtke J Improving IPC by Kernel Design InProceedings of the Fourteenth ACM Symposium on Operating Systems Principles pages  Asheville NCDecember Lucco  Lucco S HighPerformance Microkernel Systems InProceedings of the First USENIX Symposium on Operating Systems Design and Implementation OSDI page Monterey CA November Maeda  Bershad  Maeda C and Bershad B N ProtocolService Decomposition for HighPerformance NetworkingIn Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles pages  Asheville NCDecember Marsh et al  Marsh B Scott M LeBlanc T andMarkatos E FirstClass UserLevel Threads In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles pages  Pacic Grove CA October McNamee  Armstrong  McNamee D and Armstrong KExtending theMach External Pager Interface to Accommodate UserLevel Page Replacement Policies In Proceedingsof the USENIX Mach Symposium pages  Burlington VT October Mogul et al  Mogul J Rashid R and Accetta M ThePacket Filter An Ecient Mechanism for Userlevel Network Code In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles pages Austin TX November Mossenbock  Mossenbock H Extensibility in the OberonSystem Nordic Journal of Computing  February Mullender et al  Mullender S J Rossum G V Tanenbaum A S Renesse R V and van Staveren H Amoeba A Distributed Operating System for the s IEEEComputer pages  May Nelson  Nelson G editor System Programming in Modula Prentice Hall Organick  Organick E editor Computer System Organizatrion The BB Series Academic Press Pardyak  Bershad  Pardyak P and Bershad B A GroupStructuring Mechanism for a Distributed Object OrientedLanguage Objects In Proceedings of the Fourteenth International Conference on Distributed Computing Systemspages  Poznan Poland June Rashid et al  Rashid R Tevanian Jr A Young MGolub D Baron R Black D Bolosky W and ChewJ MachineIndependent Virtual Memory Management forPaged Uniprocessor and Multiprocessor Architectures InProceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOSII pages  Palo Alto CAApril Redell  Redell D Experience with Topaz Teledebugging InProceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging October Redell et al  Redell D D Dalal Y K Horsley T RLauer H C LynchW C McJones P R Murray H Gand Purcell S C Pilot An Operating System for a Personal Computer Communications of the ACM  February Romer et al  Romer T H Lee D and Bershad B N Dynamic Page Mapping Policies for Cache Conict Resolution on Standard Hardware In Proceedings of the FirstUSENIX Symposium on Operating Systems Design andImplementation OSDI pages  Monterey CANovember Romer et al  Romer T Ohlrich W Karlin A and Bershad B Reducing TLB and Memory Overhead Using Online Superpage Promotion In Proceedings of the TwentyThird International Symposium on Computer Architecturepages  Rozier et al  Rozier M AbrossimovV Armand F BouleI Giend M Guillemont M Herrmann F LeonardP Langlois S and Neuhauser W The Chorus Distributed Operating System Computing Systems  Schroeder  Burrows  Schroeder M D and Burrows MPerformance of Firey RPC ACM Transactions on Computer Systems  February Schulman et al  Schulman A Maxey D and Pietrek MUndocumented Windows AddisonWesley Small  Seltzer  Small C and Seltzer M VINO An Integrated Platform for Operating System and Database Research Technical Report TR Harvard UniversityStevenson  Julin  Stevenson J M and Julin D P MachUS Unix On Generic OS Object Servers In Proceedings ofthe  Winter USENIX Conference New Orleans LAJanuary Stodolsky et al  Stodolsky D Bershad B N and Chen BFast Interrupt Priority Management for Operating SystemKernels In Proceedings of the Second USENIX Workshopon Microkernels and Other Kernel Architectures pages San Diego CA September Stonebraker  Stonebraker M Operating System Supportfor Database Management Communications of the ACM July Thacker et al  Thacker C P Stewart L C and Satterthwaite Jr E H Firey a Multiprocessor WorkstationIEEE Transactions on Computers  AugustThekkath  Levy  Thekkath C A and Levy H M Limitsto LowLatency RPC ACM Transactions on ComputerSystems  May Thekkath  Levy  Thekkath C A and Levy H M Hardware and Software Support for Ecient Exception Handling In Proceedings of the Sixth International Conference on Architectural Support for Programming Languagesand Operating Systems ASPLOSVI pages  SanJose CA October von Eicken et al  von Eicken T Culler D E GoldsteinS C and Schauser K E Active Messages A Mechanism for Integrated Communication and Computation InProceedings of the Nineteenth International Symposium onComputer Architecture pages  Gold Coast Australia May Wahbe et al  Wahbe R Lucco S Anderson T E andGraham S L Ecient SoftwareBased Fault Isolation InProceedings of the Fourteenth ACM Symposium on Operating Systems Principles pages  Asheville NCDecember Waldspurger  Weihl  Waldspurger C A and Weihl W ELottery Scheduling Flexible ProportionalShare ResourceManagement In Proceedings of the First USENIX Symposium on Operating Systems Design and ImplementationOSDI pages  Monterey CA November Wheeler  Bershad  Wheeler B and Bershad B N Consistency Management for Virtually Indexed Caches In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and OperatingSystems ASPLOSV pages  Boston MA October Wulf et al  Wulf W A Levin R and Harbison S PHydraCmmp An Experimental Computer SystemMcGrawHill Young et al  Young M Tevanian A Rashid R GolubD Eppinger J Chew J Bolosky W Black D andBaron R The Duality of Memory and Communicationin the Implementation of a Multiprocessor Operating System In Proceedings of the Eleventh ACM Symposium onOperating Systems Principles pages  Austin TXNovember Yuhara et al  Yuhara M Bershad B N Maeda C andMoss J E B Ecient Packet Demultiplexing for Multiple Endpoints and Large Messages In Proceedings ofthe  Winter USENIX Conference pages  SanFrancisco CA January
