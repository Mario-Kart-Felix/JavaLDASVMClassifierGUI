Exploring Multiple Execution Paths for Malware AnalysisAndreas Moser, Christopher Kruegel, and Engin KirdaSecure Systems LabTechnical University Viennaandy,chris,ekseclab.tuwien.ac.atAbstractMalicious code or malware is defined as software thatfulfills the deliberately harmful intent of an attacker. Malware analysis is the process of determining the behaviorand purpose of a given malware sample such as a virus,worm, or Trojan horse. This process is a necessary stepto be able to develop effective detection techniques and removal tools. Currently, malware analysis is mostly a manual process that is tedious and timeintensive. To mitigate this problem, a number of analysis tools have beenproposed that automatically extract the behavior of an unknown program by executing it in a restricted environmentand recording the operating system calls that are invoked.The problem of dynamic analysis tools is that only a single program execution is observed. Unfortunately, however, it is possible that certain malicious actions are onlytriggered under specific circumstances e.g., on a particular day, when a certain file is present, or when a certaincommand is received. In this paper, we propose a systemthat allows us to explore multiple execution paths and identify malicious actions that are executed only when certainconditions are met. This enables us to automatically extract a more complete view of the program under analysisand identify under which circumstances suspicious actionsare carried out. Our experimental results demonstrate thatmany malware samples show different behavior dependingon input read from the environment. Thus, by exploringmultiple execution paths, we can obtain a more completepicture of their actions.1 IntroductionMalware is a generic term used to describe all kinds ofmalicious software e.g., viruses, worms, or Trojan horses.Malicious software not only poses a major threat to the security and privacy of computer users and their data, but isalso responsible for a significant amount of financial loss.Unfortunately, the problem of malicious code is likely tocontinue to grow in the future, as malware writing is quicklyturning into a profitable business 26. Malware authors often sell their creations to miscreants, who then use the malicious code to compromise large numbers of machines thatare linked together in socalled botnets. These botnets arethen abused as platforms to launch denialofservice attacksor as spam relays. An important indication of the significance of the problem is that even people without any particular interest in computers are aware of worms such asCodeRed or Sasser. This is because security incidents affect millions of users and regularly make the headlines ofmainstream news sources.The most important line of defense against maliciouscode are virus scanners. These scanners typically rely ona database of signatures that characterize known malwareinstances. Whenever an unknown malware sample is foundin the wild, it is usually necessary to update the signaturedatabase accordingly, so that this novel malware piece canbe detected by the scan engine. To this end, it is very important to be able to quickly analyze an unknown malwaresample and understand its behavior and effect on the system. In addition, the knowledge about the functionality ofmalware is important for its removal. That is, to be able toeffectively remove a piece of malware from an infected machine, it is usually not sufficient to delete the binary itself.Often, it is also necessary to remove the residues left behindby the malicious code such as undesirable registry entries,services, or processes and undo changes made to legitimatefiles. All these actions require a detailed understanding ofthe malicious code and its behavior.The traditional approach to analyze the behavior of anunknown program is to execute the binary in a restrictedenvironment and observe its actions. The restricted environment is often a debugger, used by a human analyst to manually step through the code in order to understand its functionality. Unfortunately, antivirus companies receive up toseveral hundred new malware samples each day. Clearly,the analysis of these malware samples cannot be performedcompletely manually.1In a first step towards an automated solution, a numberof dynamic malware testing systems were proposed. Thesesystems, such as CWSandbox 29, the Norman SandBox 25, TTAnalyze 2, or Cobra 28 automatically loadthe sample to be analyzed into a virtual machine environment and execute it. While the program is running, its interaction with the operating system is recorded. Typically, thisinvolves recording which system calls are invoked, togetherwith their parameters. The result of an automated analysisis a report that shows what operating system resources e.g.,files or Windows registry entries a program has created oraccessed. Some tools also allow the system to connect toa local network or even the Internet and monitor the network traffic. Usually, the generated reports provide humananalysts with an overview on the behavior of the sample andallow them to quickly decide whether a closer, manual analysis is required. Hence, these automated systems free theanalysts of the need to waste time on already known malware. Also, some tools are already deployed on the Internetand act as live analysis backends for honeypot installationssuch as Nepenthes 1. Unfortunately, current analysis systems also suffer from a significant drawback their analysisis based on a single execution trace only. That is, their reports only contain the interaction that was observed whenthe sample was run in a particular test environment at a certain point in time. Unfortunately, this approach has the potential to miss a significant fraction of the behavior that aprogram might exhibit under varying circumstances.Malware programs frequently contain checks that determine whether certain files or directories exist on a machineand only run parts of their code when they do. Others require that a connection to the Internet is established or thata specific mutex object does not exist. In case these conditions are not met, the malware may terminate immediately.This is similar to malicious code that checks for indicationsof a virtual machine environment, modifying its behaviorif such indications are present in order to make its analysisin a virtual environment more difficult. Other functionalitythat is not invoked on every run are malware routines thatare only executed at or until a certain date or time of day.For example, some variants of the Bagle worm included acheck that would deactivate the worm completely after acertain date. Another example is the Michelangelo virus,which remains dormant most of the time, delivering its payload only on March 6 which is Michelangelos birthday.Of course, functionality can also be triggered by other conditions, such as the name of the user or the IP address of thelocal network interface. Finally, some malware listens forcertain commands that must be sent over a control channelbefore an activity is started. For example, bots that automatically log into IRC servers often monitor the channel for alist of keywords that trigger certain payload routines.When the behavior of a program is determined from asingle run, it is possible that many of the previously mentioned actions cannot be observed. This might lead a humananalyst to draw incorrect conclusions about the risk of a certain sample. Even worse, when the code fails at an earlycheck and immediately exits, the generated report mightnot show any malicious activity at all. One possibility toaddress this problem is to attempt to increase test coverage.This could be done by running the executable in differentenvironments, maybe using a variety of operating systemversions, installed applications, and datatime settings. Unfortunately, even with the help of virtual machines, creatingand maintaining such a testing system can be costly. Also,performing hundreds of tests with each sample is not veryefficient, especially because many environmental changeshave no influence on the program execution. Moreover, incases where malicious code is expecting certain commandsas input or checking for the existence of nonstandard filese.g., files that a previous exploit might have created, it isvirtually impossible to trigger certain actions.In this paper, we propose a solution that addresses theproblem of test coverage and that allows automated malware analysis systems to generate more comprehensive reports. The basic idea is that we explore multiple executionpaths of a program under test, but the exploration of different paths is driven by monitoring how the code uses certaininputs. More precisely, we dynamically track certain inputvalues that the program reads such as the current time fromthe operating system, the content of a file, or the result ofa check for Internet connectivity and identify points in theexecution where this input is used to make control flow decisions. When such a decision point is identified, we firstcreate a snapshot of the current state of the program execution. Then, the program is allowed to continue along one ofthe execution branches, depending on the actual input value.Later, we return to the snapshot and rewrite the input valuesuch that the other branch is taken. This allows us to exploreboth program branches. In addition, we can determine under which conditions certain code paths are executed.For a simple example, consider a program that checks forthe presence of a file. During execution, we track the resultof the operating system call that checks for the existenceof that file. When this result is later used in a conditionalbranch by the program, we store a snapshot of the currentexecution state. Suppose, for example, that the file doesnot exist, and the program quickly exits. At this point, werewind the process to the previously stored state and rewritethe result such that it does reports the files existence. Then,we can explore the actions that the program performs underthe condition that the file is there.We have developed a system for Microsoft Windows thatallows us to dynamically execute programs and track the input that they read. Also, we have implemented a mechanism2to take snapshots of executing processes and later revert topreviously stored states. This provides us with the means toexplore the execution space of malware programs and to observe behavior that is not seen by traditional malware analysis environments. To demonstrate the feasibility of our approach, we analyzed a large number of realworld malwaresamples. In our experiments, we were able to identify timechecks that guarded damage routines and different behaviordepending on existence of certain files. Also, we were ableto automatically extract a number of command strings for abot with their corresponding actions.To summarize, the contributions of this paper are as follows We propose a dynamic analysis technique that allowsus to create comprehensive reports on the behavior ofmalicious code. To this end, our system explores multiple program paths, driven by the input that the program processes. Also, our system reports the set ofconditions on the input under which particular actionsare triggered. We developed a tool that analyzes Microsoft Windowsprograms by executing them in a virtualmachinebased environment. Our system keeps track of userinput and can create snapshots of the current processat control flow decision points. In addition, we can reset a running process to a previously stored state andconsistently modify its memory such that the alternative execution path is explored. We evaluated our system on a large number of realworld malware samples and demonstrate that we wereable to identify behavior that cannot be observed insingle execution traces.2 System OverviewThe techniques described in this paper are an extensionto an existing system for automated malware analysis 2.This tool is based on Qemu 3, a fast virtual machine emulator. Using Qemus emulation of an Intel x86 host system, a Windows 2000 guest operating system is installed.The choice of Windows and the Intel x86 architecture wasmotivated by the fact that the predominant fraction of malware is developed for this platform. The analysis works byloading the malwareprogram into the emulated Windowsenvironment, starting its execution, and subsequently monitoring its activity. To this end, the analysis tool analyzes alloperating system calls that are invoked by the binary. Foreach system call, the analysis tool records the type of service requested and the corresponding arguments. Based onthe system calls observed during execution, a report is generated that summarizes the securityrelevant actions. Theseactions currently include the creation and modification offiles and Windows registry entries, interprocess communication, and basic network interaction.The existing analysis tool implements some virtual machine introspection capabilities in particular, it is able toattribute each instruction that is executed by the emulatedprocessor to an operating system process or the kernel ofthe guest system. This allows us to track only those system calls that are invoked by the code under analysis. Also,the system provides a mechanism to copy the content ofcomplex data structures, which can contain pointers to otherobjects in the process virtual address space, from the Windows guest system into the host system. This is convenientin order to be able to copy the system call arguments fromthe emulated system into the analysis environment. Unfortunately, the existing system only collected a single execution trace.Multiple execution paths. To address the problem that asingle execution trace typically produces only part of thecomplete program behavior, we extended the analysis toolwith the capability to explore multiple execution paths. Thegoal is to obtain a number of different execution paths, andeach path possibly reveals some specific behavior that cannot be observed in the other traces. The selection of branching points  that is, points in the program execution whereboth alternative continuations are of interest  is based onthe way the program processes input data. More precisely,when a control flow decision is based on some input valuethat was previously read via a system call, the program takesone branch which depends on the outcome of the concretecheck. At this point, we ask ourselves the following question Which behavior could be observed if the input wassuch that the other branch was takenTo answer this question, we label certain inputs of interest to the program and dynamically track their propagationduring execution. Similar to the propagation of taint information used by other authors in previous work 12, 23, oursystem monitors the way these input values are moved andmanipulated by the process. Whenever we detect a controlflow decision based on a labeled value, the current contentof the process address space is stored. Then, execution continues normally. When the process later wishes to terminate, it is automatically reset to the previously stored snapshot. This is done by replacing the current content of theprocess address space with the previously stored values. Inaddition, we rewrite the input value that was used in thecontrol flow decision such that the outcome of this decision is reversed. Then, the process continues its executionalong the other branch. Of course, it is possible that multiple branching in a row are encountered. In this case, theexecution space is explored by selecting continuation pointsin a depthfirst order.30  i n t x 1  x  r e a d  i n p u t   2  i f  x  0 3  i f  x  2 4  p r i n t f   o k   5  e x i t  0  x  0x  2x  2x  2x  2e x i tx  1x  0e x i tp r i n te x i tFigure 1. Exploration of multiple executionpaths.For an example on how multiple execution paths of aprogram can be explored, consider Figure 1. Note that although this example is shown in C code to make it easier to follow, our system works directly on x86 binaries.When the program is executed, it first receives some inputand stores it into variable x on Line 1. Note that becausex is considered interesting, it is labeled. Assume that in thisconcrete run, the value stored into x is 2. On Line 2, it iscompared to 0. At this point, our system detects a comparison operation that involves labeled data. Thus, a snapshot ofthe current process is created. Then, the process is allowedto continue. Because the condition is satisfied, the ifbranchis taken and we record the fact that x has to be larger than0. On Line 3, the next check fails. However, because thecomparison again involves labeled data, another snapshotis created. This time, the process continues on the elsebranch and is about to call exit. Because there are stillunexplored paths i.e., there exist two states that have notbeen visited, the process is reverted to the previous second state. Our system inspects the comparison at Line 3and attempts to rewrite x such that the check succeeds. Forthis, the additional constraint x  0 has to be observed.This yields a solution for x that equals 1. The value of xis updated to 1 and the process is restarted. This time, theprint statement on Line 4 is invoked. When the process isabout to exit on Line 5, it is reset to the first snapshot. Thistime, the system searches a value for x that fails the checkon Line 2. Because there are no additional constraints forx, an arbitrary, nonpositive integer is selected and the process continues along the elsebranch. This time, the call toexit is permitted, and the analysis process terminates witha report that indicates that a call to print was found underthe condition that the input x was 1 but not 0 or 2.Consistent memory updates. Unfortunately, whenrewriting a certain input value to explore an alternative execution path, it is typically not sufficient to change the singlememory location that is used by the control flow decision.Instead, it is necessary to consistently update or rewriteall values in the process address space that are related tothe input. The reason is that the original input value mighthave been copied to other memory locations, and evenused by the program as part of some previous calculations.When only a single instance of the input is modified, itis possible that copies of the original value remain in theprograms data section. This can lead to the execution ofinvalid operations or the exploration of impossible paths.Thus, whenever an input value is rewritten, it is necessaryto keep the program state consistent and appropriatelyupdate all copies of the input, as well as results of previousoperations that involve this value. Also, we might not havecomplete freedom when choosing an alternative value fora certain input. For example, an input might have beenused in previous comparison operations and the resultingconstraints need to be observed when selecting a value thatcan revert the control flow decision at a branching point. Itis even possible that no valid alternative value exists thatcan lead to the exploration of the alternative path. Thus,to be able to consistently update and input and its relatedvalues, it is necessary to keep track of which memorylocations depend on a certain input and how they dependon this value.3 Path ExplorationTo be able to explore multiple program paths, two maincomponents are required. First, we need a mechanism to decide when our system should analyze both program paths.To this end, we track how the program uses data from certain input sources. Second, when an interesting branchingpoint is located, we require a mechanism to save the current program state and reload it later to explore the alternative path. The following two subsections discuss these twocomponents in more detail.3.1 Tracking InputIn traditional taintbased systems, it is sufficient to knowthat a certain memory location depends on one or more input values. To obtain this information, such systems typically rely on three components a set of taint sources, ashadow memory, and extensions to the machine instructionsthat propagate the taint information.Taint sources are used to initially assign labels to certainmemory locations of interest. For example, Vigilante 11is a taintbased system that can detect computer worms thatpropagate over the network. In this system, the network isconsidered a taint source. As a result, each new input bytethat is read from the network card by the operating system4receives a new label. The shadow memory is required tokeep track of which labels are assigned to which memorylocations at a certain point in time. Usually, a shadow byteis used for each byte of physical machine memory. Thisshadow byte stores the labels currently attached to thephysical memory location. Finally, extensions to the machine instructions are required to propagate taint information when an operation manipulates or moves labeled data.The most common propagation policy ensures that the result of an operation receives the union of the labels of theoperations arguments. For example, consider an add machine instruction that adds the constant value 10 to a memory location M1 and stores the result at location M2. In thiscase, the system would use the shadow memory to look upthe label attached to M1 and attach this label to M2. Thus,after the operation, both locations M1 and M2 share thesame label although their content is different.In principle, we rely on a taintbased system as previously described to track how the program under analysisprocesses input values. That is, we have a number of taintsources that assign labels to input that is read by the program, and we use a shadow memory to keep track of thecurrent label assigned to each memory location includingthe processor registers. Taint sources in our system aremostly system calls that return information that we consider relevant for the behavior of malicious code. This includes system calls that access the file system e.g., checkfor existence of file, read file content, the Windows registry,and the network. Also, system calls that return the currenttime or the status of the network connection are interesting.Whenever a relevant function or system call is invoked byour program, our system automatically assigns a new labelto each memory location that receives this functions result.Sometimes, this means that a single integer is labeled. Inother cases, for example, when the program reads from afile or the network, the complete return buffer is labeled,using one unique label per byte.Inverse mapping. In addition to the shadow memory,which maps memory locations to labels, we also requirean inverse mapping. The inverse mapping stores, for eachlabel, the addresses of all memory locations that currentlyhold this label. This information is needed when a processis reset to a previously stored state and a certain input variable must be rewritten. The reason is that when a memorylocation with a certain label is modified, it is necessary to simultaneously change all other locations that have the samelabel. Otherwise, the state of the process becomes inconsistent. For example, consider the case in which the valueof labeled input x is copied several times before it is eventually stored at memory location y. Furthermore, assumethat y is used as argument by a conditional branch. To explore the alternate execution branch, the content of y mustbe changed. However, via a chain of intermediate locations,this value ultimately depends on x. Thus, all intermediatelocations need to be modified appropriately. To this end,a mapping is required that helps us to quickly identify alllocations that currently share the same label.0  . . .1  x  r e a d  i n p u t   2  c h e c k  x  3  p r i n t f    d  , x  4  . . . .5 6  v o i d c h e c k  i n t m a g i c  7  i f  m a g i c   0 x 1 5 0 8 8  e x i t  1  9  Figure 2. Consistent memory updates.To underline the importance of a consistent memory update, consider the example in Figure 2. Assume that thefunction read input on Line 1 is a taint source. Thus,when the program executes this function, variable x is labeled. In our example, the program initially reads the value0. When the check routine is invoked, the value of variable x is copied into the parameter magic. As part of this assignment, the variable magic receives the label of x. Whenmagic is later used in the check on Line 7, a snapshot of thecurrent state is taken because the outcome of a conditionalbranch depends on a labeled value. Execution continuesbut quickly terminates on Line 8. At this point, the process is reverted to the previously stored snapshot and oursystem determines that the value of magic has to be rewritten to 0x1508 to take the ifbranch. At this point, the newvalue has to be propagated to all other locations that sharethe same label in our case, the variable x. Otherwise, theprogram would incorrectly print the value of 0 instead of0x1508 on Line 3.Linear dependencies. In the previous discussion, the initial input value was copied to new memory locations beforebeing used as an argument in a control flow decision. In thatcase, rewriting this argument implied that all locations thatshare the same label had to be updated with the same value.So far, however, we have not considered the case when theinitial input is not simply copied, but used as operand incalculations. Using the straightforward taint propagationmechanism outlined above, the result of an operation witha labeled argument receives this arguments label. This alsohappens when the result of an operation has a different valuethan the argument. Unfortunately, that leads to problems5when rewriting a variable at a snapshot point. In particular, when different memory locations share the same labelbut hold different values, one cannot simply overwrite thesememory locations with a single, new value.We solve this problem by assigning a new label to the result of any operation different than copying that involveslabeled arguments. In addition, we have to record how thevalue with the new label depends on the values with theold labels. This is achieved by creating a new constraintthat captures the relationship between the old and new labels, depending on the semantics of the operation. Theconstraint is then added to a constraint system that is maintained as part of the execution state of the process. Considerthe simple example where a value with label l0 is used byan add operation that increases this value by the constant10. In this case, the result of the operation receives a newlabel l1. In addition, we record the fact that the result ofthe operation with l1 is equal to the value labeled by l0 plus10. That is, the constraint l1  l0  10 is inserted into theconstraint system. The approach works similarly when twolabeled inputs, one with label l 0 and the other with label l1are summed up. In this case, the result receives a new labell 2 and we add the constraint l2  l0  l1.In our current system, we can only model linear relationships between input variables. That is, our constraintsystem is a linear constraint system that can store terms inthe form of cn  ln  cn1  ln1  . . .  c1  l1  c0where the ci are constants. These terms can be connected byequality or inequality operators. To track linear dependencies between labels, the taint propagation mechanism of themachine instructions responsible for addition, subtraction,and multiplication had to be extended.Using the information provided by the linear constraintsystem, it is possible to correctly update all memory locations that depend on an input value x via linear relationships. Consider the case where a conditional control flowdecision uses a value with label ln. To explore the alternative branch of this decision, we have to rewrite the labeledvalue such that the outcome of the condition is reverted. Todo this consistently, we first use the linear constraint systemto identify all labels that are related to ln. This provides uswith the information which memory locations have someconnection with ln, and thus, must be updated as well. In asecond step, a linear constraint solver is used to determineconcrete values for these memory locations.Two labels ls and lt are related either a when they appear together in the same constraint or b when there exists a sequence of labels li0 , . . . , lin such that ls  li0 ,lt  lin , and li, li1 n1i0 appear in the same constraint.More formally, the binary relation related is the transitiveclosure of the binary relation appears in the same constraint. Thus, when a value with label ln should be rewritten, we first determine all labels that are related to ln inthe constraint system. Then, we extract all constraints thatcontain at least one of the labels related to ln. This set ofconstraints is then solved, using a linear constraint solverwe use the Parma Polyhedral Library.When the constraint system has no solution, the labeledvalue cannot be changed such that the outcome of the condition is reverted. In this case, our system cannot explorethe alternative path, and it continues with the next snapshotstored. When a solution is found, on the other hand, thissolution can be directly used to consistently update the process state. To this end, we can directly use, for each label,the value that the solver has determined to update the corresponding memory locations. This works because all lineardependencies between values are encoded by the respectiveconstraints in the constraint system. That is, a solution ofthe constraint system respects the relationships that haveto hold between memory locations. All memory locationsthat share the same label receive the same value. However,as expected, when memory locations have different labels,they can also receive different values. These values respectthe relationships introduced by the operation previously executed by the process and captured by the correspondingconstraints in the constraint system.To illustrate the concept of linear dependencies betweenvalues and to show how their dependencies are capturedby the constraint system, consider Figure 3. The exampleshows the labels and constraints that are introduced when asimple atoi function is executed. The goal of this functionis to convert a string into the integer value that this stringrepresents. For this example, we assume that the function isexecuted on a string str with three characters the first twoare the ASCII character equivalent of the number 0 whichis 30. The third one has the value 0 and terminates thestring. We assume that interesting input was read into thestring as a result, the first character str0 has label l0 andstr1 has label l1.The figure shows the initial mapping between programvariables and labels. For this initial state, no constraintshave been identified yet. After the first loop iteration, it canbe seen that the variables c and sum are also labeled. Thisresults from the operations on Line 7 and Line 8, respectively. The relationship between the variables are capturedby the two constraints. Because sum was 0 before this loopiteration, variables sum and c hold the same value. This isexpressed by the constraint l 3  l2. Note that this example is slightly simplified. The reason is that the checks performed by the whilestatement on Line 5 lead to the creationof additional constraints that ensure that the values of str0and str1 are between 30 ASCII value for 0 and 39ASCII value for character 9. Also, because the checksoperate on labeled data, the system creates snapshots foreach check and attempts to explore additional paths later.For these alternative paths, the string elements are rewrit60  c h a r s t r   ,  p 1  i n t s u m 2 3  p  s t r 4  s u m  0 5  w h i l e   p    0     p    9   6  s u m  s u m  1 0 7  i n t c   p   0  8  s u m  s u m  c 9  p   1 0  1 1 1 2  i f  s u m   8 2 1 3  p r i n t f   o k   M a p p i n g s t r  0      l0s t r  1      l1C ons t ra i nt sM a p p i n g s t r  0      l0s t r  1      l1c     l 2s u m     l 3C ons t ra i nt sl 2  l030l 3  l 2M a p p i n g s t r  0      l0s t r  1      l1c     l 5s u m     l 6C ons t ra i nt sl 2  l030l 3  l 2l 4  1 0  l 3l 5 l130l 6 l 4  l 5I n i t i a l s t a t eSt a t e a f t e r f i r s t l o o p i t e r a t i o nSt a t e a f t e rs e c o n dl o o p i t e r a t i o nCo d e f r a g m e n tFigure 3. Constraints generated during program execution.ten to be characters that do not represent numbers. In thesecases, the whileloop would terminate immediately.In the example, the program reaches the check onLine 11 after the second loop iteration. Given the original input for str, sum is 0 at this point and the elsebranchis taken. However, because this conditional branch involvesthe value sum that is labeled with l6, a snapshot of the current program state is created. When this snapshot is laterrestored, our system needs to rewrite sum with the value 82be able to take the ifbranch. To determine how the program state can be updated consistently, the constraint system is solved for l 6  82. A solution to this system canbe found l0  38, l1  32, l2  l3  8, l4  80, andl5  2. Using the mappings, this solution determines howthe related memory locations can be consistently modified.As expected, str0 and str1 are set to the characters 8and 2, respectively. The variable c is also set to 2.Nonlinear dependencies. The atoi function discussedpreviously represents a more complex example of what canbe captured with linear relationships. However, it is alsopossible that a program performs operations that cannot berepresented as linear constraints. These operations involve,for example, bitwise operators such as and, or or a lookupin which the input value is used as an index into a table. Incase of a nonlinear relationship, our current system cannotinfer the assignment of appropriate values to labels such thata certain memory location can be rewritten as desired. Thus,whenever an operation creates a nonlinear dependency between labels l i and lj , we no longer can consistently updatethe state when any label related to l i or lj should be rewritten. To address this problem, we maintain a set N that keepstrack of all labels that are part of nonlinear dependencies.Whenever a label should be rewritten, all related labels aredetermined. In case any of these labels is in N , the statecannot be consistently changed and the alternative path cannot be explored.3.2 Saving and Restoring Program StateThe previous section explained our techniques to trackthe propagation of input values during program execution.Every memory location that depends on some interestinginput has an attached label, and the constraint system determines how values with different labels are related to eachother. Based on this information, multiple paths in the execution space can be explored. To this end, our system monitors the program execution for conditional operations thatuse one or two labeled arguments. When such a branchinstruction is identified, a snapshot of the current processstate is created.The snapshot of the current execution state contains thecontent of the complete virtual address space that is in use.In addition, we have to store the current mappings and theconstraint system. But before the process is allowed to continue, one additional step is needed. In this step, we haveto ensure that the conditional operation itself is taken intoaccount. The reason is that no matter which branch is actually taken, this conditional operation enforces a constrainton the possible value range of the labeled argument. We7call this constraint a path constraint. The path constrainthas to be remembered and taken into account in case the labeled value is later rewritten further down the executionpath. Otherwise, we might create inconsistent states orreach impossible paths. When the ifbranch of the conditional is taken that is, it evaluates to true for the currentlabeled value, the condition is directly used as path constraint. Otherwise, when the elsebranch is followed, thecondition has to be reversed before it is added to the constraint system. To this end, we simply take the conditionsnegation.For example, recall the first program that we showedin Figure 1. This program uses two checks to ensure thatx  0 and x  2 before the print function is invoked.When the first ifstatement is reached on Line 2, a snapshot of the state is created. Because x had an initial valueof 2, the process continues along the ifbranch. However,we have to record the fact that the ifbranch can only betaken when the labeled value is larger than 0. Assume thatthe label of x is l0. Hence, the appropriate path constraintl0  0 is added to the constraint system. At the next checkon Line 3, another snapshot is created. This time, the elsebranch is taken, and we add the path constraint l0  2to the constraint system which, because of the elsebranch,is the negation of the conditional check x  2. When theprocess is about to terminate on Line 5, it is reset to the previously stored state. This time, the ifbranch on Line 3 mustbe taken. To this end, we add the path constraint l 0  2 tothe constraint system. At this point, the constraint systemcontains two entries. One is the constraint just added i.e.,l 0  2. The other one stems from the first check and requires that l0  0. When these constraints are analyzed, oursolver determines that l0  1. As a result, x is rewritten to1 and the program continues with the call to print.When a program state is restored, the first task of oursystem is to load the previously saved content of the programs address space and overwrite the current values withthe stored ones. Then, the saved constraint system is loaded.Similar to the case in which the first branch was taken, it isalso necessary to add the appropriate path constraint whenfollowing the alternative branch. To this end, the path constraint that was originally used is reversed that is, we takeits negation. This new path constraint is added to the constraint system and the constraint solver is launched. Whena solution is found, we use the new values for all relatedlabels to rewrite the corresponding memory locations in aconsistent fashion. As mentioned previously, when no solution is found, the alternative branch cannot be explored.Note that at any point during the programs execution,the solution space of the constraint system specifies all possible values that the labeled input can have in order to reachthis point in the program execution. This information is important to determine the conditions under which certain behavior is exhibited. For example, consider that our analysisobserves an operating system call that should be includedinto the report of suspicious behavior. In this case, we canuse the solutions to the constraint system to determine allvalues that the labeled input can take to reach this call. Thisis helpful to understand the conditions under which certainmalicious behavior is triggered. For example, consider aworm that deactivates itself after a certain date. Using ouranalysis, we can find the program path that exhibits the malicious behavior. We can then check the constraint systemto determine under which circumstances this path is taken.This yields the information that the current time has to bebefore a certain date.4 System ImplementationWe implemented the concepts introduced in the previoussection to explore the execution space of Windows binaries.More precisely, we extended our previous malware analysis tool 2 with the capability to automatically label inputsources of interest and track their propagation using standard taint analysis as, for example, realized in 12, 23. Inaddition, we implemented the mechanisms to consistentlysave and restore program states. This allows us to automatically generate more complete reports of malicious behaviorthan our original tool. The reports also contain the information under which circumstances a particular behavior isobserved. In this section, we describe and share implementation details that we consider interesting for the reader.4.1 Creating and Restoring ProgramSnapshotsOur system and the original analysis tool is built on topof the system emulator Qemu 3. Thus, the easiest way tosave the execution state of a program would be to save thestate of the complete virtual machine Qemu already supports this functionality. Unfortunately, when a sample isanalyzed, many snapshots have to be created. Saving theimage of the complete virtual machine costs too much timeand resources. Thus, we require a mechanism to take snapshots of the process image only. To this end, we developeda Qemu component that can identify the active memorypages of a process that is executing in the guest operatingsystem in our case, Microsoft Windows. This is done byanalyzing the page table directory that belongs to the Windows process. Because Qemu is a PC emulator, we have fullaccess to the emulated machines physical memory. Hence,we can access the Windows kernel data structures and perform the same calculations as the Windows memory management code to determine the physical page that belongsto a certain virtual address of the process under analysis.Once we have identified all pages that are memory mapped8for our process, we simply copy the content of those thatare flagged valid. In addition, when creating a snapshot ofa process, we have to make a copy of the virtual CPU registers, the shadow memory, and the constraint system.The method described above has one limitation. We cannot store or reset memory that is paged out on disk. Thislimitation stems from the fact that although we can accessthe complete main memory from outside, we cannot readthe content on the virtual hard disk without understanding how the Windows file system and swapping is implemented. Thus, we have to disable swapping and preventthe guest OS from moving memory pages to the disk wherethey can no longer be accessed. In our experiments, wefound that this limitation is not a problem as our malwaresamples had very modest memory demands and never exceeded the 256 MB main memory of the guest OS.To reset a process such that it continues from a previously saved snapshot, we use a procedure that is similarto the one for storing the execution state. First, we identify all mapped pages that belong to our process of interest.Then, for each page that was previously saved, we overwritethe current content with the one that was stored. When thepages are restored, we also reset the virtual CPU to its savedstate. Note that it is possible that the process has allocatedmore pages than were present at the time when the snapshotwas taken. This is the case when the program has requestedadditional memory from the operating system. Of course,these new pages cannot be restored. Fortunately, this is noproblem and does not alter the behavior of the process. Thereason is that all references in the original pages that nowpoint to the new memory areas are reverted back to the values that they had at the time of the snapshot when the newpages did not exist yet. The only problem is that the newlyallocated pages are lost for the process, but still consideredin use by the operating system. This memory leak mightbecome an issue when, for example, a memory allocatingroutine is executed various times when different executionpaths are explored. Although we never experienced problems in our experiments, one possible solution would be toinject code into the guest OS that releases the memory.An important observation is that a process can only bereset to a previously stored state when it is executing in usermode. When a process is executing kernel code, revertingit back to a user mode state can leave data structures usedby the Windows kernel in an inconsistent state. The sameis true when the operating system is executing an interrupthandling routine. Typically, resetting the process when notin user mode leads to a crash or freezes the system.Our current implementation allows us to reliably resetprocesses to previous execution states. However, one hasto consider the kernel state when snapshots are taken or restored. In particular, we have to address the problem that aresource might be returned to the operating system after asnapshot has been taken. When we later revert to the previously stored snapshot, the resource is already gone, andany handles to it are stale. For example, such a situationcan occur when a file is closed after a snapshot is made. Toaddress this problem, we never allow a process to close orfree any resource that it obtains from the operating system.To this end, whenever an application calls the NtClosefunction or attempts to return allocated memory to the OS,we intercept the function and immediately return to the userprogram. From the point of view of the operating system,no handle is ever closed. Thus, when the process is reset toan old state, the old handles are still valid.4.2 Identification of Program TerminationThe goal of our approach is to obtain a comprehensivelog of the activities of a program on as many different execution paths as possible. Thus, before reverting to a previously stored state, the process is typically allowed to rununtil it exits normally or crashes. Of course, our system cannot allow the process to actually terminate. Otherwise, theguest operating system removes the processrelated entriesfrom its internal data structures e.g., scheduler queue andfrees its memory. In this case, we would lose the possibilityto revert the image to a snapshot we have taken earlier.To prevent the program from exiting normally, we intercept all calls to the NtTerminateProcess systemservice function provided by the ntdll.dll library.This is done by checking whether the program counterof the emulated CPU is equal to the start address of theNtTerminateProcess function. Whenever the inspected process calls this function, we assume that it wishesto terminate. In this case, we can revert the program to aprevious snapshot in case unexplored paths are left.Segmentation faults i.e., illegal memory accesses areanother venue for program termination that we intercept.To this end, we hook the page fault handler and examinethe state of the emulated CPU whenever a page fault occurs. If an invalid memory access is detected, the process isreverted to a stored snapshot. Interestingly, invalid memoryaccesses occur relatively frequently. The reason is that during path exploration, we often encounter checks that ensurethat a pointer is not null. In order to explore the alternativepath, the pointer is set to an arbitrary nonnull value. Whenthis value is later dereferenced, it very likely refers to anunmapped memory area, which results in an illegal access.Often, we encounter the situation that malicious codedoes not terminate at all. For example, spreading routinesare typically implemented as endless loops that do not stopscanning for vulnerable targets. In such cases, we cannotsimply end the analysis, because we would fail to analyzeother, potentially interesting paths. To overcome this problem, we set a timeout for each path that our system explores9currently, 20 seconds. Whenever a path is still executedwhen the timeout expires, our system waits until the process is in a safe state and then reverts it to a previous snapshot until there are no more unexplored paths left. As aresult, it is also not possible for an attacker to thwart ouranalysis by deliberating inserting code on unused executionpaths that end in an endless loop.4.3 OptimizationOne construct that frequently occurs in programs arestring comparisons. Usually, two strings are compared byperforming a sequence of pairwise equality checks betweencorresponding characters in the two strings. This can leadto problems when one of the strings or both are labeled.Note that each character comparison operates on labeled arguments and thus, is a branching point. As a result, whena labeled string of n characters is compared with anotherstring, we create n states. Each of the states si  0  i  nrepresents the case in which the first i characters of bothstrings match, while the two characters with the offset i  1differ. For practical purposes, we typically do not need thisdetailed resolution for string comparisons. The reason isthat most of the time, a program only distinguishes betweenthe two cases in which both strings are either equal or notequal. To address this problem, we implemented a heuristics that attempts to recognize string comparisons. This isimplemented by checking for situations in which the samecompare instruction is executed repeatedly, and the arguments of this compare have addresses that increase by oneon every iteration. When such a string comparison is encountered, we do not branch on every check. Instead, weexplore one path where the first characters are immediatelydifferent, and a second one in which the two strings match.This optimization avoids the significant increase of the overall number of states that would have to be processed otherwise often without yielding any additional information.4.4 LimitationsIn Section 4.1, we discussed our approach of never returning any allocated resource to the operating system. Thegoal was to avoid invalid handles that would result when aprocess first closes a handle and is then reset to a previoussnapshot in which this handle is still valid. Our approachworks well in most cases. However, one has to considersituations in which a process creates external effects, e.g.,when writing to a file or sending data over a network.There are few problems when a program writes to a file.The reason is that the file pointer is stored in user memory,and thus, it is automatically reset to the previous value whenthe process is restored. Also, as mentioned previously, filesare never closed. Unfortunately, the situation is not as easywhile handling network traffic. Consider an application thatopens a connection to a remote server and then exchangessome data e.g., such as a bot connecting to an IRC server.When reverting to a previous state, the synchronization between the application and the server is lost. In particular,when the program first sends out some data, is later reset,and then sends out this data again, the remote server receives the data twice. Typically, this breaks protocol logicand leads to the termination of the connection. In our current implementation, we solve this problem as follows Allnetwork system calls in which the program attempts to establish a connection or sends out data are intercepted andnot relayed to the operating system. That is, for these calls,our system simply returns a success code without actuallyopening a connection or sending packets. Whenever theprogram attempts to read from the network, we simply return a string of random characters of the maximum lengthrequested. The idea is that because the results of networkreads are labeled, our multiple path exploration techniquewill later determine those strings that trigger certain actionse.g., such as command strings sent to a bot.Another limitation is the lack of support for signals andmultithreaded applications. Currently, we do not recordsignals that are delivered to a process. Thus, when a signalis raised, this only happens once. When the process is laterreverted to a previous state, the signal is not resent. The lackof support for multithreaded applications is not a problemper se. Creating a snapshot for the complete process worksindependently of the number of threads. However, to ensuredeterministic behavior our system would have to ensure thatthreads are scheduled deterministically.It might also be possible for speciallycrafted malwareprograms to conceal some malicious behavior by preventing our system from exploring a certain path. To this end,the program has to ensure that a branch operation dependson a value that is related to other values via nonlinear dependencies. For example, malicious code could deliberatelyapply nonlinear operations such as xor to a certain value.When this value is later used in a conditional operation, oursystem would determine that it cannot be rewritten, as therelated memory locations cannot be updated consistently.Thus, the alternative branch would not be explored. Thereare two ways to address this threat. First, we could replacethe linear constraint solver by a system that can handle morecomplex relationships. For instance, by using a SAT solver,we could also track dependencies that involve bitwise operations. Unfortunately, when analyzing a binary that isspecifically designed to withstand our analysis, our prototype will never be able to correctly invert all operations encountered. An example for that are oneway hash functions,for which our system cannot infer the original data from thehash value alone. Therefore, a second approach could be torelax the consistent update requirement. That is, we allow10our system to explore paths by rewriting a memory location without being able to correctly modify all related input values. This approach leads to a higher coverage of thecode analyzed, but we lose the knowledge of the input thatis required to drive the execution down a certain path. Inaddition, the program could perform impossible operationsor simply crash because of its inconsistent state. However,frequent occurrences of conditional jumps that cannot be resolved by our system could be interpreted as malicious. Inthis case, we could raise an appropriate warning and have ahuman analyst perform a deeper investigation.Finally, speciallycrafted malware programs could perform a denialofservice attack against our analysis tool byperforming many conditional branches on tainted data. Thiswould force our system to create many states, which in turnleads to an exponential number of paths that have to be explored. One solution to this problem could be to definea distance metrics that can compare saved snapshots andmerge sufficiently similar paths. Furthermore, we couldalso treat a sudden, abnormal explosion of states as a signof malicious behavior.5 EvaluationIn this section, we discuss the results that we obtained byrunning our malware analysis tool on a set of 308 realworldmalicious code samples. These samples were collected inthe wild by an antivirus company and cover a wide rangeof malicious code classes such as viruses, worms, Trojanhorses and bots. Note that we performed our experimentson all the samples we received, without any preselection.The 308 samples in our test set belong to 92 distinct malware families in certain cases, several different versions ofa single family were included in the sample set. We classified these malware families using the free virus encyclopedia available at viruslist.com. Analyzing the results, we found that 42 malware families belong to the classof emailbased worms e.g., Netsky, Blaster. 30 familiesare classified as exploitbased worms e.g., Blaster, Sasser.10 malware families belong to the classic type of file infector viruses e.g., Elkern, Kriz. The remaining 10 families are classified as Trojan horses and backdoors, typicallycombined with bot functionality e.g., AceBot, AgoBot, orrBot. To understand how widespread our malware instances are, we checked Kasperskys top20 virus list forJuly 2006, the month that we received our test data. Wefound that our samples cover 18 entries on this list. Thus,we believe that we have assembled a comprehensive setof malicious code samples that cover a variety of malwareclasses that appear in the wild.In a first step, our aim was to understand to which extent malware uses interesting input to perform control flowdecisions. To this end, we had to define appropriate inputsources. In our current prototype implementation, we consider the functions listed in Table 1 to provide interestinginput. These functions were chosen primarily based on ourprevious experience with malware analysis and also basedon discussions with experienced malware analysts workingin an antivirus company. In the past, we have seen malicious code that uses the output provided by one of thesefunctions to trigger actions. Also, note that adding additional input sources, if required, is trivial and is not a limitation of our approach. During the analysis, we label thereturn values of functions that check for the existence of anoperating system resource. For functions that read from aresource i.e., file, network, or timer, we label the completebuffer that is returned by using one label for each byte.Interesting input sourcesCheck for Internet connectivity 20Check for mutex object 116Check for existence of files 79Check for existence of registry entry 74Read current time 134Read from file 106Read from network 134Table 1. Number of samples that accesstainted input sources.After running our analysis on the complete set of 308realworld malware samples, we observed that 229 of thesesamples used at least one of the tainted input sources we defined. The breakdown of the usage based on input is shownin Table 1. Of course, reading from a tainted source doesnot automatically imply that we can explore additional execution paths. For example, many samples copy their ownexecutable file into a particular directory e.g., the Windowssystem folder. In this case, our analysis observes that a fileis read, and appropriately taints the input. However, thetainted bytes are simply written to another file, but not usedfor any conditional control flow decisions. Thus, there areno alternative program paths to explore.Out of the 229 samples that access tainted sources, 172use some of the tainted bytes for control flow decisions. Inthis case, our analysis is able to explore additional pathsand extract behavior that would have remained undetectedwith a dynamic analysis only based on a single executiontrace. In general, exploring multiple paths results in a morecomplete picture of the behavior of that code. However, itis unreasonable to expect that our analysis can always extract important additional knowledge about program behavior. For example, several malware instances implement acheck that uses a mutex object to ensure that only a sin11gle program instance is running at the same time. That is,when the mutex is not found on the first execution path, themalware performs its normal malicious actions. When oursystem analyzes the alternative path i.e., we pretend thatthe mutex exists, the program immediately exits. In suchsituations, we are only able to increase our knowledge bythe fact that the presence of a specific mutex leads to immediate termination. Of course, there are many other casesin which the additional behavior is significant, and revealshidden functionality not present in a single trace.Table 2 shows the increase in coverage of the maliciouscode when we explore alternative branches. More precisely,this table shows the relative increase in the number of basicblocks that are analyzed by our system when considering alternative paths. The baseline for each sample is the numberof basic blocks covered when simply running the sample inour analysis environment. For a small number of the samples 21 of 172, the newly detected code regions amountto less than 10 of the baseline. While it is possible thatthese 10 contain information that is relevant for an analyst, they are mostly due to the exploration of error pathsthat quickly lead to program termination. For the remainingsamples 151 of 172, the increase in code coverage is above10, and often significantly larger. For example, the largestincrease in code coverage that we observed was 3413.58,when analyzing the Win32.Plexus.B worm. This wasbecause this sample only executes its payload if its file namecontains the string upu.exe. As this was not the case forthe sample uploaded into our analysis system, the malwarepayload was only run in an alternative path. Anecdotal evidence of the usefulness of our system is provided in the following paragraphs, where we describe interesting behaviorthat was revealed by alternative paths. However, examiningthe quantitative results alone, it is evident that almost onehalf of the malware samples in the wild contain significant,hidden functionality that is missed by a simple analysis.Relative increase Number of samples0   10  2110   50  7150   200  37 200  43Table 2. Relative increase of code coverage.Behavioral analysis results. One interesting class of malicious behavior that can be detected effectively by our system is code that is only executed on a certain date or in atime interval. As an example for this class, consider theBlaster code shown one the left side of Figure 4. Thiscode launches a denialofservice attack, but only after the15th of August. Suppose that Blaster is executed on the1st of January. In that case, a single execution trace wouldyield no indication of an attack. Using our system, however,a snapshot for the first check of the ifcondition is created.After resetting the process, the day is rewritten to be largerthan 15. Later, the system also passes the month check, updating the month variable to a value of 8 or larger. Hence,the multiple execution path exploration allows us to identifythe fact that Blaster launches a denialofservice attack,as well as the dates that it is launched.Another interesting case in which our analysis can provide a more complete behavioral picture is when malwarechecks for the existence of a file to determine whether it wasalready installed. For example, the Kriz virus first checksfor the existence of the file KRIZED.TT6 in the systemfolder. When this file is not present, the virus simply copiesitself into the system folder and terminates. Only when thefile is already present, malicious behavior can be observed.In such cases, an analysis system that performs a single execution run would only be able to monitor the installation.Finally, our system is wellsuited to identify actions thatare triggered by commands that are received over the network or read from a file. An important class of malwarethat can be controlled by remote commands are IRC Internet Relay Chat bots. When started, these programs usuallyconnect to an IRC server, join a channel, and listen to thechat traffic for keywords that trigger certain actions. Modern IRC bots can typically understand more than 100 commands, making a manual analysis slow and tedious. Usingour system, we can automate the process and determine, foreach command, which behavior is triggered. In contrast,when running a bot in existing analysis tools, it is likely thatno malicious actions will be seen, simply because the botnever receives any commands. The code on the right side ofFigure 4 shows a fragment of the command loop of the botrxBot. This code implements a series of ifstatements thatcheck a line received from the IRC server for the presenceof certain keywords. When this code is analyzed, the resultof the read from the network that is, the content of array ais labeled. Therefore, all calls to the strcmp function aretreated as branching points, and we can extract the actionsfor one command on each different path.Performance. The goal of our system is to provide a malware analyst with a detailed report on the behavior of anunknown sample. Thus, performance is not a primary requirement. Nevertheless, for some programs, a significantnumber of paths needs to be explored. Thus, the time andspace requirements for saving and restoring states cannot becompletely neglected.Whenever our system creates a snapshot, it saves thecomplete active memory content of the process. In addition, the state contains information from the shadow mem121  G e t D a t e F o r m a t  L O C A L E  4 0 9 , 0 , N U L L , d ,da y , s i z e o f da y   2  G e t D a t e F o r m a t  L O C A L E  4 0 9 , 0 , N U L L , M , m o n t h , s i z e o f  m o n t h   3 4  i f  a t o i da y   1 5   a t o i  m o n t h    8 5  r u n d do s  a t t a c k   B la s t e r D e n i al 0o f0 Se r v i c e A t t a c k0    r e c e i v eli n e f r o m n e t w o r k0 0 s t o r e i n a r r a y a  1    a  0   c o m m a nd, a  1   a r g 1 , a  2   a r g 2 , . . .2 3  i f  s t r c m p c r a s h, a  0     0  4  s t r c m p  a  5  ,c r a s h    y e s , t h i s w il lc r a s h .5  r e t u r n 1 6  7  els e i f  s t r c m p g e t cdk e y s, a  0     0  8  g e t cdk e y s  s o c k , a  2  , n o t i c e  9  r e t u r n 1 1 0  1 1  els e i f  s t r c m p  dr i v e i n f o, a  0     0  1 2  D r i v e I n f o  s o c k , a  2  , n o t i c e , a  1   1 3  r e t u r n 1 1 4  r xBo t C o m m a ndL o o pFigure 4. Blaster and rxBot source code snippets.ory and the constraint system. During our experiments, wedetermined that the size of a state was equal to about threetimes the amount of memory that a process has allocated.On average, the size of a state was about 3.5 MB, and itnever exceeded 10 MB. The time needed to create or restore a snapshot was 4 milliseconds on average, with a smallvariance on an Intel Pentium IV with 3.4 GHz and 2 GBRAM. As mentioned in Section 4.2, a timeout of 20 seconds was set for the exploration of each individual programpath. In addition, we set a timeout of 100 seconds for thecomplete analysis run of each sample. This tight, additionaltime limit was introduced to be able to handle a large number of samples in case certain malware instances would create many paths. In our experiments, we observed that 58of the malware programs finished before the timeout expired. The remaining 42 of the samples had unexploredpaths left when the analysis process was terminated. As aresult, by increasing the total timeout, we would expect toachieve an even larger increase in code coverage than thatreported in the previous paragraphs. The tradeoff is that itwould take longer until results are available.The size of a state could be significantly reduced if weexploited the fact that the majority of memory locationsand entries in the shadow memory are 0. Also, we couldattempt to create incremental snapshots that only store thedifference between the current and previous states. In theory, the number of concurrently active states can be as highas the number of branching points encountered. However,we observed that this is typically not the case, and the number of concurrently active states during the experiments waslower. More precisely, our system used on average 31 concurrent states the maximum was 469. Note that these numbers also represent the average and maximum depths of thesearch trees that we observed, as we use a depthfirst searchstrategy. The total number of states were on average 32,with a maximum of 1,210. Given the number of concurrently active states, we deemed it not necessary to developmore sophisticated algorithms to create program snapshots.Moreover, in a synthetic benchmark, we verified that oursystem can handle more than thousand active states.6 Related WorkMalicious code analysis. Analyzing malicious executables is not a new problem consequently, a number of solutions already exist. These solutions can be divided into twogroups static analysis and dynamic analysis techniques.Static analysis is the process of analyzing a programs codewithout actually executing it. This approach has the advantage that one can cover the entire code and thus, possiblycapture the complete program behavior, independent of anysingle path executed during runtime. In 8, a techniquewas introduced that uses model checking to identify parts ofa program that implement a previously specified, maliciouscode template. This technique was later extended in 9,allowing more general code templates and using advancedstatic analysis techniques. In 21, a system was presentedthat uses static analysis to identify malicious behavior inkernel modules that indicate a rootkit. Finally, in 20, abehavioralbased approach was presented that relies heavilyon static code analysis to detect Internet Explorer pluginsthat exhibit spywarelike behavior. The main weakness ofstatic analysis is that the code analyzed may not necessarilybe the code that is actually run. In particular, this is true forselfmodifying programs that use polymorphic or metamorphic techniques 27. Also, malware can draw from a wide13range of obfuscation mechanisms 22, 30 that may makestatic analysis very difficult.Because of the many ways in which code can be obfuscated and the fundamental limits in what can be decidedstatically, we firmly believe that dynamic analysis is a necessary complement to static detection techniques. In 4, abehaviorbased approach was presented that aims to dynamically detect evasive malware by injecting user input intothe system and monitoring the resulting actions. In addition, a number of approaches exist that directly analyze thecode dynamically. Unfortunately, the support for dynamiccode analysis is limited often, it only consists of debuggers or disassemblers that aid a human analyst. Tools suchas CWSandbox 29, the Norman SandBox 25, TTAnalyze 2, or Cobra 28 automatically record the actions performed by a code sample, but they only consider a singleexecution path and thus, might miss relevant behavior. Toaddress this limitation and to capture a more comprehensiveview of a programs behavior, we developed our approachto explore multiple execution paths.A very recent work that addresses the detection of hidden, timebased triggers in malware is described in 13.In their work, the authors attempt to automatically discovertimedependent behavior by setting the system time to different values. The problem is that timebased triggers canbe missed when the system time is not set to the exact timethat the malware expects. In our approach, we do not attempt to provide an environment such that trigger conditions are met, but explore multiple code paths independentof the environment. Thus, we have a better chance of finding hidden triggers. In addition, our approach is more comprehensive, as we can detect arbitrary triggers.Finally, in their technical report 5, the authors presenta system that is similar to ours in its goal to detect triggerbased malware behavior. The main differences are the system design, which is based on mixed execution of binarycode using elements of symbolic execution, and a less comprehensive evaluation on four malware samples.Software testing. The goal of our work is to obtain amore complete picture of the behavior of a malicious codesample, together with the conditions under which certainactions are performed. This is analogous to software testingwhere one attempts to find inputs that trigger bugs.A number of test input generation systems 6, 15, 16were presented that analyze a program and attempt to findinput that drives execution to a certain program point. Thedifference to our approach is that the emphasis of thesesystems is to reach a certain point, and not to explore thecomplete program behavior. Other tools were proposed thatexplore multiple paths of a program to detect implementation errors. For example, model checking tools 10, 17, 18translate programs into finite state machines and then reason whether certain properties hold on these automata. Thesystems that are closest to our work are DART 14 andEXE 7. Both systems use symbolic execution 19. Thatis, certain inputs are expressed as symbolic variables, andthe system explores in parallel both alternative executionpaths when a conditional operation is found that uses thissymbolic input. Similar to our approach, these systems canexplore multiple execution paths that depend on interesting input. Also, the conditions under which certain pathsare selected can be calculated and are subsequently usedto generate test cases. The main differences to our technique are the following. First, the goal of these systems isto explore programs for program bugs while our intent is tocreate comprehensive behavioral profiles of malicious code.Second, we do not have the possibility of using source codeand operate directly on hostile obfuscated binaries. Thisleads to a significantly different implementation in whichinteresting inputs are dynamically tracked by taint propagation. Also, the problem we are addressing is complicatedby the fact that we are not able to utilize builtin operatingsystem mechanisms e.g., fork to explore alternative program paths. Hence, we require an infrastructure to save andrestore snapshots of the program execution.Speculative execution. In 24, a system was presentedthat uses process snapshots to implement speculative execution. In distributed files systems, processes typically have towait until remote file system operations are completed before they can resume execution. With speculative execution,processes continue without waiting for remote responses,based on locally available data only. When it later turns outthat the remote operation returns data that is different fromthe local one, the process is reset to its previously storedsnapshot. The concept of snapshots used in speculative execution is similar to the one in our work. The difference isthat we use snapshots as a means to explore alternative execution paths, which requires consistent memory updates.7 ConclusionsIn this paper, we presented a system to explore multiple execution paths of Windows executables. The goal is toobtain a more comprehensive overview of the actions thatan unknown sample can perform. In addition, the tool automatically provides the information under which circumstances a malicious action is triggered.Our system works by tracking how a program processesinteresting input e.g., the local time, file checks, reads fromthe network. In particular, we dynamically check for conditional branch instructions whose outcome depend on certain input values. When such an instruction is encountered,a snapshot of the current execution state is created. Whenthe program later finishes along the first branch, we reset14it to the previously saved state and modify the argument ofthe condition such that the other branch is taken. Whenperforming this rewrite operation, it is important to consistently update all memory locations that are related to theargument value. This is necessary to prevent the programfrom executing invalid or impossible paths.Our experiments demonstrate that, for a significant fraction of malware samples in our evaluation set, the system isindeed exploring multiple paths. In these cases, our knowledge about a programs behavior is extended compared toa system that observes a single run. We also show for anumber of realworld malware samples that the actions thatwere discovered by our technique reveal important and relevant information about the behavior of the malicious code.AcknowledgmentsThis work was supported by the Austrian Science Foundation FWF under grant P18157, the FITIT projectPathfinder, and the Secure Business Austria competencecenter. We would like to thank our shepherd Andrew Myersand the anonymous referees for their valuable comments.References1 P. Baecher, M. Koetter, T. Holz, M. Dornseif, and F. Freiling. The Nepenthes Platform An Efficient Approach ToCollect Malware. In Recent Advances in Intrusion Detection RAID, 2006.2 U. Bayer, C. Kruegel, and E. Kirda. TTAnalyze A Tool forAnalyzing Malware. In 15th Annual Conference of the European Institute for Computer Antivirus Research EICAR,2006.3 F. Bellard. Qemu, a Fast and Portable Dynamic Translator.In Usenix Annual Technical Conference, 2005.4 K. Borders, X. Zhao, and A. Prakash. Siren Catching Evasive Malware Short Paper. In IEEE Symposium on Securityand Privacy, 2006.5 D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song,and H. Yin. Towards Automatically Identifying Triggerbased Behavior in Malware using Symbolic Executionand Binary Analysis. Technical Report CMUCS07105,Carnegie Mellon University, 2007.6 D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha.Towards automatic generation of vulnerabilitybased signatures. In IEEE Symposium on Security and Privacy, 2006.7 C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler.EXE Automatically Generating Inputs of Death. In Conference on Computer and Communication Security, 2006.8 M. Christodorescu and S. Jha. Static Analysis of Executables to Detect Malicious Patterns. In Usenix Security Symposium, 2003.9 M. Christodorescu, S. Jha, S. Seshia, D. Song, andR. Bryant. Semanticsaware Malware Detection. In IEEESymposium on Security and Privacy, 2005.10 J. Corbett, M. Dwyer, J. Hatcliff, S. Laubach, C. Pasareanu, Robby, and H. Zheng. Bandera Extracting FiniteStateModels from Java Source Code. In International Conferenceon Software Engineering ICSE, 2000.11 M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou,L. Zhang, and P. Barham. Vigilante EndtoEnd Containment of Internet Worms. In 20th ACM Symposium on Operating Systems Principles SOSP, 2005.12 J. Crandall and F. Chong. Minos Architectural support forsoftware security through control data integrity. In International Symposium on Microarchitecture, 2004.13 J. Crandall, G. Wassermann, D. Oliveira, Z. Su, F. Wu, andF. Chong. Temporal Search Detecting Hidden MalwareTimebombs with Virtual Machines. In Conference on Architectural Support for Programming Languages and OS, 2006.14 P. Godefroid, N. Klarlund, and K. Sen. DART Directed automated random testing. In Programming Language Designand Implementation PLDI, 2005.15 A. Gotlieb, B. Botella, and M. Rueher. Automatic test datageneration using constraint solving techniques. In ACMSymposium on Software Testing and Analysis, 1998.16 N. Gupta, A. Mathur, and M. Soffa. Automated test datageneration using an iterative relaxation method. In Symposium on Foundations of Software Engineering FSE, 1998.17 T. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. SoftwareVerification with Blast. In 10th SPIN Workshop, 2003.18 G. Holzmann. The model checker spin. Software Engineering, 235, 1997.19 J. King. Symbolic Execution and Program Testing. Communications of the ACM, 1976.20 E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. Kemmerer.Behaviorbased Spyware Detection. In Usenix Security Symposium, 2006.21 C. Kruegel, W. Robertson, and G. Vigna. Detecting KernelLevel Rootkits Through Binary Analysis. In Annual Computer Security Application Conference ACSAC, 2004.22 C. Linn and S. Debray. Obfuscation of Executable Code toImprove Resistance to Static Disassembly. In ACM Conference on Computer and Communications Security, 2003.23 J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. In 12th Annual Network andDistributed System Security Symposium NDSS, 2005.24 E. Nightingale, P. Chen, and J. Flinn. Speculative Executionin a Distributed File System. In 20th Symposium on Operating Systems Principles SOSP, 2005.25 Norman. Normal Sandbox. httpsandbox.norman.no, 2006.26 Symantec. Internet Security Threat Report VolumeX. httpwww.symantec.comenterprisethreatreportindex.jsp, 2006.27 P. Szor. The Art of Computer Virus Research and Defense.Addison Wesley, 2005.28 A. Vasudevan and R. Yerraballi. Cobra Finegrained Malware Analysis using Stealth LocalizedExecutions. In IEEESymposium on Security and Privacy, 2006.29 C. Willems. CWSandbox Automatic Behaviour Analysisof Malware. httpwww.cwsandbox.org, 2006.30 G. Wroblewski. General Method of Program Code Obfuscation. PhD thesis, Wroclaw University of Technology, 2002.15
