The UNIX TimeSharing SystemD. M. Ritchie and K. ThompsonABSTRACTUnix is a generalpurpose, multiuser, interactive operating system for the largerDigital Equipment Corporation PDP11 and the Interdata 832 computers. It offers anumber of features seldom found even in larger operating systems, includingi A hierarchical file system incorporating demountable volumes,ii Compatible file, device, and interprocess IO,iii The ability to initiate asynchronous processes,iv System command language selectable on a peruser basis,v Over 100 subsystems including a dozen languages,vi High degree of portability.This paper discusses the nature and implementation of the file system and of the user commandinterface.I. INTRODUCTIONThere have been four versions of the Unix timesharing system.12 The earliest circa 196970 ran on the Digital Equipment Corporation PDP7 and 9 computers. Thesecond version ran on the unprotected PDP1120 computer. The third incorporated multiprogramming andran on the PDP1134, 40, 45, 60, and 70 computers it is the one described in the previously publishedversion of this paper, and is also the most widely used today. This paper describes only the fourth, currentsystem that runs on the PDP1170 and the Interdata 832 computers. In fact, the differences among thevarious systems is rather small most of the revisions made to the originally published version of this paper,aside from those concerned with style, had to do with details of the implementation of the file system.Since PDP11 Unix became operational in February, 1971, over 600 installations have been put intoservice. Most of them are engaged in applications such as computer science education, the preparation andformatting of documents and other textual material, the collection and processing of trouble data from various switching machines within the Bell System, and recording and checking telephone service orders. Ourown installation is used mainly for research in operating systems, languages, computer networks, and othertopics in computer science, and also for document preparation.Perhaps the most important achievement of Unix is to demonstrate that a powerful operating systemfor interactive use need not be expensive either in equipment or in human effort it can run on hardwarecosting as little as 40,000, and less than two manyears were spent on the main system software. Wehope, however, that users find that the most important characteristics of the system are its simplicity, Copyright 1974, Association for Computing Machinery, Inc., reprinted by permission. This electronic edition of this paper is a reprint of the version appearing in The Bell System Technical Journal 57 no. 6, part 2 JulyAugust 1978. In turn,that was a revised version of an article that appeared in Communications of the ACM, 17, No. 7 July 1974, pp. 365375.That article was a revised version of a paper presented at the Fourth ACM Symposium on Operating Systems Principles,IBM Thomas J. Watson Research Center, Yorktown Heights, New York, October 1517, 1973. Most of the differencesbetween versions occur between the C. ACM version and the BSTJ printing we incorporated updated numbers and materialon portability. 2 elegance, and ease of use.Besides the operating system proper, some major programs available under Unix areC compilerText editor based on QED1Assembler, linking loader, symbolic debuggerPhototypesetting and equation setting programs2, 3Dozens of languages including Fortran 77, Basic, Snobol, APL, Algol 68, M6, TMG, PascalThere is a host of maintenance, utility, recreation and novelty programs, all written locally. The Unix usercommunity, which numbers in the thousands, has contributed many more programs and languages. It isworth noting that the system is totally selfsupporting. All Unix software is maintained on the system likewise, this paper and all other documents in this issue were generated and formatted by the Unix editor andtext formatting programs.II. HARDWARE AND SOFTWARE ENVIRONMENTThe PDP1170 on which the Research Unix system is installed is a 16bit word 8bit byte computer with 768K bytes of core memory the system kernel occupies 90K bytes about equally dividedbetween code and data tables. This system, however, includes a very large number of device drivers andenjoys a generous allotment of space for IO buffers and system tables a minimal system capable of running the software mentioned above can require as little as 96K bytes of core altogether. There are evenlarger installations see the description of the PWBUNIX systems 4, 5, for example. There are also muchsmaller, though somewhat restricted, versions of the system 6.Our own PDP11 has two 200Mb movinghead disks for file system storage and swapping. Thereare 20 variablespeed communications interfaces attached to 300 and 1200baud data sets, and an additional 12 communication lines hardwired to 9600baud terminals and satellite computers. There are alsoseveral 2400 and 4800baud synchronous communication interfaces used for machinetomachine filetransfer. Finally, there is a variety of miscellaneous devices including ninetrack magnetic tape, a lineprinter, a voice synthesizer, a phototypesetter, a digital switching network, and a chess machine.The preponderance of Unix software is written in the abovementioned C language 7. Early versionsof the operating system were written in assembly language, but during the summer of 1973, it was rewrittenin C. The size of the new system was about onethird greater than that of the old. Since the new system notonly became much easier to understand and to modify but also included many functional improvements,including multiprogramming and the ability to share reentrant code among several user programs, we consider this increase in size quite acceptable.III. THE FILE SYSTEMThe most important role of the system is to provide a file system. From the point of view of the user,there are three kinds of files ordinary disk files, directories, and special files.3.1 Ordinary filesA file contains whatever information the user places on it, for example, symbolic or binary objectprograms. No particular structuring is expected by the system. A file of text consists simply of a string ofcharacters, with lines demarcated by the newline character. Binary programs are sequences of words asthey will appear in core memory when the program starts executing. A few user programs manipulate fileswith more structure for example, the assembler generates, and the loader expects, an object file in a particular format. However, the structure of files is controlled by the programs that use them, not by the system.3.2 DirectoriesDirectories provide the mapping between the names of files and the files themselves, and thus inducea structure on the file system as a whole. Each user has a directory of his own files he may also create subdirectories to contain groups of files conveniently treated together. A directory behaves exactly like anordinary file except that it cannot be written on by unprivileged programs, so that the system controls the 3 contents of directories. However, anyone with appropriate permission may read a directory just like anyother file.The system maintains several directories for its own use. One of these is the root directory. All filesin the system can be found by tracing a path through a chain of directories until the desired file is reached.The starting point for such searches is often the root. Other system directories contain all the programsprovided for general use that is, all the commands. As will be seen, however, it is by no means necessarythat a program reside in one of these directories for it to be executed.Files are named by sequences of 14 or fewer characters. When the name of a file is specified to thesystem, it may be in the form of a path name, which is a sequence of directory names separated by slashes,, and ending in a file name. If the sequence begins with a slash, the search begins in the root directory.The name alphabetagamma causes the system to search the root for directory alpha, then to searchalpha for beta, finally to find gamma in beta. gamma may be an ordinary file, a directory, or a specialfile. As a limiting case, the name  refers to the root itself.A path name not starting with  causes the system to begin the search in the users current directory. Thus, the name alphabeta specifies the file named beta in subdirectory alpha of the current directory. The simplest kind of name, for example, alpha, refers to a file that itself is found in the current directory. As another limiting case, the null file name refers to the current directory.The same nondirectory file may appear in several directories under possibly different names. Thisfeature is called linking a directory entry for a file is sometimes called a link. The Unix system differsfrom other systems in which linking is permitted in that all links to a file have equal status. That is, a filedoes not exist within a particular directory the directory entry for a file consists merely of its name and apointer to the information actually describing the file. Thus a file exists independently of any directoryentry, although in practice a file is made to disappear along with the last link to it.Each directory always has at least two entries. The name  .  in each directory refers to the directory itself. Thus a program may read the current directory under the name  .  without knowing its complete path name. The name  . .  by convention refers to the parent of the directory in which it appears,that is, to the directory in which it was created.The directory structure is constrained to have the form of a rooted tree. Except for the special entries .  and  . . , each directory must appear as an entry in exactly one other directory, which is its parent.The reason for this is to simplify the writing of programs that visit subtrees of the directory structure, andmore important, to avoid the separation of portions of the hierarchy. If arbitrary links to directories werepermitted, it would be quite difficult to detect when the last connection from the root to a directory was severed.3.3 Special filesSpecial files constitute the most unusual feature of the Unix file system. Each supported IO deviceis associated with at least one such file. Special files are read and written just like ordinary disk files, butrequests to read or write result in activation of the associated device. An entry for each special file residesin directory dev, although a link may be made to one of these files just as it may to an ordinary file. Thus,for example, to write on a magnetic tape one may write on the file devmt. Special files exist for eachcommunication line, each disk, each tape drive, and for physical main memory. Of course, the active disksand the memory special file are protected from indiscriminate access.There is a threefold advantage in treating IO devices this way file and device IO are as similar aspossible file and device names have the same syntax and meaning, so that a program expecting a file nameas a parameter can be passed a device name finally, special files are subject to the same protection mechanism as regular files.3.4 Removable file systemsAlthough the root of the file system is always stored on the same device, it is not necessary that theentire file system hierarchy reside on this device. There is a mount system request with two arguments thename of an existing ordinary file, and the name of a special file whose associated storage volume e.g., adisk pack should have the structure of an independent file system containing its own directory hierarchy. 4 The effect of mount is to cause references to the heretofore ordinary file to refer instead to the root directory of the file system on the removable volume. In effect, mount replaces a leaf of the hierarchy tree theordinary file by a whole new subtree the hierarchy stored on the removable volume. After the mount,there is virtually no distinction between files on the removable volume and those in the permanent file system. In our installation, for example, the root directory resides on a small partition of one of our diskdrives, while the other drive, which contains the users files, is mounted by the system initializationsequence. A mountable file system is generated by writing on its corresponding special file. A utility program is available to create an empty file system, or one may simply copy an existing file system.There is only one exception to the rule of identical treatment of files on different devices no linkmay exist between one file system hierarchy and another. This restriction is enforced so as to avoid theelaborate bookkeeping that would otherwise be required to assure removal of the links whenever theremovable volume is dismounted.3.5 ProtectionAlthough the access control scheme is quite simple, it has some unusual features. Each user of thesystem is assigned a unique user identification number. When a file is created, it is marked with the userID of its owner. Also given for new files is a set of ten protection bits. Nine of these specify independentlyread, write, and execute permission for the owner of the file, for other members of his group, and for allremaining users.If the tenth bit is on, the system will temporarily change the user identification hereafter, user ID ofthe current user to that of the creator of the file whenever the file is executed as a program. This change inuser ID is effective only during the execution of the program that calls for it. The setuserID feature provides for privileged programs that may use files inaccessible to other users. For example, a program maykeep an accounting file that should neither be read nor changed except by the program itself. If the setuserID bit is on for the program, it may access the file although this access might be forbidden to otherprograms invoked by the given programs user. Since the actual user ID of the invoker of any program isalways available, setuserID programs may take any measures desired to satisfy themselves as to theirinvokers credentials. This mechanism is used to allow users to execute the carefully written commandsthat call privileged system entries. For example, there is a system entry invokable only by the superuser below that creates an empty directory. As indicated above, directories are expected to have entriesfor  .  and  . . . The command which creates a directory is owned by the superuser and has the setuserID bit set. After it checks its invokers authorization to create the specified directory, it creates it andmakes the entries for  .  and  . . .Because anyone may set the setuserID bit on one of his own files, this mechanism is generallyavailable without administrative intervention. For example, this protection scheme easily solves the MOOaccounting problem posed by Alephnull. 8The system recognizes one particular user ID that of the superuser as exempt from the usualconstraints on file access thus for example, programs may be written to dump and reload the file systemwithout unwanted interference from the protection system.3.6 IO callsThe system calls to do IO are designed to eliminate the differences between the various devices andstyles of access. There is no distinction between random and sequential IO, nor is any logical recordsize imposed by the system. The size of an ordinary file is determined by the number of bytes written on itno predetermination of the size of a file is necessary or possible.To illustrate the essentials of IO, some of the basic calls are summarized below in an anonymouslanguage that will indicate the required parameters without getting into the underlying complexities. Eachcall to the system may potentially result in an error return, which for simplicity is not represented in thecalling sequence.To read or write a file assumed to exist already, it must be opened by the following callfilep  openname, flag 5 where name indicates the name of the file. An arbitrary path name may be given. The flag argument indicates whether the file is to be read, written, or updated, that is, read and written simultaneously.The returned value filep is called a file descriptor. It is a small integer used to identify the file insubsequent calls to read, write, or otherwise manipulate the file.To create a new file or completely rewrite an old one, there is a create system call that creates thegiven file if it does not exist, or truncates it to zero length if it does exist create also opens the new file forwriting and, like open, returns a file descriptor.The file system maintains no locks visible to the user, nor is there any restriction on the number ofusers who may have a file open for reading or writing. Although it is possible for the contents of a file tobecome scrambled when two users write on it simultaneously, in practice difficulties do not arise. We takethe view that locks are neither necessary nor sufficient, in our environment, to prevent interference betweenusers of the same file. They are unnecessary because we are not faced with large, singlefile data basesmaintained by independent processes. They are insufficient because locks in the ordinary sense, wherebyone user is prevented from writing on a file that another user is reading, cannot prevent confusion when, forexample, both users are editing a file with an editor that makes a copy of the file being edited.There are, however, sufficient internal interlocks to maintain the logical consistency of the file system when two users engage simultaneously in activities such as writing on the same file, creating files inthe same directory, or deleting each others open files.Except as indicated below, reading and writing are sequential. This means that if a particular byte inthe file was the last byte written or read, the next IO call implicitly refers to the immediately followingbyte. For each open file there is a pointer, maintained inside the system, that indicates the next byte to beread or written. If n bytes are read or written, the pointer advances by n bytes.Once a file is open, the following calls may be usedn  readfilep, buffer, countn  writefilep, buffer, countUp to count bytes are transmitted between the file specified by filep and the byte array specified by buffer.The returned value n is the number of bytes actually transmitted. In the write case, n is the same as countexcept under exceptional conditions, such as IO errors or end of physical medium on special files in aread, however, n may without error be less than count. If the read pointer is so near the end of the file thatreading count characters would cause reading beyond the end, only sufficient bytes are transmitted to reachthe end of the file also, typewriterlike terminals never return more than one line of input. When a readcall returns with n equal to zero, the end of the file has been reached. For disk files this occurs when theread pointer becomes equal to the current size of the file. It is possible to generate an endoffile from a terminal by use of an escape sequence that depends on the device used.Bytes written affect only those parts of a file implied by the position of the write pointer and thecount no other part of the file is changed. If the last byte lies beyond the end of the file, the file is made togrow as needed.To do random directaccess IO it is only necessary to move the read or write pointer to the appropriate location in the file.location  lseekfilep, offset, baseThe pointer associated with filep is moved to a position offset bytes from the beginning of the file, from thecurrent position of the pointer, or from the end of the file, depending on base. offset may be negative. Forsome devices e.g., paper tape and terminals seek calls are ignored. The actual offset from the beginningof the file to which the pointer was moved is returned in location.There are several additional system entries having to do with IO and with the file system that willnot be discussed. For example close a file, get the status of a file, change the protection mode or the ownerof a file, create a directory, make a link to an existing file, delete a file. 6 IV. IMPLEMENTATION OF THE FILE SYSTEMAs mentioned in Section 3.2 above, a directory entry contains only a name for the associated file anda pointer to the file itself. This pointer is an integer called the inumber for index number of the file.When the file is accessed, its inumber is used as an index into a system table the ilist stored in a knownpart of the device on which the directory resides. The entry found thereby the files inode contains thedescription of the filei the user and groupID of its ownerii its protection bitsiii the physical disk or tape addresses for the file contentsiv its sizev time of creation, last use, and last modificationvi the number of links to the file, that is, the number of times it appears in a directoryvii a code indicating whether the file is a directory, an ordinary file, or a special file.The purpose of an open or create system call is to turn the path name given by the user into an inumber bysearching the explicitly or implicitly named directories. Once a file is open, its device, inumber, andreadwrite pointer are stored in a system table indexed by the file descriptor returned by the open or create.Thus, during a subsequent call to read or write the file, the descriptor may be easily related to the information necessary to access the file.When a new file is created, an inode is allocated for it and a directory entry is made that contains thename of the file and the inode number. Making a link to an existing file involves creating a directory entrywith the new name, copying the inumber from the original file entry, and incrementing the linkcount fieldof the inode. Removing deleting a file is done by decrementing the linkcount of the inode specified byits directory entry and erasing the directory entry. If the linkcount drops to 0, any disk blocks in the fileare freed and the inode is deallocated.The space on all disks that contain a file system is divided into a number of 512byte blocks logicallyaddressed from 0 up to a limit that depends on the device. There is space in the inode of each file for 13device addresses. For nonspecial files, the first 10 device addresses point at the first 10 blocks of the file.If the file is larger than 10 blocks, the 11 device address points to an indirect block containing up to 128addresses of additional blocks in the file. Still larger files use the twelfth device address of the inode topoint to a doubleindirect block naming 128 indirect blocks, each pointing to 128 blocks of the file. Ifrequired, the thirteenth device address is a tripleindirect block. Thus files may conceptually grow to1012812821283512 bytes. Once opened, bytes numbered below 5120 can be read with a singledisk access bytes in the range 5120 to 70,656 require two accesses bytes in the range 70,656 to 8,459,264require three accesses bytes from there to the largest file 1,082,201,088 require four accesses. In practice, a device cache mechanism see below proves effective in eliminating most of the indirect fetches.The foregoing discussion applies to ordinary files. When an IO request is made to a file whose inode indicates that it is special, the last 12 device address words are immaterial, and the first specifies aninternal device name, which is interpreted as a pair of numbers representing, respectively, a device type andsubdevice number. The device type indicates which system routine will deal with IO on that device thesubdevice number selects, for example, a disk drive attached to a particular controller or one of several similar terminal interfaces.In this environment, the implementation of the mount system call Section 3.4 is quite straightforward. mount maintains a system table whose argument is the inumber and device name of the ordinaryfile specified during the mount, and whose corresponding value is the device name of the indicated specialfile. This table is searched for each inumberdevice pair that turns up while a path name is being scannedduring an open or create if a match is found, the inumber is replaced by the inumber of the root directoryand the device name is replaced by the table value.To the user, both reading and writing of files appear to be synchronous and unbuffered. That is,immediately after return from a read call the data are available conversely, after a write the usersworkspace may be reused. In fact, the system maintains a rather complicated buffering mechanism that 7 reduces greatly the number of IO operations required to access a file. Suppose a write call is made specifying transmission of a single byte. The system will search its buffers to see whether the affected diskblock currently resides in main memory if not, it will be read in from the device. Then the affected byte isreplaced in the buffer and an entry is made in a list of blocks to be written. The return from the write callmay then take place, although the actual IO may not be completed until a later time. Conversely, if a single byte is read, the system determines whether the secondary storage block in which the byte is located isalready in one of the systems buffers if so, the byte can be returned immediately. If not, the block is readinto a buffer and the byte picked out.The system recognizes when a program has made accesses to sequential blocks of a file, and asynchronously prereads the next block. This significantly reduces the running time of most programs whileadding little to system overhead.A program that reads or writes files in units of 512 bytes has an advantage over a program that readsor writes a single byte at a time, but the gain is not immense it comes mainly from the avoidance of systemoverhead. If a program is used rarely or does no great volume of IO, it may quite reasonably read andwrite in units as small as it wishes.The notion of the ilist is an unusual feature of Unix. In practice, this method of organizing the filesystem has proved quite reliable and easy to deal with. To the system itself, one of its strengths is the factthat each file has a short, unambiguous name related in a simple way to the protection, addressing, andother information needed to access the file. It also permits a quite simple and rapid algorithm for checkingthe consistency of a file system, for example, verification that the portions of each device containing usefulinformation and those free to be allocated are disjoint and together exhaust the space on the device. Thisalgorithm is independent of the directory hierarchy, because it need only scan the linearly organized ilist.At the same time the notion of the ilist induces certain peculiarities not found in other file system organizations. For example, there is the question of who is to be charged for the space a file occupies, because alldirectory entries for a file have equal status. Charging the owner of a file is unfair in general, for one usermay create a file, another may link to it, and the first user may delete the file. The first user is still theowner of the file, but it should be charged to the second user. The simplest reasonably fair algorithm seemsto be to spread the charges equally among users who have links to a file. Many installations avoid the issueby not charging any fees at all.V. PROCESSES AND IMAGESAn image is a computer execution environment. It includes a memory image, general register values,status of open files, current directory and the like. An image is the current state of a pseudocomputer.A process is the execution of an image. While the processor is executing on behalf of a process, theimage must reside in main memory during the execution of other processes it remains in main memoryunless the appearance of an active, higherpriority process forces it to be swapped out to the disk.The usermemory part of an image is divided into three logical segments. The program text segmentbegins at location 0 in the virtual address space. During execution, this segment is writeprotected and asingle copy of it is shared among all processes executing the same program. At the first hardware protection byte boundary above the program text segment in the virtual address space begins a nonshared, writable data segment, the size of which may be extended by a system call. Starting at the highest address inthe virtual address space is a stack segment, which automatically grows downward as the stack pointer fluctuates.5.1 ProcessesExcept while the system is bootstrapping itself into operation, a new process can come into existenceonly by use of the fork system callprocessid  forkWhen fork is executed, the process splits into two independently executing processes. The two processeshave independent copies of the original memory image, and share all open files. The new processes differonly in that one is considered the parent process in the parent, the returned processid actually identifies the 8 child process and is never 0, while in the child, the returned value is always 0.Because the values returned by fork in the parent and child process are distinguishable, each processmay determine whether it is the parent or child.5.2 PipesProcesses may communicate with related processes using the same system read and write calls thatare used for filesystem IO. The callfilep  pipereturns a file descriptor filep and creates an interprocess channel called a pipe. This channel, like otheropen files, is passed from parent to child process in the image by the fork call. A read using a pipe filedescriptor waits until another process writes using the file descriptor for the same pipe. At this point, dataare passed between the images of the two processes. Neither process need know that a pipe, rather than anordinary file, is involved.Although interprocess communication via pipes is a quite valuable tool see Section 6.2, it is not acompletely general mechanism, because the pipe must be set up by a common ancestor of the processesinvolved.5.3 Execution of programsAnother major system primitive is invoked byexecutefile, arg1, arg2, ... , argnwhich requests the system to read in and execute the program named by file, passing it string argumentsarg1, arg2, ..., argn. All the code and data in the process invoking execute is replaced from the file, butopen files, current directory, and interprocess relationships are unaltered. Only if the call fails, for example because file could not be found or because its executepermission bit was not set, does a return takeplace from the execute primitive it resembles a jump machine instruction rather than a subroutine call.5.4 Process synchronizationAnother process control system callprocessid  waitstatuscauses its caller to suspend execution until one of its children has completed execution. Then wait returnsthe processid of the terminated process. An error return is taken if the calling process has no descendants.Certain status from the child process is also available.5.5 TerminationLastlyexitstatusterminates a process, destroys its image, closes its open files, and generally obliterates it. The parent isnotified through the wait primitive, and status is made available to it. Processes may also terminate as aresult of various illegal actions or usergenerated signals Section VII below.VI. THE SHELLFor most users, communication with the system is carried on with the aid of a program called theshell. The shell is a commandline interpreter it reads lines typed by the user and interprets them asrequests to execute other programs. The shell is described fully elsewhere 9, so this section will discussonly the theory of its operation. In simplest form, a command line consists of the command name followed by arguments to the command, all separated by spacescommand arg1 arg2 ... argn 9 The shell splits up the command name and the arguments into separate strings. Then a file with namecommand is sought command may be a path name including the  character to specify any file in thesystem. If command is found, it is brought into memory and executed. The arguments collected by theshell are accessible to the command. When the command is finished, the shell resumes its own execution,and indicates its readiness to accept another command by typing a prompt character.If file command cannot be found, the shell generally prefixes a string such as bin to command andattempts again to find the file. Directory bin contains commands intended to be generally used. Thesequence of directories to be searched may be changed by user request.6.1 Standard IOThe discussion of IO in Section III above seems to imply that every file used by a program must beopened or created by the program in order to get a file descriptor for the file. Programs executed by theshell, however, start off with three open files with file descriptors 0, 1, and 2. As such a program beginsexecution, file 1 is open for writing, and is best understood as the standard output file. Except under circumstances indicated below, this file is the users terminal. Thus programs that wish to write informativeinformation ordinarily use file descriptor 1. Conversely, file 0 starts off open for reading, and programsthat wish to read messages typed by the user read this file.The shell is able to change the standard assignments of these file descriptors from the users terminalprinter and keyboard. If one of the arguments to a command is prefixed by , file descriptor 1 will, forthe duration of the command, refer to the file named after the . For examplelsordinarily lists, on the typewriter, the names of the files in the current directory. The commandls therecreates a file called there and places the listing there. Thus the argument there means place output onthere. On the other handedordinarily enters the editor, which takes requests from the user via his keyboard. The commanded scriptinterprets script as a file of editor commands thus script means take input from script.Although the file name following  or  appears to be an argument to the command, in fact itis interpreted completely by the shell and is not passed to the command at all. Thus no special coding tohandle IO redirection is needed within each command the command need merely use the standard filedescriptors 0 and 1 where appropriate.File descriptor 2 is, like file 1, ordinarily associated with the terminal output stream. When anoutputdiversion request with  is specified, file 2 remains attached to the terminal, so that commandsmay produce diagnostic messages that do not silently end up in the output file.6.2 FiltersAn extension of the standard IO notion is used to direct output from one command to the input ofanother. A sequence of commands separated by vertical bars causes the shell to execute all the commandssimultaneously and to arrange that the standard output of each command be delivered to the standard inputof the next command in the sequence. Thus in the command linels  pr 2  oprls lists the names of the files in the current directory its output is passed to pr, which paginates its inputwith dated headings. The argument 2 requests doublecolumn output. Likewise, the output from pris input to opr this command spools its input onto a file for offline printing.This procedure could have been carried out more clumsily by 10 ls temp1pr 2 temp1 temp2opr temp2followed by removal of the temporary files. In the absence of the ability to redirect output and input, a stillclumsier method would have been to require the ls command to accept user requests to paginate its output,to print in multicolumn format, and to arrange that its output be delivered offline. Actually it would besurprising, and in fact unwise for efficiency reasons, to expect authors of commands such as ls to providesuch a wide variety of output options.A program such as pr which copies its standard input to its standard output with processing iscalled a filter. Some filters that we have found useful perform character transliteration, selection of linesaccording to a pattern, sorting of the input, and encryption and decryption.6.3 Command separators multitaskingAnother feature provided by the shell is relatively straightforward. Commands need not be on different lines instead they may be separated by semicolonsls edwill first list the contents of the current directory, then enter the editor.A related feature is more interesting. If a command is followed by , the shell will not wait forthe command to finish before prompting again instead, it is ready immediately to accept a new command.For exampleas source output causes source to be assembled, with diagnostic output going to output no matter how long the assemblytakes, the shell returns immediately. When the shell does not wait for the completion of a command, theidentification number of the process running that command is printed. This identification may be used towait for the completion of the command or to terminate it. The  may be used several times in a lineas source output  ls files does both the assembly and the listing in the background. In these examples, an output file other than theterminal was provided if this had not been done, the outputs of the various commands would have beenintermingled.The shell also allows parentheses in the above operations. For exampledate ls x writes the current date and time followed by a list of the current directory onto the file x. The shell alsoreturns immediately for another request.6.4 The shell as a command command filesThe shell is itself a command, and may be called recursively. Suppose file tryout contains the linesas sourcemv a.out testprogtestprogThe mv command causes the file a.out to be renamed testprog. a.out is the binary output of the assembler, ready to be executed. Thus if the three lines above were typed on the keyboard, source would beassembled, the resulting program renamed testprog, and testprog executed. When the lines are in tryout,the commandsh tryoutwould cause the shell sh to execute the commands sequentially.The shell has further capabilities, including the ability to substitute parameters and to construct 11 argument lists from a specified subset of the file names in a directory. It also provides general conditionaland looping constructions.6.5 Implementation of the shellThe outline of the operation of the shell can now be understood. Most of the time, the shell is waiting for the user to type a command. When the newline character ending the line is typed, the shells readcall returns. The shell analyzes the command line, putting the arguments in a form appropriate for execute.Then fork is called. The child process, whose code of course is still that of the shell, attempts to performan execute with the appropriate arguments. If successful, this will bring in and start execution of the program whose name was given. Meanwhile, the other process resulting from the fork, which is the parentprocess, waits for the child process to die. When this happens, the shell knows the command is finished, soit types its prompt and reads the keyboard to obtain another command.Given this framework, the implementation of background processes is trivial whenever a commandline contains , the shell merely refrains from waiting for the process that it created to execute the command.Happily, all of this mechanism meshes very nicely with the notion of standard input and output files.When a process is created by the fork primitive, it inherits not only the memory image of its parent but alsoall the files currently open in its parent, including those with file descriptors 0, 1, and 2. The shell, ofcourse, uses these files to read command lines and to write its prompts and diagnostics, and in the ordinarycase its childrenthe command programsinherit them automatically. When an argument with  or is given, however, the offspring process, just before it performs execute, makes the standard IO filedescriptor 0 or 1, respectively refer to the named file. This is easy because, by agreement, the smallestunused file descriptor is assigned when a new file is opened or created it is only necessary to close file 0or 1 and open the named file. Because the process in which the command program runs simply terminates when it is through, the association between a file specified after  or  and file descriptor 0 or 1is ended automatically when the process dies. Therefore the shell need not know the actual names of thefiles that are its own standard input and output, because it need never reopen them.Filters are straightforward extensions of standard IO redirection with pipes used instead of files.In ordinary circumstances, the main loop of the shell never terminates. The main loop includes thebranch of the return from fork belonging to the parent process that is, the branch that does a wait, thenreads another command line. The one thing that causes the shell to terminate is discovering an endoffilecondition on its input file. Thus, when the shell is executed as a command with a given input file, as insh comfilethe commands in comfile will be executed until the end of comfile is reached then the instance of the shellinvoked by sh will terminate. Because this shell process is the child of another instance of the shell, thewait executed in the latter will return, and another command may then be processed.6.6 InitializationThe instances of the shell to which users type commands are themselves children of another process.The last step in the initialization of the system is the creation of a single process and the invocation viaexecute of a program called init. The role of init is to create one process for each terminal channel. Thevarious subinstances of init open the appropriate terminals for input and output on files 0, 1, and 2, waiting,if necessary, for carrier to be established on dialup lines. Then a message is typed out requesting that theuser log in. When the user types a name or other identification, the appropriate instance of init wakes up,receives the login line, and reads a password file. If the users name is found, and if he is able to supplythe correct password, init changes to the users default current directory, sets the processs user ID to thatof the person logging in, and performs an execute of the shell. At this point, the shell is ready to receivecommands and the loggingin protocol is complete.Meanwhile, the mainstream path of init the parent of all the subinstances of itself that will laterbecome shells does a wait. If one of the child processes terminates, either because a shell found an end offile or because a user typed an incorrect name or password, this path of init simply recreates the defunct 12 process, which in turn reopens the appropriate input and output files and types another login message.Thus a user may log out simply by typing the endoffile sequence to the shell.6.7 Other programs as shellThe shell as described above is designed to allow users full access to the facilities of the system,because it will invoke the execution of any program with appropriate protection mode. Sometimes, however, a different interface to the system is desirable, and this feature is easily arranged for.Recall that after a user has successfully logged in by supplying a name and password, init ordinarilyinvokes the shell to interpret command lines. The users entry in the password file may contain the name ofa program to be invoked after login instead of the shell. This program is free to interpret the users messages in any way it wishes.For example, the password file entries for users of a secretarial editing system might specify that theeditor ed is to be used instead of the shell. Thus when users of the editing system log in, they are inside theeditor and can begin work immediately also, they can be prevented from invoking programs not intendedfor their use. In practice, it has proved desirable to allow a temporary escape from the editor to execute theformatting program and other utilities.Several of the games e.g., chess, blackjack, 3D tictactoe available on the system illustrate a muchmore severely restricted environment. For each of these, an entry exists in the password file specifying thatthe appropriate gameplaying program is to be invoked instead of the shell. People who log in as a playerof one of these games find themselves limited to the game and unable to investigate the presumably moreinteresting offerings of the Unix system as a whole.VII. TRAPSThe PDP11 hardware detects a number of program faults, such as references to nonexistent memory, unimplemented instructions, and odd addresses used where an even address is required. Such faultscause the processor to trap to a system routine. Unless other arrangements have been made, an illegalaction causes the system to terminate the process and to write its image on file core in the current directory.A debugger can be used to determine the state of the program at the time of the fault.Programs that are looping, that produce unwanted output, or about which the user has secondthoughts may be halted by the use of the interrupt signal, which is generated by typing the delete character. Unless special action has been taken, this signal simply causes the program to cease execution without producing a core file. There is also a quit signal used to force an image file to be produced. Thus programs that loop unexpectedly may be halted and the remains inspected without prearrangement.The hardwaregenerated faults and the interrupt and quit signals can, by request, be either ignored orcaught by a process. For example, the shell ignores quits to prevent a quit from logging the user out. Theeditor catches interrupts and returns to its command level. This is useful for stopping long printouts without losing work in progress the editor manipulates a copy of the file it is editing. In systems withoutfloatingpoint hardware, unimplemented instructions are caught and floatingpoint instructions are interpreted.VIII. PERSPECTIVEPerhaps paradoxically, the success of the Unix system is largely due to the fact that it was notdesigned to meet any predefined objectives. The first version was written when one of us Thompson, dissatisfied with the available computer facilities, discovered a littleused PDP7 and set out to create a morehospitable environment. This essentially personal effort was sufficiently successful to gain the interest ofthe other author and several colleagues, and later to justify the acquisition of the PDP1120, specifically tosupport a text editing and formatting system. When in turn the 1120 was outgrown, the system had proveduseful enough to persuade management to invest in the PDP1145, and later in the PDP1170 and Interdata 832 machines, upon which it developed to its present form. Our goals throughout the effort, whenarticulated at all, have always been to build a comfortable relationship with the machine and to exploreideas and inventions in operating systems and other software. We have not been faced with the need to satisfy someone elses requirements, and for this freedom we are grateful. 13 Three considerations that influenced the design of Unix are visible in retrospect.First because we are programmers, we naturally designed the system to make it easy to write, test,and run programs. The most important expression of our desire for programming convenience was that thesystem was arranged for interactive use, even though the original version only supported one user. Webelieve that a properly designed interactive system is much more productive and satisfying to use than abatch system. Moreover, such a system is rather easily adaptable to noninteractive use, while the converse is not true.Second there have always been fairly severe size constraints on the system and its software. Giventhe partially antagonistic desires for reasonable efficiency and expressive power, the size constraint hasencouraged not only economy, but also a certain elegance of design. This may be a thinly disguised version of the salvation through suffering philosophy, but in our case it worked.Third nearly from the start, the system was able to, and did, maintain itself. This fact is more important than it might seem. If designers of a system are forced to use that system, they quickly become awareof its functional and superficial deficiencies and are strongly motivated to correct them before it is too late.Because all source programs were always available and easily modified online, we were willing to reviseand rewrite the system and its software when new ideas were invented, discovered, or suggested by others.The aspects of Unix discussed in this paper exhibit clearly at least the first two of these design considerations. The interface to the file system, for example, is extremely convenient from a programmingstandpoint. The lowest possible interface level is designed to eliminate distinctions between the variousdevices and files and between direct and sequential access. No large access method routines arerequired to insulate the programmer from the system calls in fact, all user programs either call the systemdirectly or use a small library program, less than a page long, that buffers a number of characters and readsor writes them all at once.Another important aspect of programming convenience is that there are no control blocks with acomplicated structure partially maintained by and depended on by the file system or other system calls.Generally speaking, the contents of a programs address space are the property of the program, and we havetried to avoid placing restrictions on the data structures within that address space.Given the requirement that all programs should be usable with any file or device as input or output, itis also desirable to push devicedependent considerations into the operating system itself. The only alternatives seem to be to load, with all programs, routines for dealing with each device, which is expensive inspace, or to depend on some means of dynamically linking to the routine appropriate to each device when itis actually needed, which is expensive either in overhead or in hardware.Likewise, the processcontrol scheme and the command interface have proved both convenient andefficient. Because the shell operates as an ordinary, swappable user program, it consumes no wireddown space in the system proper, and it may be made as powerful as desired at little cost. In particular,given the framework in which the shell executes as a process that spawns other processes to perform commands, the notions of IO redirection, background processes, command files, and userselectable systeminterfaces all become essentially trivial to implement.InfluencesThe success of Unix lies not so much in new inventions but rather in the full exploitation of a carefully selected set of fertile ideas, and especially in showing that they can be keys to the implementation of asmall yet powerful operating system.The fork operation, essentially as we implemented it, was present in the GENIE timesharing system10. On a number of points we were influenced by Multics, which suggested the particular form of the IOsystem calls 11, and both the name of the shell and its general functions. The notion that the shell shouldcreate a process for each command was also suggested to us by the early design of Multics, although in thatsystem it was later dropped for efficiency reasons. A similar scheme is used by TENEX 12. 14 IX. STATISTICSThe following numbers are presented to suggest the scale of the Research Unix operation. Those ofour users not involved in document preparation tend to use the system for program development, especiallylanguage work. There are few important applications programs.Overall, we have today125 user population33 maximum simultaneous users1,630 directories28,300 files301,700 512byte secondary storage blocks usedThere is a background process that runs at the lowest possible priority it is used to soak up any idleCPU time. It has been used to produce a milliondigit approximation to the constant e, and other semiinfinite problems. Not counting this background work, we average daily13,500 commands9.6 CPU hours230 connect hours62 different users240 loginsX. ACKNOWLEDGMENTSThe contributors to Unix are, in the traditional but here especially apposite phrase, too numerous tomention. Certainly, collective salutes are due to our colleagues in the Computing Science Research Center.R. H. Canaday contributed much to the basic design of the file system. We are particularly appreciative ofthe inventiveness, thoughtful criticism, and constant support of R. Morris, M. D. McIlroy, and J. F.Ossanna.References1. L. P. Deutsch and B. W. Lampson, An online editor, J. Comm. Assoc. Comp. Mach. 10 12,December 1967 pp. 793799, 8032. B. W. Kernighan and L. L. Cherry, A System for Typesetting Mathematics, J. Comm. Assoc.Comp. Mach. 18, pp. 151157, March 1975.3. B. W. Kernighan, M. E. Lesk and J. F. Ossanna, Document Preparation, Bell Sys. Tech. J. 57 6part 2, pp. 21152135, JulyAugust 1978.4. T. A. Dolotta and J. R. Mashey, An Introduction to the Programmers Workbench, Proc. 2nd Int.Conf. on Software Engineering, October 1315, 1976, pp. 164168.5. T. A. Dolotta, R. C. Haight, and J. R. Mashey, The Programmers Workbench, Bell Sys. Tech. J.57 6, pp. 21772200, JulyAugust, 1978.6. H. Lycklama, UNIX on a Microprocessor, Bell Sys. Tech. J., 57 6, pp. 20872101. JulyAugust1978.7. B. W. Kernighan and D. M. Ritchie, The C Programming Language, PrenticeHall, EnglewoodCliffs, New Jersey, 1978. Second edition, 1988.8. Alephnull, Computer Recreations, Software Practice and Experience, 1 2, AprilJune 1971, pp.201204.9. S. R. Bourne, The UNIX Shell, Bell Sys. Tech. J. 57 6, pp. 19711990, JulyAugust 1978.10. L. P. Deutsch and B. W. Lampson, SDS 930 timesharing system preliminary reference manual,Doc. 30.10.10, Project GENIE, Univ. Cal. at Berkeley, April 1965. 15 11. R. J. Feiertag and E. I. Organick, The Multics inputoutput system, Proc. Third Symposium onOperating Systems Principles, October 1820, 1971, pp. 3541.12. D. G. Bobrow, J. D. Burchfiel, D. L. Murphy, and R. S. Tomlinson, TENEX, a Paged Time SharingSystem for the PDP10, Comm. Assoc. Comp. Mach., 15 3, March 1972, pp. 135143.
