Improving the Reliability of CommodityOperating SystemsMICHAEL M. SWIFT, BRIAN N. BERSHAD, and HENRY M. LEVYUniversity of WashingtonDespite decades of research in extensible operating system technology, extensions such as devicedrivers remain a significant cause of system failures. In Windows XP, for example, drivers accountfor 85 of recently reported failures.This article describes Nooks, a reliability subsystem that seeks to greatly enhance operatingsystem OS reliability by isolating the OS from driver failures. The Nooks approach is practicalrather than guaranteeing complete fault tolerance through a new and incompatible OS or driverarchitecture, our goal is to prevent the vast majority of drivercaused crashes with little or no changeto the existing driver and system code. Nooks isolates drivers within lightweight protection domainsinside the kernel address space, where hardware and software prevent them from corrupting thekernel. Nooks also tracks a drivers use of kernel resources to facilitate automatic cleanup duringrecovery.To prove the viability of our approach, we implemented Nooks in the Linux operating systemand used it to faultisolate several device drivers. Our results show that Nooks offers a substantialincrease in the reliability of operating systems, catching and quickly recovering from many faultsthat would otherwise crash the system. Under a wide range and number of fault conditions, weshow that Nooks recovers automatically from 99 of the faults that otherwise cause Linux to crash.While Nooks was designed for drivers, our techniques generalize to other kernel extensions. Wedemonstrate this by isolating a kernelmode file system and an inkernel Internet service. Overall,because Nooks supports existing Clanguage extensions, runs on a commodity operating system andhardware, and enables automated recovery, it represents a substantial step beyond the specializedarchitectures and typesafe languages required by previous efforts directed at safe extensibility.Categories and Subject Descriptors D.4.5 Operating Systems ReliabilityFault toleranceGeneral Terms Reliability, ManagementAdditional Key Words and Phrases Recovery, device drivers, virtual memory, protection, IO1. INTRODUCTIONThis article describes the architecture, implementation, and performance ofNooks, a new operating system subsystem that allows existing operating systemThis work was supported in part by the National Science Foundation under grants ITR0085670,CCR0121341, and ITR0326546.Authors address Department of Computer Science and Engineering, University of Washington,Box 352350, Seattle, WA 98195 email mikesw,bershad,levycs.washington.edu.Permission to make digital or hard copies of part or all of this work for personal or classroom use isgranted without fee provided that copies are not made or distributed for profit or direct commercialadvantage and that copies show this notice on the first page or initial screen of a display alongwith the full citation. Copyrights for components of this work owned by others than ACM must behonored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers,to redistribute to lists, or to use any component of this work in other works requires prior specificpermission andor a fee. Permissions may be requested from Publications Dept., ACM, Inc., 1515Broadway, New York, NY 10036 USA, fax 1 212 8690481, or permissionsacm.org.C 2005 ACM 073420710502000077 5.00ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005, Pages 77110.78  M. M. Swift et al.OS extensions such as device drivers and loadable file systems to executesafely in commodity kernels. In contemporary systems, any fault in a kernel extension can corrupt vital kernel data, causing the system to crash. Toreduce the threat of extension failures, Nooks executes each extension in alightweight kernel protection domaina privileged kernelmode environmentwith restricted write access to kernel memory. Nooks interposition servicestrack and validate all modifications to kernel data structures performed by thekernelmode extension, thereby trapping bugs as they occur and facilitatingsubsequent automatic recovery.Three factors motivated our research. First, computer system reliability remains a crucial but unsolved problem Gillen et al. 2002 Patterson et al. 2002.While the cost of highperformance computing continues to drop, the cost offailures e.g., downtime on a stock exchange or ecommerce server, or the manpower required to service a helpdesk request in an office environment continues to rise. In addition, the growing sector of unmanaged systems, suchas digital appliances and consumer devices based on commodity hardware andsoftware Hewlett Packard 2001 TiVo Corporation 2001, amplifies the needfor reliability.Second, OS extensions have become increasingly prevalent in commodity systems such as Linux where they are called modules Bovet and Cesati 2001and Windows where they are called drivers Custer 1993. Extensions areoptional components that reside in the kernel address space and typicallycommunicate with the kernel through published interfaces. In addition todevice drivers, extensions include file systems, virus detectors, and networkprotocols. Extensions now account for over 70 of Linux kernel code Chouet al. 2001, while over 35,000 different drivers with over 120,000 versionsexist on Windows XP desktops Short 2003. Many, if not most, of these extensions are written by programmers significantly less experienced in kernel organization and programming than those who built the operating systemitself.Third, extensions are a leading cause of operating system failure. In WindowsXP, for example, drivers cause 85 of recently reported failures Short 2003.In Linux, the frequency of coding errors is seven times higher for device driversthan for the rest of the kernel Chou et al. 2001. While the core operatingsystem kernel reaches high levels of reliability due to longevity and repeatedtesting, the extended operating system cannot be tested completely. With tens ofthousands of extensions, operating system vendors cannot even identify themall, let alone test all possible combinations used in the marketplace.Improving OS reliability will therefore require systems to become highlytolerant of failures in drivers and other extensions. Furthermore, the hundredsof millions of existing systems executing tens of thousands of extensionsdemand a reliability solution that is at once backward compatible and efficientfor common extensions. Backward compatibility improves the reliability ofalready deployed systems. Efficiency avoids the classic tradeoff betweenrobustness and performance.Our focus on extensibility and reliability is not new. The last 20 years haveproduced a substantial amount of research on improving extensibility andACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  79reliability through the use of new kernel architectures Engler et al. 1995,new driver architectures ProjectUDI 1999, userlevel extensions Forin et al.1991 Liedtke 1995 Young et al. 1986, new hardware Fabry 1974 Witchelet al. 2002, or typesafe languages Bershad et al. 1995.While many of the underlying techniques used in Nooks have been used inprevious systems, Nooks differs from earlier efforts in two key ways. First, wetarget existing extensions for commodity operating systems rather than propose a new extension architecture. We want todays extensions to execute ontodays platforms without change if possible. Second, we use C, a conventionalprogramming language. We do not ask developers to change languages, development environments, or, most importantly, perspective. Overall, we focus ona single and very serious problemreducing the huge number of crashes dueto drivers and other extensions.We implemented a prototype of Nooks in the Linux operating system andexperimented with a variety of kernel extension types, including several device drivers, a file system, and a kernel Web server. Using automatic faultinjection Hsueh et al. 1997, we show that when injecting synthetic bugs intoextensions, Nooks can gracefully recover and restart the extension in 99 ofthe cases that cause Linux to crash. In addition, Nooks recovered from allof the common causes of kernel crashes that we manually inserted. Extension recovery occurs quickly, as compared to a full system reboot, leaving mostapplications running. For driversthe most common extension typethe impact on performance is low to moderate. Finally, of the eight kernel extensionswe isolated with Nooks, seven required no code changes, while only 13 lineschanged in the eighth. Although our prototype is Linuxbased, we expect thatthe architecture and many implementation features would port readily to othercommodity operating systems.The rest of this article describes the design, implementation, and performance of Nooks. The next section describes the systems guiding principlesand highlevel architecture. Section 3 discusses the systems implementationon Linux. We present experiments that evaluate the reliability of Nooks inSection 4 and its performance in Section 5. We then summarize related workin OS extensibility and reliability in Section 6. Section 7 summarizes our workand draws conclusions.2. ARCHITECTUREThe Nooks architecture is based on two core principles1 Design for fault resistance, not fault tolerance. The system must preventand recover from most, but not necessarily all, extension failures.2 Design for mistakes, not abuse. Extensions are generally wellbehaved butmay fail due to errors in design or implementation.From the first principle, we are not seeking a complete solution for all possibleextension errors. However, since extensions cause the vast majority of systemfailures, eliminating most extension errors will substantially improve systemreliability. From the second principle, we have chosen to occupy the designACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.80  M. M. Swift et al.space somewhere between unprotected and safe. That is, the extensionarchitecture for conventional operating systems such as Linux or Windowsis unprotected nearly any bug within the extension can corrupt or crash therest of the system. In contrast, safe systems such as SPIN Bershad et al. 1995or the Java Virtual Machine Gosling et al. 1996 strictly limit extension behavior and thus make no distinction between buggy and malicious code. Wetrust kernel extensions not to be malicious, but we do not trust them not to bebuggy.The practical impact of these principles is substantial, both positively andnegatively. On the positive side, it allows us to define an architecture thatdirectly supports existing driver code with only moderate performance costs.On the negative side, our solution does not detect or recover from 100 of allpossible failures and can be easily circumvented by malicious code acting withinthe kernel. As examples, consider a malfunctioning driver that continues to runand does not corrupt kernel data, but returns a packet that is 1 byte short, ora malicious driver that explicitly corrupts the system page table. We do notattempt to detect or correct such failures.Among failures that can crash the system, a spectrum of possible defensiveapproaches exist. These range from the Windows approach i.e., to preemptively crash to avoid data corruption to the full virtual machine approach i.e.,to virtualize the entire architecture and provide total isolation. Our approachlies in the middle. Like all possible approaches, it reflects tradeoffs among performance, compatibility, complexity, and completeness. Section 3.6 describesour current limitations. Some limitations are architectural, while others areinduced by the current hardware or software implementation. Despite theselimitations, given tens of thousands of existing drivers, and the millions of failures they cause, a faultresistant solution like the one we propose has practicalimplications and value.2.1 GoalsGiven the preceding principles, the Nooks architecture seeks to achieve threemajor goals1 Isolation. The architecture must isolate the kernel from extension failures.Consequently, it must detect failures in the extension before they infectother parts of the kernel.2 Recovery. The architecture must support automatic recovery to permit applications that depend on a failing extension to continue.3 Backward compatibility. The architecture must apply to existing systemsand existing extensions, with minimal changes to either.Achieving all three goals in an existing operating system is challenging.In particular, the need for backward compatibility rules out certain otherwise appealing technologies, such as type safety and capabilitybased hardware. Furthermore, backward compatibility implies that the performance of asystem using Nooks should not be significantly worse than a system withoutit.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  81Fig. 1. The Nooks Isolation Manager, a transparent OS layer inserted between the kernel andkernel extensions.2.2 FunctionsWe achieve the preceding goals by creating a new operating system reliabilitylayer that is inserted between the extensions and the OS kernel. The reliabilitylayer intercepts all interactions between the extensions and the kernel to facilitate isolation and recovery. A crucial property of this layer is transparency,that is, to meet our backward compatibility goals, it must be largely invisibleto existing components.Figure 1 shows this new layer, which we call the Nooks Isolation ManagerNIM. Above the NIM is the operating system kernel. The NIM function linesjutting up into the kernel represent kerneldependent modifications, if any,the OS kernel programmer makes to insert Nooks into a particular OS. Thesemodifications need only be made once. Underneath the NIM is the set of isolated extensions. The function lines jutting down below the NIM represent thechanges, if any, the extension writer makes to interface a specific extension orextension class to Nooks. In general, no modifications should be required atthis level, since transparency for existing extensions is our major objective.The NIM provides four major architectural functions, as shown in Figure 1isolation, interposition, object tracking, and recovery. We describe each functionbelow.2.2.1 Isolation. The Nooks isolation mechanisms prevent extension errorsfrom damaging the kernel or other isolated extensions. Every extension inNooks executes within its own lightweight kernel protection domain. This domain is an execution context with the same processor privilege as the kernelbut with write access to a limited portion of the kernels address space.The major task of the isolation mechanism, then, is protectiondomainmanagement. This involves the creation, manipulation, and maintenance oflightweight protection domains. The secondary task is interdomain controltransfer. Isolation services support the control flow in both directions betweenextension domains and the kernel domain.Unlike system calls, which are always initiated by an application, the kernel frequently calls into extensions. These calls may generate callbacks intothe kernel, which may then generate a call into the extension, and so on.This complex communication style is handled by a new kernel service, calledthe Extension Procedure Call XPCa control transfer mechanism specificallyACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.82  M. M. Swift et al.tailored to isolating extensions within the kernel. This mechanism resemblesLightweight Remote Procedure Call LRPC Bershad et al. 1990 and ProtectedProcedure Call PPC in capability systems Dennis and Horn 1966. However,LRPC and PPC handle control and data transfer between mutually distrustfulpeers. XPC occurs between trusted domains but is asymmetric i.e., the kernelhas more rights to the extensions domain than vice versa.2.2.2 Interposition. The Nooks interposition mechanisms transparently integrate existing extensions into the Nooks environment. Interposition code ensures that 1 all extensiontokernel and kerneltoextension control flow occurs through the XPC mechanism, and 2 all data transfer between the kerneland extension is viewed and managed by Nooks objecttracking code describedbelow.The interface between the extension, the NIM, and the kernel is providedby a set of wrapper stubs that are part of the interposition mechanism. Wrappers resemble the stubs in an RPC system Birrell and Nelson 1984 that provide transparent control and data transfer across address space and machineboundaries. Nooks stubs provide transparent control and data transfer between the kernel domain and extension domains. Thus, from the extensionsviewpoint, the stubs appear to be the kernels extension API. From the kernelspoint of view, the stubs appear to be the extensions function entry points.2.2.3 Object Tracking. The NIMs objecttracking functions oversee all kernelresources used by extensions. In particular, objecttracking code 1 maintainsa list of kernel data structures that are manipulated by an extension, 2 controls all modifications to those structures, and 3 provides object informationfor cleanup when an extension fails. An extensions protection domain cannotmodify kernel data structures directly. Therefore, objecttracking code mustcopy kernel objects into an extension domain so they can be modified and copythem back after changes have been applied. When possible, objecttracking codeverifies the type and accessibility of each parameter that passes between theextension and kernel.2.2.4 Recovery. Nooks recovery functions detect and recover from a varietyof extension faults. Nooks detects a software fault when an extension invokesa kernel service improperly e.g., with invalid arguments or when an extension consumes too many resources. In this case, recovery policy determineswhether Nooks triggers recovery or returns an error code to the extension,which can already handle the failure of a kernel function. Triggering recoveryprevents further corruption, but may degrade performance by recovering morefrequently. Nooks detects a hardware fault when the processor raises an exception during extension execution, for example, when an extension attemptsto read unmapped memory or to write memory outside of its protection domain. Unmodified extensions are of course not in a position to handle theirown hardware faults, so in such cases Nooks always triggers a higher levelrecovery.Faulty behavior may also be detected from outside Nooks by a user or aprogram. The user or program can then trigger Nooks recovery explicitly.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  83Extensions executing in a Nooks domain only access domainlocal memory directly. All extension access to kernel resources is managed and trackedthrough wrappers. Therefore, Nooks can successfully release extensionheldkernel structures, such as memory objects or locks, during the recoveryprocess.3. IMPLEMENTATIONWe implemented Nooks inside the Linux 2.4.18 kernel on the Intel x86 architecture. We chose Linux as our platform because of its popularity and its widesupport for kernel extensions in the form of loadable modules. Although wedeveloped Nooks on Linux, we expect that the architecture and design couldbe ported to other operating systems, such as Windows XP or Solaris. TheLinux kernel provides over 700 functions callable by extensions and more than650 extensionentry functions callable by the kernel. Moreover, few data typesare abstracted, and extensions directly access fields in many kernel data structures. Despite these challenges, one developer brought the system from conceptto function in about 18 months.The Linux kernel supports standard interfaces for many extension classes.For example, there is a generic interface for block and character devices, andanother one for file systems. The interfaces are implemented as C languagestructures containing a set of function pointers.Most interactions between the kernel and extensions take place throughfunction calls, either from the kernel into extensions or from extensions intoexported kernel routines. Some global data structures, such as the current taskstructure, are directly accessed by extensions. Fortunately, extensions modifyfew of these structures, and frequently do so through preprocessor macros andinline functions. As a result, Nooks can interpose on most extensionkernel interactions by intercepting the function calls between the extensions and kernel.Figure 2 shows the Nooks layer inside of Linux. Under the Nooks IsolationManager are isolated kernel extensions a single device driver, three stackeddrivers, and a kernel service. These extensions are wrapped by Nooks wrapper stubs, as indicated by the shaded boxes surrounding them. Each wrappedbox, containing one or more extensions, represents a single Nooks protectiondomain. Figure 2 also shows unwrapped kernel extensions that continue tointerface directly to the Linux kernel.The NIM exists as a Linux layer that implements the functions described inthe previous section. To facilitate portability, we do not use the Intel x86 protection rings or memory segmentation mechanisms. Instead, extensions executeat the same privilege level ring 0 as the rest of the kernel. Memory protectionis provided through the conventional page table architecture and can be implemented both with hardware and softwarefilled translationlookaside buffersTLBs.Table I shows the size of the Nooks implementation. Nooks is composedof about 22,000 lines of code. In contrast, the kernel itself has 2.4 millionlines, and the Linux 2.4 distribution, including user mode utilities, has about30 million Wheeler 2002. Other commodity systems are of similar size.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.84  M. M. Swift et al.Fig. 2. The Nooks layer shaded inside the Linux OS, showing wrapped Linux extensions executing in isolated protection domains. It is not necessary to wrap all extensions, as indicated by theunshaded extensions on the right.Table I. The Number of Noncomment Lines ofSource Code in NooksSource components  LinesMemory management 1,882Object tracking 1,454Extension Procedure Call 770Wrappers 14,396Recovery 1,136Linux kernel changes 924Miscellaneous 2,074Total number of lines of code 22,266For example, various reports have related that the Microsoft Windows Server2003 operating system contains over 50 million lines of code Thurrott 2003.Clearly, relative to a base kernel and its extensions, Nooks reliability layerintroduces only a modest amount of additional system complexity.In the following subsections we discuss implementation of Nooks major components isolation, interposition, wrappers, object tracking, and recovery. Wedescribe wrappers separately because they make up the bulk of Nooks codeand complexity. Finally, we describe limitations of the Nooks implementation.3.1 IsolationThe isolation components of Nooks consist of two parts 1 memory management, to implement lightweight protection domains with virtual memoryACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  85Fig. 3. Protection of the kernel address space.protection, and 2 Extension Procedure Call XPC, to transfer control safelybetween extensions and the kernel.Figure 3 shows the Linux kernel with two lightweight kernel protection domains, each containing a single extension. All components exist in the kernelsaddress space. However, memory access rights differ for each component forexample, the kernel has readwrite access to the entire address space, whileeach extension is restricted to readonly kernel access and readwrite access toits local domain. This is similar to the management of address space in somesingleaddressspace operating systems Chase et al. 1994.To provide extensions with read access to the kernel, Nooks memorymanagement code maintains a synchronized copy of the kernel page table for each domain. Each lightweight protection domain has private structures, including a domainlocal heap, a pool of stacks for use by the extension, memorymapped physical inputoutput IO regions, and kernel memorybuffers, such as socket buffers or IO blocks that are currently in use by theextension.We noted previously that Nooks protects against bugs but not against malicious code. Lightweight protection domains reflect this design. For example,Nooks prevents an extension from writing kernel memory, but it does not prevent a malicious extension from explicitly replacing the domainlocal page tableby reloading the hardware page table base register.Changing protection domains requires a change of page tables. The Intel x86architecture flushes the TLB on such a change hence, there is a substantialcost to entering a lightweight protection domain on the x86, both from theflush and from subsequent TLB misses. This cost could be mitigated in anarchitecture with a tagged TLB, such as the MIPS or Alpha, or with singleaddressspace protection support Koldinger et al. 1994, such as the IA64 orPARISC. However, because Nooks lightweight protection domains are kerneltasks that share kernel address space, they minimize the costs of schedulingand data copying on a domain change when compared to normal crossaddressspace or kerneluser remote procedure calls RPCs.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.86  M. M. Swift et al.Nooks currently does not protect the kernel from direct memory accessDMA by a device into the kernel address space. Preventing a rogue DMArequires hardware that is not generally present on x86 computers. However,Nooks tracks the set of pages writable by a driver and could use this informationto restrict DMA on a machine with the appropriate hardware support.Nooks uses the XPC mechanism to transfer control between extension andkernel domains. XPC is transparent to both the kernel and its extensions, whichcontinue to interact through their original procedural interfaces. Transparencyis provided by means of the wrapper mechanism, described in Section 3.3.Control transfer in XPC is managed by two functions internal to Nooks1 nooks driver call transfers from the kernel into an extension, and 2nooks kernel call transfers from extensions into the kernel. These functionstake a function pointer, an argument list, and a protection domain. They executethe function with its arguments in the specified domain. The transfer routinessave the callers context on the stack, find a stack for the calling domain whichmay be newly allocated or reused when calls are nested, change page tablesto the target domain, and then call the function. The reverse operations areperformed when the call returns.The performance cost of an XPC is relatively high because it requires changing page tables and potentially flushing the TLB. To ameliorate this cost, XPCalso supports deferred calls, which batches many calls into a single domaincrossing. Wrappers queue deferred function calls for later execution, either atthe entry or exit of a future XPC. For example, we changed the packetdeliveryroutine used by the network driver to batch the transfer of message packetsfrom the driver to the kernel. When a packet arrives, the extension calls awrapper to pass the packet to the kernel. The wrapper queues the packet andbatches it with the next few packets that arrive. Function calls such as thiscan be deferred because there are no visible side effects to the call. Two queuesexist for each domain an extensiondomain queue holds delayed kernel calls,and a kerneldomain queue holds delayed extension calls.In addition to deferring calls for performance reasons, Nooks also uses deferred XPC to synchronize extension modifications to objects explicitly passedfrom the kernel to extensions. In Linux, the kernel often returns a kernel structure pointer to an extension for structure modification, with no explicit synchronization of the update. The kernel assumes that the modification is atomic andthat the extension will update it in time. In such cases, the wrapper queuesa deferred function call to copy the modified object back to the kernel at theextensions next XPC return to the kernel.We made several onetime changes to the Linux kernel to support isolation.First, to maintain coherency between the kernel and extension page tables, weinserted code wherever the Linux kernel modifies the kernel page table. Second,we modified the kernel exception handlers to detect exceptions that occur withinNooks protection domains. This new code swaps in the kernels stack pointerand page directory pointer for the task. On return from exception, the coderestores the stack pointer and page table for the extension. Finally, becauseLinux colocates the task structure on the kernel stack which changes as aresult of isolation, we had to change its mechanism for locating the currentACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  87task structure. We currently use a global variable to hold the task pointer,which is sufficient for uniprocessor systems. On a multiprocessor, we would usean otherwise unused x86 segment register, as is done in Windows.3.2 InterpositionInterposition allows Nooks to intercept and control communication betweenextensions and the kernel. Nooks interposes on extensionkernel control transfers with wrapper stubs. Wrappers provide transparency by preserving existingkerneldriver procedurecall interfaces while enabling the protection of all control and data transfers in both directions. Control interposition required twochanges to Linux kernel code. First, we modified the standard module loaderto bind extensions to wrappers instead of kernel functions when the extensions are loaded. Second, we modified the kernels module initialization codeto explicitly interpose on the initialization call into an extension, enabling theextension to execute within its lightweight protection domain. Following initialization, all function pointers passed from the extension to the kernel arereplaced by wrapper pointers. This causes the kernel to call wrappers ratherthan extension procedures directly.In addition to interposing on control transfers, Nooks must interpose on somedata references. The Linux kernel exports many objects that are only read byextensions e.g., the current time. These objects are linked directly into theextension so they can be freely read. Other kernel objects are directly writtenby extensions. We changed macros and inline functions that directly modifykernel objects into wrapped function calls. For object modifications that are notperformance critical, Nooks converts the access into an XPC into the kernel.For performancecritical data structures, we create a shadow copy of the kernelobject within the extensions domain. The contents of the kernel object and theshadow object are synchronized before and after XPCs into the extension. Thistechnique is used, for example, for the softnet data structure, which containsa queue of the packets sent and received by a network device.3.3 WrappersAs noted above, Nooks inserts wrapper stubs between kernel and extensionfunctions. There are two types of wrappers kernel wrappers are called by extensions to execute kernelsupplied functions extension wrappers are called bythe kernel to execute extensionsupplied functions. In either case, a wrapperfunctions as an XPC stub that appears to the caller as if it were the targetprocedure in the called domain.Both wrapper types perform the body of their work within the kernels protection domain. Therefore, the domain change occurs at a different point depending on the direction of transfer, as shown in Figure 4. When an extensioncalls a kernel wrapper, the wrapper performs an XPC on entry so that the bodyof the wrapper i.e., object checking, copying, etc. can execute in the kernelsdomain. Once the wrappers work is done, it calls the target kernel functiondirectly with a local procedure call. In the opposite direction, when the kernelcalls an extension wrapper, the wrapper executes within the kernels domain.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.88  M. M. Swift et al.Fig. 4. Control flow of extension and kernel wrappers.When it is done, the wrapper performs an XPC to transfer to the target functionwithin the extension.Wrappers perform three basic tasks. First, they check parameters for validity by verifying with the object tracker and memory manager that pointers arevalid. Second, objecttracker code within wrappers implements callbyvalueresult semantics for XPC, by creating a copy of kernel objects on the local heapor stack within the extensions protection domain. No marshalling or unmarshalling is necessary, because the extension and kernel share the kernel address space. For simple objects, the synchronization code is placed directly inthe wrappers. For more complex objects, such as file system inodes or directoryentries that have many pointers to other structures, we wrote explicit synchronization routines to copy objects between the kernel and an extension. Third,wrappers perform an XPC into the kernel or extension to execute the desiredfunction, as shown in Figure 4.Wrappers are relatively straightforward to write and integrate into thekernel. We developed a tool that automatically generates wrapper entry codeand the skeleton of wrapper bodies from Linux kernel header files. To create thewrappers for exported kernel functions, the tool takes a list of kernel functionnames and generates wrappers that implement function interposition throughXPC. Similarly, for the kerneltoextension interface, the tool takes a list of interfaces C structures containing function pointers and generates wrappers forthe kernel to call.We wrote the main wrapper body functions by hand. This is a onetime taskrequired to support the kernelextension interface for a specific OS. This codeverifies that parameters are correct and moves parameters between protectiondomains. Once written, wrappers are automatically usable by all extensionsthat use the kernels interface. Writing a wrapper requires knowing how parameters are used whether parameters are alive across calls or are passed toother threads, and which parameters or fields of parameters can be modified.We performed this task by hand, but metacompilation Engler et al. 2000 couldbe used to determine the characteristics of extensions by analyzing the set ofexisting drivers.3.3.1 Wrapper Code Sharing. Section 4 describes the eight extensions weisolated for our Nooks experiments two soundcard drivers sb and es1371,ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  89Fig. 5. Code sharing among wrappers for different extensions.four Ethernet drivers pcnet32, e1000, 3c59x, and 3c90x, a file system VFAT,and an inkernel Web server kHTTPd.Previously, Table I showed that the Nooks implementation includes 14Klines of wrapper code, over half of the Nooks code base. We implemented 248wrappers in all, which we use to isolate 463 imported and exported functions.Wrapper code is thus often shared among multiple drivers in a class or acrossclasses.Figure 5 shows the total number of wrappers both kernel and extensionwrappers used by each of these extensions. Each bar gives a breakdown ofthe number of wrappers unique to that extension and the number of wrappersshared in various ways. Sharing reduces the cost of adding fault resistance to agiven extension. For example, of the 44 wrappers used by the pcnet32 Ethernetdriver 31 kernel wrappers and 13 extension wrappers, 27 are shared amongthe four network drivers. Similarly, 39 wrappers are shared between the twosoundcard drivers. Overall, of the 159 wrappers that are not shared, 114 arein the oneofakind extensions VFAT and kHTTPd.3.4 Object TrackingThe object tracker facilitiates the recovery of kernel objects following an extension failure. The Nooks object tracker performs two independent tasks. First,it records the addresses of all objects in use by an extension. Objects usedonly for the duration of a single XPC call are recorded in a table attachedto the current task structure. Objects with long lifetimes are recorded in aACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.90  M. M. Swift et al.perprotectiondomain hash table. Second, for objects that may be written byan extension, the object tracker records an association between the kernel andextension versions of the object. This association is used by wrappers to pass parameters between the extensions protection domain and the kernels protectiondomain.The object tracker must know the lifetimes of objects to perform garbagecollection, when necessary, or to prevent extensions from using dangling references. Currently, this code can be written only by examining the kernelextension interface. There are several common paradigms. For example, someobjects are accessible to the extension only during the lifetime of a single XPCcall from the kernel. In this case, we add the object to the trackers databasewhen the call begins and remove it on return. Other objects are explicitly allocated and deallocated by the extension, in which case we know their lifetimesexactly. In still other cases, we go by the semantics of the object and its use.For example, extensions allocate the timer data structure to suspend a task.We add this object to the object tracker when an extension calls add timer andremove it when the timer fires, at which point we know that it is no longer used.In some cases, it may be necessary to modify the kernel to notify Nooks whenan object is deleted.Complex objects may be handled in different ways. In some cases, Nookscopies objects into the extensions protection domain, following embedded pointers as appropriate. In other cases, Nooks avoids copying, for example, by mapping network packets and disk blocks into and out of an extension. A pagetracker mechanism within the object tracker remembers the state of thesemapped pages and grants and revokes extension access to the pages.Our Nooks implementation currently supports many kernel object types,such as tasklets, PCI devices, inodes, and memory pages. To determine theset of objects to track, we inspected the interfaces between the kernel andour supported extensions and noted every object that passed through thoseinterfaces. We then wrote objecttracking procedures for each of the 43 objecttypes that we saw. For each object type, there is a unique type identifier andcode to release instances of that type during recovery.3.5 RecoveryRecovery in Nooks consists of two parts. After a fault occurs, the recovery manager releases resources in use by the extension. The usermode agent coordinatesrecovery and determines what course of action to take.Nooks triggers recovery when it detects a failure through software checkse.g., parameter validation or livelock detection, processor exceptions, or explicit external signals. After a failure, Nooks suspends the running extensionand notifies the recovery manager.The Nooks recovery manager is tasked with returning the system, includingthe extension, to a clean state from which it can continue. The recovery managerexecutes in phases to ensure that resources are not used after they are released.The first phase of recovery is specific to device drivers Nooks disables interruptprocessing for the device controlled by the extension, preventing livelock thatACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  91could occur if device interrupts are not properly dismissed. It then starts ausermode recovery agent, which controls the subsequent recovery.The usermode recovery agent relies on a configuration database to definethe recovery policy for specific extensions or classes of extensions. The agent canperform extensionspecific recovery actions as well as notify system managersof the fault. It can also change configuration parameters, replace the extension,or even disable recovery if the extension fails too frequently. The agent requiresthat many kernel components, such as a file system and disk driver, functionproperly.In designing the recovery mechanism, we assume that drivers fail due totransient faults, or heisenbugs Gray 1996, that do not always reproduce. Thisis evidenced by the fact that drivers typically function correctly after rebooting.We take advantage of the nonreproducing nature of driver faults to simplifyour recovery process. Rather than trying to roll back the driver to a previoussafe state, we instead completely restart the driver.By default, the recovery agent initiates full recovery of faulting extensions byunloading the extension, releasing all of its kernel and physical resources, andthen reloading and restarting the extension. The agent first calls the recoverymanager to release any resources that may be safely reused by the kernel.The recovery manager signals tasks that are currently executing within theextension, or have called through the extension, to unwind. For a task in anoninterruptible state in either the kernel or another extension, complete recovery may be impossible if the sleeping task never wakes. In this case, partialrecovery may still be possible, even though not all processes will continue toexecute. Uninterruptible sleeps are infrequent in the Linux kernel, however,so we do not believe this to be a significant limitation. Nooks then releases anykernel resources the extension is using that will not be accessed by an externaldevice. For example, a network device may continue to write to packet buffersin memory therefore, those buffers cannot be released until the device has beenreinitialized.The recovery manager walks the list of objects known to the object trackerand releases, frees, or unregisters all objects that will not be accessed by external devices. Nooks associates each object type in the tracker with a recoveryfunction. The function releases the object to the kernel and removes all references from the kernel into the extension. If new kernelextension interfacesare added to Nooks, kernel developers need only add functions to recover newobject types used by those interfaces.Nooks ensures the correctness of kernel data structures after recovery boththrough the object tracker and through XPC. The use of callbyvalueresult ensures that the kernel data structures are updated atomically. The object trackerrecords all references between extension and kernel data structures and cantherefore remove all references to the extension.After releasing kernel resources, the agent unloads the extension. It thenconsults policy and may choose to automatically reload the extension in a newlightweight protection domain. The agent then initializes the extension, usingthe startup scripts that accompany the extension. For device drivers, only afterthe driver has been reloaded does Nooks finally release all physical resourcesACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.92  M. M. Swift et al.that could be accessed by the device, such as interrupt request levels IRQsand physical memory regions.3.6 Implementation LimitationsSection 2 described the Nooks philosophy of designing for mistakes and forfault resistance. The Nooks implementation involves many tradeoffs. As such,it does not provide complete isolation or fault tolerance for all possible extensionerrors. Nooks runs extensions in kernel mode to simplify backward compatibility, so we cannot prevent extensions from deliberately executing privilegedinstructions that corrupt system state. We do not prevent infinite loops insideof the extension, but we do detect livelock between the extension and kernelwith timeouts. Finally, we check parameters passed to the operating system,but we cannot do a complete job given Linux semantics or lack thereof.Our current implementation of recovery is limited to extensions that can bekilled and restarted safely. This is true for device drivers, which are dynamicallyloaded when hardware devices are attached to a system. It may not be true forall extensions.These limitations are not insignificant, and crashes may still occur. However,we believe that our implementation will allow a kernel to resist many crashescaused by extensions. Given the enormous number of such crashes, a faultresistant solution can have a large impact on overall reliability.3.7 Achieving TransparencyAs previously mentioned, the Nooks code isolates an extension from the restof the kernel, and tracks all resources it uses. Isolation allows Nooks to catcherrant behavior. Resource tracking allows Nooks to clean up extension state following that behavior. Both isolation and resource tracking rely on being able tointerpose on all communication between the kernel and extensions. For themost part, all such communication in Linux takes place by means of a procedurecall or an inlined macro, which we replace at compile time with a procedurecall.Our implementation is therefore oriented toward these interface abidingtypes of extensions, allowing us to incorporate them into the Nooks infrastructure in a completely transparent waythat is, neither the kernel nor theextension requires any modification. Unfortunately, there are a few extensionswhich store directly into kernel data structures, making it impossible to transparently interpose. For these types of extensions, it is necessary to manuallymodify the code so as to replace stores with procedure calls. In all, of the eight extensions we isolated for our extensions, seven required no code modifications,while one kHTTPd required that we modify 13 lines of code which directlywrote to kernel data structures.4. EVALUATING RELIABILITYThe thesis of our work is that Nooks can significantly improve system reliabilityby isolating the kernel from extension failures. This section uses automatedexperiments to demonstrate that Nooks can detect and automatically recoverACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  93Table II. The Types of Faults Injected into Extensions and the CodeTransformations Used to Emulate These FaultsFault type Code transformationSource fault Change the source registerDestination fault Change the destination registerPointer fault Change the address calculation for a memory instructionInterface fault Use existing value in register instead of passed parameterBranch fault Delete a branch instructionLoop fault Invert the termination condition of a loop instructionText fault Flip a bit in an instructionNOP fault Elide an instructionfrom faults in extensions. In these tests, Nooks recovered from 99 of extensionfaults that would otherwise crash Linux.4.1 Test MethodologyWe tested Nooks on a variety of existing kernel extensions and artifically introduced bugs to induce faults.4.1.1 Fault Injection. Our experiments used synthetic fault injection to insertfaults into Linux kernel extensions. We adapted a fault injector developed forthe Rio File Cache Ng and Chen 1999 and ported it to Linux. The injectorautomatically changes single instructions in the extension code to emulate avariety of common programming errors, such as uninitialized local variables,bad parameters, and inverted test conditions.We injected two different types of faults into the system. First, we injectedfaults that emulate specific programming errors common to kernel code according to earlier studies Sullivan and Chillarege 1991 Christmansson andChillarege 1996. Source and destination faults emulate assignment errors bychanging the operand or destination of an instruction. Pointer faults emulateincorrect pointer calculations and cause memory corruption. Interface faultsemulate bad parameters. We emulated bugs in control flow through branchfaults, which remove a branch instruction, and by loop faults, which changethe termination condition for a loop.Second, we expanded the range of testing by injecting random changes thatdo not model specific programming errors. In this category are text faults, inwhich we flipped a random bit in a random instruction, and NOP faults, inwhich we deleted a random instruction.Table II shows the types of faults we injected, and how the injector simulatesprogramming errors see Ng and Chen 1999 for a more complete descriptionof the fault injector. In our tests, we injected an equal number of each faulttype.4.1.2 Types of Extensions Isolated. In the experiments reported below, weused Nooks to isolate three types of extensions device drivers, a kernel subsystem VFAT, and an applicationspecific kernel extension kHTTPd. Thedevice drivers we chose were common network and sound card drivers, representative of the largest class of Linux drivers Linux has more than 48 soundACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.94  M. M. Swift et al.Table III. The Extensions Isolated and the Function That Each PerformsMeasurements are reported for extensions shown in bold.Extension Purposesb SoundBlaster 16 driveres1371 Ensoniq sound drivere1000 Intel Pro1000gigabit Ethernet driverpcnet32 AMD PCnet32 10100 Ethernet driver3c59x 3COM 3c59x series 10100 Ethernet driver3c90x 3COM 3c90x series 10100 Ethernet driverVFAT Win95 compatible file systemkHTTPd Inkernel Web servercard drivers and 190 network drivers. A device drivers interaction with thekernel is well matched to the Nooks isolation model for many reasons. First,drivers invoke the kernel and are invoked by the kernel through narrow, welldefined interfaces therefore, it is straightforward to design and implementtheir wrappers. Second, drivers frequently deal with blocks of opaque data,such as network packets or disk blocks, that do not require validation. Third,drivers often batch their processing to amortize interrupt overheads. When runwith Nooks, batching also reduces isolation overhead.In addition to device drivers, we isolated a loadable kernel subsystem. Thesubsystem we chose was the optional VFAT file system, which is compatiblewith the Windows 95 FAT32 file system Microsoft Corporation 2000. Whiledrivers tend to have a small number of interfaces with relatively few functions,the VFAT interface is larger and more complex than the device drivers. VFAThas six distinct interfaces that together export over 35 calls by comparison, thesound and network devices each have one interface with 8 and 13 functions,respectively. In addition, driver interfaces tend to pass relatively simple datastructures, such as network packets and device objects, while the file systeminterfaces pass complex, heavily linked data structures such as inodes.Last, we isolated an applicationspecific kernel extensionthe kHTTPd Webserver van de Ven 1999. kHTTPd resides in the kernel so that it can accesskernel network and file system data structures directly, avoiding otherwiseexpensive system calls. Our experience with kHTTPd demonstrates that Nookscan isolate even ad hoc and unanticipated kernel extensions.Overall, we have isolated eight extensions under Nooks, as shown inTable III. We present reliability and performance results for five of the extensions representing the three extension types sb, e1000, pcnet32, VFAT, andkHTTPd. Results for the remaining three drivers are consistent with thosepresented.4.1.3 Test Environment. Our applicationlevel workload consists of four programs that stress the sound card driver, the network driver, VFAT, andkHTTPd. The first program plays a short MP3 file. The second performs aseries of ICMPping and TCP streaming tests, while the third untars and compiles a number of files. The fourth program runs a Web load generator againstour kernellevel Web server.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  95We ran our reliability experiments in the context of the VMware VirtualMachine Sugerman et al. 2001. The virtual machine allows us to performthousands of tests remotely while quickly and easily returning the system to aclean state following each one. We spotchecked a number of the VMware trialsagainst a base hardware configuration i.e., no virtual machine and discoveredno anomalies. In addition, the e1000 tests were run directly on raw hardware,because VMware does not support the Intel Pro1000gigabit Ethernet card.To measure reliability, we conducted a series of trials in which we injectedfaults into extensions running under two different Linux configurations. In thefirst, called native, the Nooks isolation services were present but unused. Inthe second, called Nooks, the isolation services were enabled for the extensionunder test. For each extension, we ran 400 trials 50 of each fault type onthe native configuration. In each trial, we injected five random errors into theextension and exercised the system, observing the results. We then ran thosesame 400 trials, each with the same five errors, against Nooks. It is important tonote that our native and Nooks configurations are identical binaries, allowingour automatic fault injector to introduce identical errors. Hence, we used thesame kernel and module binaries for both tests. We next describe the results ofour experiments.4.2 Test ResultsAs described above, we ran 400 faultinjection trials for each of the five measured extensions for native and Nooks configurations. Not all faultinjectiontrials cause faulty behavior, for example, bugs inserted on a rarely or neverexecuted path will rarely or never produce an error. However, many trials docause failures. We now examine different types of failures that occurred.4.2.1 System Crashes. A system crash is the most extreme and easiest problem to detect, as the operating system either panics, becomes unresponsive, orsimply reboots. In an ideal world, every system crash caused by a faultinjectiontrial under native Linux would result in a recovery under Nooks. In practice,however, as previously discussed, Nooks may not detect or recover from certainfailures caused by very bad programmers or very bad luck.Figure 6 shows the number of system crashes caused by our faultinjectionexperiments for each of the extensions running on native Linux and Nooks.Of the 365 crashes observed with native Linux, Nooks eliminated 360, or 99.In the remaining five crashes the system deadlocked, which Nooks does nothandle.Figure 6 also illustrates a substantial difference in the number of systemcrashes that occur for VFAT and sb extensions under Linux, compared to e1000,pcnet32, and kHTTPd. This difference reflects the way in which Linux respondsto kernel failures. The e1000 and pcnet32 extensions are interruptoriented,that is, kernelmode extension code is run as the result of an interrupt. VFATand sb extensions are processoriented, that is, kernelmode extension code isrun as the result of a system call from a user process. kHTTPd is processoriented but manipulates and therefore can corrupt interruptlevel data structures. Linux treats exceptions in interruptoriented code as fatal and crashesACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.96  M. M. Swift et al.Fig. 6. The reduction in system crashes in 2000 faultinjection trials 400 for each extensionobserved using Nooks. In total, there were 365 system crashes in the native configuration and onlyfive system crashes with Nooks.the system hence the large number of crashes in e1000, pcnet32, and kHTTPd.Linux treats exceptions in processoriented code as nonfatal, continuing to runthe kernel but terminating the offending process even though the exception occurred in the kernel. This behavior is unique to Linux. Other operating systems,such as Microsoft Windows XP, deal with kernel processor exceptions more aggressively by always halting the operating system. In such systems, VFAT andsb would cause system crashes.4.2.2 Nonfatal Extension Failures. While Nooks is designed to protect the OSfrom misbehaving extensions, it is not designed to detect erroneous extensionbehavior. For example, the network could disappear because the device drivercorrupts the device registers, or a mounted file system might simply becomenonresponsive due to a bug. Neither of these failures is fatal to the systemin its own right, and Nooks generally does not detect such problems nor isit intended to. However, when Nooks simple failure detectors do detect suchproblems, its recovery services can safely restart the faulty extensions.Our faultinjection trials cause a number of nonfatal extension failures, allowing us to examine Nooks effectiveness in dealing with these cases, as well.Figure 7 shows the extent to which Nooks reduces nonfatal extension failuresthat occurred in native Linux. In reality, these results are simply a reflectionof the Linux handling of process and interruptoriented extension code, aspreviously described. That is, Nooks can trap exceptions in processorientedACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  97Fig. 7. The reduction in nonfatal extension failures observed using Nooks. In total, there were471 such failures in the native configuration and 210 with Nooks.extensions and can recover the extensions to bring them to a clean state inmany cases.For the two interruptoriented Ethernet drivers e1000 and pcnet32, Nooksalready eliminated all system crashes resulting from extension exceptions. Theremaining noncrash failures are those that leave the device in a nonfunctionalstate, for example, unable to send or receive packets. Nooks cannot removethese failures for e1000 and pcnet32, since it cannot detect them. The few extension failures it eliminated occurred when the device was being manipulatedby processoriented code.For VFAT and the sb sound card driver, Nooks reduced the number of nonfatalextension failures. These failures were caused by kernel exceptions in processoriented code, which caused Linux to terminate the calling process and leave theextension in an illdefined state. Nooks detected the processor exceptions andperformed an extension recovery, thereby allowing the application to continue.The remaining nonfatal extension failures, which occurred under native Linuxand Nooks, were serious enough to leave the extension in a nonfunctioning statebut not serious enough to generate a processor exception that could be trappedby Nooks.The kHTTPd extension is similar to the interruptoriented drivers because itcauses corruption that leads to interruptlevel faults. However, a small numberof injected faults caused exceptions within the kHTTPd processoriented code.These were caught by Nooks and an extension failure was avoided.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.98  M. M. Swift et al.In general, the remaining nonfatal extension failures under Nooks were theresult of deadlock or data structure corruption within the extension itself. Fortunately, such failures were localized to the extension and could usually be recovered from once discovered. It is straightforward to develop a nanny servicethat probes for disabled extensions and invokes Nooks recovery procedures, asappropriate. Alternatively, the failure could be detected by the user, who canthen invoke Nooks to initiate a manual recovery.4.2.3 Recovery Errors. The Nooks recovery procedure is straightforwardafaulting extension is unloaded, reloaded, and restarted. For network, sb, andkHTTPd extensions, this process improves reliability directly. For VFAT, however, which deals with persistent state stored on disk, there is some chance thatthe extension will damage critical ondisk structures before Nooks detects anerror condition.In practice, we found that in 90 of the cases, VFAT recovery resulted inondisk corruption i.e., lost or corrupt files or directories. Since fault injectionoccurs after many files and directories have been created, the abrupt shutdownand restart of the file system leaves them in a corrupted state. As an experiment, we caused Nooks to synchronize the disks with the inmemory diskcache before releasing resources on a VFAT recovery. This reduced the number of corruption cases from 90 to 10. While we would not expect Nooksto do this automatically, it suggests that there may be extensions to Nooksthat could improve recovery through the use of applicationspecific recoveryservices.4.2.4 Manually Injected Errors. In addition to the automatic faultinjectionexperiments, we inserted about 10 bugs by hand. Taking the most commonfixes for faults reported on the Linux Kernel Mailing List and in the articleby Chou et al. 2001, we broke extensions by removing checks for NULLpointers, failing to properly initialize stack and heap variables, dereferencing auserlevel pointer, and freeing a resource multiple times. Nooks automaticallydetected and recovered from all such failures.4.2.5 Latent Bugs. Nooks revealed several latent bugs in existing kernel extensions. For example, it discovered a bug in the 3COM 3c90x Ethernet driverthat occurs during its initialization. If the driver fails to detect the card inthe system, it immediately frees a large buffer. Later, when the driver is unloaded, it zeroes this buffer. Nooks caught this bug because it write protectedthe memory when it was freed. Nooks also discovered a bug in another extension, kHTTPd van de Ven 1999, where an already freed object was referenced.In general, we found that Nooks could be a useful kernel development tool thatprovides a fast restart whenever an extension under development fails.4.3 Summary of Synthetic Reliability ExperimentsNooks eliminated 99 of the system crashes that occurred with native Linux.The remaining failures directly reflect our bestefforts principle and are thecost, in terms of reliability, of an approach that imposes reliability on legacyACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  99Table IV. The Relative Performance of Nooks Compared to Native Linux for Six Benchmark TestsCPU utilization is accurate to only a few percent. Relative performance is determined either bycomparing latency Playmp3, Compilelocal or throughput Sendstream, Receivestream,Servesimplewebpage, Servecomplexwebpage. The data reflects the average of three trialswith a standard deviation of less than 2.XPC Nooks Native Nooksrate relative CPU CPUBenchmark Extension per second perf.  util.  util. Playmp3 sb 150 100 4.8 4.6Receivestream e1000 receiver 10,961 97 39.7 57.8Sendstream e1000 sender 58,373 97 38.8 81.8Compilelocal VFAT 26,979 89 88.7 88.1Servesimple kHTTPd 61,183 44 96.6 96.8webpage serverServecomplex e1000 1,960 97 90.5 92.6webpage serverextension and operating systems code. In addition to crashes, Nooks can recoverfrom many nonfatal extension failures. While Nooks cannot detect many kindsof erroneous behavior, it can trap extension exceptions and initiate recoveryin many cases. Overall, Nooks eliminated 55 of nonfatal extension failurescaused by our fault injection trials. Finally, Nooks detected and recovered fromall of the commonly occurring faults that we injected by hand.5. PERFORMANCEThis section presents benchmark results that evaluate the performance cost ofthe Nooks isolation services. Our experiments used existing benchmarks andtools to compare the performance of a system using Nooks to one that doesnot. Our test machine is a Dell 1.7GHz Pentium 4 PC running Linux 2.4.18.The machine includes 890 MB of RAM, a SoundBlaster 16 sound card, an IntelPro1000gigabit Ethernet adapter, and a single 7200rpm, 41GB IDE harddisk drive. Our network tests used two similarly equipped machines we donot report performance information for the slower network adapters to avoidunfairly biasing the results in favor of Nooks. Unlike the reliability tests described previously, all performance tests were run on a bare machine, that is,one without the VMware virtualization system.Table IV summarizes the benchmarks used to evaluate system performance.For each benchmark, we used Nooks to isolate a single extension, indicatedin the second column of the table. We ran each benchmark on native Linuxwithout Nooks and then again on a version of Linux with Nooks enabled. Thetable shows the relative change in performance for Nooks, either in wall clocktime or throughput, depending on the benchmark. We also show CPU utilizationmeasured during benchmark execution, as well as the rate of XPCs per secondincurred during each test. The table shows that Nooks achieves between 44and 100 of the performance of native Linux for these tests.As the isolation services are primarily imposed at the point of the XPC, therate of XPCs offers a telling performance indicator. Thus, the benchmarks fallinto three broad categories characterized by the rate of XPCs low frequencyACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.100  M. M. Swift et al.a few hundred XPCs per second, moderate frequency a few thousand XPCsper second, and high frequency tens of thousands of XPCs per second. Wenow look at each benchmark in turn.5.1 Sound BenchmarkThe Playmp3 benchmark plays an MP3 file at 128 kbs through the systemssound card, generating only 150 XPCs per second. At this low rate, the additional XPC overhead of Nooks is imperceptible, both in terms of execution timeand CPU overhead. For the many lowbandwidth devices in a system, suchas keyboards, mice, Bluetooth devices Haarsten 2000, modems, and soundcards, Nooks offers a clear benefit by improving driver reliability with almostno performance cost.5.2 Network BenchmarksThe Receivestream benchmark is an example of a moderate XPCfrequencytest. Receivestream was measured with the netperf Jones 1995 performancetool, where the receiving node used an isolated Ethernet driver to receive astream of 32kB TCP messages using a 256kB buffer. The Ethernet driverfor the Intel Pro1000 card batches incoming packets to reduce interruptand, hence, XPC frequency. Nevertheless, the receiver performs XPCs in theinterrupthandling code, which is on the critical path for packet delivery. Thisresults in a throughput reduction of about 3 and an overall CPU utilizationincrease of 18 percentage points.In contrast, Sendstream also measured using netperf is a high XPCfrequency test that isolates the sending nodes Ethernet driver. Unlike theReceivestream test, which benefits from the batching of received packets, theOS does not batch outgoing packets that it sends. Therefore, although the total amount of data transmitted is the same, Sendstream executes nearly anorder of magnitude more XPCs per second than Receivestream. The overallCPU utilization on the sender thus increases from about 39 on native Linuxto 81 with Nooks. As with the Receivestream benchmark, throughput dropsby about 3. Despite the higher XPC rate, much of the XPC processing on thesender is overlapped with the actual sending of packets, mitigating some of theNooks overhead. Nevertheless, on slower processors or faster networks, it maybe worthwhile to batch outgoing streaming packets, as is done, for example,with network terminal protocols Gettys et al. 1990.5.3 Compile BenchmarkOur isolated file system offers the opportunity to explore more deeply some ofthe performance implications of the Nooks architecture and its implementation.Table IV shows that the time to untar and compile the Linux kernel on a localVFAT file system is about 10 greater under Nooks than under native Linux.As the CPU was equally utilized during execution in both cases, we concludethat the slowdown has two possible causes. There is more code to run with Nooksthan without, and code common to both implementations runs more slowly withNooks.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  101Fig. 8. Comparative times spent in kernel mode for the Compilelocal VFAT benchmark. Duringthe run with Nooks, the system performed 10,934,567 XPCs into the kernel and 4,0086,586 XPCsinto the extension. Time in user mode not shown was identical for both configurations 477 s.To understand these causes better, we profiled and measured the compilelocal benchmark running on both native Linux and Linux with Nooks. Theresults are shown in Figure 8. Time spent running application code is not shown,as it was identical for both configurations about 477 s. In contrast, the figureshows that the time spent executing kernel code was significantly different forthe two configurations 39 s for native, and 111 s for Nooks.The upper bars in the figure show that more code about 46 s worth executedwith Nooks than without. XPC functionality accounted for more than half of theadditional overhead. After XPC, the graph shows that object tracking incurreda significant cost about 6 s. The remaining components wrappers, page tablesynchronization, and data copying incurred only a minor overhead. At a highlevel, the figure illustrates the cost of isolation and recovery in a protected system. The isolation costs manifest themselves in terms of XPC overhead, pagetable synchronization, and data copying. The recovery costs are reflected interms of the object tracking that occurs every time a pointer is passed in an XPC.Recall that object tracking allows Nooks to correctly recover kernel resourcesin the event of an extension failure. These measurements demonstrate that enabling recovery can have a substantial cost. Conversely, they demonstrate thatfast interprocess communication IPC is only part of the performance equationin an environment where recovery is as important as isolation Bershad 1992.In addition to showing that there is more code to run under Nooks, the lowerbars in Figure 8 show that code common to both systems runs more slowly withNooks. For native Linux, about 4.4 s were spent in VFAT code, and another35 s were spent in the rest of the kernel. In contrast, Nooks spent 12 s in VFAT,and 40 s in the rest of the kernel. Because the code in VFAT and the rest of thekernel is almost identical, the difference was likely due to the increased memorypressure caused by Nooks. For example, the domain change that occurs as partof an XPC requires a complete flush of the processors TLB on the Pentium.The Pentium 4 performance counters allowed us to measure the number ofkernel data TLB and kernel data cache misses per instruction for this workload.With Nooks, the kernel TLB misses per instruction increased almost threefold.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.102  M. M. Swift et al.In contrast, the data cache misses per instruction changed relatively little.Consequently, it is the TLB, not the cache, that makes kernel code run moreslowly under Nooks. To confirm this, we built a special version of Nooks thatdoes not require a TLB flush on each XPC as extensions and the kernel run in asingle domain. This version allows us to directly observe the impact of the TLB,but of course provides no protection and is therefore useful only for evaluatingperformance. Eliminating the flush not surprisingly decreased the time spentin the Nooks code from 46 s to 23 s. Furthermore, the XPC time dropped from28 s to 7 s. The number of data TLB misses per instruction was only 16 greaterthan native Linux. This suggests that optimizations to reduce the number ofTLB misses, such as superpages, may be important in future versions of thesystem. Furthermore, processor support for tagging TLB entries would removethe need to flush, eliminating many of these misses.5.4 Web Server BenchmarksThe final two benchmarks illustrate the impact on server performance of transactional workloads. Servesimplewebpage uses a high XPCfrequency extension kHTTPd on the server to deliver static content cached in memory. Weused httperf Mosberger and Jin 1998 to generate a workload that repeatedlyrequested a single kilobytesized Web page. kHTTPd on native Linux can serveover 15,000 pages per second. With Nooks, it can serve about 6,000, representing a 60 decrease in throughput.Two elements of the benchmarks behavior conspire to produce such poorperformance. First, the kHTTPd server processor is the system bottleneck. Forexample, when run natively, the servers CPU utilization is nearly 96. Consequently, the high XPC rate slows the server substantially. Second, since theworkload is transactional and nonbuffered, the clients request rate drops asa function of the servers slowdown. By comparison, the Sendstream benchmark, which exhibits roughly the same rate of XPCs but without saturatingthe CPU, degrades by only 10. In addition, Sendstream is not transactional,so network buffering helps to mask the serverside slowdown.Nevertheless, it is clear that kHTTPd represents a poor application of Nooksit is already a bottleneck and performs many XPCs. This service was cast as anextension so that it could access kernel resources directly, rather than indirectlythrough the standard system call interface. Since Nooks isolation facilitiesimpose a penalty on those accesses, performance suffers. We believe that othertypes of extensions, such as virus and intrusion detectors, which are placed inthe kernel to access or protect resources otherwise unavailable from user level,would make better candidates as they do not represent system bottlenecks.In contrast to kHTTPd, the second Web server test Servecomplexwebpagereflects moderate XPC frequency. Here, we ran the SPECweb99 workload Standard Performance Evaluation Corporation 1999 against the usermode Apache2.0 Web Server Apache Project 2000, with and without Nooks isolation of theEthernet driver. This workload includes a mix of static and dynamic Web pages.The test configuration is throughput limited due to its single IDE disk drive.When running without Nooks, the Web server handled a peak of 114 requestsACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  103per second. With Nooks installed and the Ethernet driver isolated on the server,peak throughput dropped by about 3, to 110 requests per second.5.5 SummaryThis section used a small set of benchmarks to quantify the performance costof Nooks. For the sound and Ethernet drivers tested, Nooks imposed a performance penalty of less than 5. For kHTTPd, an ad hoc application extension,the penalty was nearly 60. A key factor in the performance impact is thenumber of XPCs required, as XPCs impose a burden, particularly on the x86TLB in our current implementation. The performance costs of Nooks isolationservices depend as well on the CPU utilization imposed by the workload. If theCPU is saturated, the additional cost can be significant.Overall, Nooks provides a substantial reliability improvement at a cost thatdepends on the extension being isolated. The reliabilityperformance tradeoffis thus one that can be made on a casebycase basis. For many computingenvironments, given the performance of modern systems, we believe that thebenefits of Nooks isolation and recovery services are well worth the costs.6. RELATED WORKOur work differs from the substantial body of research on extensibility andreliability in many dimensions. Nooks relies on a conventional processor architecture, a conventional programming language, a conventional operatingsystem architecture, and existing extensions. It is designed to be transparentto the extensions themselves, to support recoverability, and to impose only amodest performance penalty.6.1 Hardware Support for ModularityThe major hardware approaches to improve reliability include capabilitybasedarchitectures Houdek et al. 1981 Organick 1983 Levy 1984 and ring and segment architectures Intel Corporation 2002 Saltzer 1974.Witchel et al. 2002presented a similar approach in a newer context. These systems support finegrained protection, enabling construction and isolation of privileged subsystems. The OS is extended by adding new privileged subsystems that exist innew domains or segments. Recovery is not specifically addressed in either architecture. In particular, capabilities support the finegrained sharing of data.If one sharing component fails, recovery may be difficult for others sharing thesame resource. Segmented architectures have been difficult to program andplagued by poor performance. In contrast, Nooks isolates existing code on commodity processors using standard virtual memory and runtime techniques, andit supports recovery through garbage collection of extensionallocated data.6.2 Operating System Support for Isolation and RecoverySeveral projects have isolated kernel components through new operating system structures. Microkernels Wulf 1975 Liedtke 1995 Young et al. 1986 andtheir derivatives Engler et al. 1995 Ford et al. 1997 Hand 1999 promise another path to reliability. These systems isolate extensions into separate addressACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.104  M. M. Swift et al.spaces that interact with the OS through a kernel communication service, suchas messages or remote procedure call Bershad et al. 1990. Therefore, thefailure of an extension within an address space does not necessarily crash thesystem. However, as in capabilitybased systems, recovery has received littleattention in microkernel systems. In Mach, for example, a userlevel systemservice can fail without crashing the kernel, but rebooting is often the onlyway to restart the service. Despite much research in fast interprocess communication IPC Bershad et al. 1990 Liedtke 1995, the reliance on separateaddress spaces raises performance concerns that have prevented adoption incommodity systems. Microkernelmonolithic hybrids, such as L4Linux Hartiget al. 1997, provide much of the isolation support needed for reliability, but aremore difficult to integrate into existing code bases.In the past, virtual memory techniques have been used to isolate specificcomponents or data from corruption, for example, in a database Sullivan andStonebraker 1991 or in the file system cache Ng and Chen 1999. Nooks usessimilar techniques to protect the operating system from erroneous extensionbehavior.Virtual machine technologies Chapin et al. 1995 Chen and Noble 2001Sugerman et al. 2001 Whitaker et al. 2002 have been proposed as a solutionto the reliability problem. They can reduce the amount of code that can crash thewhole machine. Virtualization techniques typically run several entire operatingsystems on top of a virtual machine, so faulty extensions in one operating systemcause only a few applications to fail. However, if the extension executes in thevirtual machine monitor, such as device drivers for physical devices, a faultcauses all virtual machines and their applications to fail. While applicationscan be partitioned among virtual machines to limit the scope of failure, doingso removes the benefits of sharing within an operating system, such as fastIPC and intelligent scheduling. The challenge for reliable extensibility is notin virtualizing the underlying hardware rather it lies in virtualizing only theinterface between the kernel and extension. In fact, this is a major feature ofthe Nooks architecture.A number of transactionbased systems Schmuck and Wylie 1991 Seltzeret al. 1996 have applied recoverable database techniques within the OS to improve reliability. In some cases, such as the file system, the approach workedwell, while in others it proved awkward and slow Schmuck and Wylie 1991.Like the languagebased approaches, these strategies have limited applicability. In contrast, Nooks integrates transparently into existing hardware andoperating systems.6.3 Compiler and Language Support for ReliabilityAn alternative to operating systembased isolation is the use of typesafe programming languages and runtime systems Bershad et al. 1995 that preventmany faults from occurring. Such systems can provide performance advantages,since compiletime checking enables lightweight runtime structures e.g., local procedure calls rather than crossdomain calls. To date, however, OS suppliers have been unwilling to implement system code in typesafe, highlevelACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  105languages. Moreover, the typesafe language approach makes it impossible toleverage the enormous existing code base. In contrast, Nooks requires no specialized programming language.Recent years have seen the development of software techniques that enforcecode correctness properties, for example, software fault isolation Wahbe et al.1993 and selfverifying assembly code Necula and Lee 1996. These technologies are attractive and might replace or augment some of Nooks isolation techniques. Nevertheless, in their proposed form, they deal only with the isolationproblem, leaving unsolved the problems of transparent integration and recovery. Recently, techniques for verifying the integrity of extensions in existing operating systems have proven effective at revealing programming errors Engleret al. 2000 DeLine and Fahndrich 2001 Ball and Rajamani 2001 Condit et al.2003. This static approach obviously complements our own dynamic one.The Devil project Merillon et al. 2000 takes a different approach, ensuringthat drivers interact with devices correctly. In Devil, a device vendor specifiesthe devicesoftware interface in a domainspecific language. The Devil compilerthen uses that specification to generate an API i.e., Clanguage stubs for thedevice. Driver writers call these functions to access the device. Devil removesmany of the bugs associated with drivers by abstracting away the complexitiesof communicating through IO ports and memorymapped device registers. Thisapproach is complementary to Nooks, in that it removes many of the bugs indrivers, but requires writing new drivers to use the generated interface.6.4 RecoveryMore recently, researchers have begun to focus on recovery as a general technique for dealing with failure in complex systems Patterson et al. 2002. Forexample, Candea Candea and Fox 2001 proposes a model of recursive recovery in the model a complex software system is decomposed into a multilevelimplementation where each layer can fail and recover independently. Nooksis complementary, although our focus to date has been limited to restartingportions of operating system kernels.Other systems have focused on recovery from faults in existing code, such asdiscount checking Lowell and Chen 1998 Lowell et al. 2000. Discount checking recovers from faults in userlevel programs automatically by snapshottingstate periodically, and reverting back to a previous snapshot following a failure.Nooks, in contrast, complete restarts failed kernel extensions. Wrappers havebeen used for reliability and recovery in other systems. Fabre et al. 2000 andthe HEALERS project Fetzer and Xiao 2003 use wrappers similar to Nooksaround existing code to both tolerate and recover from faults automatically.These wrappers can verify pre and postconditions, catch exceptions, and retryfunction calls after a failure. Unlike Nooks, these systems do not incorporatememory isolation and hence do not prevent accidental memory corruption.Table V shows the changes to hardware architecture, operating system architecture, or extension architecture required by previous approaches to reliability. Only Nooks, virtual machines, and static analysis techniques need noarchitectural changes.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.106  M. M. Swift et al.Table V. Components That Require Architectural Changes for Various Approaches toReliability A yes in a cell indicates that the reliability mechanism on that row requiresarchitectural change to the component listed at the top of the column.Required modificationsApproach Hardware OS ExtensionCapabilities yes yes yesMicrokernels no yes yesLanguages no yes yesNew Driver no yes yesArchitecturesTransactions no no yesVirtual machines no no noStatic analysis no no noNooks no no noIn summary, Nooks brings to commodity operating systems the wellknownrequirements for fault toleratant operating systems Denning 1976 isolation,resource control, decision verification checking, and error recovery. Nooks provides these features for extensions in a way that is compatible and transparentto most existing code.7. CONCLUSIONSKernel extensions are a major source of failure in modern operating systems.Nooks is a new reliability layer intended to significantly reduce extensionrelated failures. Nooks uses hardware and software techniques to isolate kernelextensions, trapping many common faults and permitting extension recovery.The Nooks system focuses on achieving backward compatibility, that is, it sacrifices complete isolation and fault tolerance for compatibility and transparencywith existing kernels and extensions. Nevertheless, Nooks demonstrates thatit is possible to realize an extremely high level of operating system reliabilitywith a performance loss ranging from zero to just over 60. Our faultinjectionexperiments reveal that Nooks recovered from 99 of the faults that causednative Linux to crash.Our experience shows that 1 implementation of a Nooks layer is achievablewith only modest engineering effort, even on a monolithic operating systemlike Linux, 2 extensions such as device drivers can be isolated with little orno change to extension code, and 3 isolation and recovery can dramaticallyimprove the systems ability to survive extension faults.Overall, our experiments demonstrate that Nooks defines a new point in thereliabilityperformance space beyond simple kernel mode and user mode. Intodays world, nearly all extensions run in the kernel and are potential threatsto reliability. Nooks offers kernel developers a substantial degree of reliabilitywith a cost ranging from negligible to significant. The decision to isolate a kernelextension should be made in light of that extensions native reliance on kernelservices, its bottleneck potential, and the environment in which it will be used.Clearly, for many device drivers and low XPCfrequency extensions, the decision is easy. For others, it is a question of requirements. Where performanceACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  107matters more than reliability, isolation may not be appropriate. However, giventhe impressive performance of current processors and the enormous rate atwhich performance is increasing, many devices are in the easy decision category today, and more will join that category with each passing year.ACKNOWLEDGMENTSWe appreciate the efforts of Steve Martin and Doug Buxton for their helpin developing the wrappergenerating tool and testing Nooks, Leo Shum foradding sound card support, and Christophe Augier for his work on the recoveryagent and on reliability testing. We would like to thank Intel and Microsoft forinformation on their respective products. We would also like to thank FransKaashoek and the many anonymous referees for their suggestions which haveimproved the content and presentation of the article.REFERENCESAPACHE PROJECT. 2000. Apache HTTP server version 2.0. Available online at httphttpd.apache.org.BALL, T. AND RAJAMANI, S. K. 2001. Automatically validating temporal safety properties of interfaces. In SPIN 2001, Workshop on Model Checking of Software. Lecturer Notes in ComputerScience, vol. 2057. SpringerVerlag, Berlin, Germany, 103122.BERSHAD, B. N. 1992. The increasing irrelevance of IPC performance for microkernelbased operating systems. In Proceedings of Workshop on MicroKernels and Other Kernel ArchitecturesSeattle, WA. 205211.BERSHAD, B. N., ANDERSON, T. E., LAZOWSKA, E. D., AND LEVY, H. M. 1990. Lightweight remoteprocedure call. ACM Trans. Comput. Syst. 8, 1 Feb., 3755.BERSHAD, B. N., SAVAGE, S., PARDYAK, P., SIRER, E. G., FIUCZYNSKI, M. E., BECKER, D., CHAMBERS, C.,AND EGGERS, S. 1995. Extensibility, safety and performance in the SPIN operating system. InProceedings of the 15th ACM Symposium on Operating Systems Principles Copper Mountain,CO. 267284.BIRRELL, A. D. AND NELSON, B. J. 1984. Implementing remote procedure calls. ACM Trans. Comput.Syst. 2, 1 Feb., 3959.BOVET, D. P. AND CESATI, M. 2001. Understanding the Linux Kernel. OReilly, Sebastopal, CA.CANDEA, G. AND FOX, A. 2001. Recursive restartability Turning the reboot sledgehammer into ascalpel. In Proceedings of the Eighth IEEE HOTOS. 125132.CHAPIN, J., ROSENBLUM, M., DEVINE, S., LAHIRI, T., TEODOSIU, D., AND GUPTA, A. 1995. Hive Faultcontainment for sharedmemory multiprocessors. In Proceedings of the 15th ACM Symposiumon Operating Systems Principles Copper Mountain Resort, CO. 1225.CHASE, J. S., LEVY, H. M., FEELEY, M. J., AND LAZOWSKA, E. D. 1994. Sharing and protection in asingleaddressspace operating system. ACM Trans. Comput. Syst. 12, 4 Nov., 271307.CHEN, P. AND NOBLE, B. 2001. When virtual is better than real. In Proceedings of the Eighth IEEEHOTOS. 133138.CHOU, A., YANG, J., CHELF, B., HALLEM, S., AND ENGLER, D. 2001. An empirical study of operatingsystem errors. In Proceedings of the 18th ACM Symposium on Operating Systems PrinciplesLake Louise, Alta., Canada. 7388.CHRISTMANSSON, J. AND CHILLAREGE, R. 1996. Generation of an error set that emulates softwarefaultsbased on field data. In Proceedings of the 1996 IEEE Symposium on FaultTolerantComputing FTCS, Sendai, Japan. 304  313.CONDIT, J., HARREN, M., MCPEAK, S., NECULA, G. C., AND WEIMER, W. 2003. CCured in the real world.In Proceedings of the ACM SIGPLAN 03 ACM Conference on Programming Language Designand Implementation San Diego, CA. 232244.CUSTER, H. 1993. Inside Windows NT. Microsoft Press, Redmond, WA.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.108  M. M. Swift et al.DELINE, R. AND FAHNDRICH, M. 2001. Enforcing highlevel protocols in lowlevel software. In Proceedings of the ACM SIGPLAN 01 ACM Conference on Programming Language Design andImplementation Snowbird, UT. 5969.DENNING, P. J. 1976. Fault tolerant operating systems. ACM Comput. Surv. 8, 4 Dec., 359389.DENNIS, J. B. AND HORN, E. V. 1966. Programming semantics for multiprogramming systems.Commun. ACM 9, 3 Mar., 2935.ENGLER, D., CHELF, B., CHOU, A., AND HALLEM, S. 2000. Checking system rules using systemspecific, programmerwritten compiler extensions. In Proceedings of the 4th USENIX Symposiumon Operating Systems Design and Implementation San Diego, CA. 116.ENGLER, D. R., KAASHOEK, M. F., AND JR., J. O. 1995. Exokernel An operating system architecture for applicationlevel resource management. In Proceedings of the 15th ACM Symposium onOperating Systems Principles Copper Mountain Resort, CO. 251266.FABRE, J.C., RODRI, M., ARLAT, J., SALLES, F., AND SIZUN, J.M. 2000. Building dependable COTSmicrokernelbased systems using MAFALDA. In Proceedings of the 2000 Pacific Rim International Symposium on Dependable Computing PRDC 00 Los Angeles, CA. 8594.FABRY, R. S. 1974. Capabilitybased addressing. Commun. ACM 17, 7 July, 403412.FETZER, C. AND XIAO, Z. 2003. HEALERS A toolkit for enhancing the robustness and security ofexisting applications. In Proceedings of the 2003 International Conference on Dependable Systemsand Networks DSN03, San Francisco, CA. 317322.FORD, B., BACK, G., BENSON, G., LEPREAU, J., LIN, A., AND SHIVERS, O. 1997. The Flux OSKit Asubstrate for OS language and research. In Proceedings of the 16th ACM Symposium on OperatingSystems Principles. 3851.FORIN, A., GOLUB, D., AND BERSHAD, B. 1991. An IO system for Mach. In Proceedings of the UsenixMach Symposium. 163176.GETTYS, J., CARLTON, P. L., AND MCGREGOR, S. 1990. The X window system, version 11. Softw.Prac.Exp. 20, 52 Oct., 3567.GILLEN, A., KUSNETZKY, D., AND MCLARON, S. 2002. The role of Linux in reducing the cost of enterprise computing. IDC white paper. International Data Corporation, Framingham, MA.GOSLING, J., JOY, B., AND STEELE, G. 1996. The Java Language Specification. AddisonWesley,Reading, MA.GRAY, J. 1996. Why do computers stop and what can be done about it In Proceedings of the FifthIEEE Symposium on Reliability in Distributed Software and Database Systems Los Angeles,CA. 312.HAARSTEN, J. C. 2000. The Bluetooth radio system. IEEE Personal Commun. Mag. 7, 1 Feb.,2836.HAND, S. M. 1999. Selfpaging in the Nemesis operating system. In Proceedings of the 3rdUSENIX Symposium on Operating Systems Design and Implementation New Orleans, LA.7386.HARTIG, H., HOHMUTH, M., LIEDTKE, J., SCHOBERG, S., AND WOLTER, J. 1997. The performance ofkernelbased systems. In Proceedings of the 16th ACM Symposium on Operating Systems Principles SaintMalo, France. 6677.HEWLETT PACKARD. 2001. Hewlett Packard Digital Entertainment Center. Go online to httpwww.hp.comhpinfonewsroompress31oct01a.htm.HOUDEK, M. E., SOLTIS, F. G., AND HOFFMAN, R. L. 1981. IBM System38 support for capabilitybased addressing. In Proceedings of the 8th ACMIEEE International Symposium on ComputerArchitecture. 341348.HSUEH, M., TSAI, T. K., AND IYER, R. K. 1997. Fault injection techniques and tools. IEEE Comput. 30, 4 Apr., 7582.INTEL CORPORATION. 2002. The IA32 Architecture Software Developers Manual, Volume 1 BasicArchitecture. Intel Corporation, Santa Clara, CA. Available online at httpwww.intel.comdesignpentium4manuals24547010.pdf.JONES, R. 1995. Netperf A network performance benchmark, version 2.1. Available online athttpwww.netperf.org.KOLDINGER, E. J., CHASE, J. S., AND EGGERS, S. J. 1994. Architectural support for single addressspace operating systems. In Proceedings of the Fifth International Conference on ArchitecturalSupport for Programming Languages and Operating Systems. 175186.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.Improving Reliability of Commodity Operating Systems  109LEVY, H. M. 1984. CapabilityBased Computer Systems. Digital Press, Burlington, MA. Availableonline at httpwww.cs.washington.eduhomeslevycapabook.LIEDTKE, J. 1995. On kernel construction. In Proceedings of the 15th ACM Symposium onOperating Systems Principles Copper Mountain Resort, CO. 237250.LOWELL, D. E., CHANDRA, S., AND CHEN, P. M. 2000. Exploring failure transparency and the limitsof generic recovery. In Proceedings of the 4th USENIX Symposium on Operating Systems Designand Implementation San Diego, CA. 289303.LOWELL, D. E. AND CHEN, P. M. 1998. Discount checking Transparent, lowoverhead recovery forgeneral applications. Tech. Rep. CSETR41099. University of Michigan, Axn Arbor, MI.MERILLON, F., REVEILLERE, L., CONSEL, C., MARLET, R., AND MULLER, G. 2000. Devil An IDL forhardware programming. In Proceedings of the 4th USENIX Symposium on Operating SystemsDesign and Implementation San Diego, CA. 1730.MICROSOFT CORPORATION. 2000. FAT General overview of ondisk format, version 1.03. MicrosoftCorporation, Redmond, WA.MOSBERGER, D. AND JIN, T. 1998. httperf A tool for measuring web server performance. In FirstACM Workshop on Internet Server Performance Madison, WI. 5967.NECULA, G. C. AND LEE, P. 1996. Safe kernel extensions without runtime checking. In Proceedingsof the 2nd USENIX Symposium on Operating Systems Design and Implementation Seattle, WA.229243.NG, W. T. AND CHEN, P. M. 1999. The systematic improvement of fault tolerance in the Riofile cache. In Proceedings of the 1999 IEEE Symposium on FaultTolerant Computing FTCS.7683.ORGANICK, E. I. 1983. A Programmers View of the Intel 432 System. McGraw Hill, New York, NY.PATTERSON, D., BROWN, A., BROADWELL, P., CANDEA, G., CHEN, M., CUTLER, J., ENRIQUEZ, P., FOX,A., KYCYMAN, E., MERZBACHER, M., OPPENHEIMER, D., SASTRY, N., TETZLAFF, W., TRAUPMAN, J.,AND TREUHAFT, N. 2002. Recoveryoriented computing ROC Motivation, definition, techniques, and case studies. Tech. Rep. CSD021175. UC Berkeley Computer Science. Berkely,CA.PROJECTUDI. 1999. Introduction to UDI version 1.0. Tech. rep. Project UDI. Visit Websitewww.projectudi.org.SALTZER, J. H. 1974. Protection and the control of information sharing in Multics. Commun.ACM 17, 7 July, 388402.SCHMUCK, F. AND WYLIE, J. 1991. Experience with transactions in QuickSilver. In Proceedings ofthe 13th ACM Symposium on Operating Systems Principles Pacific Grove, CA. 239253.SELTZER, M. I., ENDO, Y., SMALL, C., AND SMITH, K. A. 1996. Dealing with disaster Survivingmisbehaved kernel extensions. In Proceedings of the 2nd USENIX Symposium on OperatingSystems Design and Implementation Seattle, WA. 213227.SHORT, R. 2003. Vice president of Windows Core Technology, Microsoft Corp. Private communication.STANDARD PERFORMANCE EVALUATION CORPORATION. 1999. The SPECweb99 benchmark. StandardPerformance Evaluation Corporation, Warrenton, VA. Visit Web site www.Apec.org.SUGERMAN, J., VENKITACHALAM, G., AND LIM, B. 2001. Virtualizing IO devices on VMware workstations hosted virtual machine monitor. In Proceedings of the 2001 USENIX Annual TechnicalConference Boston, MA.SULLIVAN, M. AND CHILLAREGE, R. 1991. Software defects and their impact on system availabilitya study of field failures in operating systems. In Proceedings of the 1991 IEEE Symposium onFaultTolerant Computing FTCS21. Montreal, P. Q., Canada. 29.SULLIVAN, M. AND STONEBRAKER, M. 1991. Using write protected data structures to improve software fault tolerance in highly available database management systems. In Proceedings of the 17thInternational Conference on Very Large Data Bases. Morgan Kaufman Publishing, San Francisco,CA, 171180.THURROTT, P. 2003. Windows 2000 server The road to gold, part two Developing windows. PaulThurrotts SuperSite for Windows.TIVO CORPORATION. 2001. TiVo digital video recorder. Go to www.tivo.com.VAN DE VEN, A. 1999. kHTTPd Linux HTTP accelerator. Available online at httpwww.fenrus.demon.nl.ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.110  M. M. Swift et al.WAHBE, R., LUCCO, S., ANDERSON, T. E., AND GRAHAM, S. L. 1993. Efficient softwarebased faultisolation. In Proceedings of the 14th ACM Symposium on Operating Systems Principles Asheville,NC. 203216.WHEELER, D. A. 2002. More than a gigabuck Estimating GNULinuxs size. Available online athttpwww.dwheeler.comslocredhat71v1redhat71sloc.html.WHITAKER, A., SHAW, M., AND GRIBBLE, S. D. 2002. Denali Lightweight virtual machines for distributed and networked applications. In Proceedings of the 5th USENIX Symposium on OperatingSystems Design and Implementation Boston, MA. 195209.WITCHEL, E., CATES, J., AND ASANOVIC, K. 2002. Mondrian memory protection. In Proceedings ofthe Tenth International Conference on Architectural Support for Programming Languages andOperating Systems. 304316.WULF, W. A. 1975. Reliatble hardwaresoftware architecture. In Proceedings of the InternationalConference on Reliable Software Los Angeles, CA. 122130.YOUNG, M., ACCETTA, M., BARON, R., BOLOSKY, W., GOLUB, D., RASHID, R., AND TEVANIAN, A. 1986.Mach A new kernel foundation for UNIX development. In Proceedings of the 1986 SummerUSENIX Conference Atlanta, GA. 93113.Received October 2003 revised May 2004, September 2004 accepted June 2004ACM Transactions on Computer Systems, Vol. 23, No. 1, February 2005.
