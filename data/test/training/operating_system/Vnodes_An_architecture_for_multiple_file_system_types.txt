Vnodes An Architecture for Multiple File System Types in Sun UNIXS.R. KleimanSun Microsystemssunsrk1. IntroductionThis paper describes an architecture for accommodating multiple file system implementations within theSun UNIX kernel. The file system implementations can encompass local, remote, or even nonUNIX filesystems. These file systems can be plugged into the kernel through a well defined interface, much thesame way as UNIX device drivers are currently added to the kernel.2. Design GoalsSplit the file system implementation independent and the file system implementation dependentfunctionality of the kernel and provide a well defined interface between the two parts.The interface must support but not require UNIX file system access semantics. In particular it mustsupport local disk file systems such as the 4.2BSD file system1, stateless remote file systems such asSuns NFS2, statefull remote file systems such as ATTs RFS, or nonUNIX file systems such as theMSDOS file system3.The interface must be usable by the server side of a remote file system to satisfy client requests.All file system operations should be atomic. In other words, the set of interface operations should be ata high enough level so that there is no need for locking hard locking, not user advisory locking acrossseveral operations. Locking, if required, should be left up to the file system implementation dependentlayer. For example, if a relatively slow computer running a remote file system requires asupercomputer server to lock a file while it does several operations, the users of the supercomputerwould be noticeably affected. It is much better to give the file system dependent code full informationabout what operation is being done and let it decide what locking is necessary and practical.3. Implementation goals and techniquesThese implementation goals were necessary in order to make future implementation easier as the kernelevolved.There should be little or no performance degradation.The file system independent layer should not force static table sizes. Most of the new file system typesuse a dynamic storage allocator to create and destroy objects.Different file system implementations should not be forced to use centralized resources e.g inode table,mount table or buffer cache. However, sharing should be allowed.The interface should be reentrant. In other words, there should be no implicit references to global datae.g. u.ubase or any global side effect information passed between operations e.g. u.udent.This has the added benefit of cutting down the size of the per user global data area u area. In addition,all the interface operations return error codes as the return value. Overloaded return codes andu.uerror should not be used.The changes to the kernel should be implemented by an object oriented programming approach. Datastructures representing objects contain a pointer to a vector of generic operations on the object.Implementations of the object fill in the vector as appropriate. The complete interface to the object is UNIX is a trademark of ATT1 specified by its data structure and its generic operations. The object data structures also contain apointer to implementation specific data. This allows implementation specific information to be hiddenfrom the interface.Each interface operation is done on behalf of the current process. It is permissible for any interfaceoperation to put the current process to sleep in the course of performing its function.System CallsVnode Layer4.2BSD File SystemDiskPC File SystemFloppyNFS NFS ServerNetworkFigure 1. Vnode architecture block diagram4. OperationThe file system dependentindependent split was done just above the UNIX kernel inode layer. This was anobvious choice, as the inode was the main object for file manipulation in the kernel. A block diagram ofthe architecture is shown in Figure 1. The file system independent inode was renamed vnode virtualnode. All file manipulation is done with a vnode object. Similarly, file systems are manipulated throughan object called a vfs virtual file system. The vfs is the analog to the old mount table entry. The filesystem independent layer is generally referred to a the vnode layer. The file system implementationdependent layer is called by the file system type it implements e.g. 4.2BSD file system, NFS file system.Figure 2 shows the definition of the vnode and vfs objects.4.1 VfssEach mounted vfs is linked into a list of mounted file systems. The first file system on the list is always theroot. The private data pointer vfsdata in the vfs points to file system dependent data. In the 4.2BSDfile system, vfsdata points to a mount table entry. The public data in the vfs structure contains dataused by the vnode layer or data about the mounted file system that does not change.Since different file system implementations require different mount data, the mount2 system call waschanged. The arguments to mount2 now specify the file system type, the directory which is the mountpoint, generic flags e.g. read only, and a pointer to file system type specific data. When a mount system2 struct vfs struct vfs vfsnext  next vfs in list struct vfsops vfsop  operations on vfs struct vnode vfsvnodecovered  vnode we cover int vfsflag  flags int vfsbsize  native block size caddrt vfsdata  private data struct vfsops int vfsmountint vfsunmountint vfsrootint vfsstatfsint vfssyncint vfsfidint vfsvgetenum vtype  VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VBAD struct vnode ushort vflag  vnode flags ushort vcount  reference count ushort vshlockc   of shared locks ushort vexlockc   of exclusive locks struct vfs vvfsmountedhere  covering vfs struct vnodeops vop  vnode operations union struct socket vSocket  unix ipc struct stdata vStream  stream struct vfs vvfsp  vfs we are in enum vtype vtype  vnode type caddrt vdata  private data struct vnodeops int vnopenint vncloseint vnrdwrint vnioctlint vnselectint vngetattrint vnsetattrint vnaccessint vnlookupint vncreateint vnremoveint vnlinkint vnrenameint vnmkdirint vnrmdirint vnreaddirint vnsymlinkint vnreadlinkint vnfsyncint vninactiveint vnbmapint vnstrategyint vnbreadint vnbrelseFigure 2. Vfs and vnode objects3 call is performed, the vnode for the mount point is looked up see below and the vfsmount operationfor the file system type is called. If this succeeds, the file system is linked into the list of mounted filesystems, and the vfsvnodecovered field is set to point to the vnode for the mount point. This field isnull in the root vfs. The root vfs is always first in the list of mounted file systems.Once mounted, file systems are named by the path name of their mount points. Special device name are nolonger used because remote file systems do not necessarily have a unique local device associated withthem. Umount2 was changed to unmount2 which takes a path name for a file system mount pointinstead of a device.The root vnode for a mounted file system is obtained by the vfsroot operation, as opposed to alwaysreferencing the root vnode in the vfs structure. This allows the root vnode to be deallocated if the filesystem is not being referenced. For example, remote mount points can exist in embryonic form, whichcontains just enough information to actually contact the server and complete the remote mount when thefile system is referenced. These mount points can exist with minimal allocated resources when they are notbeing used.4.2 VnodesThe public data fields in each vnode either contain data that is manipulated only by the vfs layer or dataabout the file that does not change over the life of the file, such as the file type vtype. Each vnodecontains a reference count vcount which is maintained by the generic vnode macros VNHOLD andVNRELE. The vnode layer and file systems call these macros when vnode pointers are copied ordestroyed. When the last reference to a vnode is destroyed, the vninactive operation is called to tellthe vnodes file system that there are no more references. The file system may then destroy the vnode orcache it for later use. The vvfsp field in the vnode points to the vfs for the file system to which thevnode belongs. If a vnode is a mount point, the vvfsmountedhere field points to the vfs for anotherfile system. The private data pointer vdata in the vnode points to data that is dependent on the filesystem. In the 4.2BSD file system vdata points to an in core inode table entry.Vnodes are not locked by the vnode layer. All hard locking i.e. not user advisory locks is done within thefile system dependent layer. Locking could have been done in the vnode layer for synchronizationpurposes without violating the design goal however, it was found to be not necessary.4.3 An exampleFigure 3 shows an example vnode and vfs object interconnection. In figure 3, vnode1 is a file ordirectory in a 4.2BSD type file system. As such, its private data pointer points to an inode in the 4.2BSDfile systems inode table. Vnode1 belongs to vfs1, which is the root vfs, since it is the first on the vfslist rootvfs. Vfs1s private data pointer points to a mount table entry in the 4.2BSD file systemsmount table. Vnode2 is a directory in vfs1, which is the mount point for vfs2. Vfs2 is an NFSfile system, which contains vnode3.4.4 Path name traversalPath name traversal is done by the lookuppn routine lookup path name, which takes a path name in a pathname buffer and returns a pointer to the vnode which the path represents. This takes the place of the oldnamei routine.If the path name begins with a , Path name traversal starts at the vnode pointed to by either u.urdiror the root. Otherwise it starts at the vnode pointed to by u.ucdir the current directory. Lookuppntraverses the path one component at a time using the vnlookup vnode operation. Vnlookup takesa directory vnode and a component as arguments and returns a vnode representing that component. If adirectory vnode has vvfsmountedhere set, then it is a mount point. When a mount point isencountered going down the file system tree, lookuppn follows the vnodes vvfsmountedherepointer to the mounted file system and calls the vfsroot operation to obtain the root vnode for the filesystem. Path name traversal then continues from this point. If a root vnode is encountered VROOT flagin vflag set when following .., lookuppn follows the vfsvnodecovered pointer in the vnodesassociated vfs to obtain the covered vnode. If a symbolic link is encountered lookuppn calls the4 rootvfs vfsnextvfs1vfsvnodecoveredvfsdatavfsnextvfs2vfsvnodecoveredvfsdatavvfspvnode1vvfsmountedherevdatavvfspvnode2vvfsmountedherevdatavvfspvnode3vvfsmountedherevdatainode1 inode2 rnode1mount mntinfo4.2BSD File System NFSFigure 3. Example vnode layer object interconnection5 vnreadlink vnode operation to obtain the symbolic link. If the symbolic link begins with a , thepath name traversal is restarted from the root or u.urdir otherwise the traversal continues from thelast directory. The caller of lookuppn specifies whether the last component of the path name is to befollowed if it is a symbolic link. This process continues until the path name is exhausted or an error occurs.When lookuppn completes, a vnode representing the desired file is returned.4.5 Remote file systemsThe path name traversal scheme implies that files on remote file systems appear as files within the normalUNIX file name space. Remote files are not named by any special constructs that current programs dontunderstand4. The path name traversal process handles all indirection through mount points. This meansthat in a remote file system implementation, the client maintains its own mount points. If the client mountsanother file system on a remote directory, the remote file system will never see references below the newmount point. Also, the remote file system will not see any .. references at the root of the remote filesystem. For example, if the client has mounted a servers usr on his usr and a local file system onusrlocal then the path usrlocalbin will access the local root, the remote usr and the localusrlocal without the remote file system having any knowledge of the usrlocal mount point.Similarly, the path usr.. will access the local root, the remote usr and the local root, without theremote file system or the server seeing the .. out of usr.4.6 New system callsThree new system calls were added in order to make the normal application interface file systemimplementation independent. The getdirentries2 system call was added to read directories in a mannerwhich is independent of the on disk directory format. Getdirentries reads directory entries from an opendirectory file descriptor into a user buffer, in file system independent format. As many directory entries ascan fit in the buffer are read. The file pointer is is changed so that it points at directory entry boundariesafter each call to getdirentries. The statfs2 and fstatfs2 system calls were added to get general filesystem statistics e.g. space left. Statfs and fstatfs take a path name or a file descriptor, respectively, for afile within a particular file system, and return a statfs structure see below.4.7 DevicesThe device interfaces, bdevsw and cdevsw, are hidden from the vnode layer, so that devices are onlymanipulated through the vnode interface. A special device file system implementation, which is nevermounted, is provided to facilitate this. Thus, file systems which have a notion of associating a name withinthe file system with a local device may redirect vnodes to the special device file system.4.8 The buffer cacheThe buffer cache routines have been modified to act either as a physical buffer cache or a logical buffercache. A local file system typically uses the buffer cache as a cache of physical disk blocks. Other filesystem types may use the buffer cache as a cache of logical file blocks. Unique blocks are identified by thepair vnodepointer, blocknumber. The vnode pointer points to a device vnode when a cached block is acopy of a physical device block, or it points to a file vnode when the block is a copy of a logical file block.5. VFS operationsIn the following descriptions of the vfs operations the vfsp argument is a pointer to the vfs that theoperation is being applied to.vfsmountvfsp,pathp,datap Mount vfsp i.e. read the superblock etc.. Pathp points to the path nameto be mounted for recording purposes, and datap points to file systemdependent data.vfsunmountvfsp Unmount vfsp a.e. sync the superblock.vfsrootvfsp,vpp Return the root vnode for this file system. Vpp points to a pointer to avnode for the results.6 vfsstatfsvfsp,sbp Return file system information. Sbp points to a statfs structure for theresults.struct statfs long ftype  type of info long fbsize  block size long fblocks  total blocks long fbfree  free blocks long fbavail  nonsu blocks long ffiles  total  of nodes long fffree  free nodes in fs fsidt ffsid  file system id long fspare7  spare for later vfssyncvfsp Write out all cached information for vfsp. Note that this is not necessarilydone synchronously. When the operation returns all data has notnecessarily been written out, however it has been scheduled.vfsfidvfsp,vp,fidpp Get a unique file identifier for vp which represents a file within this filesystem. Fidpp points to a pointer to a fid structure for the results.struct fid ushort fidlen  length of data char fiddata1  variable size vfsvgetvfsp,vpp,fidp Turn unique file identifier fidp into a vnode representing the file associatedwith the file identifier. vpp points to a pointer to a vnode for the result.6. Vnode operationsIn the following descriptions of the vnode operations, the vp argument is a pointer to the vnode to whichthe operation is being applied the c argument is a pointer to a credentials structure which contains the usercredentials e.g. uid to use for the operation and the nm argument is a pointer to a character stringcontaining a name.vnopenvpp,f,c Perform any open protocol on a vnode pointed to by vpp e.g. devices. Ifthe open is a clone open the operation may return a new vnode. F is theopen flags.vnclosevp,f,c Perform any close protocol on a vnode e.g. devices. Called on theclosing of the last reference to the vnode from the file table, if vnode is adevice. Called on the last user close of a file descriptor, otherwise. F isthe open flags.vnrdwrvp,uiop,rw,f,c Read or write vnode. Reads or writes a number of bytes at a specifiedoffset in the file. Uiop points to a uio structure which supplies the IOarguments. Rw specifies the IO direction. F is the IO flags, which mayspecify that the IO is to be done synchronously i.e. dont return until allthe volatile data is on disk andor in a unit i.e. lock the file to write alarge unit.vnioctlvp,com,d,f,c Perform an ioctl on vnode vp. Com is the command, d is the pointer to thedata, and f is the open flags.vnselectvp,w,c Perform a select on vp. W specifies the IO direction.vngetattrvp,va,c Get attributes for vp. Va points to a vattr structure.7 struct vattr enum vtype vatype  vnode type ushort vamode  acc mode short vauid  owner uid short vagid  owner gid long vafsid  fs id long vanodeid  node  short vanlink   links ulong vasize  file size long vablocksize  block size struct timeval vaatime  last acc struct timeval vamtime  last mod struct timeval vactime  last chg devt vardev  dev long vablocks  space used This must map file system dependent attributes to UNIX file attributes.vnsetattrvp,va,c Set attributes for vp. Va points to a vattr structure, but only mode, uid, gid,file size, and times may be set. This must map UNIX file attributes to filesystem dependent attributes.vnaccessvp,m,c Check access permissions for vp. Returns error if access is denied. M isthe mode to check for access e.g. read, write, execute. This must mapUNIX file protection information to file system dependent protectioninformation.vnlookupvp,nm,vpp,c Lookup a component name nm in directory vp. Vpp points to a pointer to avnode for the results.vncreatevp,nm,va,e,m,vpp,c Create a new file nm in directory vp. Va points to an vattr structurecontaining the attributes of the new file. E is the exclusivenonexclusivecreate flag. M is the open mode. vpp points to a pointer to a vnode for theresults.vnremovevp,nm,c Remove a file nm in directory vp.vnlinkvp,tdvp,tnm,c Link the vnode vp to the target name tnm in the target directory tdvp.vnrenamevp,nm,tdvp,tnm,c Rename the file nm in directory vp to tnm in target directory tdvp. Thenode cant be lost if the system crashes in the middle of the operation.vnmkdirvp,nm,va,vpp,c Create directory nm in directory vp. Va points to an vattr structurecontaining the attributes of the new directory and vpp points to a pointer toa vnode for the results.vnrmdirvp,nm,c Remove the directory nm from directory vp.vnreaddirvp,uiop,c Read entries from directory vp. Uiop points to a uio structure whichsupplies the IO arguments. The uio offset is set to a file system dependentnumber which represents the logical offset in the directory when thereading is done. This is necessary because the number of bytes returnedby vnreaddir is not necessarily the number of bytes in the equivalent partof the on disk directory.vnsymlinkvp,lnm,va,tnm,c Symbolically link the path pointed to by tnm to the name lnm in directoryvp.vnreadlinkvp,uiop,c Read symbolic link vp. Uiop points to a uio structure which supplies theIO arguments.vnfsyncvp,c Write out all cached information for file vp. The operation is synchronousand does not return until the IO is complete.8 vninactivevp,c The vp is no longer referenced by the vnode layer. It may now bedeallocated.vnbmapvp,bn,vpp,bnp Map logical block number bn in file vp to physical block number andphysical device. Bnp is a pointer to a block number for the physical blockand vpp is a pointer to a vnode pointer for the physical device. Note thatthe returned vnode is not necessarily a physical device. This is used by thepaging system to premap files before they are paged. In the NFS this is anull mapping.vnstrategybp Block oriented interface to read or write a logical block from a file into orout of a buffer. Bp is a pointer to a buffer header which contains a pointerto the vnode to be operated on. Does not copy through the buffer cache ifthe file system uses it. This is used by the buffer cache routines and thepaging system to read blocks into memory.vnbreadvp,bn,bpp Read a logical block bn from a file vp and return a pointer to a bufferheader in bpp which contains a pointer to the data. This does notnecessarily imply the use of the buffer cache. This operation is usefulavoid extra data copying on the server side of a remote file system.vnbrelsevp,bp The buffer returned by vnbread can be released.6.1 Kernel interfacesA veneer layer is provided over the generic vnode interface to make it easier for kernel subsystems tomanipulate filesvnopen Perform permission checks and then open a vnode given by a path name.vnclose Close a vnode.vnrdwr Build a uio structure and read or write a vnode.vncreate Perform permission checks and then create a vnode given by a path name.vnremove Remove a node given by a path name.vnlink Link a node given by a source path name to a target given by a target path name.vnrename Rename a node given by a source path name to a target given by a target path name.VNHOLD Increment the vnode reference count.VNRELE Decrement the vnode reference count and call vninactive if this is the last reference.Many system calls which take names do a lookuppn to resolve the name to a vnode then call theappropriate veneer routine to do the operation. System calls which work off file descriptors pull the vnodepointer out of the file table and call the appropriate veneer routine.7. Current statusThe current interface has been in operation since the summer of 1984, and is a released Sun product. Ingeneral, the system performance degradation was nil to 2 depending on the benchmark. To date the4.2BSD file system, the Sun Network File System, and an MSDOS floppy disk file system have beenimplemented under the interface, with other file system types to follow. In addition, a prototype procfile system5 has been implemented. It is also possible to configure out all the disk based file systems andrun with just the NFS. Throughout this time the interface definition has been stable, with minor additions,even though several radically different file system types were implemented. Vnodes has been proven toprovide a clean, well defined interface to different file system implementations.Sun is currently discussing with ATT and Berkeley the merging of this interface with ATTs FileSystem Switch technology. The goal is to produce a standard UNIX file system interface. Some of the9 current issues areAllow multiple component lookup in vnlookup. This would require file systems that implementedthis to know about mount points.Cleaner replacements for vnbmap, vnstrategy, vnbread, and vnbrelse.Symlink handling in the file system independent layer.Eliminate redundant lookups.8. AcknowledgementsBill Joy is the designer of the architecture, and provided much help in its implementation. Dan Walshmodified bio and implemented parts of the device interface as well as parts of the 4.2BSD file system port.Russel Sandberg was the primary NFS implementor. He also built the prototype proc file system andimproved the device interface. Bill Shannon, Tom Lyon and Bob Lyon were invaluable in reviewing andevolving the interface.REFERENCES1. M.K. McKusick, W. Joy, S. Leffler, R. Fabry, A Fast File System for UNIX, ACM TOCS, 2, 3, August1984, pp 181197.2. R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, B. Lyon, Design and Implementation of the SunNetwork Filesystem, USENIX Summer 1985, pp 119130.3. IBM, DOS Operating System Version 2.0, January 1983.4. R. Pike, P. Weinberger, The Hideous Name USENIX Summer 1985, pp 563568.5. T.J. Killian, Processes as Files, USENIX Summer 1985, pp 203207.10
