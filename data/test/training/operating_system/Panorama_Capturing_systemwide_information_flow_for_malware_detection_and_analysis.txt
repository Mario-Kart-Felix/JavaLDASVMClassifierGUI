Panorama Capturing Systemwide Information Flow forMalware Detection and AnalysisHeng Yin Dawn Song Manuel Egele, Christopher Kruegel, Engin Kirdahyinece.cmu.edu dawnsongcs.berkeley.edu pizzaman,chris,ekseclab.tuiwen.ac.at Carnegie Mellon University, Pittsburgh, PA, USACollege of William and Mary, Williamsburg, VA, USA UC Berkeley, Berkeley, CA, USA Technical University Vienna, AustriaABSTRACTMalicious programs spy on users behavior and compromisetheir privacy. Even software from reputable vendors, suchas Google Desktop and Sony DRM media player, may perform undesirable actions. Unfortunately, existing techniquesfor detecting malware and analyzing unknown code samplesare insufficient and have significant shortcomings. We observe that malicious information access and processing behavior is the fundamental trait of numerous malware categories breaching users privacy including keyloggers, password thieves, network sniffers, stealth backdoors, spywareand rootkits, which separates these malicious applicationsfrom benign software. We propose a system, Panorama, todetect and analyze malware by capturing this fundamentaltrait. In our extensive experiments, Panorama successfullydetected all the malware samples and had very few falsepositives. Furthermore, by using Google Desktop as a casestudy, we show that our system can accurately capture itsinformation access and processing behavior, and we can confirm that it does send back sensitive information to remoteservers in certain settings. We believe that a system suchas Panorama will offer indispensable assistance to code analysts and malware researchers by enabling them to quicklycomprehend the behavior and innerworkings of an unknownsample.Categories and Subject DescriptorsD.4.6 Operating Systems Security and ProtectionInvasive softwareGeneral TermsSecurityPermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page. To copy otherwise, torepublish, to post on servers or to redistribute to lists, requires prior specificpermission andor a fee.CCS07, October 29November 2, 2007, Alexandria, Virginia, USA.Copyright 2007 ACM 9781595937032070011 ...5.00.KeywordsMalware Detection, Malware Analysis, Dynamic Taint Analysis, Spyware1. INTRODUCTIONMalicious software i.e., Malware creeps into users computers, collecting users private information, wrecking havocon the Internet and causing millions of dollars in damage.Surprisingly, even software provided by reputable vendorsmay contain code that performs undesirable actions whichmay violate users privacy. For example, Google Desktop, apopular local file system search tool, actually sends sensitiveuser information such as the local search index files back toGoogles servers in certain configuration settings 18. In another widely publicized example, Sony Media Player installsa rootkit without the users knowledge in order to enforcecopyright restrictions and sends back users music listeninghabits 34.Malware detection and analysis is a challenging task, andcurrent malware analysis and detection techniques often fallshort and fail to detect many new, unknown malware samples. Current malware detection methods in general fall intotwo categories signaturebased detection and heuristicsbased detection. The former cannot detect new malwareor new variants. The latter are often based on some heuristics such as the monitoring of modifications to the registryand the insertion of hooks into certain library or systeminterfaces. Since these heuristics are not based on the fundamental characteristics of malware, they can incur highfalse positive and false negative rates. For example, manybenign software access and modify registry entries. Hence,just because an application creates hooks in the registry doesnot mean that it is malicious i.e., the application could be auseful system utility. Furthermore, to evade detection, malware may attempt to hook library or system call interfacesthat the detector does not monitor. Even worse, since manyrootkits hide in the kernel, most such heuristicsbased detectors cannot detect them as they do not necessarily modifyany visible registry entries or library or system call interfaces.In this paper, we propose a novel approach for the detection and analysis of privacybreaching malware. We observethat numerous malware categories, including spyware, keyloggers, network sniffers, stealth backdoors, and rootkits,share similar fundamental characteristics, which lies in theirmalicious or suspicious information access and processingbehavior. That is, they access, tamper, and in some casesleak sensitive information that was not intended for theirconsumption. For example, when a user inputs some textinto an editor, benign software except the editor will notaccess this text, whereas a keylogger will obtain the text,and then send it to the attacker. This behavior is typicallyexhibited without the users knowledge or consent and it isthis fundamental trait that separates such malicious applications from benign software.Thus, based on this observation, we have designed anddeveloped an endtoend approach to automatically identifythis fundamental trait of malicioussuspicious informationaccess and processing behavior of a given program. At ahigh level, our approach is a threestep process test, monitor, and analyze. When examining a malware sample, wefirst load it into our analysis environment and run a seriesof automated tests on it. Each test generates events that introduce sensitive information into the system in a way thatis not destined for the sample under analysis. For example,the introduced information may be keystrokes that are intended for the Windows login process, or user input that isentered into web forms. We then monitor the behavior ofthe sample during the tests and record its information accessand processing behavior. Finally, we automatically analyzethe recorded information access and processing behavior ofthe sample to detect malicioussuspicious behavior and usethe behavioral information we extract from the sample fordetailed analysis.To monitor and record the information access and processing behavior of the sample in the test cases, we propose touse wholesystem, finegrained taint tracking. The approachworks by marking the sensitive information introduced in thetests as tainted, and monitoring taint propagation over thewhole system including the propagation through the kerneland all applications. We monitor the taint propagation atthe hardware level. To perform meaningful analysis, we alsoneed a mechanism to extract operatingsystem level information. For example, we need to know which processes andwhich program modules operate on tainted data, or whichfiles the tainted data is written to. We call this conceptoperatingsystemaware taint analysis.By combining the taint propagation information at thehardware level with operatingsystemlevel knowledge, wethen generate taint graphs. A taint graph is a representation of information flow that shows the processes that accesstainted data, how the data propagates through the system,and finally, to which file or network connection this data iswritten to. Based on taint graphs, we can define variouspolicies that specify the characteristic behavior of differenttypes of malware. By checking the policies against the taintgraph of an unknown sample, we can then enable automaticdetection and analysis of malicious code from numerous categories.To explore the feasibility of our approach, we have designed and developed an endtoend prototype called Panorama.Our experiments demonstrate that Panorama is successfulin detecting all malicious code samples in our test set, generating only a small number of false positives. During thetests, we also observed that finegrained taint analysis suffers from a significant performance degradation a slowdownby a factor of 20. However, since Panorama is targeted tosupport offline detection and analysis of malware, and sinceoptimization is not our main focus while building the prototype, we believe that although significant, this overheadis not a severe limitation for our purposes. We also believethat the approach we propose can be used in combinationwith existing malware crawlers e.g., such as 25 to searchthe web for unknown malware.In summary, this paper makes the following contributions We observe that a fundamental trait of privacybreachingmalware lies in their information access and processing behavior to sensitive information, and propose anendtoend automatic approach to classify and detectmalware using their information access and processingbehaviors. Our approach does not rely on signaturesand thus, it can detect novel instances of maliciouscode. And since it captures the fundamental trait ofmalware, it provides a unified approach to detect andanalyze a wide spectrum of different malware. We have designed and developed Panorama, an endtoend system that can automatically analyze samplesfor malicious information access and processing behavior. As a critical component of Panorama, we havedesigned and developed a wholesystem, finegrained,operatingsystemaware, dynamic taint tracking system to enable us to monitor and investigate the unknown samples information access and processing behavior to sensitive information. In our extensive experiments, our system detected allthe malware samples and had very few false positives.The malware samples include a wide range of differentclasses of malware, such as keyloggers, password sniffers, packet sniffers, stealth backdoors, rootkits andspyware. Using the Google Desktop as a case study,we demonstrate that our system accurately capturesits information access and processing behavior, andthat we can confirm by automated analysis that it doesleak sensitive information to remote servers.The paper is structured as follows The next section givesan overview of our approach. Section 3 presents details onthe design and implementation of Panorama. Section 4 discusses our taint graphbased malware analysis and detection. Section 5 presents the experimental results. Section 6discusses the potential evasions and our countermeasures.Section 7 surveys related work and Section 8 concludes thepaper.2. OVERVIEW OF APPROACHGiven an unknown program to analyze, we wish to automatically determine whether it exhibits malicious information access and processing behavior. At a higher level,our approach to automatically detect whether an unknownsample exhibits malicious behavior is a threestep processtest, monitor, and analyze. In this work, we focus on theanalysis of Windowsbased malware. Hence, we use an outofthebox installation of Microsoft Windows as the analysisenvironment. We regard all code that comes with this installation as being trusted in contrast to the unknown sampleabout which we have no information. We load the sample to be analyzed into this environment and mark whichfiles belong to the loaded sample. We then run the entireenvironment including Microsoft Windows and the loadedMalwareResultsDetectionPoliciesTest EngineGuest SystemTaint GraphsSpecify Taint SourcesTest ScriptTaint EngineOSawareEngineEngineMalware DetectionMalware AnalysisFigure 1 System Overviewsample in our system Panorama. Figure 1 depicts the architecture of Panorama. The system consists of the taintengine, the test engine, the malware detection engine, andthe malware analysis engine.To perform our automatic malware detection and analysis, we run a series of automated tests, which is performedby the test engine. For each test, we generate events thatintroduce sensitive information into the guest system. Thissensitive data is sent to some trusted application, and isnot destined for the sample that is under analysis. We thenmonitor the behavior of the sample during the tests andrecord its information access and processing behavior withrespect to the sensitive information introduced in the tests.To this end, we have designed the taint engine, which performs wholesystem, finegrained information flow tracking.It monitors how the sensitive information propagates withinthe whole guest system including the propagation throughthe kernel and all applications. In particular, we need to investigate whether the information has propagated into thesample i.e., whether it has been accessed by the sampleand what the sample has done with the information e.g.,sending it to an external server via the network.Note that even though dynamic taint analysis has beenproposed before, our approach is the first generic frameworkthat applies dynamic taint analysis to the problem domainof detecting and analyzing privacybreaching malware. Furthermore, our system offers several new capabilities thatare necessary in our problem setting 1 Our system isOSawarein addition to hardwarelevel taint tracking, weneed to understand the highlevel representations of hardware states for the analysis 2 We also need to identifywhat actions are performed by or on behalf of the sampleunder analysis, even if the sample performs code unpackingand dynamic code generation, and executes actions throughlibraries, etc. 3 Our monitoring needs to be wholesystemand finegrained, in order to precisely detect all actions ofthe sample.The systemwide information behavior is captured by agraph representation, which we call taint graph. Taint graphscapture the taint propagation from the initial taint sourcei.e., the sensitive information introduced in the tests throughout the system. Using taint graphs, we can determine whetherthe unknown sample has performed malicious actions. Ingeneral, the decision whether an information access and processing behavior is considered malicious or benign is madewith the help of policies. One characteristic property ofmany types of malicious code such as keyloggers, spyware,stealth backdoors, and rootkits is that they steal, leak ortamper with sensitive user information. Consider the following examples 1 The user is typing input into an application such as a Microsoft Notepad, or is entering his username and password into a web login form through a browser,while an unknown sample also accesses these keystrokes 2The user is visiting some websites, while an unknown sample accesses the webpages or URLs and sends them to aremote host 3 The user is browsing a directory or searching a file, while an unknown sample intercepts the access tothe directory entries and tampers with one or more entries.We devise a set of policies, which are used by the malwaredetection engine to detect malware from unknown samples.Finally, since taint graphs present invaluable insights aboutthe samples information access and processing behaviors,analysts can use the malware analysis engine to examinethe taint graphs, for detailed analysis information. Moreinformation on taintgraphbased analysis and detection isprovided in Section 4.3. DESIGN AND IMPLEMENTATIONIn this section, we describe the design and implementationof Panorama. First, we describe the hardwarelevel tainttracking in Section 3.1. Then we discuss the mechanismsthat can map hardwarelevel operations such as instructionsexecuted on the processor to the corresponding operatingsystem objects such as processes, in Section 3.2. Finally,we describe our approach to performing automated testingand generating taint graphs in Section 3.3.3.1 Hardwarelevel Dynamic Taint TrackingTo perform wholesystem, finegrained taint tracking, weneed to monitor how tainted data propagates throughout thewhole system including the OS and the applications. Sincethe source code for commodity software such as theWindowsoperating system and applications are usually not available,we choose the approach of dynamic instrumentationi.e.,we monitor the whole system execution in a processor emulator and dynamically instrument code to keep track ofhow tainted data propagates during program execution. Wechoose to implement Panorama on QEMU 29, 3, a genericand open source processor emulator, because of its efficiencyachieved through dynamic translation and caching  whencompared to previous processor emulators such as Bochs 5.Our hardwarelevel taint tracking is similar in spirit to anumber of previous systems 10, 26, 13, 35, 12. However,since our goal is to enable wholesystem finegrained taintanalysis, our design and implementation is the most complete. For example, previous approaches either operate ona single process only 12, 26, 35, or they cannot deal withmemory swapping and disks 10, 13.Shadow Memory.We use a shadow memory to store the taint status of eachbyte of the physical memory, CPUs generalpurpose registers1, the hard disk and the network interface buffer. Eachtainted byte is associated with a small data structure storing the original source of the taint and some other bookkeeping information which is necessary for generating taintgraphs. The shadow memory is organized in a pagetablelike structure to ensure efficient memory usage. With theshadow memory for the hard disks, the system can continueto track the tainted data that has been swapped out. Obviously, this also enables the tracking of the tainted data thathas been saved to a file and is then read in.Taint Sources.All sensitive information that is introduced into the system in the automated tests is marked as a taint source.Panorama supports taint input from hardware, such as thekeyboard, network interface, and hard disk. Tainting a highlevel abstract data object e.g. the output of a function call,or a data structure in a specific application or the OS kernel would also be appropriate. Note that taint sources haveto be specified as close to the hardware i.e., lowlevel aspossible. For example, tainting the input typed at the keyboard level is better than tainting the input in a browserform. Otherwise, malware may try to evade detection bycreating hooks that are invoked before the input arrives atthe browser.Taint Propagation.After a data source is tainted, we need to monitor eachCPU instruction and DMA operation that manipulates thisdata in order to determine how the taint propagates. Fordata movement instructions and DMA operations, the destination will be tainted if and only if the source is tainted.For arithmetic instructions, the result will be tainted if andonly if any byte of the operands is tainted. We also handlethe following special situations.Constant function some instructions or instruction sequences always produce the same results, independent of thevalues of their operands. A good example is the instructionxor eax, eax that commonly appears in IA32 programsas a compiler idiom. After executing this instruction, thevalue of eax is always zero, regardless of its original value.We recognize a number of such special cases and untaint theresult.Table lookup a tainted input may be used as an index to access an entry of a table. The taint propagationpolicy above will not propagate taint to the destination, because the value that is actually read is untainted. Unfortunately, such table lookup operations appear frequently, suchas for UnicodeASCII conversion in Windows. Thus, weaugmented our propagation policy with the following ruleif any byte used to calculate the address of a memory loca1For the sake of simplicity, in the current implementation, flags, debug registers, control registers and SIMD e.g.MMX and SSE registers are not considered. However,adding the necessary tracking for these registers would bestraightforward.tions is tainted, then, the result of a memory read using thisaddress is tainted as well.Control flow evasion the taint information may alsopropagate through control flow. The following example illustrates this situation.switchx case a ya break case b yb break ...Note that the above code fragment copies the value ofvariable x to y, without propagating the taint status. Thatis, y will always be untainted, even when x is tainted.The situation outlined above occurs rarely in regular code.However, it does appear in the keystroke handling routinesin Windows 2000 and later versions. In our experimentswith Windows XP, we observed that the Unicode charactersderived from keystrokes were not tainted as expected. Afterreviewing the raw taint propagation events and examiningthe Windows kernel code using IDA Pro 22, we determinedthat taint tracking stops at a keystroke Unicode conversionroutine called xxxInternalToUnicode which is in part ofthe win32k.sys system file. Interestingly, Chow et al. facedthe same problem in their TaintBochs 10. Unfortunately,they did not have a solution. The translation of scancodeinto corresponding unicode characters involves a loop thatcontains a switch statement such as the example discussedpreviously. We solved the problem by specially instrumenting an instruction within the function xxxInternalToUnicode. This instrumentation checks the taint status of theinput parameter of the function, and appropriately propagates the taint status to its output parameter.Being aware of this property, malicious code may exploitcontrol flow evasion in the future to cut off the taint flowin order to thwart detection. The current implementationof Panorama does not handle this situation. This does notcause problems for now, because to the best of our knowledgeno existing malware has used this technique. Furthermore,we will incorporate the static analysis approach proposed in14 into the future implementation of Panorama to preventthis potential evasion.3.2 OSAware Taint TrackingResolving process and module information.When an instruction is operating on tainted data, we needto know which process and module this instruction comesfrom. In some rare situations, instructions may also be dynamically generated and executed on the heap.Maintaining a mapping between addresses in memory andmodules requires information from the guest operating system. To obtain this information, we developed a kernelmodule called module notifier. We load this module intothe guest operating system to collect the updated memorymap information. The module notifier registers two callbackroutines. The first callback routine is invoked whenever aprocess is created or deleted. The second callback routineis called whenever a new module is loaded and gathers theaddress range in the virtual memory that the new moduleoccupies. In addition, the module notifier obtains the valueof the CR3 register for each process. As the CR3 registercontains the physical address of the page table of the current process, it is different and unique for each process. Allthe information described above is passed on to Panoramathrough a predefined IO port.Since our module notifier component resides in the guestoperating system, malicious code may attempt to tamperwith it. For example, malware could attempt to send incorrect information to the predefined IO port or tamper withthe code image of the module. To ensure the authenticity ofthe messages that Panorama receives from the module notifier, we check the program counter of the instruction thatis responsible for sending this message. Of course, only instructions that belong to the module notifier are permittedto send messages. We also protect the integrity of the codeof the module notifier by marking the corresponding memory region readonly. As a result, any attempts to tamperwith the code of the module notifier can be detected andprevented. Note that a more secure approach to resolvingprocess and module information is to directly examine theprocess and module objects from the outside. The disadvantage of this approach is less of portability. That is, differentversions of Windows, and even different service packages,need be handled differently. Thus, we decided to use thefirst, more portable approach in our proofofconcept prototype implementation.Resolving filesystem and network information.In addition to mapping instructions executed on the processor to operatingsystem processes, we are also interestedin obtaining more information when data is exchanged between the memory and hardware devices. In particular, weare interested in more details about when tainted data iswritten to the hard disk or sent over the network. Moreprecisely, when tainted data is written to the hard disk, wewish to identify which file it is written to. Analogously, whentainted data is transmitted over the network, we would liketo know which TCP or UDP virtual connection it is sentover or received from.We integrated a disk forensic tool called The Sleuth KitTSK 36 into Panorama for gathering filesystem information. Specifically, when tainted data is written to a blockon the hard disk, TSK can determine which file this blockbelongs to. In addition, when a file on disk is selected as ataint source, TSK will identify all data blocks that belongto this file so that all blocks can be appropriately tainted.The toolkit achieves these goals by scanning and parsing theondisk metadata structures.Resolving network information is straightforward. Whentainted data is sent out, we simply check the packet headerto find out which connection it belongs to.2 Similarly, whenselectively tainting the incoming traffic of a specific connection, we check its packet header and taint the packet accordingly. Tainting incoming network packets from the networkcard is performed at the granularity of virtual connections.Identifying the code under analysis and its actions.An important task of our system is to identify the actionsof the code under analysis. In particular, we are interestedin observing cases in which the potential malware sampleaccesses tainted data. It is clear that the code under analysis operates on tainted data if an instruction in it accessesthe taint directly. This can be checked in a straightforward2We may not be able to obtain transportlayer informationdirectly from IP fragments. In the current prototype implementation, we do not solve this infrequent case. However,reassembling the fragments and extracting this informationis quite straightforward if desired.fashion by consulting the mapping between instruction addresses and modules. However, there are two importantcases in which it is not the malicious sample itself that accesses tainted data, but code that operates on its behalf.The first case occurs when the sample under analysis dynamically generates new code either by decrypting dataregions, or by generating code on the fly. In this case, thederived code belongs to the sample under analysis, but theorigin of the code is not reflected in our module mapping. Tohandle this situation, we taint the complete code segment ofthe sample under analysis, using a special label. Wheneveran instruction is executed that is marked with the speciallabel, the output of this instruction receives the special label as well. This strategy helps identify all code regionsderived from the original sample, such as uncompressed anddecrypted instructions from packed executables, or those dynamically generated.The second case occurs when the given code calls a pieceof trusted code in order to perform tainted operations onits behalf. In this case, the program counter would point tothe trusted code, and we would miss the potential maliciousbehavior of the given sample, if we only look at the programcounter. We use the following observation to identify taintpropagation that is performed by trusted system modules onbehalf of the malware Whenever the malicious code callsa trusted function to propagate tainted data, the value ofthe stack pointer at the time of the function call must begreater than the value of the stack pointer at the time whenthe tainted data is actually propagated. This is because oneor more stack frames have to be pushed onto the stack whenmaking function calls, and the stack grows toward smalleraddresses on the x86 architecture.Based on our observation, we use the following approachto identify the case when trusted functions propagate taintedvalues on behalf of the code under analysis Whenever theexecution jumps into the code under analysis or code derived from it, we record the current value of the stackpointer, together with the current thread identifier. Whenexecuting jumps out of this code, we check whether thereis a recorded stack pointer for the current thread identifier,and if so, whether this value is smaller than the currentstack pointer. If this is the case, we remove the record asthe code is not on the stack anymore. Whenever a trustedmodule propagates tainted data, we check whether there isa recorded stack pointer under the current thread identifier.If so, we consider this tainted data being propagated by thecode under analysis. Note that the current thread identifieris mapped into a wellknown virtual address in Windows.Hence, obtaining its value is straightforward.Note that the strategy described above will detect alltaintrelated action on behalf of the malicious code, giventhat they are performed in the same thread context. Whilethis is true most of the time, there are cases in which theactual taint propagation occurs in an asynchronous fashion.For example, when the code calls an API function asynchronously to save the tainted data to a file, the API function immediately returns to the caller. The actual actionthat is requested is performed later. We have identified several kernel API calls dealing with filesystem and networkaccess that may be used asynchronously. When such a function is invoked, we analyze the stack pointers to determinewhether both the code under analysis is calling this function and the input buffer is tainted. If this is the case, wetreat this tainted buffer as being propagated by the analyzedsample.3.3 Automated Testing and Taint Graph Generation3.3.1 Automated TestingThe test engine in Panorama allows us to perform theanalysis of samples and the detection of malicious code without human intervention. It executes a number of test casesthat mimic common tasks that a user might perform, suchas editing text in an editor, visiting several websites, andso on. The specific test cases used in our experiments willbe discussed in Section 4.1. To automatically run tests, ourtest engine is equipped with scripts that execute all stepsnecessary for each test case. For our current implementation, these scripts are based on the open source programAutoHotkey 1. Scripts can be either manually written orautomatically generated by recording user actions while atask is performed.Whenever the test engine executes a certain test case, itintroduces input such as keystrokes or network packets intothe system. To determine which part of this input shouldbe tainted and with which taint label, the test engine cooperates with the taint engine. Currently, our system defines the following nine different types of taint sources text,password, HTTP, HTTPS, ICMP, FTP, document, and directory, which will be discussed in Section 4.1. For example,when editing a document in an editor, the test engine asksthe taint engine to send keystrokes to the editor, and labelthem as text when entering password in a secure web form,the test engine asks the taint engine to send keystrokes andlabel them as password. When considering these cases, itbecomes evident that the taint engine requires support fromthe test engine to properly label input. In both cases, thekeystroke information enters the system. However, in theformer case, the keystroke is considered text as it is sent tothe one of the text editors. In the latter, the recipient ofthe input is a password field and the keystroke informationis marked as password. Clearly, this information is testspecific and not available at the hardware level. The datareceived as a response to the web requests are tainted asHTTP. The packets received in response to ping requestsare labeled ICMP. The information sent by the FTP serverare marked FTP. Finally, when listing a directory, all accessed disk blocks that hold file directory information aretainted as directory. The communication between the testengine and the taint engine is via an intercepted registrywriting API the test engine writes information into a predetermined registry entry, and taint engine intercepts thisAPI call and then obtains the information.3.3.2 Taint Graph GenerationThe systemwide propagation of tainted input introducedby the test engine forms a graph over the processesprogrammodules and OS resources. For example, assume that akeystroke is tainted as text because it is part of the input sentto a text editor. When a user process A reads the characterthat corresponds to the keystroke, this fact is recorded bylinking the text taint source to process A. When this processlater writes the character into a file F, from where it is thenread by process B, we can establish a link from process Ato the file, and subsequently from file F to process B. Forclarity, we generate one graph for each taint source with adifferent label that is, one graph that shows the flow of datalabeled as text, one for password, . . . . For each taint source,the taint propagation originating from this source forms adirected graph. We call this graph a taint graph.More formally, a taint graph can be represented as g V, E, where V is a set of vertices and E is a set of directededges connecting the vertices, and we use g.root to representthe root node of graph g i.e., the taint source. A vertexcan either represent an operating system object such as aprocess or module, an OS resource such as a file, or ataint source such as keyboard or network input with theappropriate labels. An edge between two vertices v1 andv2 is introduced when tainted data is propagated from theentity that corresponds to v1 to the entity that correspondsto v2.When generating the taint graphs, the taint engine mapsthe hardwarelevel taint propagation information to operatingsystem level. For example, the taint engine determines whichprocess and which module such as which dll has performed a certain operation, and it also keeps track of whetherthis operation is performed on behalf of the sample underanalysis. Also, writes to disk blocks are attributed to fileobjects and network operations to specific network connections. To further simplify the taint graphs, we apply thefollowing optimizations, without losing the dependencies between the sample under analysis and other objects 1 wemake the vertices for system kernel modules transparent 2for userlevel instructions, if they are not derived from thesample under analysis i.e., they are trusted, they are attributed to the processes they are running in, instead of themodules they are from.3In a taint graph, each vertex is labeled with a type, valuepair, where value is the unique name that identifies the vertex. For the root node, the type is one of the nine differentinput taint labels introduced previously. For any nonrootnode, the type represents the category of the node as a OSobject, including process, module, keyboard, network, andfile. Formally, the type of a vertex can be defined in a hierarchical form, as followstype  taintsource  osobjecttaintsource  text  password  HTTP  HTTPS FTP ICMP  document  directoryosobject  process  module  network  fileFigure 2 shows an example of a taint graph. We use ellipses to represent process nodes and use shaded ellipses torepresent the module node. We use an octagon to representthe taint source here, a password typed on the keyboard,and a rectangle to represent the other nodes. We will givemore description of this graph in Section 4.2.4. TAINTGRAPHBASED MALWARE DETECTION AND ANALYSISIn this section, we describe how taint graphs can be usedto detect malware, and how they help to understand theactions of malicious code,4.1 TaintGraphBased Malware Detection3In other words, the presence of a module node in a taintgraph indicates at least one instruction of this module stemsfrom the sample.password Winlogon.exelsass.exeWinlogon.exemscad.dll cginalog.logFigure 2 An example of taint graph. This graphreflects the procedure for Windows user authentication. While a password thief is running in thebackground, it catches the password and saves themto its log file cginalog.log.Our essential observation is that numerous types of malicious code, including keyloggers, password thieves, networksniffers, stealth backdoors, spywareadware, and rootkits,exhibit anomalous information access and processing behavior. Currently, we categorize three kinds of anomalous behavior anomalous information access, anomalous information leakage, and excessive information access.Anomalous information access behavior.For some information sources, a simple access performedby the samples under analysis is already suspicious. We referto this behavior as anomalous information access behavior.Considering the keyboard inputs, such information sourcesmay include the text input sent to the text editor, the command sent to the command console, and the passwords sentto the Windows Logon dialog and secure web pages. Benignsamples do not access these inputs, whereas keyloggers andpassword thieves will access these inputs. Keyloggers referto the malicious programs that capture keystrokes destinedfor the other applications, and thus will access all these inputs. Password thieves, by definition, steal the passwordinformation, and therefore will access the password inputs.Note that password thieves can be a subset of keyloggers,because keyloggers may also record passwords.Similarly, some network inputs are not supposed to beaccessed by unknown samples. For example, ICMP is designed for network testing and diagnosis purpose, and henceonly operating system and trusted utilities e.g. ping.exeuse it. For many TCP and UDP applications, the incomingTCP and UDP traffic can only be accessed by their own andthe operating system. Benign samples do not interfere withthe process of these inputs. However, network sniffers andstealth backdoors access these inputs for different purposes.Network sniffers eavesdrop on the network traffic to obtainvaluable information. Even though a network sniffer maynot be directly interested in these inputs, it usually has toaccess them to check if they are valuable. Stealth backdoorsrefer to a class of malicious programs that contact with remote attackers without explicitly opening a port. To achievestealthiness, the stealth backdoors either use an uncommonprotocol such as ICMP, create a raw socket, or intercept thenetwork stack, in order to communicate with remote adversaries. The ICMPbased stealth backdoors will access ICMPtraffic. The rawsocketbased stealth backdoor will access allthe packets with the same protocol number. For example, aTCP raw socket will receive all TCP packets. The stealthbackdoors intercepting the network stack will behave like anetwork sniffer.Anomalous information leakage behavior.Test case description Introduced inputs1. Edit a text file and save it text, document2. Enter password in a GUI program password3. Log in a secure website URL, password, HTTPS4. Visit several websites URL, HTTP5. Log into an FTP server text, password, FTP6. Recursively list a directory directory7. Send UDP packets into the system UDP8. Ping a remote host ICMPTable 1 The test cases and introduced inputs..For some other information sources, it is acceptable for thesamples to access them locally, but unacceptable to leak theinformation to third parties. For example, spywareadwareprograms record users surfing habits and send this privateinformation to third parties. In contrast, benign BHOs i.e.,Browser Helper Objects may access this information butwill not send it out. We consider the following as information leakage the sample under analysis accesses the information and then saves it to disk or sends it over the network.Note that saving the information to disk covers three situations saving it to files, the registry, and even individualdisk blocks. We consider information sources like HTTP,HTTPS, documents, and URLs fall into this category.Excessive information access behavior.For some information sources, benign samples may accesssome of them occasionally, while malicious samples will access them excessively to achieve their malicious intent. Werefer to it as anomalous information excessive access behavior.The directory information is such a case. Rootkits exhibitexcessive access behavior to the directory information, because they attempt to conceal their presence in the filesystem by intercepting the accesses to directory informationand removing the entries that point to their files. Thus,when recursively listing directories, we will see the rootkitsamples accessing many disk blocks that contain directoryinformation. A benign program may access some directoryentries, or even scan directories occasionally. However, itis very unlikely that it accesses the same directories at thesame time while we list directories.Test cases and policies.According to the above discussion, we compile the following test cases and introduce the inputs with correspondinglabels, as shown in Table 1. Specifically, we introduce text,password, URL inputs from the keyboard, HTTP, HTTPS,FTP, ICMP, and UDP inputs from the network, and document and directory input from the disk. Note that in thetest case 6, to eliminate the possibility that a benign program scans the same directory at a different time, we cleanthe taint labels of the visited directory entries after finishingwith listing the directory. After finishing all the test cases,the test engine waits for a while a configurable parameterand then shuts down the guest machine.From the above discussion, we specify the following policies 1 text, password, FTP, UDP and ICMP inputs cannotbe accessed by the samples 2 URL, HTTP, HTTPS anddocument inputs cannot be leaked by the samples 3 directory inputs cannot be accessed excessively by the samples.More formally, we show how these policies are enforced onthe taint graphsg  G, v  g.V, v.type  module g.root.type  text, password, FTP, UDP, ICMP V iolatev, No Access 1g  G, v  g.V, v.type  module g.root.type  URL, HTTP, HTTPS, document u  descendantsv, u.type  file, network V iolatev, No Leakage 2g  G, g.root.type  directory v  g.V, v.type  module V iolatev, No Excessive Access 3In addition to manually specifying the policies, it is possible to automatically generate policies by using machinelearning techniques. First, we can gather a representativecollection of malware and benign samples as our trainingset. Using this training set, Panorama will extract the corresponding taint graphs. Then, we need to develop a mechanism to transform a taint graph into a feature vector. Basedon the feature vectors for the benign and malicious samples,standard classification algorithms can be applied to determine a model. Using this model, novel samples can thenbe classified. We will further explore this approach in ourfuture work.4.2 TaintGraphBased Malware AnalysisGiven a taint graph, the first step is to check this graphfor the presence of a node that corresponds to the sampleunder analysis. If such a node is present, we obtain the information that the sample has accessed certain tainted inputdata. This is already suspicious, because the test cases aredesigned such that input data is sent to trusted applications,but never to the sample under analysis. Once we determinethat a sample has accessed certain input, the samples successor nodes in the graph can be examined. This indicateswhat has been done with the data that was captured. Suchinsights can be instrumental for system administrators andanalysts to understand the behavior and actions of malware.As an example, recall the taint graph previously shown inFigure 2. This taint graph has been produced by automatically analyzing the behavior of the password thief programGINA spy 16. Note that the entered password is receivedby the Windows Logon process Winlogon.exe. This process passes the password on to lsass.exe for subsequentauthentication. Interestingly, the password data is also accessed by the sample under analysis mscad.dll, which isloaded by Winlogon.exe. This code module reads the password and saves it to a file called cginalog.log. Thegraph correctly reflects how the user password is processedby Windows, and how the password thief intercepts it. InSection 5.2, we discuss a more complex realworld examplethat we investigated during our experiments.5. EVALUATIONIn this section, we present details on the experimentalevaluation of our Panorama system. Our evaluation consisted of three parts. First, we investigated the effectiveness of our taintgraphbased malware detection approachCategory Total FNs FPsKeyloggers 5 0 Password thieves 2 0 Network sniffers 2 0 Stealth backdoors 3 0 Spywareadware 22 0 Rootkits 8 0 Browser plugins 16  1Multimedia 9  0Security 10  2System utilities 9  0Office productivity 4  0Games 4  0Others 4  0Sum 98 0 3Table 2 Summary of detection results against malware and benign samples.using a large body of realworld malware and benign samples. Then, by using Google Desktop as a case study i.e., asample from a vendor whose privacy policy we believed wecould trust, we explored the amount of detailed informationthat we could extract from the taint graph of an unknownsample. Third, we performed tests to evaluate the performance overhead of our prototype. In all our experiments, weran Panorama on a Linux machine with a dualcore 3.2 GHzPentium 4 CPU and 2GB RAM. On top of Panorama, weinstalled Windows XP Professional with 512M of allocatedRAM.5.1 Malware DetectionOur malware collection consisted of 42 realworld malwaresamples, including 5 keyloggers, 2 password thieves, 2 network sniffer, 3 stealth backdoors, and 22 spyware BHOs, and8 rootkits. Some of these samples were publicly available onthe Internet e.g., from web sites such as www.rootkit.com,while others were collected from academic researchers andan Austrian antivirus company. Furthermore, we downloaded 56 benign, freelyavailable samples from a reputableand trustworthy web site www.download.com. These benign samples were freeware programs from a wide range ofdifferent application domains such as browser plugins, system utilities, and office productivity applications, with thesize up to 3MB.To further facilitate the experiments, we developed a toolusing Python to run the samples and automatically performthe installation procedure if required using several heuristics. The tool can handle 70 of the samples in our test set.For the remaining samples, some required manual configuration they were all malware samples, and the others werenot properly handled by the heuristics. We then manuallyinstalled the remaining samples. We installed up to 3 samples each time. After that, we ran the test cases. We setthe test engine to wait for 5 minutes before shutting downthe guest machine. Depending on the installation delay, thewhole procedure lasts 15 to 25 minutes.Table 2 summarizes the results of this experiment. Wecan see that Panorama was able to correctly identify allmalware samples, but falsely declared three benign samplesto be malicious.Two of these false positives were personal firewall programs. The third false positive was a browser accelerator.By checking the taint graphs related to these three samples, we observed that the information access and processingbehaviors of these benign samples closely resemble that ofmalware. In fact, the two personal firewalls install packetfilters and monitor all network traffic. Hence, their behavior resembles that of a malicious network sniffer. In thecase of the browser accelerator, we observed that the application prefetches web pages on behalf of the browser andstores them into its own cache files. This behavior resembles that of spyware that monitors the web pages that auser is surfing. The reason for our false positives is thatour taintgraphbased detection approach can only identifythe information access and processing behavior of a givensample, but not its intent. In reallife, the taint graphs areinvaluable for human analysts, as they help them to quicklydetermine and understand whether an unknown sample isindeed malicious, or whether it is benign software that isexhibiting malwarelike behavior.5.2 Malware AnalysisIn order to determine how well we are able to performdetailed analysis on an unknown sample, we chose GoogleDesktop for a case study. This application claims in itsprivacy policy 19 that it will index and store data files,mail, chat logs, and the web history of a user while theuser is working on her system. Furthermore, if the specialconfiguration setting Search Across Computers is enabled,Google Desktop will securely transmit copies of the usersindex files to Google servers. Hence, Google Desktop, infact, exhibits some malwarelike behavior, as the index filesmay contain sensitive information about a user e.g., a listof web sites that the user has visited, and these files aresent to an external server.First, we downloaded the installation file GoogleDesktopSetup.exe. Before installing the tool, we marked theinstallation file such that we could track which componentswould be installed into the system. After the installationwas complete, we observed that 18 executables and sharedlibraries, as well as a dozen data files were installed.Second, we ran the test cases, using the default settingsof Google Desktop in which Search Across Computersis disabled. After performing the test cases, we observedthat some components extracted from the installation fileaccessed the tainted inputs, including HTTPS, HTTP anddocument. All of this information was later saved into theindex files in the local installation directory. To determineif the information is sent out to remote hosts, we kept thesystem alive for 12 hours. However, we did not observe thisbehavior.Third, we changed the settings of Google Desktop and enabled the feature Search Across Computers. Then, we ranthe test cases again and kept the system alive for another30 minutes. It was evident from the generated taint graphsthat, in this mode, Google Desktop did leak the collectedinformation via HTTPS connections to Google servers. Wepicked a representative taint graph, which clearly illustrateshow the components of Google Desktop process the incoming traffic of an HTTP connection from the QEMU web sitewe visited, see Figure 3.By examining this taint graph, we can draw several conclusions 1 the incoming web page was first received andprocessed by the Internet Explorer IEXPLORE.EXE, whichlater saved the content into a cache file qemu1.htm under the temporary Internet file folder 2 a component fromGoogle Desktop GoogleDesktopAPI2.dll was loaded intothe IEXPLORE.EXE, obtained the web page, and passed itover to a standalone program also from Google DesktopGoogleDesktopIndex.exe 3 GoogleDesktopIndex.exefurther processed this information and saved it into two datafiles rpm1m.cf1 and fiih.ht1 in its local installation directory and 4 it sent some information derived from theweb page to a remote Google server 72.14.219.147 throughan HTTPS connection.With the capability provided by Panorama, we could confirm that Google Desktop really sends some sensitive information if a special feature is activated as it also claims inits privacy policy.5.3 Performance OverheadWemeasured Panoramas performance overhead using several utilities in Cygwin, such as curl, scp, gzip, and bzip2.When running these tools, we tainted file and network inputs accordingly. We found that the current unoptimizedimplementation of Panorama suffers a slowdown of 20 timeson average. Since Panorama aims to support offline malware detection and analysis, we believe that this overheadis not a severe limitation for our intended application scenarios. When one considers that unknown malware samplesare currently mostly analyzed manually, it is clear that anautomated system such as Panorama significantly simplifiesand speeds up this task. Also, note that some research hasbeen done to explore more efficient means for dynamic taintanalysis. Ho et. al. proposed Demand Emulation, in whicha running system dynamically switches between virtualizedand emulated execution, and emulation is only used whentainted data is being processed by the CPU 20. Exploring finergrained hardware protection provided by ECC mayfurther improve the performance significantly 30. Recently,Qin et. al. explored several optimizations on dynamic binaryinstrumentation to minimize the runtime overhead 31.6. DISCUSSIONIn this section, we discuss several potential evasion techniques that malware writers may attempt to use in order tothwart the current implementation of Panorama. Furthermore, we discuss the countermeasures that we can employ.Breaking the propagation of taint information.As mentioned in Section 3.1, a malware author can attempt to design his code such that the taint engine fails toproperly keep track of tainted information. For example, byexploiting indirect dependencies dependencies encoded using control flow decisions, a malicious program could conceal the fact that sensitive information is leaked. This isa limitation of our current implementation. We will enhance the implementation to keep track of taint propagation via control flow in the future, as in our earlier implementation 14. Moreover, it is important to note that thecurrent system observes all instances in which the sampleunder analysis accesses tainted data. That is, a malwaresample can only hide the fact that it leaks information aswell as the operating system resources that this informationis written to. Fortunately, the mere fact that sensitive datais accessed without authorization is often enough to classifya sample as malware.tcp212.27.63.117801047IEXPLORE.EXEexplorer.exe IEXPLORE.EXEGoogleDesktopAPI2.dll GoogleDesktopCrawl.exeGoogleDesktopCrawl.exe cLogFile TEMPContent.IE50JBRMNI7qemu1.htmGoogleDesktopIndex.exeGoogleDesktopAPI2.dllGoogleDesktopIndex.exeGoogleDesktopIndex.exeGoogleDesktopIndex.exegzlib.dll GoogleDesktopIndex.exeGoogleDesktopSSD.dll INSTDIR577eef2d8a09rpm1m.cf1 INSTDIR577eef2d8a09fiih.ht1tcp72.14.219.1471068443Figure 3 A taint graph that presents how Google Desktop handles incoming web pages. Here, INST DIRrepresents cProgram FilesGoogleGoogle Desktop Search, and TEMP is cDocuments andSettingsuserLocal SettingsTemporary Internet Files.Not behaving maliciously when tested.Malware may evade detection by simply not performingmalicious behavior while the test cases are conducted. Itmay stay inactive until certain conditions are satisfied. Forexample, time bombs activate themselves only on specificdates, and some keyloggers only record keystrokes for certain applications or windows. Malware may also detect if itis running in the QEMU environment and remains dormantif indeed. Ferrie discussed the technique to detect the virtualmachines and emulators including QEMU 15. Our currentprototype will not detect this kind of malware. However,some complementary work has been done to address thisproblem. Vasudevan et al. proposed several stealthy techniques, such that the analysis environment cannot be easilydetected 37. Moser et al. 24 and Brumley et al. 7, 6 alsoused QEMU to built malware analysis systems, which areable to uncover hidden behavior of malware by exploringmultiple execution paths. Incorporating these techniquesinto our system will be our future work.Subverting Panorama.As an emulated environment, Panorama provides strongisolation such that it is unlikely for the malware runninginside to interfere with Panorama and the host system. Although it is usually true, some study shows the possibilityof subverting the entire emulated environment by exploitingbuffer overflows and integer bugs 27. This problem can besolved by fixing these bugs.7. RELATED WORKMalware detection approaches.Signature based malware detection has been in use foryears to scan files on disk and even memory for known signatures. Although semanticaware signature checking 11 improves its resilience to polymorphic and metamorphic variants, the inherent limitation of the signature based approachis its incapability of detecting previously unseen malwareinstances. Its usefulness is also limited by the rootkits thathide files on disk and, as demonstrated in ShadowWalker 9,may even hide malware footprints in memory.Behavior based malware detection identifies malicious programs by observing their behaviors and system states i.e.,detection points. By recognizing deviations from normalsystem states and behaviors, behavior based detection mayidentify entire classes of malware, including previously unseen instances. There are a variety of detections that examine different detection points. Strider GateKeeper 39checks autostart extensibility points in the registry to determine surreptitious restartsurviving behaviors. VICE 8and System Virginity Verifier 33 search for various hooksthat are usually used by rootkits and the other malware.Behavior based detection can be defeated, either by exploring stealthier methods to evade the known detection points,or by providing misleading information to cheat detectiontools. In addition, current detection tools usually residetogether with malicious programs, and therefore expose tocomplete subversion. In contrast, our system overcomesthese three weaknesses. First, it captures the characteristic information access and processing behavior of malware,and thus cannot be easily evaded. Second, it detects malware based on the hardwarelevel knowledge and makes veryfew assumption at software level, and hence cannot be easily cheated. Third, it is implemented completely outsideof the victim system, and so strongly protected from beingsubverted.The crossview based rootkit detection technique e.g. Blacklight 4, Rootkit Revealer 32, and Strider Ghostbuster 2identifies hidden files, processes, registry entries by comparing two views of the system the upperlevel view is derivedfrom calling common APIs, while the lowlevel view is obtained from system states in the kernel or from hardware ifapplicable. In comparison, our approach for rootkit detection has two advantages 1 the crossview based techniquerequires enumerating all files and registry entries, etc. tofind hidden entries, which often takes several hours, whereasour approach only takes a few minutes 2 the result givenby the crossview based technique can only identify a listof hidden entries, while our approach recognizes the rootkitdirectly.Dynamic Taint Analysis.Dynamic taint analysis has been applied to solve and analyze other security related problems. Many systems 26,13, 28, 12, 35 detect exploits by tracking the data fromuntrusted sources such as the network being misused to alter the control flow. Chow et al. made use of wholesystemdynamic taint analysis to analyze how sensitive data arehandled in operating systems and large programs 10. Themajor analysis was conducted in Linux, with source codesupport of the kernel and the applications. Egele et al.also utilized wholesystem dynamic taint analysis to examine BHObased spyware behavior 14. Vogt et al. extendedthe JaveScript engine with dynamic taint analysis to preventcrosssite scripting attacks 38. Our system is independentlydeveloped with OSaware analysis for closedsource operating systems, and devises a unified machinery for detectingmalware from several different categories.Information flow analysis.Our system works by analyzing taint graphs to identifysuspicious information access and processing behavior of foreign code. This is related to previous work that performsforensic analysis based on information flows. For example,some systems track the flow of information between operating system processes to perform intrusion analysis 23,intrusion recovery 17, and malware removal 21. However,these systems typically monitor the system call interface andthus, are not as comprehensive and do not provide the samelevel of precision as our technique. Another limitation of previous systems is that it is often not possible to precisely trackdata while it is processed by a program. This can introduceincorrect connections between data objects or lead to missedinformation flows. Also, previous systems do not apply tokernelmode attacks. Thus, we believe that by performingwholesystem, fine grained taint tracking, our method provides higher accuracy than previous work, and we can alsohandle kernel attacks.8. CONCLUSIONMalware has brought along serious security and privacythreats. However, existing techniques for malware detection and analysis are ineffective. In this paper, we haveproposed wholesystem finegrained taint analysis to discernfinegrained information access and processing behavior of apiece of unknown code. This behavior captures the intrinsic characteristics of a widespectrum of malware, includingkeyloggers, password sniffers, packet sniffers, stealth backdoors, BHObased spyware, and rootkits. Thus, the detection and analysis relying on it cannot be easily evaded. Toevaluate the effectiveness of this approach, we have designedand developed a system, called Panorama. In the experiments, we have evaluated 42 malware samples and 56 benignsamples. Panorama yields zero false negative and very fewfalse positives. Then we use Google Desktop as a case study.We have demonstrated that Panorama can accurately capture its information access and processing behavior, and weconfirm that it does send back sensitive information to remote servers. We believe that a system such as Panoramawill offer indispensable assistance to malware analysts andenable them to quickly comprehend the behavior and innerworkings of malware.9. ACKNOWLEDGEMENTThis material is based upon work partially supported bythe National Science Foundation under Grants No. 0311808,No. 0433540, No. 0448452, No. 0627511, and CCF0424422.Partial support is also provided by the International Technology Alliance, and by the U.S. Army Research Office underthe CyberTA Research Grant No. W911NF0610316, andunder grant DAAD190210389 through CyLab at CarnegieMellon. The views and conclusions contained here are thoseof the authors and should not be interpreted as necessarilyrepresenting the official policies or endorsements, either expressed or implied, of ARO, NSF, or the U.S. Govermentor any of its agencies. This work is also supported in partby the Korean Ministry of Information and CommunicationMIC and the Korean Institute for Information TechnologyAdvancement IITA under program 2005S60602, NextGeneration Prediction and Response Technology for Computer and Network Security Incidents. Moreover, this workwas supported by the Austrian Science Foundation FWFunder grant P18157, the FITIT project Pathfinder, and theSecure Business Austria competence center.10. REFERENCES1 AutoHotkey. httpwww.autohotkey.com.2 D. Beck, B. Vo, and C. Verbowski. Detecting stealthsoftware with strider ghostbuster. In Proceedings of the2005 International Conference on Dependable Systemsand Networks DSN05, pages 368377, June 2005.3 F. Bellard. Qemu, a fast and portable dynamictranslator. In USENIX Annual Technical Conference,FREENIX Track, April 2005.4 Blacklight. httpwww.europe.fsecure.comexcludeblacklight.5 Bochs The open source IA32 emulation project.httpbochs.sourceforge.net.6 D. Brumley, C. Hartwig, M. G. Kang, Z. Liang,J. Newsome, D. Song, and H. Yin. BitScopeAutomatically dissecting malicious binaries. TechnicalReport CMUCS07133, School of Computer Science,Carnegie Mellon University, March 2007.7 D. Brumley, C. Hartwig, Z. Liang, J. Newsome,D. Song, and H. Yin. Botnet Analysis, chapterAutomatically Identifying Triggerbased Behavior inMalware. 2007.8 J. Butler and G. Hoglund. VICEcatch the hookersIn Black Hat USA, July 2004.httpwww.blackhat.compresentationsbhusa04bhus04butlerbhus04butler.pdf.9 J. Butler and S. Sparks. Shadow walker Raising thebar for windows rootkit detection. In Phrack 63, July2005.10 J. Chow, B. Pfaff, T. Garfinkel, K. Christopher, andM. Rosenblum. Understanding data lifetime via wholesystem simulation. In Proceedings of the 13th USENIXSecurity Symposium Security03, August 2004.11 M. Christodorescu, S. Jha, S. A. Seshia, D. Song, andR. E. Bryant. Semanticsaware malware detection. InProceedings of the 2005 IEEE Symposium on Securityand Privacy Oakland05, May 2005.12 M. Costa, J. Crowcroft, M. Castro, A. Rowstron,L. Zhou, L. Zhang, and P. Barham. VigilanteEndtoend containment of internet worms. InProceedings of the 20th ACM Symposium on OperatingSystems Principles SOSP05, October 2005.13 J. R. Crandall and F. T. Chong. Minos Control dataattack prevention orthogonal to memory model. InProceedings of the 37th International Symposium onMicroarchitecture MICRO04, December 2004.14 M. Egele, C. Kruegel, E. Kirda, H. Yin, and D. Song.Dynamic Spyware Analysis. In Proceedings of the 2007Usenix Annual Conference Usenix07, June 2007.15 P. Ferrie. Attacks on virtual machine emulators.Symantec Security Response, December 2006.16 GINA spy. httpwww.codeproject.comuseritemsGINASPY.Asp.17 A. Goel, K. Po, K. Farhadi, Z. Li, and E. de Lara.The taser intrusion recovery system. In Proceedings ofthe 20th ACM Symposium on Operating SystemsPrinciplesSOSP05, October 2005.18 Googles desktop search red flag. httpwww.internetnews.comxSParticle.php3584131.19 Google Desktop  Privacy Policy. httpdesktop.google.comenprivacypolicy.html.20 A. Ho, M. Fetterman, C. Clark, A. Watfield, andS. Hand. Practical taintbased protection usingdemand emulation. In EuroSys 2006, April 2006.21 F. Hsu, H. Chen, T. Ristenpart, J. Li, and Z. Su. Backto the future A framework for automatic malwareremoval and system repair. In Proceedings of the 22ndAnnual Computer Security Applications ConferenceACSAC06, December 2006.22 The IDA Pro Disassembler and Debugger.httpwww.datarescue.comidabase.23 S. T. King and P. M. Chen. Backtracking intrusions.In Proceedings of the 19th ACM Symposium onOperating Systems Principles SOSP03, pages223236, October 2003.24 A. Moser, C. Kruegel, and E. Kirda. Exploringmultiple execution paths for malware analysis. InProceedings of the 2007 IEEE Symposium on Securityand PrivacyOakland07, May 2007.25 A. Moshchuk, T. Bragin, S. D. Gribble, and H. M.Levy. A crawlerbased study of spyware in the web. InProceeding of the 13th Network and DistributedSystem Security NDSS06, February 2006.26 J. Newsome and D. Song. Dynamic taint analysis forautomatic detection, analysis, and signaturegeneration of exploits on commodity software. InProceedings of the 12th Annual Network andDistributed System Security Symposium NDSS05,February 2005.27 T. Ormandy. An Empirical Study into the SecurityExposure to Host of Hostile Virtualized Environments.httptaviso.decsystem.orgvirtsec.pdf.28 G. Portokalidis, A. Slowinska, and H. Bos. Argos anemulator for fingerprinting zeroday attacks. InEuroSys 2006, April 2006.29 Qemu. httpfabrice.bellard.free.frqemu.30 F. Qin, S. Lu, and Y. Zhou. Safemem ExploitingECCmemory for detecting memory leaks and memorycorruption during production runs. In Proceedings ofthe 11th International Symposium onHighPerformance Computer Architecture HPCA05,February 2005.31 F. Qin, C. Wang, Z. Li, H. seop Kim, Y. Zhou, andY. Wu. LIFT A lowoverhead practical informationflow tracking system for detecting general securityattacks. In Proceedings of the 39th AnnualIEEEACM International Symposium onMicroarchitecture MICRO06, December 2006.32 Rootkit revealer. httpwww.sysinternals.comFilesRootkitRevealer.zip.33 J. Rutkowska. System virginity verifier Defining theroadmap for malware detection on windows systems.In Hack In The Box Security Conference, September2005. httpwww.invisiblethings.orgpapershitb05virginityverifier.ppt.34 Sonys DRM Rootkit The Real Story.httpwww.schneier.comblogarchives200511sonysdrmrootk.html.35 G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas.Secure program execution via dynamic informationflow tracking. In Proceedings of the 11th InternationalConference on Architectural Support for ProgrammingLanguages and Operating Systems ASPLOS04,October 2004.36 The Sleuth Kit TSK.httpwww.sleuthkit.orgsleuthkit.37 A. Vasudevan and R. Yerraballi. Cobra FinegrainedMalware Analysis using Stealth LocalizedExecutions.In Proceedings of 2006 IEEE Symposium on Securityand Privacy Oakland06, may 2006.38 P. Vogt, F. Nentwich, N. Jovanovic, E. Kirda,C. Kruegel, and G. Vigna. CrossSite ScriptingPrevention with Dynamic Data Tainting and StaticAnalysis. In Proceeding of the Network and DistributedSystem Security Symposium NDSS07, February2007.39 Y.M. Wang, R. Roussev, C. Verbowski, A. Johnson,M.W. Wu, Y. Huang, and S.Y. Kuo. GatekeeperMonitoring AutoStart Extensibility Points ASEPsfor spyware management. In Proceedings of the LargeInstallation System Administration ConferenceLISA04, November 2004.
