Integrating Flexible Support for Security Policies into the Linux OperatingSystemPeter Loscocco, NSA, loscoccotycho.nsa.govStephen Smalley, NAI Labs, ssmalleynai.comAbstractThe protection mechanisms of current mainstream operating systems are inadequate to support confidentialityand integrity requirements for end systems. Mandatoryaccess control MAC is needed to address such requirements, but the limitations of traditional MAC have inhibited its adoption into mainstream operating systems.The National Security Agency NSA worked with Secure Computing Corporation SCC to develop a flexible MAC architecture called Flask to overcome the limitations of traditional MAC. The NSA has implementedthis architecture in the Linux operating system, producing a SecurityEnhanced Linux SELinux prototype, tomake the technology available to a wider communityand to enable further research into secure operating systems. NAI Labs has developed an example security policy configuration to demonstrate the benefits of the architecture and to provide a foundation for others to use.This paper describes the security architecture, securitymechanisms, application programming interface, security policy configuration, and performance of SELinux.1 IntroductionEnd systems must be able to enforce the separationof information based on confidentiality and integrity requirements to provide system security. Operating system security mechanisms are the foundation for ensuring such separation. Unfortunately, existing mainstreamoperating systems lack the critical security feature required for enforcing separation mandatory access control MAC 17. Instead, they rely on discretionary access control DAC mechanisms. As a consequence, application security mechanisms are vulnerable to tampering and bypass, and malicious or flawed applications caneasily cause failures in system security.DAC mechanisms are fundamentally inadequate forstrong system security. DAC access decisions are onlybased on user identity and ownership, ignoring othersecurityrelevant information such as the role of the user,the function and trustworthiness of the program, and thesensitivity and integrity of the data. Each user has complete discretion over his objects, making it impossible toenforce a systemwide security policy. Furthermore, every program run by a user inherits all of the permissionsgranted to the user and is free to change access to theusers objects, so no protection is provided against malicious software. Typically, only two major categoriesof users are supported by DAC mechanisms, completelytrusted administrators and completely untrusted ordinaryusers. Many system services and privileged programsmust run with coarsegrained privileges that far exceedtheir requirements, so that a flaw in any one of theseprograms can be exploited to obtain complete system access.By adding MAC mechanisms to the operating system,these vulnerabilities can be addressed. MAC access decisions are based on labels that can contain a variety ofsecurityrelevant information. A MAC policy is definedby a system security policy administrator and enforcedover all subjects processes and objects e.g. files, sockets, network interfaces in the system. MAC can supporta wide variety of categories of users on a system, and itcan confine the damage that can be caused by flawed ormalicious software.Traditional MAC mechanisms have typically beentightly coupled to a multilevel security MLS 7 policy which bases its access decisions on clearances forsubjects and classifications for objects. This traditionalapproach is too limiting to meet many security requirements 8, 9, 10. It provides poor support for data andapplication integrity, separation of duty, and least privilege requirements. It requires special trusted subjectsthat act outside of the access control model. It fails totightly control the relationship between a subject and thecode it executes. This limits the ability of the system tooffer protection based on the function and trustworthiness of the code, to correctly manage permissions required for execution, and to minimize the likelihood ofmalicious code execution.To address the limitations of traditional MAC, the National Security Agency NSA, with the help of SecureComputing Corporation SCC, began researching newways to provide strong mandatory access controls thatcould be acceptable for mainstream operating systems.An important design goal for the NSA was to provideflexible support for security policies, since no singleMAC policy model is likely to satisfy everyones security requirements. This goal was achieved by cleanlyseparating the security policy logic from the enforcement mechanism. Through the development of twoMachbased prototypes, DTMach 12 and DTOS 20,the NSA and SCC developed a strong, flexible securityarchitecture. Although high assurance was not a goal ofthe research, formal methods were applied to the designto help validate the security properties of the architecture 23, 24. Likewise, performance optimization wasnot a goal, but significant steps were taken in the architecture to minimize the performance overhead normallyassociated with MAC. NSA and SCC then worked withthe University of Utahs Flux research group to transfer the architecture to the Fluke research operating system 25. During the transfer, what has become the Flaskarchitecture was enhanced to provide better support fordynamic security policies.The NSA created SecurityEnhanced Linux, orSELinux for short, by integrating this enhanced architecture into the Linux operating system. It has been applied to the major subsystems of the Linux kernel, including the integration of mandatory access controls foroperations on processes, files, and sockets. NAI Labshas since joined the effort and has implemented several additional kernel mandatory access controls, including controls for the procfs and devpts file systems. TheMITRE Corporation and SCC have contributed to thedevelopment of some application security policies andhave modified utility programs, but their contributionsare not discussed further in this paper.Using the flexibility of SELinux, it is possible to configure the system to support a wide variety of securitypolicies. The system can support separation policies that can enforce legal restrictions on data, establish welldefined user roles, orrestrict access to classified data, containment policies useful for such things as restricting web server access to only authorized dataand minimizing damage caused by viruses andother malicious code, integrity policies that are capable of protectingunauthorized modifications to data and applications, and invocation policies that can guarantee data is processed as required.The flexibility of SELinux meets the goal of enablingmany different models of security to be enforced withthe same base system.The NSA released the SELinux to make the technology available to a wider community and enable furtherresearch into secure operating systems. To help introduce the system in a more immediately useful form thathelps demonstrate the added value of SELinux, NSAcontracted NAI Labs to develop an example security policy configuration for the system designed to meet a number of common generalpurpose security objectives. Theexample configuration greatly reduces the complexity ofSELinux that would otherwise be present if building thepolicy specification from scratch were required. The example configuration released with the SELinux providesa customizable foundation with which a secure systemcan be built.The remainder of this paper describes SELinux. Itbegins by providing an overview of the Flask architecture and its SELinux implementation in Section 2. Thesecurity mechanisms added to the system are then described in Section 3. The SELinux application programming interface API is discussed in Section 4. Section 5describes the example security policy configuration created for the system. The performance overhead of theSELinux mechanisms is described in Section 6. Relatedwork is discussed in Section 7.2 Security ArchitectureThis section provides an overview of the Flask architecture and the SELinux implementation of the architecture. The Flask architecture provides flexible supportfor mandatory access control policies. In a system withmandatory access controls, a security label is assignedto each subject and object. All accesses from a subjectto an object or between two subjects must be authorizedby the policy based on these labels. The Flask architecture cleanly separates the definition of the policy logicfrom the enforcement mechanism. The security policylogic is encapsulated within a separate component of theoperating system with welldefined interfaces for obtaining security policy decisions. This separate componentis referred to as the security server due to its origins asa userspace server running on a microkernel. In theSELinux implementation, the security server is merelya kernel subsystem.Components in the system that enforce the securitypolicy are referred to as object managers in the Flaskarchitecture. Object managers are modified to obtain security policy decisions from the security server and toapply these decisions to label and control access to theirobjects. In the SELinux implementation, the other kernel subsystems e.g. process management, filesystem,socket IPC, System V IPC are object managers. Application object managers can also be supported, such as awindowing system or a database management system.The Flask architecture also provides an access vector cache AVC component that stores the access decision computations provided by the security server forsubsequent use by the object managers. The AVC component also supports revocation of permissions, as described later in Section 2.4. An object manager may further reduce the cost of a permission check by storingreferences to the appropriate entry in the AVC with itsobjects. As a result, most permission checks can occurwithout even incurring the cost of an extra function call.The remainder of this section further elaborates on theFlask architecture and its SELinux implementation. Itbegins by discussing how security labels are encapsulated in Flask. This section then discusses how Flasksupports flexibility in labeling and access decisions. Theability of Flask to support policy changes is then described.2.1 Encapsulation of Security LabelsSince the content and format of security labels aredependent on the particular security policy, the Flaskarchitecture defines two policyindependent data typesfor security labels the security context and the securityidentifier. A security context is a variablelength stringrepresentation of the security label. Internally, the security server stores a security context as a structure using a private data type. A security identifier SID or security id t is an integer that is mapped by the securityserver to a security context. Flask object managers areresponsible for binding security labels to their objects,so they bind SIDs to active kernel objects. The file system object manager must also maintain a persistent binding between files and security contexts. Since the objectmanagers handle SIDs and security contexts opaquely, achange in the format or content of security labels doesnot require any changes to the object managers.The Flask architecture merely specifies the interfacesprovided by the security server to the object managers.The implementation of the security server, includingany policy language it may support, are not specifiedby the architecture. The SELinux example securityserver defines a security policy that is a combinationof Type Enforcement TE 8, rolebased access control RBAC 11, and optionally multilevel securityMLS 7. The example configuration for the TE andRBAC policy components is described in Section 5. TheSELinux example security server defines a security context as containing a user identity, a role, a type, and optionally a MLS level or range. Roles are only relevantfor processes, so file security contexts have a genericobject r role. The security server only provides SIDs forsecurity contexts with legal combinations of user, role,type, and level or range. The individual attributes of theint securitytransitionsidsecurityidt ssid,securityidt tsid,securityclasst tclass,securityidt outsidret  securitytransitionsidcurrentsid,dirisid,SECCLASSFILE,sidFigure 1 Interface and example call to obtain a security label. Theinput parameters are the subject SID, the SID of a related object e.g.the parent directory, and the class of the new object. The SID for thenew object is returned as an output parameter.security context are not manipulated by the object managers.The user identity attribute in the security context is independent of the ordinary Linux user identity attributes.Modifications to the Linux login program and cron daemon are provided to set this new user identity attributeappropriately for login sessions and user cron jobs. Byusing a separate user identity attribute, the SELinuxmandatory access controls remain completely orthogonal to the existing Linux access controls. SELinux canenforce rigorous controls over changes in its user identity attribute without affecting compatibility with existing applications.2.2 Flexibility in Labeling DecisionsWhen a Flask object manager requires a label for anew object, it consults the security server to obtain a labeling decision based on the label of the creating subject,the label of a related object, and the class of the new object. For program execution, the Flask process managerobtains the label for the transformed process based onthe current label of the process and the label of the program executable. For file creation, the Flask file systemobject manager obtains the label for the new file basedon the label of the creating process, the label of the parent directory, and the kind of file being created. The security server may compute the new label based on theseinputs and may also use other external information. Figure 1 shows the security servers security transition sidinterface for obtaining a label and an example call to thisinterface to obtain the label of a new file.The SELinux example security server may be configured to automatically cause changes in the role or domain attributes of a process based on the role and domainof the process and the type of the program. By default,the role and domain of a process is not changed by program execution. The SELinux security server may alsobe configured to use specified types for new files basedint securitycomputeavsecurityidt ssid,securityidt tsid,securityclasst tclass,accessvectort requested,accessvectort allowed,accessvectort decided,u32 seqnoFigure 2 Interface for obtaining access decisions from the security server. The input parameters are a pair of SIDs, the class of theobject, and the set of requested permissions. The pair of SIDs maybe subjecttoobject, subjecttosubject, or even objecttoobject. Thegranted permissions are returned as output parameters.on the domain of the process, the type of the parent directory, and the kind of file. A new file inherits the sametype as its parent directory by default. For objects wherethere is only one relevant SID, object managers typicallydo not consult the security server. Instead, they merelyuse this SID as the SID for the new object. Pipes, filedescriptions, and sockets inherit the SID of the creating process, and output messages inherit the SID of thesending socket.2.3 Flexibility in Access DecisionsObject managers consult the AVC to check permissions based on a pair of labels and an object class,and the AVC obtains access decisions from the securityserver as needed. Figure 2 shows the security serverssecurity compute av interface for obtaining access decisions. Figure 3 shows the AVCs avc has perm ref interface for checking permissions and an example call tothis interface to check bind permission to a socket.Each object class has a set of associated permissions.These permission sets are represented by a bitmap calledan access vector access vector t. Flask defines a distinct permission for each service, and when a service accesses multiple objects, Flask defines a separate permission to control access to each object. For example, whena file is unlinked, Flask checks remove name permissionto the directory and unlink permission to the file.The use of object classes in access requests allows distinct permission sets to be defined for each kind of object based on the particular services that are supportedby the object. It also allows the security policy to makedistinctions based on the kind of object, so that accessto a device special file can be distinguished from accessto a regular file and access to a raw IP socket can bedistinguished from access to a UDP or TCP socket.2.4 Support for Policy ChangesThe Flask AVC provides an interface to the security server for managing the cache as needed for policychanges. Sequence numbers are used to address the poextern inlineint avchaspermrefsecurityidt ssid,securityidt tsid,securityclasst tclass,accessvectort requested,avcentryreft aerefret  avchaspermrefcurrentsid,sksid, sksclass,SOCKETBIND,skavcrFigure 3 AVC interface and example call to check permissions.The input parameters are the same as for security compute av, exceptfor the additional aeref parameter. On its first use, the aeref parameteris set to refer to the AVC entry used for the permission check, and onsubsequent checks this reference is used to optimize the lookup. Thereference is revalidated on each use to ensure its correctness.tential interleaving of access decision computations andpolicy change notifications. When the AVC receives apolicy change notification, it updates its own state andthen invokes callback functions registered by the objectmanagers to update any permissions retained in the stateof the object managers. For example, permissions maybe retained in the access rights in page tables or in theflags on an open file description. After updating the stateof the object managers and the state of the AVC to conform to the policy change, the AVC notifies the securityserver that the transition to the new policy has been completed.In SELinux, many permissions are revalidated on use,such as permissions for reading and writing files andpermissions for communicating on an established connection. Consequently, policy changes for these permissions are automatically recognized and enforced withoutthe need for object manager callbacks. Permissions canbe efficiently revalidated by object managers using references to entries in the AVC. However, the revalidationof permissions on use is not adequate for revoking access to mapped file pages in the Linux page cache. Thecurrent SELinux implementation does invalidate the appropriate page cache entries when a file is relabeled, buta callback has not yet been defined to invalidate the appropriate page cache entries when a policy change notification is received.The SELinux example security server provides an interface for changing the security policy configuration atruntime. The security load policy call may be used toread a new policy configuration from a file. After loading the new policy configuration, the security server updates its SID mapping, invalidating any SIDs that areno longer authorized, and resets the AVC. Subsequentpermission checks on processes and objects with invalidPERMISSIONS DESCRIPTIONexecute Executetransition Change labelentrypoint Enter via programsigkill Signalsigstopsigchldsignalfork Forkptrace Tracegetsched Get schedule infosetsched Set schedule infogetsession Get sessiongetpgid Get process groupsetpgid Set process groupgetcap Get capabilitiessetcap Set capabilitiesTable 1 Permissions for the process object class.SIDs always fail, preventing any further accesses bysuch processes and any further accesses to such objects.Support for automatically relabeling these processes andobjects to a label that is accessible to administrators hasnot yet been implemented.3 Security MechanismsThis section describes the security mechanisms defined by the Flask architecture and the SELinux implementation of these mechanisms. It begins with a discussion of the mandatory access controls for process management. Mandatory access controls for file system objects are then described. This section concludes with adiscussion of socket mandatory access controls.3.1 Process ControlsTable 1 shows the permissions defined for the processmanagement component. The process execute permission is used to control the ability of a process to execute from a given executable image. This permissionis checked between the label of the transformed processand the label of the executable on every program execution. It is also checked when an ELF or script interpreteris executed, and when a file is memorymapped with execute access i.e. a shared library. This process executepermission is distinct from the file execute permissionwhich is used to control the ability of a process to initiate the execution of a program.The transition permission is used to control the ability of a process to transition from one security identifierSID to another. The entrypoint permission is used tocontrol what programs may be used as the entry pointfor a given process SID. This permission is similar tothe process execute permission, except that it is onlychecked when a process transitions to a new SID. Hence,the security policy can distinguish between what programs may be used to initially enter a given process SIDand the full set of programs that may be executed by thatprocess SID.This entrypoint permission is especially necessary inan environment with shared libraries, since most processes must be authorized to execute the system dynamicloader. Without separate control over entry point programs, any security label could be entered by executingthe system dynamic loader. Separate entry point controlis also necessary in order to support security label transitions on scripts, since the new security label must beauthorized to execute the interpreter and the script.Separate permissions for each signal could easily bedefined, but until empirical evidence suggests this is necessary, this will not be done. Separate permissions weredefined for the SIGKILL and SIGSTOP signals, sigkill,sigstop respectively, since these signals cannot be caughtor ignored. A separate permission, sigchld was also defined to control the SIGCHLD signal because experiencedemonstrated that it was useful to control this signal separately. A single permission, signal, is used to controlthe remaining signals.The ptrace permission is used to control the abilityof a process to trace another process. The getsched,setsched, getsession, getpgid, setpgid, getcap, and setcap permissions are used to control the ability of a process to observe or modify the corresponding attributes ofanother process.In addition to the permissions listed in this table,SELinux provides an equivalent permission for eachLinux capability. This allows the security policy to control the use of capabilities based on the SID of the process. SELinux could also be extended to provide a finergrained replacement mechanism for capabilities. Such amechanism was developed for one of SELinuxs predecessors, the DTOS system 20. This mechanism permitted privileges to be granted based on both the attributes of the process and the attributes of the relevantobject, e.g. discretionary read override could be grantedto a particular set of files. Since the mechanism obtained privilege decisions from the security server, management of privileges was centralized and verificationthat privileges were granted appropriately was straightforward.3.2 File ControlsTable 2 lists the permissions for controlling accessto open file description objects. Since open file descriptions may be inherited across execve or transferredthrough UNIX socket IPC, SELinux labels and controlsopen file descriptions. An open file description is labeledwith the SID of its creating process, since its state is usuPERMISSIONS DESCRIPTIONcreate Creategetattr Get attributessetattr Set attributesinherit Inherit across execvereceive Receive via IPCTable 2 Permissions for the open file description object class.ally treated as part of the private state of the process. Itis important to distinguish between the label of an openfile description and the label of the file it references. Aread operation on a file changes the file offset in the openfile description, so it may be necessary to prevent a process from reading a file using an open file descriptionreceived or inherited from another process even thoughthe process is allowed to directly open and read the file.Permissions for controlling access to file systems areshown in Table 3. SELinux labels file systems andcontrols services that manipulate file systems, including calls for mounting and unmounting file systems, thestatfs call and the file creation calls. SELinux controlsthe mounting of file systems through several permissionchecks. It requires that the process have mounton permission to the mount point directory and mount permission to the file system. It also requires that the mountassociate permission be granted between the root directoryof the file system and the mount point directory.SELinux binds security labels to files and directoriesand controls access to them. It stores a persistent labeling table in each file system that specifies the security label for each file and directory in that file system. For efficient storage, SELinux assigns an integer value referredto as a persistent SID PSID to each security label usedby an object in a file system. The persistent labeling table is partitioned into a mapping between each PSID andits security label and a mapping between each object andits PSID. Since the table is stored in each file system, filelabels are preserved if the file system is mounted at a different location or if the file system is moved to a differentsystem.The mapping between each PSID and its security label is implemented using regular files in a fixed subdirectory of the root directory of each file system. Thismapping is loaded into memory when the file system ismounted, and is updated both in memory and on the diskwhen a new security label is used for an object in the filesystem. The mapping between each object and its PSIDis implemented by storing the PSID in an unused field ofthe ondisk inode. Since the PSID is available in the ondisk inode, no extra overhead is incurred either to obtainthe PSID when a file is accessed or to set the PSID whena file is created. Additionally, since the mapping bePERMISSIONS DESCRIPTIONmount Mountremount Change optionsunmount Unmountgetattr Get attributesrelabelfrom Relabelrelabeltotransitionassociate Associate fileTable 3 Permissions for the file system object class.tween each object and its PSID is inodebased, changesto the file system name space do not affect the mapping.SELinux currently only implements file labeling forthe ext2 file system. However, only the binding betweenondisk inodes and PSIDs is filesystemspecific, so support for other local file system types can be easily added.For NFS file systems, a single label is currently used forall files mounted from a given NFS server. A designhas been developed to provide complete file labeling andcontrols for NFS filesystems, but this design has not yetbeen implemented. SELinux also implements file labeling for the special procfs and devpts file systems basedon the labels of the associated process, but these specialfile system types do not require the use of persistent labelmappings.When an unlabeled file system is first mounted, a persistent labeling table is created for the file system, using a default label for all files obtained from the securityserver. Subsequently, existing files may be relabeled using new system calls. A program called setfiles isused to initially set file labels from a configuration filethat specifies labels based on pathname regular expressions. This program and configuration file may also beused to reset file labels to a welldefined state. However,unless the configuration file is updated to reflect runtimechanges in file labels, these changes will be lost whenthe program is executed. Runtime changes may occur asa result of new files being created, existing files beingrelabeled, or changes to the name space.Table 4 shows the permissions defined for controlling access to files, and Table 5 shows the additionalpermissions defined for controlling access to directories.SELinux defines a separate permission for each file anddirectory service. For example, SELinux defines an append permission for files in addition to the write permission, and it defines separate add name and remove namepermissions for directories to support appendonly filesand directories. SELinux also defines a reparent permission for directories that controls whether the parentdirectory link can be changed by a rename.SELinux provides control over each object affectedby a file or directory service. For example, in addition toPERMISSIONS DESCRIPTIONread Readwrite Write or appendappend Appendpoll Pollselectioctl IO controlcreate Createexecute Executeaccess Check accessibilitygetattr Get attributessetattr Set attributesunlink Remove hard linklink Create hard linkrename Rename hard linklock Lock or unlockrelabelfrom RelabelrelabeltotransitionTable 4 Permissions for the pipe and file object classes.checking access to the parent directory, SELinux definespermissions for controlling access to the individual fileitself for operations such as stat, link, rename, unlink,and rmdir.3.3 Socket ControlsSELinux provides control over socket IPC through aset of layered controls over sockets, messages, nodes,and network interfaces. Currently, the SELinux prototype only provides labeling and controls for INET andUNIX domain sockets. At the socket layer, SELinuxcontrols the ability of processes to perform operationson sockets. At the transport layer, SELinux controls theability of sockets to communicate with other sockets. Atthe network layer, SELinux controls the ability to sendand receive messages on network interfaces, and it controls the ability to send messages to nodes and to receivemessages from nodes. SELinux also controls the ability of processes to configure network interfaces and tomanipulate the kernel routing table.Since sockets are accessed through file descriptions,the socket object classes inherit the permissions definedfor controlling access to the file object classes. Only asubset of these permissions are meaningful for sockets.Table 6 shows additional permissions that are specifically defined for controlling access to the socket objectclasses. The connectionoriented service provided bystream sockets requires several additional permissions,as shown in Table 7. Permissions for network interfacesand nodes are shown in Table 8.Sockets effectively serve as communication proxiesfor processes in the SELinux control model. Consequently, sockets are labeled with the label of the creating process by default. A process may create and use asocket with a different label to perform socket IPC withPERMISSIONS DESCRIPTIONadd name Add a nameremove name Remove a namereparent Change parent directorysearch Searchrmdir Removemounton Use as mount pointmountassociateTable 5 Additional permissions for the directory object class.PERMISSIONS DESCRIPTIONbind Bind namename bind Use port or fileconnect Initiate connectiongetopt Get socket optionssetopt Set socket optionsshutdown Shut down connectionrecvfrom Receive from socketsendto Send to socketrecv msg Receive messagesend msg Send messageTable 6 Additional permissions for the socket object classes.PERMISSIONS DESCRIPTIONlisten Listen for connectionsaccept Accept a connectionnewconn Create new socket for connectionconnectto Connect to server socketacceptfrom Accept connection from client socketTable 7 Additional permissions for the TCP and Unix streamsocket object classes.PERMISSIONS DESCRIPTIONgetattr Get attributessetattr Set attributestcp recv Receive TCP packettcp send Send TCP packetudp recv Receive UDP packetudp send Send UDP packetrawip recv Receive Raw IP packetrawip send Send Raw IP packetTable 8 Permissions for the network interface and node objectclasses.a different source security label. A process may set upa listening socket so that server sockets created by connections are labeled with either a specified label or withthe label of the connecting client socket to act as a serverfor multiple labels.SELinux allows the security policy to distinguish between clients and servers for stream socket connections through the connectto and acceptfrom permissions.SELinux allows the security policy to base decisions onthe kind of socket through the use of object classes, andit allows the security policy to base decisions on the message protocol through the perprotocol node and networkinterface permissions.SELinux provides control over the association between INET domain sockets and port numbers and theassociation between UNIX domain sockets and files.Hence, the security policy can restrict the use of portnumbers and pathnames for use by particular processes.SELinux also provides control over open file descriptiontransfer via UNIX domain sockets.In SELinux, messages are associated with both the label of their sending socket and a separate message label.By default, this message label is the same as the sendingsocket label. A process may explicitly label individualmessages if the underlying protocol supports messageboundaries, i.e. datagram sockets. Messages sent on astream socket all have the same label, which is the labelof the stream socket.Support for communicating message labels across thenetwork has not yet been implemented in SELinux. TheFluke implementation of the Flask architecture usedIPSECISAKMP both to label and protect messages,storing the labeling information in the IPSEC security association. During an ISAKMP negotiation, theappropriate security contexts are sent across the network and the peer obtains SIDs for these security contexts and stores them in its IPSEC security association. When messages are subsequently received that usethe IPSEC security association, the messages are validated and then labeled with the SIDs from the association. Similar support will be provided in SELinux usingthe FreeSWAN 14 IPSEC implementation. IntegratingFreeSWAN with the SELinux network mandatory accesscontrols is the next major phase for SELinux development.4 Application Programming InterfaceTypically, the SELinux mandatory access controls operate transparently to applications and users. The labeling decisions of the Flask architecture provide appropriate default behaviors so that the existing Linux application programming interface API calls can be left unchanged. The mandatory access controls are only visible to applications and users upon access failures, inwhich case they return the normal Linux error codese.g. EACCES, EPERM, ECONNREFUSED, ECONNRESET for such failures. In most cases, the potential forthese same error conditions already existed with the ordinary Linux kernel, so most applications should handlethese conditions. Only a few controls, such as the controls on individual read and write calls, can cause accessfailures where an access failure was not previously possible.Although existing applications can be used unmodified, it is desirable to provide new API calls to allowmodified and new applications to be developed that havesome degree of awareness of the new security features.Each SELinux kernel subsystem provides a set of newAPI calls that extend existing API calls with additionalparameters for SIDs. The process management subsystem provides calls to get the current and old SIDs of aprocess, and a call to execute a program with a specifiedSID. The filesystem subsystem provides calls to createfiles with particular SIDs, calls to obtain the SIDs of filesand filesystems, and calls to change the SIDs of files andfile systems. The socket IPC subsystem provides calls tocreate sockets and messages with particular SIDs, callsto obtain the SIDs of sockets and messages, and calls tospecify the desired SID for peer sockets. The same set ofcontrols used for the existing API calls are also appliedto these extended API calls, with the only difference being the use of an applicationprovided SID rather than adefault SID.Applications that use these new calls need to be ableto convert between SIDs and security contexts. Furthermore, it is desirable to allow applications to obtain security policy decisions from the security server so thatsecurity policies can be defined that control access toapplication abstractions. For example, a windowing system might be enhanced to provide labeling and separation of windows, with controlled cutandpaste betweenwindows, or a database system might be enhanced toprovide labeling and separation of individual databaserecords maintained in a single file. Such applicationpolicy enforcers would still be controlled by the kernelmandatory access controls but could further refine thegranularity of protection provided by the kernel. To support such applications, the security server provides a setof new API calls that export its services for convertingbetween SIDs and contexts and obtaining security policy decisions. A set of controls is defined for these newAPI calls to ensure that the policy can control the abilityto use them. An application access vector cache librarycould easily be created based on the SELinux kernel access vector cache implementation to provide security decision caching for applications.5 Security Policy ConfigurationThis section describes the example security policyconfiguration that has been developed for the SecurityEnhanced Linux. At a high level, the goals of the example security policy configuration are to demonstratethe flexibility and security of the mandatory access controls and to provide a simple working system with minimal modifications to applications. The example securitypolicy configuration consists of a combination of RoleBased Access Control RBAC 11 and Type Enforcement 8. The configuration draws from the Domainand Type Enforcement DTE configuration describedin 26, although it uses a different configuration language described in 16.The example security policy configuration defines aset of Type Enforcement domains and types. Each process has an associated domain, and each object has an associated type. The policy configuration specifies the allowable accesses by domains to types and the allowableinteractions among domains. It specifies what programtypes can be used to enter each domain and the allowable transitions between domains. It also specifies automatic transitions between domains when certain program types are executed. These transitions ensure thatsystem processes and certain programs are placed intotheir own separate domains automatically.The configuration also defines a set of roles. Eachprocess has an associated role. All system processes runin the system r role. Two roles are currently defined forusers, user r for ordinary users and sysadm r for system administrators. These user roles are initially set bythe login program and can be changed by a newroleprogram similar to the su program.The policy configuration specifies the set of domainsthat can be entered by each role. Each user role hasan associated initial login domain, the user t domainfor the user r role and the sysadm t domain for thesysadm r role. This initial login domain is associatedwith the users initial login shell. As the user executesprograms, transitions to other domains may automatically occur to support changes in privilege. Often, theseother domains are derived from the users initial logindomain. For example, the user t domain transitions tothe user netscape t domain and the sysadm t domaintransitions to the sysadm netscape t domain when thenetscape program is executed to restrict the browserto a subset of the users permissions.Figure 4 shows a portion of the policy configurationthat allows the administrator domain sysadm t to runthe insmod program to insert kernel modules. The insmod program is labeled with the insmod exec t type andruns in the insmod t domain. The first rule allows thesysadm t domain to run the insmod program. The secallow sysadmt insmodexectfile xfilepermsallow sysadmt insmodtprocess transitionallow insmodt insmodexectprocess  entrypoint execute allow insmodt sysadmtfd inheritfdpermsallow insmodt selfcapability sysmoduleallow insmodt sysadmtprocess sigchldFigure 4 Configuration for running insmod.ond rule allows the sysadm t domain to transition to theinsmod t domain. The third rule allows the insmod t domain to be entered by the insmod program and to executecode from this program. The fourth rule allows the insmod t domain to inherit and use file descriptors from thesysadm t domain. The fifth rule allows the insmod t domain to use the CAP SYS MODULE capability. The lastrule allows the insmod t domain to send the SIGCHLDsignal to sysadm t when it exits.From this small portion of the policy configuration, itis clear that the flexibility of the mandatory access controls also yields a corresponding increase in the complexity of managing the security policy. Creating andmaintaining a configuration to meet a set of security requirements and verifying that the configuration is consistent with those requirements can be a challengingtask. In order for SELinux to be widely deployed andused, a collection of base policy configurations must bedeveloped to meet common sets of security requirementsto allow its use by end users with no security expertise.Furthermore, higherlevel configuration languages andpolicy analysis tools are needed to address these challenges.The security policy configuration controls variousforms of raw access to data. The policy configurationdefines distinct types for kernel memory devices, diskdevices, and prockcore. It defines separate domains for processes that require access to these types,such as klogd t and fsadm t.The configuration protects the integrity of the kernel.The policy configuration defines distinct types for theboot files, module object files, module utilities, moduleconfiguration files and sysctl parameters, and it definesseparate domains for processes that require write accessto these files. As illustrated by the example in Figure 4,the configuration defines separate domains for the module utilities, and it restricts the use of the module capability to these domains. It only allows a small set ofprivileged domains to transition to the module utility domains.The integrity of system software, system configuration information and system logs is protected by theconfiguration. The policy configuration defines distincttypes for system libraries and binaries to control accessto these files. It only allows administrators to modifysystem software. It defines separate types for systemconfiguration files and system logs and defines separatedomains for programs that require write access.The configuration confines the potential damage thatcan be caused through the exploitation of a flaw in a process that requires privileges, whether a system processor privilegeenhancing setuid or setgid program. Thepolicy configuration places these privileged system processes and programs into separate domains, with eachdomain limited to only those permissions it requires.Separate types for objects are defined in the policy configuration as needed to support least privilege for thesedomains.Privileged processes are protected from executing malicious code. The policy configuration defines an executable type for the program executed by each privilegedprocess and only allows transitions to the privileged domain by executing that type. When possible, it limitsprivileged process domains to executing the initial program for the domain, the system dynamic linker, and thesystem shared libraries. The administrator domain is allowed to execute programs created by administrators aswell as system software, but not programs created by ordinary users or system processes.The configuration ensures that the administrator roleand domain cannot be entered without user authentication. The policy configuration only allows transitions tothe administrator role and domain by the login program, which requires the user to authenticate beforestarting a shell with the administrator role and domain.It prevents transitions to the administrator role and domain by remote logins to prevent unauthenticated remotelogins via .rhosts files. A newrole program wasadded to permit authorized users to enter the administrator role and domain during a remote login session, andthis program reauthenticates the user. To provide confidentiality of secret authentication information, the policy configuration labels the shadow password file withits own type and restricts the ability to read this type toauthorized programs such as login and su.Ordinary user processes are prevented from interfering with system processes or administrator processes.The policy configuration only allows certain system processes and administrators to access the procfs entries ofprocesses in other domains. It controls the use of ptraceon other processes, and it controls signal delivery between domains. It defines separate types for the homedirectories of ordinary users and the home directories ofadministrators. It ensures that files created in shared directories such as tmp are separately typed based on thecreating domain. It defines separate types for terminalsbased on the owners domain.The configuration protects users and administratorsfrom the exploitation of flaws in the netscape browserby malicious mobile code. The policy configurationplaces the browser into a separate domain and limits itspermissions. It defines a type that users can use to restrict read access by the browser to local files, and it defines a type that users can use to grant write access tolocal files.6 PerformanceThis section discusses the impact of the SELinux security mechanisms on the performance of the the Linuxkernel. The set of benchmarks used was influenced bythe Linux Benchmarking HOWTO 6. Microbenchmarktests were performed to determine the performance overhead due to the SELinux changes for various lowlevelsystem operations. Macrobenchmark tests were performed to determine the impact of the SELinux changeson the performance of typical workloads.Each test was performed with two different kernelconfigurations. The base kernel configuration corresponds to an unmodified Linux 2.4.2 kernel. This configuration was measured to provide the performancebaseline for each benchmark. The selinux configurationcorresponds to an enforcing SecurityEnhanced Linux2.4.2 kernel. The performance measurements of theselinux configuration can be compared against the baseline to determine the overhead imposed by the SELinuxsecurity mechanisms.6.1 MicrobenchmarksThe microbenchmark tests were drawn from theUnixBench 4.1.0 benchmark 21 and the lmbench 2benchmark 18 suites. These microbenchmark testswere used to determine the performance overhead of theSELinux changes for various process, file, and socketlowlevel operations. These benchmarks were executedon a 333MHz Pentium II with 128M RAM. The lmbench network tests ran server programs on a 166MHzPentium with 64MB RAM. Both the client and servermachines ran the same kernel for the lmbench networkbenchmarks so that the results show the total cost of theSELinux overhead on both systems.6.1.1 UnixBench The results for the UnixBench system microbenchmarks are shown in Table 9. The filecopy benchmark measures the rate at which data can betransferred from one file to another, using various buffersizes. For small buffer sizes, the system call overheaddominates the time to copy the file. The SELinux overhead consists of revalidating permissions for each readand write for the file copy. As the buffer size increases,the time to copy the file becomes dominated by the unafMicrobenchmark Base SELinux Overheadfile copy 4KB 49.5 48.6 2file copy 1KB 40.4 38.6 5file copy 256B 23.0 21.0 10pipe 6.17 7.17 16pipe switching 12.7 15.0 18process creation 485 494 2execl 2480 2610 5shell scripts 8 659 684 4Table 9 UnixBench system microbenchmarks. File copy throughput is in megabytes per second. The other UnixBench microbenchmarks are in microseconds per loop iteration or milliseconds for theshell scripts benchmark. These results were converted into units thatcan be more easily compared with the lmbench results.fected memory copying costs, so the SELinux overheadbecomes negligible.The pipe benchmark measures the number of timesa process can write 512 bytes to a pipe and read themback per second. The pipe switching benchmark measures the number of times two processes can exchangean increasing integer through a pipe. The SELinux overhead consists of revalidating permissions for each readand write on the pipe.The process creation test measures the number oftimes a process can fork and reap a child that immediately exits. The SELinux overhead consists of performing a permission check on each fork and wait operation.The execl benchmark measures the number of execl callsthat can be performed per second. The SELinux overhead consists of computing the label for the transformedprocess and performing permission checks for searchingthe path, executing the program, and inheriting open filedescriptions.The shell scripts test measures the number of timesper minute a process can start and reap a set of 8 concurrent copies of a shell script, where the shell script appliesa series of transformations to a data file. The SELinuxoverhead consists of computing the label for processesfor each program execution, computing the label for newfiles created by the scripts, and performing permissionchecks for the various process and file operations.6.1.2 lmbench The results for the lmbench microbenchmarks are shown in Table 10. The null IObenchmark measures the average of the times for aonebyte read from devzero and a onebyte write todevnull. The SELinux overhead consists of revalidating permissions on each read and write.The stat benchmarks measures the time to invoke thestat system call on a temporary file. The SELinuxoverhead consists of performing permission checks forsearching the path and obtaining the file attributes. Theopenclose test measures the time to open a temporaryMicrobenchmark Base SELinux Overheadnull IO 1.45 1.93 33stat 8.06 10.3 28openclose 11.0 14.0 270KB create 22.0 26.0 180KB delete 1.72 1.90 10fork 499 505 1execve 2730 2820 3sh 10K 11K 10pipe 12.5 14.0 12AF UNIX 20.6 24.6 19UDP 310 356 15RPCUDP 441 519 18TCP 389 425 9RPCTCP 667 726 9TCP connect 675 738 9Table 10 lmbench microbenchmarks. Measurements are in microseconds. Measurements below the bar represent roundtrip latencyfor various forms of IPC.file for reading and immediately close it. The SELinuxoverhead consists of performing permission checks forsearching the path and opening the file with read access.The 0K create and 0k delete benchmarks measure thetime required to create and delete a zerolength file. Forthe 0K create, the SELinux overhead consists of computing the label for the new file and performing permission checks for searching the path, modifying the directory, and creating the file. The SELinux overhead for the0K delete consists of performing permission checks forsearching the path, modifying the directory, and unlinking the file.The fork, execve, and sh benchmarks measure threeincreasingly expensive forms of process creation forkand exit, fork and execve, and fork and execlp of theshell with the new program as a command to the shell.For the fork benchmark, the SELinux overhead consists of permission checks on fork and wait, as withthe UnixBench process creation benchmark. For the execve benchmark, the SELinux overhead consists of thefork overhead plus the label computation and permission checks associated with program execution, as withthe UnixBench execl benchmark. For the sh benchmark,this overhead is further increased by the additional layerof process creation, program execution, and path searching by the shell.The remaining lmbench tests measure roundtrip latency in microseconds for various forms of interprocesscommunication between a pair of processes. The lmbench bandwidth benchmark results are omitted sincethey did not show any significant difference between thebase and selinux configurations, as expected.The SELinux overhead on the pipe benchmark consists of revalidating permissions on each read and write,as with the UnixBench pipe switching benchmark. Forthe AF UNIX benchmark, the SELinux overhead consists of checking permission to each socket and revalidating the permissions for the connection between thesockets on each send and receive. For each of the networking benchmarks, the SELinux overhead includeschecking permission to each socket, host, and networkinterface for each packet. The overhead for the UDP andRPCUDP benchmarks also includes checking permission between the socket pair on each send and receive.For the TCP and RPCTCP benchmarks, SELinux revalidates the permissions granted during connection establishment between the socket pair on each send and receive. The SELinux overhead for the TCP connectionbenchmark includes the permission checks between thesocket pair for the connection on connect and accept.6.1.3 Conclusion Although the percentage overheadfor some of the microbenchmark results is large, the realdifference in absolute times is typically quite small andbecomes insignificant for macro operations, as shownby the results in Section 6.2. Furthermore, these resultsmust be viewed as an upper bound on the performanceoverhead, since neither the AVC nor the security serverimplementation have been optimized. Other known areas where the performance could be improved includemaking better use of AVC entry references and improving the AVC locking scheme.6.2 MacrobenchmarksThe first macrobenchmark consisted of compiling theLinux 2.4.2 kernel sources, since this involves significant file system activity and is representative of a workload experienced commonly by Linux users. The second macrobenchmark was the WebStone 2.5 benchmarkfor web servers 19, which is representative of a typicalworkload for a web server.For the kernel compilation macrobenchmark, the timeto execute make was measured. The 2.4.2 kernelsources were configured with the default options, anda make dep was done prior to the testing. Three kernel compilations were performed, each immediately after a reboot into singleuser mode, and the results wereaveraged. This benchmark was executed on a 333MHzPentium II with 128M RAM.For the WebStone macrobenchmark, one hundred 10minute trials were run with 32 web clients requestingthe standard WebStone file set. A Sun Ultra 5 runningSunOS 5.6 with 128M RAM was used as the test controller and client machine. This machine was directlyconnected using a 10Mbit Ethernet crossover cable to a133MHz Pentium with 64M RAM running the Apacheweb server provided with RedHat 6.1.Table 11 displays the results of the macrobenchmarks.Base SELinux Overheadelapsed 1114 1115 0system 0049 0051 4latency 0.56 0.56 0throughput 8.29 8.28 0Table 11 Macrobenchmark results. The elapsed and system timesfor a time make on the Linux 2.4.2 kernel sources are shown in minutes and seconds. The latency in seconds and throughput in MBits persecond are shown for the WebStone benchmark.There was no significant change in the total elapsed time,and there was only a 4 increase in the system time fora kernel compilation. There was no significant changein either the latency or the throughput measurements forWebStone. At the macro level, there appears to be littlenoticeable difference.7 Related WorkThe project that is most similar to SELinux is theRule Set Based Access Control RSBAC 22 for Linuxproject. RSBAC is based on the Generalized Frameworkfor Access Control GFAC 4. Like the Flask architecture, the GFAC separates policy from enforcement andcan support a variety of security policies. RSBAC provides a Role Compatibility policy module that is verysimilar to the SELinux Type Enforcement policy module.However, RSBAC also differs from SELinux in anumber of ways. The GFAC does not specifically address the issue of atomic policy changes, so RSBAClacks the SELinux support for dynamic security policies.Since the GFAC places the responsibility for managingsecurity labels in its Access Control Information ACImodule, RSBAC does not provide policyindependentdata types for security labels. The RSBAC Access Decision Facility ADF depends on kernelspecific datastructures, and RSBAC does not provide a security decision cache mechanism, because the RSBAC ADF wasdirectly implemented as a kernel subsystem. In contrast,since SELinuxs predecessor systems implemented thesecurity server as a userspace server running on a microkernel, the SELinux security server is cleanly decoupled from the kernel and SELinux provides the accessvector cache.Since RSBAC was not designed with securityawareapplications and application policy enforcers in mind,it lacks equivalents for the extended API calls and newAPI calls of SELinux, only providing calls for settingand getting attributes of existing subjects and objects.RSBAC uses the Linux real user identity attribute for itsdecisions and must control changes to this attribute, so itis not completely orthogonal to the existing Linux accesscontrols. Finally, RSBAC lacks a number of the controlsprovided by SELinux for each of the kernel subsystems.Type Enforcement 8 TE and Domain and Type Enforcement DTE 5 have a number of similarities toSELinux, since SELinux provides a generalization of TEin its example security server. Two projects are integrating DTE into Linux 15, 1. SELinux was designed toprovide flexible support for a variety of policy models,while DTE was only designed to implement an enhancedform of TE. DTE is distinguished from traditional TE bythe DTE Language DTEL for expressing access control configurations and by an implicit typing mechanismbased on the directory hierarchy for labeling files. TheSELinux TE policy module likewise has a configurationlanguage for expressing access control rules. SELinuxstores file labels explicitly, but allows labels to be managed using a higherlevel specification based on pathname regular expressions. NAI Labs DTE prototypealso provided labeling and controls for NFS and was integrated with IPSEC.The TrustedBSD project is developing a variety oftrusted operating system features, including mandatoryaccess controls, for FreeBSD 27. SELinux differs fromTrustedBSD in that SELinux is a more mature system,that it addresses only mandatory access controls, andthat it uses a flexible mandatory access control architecture rather than hardcoded policies. The TrustedBSDproject plans to migrate to a more flexible mandatory access control architecture in the future 28.The Medusa DS9 3 project is similar to SELinux ata high level in that it is also developing a kernel accesscontrol architecture that separates policy from enforcement. However, Medusa is very different in its specifics.In Medusa, the kernel consults a userspace authorization server for access decisions. The Medusa accesscontrols are primarily based on labeling subjects and objects with sets of virtual spaces to which they belong anddefining what virtual spaces can be seen, read, and written by each subject. The authorization server can alsorequire explicit authorization in addition to the virtualspace checking, in which case it can apply other kindsof policy logic and can even override the ordinary Linuxaccess controls. Medusa DS9 also provides support forsystem call interception by the authorization server andfor forcing a process to execute code provided by theauthorization server.The Linux Intrusion Detection System LIDS 2provides a set of additional security features for Linux.It supports administrativelydefined access control listsfor files that identify subjects based on their program.Like Medusa, LIDS can control the ability to see filesand processes in directory listings. LIDS also supportsdefining capability sets for programs, preventing certainprocesses from being killed, sending security alerts onaccess failures, and detecting port scans.The LOMAC 13 project has implemented a form ofmandatory access control based on the Low WaterMarkmodel in a Linux loadable kernel module. LOMAC wasnot designed to provide flexibility in its support for security policies instead, it focuses on providing usefulintegrity protection without any sitespecific configuration, regardless of the software and users present on asystem. It should be possible to implement the LowWaterMark model in SELinux as a particular policymodule.8 SummaryThis paper explains the need for mandatory access control MAC in mainstream operating systemsand presents the NSAs implementation of a flexibleMAC architecture called Flask in the SecurityEnhancedLinux SELinux prototype. The paper explains howthe Flask architecture separates policy from enforcementand provides the necessary interfaces and infrastructurefor flexible policy decisions and policy changes. It describes the finegrained labeling and controls providedby SELinux for kernel objects and services. The paper explains how existing Linux applications can run unchanged on the SELinux kernel, and it describes the support for securityaware applications. The paper showshow the SELinux controls can be applied to meet real security objectives by describing the example security policy configuration. It demonstrates that the performanceoverhead of the SELinux controls is minimal. Finally,the paper highlights the differences between SELinuxand related systems.AvailabilityThe SecurityEnhanced Linux software is availableunder the GNU General Public License GPL athttpwww.nsa.govselinux.AcknowledgmentsWe thank Timothy Fraser for his contributions to theexample policy configuration and for his assistance inporting the kernel modifications to the 2.4 kernel. Wethank Anthony Colatrella and Timothy Fraser for assisting with the performance benchmarking and analysis.We also thank Ted Faber, Timothy Fraser and the anonymous reviewers for reviewing earlier drafts of this paper.References1 Configurable Access Control Effort. httpresearchcistw.saic.comcace.2 Linux Intrusion Detection System. httpwww.lids.org.3 Medusa DS9. httpmedusa.fornax.sk.4 M. D. Abrams, K. W. Eggers, L. J. L. Padula, and I. M. Olson.A Generalized Framework for Access Control An Informal Description. In Proceedings of the Thirteenth National ComputerSecurity Conference, pages 135143, Oct. 1990.5 L. Badger, D. F. Sterne, D. L. Sherman, K. M. Walker, and S. A.Haghighat. Practical Domain and Type Enforcement for UNIX.In Proceedings of the 1995 IEEE Symposium on Security andPrivacy, pages 6677, May 1995.6 A. D. Balsa. Linux Benchmarking HOWTO, Aug. 1997. httpwww.linuxdoc.orgHOWTOBenchmarkingHOWTO.html.7 D. E. Bell and L. J. La Padula. Secure Computer Systems Mathematical Foundations and Model. Technical Report M74244,The MITRE Corporation, Bedford, MA, May 1973.8 W. E. Boebert and R. Y. Kain. A Practical Alternative to Hierarchical Integrity Policies. In Proceedings of the Eighth NationalComputer Security Conference, 1985.9 D. F. C. Brewer and M. J. Nash. The Chinese Wall security policy. In Proceedings of the 1989 IEEE Symposium on Securityand Privacy, pages 206214, May 1989.10 D. D. Clark and D. R. Wilson. A Comparison of Commercialand Military Computer Security Policies. In Proceedings of the1987 IEEE Symposium on Security and Privacy, pages 184194,Apr. 1987.11 D. Ferraiolo and R. Kuhn. RoleBased Access Controls. In Proceedings of the 15th National Computer Security Conference,pages 554563, Oct. 1992.12 T. Fine and S. E. Minear. Assuring Distributed Trusted Mach. InProceedings IEEE Computer Society Symposium on Research inSecurity and Privacy, pages 206218, May 1993.13 T. Fraser. LOMAC Low WaterMark Integrity Protection forCOTS Environments. In Proceedings of the 2000 IEEE Symposium on Security and Privacy, May 2000.14 J. Gilmore. FreeSWAN. httpwww.freeswan.org.15 S. Hallyn and P. Kearns. Domain and Type Enforcement forLinux. In Proceedings of the 4th Annual Linux Showcase andConference, Oct. 2000.16 P. Loscocco and S. Smalley. Integrating Flexible Support forSecurity Policies into the Linux Operating System. Technicalreport, NSA and NAI Labs, Oct. 2000.17 P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, R. C. Taylor,S. J. Turner, and J. F. Farrell. The Inevitability of Failure TheFlawed Assumption of Security in Modern Computing Environments. In Proceedings of the 21st National Information SystemsSecurity Conference, pages 303314, Oct. 1998.18 L. McVoy and C. Staelin. lmbench 2. httpwww.bitmover.comlmbench.19 MindCraft. Webstone. httpwww.mindcraft.comwebstone.20 S. E. Minear. Providing Policy Control Over Object Operationsin a Mach Based System. In Proceedings of the Fifth USENIXUNIX Security Symposium, pages 141156, June 1995.21 D. C. Niemi. Unixbench 4.1.0. httpwww.tux.orgpubtuxniemiunixbench.22 A. Ott. Rule Set Based Access Control as proposed in the Generalized Framework for Access Control approach in Linux. Masters thesis, University of Hamburg, Nov. 1997. pp. 157. httpwww.rsbac.orgpapers.htm.23 Secure Computing Corp. DTOS Formal Security Policy Model.DTOS CDRL A004, 2675 Long Lake Rd, Roseville, MN 55113,Sept. 1996. httpwww.securecomputing.comrandtHTMLdtos.html.24 Secure Computing Corp. DTOS Generalized Security PolicySpecification. DTOS CDRL A019, 2675 Long Lake Rd, Roseville, MN 55113, June 1997.25 R. Spencer, S. Smalley, P. Loscocco, M. Hibler, D. Andersen,and J. Lepreau. The Flask Security Architecture System Support for Diverse Security Policies. In Proceedings of the EighthUSENIX Security Symposium, pages 123139, Aug. 1999.26 K. W. Walker, D. F. Sterne, M. L. Badger, M. J. Petkac, D. L.Sherman, and K. A. Oostendorp. Confining Root Programs withDomain and Type Enforcement. In Proceedings of the 6th UsenixSecurity Symposium, San Jose, California, 1996.27 R. Watson. Introducing Supporting Infrastructure for TrustedOperating System Support in FreeBSD. In Proceedings of the2000 BSD Conference and Expo, Oct. 2000.28 R. Watson. Robert Watson on FreeBSD and TrustedBSD, Jan.2001. httpslashdot.orginterviews0101181251257.shtml.
