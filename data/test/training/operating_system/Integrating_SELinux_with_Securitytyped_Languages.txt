Integrating SELinux with Securitytyped LanguagesBoniface Hicks, Sandra Rueda, Trent Jaeger and Patrick McDanielSystems and Internet Infrastructure Security Laboratory SIISComputer Science and Engineering, Pennsylvania State Universityphicks,ruedarod,tjaeger,mcdanielcse.psu.eduAbstractTraditionally, operating systems have enforced MAC and information flow policies with minimal dependence on application programs. However, there are many cases where systems depend on userlevel programs to enforce informationflows. Previous approaches to handling this problem, suchas privilegeseparation of application components or assuming trust in application information flow enforcement, areprone to error and cumbersome to manage. On the otherhand, recent advances in the area of securitytyped languages have enabled the development of realistic applications with formally and automatically verified informationflow controls. In this paper, we examine what it takes to integrate information flow enforcement of applications written in a securitytyped extension of Java called Jif withSELinux. To this end, we have extended the Jif infrastructureto support interaction with SELinux security contexts, andwe describe the SELinux policy and system calls which arenecessary for a successful integration. We have also identified the need for further services, such as a means of formally verifying compliance between information flow policies. We have demonstrated the utility, flexibility and security of our approach by constructing a prototype multilevelsecure email client.KeywordsInformation Flow Policies, Java Information Flow Jif,securitytyped languages, SELinux1 IntroductionMandatory access control MAC operating systems likeSELinux often require the assistance of userlevel programs.For example, the X server is a userlevel service that processes information for all programs that use the graphicaluser interface 21. Since multiple users of multiple security clearances may use the same X server, it is necessaryto enable the X server to enforce the systems MAC policyon the resulting information flows. The X server has beenextended with a reference monitor interface to enforce suchMAC policies 21, and a userlevel policy server architecture has been developed to provide MAC enforcement to anyapplication with an appropriate reference monitor 28. Oneproblem with this approach is that the completeness of thereference monitor hooks i.e. whether all securitysensitiveoperations are checked depends on the programmer 8, 9and is not an easy property to check. Past experience showsthat this is errorprone.An alternative approach to enforcing MAC policies inuserlevel programs is to use securitytyped languages, suchas the Java  Information Flow Jif language 23, 25, FlowCaml 27, and a web scripting language 22. Jif is the mostmature among these. Jif extends the Java language to enablesecurity labels to be associated with program variables byextending their data types. Jif enforces a traditional latticepolicy 7 where the data in a variable of label x may not beleaked to a variable of label y unless y is equal to or dominates x in the lattice policy. Importantly, the Jif compiler willonly compile programs that meet this requirement, so an executing Jif program is guaranteed to enforce its informationflow policy. This may involve some hooks for making runtime checks of the policy, but Jif ensures the completenessof hook placement. While these guarantees depend on trustin the Jif compiler and the JVM implementation, it is debatable whether these assumptions are more significant thanthose in the X server or Linux kernel itself. In this paper, weinvestigate the integration of Jif programs into an SELinuxsystem.A question is how important is it for SELinux to recognizeMAC enforcement in Jif programs. First, although there areonly a small number of Jif programs that have been writtento date, real applications are starting to emerge 11 whichis also driving the construction of development infrastructure for Jif 1, 11. We expect that once a critical mass ofinfrastructure and knowledge is developed we will see manyapplications built in such languages.Second, and more importantly, the problem ofapplicationlevel information flow control is more prevalentthan has been acknowledged. The community is wellawarethat some servers e.g., the X server, as mentioned above,as well as sshd may be entrusted to enforce separationbetween the information flows of different clients. The current MLS policy already recognizes the need to allow manysystem utilities and policy management tools to handledata with multiple levels of sensitivity including passwd,logrotate, klogd, auditd, tmpreaper, iptablesand twentyeight others. Further, we identify that clientapplications, such as email clients and web browsers, mustprotect client data that may be of multiple secrecy levels.For example, phishing attacks involve leaking secret data tounauthorized principals. Finally, we have found that mostapplications need to protect their own integrity e.g., fromnetwork data 26, and securitytyped languages, such asJif offer a means to do this in a principled way. For thesereasons, we find a significant motivation in having applications built in securitytyped languages and integratingsystem and application information flow enforcement.In this paper, we examine how to enable SELinux to leverage the MAC enforcement abilities of programs written insecuritytyped languages, in particular the Jif language. Because these programs enforce their own lattice policies, thereis no need for the addition of a reference monitor interfaceor to use the SELinux policy server. On the other hand, wemust be able to configure the Jif application and SELinuxsystems to work together. The Jif application must be ableto extract the necessary information from the SELinux system to be able to enforce its information flow policy. Wedescribe how SELinux mechanisms and policy are used toenable a Jif email client application to use SELinux to enforce system policies. Also, the SELinux system must beable to convince itself that a Jif program is enforcing the systems MAC requirements. We outline the mechanisms thatare required to achieve this goal. This paper is a shorter version of another technical report 14, but this paper focuseson the specific SELinux impact of integrating securitytypedapplications with MAC systems.The rest of the paper is structured as follows. In Section 2, we motivate the need for comprehensive information flow enforcement that includes applications and operating systems. In Section 3, we examine the challenges inleveraging securitytyped languages for system informationflow enforcement. In Section 4, we outline the approach tobuilding securitytyped applications that enable comprehensive information flow control by examining an email client,JPmail. In Section 5, we detail how to implement JPmail onan SELinux system, such that the system information flowrequirements can be enforced. In Section 6, we discuss taking the proofofconcept to a more complete approach. InSection 7, we conclude and discuss future work.2 Comprehensive Information Flow EnforcementWe propose integrating SELinux controls with informationflowaware applications to enforce system security guarantees on the secrecy and integrity of data. While informationflow control is a traditional approach to enforcing security,even comprehensive MAC enforcement with flexible policymodels, such as SELinux, are not capable of practical information flow control alone. We claim that they need helpfrom information flowaware applications in some cases, andwe examine what is necessary to integrate security enforcement in SELinux with such applications to achieve the necessary information flow control.A reasonable question to ask is why the SELinux security goal should be expressed in terms of information flow.SELinux uses an extended Type Enforcement policy 4 andmultilevel security MLS models that can represent information flow security goals, least privilege, and many others.Regardless of how the policy is expressed in SELinux, wemust prove that a system protects the secrecy and integrityof data. Fundamentally, secrecy is about which subjects maybe able to access the data in worst case, and integrity isabout which subjects can provide data that others may depend upon. In both cases, information flow is a natural representation of these requirements.For example, we aimed to prove that SELinux policies protect the integrity of the system and certain applications 19, 16. In order to do this, we built a policy analysistool, called Gokyo, that identified the SELinux TE policyrules that permitted low integrity data to reach high integritysubjects 20. The analysis is a Biba information flow integrity analysis 3 where any information flows of low integrity data to high integrity subjects are problematic. Adeeper examination determined that nearly all high integrityapplications must process some low integrity data e.g., network requests, but it is possible to limit applications to receive that low integrity data only through interfaces that theapplications declare are capable of processing such data according to ClarkWilson integrity semantics i.e., discard orupgrade immediately 6, 26. Note that although SELinuxwith some minor extensions can restrict which interfacesreceive low integrity data, it cannot prove that the applicationreally protects itself correctly. We claim that the problem issimilar for information flow secrecy where many client andserver applications may be entrusted with data of multipleaccess classes.As a result, the premise of this paper is as follows. First,we find it valuable to evaluate whether SELinux policies enforce security goals for both secrecy and integrity using information flow. Second, even to achieve system information flow goals, some applications must be able to provetheir ability to protect themselves from low integrity inputdata and prevent the leakage of high secrecy data. Third,SELinux must be able to support such applications information flow control e.g., via system labels and policy andleverage such applicationlevel information flow control toprove that the system security goals are achieved.3 Leveraging SecurityTyped LanguagesThe recent emergence of securitytyped languages that enable the construction of applications with provable information flow guarantees motivates us to integrate application andsystem information flow control. Securitytyped languagesextend the type system of the language to include securitylabels. Typically, these labels provide semantic informationused to enforce information flow, either secrecy or integrity,on the variables. The compiler ensures that any legal program in the language enforces the information flow impliedby the securitytyped labels, so information flow guarantees,such as the property and simple security property 2, canbe enforced by the compiler.By integrating the enforcement guarantees of securitytyped languages and operating systems, SELinux can builda comprehensive guarantee of system security. If an application can guarantee to SELinux that it only allows informationflows permitted in the SELinux policy, then SELinux canguarantee the secrecy and integrity implied by those flows.Securitytyped applications will need support from SELinuxto do this. For example, SELinux must provide the labelsfor input data that the application receives, such that it mayenforce security properly. In this section, we explore thecharacteristics of SELinux and Jif that must be consideredto create a comprehensive information flow enforcer.3.1 Java  Information Flow JifSecuritytyped language compilers can guarantee the property no write down and simple security propertyno read up of the BellLaPadula model 2 for all data ina given application. By extending all datatype declarationswith a label that indicates the security level of the data andthen performing a compositional type analysis, a securitytyped language compiler is able to catch all illegal explicitand implicit1 flows in a given program. In this way, all programs which successfully compile are also assured to havethe strong security property of noninterference 10 betweenhighsecure data and lowsecure data.In this work, we have used the most mature securitytypedlanguage, Jif Java  information flow 23, 25, which covers the majority of the Java language and includes manyadvanced features specific to information flow which wehave found to be vital for developing realworld applications 11, such as runtime principals, dynamic labels, label polymorphism, declassification2 and labels drawn fromthe decentralized label model DLM 24. Essentially, a Jiflabel consists of a principal e.g. alice, bob, or aconjunction of principals alicebob where the principals are drawn from a principal hierarchy. The speciallabel  denotes public and is always at the bottom of thehierarchy, such that  v  for all labels, .Figure 1 gives an example of a Jif program. In this example, the Jif application handles two operating system objects,the stdin InputStream and a Socket. When getting the objects from the OS, the application must request them at a1The latest technology only considers control flows, not timing or termination flows.2The most recent version of Jif has added integrity constraints to labels 5, but we did not use this feature.1 Socket leak Runtime.openSocketspy.org,9999,2 InputStreamsec in  Runtime.stdinsec3 Stringsec passwd  in.readLine4 leak.printlnpasswd  ERROR Illegal leakageFigure 1 Example of securitytyped program written in Jifpseudocode, demonstrating a leaky program using operating system resources. Jif catches the leaks at compiletime.certain secrecy level by passing a Jif label as an argumentto the Runtime class. The code in Runtime which is partof the trusted computing base for the Jif compiler checksthe labels against the operating system resources and throwsan exception if they are not sufficiently secret. Otherwise,it returns the object at the requested secrecy level. Here iswhere the power of Jif becomes evident once a resource islabeled, the Jif type system will ensure through a static analysis that the label is never violated througout the duration ofits lifetime. This means that all leaks, such as the one in Figure 1, and more complicated leaks, will definitely be caughtat compiletime.As we have indicated, applications may have to handle illegal information flows, such as the input of low integritydata or the controlled release of secret data. Securitytypedlanguages use declassification to relabel data in an exceptional way, contrary to the lattice policy. Jif implementsrobust declassification, allowing a data items label to bedowngraded under certain conditions. We have extended thismechanism to handle trusted declassification 12. This requires that each principal specify the declassifying functionsdeclassifiers which should be trusted as downgraders forthat principals data in a Jif program. This is specified in apolicy which is dynamically checked whenever downgrading is attempted during program execution. Declassifiersallow the strong noninterference property to be violated incontrolled ways. For example, encryption is often considered a safe means of information release because the information released is vanishingly small. Also acceptable maybe a declassifier which performs certain checks or audits forthe declassification.3.2 Integrating SecurityTyped Applicationsand SELinuxIntegrating securitytyped applications into the enforcementof an SELinux policy requires support from both SELinuxand the application. Solutions to these problems will guarantee an integrated infrastructure to enforce information flowpolicies across layers in a single machine and across machines in a network. 13 SELinux labeling The application needs SELinux toprovide mechanisms to identify the security label of allsystem channels to the application. Application labeling SELinux needs the applicationto provide mechanisms to specify the security label ofall application channels to the system. Policy Compliance Both SELinux and the applicationrequire that the information flows in the two policiescomply i.e., no new flows are created between nodesin the lattices. Authorized Declassification Both SELinux and theapplication must authorize the declassifiers used to relabel data.First, a securitytyped application must be able to determine the label of any data that it receives from the system.SELinux provides a means to extract the labels of file andnetwork data, so we verify whether these are sufficient.Second, a securitytyped application must be able to convey the labels of its output data to SELinux. This turns outto be more complex. Suppose an application processes bothsecret and public data. If the application sends the data toa remote computer that can receive both secret and publicdata, then it must identify the data to the operating system,such that SELinux can protect the data correctly. For example, SELinux should not send secrets in the clear or sendsecrets to a remote computer that is not trusted. We investigate the systems support that SELinux should provide forapplications.Third, it is necessary for correct enforcement of systemand application information flows, that the two policies arecompliant. Compliance in this case means that there is noinformation flow in one system that is not allowed in theother, and there is no integrity dependence in one systemthat is not allowed in the other. This must be stated in termsof the SELinux and Jif application policies.Namely, consider a program with an input flow I from theoperating system, labeled with SELinux security context s1and Jif principal p1. I eventually flows to an output O labeled with the Jif principal p2, and the program would liketo output O to an OS resource with security context s2. Jifwill ensure that p1  p2 i.e. p2 is more secret than p1throughout the application. Before allowing data labeled p2to be output to an OS resource labeled s2, however, we mustbe sure that s1  s2 in the SELinux policy. Fortunately,these mappings can be vetted before the application is executed, because the Jif policy with statements such as p1 p2 and the JifSELinux mappings such as s1  p1and p2  s2 are made available to a compliance checking service prior to execution. The compliance algorithmand policy mappings are slightly more general than what wejust described, but they follow the same idea. Details can befound in a recent technical report 15.Fourth, any cases that involve declassification require thatboth parties authorize the declassification. For example,from an applications perspective, all input and output channels are public, thus any secret data must be encrypted tobe sent out on the network. However, SELinux is able touse Labeled IPsec 18 to encrypt and label such channels,so the application need not do its own encryption if it authorizes SELinux to do this. Of course, SELinux must alsoauthorize the use of IPsec.4 Case Study An MLS Email ClientIn this investigation, we have focused on integrating theSELinux MAC security with Jif applicationlevel information flow control for a secure email client. Specifically, wereworked a secure email client written in Jif, JPmail. Theclient originally presumed that the operating system and network could not be trusted to maintain the confidentiality ofemails as they were sent outside the client to remote emailservers. In this work, we have investigated how to removethis assumption when the client is running in SELinux andexamined what impact this makes on both application andoperating system.4.1 Information Flow RequirementsA challenging problem with multilevel secure email is thata single person often has multiple security clearances. Theprevalent approach to this problem is to run multiple emailclients in multiple security contexts. This approach is noteasy to manage. A good alternative is to run a single emailclient that is aware of information flow security and canprovably prevent leakage of secret emails to public recipients.To avoid information leakage, multilevel secure emailclients must support specific requirements1. Secret emails should be encrypted before being sent outover the Internet.2. For easier usability, all of the users email should bereadable within a single interface i.e. merged into asingle listing, regardless of security classification.3. To prevent leakage writedown, a reply to an emailshould only be sent out at the same level as the originalincoming message or possibly at a higher level.4. The clients should be able to utilize existing emailSMTP and POP3 servers.4.2 JPmail Email ClientJPmail is an information flow aware application developedwith Jif, that enables users to send, receive and reply toemails while also guaranteeing preservation of privacy i.e.,information is not leaked to unauthorized parties. The JPmail system is composed of four parts 1 the JPmail client2 the operating system on which it is running 3 the Internet and 4 remote, public mail SMTP and POP3 servers.The original JPmail client presumed that the operating system made no effort to protect the secrecy of data being sentout on network sockets. The client also presumed that remote mail servers could not be trusted to keep emails secret to satisfy requirement 4. Consequently, to meet requirements 1 and 4, the original client incorporated a proprietary public key infrastructure PKI in order to encryptall outgoing secret emails and decrypt all incoming secretemails. Unfortunately, the complexity of handling the encryption and the corresponding declassifications since releasing encrypted data is technically still leaking information, however small, about the unencrypted secret data retarded the efforts of including features such as handling multiple security levels within a single client. Thus, we were notable to meet all the abovelisted requirements for a secureemail client namely, 2 was left incomplete.4.3 Integrating JPmail with SELinuxFor this work, we updated the JPmail client to take advantageof SELinux security enforcement. This enabled a significantsimplification of the client applications code and allowed usalso to extend the client to handle multiple information flowswithin a single execution.By integrating with SELinux security enforcement, wewere able to simplify JPmail in the following ways Utilizing secure communications Labeled IPsec allows the application to forego encryption while still satisfying requirement 1 from Section 4.1. Integrating a secure operating system changed our assumption about remote mail servers knowing thatthe servers are confined at a certain security level bySELinux allows us to entrust our emails to the serverswithout encryption except the encryption provided intransit by IPsec without fear of leakage. Thus we stillmeet requirement 4. By introducing a mechanism for trusting the operatingsystems secure sockets, problems related to declassification no longer need to be handled in the application. While not directly enabling us to meet requirement 2, this simplification of program logic and codecomplexity opened the door for us to include this feature, rather than requiring independent incarnations ofthe email client for different security levels.The logic and information flow framework for requirement3 was developed largely in previous work 11, 13. Withthese changes, we are able to meet all the abovelisted requirements. More details about how these requirements aremet are given in the next section.5 ImplementationThe implementation described below implements the following email operations reading, sending, and replying toemails shown in Figure 2.Reading email Suppose Alice has secret clearance, soshe is allowed to read emails at that security level and lowerlevels. This means that she can contact POP servers runningat these levels to retrieve such emails. When she receives anemail at a lower level e.g., confidential, it is reclassified tosecret. This fulfills criteria 2 and 4 from the informationflow requirements in Section 4.1.SecretKernel Layer  SELinux Kernel Layer SELinuxJPmail processNetwork layer Labeled IPsecSMTPserverSELinux processMachine AMachine BunencryptedencryptedsecretsecretsecretPublicpublicKernel LayerSMTPserver processMachine CunknownpublicFigure 2 We configure SELinux to allow a trusted, Jif application to select the security levels required for a specificIO channel. Jif is extended to allow applications to outputunencrypted, secret data, because it is able to trust the OS tosecurely handle its secret data through Labeled IPsec sockets.Sending email Since Alice has secret clearance, her keyboard input enters at that security level. Declassificatione.g., encryption is necessary to send the email onto the Internet. Such declassification must be authorized for secretemail data. The output is labeled as secret and JPmail hasto ensure that it is only sent to an SMTP server with a secretsecurity level. Using Labeled IPsec fulfills criterion 1, ensuring that secret data is properly protected when it is sentout onto the Internet. In this case, the operating system isauthorized to perform the proper declassification via encryption . This implementation also fulfills criterion 4 becausethe remote SMTP server need not be Jifaware so long as it issandboxed by SELinux in the appropriate security contextguaranteed by the fact that a properly labeled IPsec socketcould be established.Replying to email When replying, JPmail has to declassify the response including the text of the original emailfrom the upgraded secrecy level Alices highest level tothe original level of the email. This must be done carefullyto ensure that no secure information is leaked. The reply issent to an SMTP server with the declassified security level.The algorithm and framework for this is not impacted by integration with SELinux and is discussed further in previouswork 11, 13. This part of the implementation fulfills criterion 3 in the information flow requirements.5.1 Jif Infrastructure ExtensionsIn Jif, the only way to request resources, such as files,standard input and standard output, from the operating system is through a special Runtime class. We have extended the Runtime class to handle labeled sockets andfiles. We consider the details here only for socketsfiles were more straightforward, applying similar concepts.Jif applications have a policy, external to the application,that establishes acceptable mappings between SELinux security contexts and Jif principals. For our example, we pre Example Jif code tries to leak secret dataInputStreams3  Runtime.openSockethost, port, new labels3,useruobjectrjpmailts3.getInputStreamPrintStream pubFile  new PrintStreamRuntime.openFileWriteleak.txt,false,new labelchar ch  in.readpubFile.printch  ERR illegal information flowFigure 3 This Jif code demonstrates how Jif controls information flow through an application. This code opens a secret socket, reads data from the socket and attempts to writeit to a public file. A compiler error would occur in this casebecause the code violates the noninterference property forconfidentiality no writedown.sume our policy establishes that access is only allowed to auseruobjectrjpmailts3 SELinux label socketthrough a stream labeled s3 Jif label. Furthermore,since Jif also ensures that a stream connected to a public filemust be labeled , and Jif prevents data labeled s3 fromflowing to channels labeled , a Jif program can be trustedto keep the secret socket input from being leaked to the public file. An example of this is given in Figure 3. Note, thatthis code is simplified for illustration purposes. In order tocompile in Jif, it must also handle all runtime exceptions.Our extension to Jif adds a call to the SELinux C library in the Runtime.openSocket method such as thefirst line in Figure 3. openSocket takes four argumentsthe host IP address and port number we want to connectto, as well as the Jif label and the SELinux security context we would like to label the socket with. The Runtimethen performs the proper security checks and socket initialization. The Runtime first creates an unconnected socketwith the Java constructor. Then we call two C functions1 getfd to get the file descriptor on the socket and 2fsetfilecon to attempt to change the context on the socketto openSockets fourth input parameter in this case itwould be useruobjectrjpmailts3. If thissucceeds i.e., it doesnt throw a SecurityException,we attempt to connect the socket using the Java method,sock.connect.... This will automatically engage theIPsec subsystem, attempt to establish a security association for the socket and make the connection with the remote server socket. After making a connection, the security association SA is checked by making the kernelcall to getsockopt with the SOPEERSEC attribute in ourC function getSecurityContext. If the SA does nothave the security level requested by the Jif application, aSecurityException is thrown. If all this succeeds, theRuntime.openSocket method returns the newly created, properly labeled socket. Otherwise, it throws aSecurityException.Another important consideration regarding the protectionof secure information for an email client is what label shouldbe on data entered via the keyboard. Currently, the JifRuntime class requires that the standard input must have thesame or a higher security level than the process running theprogram. As we extend the Jif infrastructure for tighter integration with SELinux, this label could also be drawn fromthe X Window that the process is running in. A similar approach could be taken for standard output. We leave this asfuture work.5.2 SELinux ImplementationThis section presents an overview of a proofofconcept system that implements comprehensive information flow enforcement using SELinux. This proofofconcept systemuses the SELinux Type Enforcement TE and MLS policies to enforce information flow secrecy. The support forMLS in Labeled IPsec was being developed as this work wasdone, so we built this system using the initial Labeled IPsecsystem. We discuss the implications of moving to the MLSLabeled IPsec in Section 6, and plan to port to that system.Enabling JPmail to send information over the network atdifferent security levels requires allowing the application tochange the security context of their resources sockets, sothey can be associated to appropriate IPsec security associations. The following list presents the general requirements JPmail must run in a context that enables it to accesssockets with different MLS levels, for instance secretand public JPmail needs to relabel a sockets context to secret orpublic JPmails secret and public sockets need access to security associations of those respective labelsWe created a separate domain for Jif applications since weare authorizing them to determine the security level of theirresources. We do not want to give such control to other applications. Such privilege is given to Jif applications becausethey guarantee information flow enforcement over their owndata. The following rules configure the environment to accept our new domaintype jpmailexecttype jpmailtdomaintypejpmailtdomainentryfilejpmailt,jpmailexectdomainautotransusert, jpmailexect, jpmailtWe also need to assign special MLS attributes to our new domain mlsnetreadtoclr and mlsnetwritetoclr. Theseattributes allow the application to read data from and writedata to network resources sockets in this case if the MLSlevel of the resource lies within the applications MLS range.typeattribute jpmailt mlsnetreadtoclr, mlsnetwritetoclrThe following rule indirectly defines the users that are allowed to run a Jif application Since SELinux users have arole associated, any subject with this role is allowed to execute our Jif applicationrole userr types jpmailtSince JPmail connects to POP and SMTP servers to receiveand send messages, we need to give it access to sockets andsecurity associationsallow jpmailt selftcpsocket  create bind listengetopt getattr relabelfrom relabelto read write allow jpmailt selfassociation  recvfrom sendtoPrevious statements give JPmail permissions to relabel itsresources and use them.The sockets access to network communications is controlled by Labeled IPsec. Labeled IPsec 17 enables theinformation flow guarantees to reach other machines, by authorizing network communication only if the sockets on eachmachine have access to the label of the resulting security associations. JPmail relies on Labeled IPsec to guarantee confidentiality for data transmission.IPsec rules must be specified that describe the secure communication requirements and labels of the connection between the two machines. These statements define that secretcommunication uses ESP in transport mode.spdadd addr2 addr3 anyctx 1 1 useruobjectrjpmailts1P out ipsec esptransportrequire spdadd addr2 addr3 anyctx 1 1 useruobjectrjpmailts1P in ipsec esptransportrequire With the old Labeled IPsec implementation we need rulesfor every one of the possible MLS levels s0,s1,.... A mostrecent version allows to specify a range, thus the level of thesecurity association is assigned when it is created accordingto the actual MLS level of the involved socket and the rangeallowed by the IPsec rule.An additional issue is whether it is acceptable to movethe responsibility of encryption operations from the application to the operating system and labeled IPsec encryptionis usually required when downgrading information to sendit through the network. Consistency between what is expected by the application encryption and hash algorithmsand authentication method and what is actually available atthe IPsec layer has to be checked by hand.5.3 ResultsContrary to the usual case that operating systems do not trustapplications, SELinux may trust the application to collaborate in enforcing the systems information flow policies. InSection 3.2, we identify that SELinux needs to depend on theapplication for 1 labeling outputs to the system 2 compliant information flow policies and 3 authorized declassifiers. In this paper, we show that 1 is possible in SELinuxusing process and socket relabeling. We built the modifiedJPmail email client, and have a performance analysis of theimpact of using IPsec for encryption 13.To achieve 2, we need a service that verifies the compliance between the information flow policies. An architecturefor this service 14 and an algorithm 15 are proposed inprior work. Unfortunately, identifying authorized declassifiers 3 is a manual task. Therefore, eliminating unnecessary declassifiers, such as removing the JPmail encryption,is beneficial.In addition to removal of a declassifier, the integration ofinformation flow control reduces the amount of secret dataspecific to the application. For example, private keys are nolonger required to decrypt messages within the application.This reduces the problem that SELinux has to depend on thecorrect labeling of data that originates within the application.6 DiscussionThis work is a proofofconcept to show what is necessary ingeneral for SELinux to leverage securitytyped applicationsto enforce information flow comprehensively. The proofofconcept system is limited in two key ways 1 it does notleverage MLS labels for secrecy and 2 it does not enforceintegrity information flow controls. We discuss the efficacyof addressing these limitations in practice below.First, using MLS labels to enforce information flow secrecy is a natural extension. With the inclusion of the MLSextensions for Labeled IPsec in the near future, we can portJPmail to use MLS labels in a more consistent way. Of theSELinux tasks, listed at the beginning of Section 5.2, all arestraightforward once the system starts the JPmail process inthe appropriate MLS range.Jif can represent a range of secrecy labels using meets, butthis is awkward to use. Fortunately, most SELinux objectswill have a single access class. We have only seen MLSranges for directory objects, thusfar. The JPmail processwould have an MLS range for its label that covers the emailsthat it can send i.e., lowest secrecy send and receive i.e.,highest secrecy receive. This would enable the user to usethe JPmail client to send an email with any secrecy classwithin this secrecy range. Clearly, the breadth of the rangedepends on the declassifiers for message secrecy. Socketswould be created for each label of message that could besent, but this may result in a large number of sockets being used. Further investigation is necessary to determine thisimpact.Second, handling information flow integrity is limited intwo ways in our proofofconcept 1 SELinux does nothave an integrity lattice policy and 2 we only use the secrecy lattice in Jif at present. Our view is that the TE policyrepresents integrity protections whereas the MLS policy isfor secrecy. In the past, we have associated integrity labelswith subject types 19. Since we have important processesi.e., trusted and others, a simple twolevel integrity hierarchy has sufficed. Further, a recent extension of the Jifenvironment supports an integrity lattice policy 5. Thus,we envision that integrity information can be enforced using the SELinux TE policy to identify lowtohigh integrityflows and the Jif integrity lattice and declassifiers to ensurethat the low integrity is immediately upgraded or discardedaccording to the ClarkWilson integrity model 6.7 Conclusions and Future WorkWe have described and implemented a model for integratingOS MAC security with applicationlevel information flowcontrols. We demonstrate the feasibility of this model bymodifying a multilevel secure email client, developed inthe securitytyped language Jif, to utilize SELinux securitymechanisms such as Type Enforcement and Labeled IPsec.We extended the Jif infrastructure to support this interaction and we describe the policy and system calls necessaryin SELinux for a successful integration. Furthermore, wenote that this modification led to several improvements tothe application in accord with good practices for security environments it simplifies the code of the application, and itdistributes various security tasks to the best mechanism OS,network or application who can perform each task.By developing this work we also uncovered some areasfor further research. It is important to formalize a theory ofSELinux behavior such that it can generate provable guarantees similar to Jifs. Also, we identified the need for a formaldefinition of compliance between the operating system andapplication information flow policies.8 AcknowledgmentThis research was supported in part by NSF grant CCF0524132,Flexible, Decentralized Informationflow Control for DynamicEnvironments.References1 K. Ahmadizadeh. Integrating jif into eclipse. Honors Thesis. Pennsylvania State University., May 2006.2 D. E. Bell and L. J. LaPadula. Secure computer system Unifiedexposition and Multics interpretation. Technical Report ESDTR75306, MITRE Corp. MTR2997, Bedford, MA, 1975. Available asNTIS ADA023 588.3 K. J. Biba. Integrity Considerations for Secure Computer Systems.Technical Report ESDTR76372, USAF Electronic Systems Division, Bedford, MA, April 1977. Also available through National Technical Information Service, Springfield Va., NTIS ADA039324..4 W.E. Boebert and R.Y. Kain. A practical alternative to hierarchicalintegrity policies. In Proceedings of the 8th National Conference onComputer Security, pages 1827, 1985.5 S. Chong and A. C. Myers. Decentralized robustness. In Proceedingsof the 19th IEEE Computer Security Foundations Workshop CSFW,Venice, July 2006.6 D. D. Clark and D. R. Wilson. A comparison of commercial andmilitary computer security policies. In IEEE Symposium on Securityand Privacy, pages 184195, 1987.7 D. E. Denning and P. J. Denning. Certification of programs for secure information flow. Communications of the ACM, 207504513,1977.8 V. Ganapathy, T. Jaeger, and S. Jha. Automatic placement of authorization hooks in the linux security modules framework. In CCS05Proceedings of 12th ACM Conference on Computer and Communications Security, page To Appear, New York, NY, USA, November2005. ACM Press.9 V. Ganapathy, D. King, T. Jaeger, and S. Jha. Mining securitysensitive operations in legacy code using concept analysis. In Proceedings of the 29th International Conference on Software Engineering ICSE 07, 2007. To appear.10 J. A. Goguen and J. Meseguer. Security policies and security models.pages 1120, April 1982.11 B. Hicks, K. Ahmadizadeh, and P. McDaniel. From Languagesto Systems Understanding Practical Application Development inSecuritytyped Languages. In Proceedings of the 22nd Annual Computer Security Applications Conference ACSAC 2006, Miami, FL,December 1115 2006.12 B. Hicks, D. King, P. McDaniel, and M. Hicks. Trusted declassification Highlevel policy for a securitytyped language. In Proceedings of the 1st ACM SIGPLANWorkshop on Programming Languagesand Analysis for Security PLAS 06, Ottawa, Canada, June 10 2006.ACM Press.13 B. Hicks, S. Rueda, T. Jaeger, and P. McDaniel. Breaking Downthe Walls of Mutual Distrust Securitytyped Email Using LabeledIPsec. Technical Report NASTR00492006, Network and SecurityResearch Center, Department of Computer Science and Engineering,Pennsylvania State University, University Park, PA, USA, September2006.14 B. Hicks, S. Rueda, T. Jaeger, and P. McDaniel. From trusted tosecure Building and executing applications that enforce system security. Technical Report NASTR00612007, Networking and Security Research Center, Department of Computer Science, PennsylvaniaState University, 2007.15 B. Hicks, S. Rueda, L. St.Clair, T. Jaeger, and P. McDaniel. A logicalspecification and analysis for SELinux MLS policy. Technical ReportNASTR00582007, Networking and Security Research Center, Department of Computer Science, Pennsylvania State University, 2007.16 T. Jaeger, , A. Edwards, and X. Zhang. Policy management usingaccess control spaces. ACM Trans. Inf. Syst. Secur., 63327364,2003.17 T. Jaeger, S. Hallyn, and J. Latten. Leveraging IPsec for mandatory access control of linux network communications. In Proceedings of the 21st Annual Computer Security Applications ConferenceACSAC05, Tucson, Arizona, Dec. 59 2005.18 T. Jaeger, D. King, K. Butler, S. Hallyn, J. Latten, and X. Zhang.Leveraging IPsec for mandatory access control across systems. InProceedings of the Second International Conference on Security andPrivacy in Communication Networks SecureComm 2006, Baltimore, MD, USA, August 2006.19 T. Jaeger, R. Sailer, and X. Zhang. Analyzing integrity protectionin the SELinux example policy. In Proceedings of the 12th USENIXSecurity Symposium, pages 5974, August 2003.20 T. Jaeger, R. Sailer, and X. Zhang. Resolving constraint conflicts. InProceedings of the 2004 ACM Symposium on Access Control Modelsand Technologies, June 2004.21 D. Kilpatrick, W. Salamon, and C. Vance. Securing the X Windowsystem with SELinux. Technical Report Technical Report 03006,NAI Labs, March 2003.22 P. Li and S. Zdancewic. Practical Informationflow Control in Webbased Information Systems. In Proceedings of 18th IEEE Computer Security Foundations Workshop. IEEE Computer Society Press,2005.23 A. C. Myers. MostlyStatic Decentralized Information Flow Control. Technical Report MITLCSTR783, Massachussetts Institute ofTechnology, January 1999. Ph.D. thesis.24 A. C. Myers and B. Liskov. Protecting privacy using the decentralized label model. ACM Transactions on Software Engineering andMethodology, 94410442, 2000.25 A. C. Myers, N. Nystrom, L. Zheng, and S. Zdancewic.Jif Java  information flow. Software release. Located athttpwww.cs.cornell.edujif, July 2001.26 U. Shankar, T. Jaeger, and R. Sailer. Toward automated informationflow integrity verification for securitycritical applications. In Proceedings of the 2006 ISOC Networked and Distributed Systems Security Symposium NDSS06, San Diego, CA, USA, February 2006.27 V. Simonet. The Flow Caml System Documentation and UsersManual. Technical Report 0282, Institut National de Recherche enInformatique et en Automatique INRIA, July 2003. cINRIA.28 Tresys Technology. SE Linux Policy Server. Available at httpwww.tresys.comselinuxselinuxpolicyserver.
