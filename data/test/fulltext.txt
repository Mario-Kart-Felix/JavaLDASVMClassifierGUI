University of Pennsylvania
ScholarlyCommons
Departmental Papers (CIS) Department of Computer & Information Science
March 2004
A Temporal Logic of Nested Calls and Returns
Rajeev Alur
University of Pennsylvania, alur@cis.upenn.edu
Kousha Etessami
University of Edinburgh
P. Madhusudan
University of Pennsylvania
Follow this and additional works at: http://repository.upenn.edu/cis_papers
From the 10th International Conference, TACAS 2004, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS
2004, Barcelona, Spain, March 29 - April 2, 2004.
This paper is posted at ScholarlyCommons. http://repository.upenn.edu/cis_papers/203
For more information, please contact libraryrepository@pobox.upenn.edu.
Recommended Citation
Rajeev Alur, Kousha Etessami, and P. Madhusudan, "A Temporal Logic of Nested Calls and Returns ", Lecture Notes in Computer
Science: Tools and Algorithms for the Construction and Analysis of Systems 2988, 467-481. March 2004. http://dx.doi.org/10.1007/
978-3-540-24730-2_35
A Temporal Logic of Nested Calls and Returns
Abstract
Model checking of linear temporal logic (LTL) specifications with respect to pushdown systems has been
shown to be a useful tool for analysis of programs with potentially recursive procedures. LTL, however, can
specify only regular properties, and properties such as correctness of procedures with respect to pre and post
conditions, that require matching of calls and returns, are not regular. We introduce a temporal logic of calls and
returns (CARET) for specification and algorithmic verification of correctness requirements of structured
programs. The formulas of CARET are interpreted over sequences of propositional valuations tagged with
special symbols call and ret. Besides the standard global temporal modalities, CARET admits the abstract-next
operator that allows a path to jump from a call to the matching return. This operator can be used to specify a
variety of non-regular properties such as partial and total correctness of program blocks with respect to pre
and post conditions. The abstract versions of the other temporal modalities can be used to specify regular
properties of local paths within a procedure that skip over calls to other procedures. CARET also admits the
caller modality that jumps to the most recent pending call, and such caller modalities allow specification of a
variety of security properties that involve inspection of the call-stack. Even though verifying context-free
properties of pushdown systems is undecidable, we show that model checking CARET formulas against a
pushdown model is decidable. We present a tableau construction that reduces our model checking problem to
the emptiness problem for a B√ºchi pushdown system. The complexity of model checking CARET formulas is
the same as that of checking LTL formulas, namely, polynomial in the model and singly exponential in the size
of the specification.
Comments
From the 10th International Conference, TACAS 2004, Held as Part of the Joint European Conferences on
Theory and Practice of Software, ETAPS 2004, Barcelona, Spain, March 29 - April 2, 2004.
This conference paper is available at ScholarlyCommons: http://repository.upenn.edu/cis_papers/203
A Temporal Logic of Nested Calls and Returns ?
Rajeev Alur1, Kousha Etessami2, and P. Madhusudan1
1 University of Pennsylvania
2 University of Edinburgh
Abstract. Model checking of linear temporal logic (LTL) specications
with respect to pushdown systems has been shown to be a useful tool for
analysis of programs with potentially recursive procedures. LTL, how-
ever, can specify only regular properties, and properties such as correct-
ness of procedures with respect to pre and post conditions, that require
matching of calls and returns, are not regular. We introduce a tempo-
ral logic of calls and returns (CaRet) for specication and algorithmic
verication of correctness requirements of structured programs. The for-
mulas of CaRet are interpreted over sequences of propositional valu-
ations tagged with special symbols call and ret. Besides the standard
global temporal modalities, CaRet admits the abstract-next operator
that allows a path to jump from a call to the matching return. This op-
erator can be used to specify a variety of non-regular properties such as
partial and total correctness of program blocks with respect to pre and
post conditions. The abstract versions of the other temporal modalities
can be used to specify regular properties of local paths within a proce-
dure that skip over calls to other procedures. CaRet also admits the
caller modality that jumps to the most recent pending call, and such
caller modalities allow specication of a variety of security properties
that involve inspection of the call-stack. Even though verifying context-
free properties of pushdown systems is undecidable, we show that model
checking CaRet formulas against a pushdown model is decidable. We
present a tableau construction that reduces our model checking problem
to the emptiness problem for a Buchi pushdown system. The complexity
of model checking CaRet formulas is the same as that of checking LTL
formulas, namely, polynomial in the model and singly exponential in the
size of the specication.
1 Introduction
Propositional linear temporal logic (LTL) is a popular choice for specifying cor-
rectness requirements of reactive systems [23, 22]. LTL formulas are built from
atomic propositions using temporal modalities such as \next," \always," and
\until," and are interpreted over innite sequences of states that assign val-
ues to atomic propositions. The LTL model checking problem is to determine
whether all the computations of a system satisfy a given LTL specication. In
? Supported in part by ARO URI award DAAD19-01-1-0473 and NSF award CCR-
0306382.
traditional model checking [11, 21, 16], the model is a nite state machine whose
vertices correspond to system states and whose edges correspond to system tran-
sitions. However, model checking is also feasible when the model is a recursive
state machine (or equivalently, a pushdown system), in which vertices can either
be ordinary states or can correspond to invocations of other state machines in a
potentially recursive manner. Recursive state machines (RSMs) can model the
control ow in typical sequential imperative programming languages with recur-
sive procedure calls. Model checking of LTL specications with respect to RSMs
can be solved in time polynomial in the size of the model and exponential in
the size of the specication [7, 5, 12, 1, 3, 20]. This problem has been well studied
over the last few years leading to e√Ücient implementations and applications to
program analysis as well as model checking of C or Java programs [24, 2, 13, 10].
While LTL is an attractive specication language for capturing regular se-
quencing requirements such as \between successive write operations to a variable,
a read operation should occur," it cannot express requirements such as \if the
pre-condition p holds when a module is invoked, the post-condition q should hold
when the module returns." This requires matching of calls and returns, and is a
context-free property if calls are nested (recall that the language fanbn j n 2 Ng
is a non-regular context-free language [17]). Correctness of program blocks with
respect to pre and post conditions has been emphasized in the verication liter-
ature since the early days of logics for structured programs [15], and also forms
an integral part of modern interface specication languages for object oriented
programming such as JML [6]. In this paper, we introduce CaRet |a temporal
logic that can express requirements about matching calls and returns, along with
the necessary tools for algorithmic reasoning. Algorithmic verication of nonreg-
ular specications have been considered previously [4, 14, 19], but to the best of
our knowledge, this is the rst specication language that allows specication
of partial and total correctness with respect to pre and post conditions, and
has a decidable model checking problem with respect to boolean abstractions of
recursive sequential programs.
The formulas of our logic are interpreted over structured computations . A
structured computation is an innite sequence of states, where each state as-
signs values to atomic propositions, and can be additionally tagged with call or
ret symbols. A call denotes invocation of a (sequential) program module, and
the matching return denotes the exit from this module, where a module may cor-
respond to a procedure or a function in structured imperative languages such as
C, or methods in object-oriented languages such as Java, or remote invocations
of components in a distributed environment. Given a structured computation,
the abstract-successor of the i-state is dened to be the matching return posi-
tion if the i-th state is a call, and i+ 1 otherwise. Besides the global temporal
modalities, CaRet admits their abstract counterparts. For example,a' holds
at a position if ' holds at its abstract-successor position. Consequently, if the
state formula callA denotes the invocation of a module A, then the CaRet
formula 2(callA ^ p ! aq) species the total correctness with respect to the
pre-condition p and post-condition q. An abstract path is obtained by applying
the abstract-successor operation repeatedly, and captures the local computation
within a module that removes computation fragments corresponding to calls to
other blocks. The abstract-versions of operators such as always and until can be
used to specify regular requirements about such local paths.
In a structured computation, for every position, besides the global and ab-
stract successors, there is also a natural notion of the caller position which gives
the most recent unmatched call position. The caller path, obtained by repeated
applications of the caller operator can be interpreted as the contents of the
call-stack at a position. Our logic admits the caller counterparts of all the tem-
poral modalities. These modalities allow specication of properties that require
inspection of the call-stack such as \a module A should be invoked only if the
module B belongs to the call-stack," or \the number of interrupt-handlers in the
call-stack should never exceed 10." It is worth noting that the relevance of stack
inspection for specifying correctness of security properties and calling sequences
of interrupt handlers has been identied by many researchers, and decision pro-
cedures for checking specic properties already exist [18, 10, 13, 9]. In particular,
[13] uses LTL on pushdown systems but allows the atomic propositions of the
LTL formula to correspond to any regular language evaluated over the call stack.
Our logic mixes global, abstract, and temporal modalities allowing integrated
specications, and is more expressive allowing specication of properties such as
\variable x remains unchanged after the current call returns."
Given an RSM (or a pushdown system) whose vertices are labeled with
atomic propositions, there is a natural way to associate a set of structured com-
putations by tagging invocations and returns with call and ret symbols. The
model checking problem, then, is to check whether all computations of an RSM
S satisfy a CaRet specication '. Note that both S and ' dene context-free
languages, and problems such as inclusion and emptiness of intersection are un-
decidable for context-free languages [17]. However, in our setting, the model and
the specication are synchronized on the call and ret symbols, and as a result
we show that the model checking problem becomes decidable. Our decision pro-
cedure generalizes the tableau-based construction for LTL model checking: given
an RSM S and a specication ', we show how to construct another RSM S'
with generalized Buchi conditions such that S' has an accepting run i S has
a computation that violates '. The time complexity of the decision procedure
is polynomial in the size of S and exponential in the size of '. This is identical
to the time complexity of model checking of LTL specications with respect to
RSMs, and the model complexity is exactly the same as that of the reachability
problem for RSMs (cubic in general, and linear if the number of entries denoting
the inputs to a module, or the number of exits denoting the outputs of a module,
is bounded). As in the case of LTL, model checking of CaRet with respect to
RSMs is Exptime-complete, and its model complexity is Ptime-complete.
Related Work: In [4], the authors show a restricted but decidable tempo-
ral logic which allows variables to count the number of occurrences of states
in intervals which then can be compared using Presburger constraints. The
work in [19] deals with model checking regular systems against pushdown tree-
automata specications. Propositional dynamic logic can be augmented with
some restricted classes of context-free languages (those accepted by simple-
minded PDAs) such that validity is decidable [14]. Stack inspection is considered
in [18] where the authors propose a logic that can specify properties of the stack
at any point using temporal operators; in [13] a more general way of accessing
the stack is provided using propositions that are interpreted using automata that
run over the stack.
2 Computation Model
2.1 Structured Computations
Let us x a nite set   of symbols. The augmented alphabet of   is the alphabet:
 ÃÇ =   fcall ; ret ; intg. The symbol call denotes the invocation of a module, ret
denotes the exit or the return from a module and int stands for internal actions
of the current module. For  2   , we call the symbols of the form (; call ),
(; ret) and (; int), calls, returns and internal symbols, respectively.
For an innite word  and an integer i  0, we use i to denote the i-th
symbol in  and i to denote the su√Üx of  starting at the i-th symbol.
For a word  over  ÃÇ , there is a natural notion of a matching between calls
and returns: if i = (; call ) and j = (
0; ret), we say that j is the matching
return for i if j is the return corresponding to the call at i. Formally, we dene
a more general partial function R that maps any i 2 N to the rst unmatched
return after i: if there is a j0 such that j0 is greater than i and j0 is a return
and the number of calls and returns in i+1 : : : j0 1 are equal, then R(i) = j,
where j is the smallest such j0; else R(i) = ?. If i is a call, then R(i) will be
its corresponding return.
In the logic we dene we have three notions of successor:
{ The global-successor (succg) is the usual successor function. The global-
successor of i in , denoted succg(i), is i+ 1.
{ The abstract-successor (succa) points to the next \local" successor. If the
current symbol is a call, then it skips the entire computation within the
call and moves to the matching return. Otherwise, it is the global-successor
provided the global-successor is not a return. If the global successor is a
return, then the abstract-successor is dened as ?. Formally, if i is an
internal symbol or a return, then: if i+1 is not a return, then succ
a
(i) is
i + 1, otherwise it ?. If i is a call, then succa(i) = R(i). Note that if i
is a call that has no matching return, then succa(i) is ?.
{ The caller (succ ) is a \past" modality that points to the innermost call
within which the current action is executed. If there is a j0 < i such that j0
is a call and R(j
0) > i or R(j
0) = ?, then succ  (i) = j, where j is the
greatest such j0. Otherwise, succ  (i) = ?.
Notice that we do not demand that calls have matching returns, or even that
returns have matching calls. In the models of programs that we consider, it is true
that every return has a matching call (but calls to a module may never return).
However, since our logic does not require this assumption, we have chosen to
present it in this general framework.
2.2 Recursive State Machines
Recursive state machines (RSMs) were introduced in [1], and independently in
[3] under a dierent name, to model the interprocedural control ow in recursive
programs. RSMs are expressively equivalent to pushdown systems, but they more
tightly capture the control ow graphs of procedural programs and enable us to
more directly reason about them. We therefore adopt RSMs as system models
in this paper.
Syntax. A recursive state machine (RSM) S over a set of propositions AP
is a tuple (M; fSmgm2M ; start), where M is a nite set of module names, for
every m 2 M , Sm is a module Sm = (Nm; Bm; Ym;Enm;Exm; √Üm; m), and
start 
S
m2M Nm, is a set of start nodes. Each module Sm consists of the
following components:
{ A nite nonempty set of nodes Nm and a nite set of boxes Bm.
{ A labeling Ym : Bm !M that assigns to every box a module name.
{ A nonempty set of entry nodes Enm  Nm and a nonempty set of exit nodes
Exm  Nm.
{ Let Callsm = f(b; e) j b 2 Bm; e 2 EnYm(b)g denote the set of calls of m and
let Retnsm = f(b; x) j b 2 Bm; x 2 ExYm(b)g denote the set of returns in m.
Then, √Üm : Nm [ Retnsm ! 2Nm[Callsm is a transition function.
{ Let Vm = (Nm [ Callsm [ Retnsm). We refer to Vm as the set of vertices
of Sm. m is a labeling function m : Vm ! 2
AP that associates a set of
propositions to each vertex, i.e., to nodes, calls and returns.
We let V =
S
m2M Vm denote the set of all vertices of S and let  : V ! 2
AP
be the extension of all the functions m, m 2 M . Also, let B =
S
m2M Bm and
let Y : B !M denote the function that extends all the functions Ym (m 2M).
Figure 1 depicts an example RSM in which there are two modules, S1 and
S2. The calls and returns have been identied explicitly by labeling them with c
and r, respectively. Module S1, for example, has two entries labeled by p and by
q, only one exit, labeled x, and two boxes b1 and b2. Note that calls and returns
can also have other propositions labeling them, and these may dier from the
labels of the corresponding entries and exits. For example the call of box b2 has
label t, and this diers from the label z of the entry to S2, which box b2 maps to.
Assume that the entry of S1 labeled q is the unique start node. In such a case,
a sample computation of the RSM, annotated with call and return information,
consists of the sequence of labels:
(fqg; int) (fdg; int) (ftg; call) (fzg; int) (ftg; int) (fyg; int) (fwg; ret) : : :.
Semantics. From an RSM S we dene a (innite) global Kripke structureKS =
(Q; Init; ; √Ü). The (global) states, denoted Q, are elements (; u) 2 BV such
that either
S 1 S 2
b2:S
b3:S
2
1b1:S1c
c
x
c
c
r
y
q
p
d c
t
r
h
z
t
wr
Fig. 1. A sample RSM
{  =  and u 2 V , or,
{  = b1 : : : bk (with k  1) and 8i 2 [1; k   1], bi+1 2 BY (bi) and u 2 VY (bk).
The initial states are Init = f(; u) 2 Q j u 2 startg. The labeling function
is ((; u)) = ((u); z), where z = int if u is a node, z = call if u is a call, and
z = ret if u is a return.
The global transition relation √Ü : Q! 2Q, is dened as follows. For s = (; u)
and s0 = (0; u0), s0 2 √Ü(s) if and only if one of the following holds:
{ Internal move: u 2 (Nm [ Retnsm) n Exm, u0 2 √Üm(u), and 0 = 
{ Call a module: u = (b; e) 2 Callsm, u0 = e and 0 = :b
{ Return from a call: u 2 Exm,  = 0:b, and u0 = (b; u)
Let   = 2AP and  ÃÇ =    fcall ; ret ; intg. For a word  = 01 : : : 2  ÃÇ!, a run
of KS on  is a sequence of states  = s0; s1; : : : where (si) = i, for all i 2 N,
and such that s0 2 Init and for every i 2 N, si+1 2 √Ü(si).
For an RSM S, let L(S) = f 2  ÃÇ! j there is a run of KS on g.
3 Linear Temporal Logic of Calls and Returns
3.1 Syntax and Semantics
Let   = 2AP , where AP is a nite set of atomic propositions. Let the aug-
mented alphabet of   be  ÃÇ =    fcall ; ret ; intg. Let P denote the set AP [
fcall ; ret ; intg. The models of our logic are the words in  ÃÇ!.
The Propositional Linear Temporal Logic of Calls and Returns (CaRet) over
AP is the set of formulas dened by:
' := p j ' _ ' j :' j g' j 'Ug' j a' j 'Ua' j  ' j 'U '
where p 2 P .
For a word  2  ÃÇ!, we dene the semantics by inductively dening when
(; n) satises a formula ', where n 2 N. A word  satises ' i (; 0) satises
'.
For a word  over  ÃÇ , n 2 N, the semantics is dened as:
{ (; n) j= p i 0 = (X; d) and p 2 X or p = d (where p 2 P )
{ (; n) j= '1 _ '2 i (; n) j= '1 or (; n) j= '2
{ (; n) j= :' i (; n) 6j= '
{ (; n) j=g' i (; succg(n)) j= ', i.e., i (; n+ 1) j= '.
{ (; n) j=a' i succa(n) 6= ? and (; succ
a
(n)) j= '.
{ (; n) j= ' i succ  (n) 6= ? and (; succ
 
 (n)) j= '.
{ (; n) j= '1 U
b'2 (for any b 2 fg; a; g) i there is a sequence of positions
i0; i1; : : : ; ik, where i0 = n, (; ik) j= '2 and for every 0  j  k   1,
ij+1 = succ
b
(ij) and (; ij) j= '1.
The operators g and Ug are the usual global-next and global-until oper-
ators of LTL. The a and Ua operators are the abstract versions of the next
and until operators| a' demands that the abstract successor state satisfy '
while '1 U
a'2 demands that the abstract path from the current position (i.e.
the path formed by successive abstract successors) satisfy '1 U'2.
The formula  ' demands that the caller of the current position satises
' while '1 U
 '2 demands that the backward path of successive caller states
(which is always nite) satises '1 U'2.
As in standard linear temporal logic, we will use 3b' as an abbreviation for
True Ub', and 2b' for :3b:', for b 2 fa; g; g. While writing specications,
we will omit the superscript g as the global scope coincides with the classical
interpretation of temporal operators, and we will also use logical connectives
such as conjunction and implication freely.
Given an RSM S and a formula ' of CaRet, both over AP , dene S j= ' to
mean that for every  2 L(S),  j= '. We are ready to dene the model-checking
question we are interested in:
Model-checking problem:
Given an RSM S and a formula ' of CaRet, does S j= '?
Consider the RSM S, of Figure 1. Assume start = En1, then S j= 2g(d !
3
gz) because every global path starting at the vertex labelled d leads to the
entry of S2, which is labeled z (assuming there are no other vertices labeled
d). However, S 6j= 2g(d ! 3az) because abstract runs starting in S1 stay only
within S1 and do not go inside a box to visit the entry of S2, and hence do not
encounter the label z. Also note that S j= 2g(y ! t) because if we are at the
exit of the module S2, then the last call (which must exist because executions
begin in S1) must have occured from the call of box b2 (the only box labeled by
S2).
3.2 Specifying Requirements
Pre and Post Conditions: In the classical verication formalisms such as
Hoare logic, correctness of procedures is expressed using pre and post condi-
tions [15]. Partial correctness of a procedure A species that if the pre-condition
p holds when the procedure A is invoked, then if the procedure terminates, the
post-condition q is satised upon return. Total correctness, in addition, requires
the procedure to terminate. Assume that all calls to the procedure A are char-
acterized by the proposition pA. Then, the requirement
'total : 2 [ (call ^ p ^ pA) !aq ]
expresses the total correctness, while
'partial : 2 [ (call ^ p ^ pA) ! :a :q ]
expresses the partial correctness.
Boundedness: The number of unmatched calls at a position in a word corre-
sponds to the height of the stack at that position. The requirement that \every
call must return," or equivalently, \the stack should be empty innitely often",
is expressed by the specication
'empty : 2 ( call !aret )
A weaker requirement is that the stack should be repeatedly bounded, that is,
there exists a natural number n such that innitely often the stack is of height
at most n. These kinds of specications have been studied for pushdown games
[8]. This property can be specied in CaRet by the formula:
'rep-bounded : 32 ( call !aret )
Even though this specication does not rule out the possibility that the stack
grows unboundedly, an RSM S satises the requirement 'rep-bounded i there
exists a natural number n such that the number of pending calls at any position
is at most n. The boundedness requirement itself is not expressible in our logic.
Local Properties: The abstract path starting at a node inside a module A is
obtained by successive applications of a operator, and skips over invocations
of other modules called from A. CaRet formulas can specify properties of such
abstract paths. For example, if the proposition tA denotes that the control is
within a module A, then the formula
'local-response : 2 [(tA ^ p) ! 3aq ]
species the local version of the response property \every request p is followed
by a response q." In general, any LTL expressible local property can be specied
in CaRet.
Stack Inspection Properties: The caller path starting at a node inside a
module A is obtained by successive applications of   operator, and encodes
the stack at that position. As shown in [18, 13], stack inspection can specify a
variety of security properties. For instance, the requirement that a module A
should be invoked only within the context of a module B, with no intervening
call to an overriding module C, is expressed by the formula
'stack : 2 (call ^ pA ! (:pC)U
 pB ):
In general, any property that can be formulated as a star-free regular property
of the stack content can be expressed in CaRet. For example, when a critical
procedure is invoked, one can require that all the procedures in the call stack
have the necessary privilege. We refer the reader to [18, 13] for the relevance
of such specications for capturing security domains, authority delegation, and
stack inspection policies in modern programming languages such as Java. Since
CaRet can state properties of the stack as well as the global evolution, it
can express dynamic security policy constraints, where the permissions change
depending upon what privileges have been used thus far (see [18] where such
constraints are motivated but cannot be expressed in their logic).
It is worth noting that CaRet allows nesting of dierent types of modalities.
The requirement that a temporal property ' holds when the current module re-
turns is expressed by the formula
'upon-return :  a '
This property is not expressible in existing approaches such as augmenting LTL
with regular stack valuations [13].
Interrupt-driven sequences: Interrupt-driven software are prevalent in the
embedded software domain where the stack-size is very limited. In this setting,
while the system is handling an interrupt, the same interrupt could occur, caus-
ing the stack to get large. Estimating the maximum stack content is thus a
relevant question (see for example [9]). The property that states that \in com-
putations where an interrupt is not interrupted by itself, the formula ' holds"
can be expressed in CaRet as:
'no-rec-int : 2 ((call ^ pint)! :  3 pint)! '
We can also write CaRet formulas that are true only where the stack depth
reaches n, for some constant n.
RSM Encoding: Our logic is rich enough to encode the computations of an
RSM in a manner similar to the encoding of nite-state machines in LTL. For an
RSM S, we write the formula 'S by introducing a proposition for every vertex of
S and ensuring local rules of the evolution of S using the global-next modalities.
To ensure that a call at (b; e) returns to some return of the form (b; x), we can
assert the following: whenever p(b;e) holds (where p(b;e) is the proposition for
(b; e)), either :a true holds or for precisely one return of the form (b; x), both
ap(b;x) and 
g
3
apx hold. Then for any S, 'S is such that for any formula ',
S j= ' i 'S ! ' is valid.
It is worth noting that if S and S0 are RSMs (or pushdown automata) then
'S ^ 'S0 does not represent the intersection of their languages in the usual
sense due to the shared call and ret tags; it represents the synchronized product
where the two are required to synchronize on when to call (i.e. push) and when
to return (i.e. pop).
4 Model checking
In this section we show how to solve the model checking problem for RSMs
against CaRet specications. We rst dene the notion of recursive generalized
Buchi automata which our decision procedure will use.
4.1 Recursive Generalized Buchi Automata
Our automata-based algorithms will use RSMs augmented with acceptance con-
ditions: both ordinary and generalized Buchi conditions. A recursive generalized
Buchi automaton (RGBA) S = (M; fSmgm2M ; start;F) consists of an RSM to-
gether with a family F = fF1; : : : ; Frg of accepting sets of vertices of S where
Fj  V , for j 2 f1; : : : ; rg. When there is only one accepting set, F = fFg, we
have a Recursive Buchi Automaton (RBA).
For an RGBA S, the acceptance condition F = fF1; : : : ; Frg, induces an
acceptance condition on the Kripke structure KS : F# = fF
#
1 ; : : : ; F
#
r g, where
F#i = f(; u) 2 Q j u 2 Fig. We say a run  of KS is an accepting run i for
all F 2 F , for innitely many i 2 N, si 2 F#. For an RGBA S, let L(S) =
f 2  ÃÇ! j there is an accepting run of KS on g. Note that when there is no
acceptance condition, i.e., when F is the empty set, every run is accepting, and
thus such RGBAs correspond to ordinary RSMs.
An important parameter of the size of an RSM S, introduced in [1], is S =
maxm2M minfjEnmj; jExmjg, that is, each module has at most S entries or
S exits. It was shown in [1] that reachability analysis for RSMs and language
emptiness for RBAs can be performed in time O(jSj2S) and space O(jSjS).
This construction can be generalized to obtain the following:
Proposition 1. Given an RGBA S, with acceptance condition F =
fF1; : : : ; Frg, checking L(S) = ; can be solved in time O(rjSj2S) and space
O(rjSjS).
To see why the proposition holds, let us recall the algorithm of [1] for the
analysis of RBAs with one acceptance condition F . That algorithm proceeds
in two phases. In the rst phase, for each component Sm, we compute for ev-
ery entry en and every exit ex of Sm whether there is a path from (; en) to
(; ex) in the global Kripke structure KS , and if so, whether there is a path that
goes through an accepting state in F#. This involves solving reachability in an
And-Or graph and takes time O(jSj2S) and space O(jSjS). We then augment
the RSM with \summary edges" between calls and returns of boxes, to indicate
reachability from entries to exits, and we label these summary edges as \accept-
ing edges" if it is possible to get from the entry to the exit via an accepting
state. In addition, we also add edges from a call to the corresponding entry of
the component that labels the call's box. Once all these edges are added, we are
left with an ordinary (at) Buchi automaton of size O(jSjS), in which we must
detect the existence of a reachable accepting cycle (which we can in linear time).
To generalize this construction to RGBAs with acceptance condition F =
fF1; : : : ; Frg, we rst observe that we can do the rst phase of \summary edge"
calculation separately with respect to every accepting set Fi 2 F . We then
label each summary edge from a call to a return with the set C  f1; : : : ; rg of
\colors" corresponding to those accepting sets which can be visited on some path
from the respective entry to the exit. The computation takes time O(rjSj2S),
and the resulting at generalized Buchi automaton H has O(jSjS) edges, but
summary edges can each be labeled with O(r) colors. To check that L(H) = ;,
we can use a slightly modied version of the standard algorithm for conversion of
the generalized Buchi automaton H to a Buchi automaton, to produce a Buchi
automaton H 0 of size O(rjSjS) that accepts the same language as H . We then
run a linear time emptiness test on this Buchi automaton.
4.2 The Decision Procedure
The main construction here will show how to build, for any RSM S and a formula
' over AP , a recursive generalized Buchi automata (RGBA) that accepts exactly
the set of words in L(S) that satisfy '. For simplifying the proof, we assume
without loss of generality that in the RSMs we consider, entries have no incoming
transitions, exits have no outgoing transitions and there are no transitions from
returns to calls nor exits.
Let ' be a formula over AP . The closure of ', Cl('), is the smallest set that
contains ', contains call , ret and int , and satises the following properties:
{ If :'0 2 Cl(') or b'0 2 Cl(') (for some b 2 fg; a; g), then '0 2 Cl(').
{ If '0 _ '00 2 Cl('), then '0; '00 2 Cl(').
{ If '0 Ub'00 2 Cl('), where b 2 fg; a; g, then '0, '00, and b('0 U b'00) are
in Cl(').
{ If '0 2 Cl(') and '0 is not of the form :'00 (for any '00), then :'0 2 Cl(').
It is straightforward to see that the size of Cl(') is only linear in the size of
'. Henceforth, we identify ::' with the formula '.
An atom of ' is a set Y  Cl(') that satises the following properties:
{ For every '0 2 Cl('), '0 2 Y i :'0 62 Y .
{ For every formula '0 _ '00 2 Cl('), '0 _ '00 2 Y i ('0 2 Y or '00 2 Y ).
{ For every formula '0 U b'00 2 Cl('), where b 2 fa; g; g, '0 U b'00 2 Y i
either '00 2 Y or ('0 2 Y and b('0 Ub'00) 2 Y ).
{ Y contains exactly one of the elements in the set fcall ; ret ; intg.
Let Atoms(') denote the set of atoms of '; note that there are 2O(j'j) atoms
of '. To handle formulas in LTL, we can build a pushdown automaton whose
states are of the form (u;A), where u is the current node of the RSM that is
being simulated and A is an atom that represents the set of formulas true at
u. We can use the stack for storing the names of the boxes, pushing in the box
name at a call and popping it at the return.
The main dierence in the construction for CaRet formulas is that at a call,
the atom A true at the call is also pushed onto the stack along with the box b.
When the call returns, we pop b and A and make sure that the abstract-next
requirements in A get satised at the return-node. Note that we cannot keep
track of A using the nite-state control because recursive calls will make the set
of atoms to be remembered unbounded.
The caller modality is easier to handle. If we are at a call (b; e) where the set
of formulas A is true, then a formula  '0 is true in the module being called
only if '0 2 A. The caller formulas are hence passed down from the caller to the
called module. The above two ideas are the crux of the construction.
There are several other technical issues to be handled. When an until-formula
'1 U
b'2 is asserted at a node, we must make sure the liveness requirement '2 is
eventually satised. This is done (as for LTL) using a generalized Buchi condi-
tion, one for each until formula. Caller-until formulas do not even require such
a condition as the caller-path from any node is nite.
If an abstract-until formula '1 U
a'2 is asserted at a node u in a module, its
liveness requirement '2 must be met in the abstract path from u and not in a
node belonging to an invocation from the current module. In order to handle
this we also keep track in the state whether the current node belongs to an
invocation that will eventually return or not. For an abstract-until formula, the
Buchi condition corresponding it has only states that correspond to invocations
that do not return.
Let us now describe the construction formally. Let the given RSM be
(M; fSmgm2M ; start). Let M 0 = fm0 j m 2 Mg be a new set of module names,
one for each module m 2 M . The recursive generalized Buchi automaton we
construct is (M 0; fSm0gm2M 0 ; start0;F) which is dened below.
Let Tag = finf ;ng. For every node u 2 Nm that is not an exit there are
nodes of the form (u;A; t) in Sm0 , where A is an atom that represents the set
of formulas that hold at u and t 2 Tag is a tag that signies whether the run
in the current module is innite (inf {will never exit) or is nite (n{will exit
eventually). Similarly, for every b 2 Bm, there are boxes of the form (b; A; t) in
Sm0 where t is a tag and A is an atom containing formulas true at entries (b; e).
For any vertex v of S, we say an atom A is propositionally consistent with v
if (v) \ AP = A \ AP and, further, if v is a node, then int 2 A, if v is a call,
then call 2 A and if v is a return then ret 2 A.
For every m 2 M , if Sm = (Nm; Bm; Ym;Enm;Exm; √Üm; m), then S0m =
(Nm0 ; Bm0 ; Ym0 ;Enm0 ;Exm0 ; √Üm0 ; m0) where
{ Nm0 = f (u;A; t) j u 2 Nm n Exm; A 2 Atoms('); t 2 Tag and A is
propositionally consistent with u g [
f (x;A;R) j x 2 Exm; A;R 2 Atoms('); and A is propositionally
consistent with x g
{ Bm0 = Bm Atoms(') Tag ; Ym0(b; A; t) = (Ym(b))0
{ Enm0 = f(e; A; t) j e 2 Enm; A 2 Atoms('); t 2 Tagg
{ Exm0 = f(x;A;R) j x 2 Exm; A;R 2 Atoms(')g
{ m0((u;A; t)) = m(u), m0(((b; A; t); (e; A
0; t0))) = m((b; e)), and
m0(((b; A; t); (x;A
0; R))) = m((b; x))
Notice that calls are of the form ((b; A; t); (e; A0; t0)). In this A is the set of
formulas true at this call and A0 is the set of formulas true at the next vertex
which will be the entry e. Hence, since the box-name (b; A; t) is pushed on the
stack, the formulas A true at the call is remembered across the invocation.
Exits are of the form (x;A;R); here A denotes the formulas that are true at
the exit x while R denotes the formulas true when the control returns to the
called module. At a return ((b; A; t); (x;A0; R)), since the set of formulas true at
the call was A and the set of formulas true at return is R, we will require that
the abstract-next requirements in A are met in R.
For atoms A and A0, we dene a relation AbsNextReq(A;A0) that is true i
the abstract-next requirements in A are exactly the ones that hold in A0, i.e.
for each a'0 2 Cl('), a'0 2 A i '0 2 A0. Similarly, we dene a relation
GlNextReq(A;A0) that is true i the global-next requirements in A are exactly
the ones that hold in A0, i.e. for each g'0 2 Cl('), g'0 2 A i '0 2 A0.
Also, let the caller formulas in A be denoted by CallerFormulas(A) =
f '0 j  '0 2 Ag. The transition relation √Üm0 is dened as follows:
(T1) From nodes to non-exit nodes: √Üm0((u;A; t)) contains (u
0; A0; t0) i:
{ u0 2 √Üm(u); t = t0
{ GlNextReq(A;A0) and AbsNextReq(A;A0)
{ CallerFormulas(A) = CallerFormulas(A0)
(T2) From nodes to calls: √Üm0((u;A; t)) contains ((b; A
0; t0); (e; A00; t00)) i:
{ (b; e) 2 √Üm(u); t0 = t
{ A0 is propositionally consistent with (b; e).
{ GlNextReq(A;A0) and AbsNextReq(A;A0)
{ CallerFormulas(A) = CallerFormulas(A0)
{ GlNextReq(A0; A00); CallerFormulas(A00) = f '0 2 Cl (') j '0 2 A0g
{ If t00 = inf , then t = inf and there is no formula of the kind a' in A0.
(T3) From nodes to exits:
√Üm0((u;A; t)) contains (x;A
0; R), where x 2 Exm, i:
{ x 2 √Üm(u); t = n
{ GlNextReq(A;A0); AbsNextReq(A;A0); GlNextReq(A0; R)
{ CallerFormulas(A) = CallerFormulas(A0)
{ There is no formula of the kind a' in A0.
(T4) From returns to nodes: √Üm0((b; A; t); (x;A
0; R)) contains (u;A00; t00) i
{ u 2 √Üm((b; x)); t00 = t
{ AbsNextReq(A;R); CallerFormulas(A) = CallerFormulas(R)
{ R is propositionally consistent with (b; x).
{ GlNextReq(R;A00) and AbsNextReq(R;A00)
{ CallerFormulas(R) = CallerFormulas(A00)
The set of initial nodes is the set start0 = f(u;A; t) j u 2 start; ' 2 A;A does not
contain any formulas of the form   '0; t = inf g.
We say an atom A momentarily satises an abstract or global until formula
'1 U
b'2 (where b = g or b = a) if either '2 2 A or '1 U
b'2 62 A.
The generalized Buchi condition F is given by the following sets:
{ A set containing all vertices of the form (u;A; t), where t = inf .
{ For every global-until formula '1 U
g'2 in Cl('), there is a set in F contain-
ing all vertices of the form (u;A; t) or (x;A;R) or ((b; A; t; R); (e; A0; t0)) or
((b; A0; t; A); (x;A00; A)) where A momentarily satises '1 U
g'2.
{ For every abstract-until formula '1 U
a'2 in Cl('), there is a set in
F containing all vertices of the form (u;A; t), ((b; A; t; R); (e; A0; t0)) or
((b; A0; t; A); (x;A00; A)) where A momentarily satises '1 U
a'2 and t = inf .
The rst set ensures that the tags were guessed correctly. The second class
of states ensure that global-until formulas get satised eventually. For abstract-
until formulas that get asserted at nodes where the abstract-path is innite, the
third class of sets ensure that they get eventually satised. Hence:
Theorem 1. Given an RSM S and a formula ', the model-checking problem
for S against ' can be solved in time jSj  2S  2
O(j'j), i.e., in time polynomial in
S and exponential in the size of the formula. The problem is Exptime-complete
(even when the RSM is xed).
Proof: Given RSM S and a formula ', construct the RGBA S:' for the RSM
S and the negation of the formula '. This RGBA generates exactly the runs of
S that do not satisfy '. Note that for every vertex/edge in S, we have 2O(j'j)
vertices/edges in the RGBA; similarly S:' is S  2
O(j'j). Also, the number of
generalized Buchi sets is at most j'j+1. By Proposition 1, the complexity follows
and the problem is in Exptime. It is known that checking RSMs against LTL is
already Exptime-hard, even when the RSM is xed (this follows from the proof
in [5]). Hence the problem is Exptime-complete. ut
5 Conclusions
We have proposed a notion of structured computations that abstractly captures
reactive computations with nested calls and returns of program modules. We
have introduced a temporal logic that allows specication of requirements of
such computations, and a decision procedure to model check such specications
with respect to recursive state machines. This leads to a rich and unied frame-
work for algorithmic reasoning about temporal requirements, stack inspection
properties, and classical correctness requirements of structured programs. While
our technical focus has been on model checking, CaRet can be used in other
applications such as simulation and runtime monitoring where LTL has been
established to be fruitful.
The temporal modalities presented in this paper are natural for structured
computations, but are not exhaustive. For example, one can dene global-
predecessor , abstract-predecessor , and next-return as the temporal duals of
the global-successor, abstract-successor, and last-caller modalities, respectively.
These can be added to the logic at no extra cost. On the other hand, consider
the within modality I : I' holds at a call position i i the computation frag-
ment from position i to j, where j is the matching return, satises the temporal
formula '. Adding this modality raises the complexity of model checking to 2Ex-
ptime. A related question concerns the expressive completeness of the logic. We
are currently studying the problem of characterizing the subclass of context-free
properties that can be algorithmically checked against an RSM model.
Acknowledgement: We thank Mihalis Yannakakis for fruitful discussions.
References
1. R. Alur, K. Etessami, and M. Yannakakis. Analysis of recursive state machines.
In Proc. of CAV'01, LNCS 2102, pages 207{220. Springer, 2001.
2. T. Ball and S. Rajamani. Bebop: A symbolic model checker for boolean programs.
SPIN Workshop on Model Checking of Software, LNCS 1885, pages 113{130, 2000.
3. M. Benedikt, P. Godefroid, and T. Reps. Model checking of unrestricted hierar-
chical state machines. In Proc. ICALP, volume LNCS 2076, pages 652{666. 2001.
4. A. Bouajjani, R. Echahed, and P. Habermehl. On the verication problem of
nonregular properties for nonregular processes. In Proc., 10th Annual IEEE Symp.
on Logic in Computer Science, pages 123{133. IEEE, 1995.
5. A. Bouajjani, J. Esparza, and O. Maler. Reachability analysis of pushdown au-
tomata: Applications to model checking. In CONCUR'97: Concurrency Theory,
Eighth International Conference, LNCS 1243, pages 135{150. Springer, 1997.
6. L. Burdy, Y. Cheon, D. Cok, M. Ernst, J. Kiniry, G.T. Leavens, R. Leino, and
E. Poll. An overview of JML tools and applications. In Proc. 8th International
Workshop on Formal Methods for Industrial Critical Systems, pages 75{89, 2003.
7. O. Burkart and B. Steen. Model checking for context-free processes. In CON-
CUR'92: Concurrency Theory, LNCS 630, pages 123{137. Springer, 1992.
8. T. Cachat, J. Duparc, andW. Thomas. Solving pushdown games with a3 winning
condition. In Proc. of CSL 2002, LNCS 2471, 322-336. Springer, 2002.
9. K. Chatterjee, D. Ma, R. Majumdar, T. Zhao, T.A. Henzinger, and J. Palsberg.
Stack size analysis for interrupt driven programs. In Proceedings of the 10th Inter-
national Symposium on Static Analysis, volume LNCS 2694, pages 109{126, 2003.
10. H. Chen and D. Wagner. Mops: an infrastructure for examining security properties
of software. In Proceedings of ACM Conference on Computer and Communications
Security, pages 235{244, 2002.
11. E.M. Clarke and E.A. Emerson. Design and synthesis of synchronization skeletons
using branching time temporal logic. In Proc. Workshop on Logic of Programs,
LNCS 131, pages 52{71. Springer-Verlag, 1981.
12. J. Esparza, D. Hansel, P. Rossmanith, and S. Schwoon. E√Ücient algorithms for
model checking pushdown systems. In Computer Aided Verication, 12th Interna-
tional Conference, LNCS 1855, pages 232{247. Springer, 2000.
13. J. Esparza, A. Kucera, and S. S. Schwoon. Model-checking LTL with regular
valuations for pushdown systems. Information and Computation, 186(2):355{376,
2003.
14. D. Harel, D. Kozen and J. Tiuryn. Dynamic Logic. MIT Press, 2000.
15. C.A.R. Hoare. An axiomatic basis for computer programming. Communications
of the ACM, 12(10):576{580, 1969.
16. G.J. Holzmann. The model checker SPIN. IEEE Transactions on Software Engi-
neering, 23(5):279{295, 1997.
17. J.E. Hopcroft and J.D. Ullman. Introduction to Automata Theory, Languages, and
Computation. Addison-Wesley, 1979.
18. T. Jensen, D. Le Metayer, and T. Thorn. Verication of control ow based security
properties. In Proc. of the IEEE Symp. on Security and Privacy, 89{103, 1999.
19. O. Kupferman, N. Piterman, and M.Y. Vardi. Pushdown Specications. In Proc.
of LPAR 02, LNCS 2514, pages 262{277. Springer, 2002.
20. O. Kupferman, N. Piterman, and M.Y. Vardi. Model checking linear properties of
prex-recognizable systems. In Proc. of CAV 02, LNCS 2404, 371{385, 2002.
21. O. Lichtenstein and A. Pnueli. Checking that nite-state concurrent programs
satisfy their linear specication. In Proc., 12th ACM POPL, pages 97{107, 1985.
22. Z. Manna and A. Pnueli. The temporal logic of reactive and concurrent systems:
Specication. Springer-verlag, 1991.
23. A. Pnueli. The temporal logic of programs. In Proceedings of the 18th IEEE
Symposium on Foundations of Computer Science, pages 46{77, 1977.
24. T. Reps, S. Horwitz, and S. Sagiv. Precise interprocedural dataow analysis via
graph reachability. In Proc. ACM POPL, pages 49{61, 1995.

